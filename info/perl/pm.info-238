This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Math/Cephes/Complex,  Next: Math/Cephes/Fraction,  Prev: Math/Cephes,  Up: Module List

Perl interface to the cephes complex number routines
****************************************************

NAME
====

     Math::Cephes::Complex - Perl interface to the cephes complex number routines

SYNOPSIS
========

     use Math::Cephes::Complex qw(cmplx);
     my $z1 = cmplx(2,3);          # $z1 = 2 + 3 i
     my $z2 = cmplx(3,4);          # $z2 = 3 + 4 i
     my $z3 = $z1->radd($z2);      # $z3 = $z1 + $z2

DESCRIPTION
===========

     This module is a layer on top of the basic routines in the
     cephes math library to handle complex numbers. A complex
     number is created via any of the following syntaxes:

     my $f = Math::Cephes::Complex->new(3, 2);   # $f = 3 + 2 i
     my $g = new Math::Cephes::Complex(5, 3);    # $g = 5 + 3 i
     my $h = cmplx(7, 5);                        # $h = 7 + 5 i

     the last one being available by importing I<cmplx>. If no arguments
     are specified, as in

     my $h = cmplx();

     then the defaults $z = 0 + 0 i are assumed. The real and imaginary
     part of a complex number are represented respectively by

     $f->{r}; $f->{i}

     and can be set according to

     $f->{i} = 4; $f->{i} = 9;

     The complex number can be printed out as

     print $f->as_string;

     A summary of the usage is as follows.

*csin*: Complex circular sine
          SYNOPSIS:

          # void csin();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->csin;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          If
              z = x + iy,

          then

          w = sin x  cosh y  +  i cos x sinh y.

*ccos*: Complex circular cosine
          SYNOPSIS:

          # void ccos();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->ccos;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          If
              z = x + iy,

          then

          w = cos x  cosh y  -  i sin x sinh y.

*ctan*: Complex circular tangent
          SYNOPSIS:

          # void ctan();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->ctan;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          If
              z = x + iy,

          then

          sin 2x  +  i sinh 2y
               w  =  --------------------.
           cos 2x  +  cosh 2y

          On the real axis the denominator is zero at odd multiples
          of PI/2.  The denominator is evaluated by its Taylor
          series near these points.

*ccot*: Complex circular cotangent
          SYNOPSIS:

          # void ccot();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->ccot;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          If
              z = x + iy,

          then

          sin 2x  -  i sinh 2y
               w  =  --------------------.
           cosh 2y  -  cos 2x

          On the real axis, the denominator has zeros at even
          multiples of PI/2.  Near these points it is evaluated
          by a Taylor series.

*casin*: Complex circular arc sine
          SYNOPSIS:

          # void casin();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->casin;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          Inverse complex sine:

          2
           w = -i clog( iz + csqrt( 1 - z ) ).

*cacos*: Complex circular arc cosine
          SYNOPSIS:

          # void cacos();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->cacos;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          w = arccos z  =  PI/2 - arcsin z.

*catan*: Complex circular arc tangent
          SYNOPSIS:

          # void catan();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->catan;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          If
              z = x + iy,

          then
                   1       (    2x     )
          Re w  =  - arctan(-----------)  +  k PI
                   2       (     2    2)
                           (1 - x  - y )

          ( 2         2)
                    1    (x  +  (y+1) )
           Im w  =  - log(------------)
                    4    ( 2         2)
          (x  +  (y-1) )

          Where k is an arbitrary integer.

*csinh*: Complex hyperbolic sine
          SYNOPSIS:
          
          # void csinh();
          # cmplx z, w;
          
           $z = cmplx(2, 3);    # $z = 2 + 3 i
           $w = $z->csinh;
           print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
           print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:
          csinh z = (cexp(z) - cexp(-z))/2
                    = sinh x * cos y  +  i cosh x * sin y .

*casinh*: Complex inverse hyperbolic sine
          SYNOPSIS:
          
          # void casinh();
          # cmplx z, w;
          
           $z = cmplx(2, 3);    # $z = 2 + 3 i
           $w = $z->casinh;
           print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
           print $w->as_string;           # prints $w as Re($w) + i Im($w)
          
          DESCRIPTION:
          
          casinh z = -i casin iz .

*ccosh*: Complex hyperbolic cosine
          SYNOPSIS:
          
          # void ccosh();
          # cmplx z, w;
          
           $z = cmplx(2, 3);    # $z = 2 + 3 i
           $w = $z->ccosh;
           print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
           print $w->as_string;           # prints $w as Re($w) + i Im($w)
          
          DESCRIPTION:
          
          ccosh(z) = cosh x  cos y + i sinh x sin y .

*cacosh*: Complex inverse hyperbolic cosine
          SYNOPSIS:
          # void cacosh();
            # cmplx z, w;
          
           $z = cmplx(2, 3);    # $z = 2 + 3 i
           $w = $z->cacosh;
           print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
           print $w->as_string;           # prints $w as Re($w) + i Im($w)
          DESCRIPTION:
          acosh z = i acos z .

*ctanh*: Complex hyperbolic tangent
          SYNOPSIS:

          # void ctanh();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->ctanh;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          tanh z = (sinh 2x  +  i sin 2y) / (cosh 2x + cos 2y) .

*catanh*: Complex inverse hyperbolic tangent
          SYNOPSIS:
          
          # void catanh();
          # cmplx z, w;
          
           $z = cmplx(2, 3);    # $z = 2 + 3 i
           $w = $z->catanh;
           print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
           print $w->as_string;           # prints $w as Re($w) + i Im($w)
          
          DESCRIPTION:
          
          Inverse tanh, equal to  -i catan (iz);

*cpow*: Complex power function
          SYNOPSIS:
          
          # void cpow();
          # cmplx a, z, w;
          
           $a = cmplx(5, 6);    # $z = 5 + 6 i
           $z = cmplx(2, 3);    # $z = 2 + 3 i
           $w = $a->cpow($z);
           print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
           print $w->as_string;           # prints $w as Re($w) + i Im($w)
          
          DESCRIPTION:
          
          Raises complex A to the complex Zth power.
          Definition is per AMS55 # 4.2.8,
          analytically equivalent to cpow(a,z) = cexp(z clog(a)).

*cmplx*: Complex number arithmetic
          SYNOPSIS:

          # typedef struct {
          #     double r;     real part
          #     double i;     imaginary part
          #    }cmplx;

          # cmplx *a, *b, *c;

          $a = cmplx(3, 5);   # $a = 3 + 5 i
          $b = cmplx(2, 3);   # $b = 2 + 3 i

          $c = $a->cadd( $b );  #   c = a + b
          $c = $a->csub( $b );  #   c = a - b
          $c = $a->cmul( $b );  #   c = a * b
          $c = $a->cdiv( $b );  #   c = a / b
          $c = $a->cneg;        #   c = -a
          $c = $a->cmov;        #   c = a

          print $c->{r}, '  ', $c->{i};   # prints real and imaginary parts of $c
          print $c->as_string;           # prints $c as Re($c) + i Im($c)

          DESCRIPTION:

          Addition:
             c.r  =  b.r + a.r
             c.i  =  b.i + a.i

          Subtraction:
             c.r  =  b.r - a.r
             c.i  =  b.i - a.i

          Multiplication:
             c.r  =  b.r * a.r  -  b.i * a.i
             c.i  =  b.r * a.i  +  b.i * a.r

          Division:
             d    =  a.r * a.r  +  a.i * a.i
             c.r  = (b.r * a.r  + b.i * a.i)/d
             c.i  = (b.i * a.r  -  b.r * a.i)/d

*cabs*: Complex absolute value
          SYNOPSIS:

          # double a, cabs();
          # cmplx z;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $a = cabs( $z );

          DESCRIPTION:

          If z = x + iy

          then

          a = sqrt( x**2 + y**2 ).
          
           Overflow and underflow are avoided by testing the magnitudes
           of x and y before squaring.  If either is outside half of
           the floating point full scale range, both are rescaled.

*csqrt*: Complex square root
          SYNOPSIS:

          # void csqrt();
          # cmplx z, w;

          $z = cmplx(2, 3);    # $z = 2 + 3 i
          $w = $z->csqrt;
          print $w->{r}, '  ', $w->{i};  # prints real and imaginary parts of $w
          print $w->as_string;           # prints $w as Re($w) + i Im($w)

          DESCRIPTION:

          If z = x + iy,  r = |z|, then

          1/2
           Im w  =  [ (r - x)/2 ]   ,

          Re w  =  y / 2 Im w.

          Note that -w is also a square root of z.  The root chosen
          is always in the upper half plane.

          Because of the potential for cancellation error in r - x,
          the result is sharpened by doing a Heron iteration
          (see sqrt.c) in complex arithmetic.

TODO
====

   * Integrate the C routines with Math::Complex.

BUGS
====

     Please report any to Randy Kobes <randy@theoryx5.uwinnipeg.ca>

SEE ALSO
========

   For the basic interface to the cephes complex number routines, see
*Note Math/Cephes: Math/Cephes,. See also *Note Math/Complex: Math/Complex,
for a more extensive interface to complex number routines.

COPYRIGHT
=========

   The C code for the Cephes Math Library is Copyright 1984, 1987, 1989 by
Stephen L. Moshier, and is available at http://www.netlib.org/cephes/.
Direct inquiries to 30 Frost Street, Cambridge, MA 02140.

   The perl interface is copyright 2000 by Randy Kobes.  This library is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Math/Cephes/Fraction,  Next: Math/Complex,  Prev: Math/Cephes/Complex,  Up: Module List

Perl interface to the cephes math fraction routines
***************************************************

NAME
====

     Math::Cephes::Fraction - Perl interface to the cephes math fraction routines

SYNOPSIS
========

     use Math::Cephes::Fraction qw(fract);
     my $f1 = fract(2,3);          # $f1 = 2/3
     my $f2 = fract(3,4);          # $f2 = 3/4
     my $f3 = $f1->radd($f2);      # $f3 = $f1 + $f2

DESCRIPTION
===========

     This module is a layer on top of the basic routines in the
     cephes math library to handle fractions. A fraction object
     is created via any of the following syntaxes:

     my $f = Math::Cephes::Fraction->new(3, 2);  # $f = 3/2
     my $g = new Math::Cephes::Fraction(5, 3);   # $g = 5/3
     my $h = fract(7, 5);                        # $h = 7/5

     the last one being available by importing I<:fract>. If no arguments
     are specified, as in

     my $h = fract();

     then the defaults $z = 0/1 are assumed. The numerator and
     denominator of a fraction are represented respectively by

     $f->{n}; $f->{d}

     and can be set according to

     $f->{n} = 4; $f->{d} = 9;

     The fraction can be printed out as

     print $f->as_string;

     or as a mixed fraction as

     print $f->as_mixed_string;

     These routines reduce the fraction to its basic form before printing.
     This uses the I<euclid> routine which finds the greatest common
     divisor of two numbers, as follows:

     ($gcd, $m_reduced, $n_reduced) = euclid($m, $n);

     which returns the greatest common divisor of $m and $n, as well as
     the result of reducing $m and $n by $gcd

     A summary of the basic routines is as follows.

     $x = fract(3, 4);	 #  x = 3 / 4
     $y = fract(2, 3);       #  y = 2 / 3
     $z = $x->radd( $y );    #  z = x + y
     $z = $x->rsub( $y );    #  z = x - y
     $z = $x->rmul( $y );    #  z = x * y
     $z = $x->rdiv( $y );    #  z = x / y
     print $z->{n}, ' ', $z->{d};  # prints numerator and denominator of $z
     print $z->as_string;         # prints the fraction $z
     print $z->as_mixed_string;   # converts $z to a mixed fraction, then prints it
     
     $m = 60;
     $n = 144;
     ($gcd, $m_reduced, $n_reduced) = euclid($m, $n);

TODO
====

   * Integrate the C routines with the `Math::Fraction' module.

BUGS
====

     Please report any to Randy Kobes <randy@theoryx5.uwinnipeg.ca>

SEE ALSO
========

   For the basic interface to the cephes fraction routines, see *Note
Math/Cephes: Math/Cephes,. See also *Note Math/Fraction: Math/Fraction,
for a more extensive interface to fraction routines.

COPYRIGHT
=========

   The C code for the Cephes Math Library is Copyright 1984, 1987, 1989 by
Stephen L. Moshier, and is available at http://www.netlib.org/cephes/.
Direct inquiries to 30 Frost Street, Cambridge, MA 02140.

   The perl interface is copyright 2000 by Randy Kobes.  This library is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Math/Complex,  Next: Math/Currency,  Prev: Math/Cephes/Fraction,  Up: Module List

   Math::Complex - complex numbers and associated mathematical functions

SYNOPSIS
========

     use Math::Complex;

     $z = Math::Complex->make(5, 6);
     $t = 4 - 3*i + $z;
     $j = cplxe(1, 2*pi/3);

DESCRIPTION
===========

   This package lets you create and manipulate complex numbers. By default,
Perl limits itself to real numbers, but an extra use statement brings full
complex support, along with a full set of mathematical functions typically
associated with and/or extended to complex numbers.

   If you wonder what complex numbers are, they were invented to be able
to solve the following equation:

     x*x = -1

   and by definition, the solution is noted i (engineers use *j* instead
since i usually denotes an intensity, but the name does not matter). The
number i is a pure *imaginary* number.

   The arithmetics with pure imaginary numbers works just like you would
expect it with real numbers... you just have to remember that

     i*i = -1

   so you have:

     5i + 7i = i * (5 + 7) = 12i
     4i - 3i = i * (4 - 3) = i
     4i * 2i = -8
     6i / 2i = 3
     1 / i = -i

   Complex numbers are numbers that have both a real part and an imaginary
part, and are usually noted:

     a + bi

   where a is the real part and b is the *imaginary* part. The arithmetic
with complex numbers is straightforward. You have to keep track of the
real and the imaginary parts, but otherwise the rules used for real
numbers just apply:

     (4 + 3i) + (5 - 2i) = (4 + 5) + i(3 - 2) = 9 + i
     (2 + i) * (4 - i) = 2*4 + 4i -2i -i*i = 8 + 2i + 1 = 9 + 2i

   A graphical representation of complex numbers is possible in a plane
(also called the *complex plane*, but it's really a 2D plane).  The number

     z = a + bi

   is the point whose coordinates are (a, b). Actually, it would be the
vector originating from (0, 0) to (a, b). It follows that the addition of
two complex numbers is a vectorial addition.

   Since there is a bijection between a point in the 2D plane and a complex
number (i.e. the mapping is unique and reciprocal), a complex number can
also be uniquely identified with polar coordinates:

     [rho, theta]

   where `rho' is the distance to the origin, and `theta' the angle between
the vector and the x axis. There is a notation for this using the
exponential form, which is:

     rho * exp(i * theta)

   where i is the famous imaginary number introduced above. Conversion
between this form and the cartesian form `a + bi' is immediate:

     a = rho * cos(theta)
     b = rho * sin(theta)

   which is also expressed by this formula:

     z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)

   In other words, it's the projection of the vector onto the x and y
axes. Mathematicians call *rho* the norm or *modulus* and *theta* the
argument of the complex number. The norm of z will be noted `abs(z)'.

   The polar notation (also known as the trigonometric representation) is
much more handy for performing multiplications and divisions of complex
numbers, whilst the cartesian notation is better suited for additions and
subtractions. Real numbers are on the x axis, and therefore *theta* is
zero or pi.

   All the common operations that can be performed on a real number have
been defined to work on complex numbers as well, and are merely
*extensions* of the operations defined on real numbers. This means they
keep their natural meaning when there is no imaginary part, provided the
number is within their definition set.

   For instance, the sqrt routine which computes the square root of its
argument is only defined for non-negative real numbers and yields a
non-negative real number (it is an application from *R+* to *R+*).  If we
allow it to return a complex number, then it can be extended to negative
real numbers to become an application from R to C (the set of complex
numbers):

     sqrt(x) = x >= 0 ? sqrt(x) : sqrt(-x)*i

   It can also be extended to be an application from C to C, whilst its
restriction to R behaves as defined above by using the following
definition:

     sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)

   Indeed, a negative real number can be noted `[x,pi]' (the modulus x is
always non-negative, so `[x,pi]' is really -x, a negative number) and the
above definition states that

     sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i

   which is exactly what we had defined for negative real numbers above.
The sqrt returns only one of the solutions: if you want the both, use the
root function.

   All the common mathematical functions defined on real numbers that are
extended to complex numbers share that same property of working *as usual*
when the imaginary part is zero (otherwise, it would not be called an
extension, would it?).

   A new operation possible on a complex number that is the identity for
real numbers is called the *conjugate*, and is noted with an horizontal
bar above the number, or `~z' here.

     z = a + bi
     	~z = a - bi

   Simple... Now look:

     z * ~z = (a + bi) * (a - bi) = a*a + b*b

   We saw that the norm of z was noted `abs(z)' and was defined as the
distance to the origin, also known as:

     rho = abs(z) = sqrt(a*a + b*b)

   so

     z * ~z = abs(z) ** 2

   If z is a pure real number (i.e. `b == 0'), then the above yields:

     a * a = abs(a) ** 2

   which is true (abs has the regular meaning for real number, i.e. stands
for the absolute value). This example explains why the norm of z is noted
`abs(z)': it extends the abs function to complex numbers, yet is the
regular abs we know when the complex number actually has no imaginary
part... This justifies *a posteriori* our use of the abs notation for the
norm.

OPERATIONS
==========

   Given the following notations:

     z1 = a + bi = r1 * exp(i * t1)
     z2 = c + di = r2 * exp(i * t2)
     z = <any complex or real number>

   the following (overloaded) operations are supported on complex numbers:

     z1 + z2 = (a + c) + i(b + d)
     z1 - z2 = (a - c) + i(b - d)
     z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
     z1 / z2 = (r1 / r2) * exp(i * (t1 - t2))
     z1 ** z2 = exp(z2 * log z1)
     ~z = a - bi
     abs(z) = r1 = sqrt(a*a + b*b)
     sqrt(z) = sqrt(r1) * exp(i * t/2)
     exp(z) = exp(a) * exp(i * b)
     log(z) = log(r1) + i*t
     sin(z) = 1/2i (exp(i * z1) - exp(-i * z))
     cos(z) = 1/2 (exp(i * z1) + exp(-i * z))
     atan2(z1, z2) = atan(z1/z2)

   The following extra operations are supported on both real and complex
numbers:

     Re(z) = a
     Im(z) = b
     arg(z) = t
     abs(z) = r

     cbrt(z) = z ** (1/3)
     log10(z) = log(z) / log(10)
     logn(z, n) = log(z) / log(n)

     tan(z) = sin(z) / cos(z)

     csc(z) = 1 / sin(z)
     sec(z) = 1 / cos(z)
     cot(z) = 1 / tan(z)

     asin(z) = -i * log(i*z + sqrt(1-z*z))
     acos(z) = -i * log(z + i*sqrt(1-z*z))
     atan(z) = i/2 * log((i+z) / (i-z))

     acsc(z) = asin(1 / z)
     asec(z) = acos(1 / z)
     acot(z) = atan(1 / z) = -i/2 * log((i+z) / (z-i))

     sinh(z) = 1/2 (exp(z) - exp(-z))
     cosh(z) = 1/2 (exp(z) + exp(-z))
     tanh(z) = sinh(z) / cosh(z) = (exp(z) - exp(-z)) / (exp(z) + exp(-z))

     csch(z) = 1 / sinh(z)
     sech(z) = 1 / cosh(z)
     coth(z) = 1 / tanh(z)

     asinh(z) = log(z + sqrt(z*z+1))
     acosh(z) = log(z + sqrt(z*z-1))
     atanh(z) = 1/2 * log((1+z) / (1-z))

     acsch(z) = asinh(1 / z)
     asech(z) = acosh(1 / z)
     acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z-1))

   *arg*, abs, log, *csc*, *cot*, *acsc*, *acot*, *csch*, *coth*,
*acosech*, *acotanh*, have aliases *rho*, *theta*, *ln*, *cosec*, *cotan*,
*acosec*, *acotan*, *cosech*, *cotanh*, *acosech*, *acotanh*,
respectively.  `Re', `Im', `arg', abs, `rho', and `theta' can be used also
also mutators.  The `cbrt' returns only one of the solutions: if you want
all three, use the root function.

   The root function is available to compute all the n roots of some
complex, where n is a strictly positive integer.  There are exactly n such
roots, returned as a list. Getting the number mathematicians call `j' such
that:

     1 + j + j*j = 0;

   is a simple matter of writing:

     $j = ((root(1, 3))[1];

   The kth root for `z = [r,t]' is given by:

     (root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)

   The spaceship comparison operator, <=>, is also defined. In order to
ensure its restriction to real numbers is conform to what you would
expect, the comparison is run on the real part of the complex number
first, and imaginary parts are compared only when the real parts match.

CREATION
========

   To create a complex number, use either:

     $z = Math::Complex->make(3, 4);
     $z = cplx(3, 4);

   if you know the cartesian form of the number, or

     $z = 3 + 4*i;

   if you like. To create a number using the polar form, use either:

     $z = Math::Complex->emake(5, pi/3);
     $x = cplxe(5, pi/3);

   instead. The first argument is the modulus, the second is the angle (in
radians, the full circle is 2*pi).  (Mnemonic: e is used as a notation for
complex numbers in the polar form).

   It is possible to write:

     $x = cplxe(-3, pi/4);

   but that will be silently converted into `[3,-3pi/4]', since the
modulus must be non-negative (it represents the distance to the origin in
the complex plane).

   It is also possible to have a complex number as either argument of
either the make or `emake': the appropriate component of the argument will
be used.

     $z1 = cplx(-2,  1);
     $z2 = cplx($z1, 4);

STRINGIFICATION
===============

   When printed, a complex number is usually shown under its cartesian
style *a+bi*, but there are legitimate cases where the polar style *[r,t]*
is more appropriate.

   By calling the class method `Math::Complex::display_format' and
supplying either `"polar"' or `"cartesian"' as an argument, you override
the default display style, which is `"cartesian"'. Not supplying any
argument returns the current settings.

   This default can be overridden on a per-number basis by calling the
`display_format' method instead. As before, not supplying any argument
returns the current display style for this number. Otherwise whatever you
specify will be the new display style for *this* particular number.

   For instance:

     use Math::Complex;

     Math::Complex::display_format('polar');
     $j = (root(1, 3))[1];
     print "j = $j\n";		# Prints "j = [1,2pi/3]"
     $j->display_format('cartesian');
     print "j = $j\n";		# Prints "j = -0.5+0.866025403784439i"

   The polar style attempts to emphasize arguments like *k*pi/n* (where n
is a positive integer and k an integer within [-9,+9]), this is called
*polar pretty-printing*.

CHANGED IN PERL 5.6
-------------------

   The `display_format' class method and the corresponding
`display_format' object method can now be called using a parameter hash
instead of just a one parameter.

   The old display format style, which can have values `"cartesian"' or
`"polar"', can be changed using the `"style"' parameter.  (The one
parameter calling convention also still works.)

   There are two new display parameters.

   The first one is `"format"', which is a sprintf()-style format string
to be used for both parts of the complex number(s).  The default is undef,
which corresponds usually (this is somewhat system-dependent) to
`"%.15g"'.  You can revert to the default by setting the format string to
undef.

     # the $j from the above example

     $j->display_format('format' => '%.5f');
     print "j = $j\n";		# Prints "j = -0.50000+0.86603i"
     $j->display_format('format' => '%.6f');
     print "j = $j\n";		# Prints "j = -0.5+0.86603i"

   Notice that this affects also the return values of the `display_format'
methods: in list context the whole parameter hash will be returned, as
opposed to only the style parameter value.  If you want to know the whole
truth for a complex number, you must call both the class method and the
object method:

   The second new display parameter is `"polar_pretty_print"', which can
be set to true or false, the default being true.  See the previous section
for what this means.

USAGE
=====

   Thanks to overloading, the handling of arithmetics with complex numbers
is simple and almost transparent.

   Here are some examples:

     use Math::Complex;

     $j = cplxe(1, 2*pi/3);	# $j ** 3 == 1
     print "j = $j, j**3 = ", $j ** 3, "\n";
     print "1 + j + j**2 = ", 1 + $j + $j**2, "\n";

     $z = -16 + 0*i;			# Force it to be a complex
     print "sqrt($z) = ", sqrt($z), "\n";

     $k = exp(i * 2*pi/3);
     print "$j - $k = ", $j - $k, "\n";

     $z->Re(3);			# Re, Im, arg, abs,
     $j->arg(2);			# (the last two aka rho, theta)
     				# can be used also as mutators.

ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO
===================================================

   The division (/) and the following functions

     log	ln	log10	logn
     tan	sec	csc	cot
     atan	asec	acsc	acot
     tanh	sech	csch	coth
     atanh	asech	acsch	acoth

   cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal runtime
errors looking like this

     cot(0): Division by zero.
     (Because in the definition of cot(0), the divisor sin(0) is 0)
     Died at ...

   or

     atanh(-1): Logarithm of zero.
     Died at...

   For the `csc', `cot', `asec', `acsc', `acot', `csch', `coth', `asech',
`acsch', the argument cannot be 0 (zero).  For the the logarithmic
functions and the atanh, `acoth', the argument cannot be 1 (one).  For the
atanh, `acoth', the argument cannot be `-1' (minus one).  For the atan,
`acot', the argument cannot be i (the imaginary unit).  For the atan,
`acoth', the argument cannot be -i (the negative imaginary unit).  For the
tan, sec, tanh, the argument cannot be *pi/2 + k * pi*, where k is any
integer.

   Note that because we are operating on approximations of real numbers,
these errors can happen when merely `too close' to the singularities
listed above.  For example `tan(2*atan2(1,1)+1e-15)' will die of division
by zero.

ERRORS DUE TO INDIGESTIBLE ARGUMENTS
====================================

   The make and `emake' accept both real and complex arguments.  When they
cannot recognize the arguments they will die with error messages like the
following

     Math::Complex::make: Cannot take real part of ...
     Math::Complex::make: Cannot take real part of ...
     Math::Complex::emake: Cannot take rho of ...
     Math::Complex::emake: Cannot take theta of ...

BUGS
====

   Saying `use Math::Complex;' exports many mathematical routines in the
caller environment and even overrides some (sqrt, log).  This is construed
as a feature by the Authors, actually... ;-)

   All routines expect to be given real or complex numbers. Don't attempt
to use BigFloat, since Perl has currently no rule to disambiguate a '+'
operation (for instance) between two overloaded entities.

   In Cray UNICOS there is some strange numerical instability that results
in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast.  Beware.
The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex.
Whatever it is, it does not manifest itself anywhere else where Perl runs.

AUTHORS
=======

   Raphael Manfredi <`Raphael_Manfredi@pobox.com'> and Jarkko Hietaniemi
<`jhi@iki.fi'>.

   Extensive patches by Daniel S. Lewart <`d-lewart@uiuc.edu'>.


File: pm.info,  Node: Math/Currency,  Next: Math/Derivative,  Prev: Math/Complex,  Up: Module List

Exact Currency Math with Formatting and Rounding
************************************************

NAME
====

   Math::Currency - Exact Currency Math with Formatting and Rounding

SYNOPSIS
========

     use Math::Currency qw(Money);
     $dollar = Math::Currency->new("$12,345.67");
     $taxamt = $dollar * 0.28;
     Math::Currency->format(
     	{
     		PREFIX      =>     '',
     		SEPARATOR   =>    ' ',
     		DECIMAL     =>    ',',
     		POSTFIX     =>  ' DM',
     		FRAC_DIGITS =>      2,
     		GROUPING    =>      3,
     	});
     $deutschmark = Money(12345.67);
     $deutschmark_string = Money(12345.67)->stringify();
     # or if you already have a Math::Currency object
     $deutschmark_string = "$deutschmark";

DESCRIPTION
===========

   Currency math is actually more closely related to integer math than it
is to floating point math.  Rounding errors on addition and subtraction
are not allowed and division/multiplication should never create more
accuracy than the original values.  All currency values should round to
the closest cent or whatever the local equivalent should happen to be.

   Each currency value can have an individual format or the global currency
format can be changed to reflect local usage.  I used the suggestions in
Tom Christiansen's `PerlTootC|http:' in this node to implement translucent
attributes.  If you have set your locale values correctly, this module
will pick up your local settings or US standards if you haven't.

   All common mathematical operations are overloaded, so once you
initialize a currency variable, you can treat it like any number and the
module will do the right thing.  This module is a thin layer over
Math::FixedPrecision which is itself a layer over Math::BigFloat which is
itself a layer over Math::BigInt.  The module optionally exports a single
function Money() which can be used instead of Math::Currency->new().

AUTHOR
======

   John Peacock <jpeacock@rowman.com>

SEE ALSO
========

   perl(1).  perllocale Math::FixedPrecision


File: pm.info,  Node: Math/Derivative,  Next: Math/Expr,  Prev: Math/Currency,  Up: Module List

SYNOPSIS
========

     use Math::Derivative qw(Derivative1 Derivative2);
     @dydx=Derivative1(\@x,\@y);
     @d2ydx2=Derivative2(\@x,\@y);
     @d2ydx2=Derivative2(\@x,\@y,$yp0,$ypn);

DESCRIPTION
===========

   This Perl package exports functions for performing numerical first
(*Derivative1*) and second *Derivative2*) order differentiation on vectors
of data. They both take references to two arrays containing the x and y
ordinates of the data and return an array of the 1st or 2nd derivative at
the given x ordinates. *Derivative2* may optionally be given values to use
for the first dervivative at the start and end points of the data -
otherwiswe 'natural' values are used.

HISTORY
=======

   $Log: Derivative.pm,v $ Revision 1.1  1995/12/26 16:26:59  willijar
Initial revision

BUGS
====

   Let me know.

AUTHOR
======

   John A.R. Williams <J.A.R.Williams@aston.ac.uk>


File: pm.info,  Node: Math/Expr,  Next: Math/Expr/FormulaDB,  Prev: Math/Derivative,  Up: Module List

Parses mathematical expressions
*******************************

NAME
====

     Math::Expr - Parses mathematical expressions

SYNOPSIS
========

     use Math::Expr;
     
     SetOppDB(new Math::Expr::OpperationDB('<DBFileName>'));
     $e=Parse("a+4*b-d/log(s)+f(d,e)");

DESCRIPTION
===========

     Parses mathematical expressions into a tree structure. The expressions
     may contain integers, real numbers, alphanumeric variable names,
     alphanumeric function names and most other characters might be used
     as operators. The operators can even be longer than one character!
     The only limitation is that a variable or function name may not start
     on a digit, and not all chars are accepted as operations. To be exact,
     here is the grammatic (in perl regexp notation):

     <Expr>     = -?<Elem>(<OpChr><Elem>)*
     <Elem>     = <Number>|<Var>|<Function>|\(<Expr>\)
     <Number>   = <Integer>|<Float>
     <Integer>  = \d+
     <Float>    = \d*\.\d+
     <Var>      = [a-zA-Z][a-zA-Z0-9]*(:[a-zA-Z][a-zA-Z0-9]*)?
     <Function> = [a-zA-Z][a-zA-Z0-9]*\(<Expr>(,<Expr>)*\)
     <OpChr>    = [^a-zA-Z0-9\(\)\,\.\:]+

     If the - sign is present at the beginning of an <Expr> Then a neg()
     	function is placed around it. That is to allow constructions like
     "-a*b" or "b+3*(-7)".

     A variable consists of two parts separated by a ':'-char. The first
     part is the variable name, and the second optional part is its type.
     Default type is Real.

METHODS
=======

$e=Parse($str)
--------------

   This will parse the string $str and return an expression tree, in the
form of a Math::Expr::Opp object (or in simple cases only a
Math::Expr::Var or Math::Expr::Num object).

$p = new  Math::Expr
--------------------

   This is the constructor, it creates an object which later can be used
to parse the strings.

Priority({'^'=>50, '/'=>40, '*'=>30, '-'=>20, '+'=>10})
-------------------------------------------------------

   This will set the priority of ALL the operands (there is currently no
way to change only one of them). The priority decides what should be
constructed if several operands is listed without delimiters. Eg if a+b*c
should be treated as (a+b)*c or a+(b*c). (Default is listed in header).

   The priority is global for all parsers and all expretions, so changing
it here will change it for all parsers and parsed objects.  The idea is to
use this method to initiate the system before using it.

SetOppDB($db)
-------------

   Sets the OpperationDB to be used to $db. See *Note
Math/Expr/OpperationDB: Math/Expr/OpperationDB, for more info.

   This is a global variable afecting all parsers and all parsed
structures.

BUGS
====

     The parses does not handle bad strings in a decent way. If you try
     to parse a string that does not follow the specification above, all
     strange things might happen...

AUTHOR
======

     Hakan Ardo <hakan@debian.org>

SEE ALSO
========

   *Note Math/Expr/Opp: Math/Expr/Opp,


File: pm.info,  Node: Math/Expr/FormulaDB,  Next: Math/Expr/MatchSet,  Prev: Math/Expr,  Up: Module List

A db of formulas and there properties
*************************************

NAME
====

     Math::Expr::FormulaDB - A db of formulas and there properties

SYNOPSIS
========

     require Math::Expr::FormulaDB;
     $db=new Math::Expr::FormulaDB($file);


File: pm.info,  Node: Math/Expr/MatchSet,  Next: Math/Expr/Node,  Prev: Math/Expr/FormulaDB,  Up: Module List

Represents matches in algebraic expretions
******************************************

NAME
====

     Math::Expr::MatchSet - Represents matches in algebraic expretions

SYNOPSIS
========

     require Math::Expr::MatchSet;
     $s=new Math::Expr::MatchSet;
     $s->Set($pos,$match);
     $s->Get($pos);

DESCRIPTION
===========

     Two expretion can be matched in several ways, therefor we need to be
     able to represent a set of matches keyed by the matchposition (the
     subexpretion, where the match where found).

METHODS
=======

$s=new Math::Expr::MatchSet
---------------------------

     Create a new MatchSet object.

$s->Set($pos, $match)
---------------------

     Sets the match at $pos to $match.

$s->Add($pos, $match)
---------------------

     Synonyme to Set.

$s->Insert($mset)
-----------------

     Inserts all mathes in the MatchSet £mset intho $s.

$s->SetAll($var, $obj)
----------------------

     Sets the variable $var to $obj in all mathces in this set, and removes
     all matches that already had a diffrent value for the variable $var.

$s->tostr
---------

     Generates a string representation of the MatchSet, used for debugging.

$s->Get($pos)
-------------

     Returns the Match at possition $pos.

$s->Keys
--------

     Returns the positions at which there excists a match.


File: pm.info,  Node: Math/Expr/Node,  Next: Math/Expr/Num,  Prev: Math/Expr/MatchSet,  Up: Module List

A node in the expretion tree, used as superclass only
*****************************************************

NAME
====

     Math::Expr::Num - A node in the expretion tree, used as superclass only

SYNOPSIS
========

     package Math::Expr::Num;
     require Math::Expr::Node;

     use Math::Expr::Node;
     use vars qw(@ISA);
     @ISA = qw(Math::Expr::Node);

DESCRIPTION
===========

     Each expretion is represented by a tree where each opperation and variable
     is a separate node. This class contain the common code for all those noeds.

     It also defines all the common methods used in those node classes and does
     some typecheckinig for them. Therefor the methodname in the subclasses
     should start with a '_'-char followed by the actually method name. This
     method will be called by the acutall method in this class after the
     typecheking is done.


File: pm.info,  Node: Math/Expr/Num,  Next: Math/Expr/Opp,  Prev: Math/Expr/Node,  Up: Module List

Represents one number in a parsed expression tree
*************************************************

NAME
====

     Math::Expr::Num - Represents one number in a parsed expression tree

SYNOPSIS
========

     require Math::Expr::Opp;
     require Math::Expr::Var;
     require Math::Expr::Num;
     
     # To represent the expression "x+7":
     $n=new Math::Expr::Opp("+");
     $n->SetOpp(0,new Math::Expr::Var("x"));
     $n->SetOpp(1,new Math::Expr::Num(7));
     print $n->tostr . "\n";

DESCRIPTION
===========

     Used by the Math::Expr to represent numbers.

METHODS
=======

$n=new Math::Expr::Num($num)
----------------------------

     Creates a new representation of the number $num.

$n->tostr
---------

     Returns the string representation of the number which in perl is
     the same as the number itsefle

$n->Copy
--------

   Returns a new copy of itself.

AUTHOR
======

     Hakan Ardo <hakan@debian.org>

SEE ALSO
========

     L<Math::Expr::Opp>


File: pm.info,  Node: Math/Expr/Opp,  Next: Math/Expr/OpperationDB,  Prev: Math/Expr/Num,  Up: Module List

Represents one operation in the parsed expression                      tree
***************************************************************************

NAME
====

     Math::Expr::Opp - Represents one operation in the parsed expression
                       tree

SYNOPSIS
========

     require Math::Expr::Opp;
     require Math::Expr::Var;
     require Math::Expr::Num;
     
     # To represent the expression "x+7":
     $n=new Math::Expr::Opp("+");
     $n->SetOpp(0,new Math::Expr::Var("x"));
     $n->SetOpp(1,new Math::Expr::Num(7));
     print $n->tostr . "\n";

DESCRIPTION
===========

     Used by the Math::Expr to represent algebraic expressions. This class
     represents one operation or function with a set of operands, which
     in turn can be other Math::Expr::Opp objects. And in that way we are
     able to represent entire expression.

     Operations like a+b and functions like sin(a) or f(a,b) are all
     represented by this kind of objects with "+", "sin" and "f" as the
     operation- or function names and Math::Expr::Var(a) and
     Math::Expr::Var(b) as operands (only a in the sin example).

METHODS
=======

$e=new  Math::Expr::Opp($name,$db)
----------------------------------

     Creates a new operation object with the operation- or function-name
     $name. Using the operations defined in $db. See
     L<Math::Expr::OpperationDB> for more info.

$e->SetOpp($i, $v)
------------------

     Sets operand number $i to $v.

$e->Opp($i)
-----------

     Returns operand to number $i.

$e->tostr
---------

     Returns a string representation of the entire expression to be
     used for debugging.

$e->strtype
-----------

     Returns a string representation of this expressions entire type,
     without simplifying it. In the same notation as the tostr method.

$n->Simplify
------------

     Simplifys the expression to some normal from.

$n->BaseType
------------

     Returns a string type of this expression simplifyed as much as
     possible.

$n->SubMatch($rules,$match)
---------------------------

     Tries to match $rules to this expretions and adds the substitutions
     needed to $match.Returns 1 if the match excists and the substitutions
     needed can coexcist with those already in $match otherwise 0.

$n->Match($rules)
-----------------

     Tries to match $rules to this expretions and to all its subexpretions.
     Returns a MatchSet object specifying where the matches ocored and what
     substitutions they represent.

$n->Subs($vars)
---------------

     Substitues all variables in the expretion with there vaules in $vars.

$n->Copy
--------

   Returns a copy of this object.

$n->Breakable
-------------

     Used by the parser to indikate if this object was created using
     parantesis or if he should break it up to preserve the rules of order
     between the diffrent opperations.

$n->Find($pos)
--------------

     Returns an object pointer to the subexpression represented by the
     string $pos.

$n->Set($pos, $val)
-------------------

     Replaces the subexpression at position $pos with $val.

AUTHOR
======

     Hakan Ardo <hakan@debian.org>

SEE ALSO
========

     L<Math::Expr>


File: pm.info,  Node: Math/Expr/OpperationDB,  Next: Math/Expr/Rule,  Prev: Math/Expr/Opp,  Up: Module List

A db of basic opperands properties
**********************************

NAME
====

     Math::Expr::OpperationDB - A db of basic opperands properties

SYNOPSIS
========

     require Math::Expr::OpperationDB;
     $db=new Math::Expr::OpperationDB($file);

DESCRIPTION
===========

     This is a database containing info about the different opperations
     (eg +,  -, *, ...). Each opperation is represented by a regexp
     mathing a type specifikation. That way Real*Real wont be the same
     opperation as Matrix*Matrix even though the same operation character
     is used.

     The data stored for each operation is the return type of the
     operation and whatever this operation is kommutativ or assosiative.

     Currently the data is hardcoded into the code, but that is about to
     chnage.

METHODS
=======

$db=new Math::Expr::OpperationDB;
---------------------------------

     Creates a new db.

$db->Find($t)
-------------

     Tries all the type regexps in the db on $t and if one matches that
     post is returned.


File: pm.info,  Node: Math/Expr/Rule,  Next: Math/Expr/TypeDB,  Prev: Math/Expr/OpperationDB,  Up: Module List

Represents a agebraic rule
**************************

NAME
====

     Math::Expr::Var - Represents a agebraic rule

SYNOPSIS
========

     reuire Math::Expr::Var;
     reuire Math::Expr;
     
     	$r=new Math::Expr::Var($from, $to);
     @res=$r->Apply($expr)

DESCRIPTION
===========

     This will create a rule that converts the expression $from to $to,
     and then apply that rule to $expr. $from, $to, $expr are all
     Math::Expr::Opp structures that should be Simplified to work ok.

     The result is a array @res of Math::Expr::Opp objects which should
     contain the results of applying the rule once on $expr in all
     possible ways. They are all simplified, and duplicaions are removed.

METHODS
=======

$r=new Math::Expr::Var($from, $to);
-----------------------------------

     Makes a rule converting the Math::Expr::Opp structur $from into $to.


File: pm.info,  Node: Math/Expr/TypeDB,  Next: Math/Expr/Var,  Prev: Math/Expr/Rule,  Up: Module List

A db of basic type and there properties
***************************************

NAME
====

     Math::Expr::TypeDB - A db of basic type and there properties

SYNOPSIS
========

     require Math::Expr::TypeDB;
     $db=new Math::Expr::TypeDB($file);


File: pm.info,  Node: Math/Expr/Var,  Next: Math/Expr/VarSet,  Prev: Math/Expr/TypeDB,  Up: Module List

Represents one variable in a parsed expression tree
***************************************************

NAME
====

     Math::Expr::Var - Represents one variable in a parsed expression tree

SYNOPSIS
========

     require Math::Expr::Opp;
     require Math::Expr::Var;
     require Math::Expr::Num;
     
     # To represent the expression "x+7":
     $n=new Math::Expr::Opp("+");
     $n->SetOpp(0,new Math::Expr::Var("x"));
     $n->SetOpp(1,new Math::Expr::Num(7));
     print $n->tostr . "\n";

DESCRIPTION
===========

     Used by the Math::Expr to represent variables.

METHODS
=======

$n=new Math::Expr::Var($name)
-----------------------------

     Creates a new representation of the variable named $name.

$n->tostr
---------

     Returns the string representation of the variable, that is the
     variable name.

$n->strtype
-----------

     Returns the type of the variable.

$n->BaseType
------------

     Simply cals strtype, its needed to be compatible with the other
     elements in the structure.

$n->Match
---------

     Mathces a rule expression with the variable, and returns an array of
     VarSet objects with this variable name set to the expression if there
     types match.

$n->SubMatch
------------

     Used by upper level Match procedure to match an entire expression.

$n->Subs($vars)
---------------

     Returns this variables vaule taken from $vars or a new copy of itselfe
     if it does not excist.

$n->Copy
--------

   Returns a new copy of itself.

AUTHOR
======

     Hakan Ardo <hakan@debian.org>

SEE ALSO
========

     L<Math::Expr::Opp>


File: pm.info,  Node: Math/Expr/VarSet,  Next: Math/FFT,  Prev: Math/Expr/Var,  Up: Module List

Represents a set of variables and there values
**********************************************

NAME
====

     Math::Expr::VarSet - Represents a set of variables and there values

SYNOPSIS
========

     require Math::Expr::VarSet;
     $s=new Math::Expr::VarSet;
     $s->Set('a', 7);
     $s->Get('a');

DESCRIPTION
===========

     Used to represent variables with values and substitutions.

METHODS
=======

$s=new Math::Expr::VarSet
-------------------------

     Create a new VarSet object.

$s->Set($var, $val)
-------------------

     Sets $var to $val. Returns 1 if the $var was already set to $val ore did
     not have a value previously, otherwise 0.

$s->Insert($set)
----------------

     Inserts all variables from $set into this object

$s->tostr
---------

     Returns a stringrepresentation of the set, usefull for debugging.

$s->Get($var)
-------------

     Returns the value of $var.


File: pm.info,  Node: Math/FFT,  Next: Math/Financial,  Prev: Math/Expr/VarSet,  Up: Module List

Perl module to calculate Fast Fourier Transforms
************************************************

NAME
====

   Math::FFT - Perl module to calculate Fast Fourier Transforms

SYNOPSIS
========

     use Math::FFT;
     my $PI = 3.1415926539;
     my $N = 64;
     my ($series, $other_series);
     for (my $k=0; $k<$N; $k++) {
         $series->[$k] = sin(4*$k*$PI/$N) + cos(6*$k*$PI/$N);
     }
     my $fft = new Math::FFT($series);
     my $coeff = $fft->rdft();
     my $spectrum = $fft->spctrm;
     my $original_data = $fft->invrdft($coeff);

     for (my $k=0; $k<$N; $k++) {
         $other_series->[$k] = sin(16*$k*$PI/$N) + cos(8*$k*$PI/$N);
     }
     my $other_fft = $fft->clone($other_series);
     my $other_coeff = $other_fft->rdft();
     my $correlation = $fft->correl($other_fft);

DESCRIPTION
===========

   This module implements some algorithms for calculating Fast Fourier
Transforms for one-dimensional data sets of size 2^n.  The data, assumed
to arise from a constant sampling rate, is represented by an array
reference $data (as described in the methods below), which is then used to
create a `Math::FFT' object as

     my $fft = new Math::FFT($data);

   The methods available include the following.

FFT METHODS
-----------

`$coeff = $fft->cdft();'
     This calculates the complex discrete Fourier transform for a data set
     `x[j]'. Here, $data is a reference to an array `data[0...2*n-1]'
     holding the data

          data[2*j] = Re(x[j]),
          data[2*j+1] = Im(x[j]), 0<=j<n

     An array reference `$coeff' is returned consisting of

          coeff[2*k] = Re(X[k]),
          coeff[2*k+1] = Im(X[k]), 0<=k<n

     where

          X[k] = sum_j=0^n-1 x[j]*exp(2*pi*i*j*k/n), 0<=k<n

`$orig_data = $fft->invcdft([$coeff]);'
     Calculates the inverse complex discrete Fourier transform on a data
     set `x[j]'. If `$coeff' is not given, it will be set equal to an
     earlier call to `$fft->cdft()'. `$coeff' is a reference to an array
     `coeff[0...2*n-1]' holding the data

          coeff[2*j] = Re(x[j]),
          coeff[2*j+1] = Im(x[j]), 0<=j<n

     An array reference `$orig_data' is returned consisting of

          orig_data[2*k] = Re(X[k]),
          orig_data[2*k+1] = Im(X[k]), 0<=k<n

     where, excluding the scale,

          X[k] = sum_j=0^n-1 x[j]*exp(-2*pi*i*j*k/n), 0<=k<n

     A scaling `$orig_data->[$i] *= 2.0/$n' is then done so that
     `$orig_data' coincides with the original $data.

`$coeff = $fft->rdft();'
     This calculates the real discrete Fourier transform for a data set
     `x[j]'. On input, $data is a reference to an array `data[0...n-1]'
     holding the data. An array reference `$coeff' is returned consisting
     of

          coeff[2*k] = R[k], 0<=k<n/2
          coeff[2*k+1] = I[k], 0<k<n/2
          coeff[1] = R[n/2]

     where

          R[k] = sum_j=0^n-1 data[j]*cos(2*pi*j*k/n), 0<=k<=n/2
          I[k] = sum_j=0^n-1 data[j]*sin(2*pi*j*k/n), 0<k<n/2

`$orig_data = $fft->invrdft([$coeff]);'
     Calculates the inverse real discrete Fourier transform on a data set
     `coeff[j]'. If `$coeff' is not given, it will be set equal to an
     earlier call to `$fft->rdft()'. `$coeff' is a reference to an array
     `coeff[0...n-1]' holding the data

          coeff[2*j] = R[j], 0<=j<n/2
          coeff[2*j+1] = I[j], 0<j<n/2
          coeff[1] = R[n/2]

     An array reference `$orig_data' is returned where, excluding the
     scale,

          orig_data[k] = (R[0] + R[n/2]*cos(pi*k))/2 +
            sum_j=1^n/2-1 R[j]*cos(2*pi*j*k/n) +
              sum_j=1^n/2-1 I[j]*sin(2*pi*j*k/n), 0<=k<n

     A scaling `$orig_data->[$i] *= 2.0/$n' is then done so that
     `$orig_data' coincides with the original $data.

`$coeff = $fft->ddct();'
     Computes the discrete cosine tranform on a data set `data[0...n-1]'
     contained in an array reference $data. An array reference `$coeff' is
     returned consisting of

          coeff[k] = C[k], 0<=k<n

     where

          C[k] = sum_j=0^n-1 data[j]*cos(pi*(j+1/2)*k/n), 0<=k<n

`$orig_data = $fft->invddct([$coeff]);'
     Computes the inverse discrete cosine tranform on a data set
     `coeff[0...n-1]' contained in an array reference `$coeff'.  If
     `$coeff' is not given, it will be set equal to an earlier call to
     `$fft->ddct()'. An array reference `$orig_data' is returned
     consisting of

          orig_data[k] = C[k], 0<=k<n

     where, excluding the scale,

          C[k] = sum_j=0^n-1 coeff[j]*cos(pi*j*(k+1/2)/n), 0<=k<n

     A scaling `$orig_data->[$i] *= 2.0/$n' is then done so that
     `$orig_data' coincides with the original $data.

`$coeff = $fft->ddst();'
     Computes the discrete sine transform of a data set `data[0...n-1]'
     contained in an array reference $data. An array reference `$coeff' is
     returned consisting of

          coeff[k] = S[k], 0<k<n
          coeff[0] = S[n]

     where

          S[k] = sum_j=0^n-1 data[j]*sin(pi*(j+1/2)*k/n), 0<k<=n

`$orig_data = $fft->invddst($coeff);'
     Computes the inverse discrete sine transform of a data set
     `coeff[0...n-1]' contained in an array reference `$coeff', arranged as

          coeff[j] = A[j], 0<j<n
          coeff[0] = A[n]

     If `$coeff' is not given, it will be set equal to an earlier call to
     `$fft->ddst()'. An array reference `$orig_data' is returned
     consisting of

          orig_data[k] = S[k], 0<=k<n

     where, excluding a scale,

          S[k] =  sum_j=1^n A[j]*sin(pi*j*(k+1/2)/n), 0<=k<n

     The scaling `$a->[$i] *= 2.0/$n' is then done so that `$orig_data'
     coincides with the original $data.

`$coeff = $fft->dfct();'
     Computes the real symmetric discrete Fourier transform of a data set
     `data[0...n]' contained in the array reference $data. An array
     reference `$coeff' is returned consisting of

          coeff[k] = C[k], 0<=k<=n

     where

          C[k] = sum_j=0^n data[j]*cos(pi*j*k/n), 0<=k<=n

`$orig_data = $fft->invdfct($coeff);'
     Computes the inverse real symmetric discrete Fourier transform of a
     data set `coeff[0...n]' contained in the array reference `$coeff'.
     If `$coeff' is not given, it will be set equal to an earlier call to
     `$fft->dfct()'. An array reference `$orig_data' is returned
     consisting of

          orig_data[k] = C[k], 0<=k<=n

     where, excluding the scale,

          C[k] = sum_j=0^n coeff[j]*cos(pi*j*k/n), 0<=k<=n

     A scaling `$coeff->[0] *= 0.5', `$coeff->[$n] *= 0.5', and
     `$orig_data->[$i] *= 2.0/$n' is then done so that `$orig_data'
     coincides with the original $data.

`$coeff = $fft->dfst();'
     Computes the real anti-symmetric discrete Fourier transform of a data
     set `data[0...n-1]' contained in the array reference $data. An array
     reference `$coeff' is returned consisting of

          coeff[k] = C[k], 0<k<n

     where

          C[k] = sum_j=0^n data[j]*sin(pi*j*k/n), 0<k<n

     (`coeff[0]' is used for a work area)

`$orig_data = $fft->invdfst($coeff);'
     Computes the inverse real anti-symmetric discrete Fourier transform
     of a data set `coeff[0...n-1]' contained in the array reference
     `$coeff'.  If `$coeff' is not given, it will be set equal to an
     earlier call to `$fft->dfst()'. An array reference `$orig_data' is
     returned consisting of

          orig_data[k] = C[k], 0<k<n

     where, excluding the scale,

          C[k] = sum_j=0^n coeff[j]*sin(pi*j*k/n), 0<k<n

     A scaling `$orig_data->[$i] *= 2.0/$n' is then done so that
     `$orig_data' coincides with the original $data.

CLONING
-------

   The algorithm used in the transforms makes use of arrays for a work
area and for a cos/sin lookup table dependent only on the size of the data
set. These arrays are initialized when the `Math::FFT' object is created
and then are populated when a transform method is first invoked. After
this, they persist for the lifetime of the object.

   This aspect is exploited in a cloning method; if a `Math::FFT' object
is created for a data set `$data1' of size N:

     $fft1 = new Math::FFT($data1);

   then a new `Math::FFT' object can be created for a second data set
`$data2' of the *same* size N by

     $fft2 = $fft1->clone($data2);

   The `$fft2' object will copy the reuseable work area and lookup table
calculated from `$fft1'.

APPLICATIONS
------------

   This module includes some common applications - correlation,
convolution and deconvolution, and power spectrum - that arise with real
data sets. The conventions used here follow that of *Numerical Recipes in
C*, by Press, Teukolsky, Vetterling, and Flannery, in which further
details of the algorithms are given. Note in particular the treatment of
end effects by zero padding, which is assumed to be done by the user, if
required.

Correlation
     The correlation between two functions is defined as

          /
             Corr(t) = | ds g(s+t) h(s)
          /

     This may be calculated, for two array references `$data1' and
     `$data2' of the same size $n, as either

          $fft1 = new Math::FFT($data1);
          $fft2 = new Math::FFT($data2);
          $corr = $fft1->correl($fft2);

     or as

          $fft1 = new Math::FFT($data1);
          $corr = $fft1->correl($data2);

     The array reference `$corr' is returned in wrap-around order -
     correlations at increasingly positive lags are in `$corr->[0]' (zero
     lag) on up to `$corr->[$n/2-1]', while correlations at increasingly
     negative lags are in `$corr->[$n-1]' on down to `$corr->[$n/2]'. The
     sign convention used is such that if `$data1' lags `$data2' (that is,
     is shifted to the right), then `$corr' will show a peak at positive
     lags.

Convolution
     The convolution of two functions is defined as

          /
             Convlv(t) = | ds g(s) h(t-s)
          /

     This is similar to calculating the correlation between the two
     functions, but typically the functions here have a quite different
     physical interpretation - one is a signal which persists indefinitely
     in time, and the other is a response function of limited duration.
     The convolution may be calculated, for two array references $data and
     `$respn', as

          $fft = new Math::FFT($data);
          $convlv = $fft->convlv($respn);

     with the returned `$convlv' being an array reference. The method
     assumes that the response function `$respn' has an *odd* number of
     elements $m less than or equal to the number of elements $n of $data.
     `$respn' is assumed to be stored in wrap-around order - the first
     half contains the response at positive times, while the second half,
     counting down from `$respn->[$m-1]', contains the response at
     negative times.

Deconvolution
     Deconvolution undoes the effects of convoluting a signal with a known
     response function. In other words, in the relation

          /
             Convlv(t) = | ds g(s) h(t-s)
          /

     deconvolution reconstructs the original signal, given the convolution
     and the response function. The method is implemented, for two array
     references $data and `$respn', as

          $fft = new Math::FFT($data);
          $deconvlv = $fft->deconvlv($respn);

     As a result, if the convolution of a data set $data with a response
     function `$respn' is calculated as

          $fft1 = new Math::FFT($data);
          $convlv = $fft1->convlv($respn);

     then the deconvolution

          $fft2 = new Math::FFT($convlv);
          $deconvlv = $fft2->deconvlv($respn);

     will give an array reference `$deconvlv' containing the same elements
     as the original data $data.

Power Spectrum
     If the FFT of a real function of N elements is calculated, the
     `N/2+1' elements of the power spectrum are defined, in terms of the
     (complex) Fourier coefficients `C[k]', as

          P[0] = |C[0]|^2 / N^2
          P[k] = 2 |C[k]|^2 / N^2   (k = 1, 2 ,..., N/2-1)
          P[N/2] = |C[N/2]|^2 / N^2

     Often for these purposes the data is partitioned into K segments,
     each containing `2M' elements. The power spectrum for each segment is
     calculated, and the net power spectrum is the average of all of these
     segmented spectra.

     Partitioning may be done in one of two ways: *non-overlapping* and
     overlapping. Non-overlapping is useful when the data set is gathered
     in real time, where the number of data points can be varied at will.
     Overlapping is useful where there is a fixed number of data points.
     In non-overlapping, the first <2M> elements constitute segment 1, the
     next `2M' elements are segment 2, and so on up to segment K, for a
     total of `2KM' sampled points. In overlapping, the first and second M
     elements are segment 1, the second and third M elements are segment
     2, and so on, for a total of `(K+1)M' sampled points.

     A problem that may arise in this procedure is *leakage*: the power
     spectrum calculated for one bin contains contributions from nearby
     bins. To lessen this effect *data windowing* is often used: multiply
     the original data `d[j]' by a window function `w[j]', where j = 0, 1,
     ..., N-1. Some popular choices of such functions are

          | j - N/2 |
            w[j] = 1 -  | ------- |     ... Bartlett
          |   N/2   |

          / j - N/2 \ 2
            w[j] = 1 -  | ------- |     ... Welch
          \   N/2   /

          1   /                    \
            w[j] =  ---  |1 - cos(2 pi j / N) |     ... Hamm
          2   \                    /

     The `spctrm' method, used as

          $fft = Math::FFT->new($data);
          $spectrum = $fft->spctrm([$key => $value, ...]);

     returns an array reference `$spectrum' representing the power
     spectrum for a data set represented by an array reference $data.  The
     options available are

    `window => window_name'
          This specifies the window function; if not given, no such
          function is used. Accepted values (see above) are `"bartlett"',
          `"welch"', `"hamm"', and `\&my_window', where `my_window' is a
          user specified subroutine which must be of the form, for example,

               sub my_window {
                  my ($j, $n) = @_;
                  return 1 - abs(2*($j-$n/2)/$n);
               }

          which implements the Bartlett window.

    `overlap => 1'
          This specifies whether overlapping should be done; if true (1),
          overlapping will be used, whereas if false (0), or not
          specified, no overlapping is used.

    `segments => n'
          This specifies that the data will be partitioned into n
          segments. If not specified, no segmentation will be done.

    `number => m'
          This specifies that `2m' data points will be used for each
          segment, and must be a power of 2. The power spectrum returned
          will consist of `m+1' elements.

STATISTICAL FUNCTIONS
---------------------

   For convenience, a number of common statistical functions are included
for analyzing real data. After creating the object as

     my $fft = new Math::FFT($data);

   for a data set represented by the array reference $data of size N,
these methods may be called as follows.

`$mean = $fft->mean([$data]);'
     This returns the mean

          1/N * sum_j=0^N-1 data[j]

     If an array reference $data is not given, the data set used in
     creating `$fft' will be used.

`$stdev = $fft->stdev([$data]);'
     This returns the standard deviation

          sqrt{ 1/(N-1) * sum_j=0^N-1 (data[j] - mean)**2 }

     If an array reference $data is not given, the data set used in
     creating `$fft' will be used.

`($min, $max) = $fft->range([$data]);'
     This returns the minimum and maximum values of the data set.  If an
     array reference $data is not given, the data set used in creating
     `$fft' will be used.

`$median = $fft->median([$data]);'
     This returns the median of a data set. The median is defined, for the
     sorted data set, as either the middle element, if the number of
     elements is odd, or as the interpolated value of the the two values
     on either side of the middle, if the number of elements is even. If
     an array reference $data is not given, the data set used in creating
     `$fft' will be used.

BUGS
====

   Please report any to Randy Kobes <randy@theoryx5.uwinnipeg.ca>

SEE ALSO
========

   `Math::Pari' in this node and *Note PDL: PDL,

COPYRIGHT
=========

   The algorithm used in this module to calculate the Fourier transforms
is based on the C routine of fft4g.c available at
http://momonga.t.u-tokyo.ac.jp/~ooura/fft.html, which is copyrighted
1996-99 by Takuya OOURA. The file arrays.c included here to handle passing
arrays to and from C comes from the PGPLOT module of Karl Glazebrook
<kgb@aaoepp.aao.gov.au>. The perl code of Math::FFT is copyright 2000 by
Randy Kobes, and is distributed under the same terms as Perl itself.


