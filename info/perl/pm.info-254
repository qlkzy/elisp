This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Net/Inet,  Next: Net/Interface,  Prev: Net/Ident,  Up: Module List

Internet socket interface module
********************************

NAME
====

   Net::Inet - Internet socket interface module

SYNOPSIS
========

     use Net::Gen;		# optional
     use Net::Inet;

DESCRIPTION
===========

   The `Net::Inet' module provides basic services for handling
socket-based communications for the Internet protocol family.  It inherits
from `Net::Gen', and is a base for `Net::TCP' and `Net::UDP'.

Public Methods
--------------

new
     Usage:

          $obj = new Net::Inet;
          $obj = new Net::Inet $desthost, $destservice;
          $obj = new Net::Inet \%parameters;
          $obj = new Net::Inet $desthost, $destservice, \%parameters;
          $obj = 'Net::Inet'->new();
          $obj = 'Net::Inet'->new($desthost, $destservice);
          $obj = 'Net::Inet'->new(\%parameters);
          $obj = 'Net::Inet'->new($desthost, $destservice, \%parameters);

     Returns a newly-initialised object of the given class.  If called for
     a derived class, no validation of the supplied parameters will be
     performed.  (This is so that the derived class can set up the
     parameter validation it needs in the object before allowing the
     validation.)  Otherwise, it will cause the parameters to be validated
     by calling its init method.  In particular, this means that if both a
     host and a service are given, then an object will only be returned if
     a connect() call was successful, or if the object is non-blocking and
     a connect() call is in progress.

     The examples above show the indirect object syntax which many prefer,
     as well as the guaranteed-to-be-safe static method call.  There are
     occasional problems with the indirect object syntax, which tend to be
     rather obscure when encountered.  See





















     <URL:http://www.rosat.mpe-garching.mpg.de/mailing-lists/perl-porters/1998-01/msg01674.html>
     for details.

init
     Usage:

          return undef unless $self->init;
          return undef unless $self->init(\%parameters);
          return undef unless $self->init($desthost, $destservice);
          return undef unless $self->init($desthost, $destservice, \%parameters);

     Verifies that all previous parameter assignments are valid (via
     checkparams).  Returns the incoming object on success, and undef on
     failure.  Usually called only via a derived class's init method or
     its own new call.

bind
     Usage:

          $ok = $obj->bind;
          $ok = $obj->bind($lclhost, $lclservice);
          $ok = $obj->bind($lclhost, $lclservice, \%parameters);

     Sets up the srcaddrlist object parameter with the specified $lclhost
     and $lclservice arguments if supplied (via the thishost and thisport
     object parameters), and then returns the value from the inherited
     bind method.  Changing of parameters is also allowed, mainly for
     setting debug status or timeouts.

     Example:

          $ok = $obj->bind(0, 'echo(7)'); # attach to the local TCP echo port

unbind
     Usage:

          $obj->unbind;

     Deletes the thishost and thisport object parameters, and then
     (assuming that succeeds, which it should) returns the value from the
     inherited unbind method.

connect
     Usage:

          $ok = $obj->connect;
          $ok = $obj->connect($host, $service);
          $ok = $obj->connect($host, $service, \%parameters);

     Attempts to establish a connection for the object.  If the $host or
     $service arguments are specified, they will be used to set the
     desthost and destservice/destport object parameters, with
     side-effects of setting up the dstaddrlist object parameter.  Then,
     the result of a call to the inherited connect method will be
     returned.  Changing of parameters is also allowed, mainly for setting
     debug status or timeouts.

format_addr
     Usage:

          $string = $obj->format_addr($sockaddr);
          $string = $obj->format_addr($sockaddr, $numeric_only);
          $string = format_addr Module $sockaddr;
          $string = format_addr Module $sockaddr, $numeric_only;

     Returns a formatted representation of the address.  This is a method
     so that it can be overridden by derived classes.  It is used to
     implement "pretty-printing" methods for source and destination
     addresses.  If the $numeric_only argument is true, the address and
     port number will be used even if they can be resolved to names.
     Otherwise, the resolved hostname and service name will be used if
     possible.

format_local_addr
     Usage:

          $string = $obj->format_local_addr;
          $string = $obj->format_local_addr($numeric_only);

     Returns a formatted representation of the local socket address
     associated with the object.  A sugar-coated way of calling the
     format_addr method for the srcaddr object parameter.

format_remote_addr
     Usage:

          $string = $obj->format_remote_addr;

     Returns a formatted representation of the remote socket address
     associated with the object.  A sugar-coated way of calling the
     format_addr method for the dstaddr object parameter.

getsockinfo
     An augmented form of `Net::Gen::getsockinfo'.  Aside from updating
     more object parameters, it behaves the same as that in the base
     class.  The additional object parameters which get set are lcladdr,
     lclhost, lclport, lclservice, remaddr, remhost, remport, and
     remservice.  (They are described in `"Known Object Parameters"' in
     this node below.)

   There are also various *accessor* methods for the object parameters.
See `Accessors', *Note Net/Gen: Net/Gen, for calling details.  See `"Known
Object Parameters"' in this node below for those defined by this class.

Protected Methods
-----------------

   [See the note in `"Protected Methods"', *Note Net/Gen: Net/Gen, about my
definition of protected methods in Perl.]

   None.

Known Socket Options
--------------------

   These are the socket options known to the `Net::Inet' module itself:


     `IP_HDRINCL' `IP_RECVDSTADDR' `IP_RECVOPTS' `IP_RECVRETOPTS' `IP_TOS'
     `IP_TTL' `IP_ADD_MEMBERSHIP' `IP_DROP_MEMBERSHIP' `IP_MULTICAST_IF'
     `IP_MULTICAST_LOOP' `IP_MULTICAST_TTL' `IP_OPTIONS' `IP_RETOPTS'

Known Object Parameters
-----------------------

   These are the object parameters registered by the `Net::Inet' module
itself:

IPproto
     The name of the Internet protocol in use on the socket associated
     with the object.  Set as a side-effect of setting the proto object
     parameter, and vice versa.

proto
     Used the same way as with `Net::Gen', but has a handler attached to
     keep it in sync with IPproto.

thishost
     The source host name or address to use for the bind method.  When
     used in conjunction with the thisservice or thisport object
     parameter, causes the srcaddrlist object parameter to be set, which
     is how it affects the bind() action.  This parameter is validated,
     and must be either a valid internet address or a hostname for which
     an address can be found.  If a hostname is given, and multiple
     addresses are found for it, then each address will be entered into
     the srcaddrlist array reference.

desthost
     The destination host name or address to use for the connect method.
     When used in conjunction with the destservice or destport object
     parameter, causes the dstaddrlist object parameter to be set, which
     is how it affects the connect() action.  This parameter is validated,
     and must be either a valid internet address or a hostname for which
     an address can be found.  If a hostname is given, and multiple
     addresses are found for it, then each address will be entered into
     the dstaddrlist array reference, in order.  This allows the connect
     method to attempt a connection to each address, as per RFC 1123.

thisservice
     The source service name (or number) to use for the bind method.  An
     attempt will be made to translate the supplied service name with
     getservbyname().  If that succeeds, or if it fails but the supplied
     value was strictly numeric, the port number will be set in the
     thisport object parameter.  If the supplied value is not numeric and
     can't be translated, the attempt to set the value will fail.
     Otherwise, this causes the srcaddrlist object parameter to be
     updated, in preparation for an invocation of the bind method
     (possibly implicitly from the connect method).

thisport
     The source service number (or name) to use for the bind method.  An
     attempt will be made to translate the supplied service name with
     getservbyname() if it is not strictly numeric.  If that succeeds, the
     given name will be set in the thisservice parameter, and the resolved
     port number will be set in the thisport object parameter.  If the
     supplied value is strictly numeric, and a call to getservbyport can
     resolve a name for the service, the thisservice parameter will be
     updated appropriately.  If the supplied value is not numeric and
     can't be translated, the attempt to set the value will fail.
     Otherwise, this causes the srcaddrlist object parameter to be
     updated, in preparation for an invocation of the bind method
     (possibly implicitly from the connect method).

destservice
     The destination service name (or number) to use for the connect
     method.  An attempt will be made to translate the supplied service
     name with getservbyname().  If that succeeds, or if it fails but the
     supplied value was strictly numeric, the port number will be set in
     the destport object parameter.  If the supplied value is not numeric
     and can't be translated, the attempt to set the value will fail.
     Otherwise, if the desthost parameter has a defined value, this causes
     the dstaddrlist object parameter to be updated, in preparation for an
     invocation of the connect method.

destport
     The destination service number (or name) to use for the connect
     method.  An attempt will be made to translate the supplied service
     name with getservbyname() if it is not strictly numeric.  If that
     succeeds, the given name will be set in the destservice parameter,
     and the resolved port number will be set in the destport parameter.
     If the supplied value is strictly numeric, and a call to
     getservbyport can resolve a name for the service, the destservice
     parameter will be updated appropriately.  If the supplied value is
     not numeric and can't be translated, the attempt to set the value
     will fail.  Otherwise, if the desthost parameter has a defined value,
     this causes the dstaddrlist object parameter to be updated, in
     preparation for an invocation of the connect method.

lcladdr
     The local IP address stashed by the getsockinfo method after a
     successful bind() or connect() call.

lclhost
     The local hostname stashed by the getsockinfo method after a
     successful bind() or connect(), as resolved from the lcladdr object
     parameter.

lclport
     The local port number stashed by the getsockinfo method after a
     successful bind() or connect() call.

lclservice
     The local service name stashed by the getsockinfo method after a
     successful bind() or connect(), as resolved from the lclport object
     parameter.

remaddr
     The remote IP address stashed by the getsockinfo method after a
     successful connect() call.

remhost
     The remote hostname stashed by the getsockinfo method after a
     successful connect() call, as resolved from the remaddr object
     parameter.

remport
     The remote port number stashed by the getsockinfo method after a
     successful connect() call.

remservice
     The remote service name stashed by the getsockinfo method after a
     successful connect() call, as resolved from the remport object
     parameter.

Non-Method Subroutines
----------------------

inet_aton
     Usage:

          $in_addr = inet_aton('192.0.2.1');

     Returns the packed `AF_INET' address in network order, if it is
     validly formed, or undef on error.  This used to be a separate
     implementation in this package, but is now inherited from the Socket
     module.

inet_addr
     A synonym for inet_aton() (for old fogeys like me who forget about
     the new name).  (Yes, I know it's different in C, but in Perl there's
     no need to propagate the old inet_addr() braindamage of being unable
     to handle "255.255.255.255", so I didn't.)

inet_ntoa
     Usage:

          $addr_string = inet_ntoa($in_addr);

     Returns the ASCII representation of the `AF_INET' address provided
     (if possible), or undef on error.  This used to be a separate
     implementation in this package, but is now inherited from the Socket
     module.

htonl
htons
ntohl
ntohs
     As you'd expect, I think.

pack_sockaddr_in
     Usage:

          $connect_address = pack_sockaddr_in($family, $port, $in_addr);
          $connect_address = pack_sockaddr_in($port, $in_addr);

     Returns the packed `struct sockaddr_in' corresponding to the provided
     $family, $port, and $in_addr arguments.  The $family and $port
     arguments must be numbers, and the $in_addr argument must be a packed
     `struct in_addr' such as the trailing elements from perl's
     gethostent() return list.  This differs from the implementation in
     the Socket module in that the `$family' argument is available (though
     optional).

unpack_sockaddr_in
     Usage:

          ($family, $port, $in_addr) = unpack_sockaddr_in($connected_address);

     Returns the address family, port, and packed `struct in_addr' from
     the supplied packed `struct sockaddr_in'.  This is the inverse of
     pack_sockaddr_in().  This differs from the implementation in the
     Socket module in that the `$family' value from the socket address is
     returned (and might not be AF_INET).

INADDR_UNSPEC_GROUP
INADDR_ALLHOSTS_GROUP
INADDR_ALLRTRS_GROUP
INADDR_MAX_LOCAL_GROUP
     Constant routines returning the unspecified local, all hosts,
     all routers, or the maximum possible local IP multicast group
     address, respectively.  These routines return results in the form of
     a packed `struct inaddr' much like the INADDR_ANY result described in
     `INADDR_ANY', *Note Socket: Socket,.

IN_CLASSA
IN_CLASSB
IN_CLASSC
IN_CLASSD
IN_MULTICAST
IN_EXPERIMENTAL
IN_BADCLASS
     Usage:

          $boolean = IN_EXPERIMENTAL(INADDR_ALLHOSTS_GROUP);
          $boolean = IN_CLASSA(0x7f000001);

     These routines return the *network class* information for the
     supplied IP address.  Of these, only IN_BADCLASS() and IN_MULTICAST()
     are really useful in today's Internet, since the advent of CIDR
     (classless Internet domain routing).  In particular,
     IN_EXPERIMENTAL() is at the mercy of your vendor's definition.  The
     first example above will be true only on older systems, which almost
     certainly don't support IP multicast anyway.  The argument to any of
     these functions can be either a packed `struct inaddr' such as that
     returned by inet_ntoa() or unpack_sockaddr_in(), or an integer (or
     integer expression) giving an IP address in host byte order.

IPOPT_CLASS
IPOPT_COPIED
IPOPT_NUMBER
     Usage:

          $optnum = IPOPT_NUMBER($option);

     These routines extract information from IP option numbers, as per the
     information on IP options in RFC 791.

...
     Other constants which relate to parts of IP or ICMP headers or
     vendor-defined socket options, as listed in `"Exports"' in this node
     below.

Exports
-------

default
     INADDR_ALLHOSTS_GROUP INADDR_ALLRTRS_GROUP INADDR_ANY
     INADDR_BROADCAST INADDR_LOOPBACK INADDR_MAX_LOCAL_GROUP INADDR_NONE
     INADDR_UNSPEC_GROUP `IPPORT_RESERVED' `IPPORT_USERRESERVED'
     `IPPORT_DYNAMIC' `IPPROTO_EGP' `IPPROTO_EON' `IPPROTO_GGP'
     `IPPROTO_HELLO' `IPPROTO_ICMP' `IPPROTO_IDP' `IPPROTO_IGMP'
     `IPPROTO_IP' `IPPROTO_IPIP' `IPPROTO_MAX' `IPPROTO_PUP' `IPPROTO_RAW'
     `IPPROTO_RSVP' `IPPROTO_TCP' `IPPROTO_TP' `IPPROTO_UDP' htonl htons
     inet_addr inet_aton inet_ntoa ntohl ntohs

exportable
     `DEFTTL' `ICMP_ADVLENMIN' `ICMP_ECHO' `ICMP_ECHOREPLY'
     `ICMP_INFOTYPE' `ICMP_IREQ' `ICMP_IREQREPLY' `ICMP_MASKLEN'
     `ICMP_MASKREPLY' `ICMP_MASKREQ' `ICMP_MAXTYPE' `ICMP_MINLEN'
     `ICMP_PARAMPROB' `ICMP_REDIRECT' `ICMP_REDIRECT_HOST'
     `ICMP_REDIRECT_NET' `ICMP_REDIRECT_TOSHOST' `ICMP_REDIRECT_TOSNET'
     `ICMP_SOURCEQUENCH' `ICMP_TIMXCEED' `ICMP_TIMXCEED_INTRANS'
     `ICMP_TIMXCEED_REASS' `ICMP_TSLEN' `ICMP_TSTAMP' `ICMP_TSTAMPREPLY'
     `ICMP_UNREACH' `ICMP_UNREACH_HOST' `ICMP_UNREACH_NEEDFRAG'
     `ICMP_UNREACH_NET' `ICMP_UNREACH_PORT' `ICMP_UNREACH_PROTOCOL'
     `ICMP_UNREACH_SRCFAIL' IN_BADCLASS IN_CLASSA `IN_CLASSA_HOST'
     `IN_CLASSA_MAX' `IN_CLASSA_NET' `IN_CLASSA_NSHIFT'
     `IN_CLASSA_SUBHOST' `IN_CLASSA_SUBNET' `IN_CLASSA_SUBNSHIFT'
     IN_CLASSB `IN_CLASSB_HOST' `IN_CLASSB_MAX' `IN_CLASSB_NET'
     `IN_CLASSB_NSHIFT' `IN_CLASSB_SUBHOST' `IN_CLASSB_SUBNET'
     `IN_CLASSB_SUBNSHIFT' IN_CLASSC `IN_CLASSC_HOST' `IN_CLASSC_MAX'
     `IN_CLASSC_NET' `IN_CLASSC_NSHIFT' IN_CLASSD `IN_CLASSD_HOST'
     `IN_CLASSD_NET' `IN_CLASSD_NSHIFT' IN_EXPERIMENTAL `IN_LOOPBACKNET'
     IN_MULTICAST `IPFRAGTTL' `IPOPT_CIPSO' IPOPT_CLASS `IPOPT_CONTROL'
     IPOPT_COPIED `IPOPT_DEBMEAS' `IPOPT_EOL' `IPOPT_LSRR' `IPOPT_MINOFF'
     `IPOPT_NOP' IPOPT_NUMBER `IPOPT_OFFSET' `IPOPT_OLEN' `IPOPT_OPTVAL'
     `IPOPT_RESERVED1' `IPOPT_RESERVED2' `IPOPT_RIPSO_AUX' `IPOPT_RR'
     `IPOPT_SATID' `IPOPT_SECURITY' `IPOPT_SECUR_CONFID' `IPOPT_SECUR_EFTO'
     `IPOPT_SECUR_MMMM' `IPOPT_SECUR_RESTR' `IPOPT_SECUR_SECRET'
     `IPOPT_SECUR_TOPSECRET' `IPOPT_SECUR_UNCLASS' `IPOPT_SSRR' `IPOPT_TS'
     `IPOPT_TS_PRESPEC' `IPOPT_TS_TSANDADDR' `IPOPT_TS_TSONLY'
     `IPPORT_TIMESERVER' `IPTOS_LOWDELAY' `IPTOS_PREC_CRITIC_ECP'
     `IPTOS_PREC_FLASH' `IPTOS_PREC_FLASHOVERRIDE' `IPTOS_PREC_IMMEDIATE'
     `IPTOS_PREC_INTERNETCONTROL' `IPTOS_PREC_NETCONTROL'
     `IPTOS_PREC_PRIORITY' `IPTOS_PREC_ROUTINE' `IPTOS_RELIABILITY'
     `IPTOS_THROUGHPUT' `IPTTLDEC' `IPVERSION' `IP_ADD_MEMBERSHIP'
     `IP_DEFAULT_MULTICAST_LOOP' `IP_DEFAULT_MULTICAST_TTL' `IP_DF'
     `IP_DROP_MEMBERSHIP' `IP_HDRINCL' `IP_MAXPACKET' `IP_MAX_MEMBERSHIPS'
     `IP_MF' `IP_MSS' `IP_MULTICAST_IF' `IP_MULTICAST_LOOP'
     `IP_MULTICAST_TTL' `IP_OPTIONS' `IP_RECVDSTADDR' `IP_RECVOPTS'
     `IP_RECVRETOPTS' `IP_RETOPTS' `IP_TOS' `IP_TTL' `MAXTTL'
     `MAX_IPOPTLEN' `MINTTL' `SUBNETSHIFT' pack_sockaddr_in
     unpack_sockaddr_in

tags
     The following :tags are in `%EXPORT_TAGS', with the associated
     exportable values as listed:

    :sockopts
          `IP_HDRINCL' `IP_RECVDSTADDR' `IP_RECVOPTS' `IP_RECVRETOPTS'
          `IP_TOS' `IP_TTL' `IP_ADD_MEMBERSHIP' `IP_DROP_MEMBERSHIP'
          `IP_MULTICAST_IF' `IP_MULTICAST_LOOP' `IP_MULTICAST_TTL'
          `IP_OPTIONS' `IP_RETOPTS'

    :routines
          pack_sockaddr_in unpack_sockaddr_in inet_ntoa inet_aton
          inet_addr htonl ntohl htons ntohs `ICMP_INFOTYPE' IN_BADCLASS
          IN_EXPERIMENTAL IN_MULTICAST IPOPT_CLASS IPOPT_COPIED
          IPOPT_NUMBER

    :icmpvalues
          `ICMP_ADVLENMIN' `ICMP_ECHO' `ICMP_ECHOREPLY' `ICMP_IREQ'
          `ICMP_IREQREPLY' `ICMP_MASKLEN' `ICMP_MASKREPLY' `ICMP_MASKREQ'
          `ICMP_MAXTYPE' `ICMP_MINLEN' `ICMP_PARAMPROB' `ICMP_REDIRECT'
          `ICMP_REDIRECT_HOST' `ICMP_REDIRECT_NET' `ICMP_REDIRECT_TOSHOST'
          `ICMP_REDIRECT_TOSNET' `ICMP_SOURCEQUENCH' `ICMP_TIMXCEED'
          `ICMP_TIMXCEED_INTRANS' `ICMP_TIMXCEED_REASS' `ICMP_TSLEN'
          `ICMP_TSTAMP' `ICMP_TSTAMPREPLY' `ICMP_UNREACH'
          `ICMP_UNREACH_HOST' `ICMP_UNREACH_NEEDFRAG' `ICMP_UNREACH_NET'
          `ICMP_UNREACH_PORT' `ICMP_UNREACH_PROTOCOL'
          `ICMP_UNREACH_SRCFAIL'

    :ipoptions
          `IPOPT_CIPSO' `IPOPT_CONTROL' `IPOPT_DEBMEAS' `IPOPT_EOL'
          `IPOPT_LSRR' `IPOPT_MINOFF' `IPOPT_NOP' `IPOPT_OFFSET'
          `IPOPT_OLEN' `IPOPT_OPTVAL' `IPOPT_RESERVED1' `IPOPT_RESERVED2'
          `IPOPT_RIPSO_AUX' `IPOPT_RR' `IPOPT_SATID' `IPOPT_SECURITY'
          `IPOPT_SECUR_CONFID' `IPOPT_SECUR_EFTO' `IPOPT_SECUR_MMMM'
          `IPOPT_SECUR_RESTR' `IPOPT_SECUR_SECRET' `IPOPT_SECUR_TOPSECRET'
          `IPOPT_SECUR_UNCLASS' `IPOPT_SSRR' `IPOPT_TS' `IPOPT_TS_PRESPEC'
          `IPOPT_TS_TSANDADDR' `IPOPT_TS_TSONLY' `MAX_IPOPTLEN'

    :iptosvalues
          `IPTOS_LOWDELAY' `IPTOS_PREC_CRITIC_ECP' `IPTOS_PREC_FLASH'
          `IPTOS_PREC_FLASHOVERRIDE' `IPTOS_PREC_IMMEDIATE'
          `IPTOS_PREC_INTERNETCONTROL' `IPTOS_PREC_NETCONTROL'
          `IPTOS_PREC_PRIORITY' `IPTOS_PREC_ROUTINE' `IPTOS_RELIABILITY'
          `IPTOS_THROUGHPUT'

    :protocolvalues
          `DEFTTL' INADDR_ALLHOSTS_GROUP INADDR_ALLRTRS_GROUP INADDR_ANY
          INADDR_BROADCAST INADDR_LOOPBACK INADDR_MAX_LOCAL_GROUP
          INADDR_NONE INADDR_UNSPEC_GROUP `IN_LOOPBACKNET'
          `IPPORT_RESERVED' `IPPORT_USERRESERVED' `IPPORT_DYNAMIC'
          `IPPROTO_EGP' `IPPROTO_EON' `IPPROTO_GGP' `IPPROTO_HELLO'
          `IPPROTO_ICMP' `IPPROTO_IDP' `IPPROTO_IGMP' `IPPROTO_IP'
          `IPPROTO_IPIP' `IPPROTO_MAX' `IPPROTO_PUP' `IPPROTO_RAW'
          `IPPROTO_RSVP' `IPPROTO_TCP' `IPPROTO_TP' `IPPROTO_UDP'
          `IPFRAGTTL' `IPTTLDEC' `IPVERSION' `IP_DF' `IP_MAXPACKET' `IP_MF'
          `IP_MSS' `MAXTTL' `MAX_IPOPTLEN' `MINTTL'

    :ipmulticast
          `IP_ADD_MEMBERSHIP' `IP_DEFAULT_MULTICAST_LOOP'
          `IP_DEFAULT_MULTICAST_TTL' `IP_DROP_MEMBERSHIP'
          `IP_MAX_MEMBERSHIPS' `IP_MULTICAST_IF' `IP_MULTICAST_LOOP'
          `IP_MULTICAST_TTL'

    :deprecated
          `IN_CLASSA_HOST' `IN_CLASSA_MAX' `IN_CLASSA_NET'
          `IN_CLASSA_NSHIFT' `IN_CLASSA_SUBHOST' `IN_CLASSA_SUBNET'
          `IN_CLASSA_SUBNSHIFT' `IN_CLASSB_HOST' `IN_CLASSB_MAX'
          `IN_CLASSB_NET' `IN_CLASSB_NSHIFT' `IN_CLASSB_SUBHOST'
          `IN_CLASSB_SUBNET' `IN_CLASSB_SUBNSHIFT' `IN_CLASSC_HOST'
          `IN_CLASSC_MAX' `IN_CLASSC_NET' `IN_CLASSC_NSHIFT'
          `IN_CLASSD_HOST' `IN_CLASSD_NET' `IN_CLASSD_NSHIFT' IN_CLASSA
          IN_CLASSB IN_CLASSC IN_CLASSD `IPPORT_TIMESERVER' `SUBNETSHIFT'

    :ALL
          All of the above exportable items.

NOTES
=====

   Anywhere a service or port argument is used above, the allowed syntax
is either a service name, a port number, or a service name with a
caller-supplied default port number.  Examples are `'echo'', 7, and
`'echo(7)'', respectively.  For a service argument, a bare port number
must be translatable into a service name with getservbyport() or an error
will result.  A service name must be translatable into a port with
getservbyname() or an error will result.  However, a service name with a
default port number will succeed (by using the supplied default) even if
the translation with getservbyname() fails.

THREADING STATUS
================

   This module has been tested with threaded perls, and should be as
thread-safe as perl itself.  (As of 5.005_03 and 5.005_57, that's not all
that safe just yet.)

SEE ALSO
========

   Net::Gen(3), Net::TCP(3), Net::UDP(3)

AUTHOR
======

   Spider Boardman <spider@Orb.Nashua.NH.US>


File: pm.info,  Node: Net/Interface,  Next: Net/Jabber,  Prev: Net/Inet,  Up: Module List

Perl extension to access network interfaces
*******************************************

NAME
====

   Net::Interface - Perl extension to access network interfaces

SYNOPSIS
========

     use Net::Interface;
     
     $if = Net::Interface->new ("lo0");
     $if->mtu (1024);

     foreach (Net::Interface->interfaces ()) {print $_->name;}

DESCRIPTION
===========

   Net::Interface is designed to make the use of ifconfig(1) and friends
unnecessary from within Perl.  It provides methods to get at set all the
attributes of an interface, and even create new logical or physical
interfaces (if your O/S supports it).

AUTHOR
======

   Stephen Zander <gibreel@pobox.com>

SEE ALSO
========

   perl(1), ifconfig(8)


File: pm.info,  Node: Net/Jabber,  Next: Net/Jabber/Client,  Prev: Net/Interface,  Up: Module List

Jabber Perl Library
*******************

NAME
====

   Net::Jabber - Jabber Perl Library

SYNOPSIS
========

     Net::Jabber provides a Perl user with access to the Jabber
     Instant Messaging protocol.

     For more information about Jabber visit:
     
       http://www.jabber.org

DESCRIPTION
===========

     Net::Jabber is a convenient tool to use for any perl scripts
     that would like to utilize the Jabber Instant Messaging
     protocol.  While not a client in and of itself, it provides
     all of the necessary back-end functions to make a CGI client
     or command-line perl client feasible and easy to use.
     Net::Jabber is a wrapper around the rest of the official
     Net::Jabber::xxxxxx packages.

     There is an example script, client.pl, that provides you with
     an example a very simple Jabber client that logs a user in and
     displays any messages they receive.

     There is also an example transport script, transport.pl,
     that shows how to write a transport that gets a message,
     converts the entire message to uppercase, and send it back
     to the sender.

PACKAGES
========

     Net::Jabber::Client - this package contains the code needed to
     communicate with a Jabber server: login, wait for messages,
     send messages, and logout.  It uses XML::Stream to read the
     stream from the server and based on what kind of tag it
     encounters it calls a function to handle the tag.

     Net::Jabber::Component - this package contains the code needed
     to write a server component.  A component is a program tha handles
     the communication between a jabber server and some outside
     program or communications pacakge (IRC, talk, email, etc...)
     With this module you can write a full component in just
     a few lines of Perl.  It uses XML::Stream to communicate with
     its host server and based on what kind of tag it encounters it
     calls a function to handle the tag.  This replaces the Transport
     module as of the new Jabber server v1.1.2.

     Net::Jabber::Transport - *****REMOVED***** this package no
     longer exists.

     Net::Jabber::Protocol - a collection of high-level functions
     that Client and transport use to make their lives easier.
     These functions are included through AUTOLOAD and delegates.

     Net::Jabber::JID - the Jabber IDs consist of three parts:
     user id, server, and resource.  This module gives you access
     to those components without having to parse the string
     yourself.

     Net::Jabber::Message - everything needed to create and read
     a <message/> received from the server.

     Net::Jabber::Presence - everything needed to create and read
     a <presence/> received from the server.

     Net::Jabber::IQ - IQ is a wrapper around a number of modules
     that provide support for the various Info/Query namespaces that
     Jabber recognizes.

     Net::Jabber::Query - this module uses delegates and autoloading
     to provide access to all of the Query modules listed below.

     Net::Jabber::Query::Agent - provides access to the information
     about an agent that the server supports.

     Net::Jabber::Query::Agents - the list of agents, see agent above,
     that the server supports.

     Net::Jabber::Query::Auth - everything needed to authenticate a
     session to the server.

     Net::Jabber::Query::Fneg - feature negoation between the client
     and server.

     Net::Jabber::Query::Oob - support for out of bandwidth file
     transfers.

     Net::Jabber::Query::Register - everything needed to create a new
     Jabber account on the server.

     Net::Jabber::Query::Roster - everything needed to manage and query
     the server side Rosters.

     Net::Jabber::Query::Roster::Item - access to an item from the
     roster.

     Net::Jabber::Query::Time - exchange time information with the
     target recipient (either server or client).

     Net::Jabber::Query::Version - exchange version information with
     the target recipient (either server or client).

     Net::Jabber::X::Delay - specifies the delays that the message
     went through before begin delivered.

     Net::Jabber::X::Oob - out of bandwidth file transers.

     Net::Jabber::X::Roster - support for embedded roster items.

     Net::Jabber::X::Roster::Item - access to the item in a roster.

AUTHOR
======

   By Ryan Eatmon in May of 2000 for http://perl.jabber.org/

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Net/Jabber/Client,  Next: Net/Jabber/Component,  Prev: Net/Jabber,  Up: Module List

Jabber Client Library
*********************

NAME
====

   Net::Jabber::Client - Jabber Client Library

SYNOPSIS
========

     Net::Jabber::Client is a module that provides a developer easy access
     to the Jabber Instant Messaging protocol.

DESCRIPTION
===========

     Client.pm uses Protocol.pm to provide enough high level APIs and
     automation of the low level APIs that writing a Jabber Client in
     Perl is trivial.  For those that wish to work with the low level
     you can do that too, but those functions are covered in the
     documentation for each module.

     Net::Jabber::Client provides functions to connect to a Jabber server,
     login, send and receive messages, set personal information, create
     a new user account, manage the roster, and disconnect.  You can use
     all or none of the functions, there is no requirement.

     For more information on how the details for how Net::Jabber is written
     please see the help for Net::Jabber itself.

     For a full list of high level functions available please see
     Net::Jabber::Protocol.

Basic Functions
---------------

     use Net::Jabber;

     $Con = new Net::Jabber::Client();

     $Con->Connect(hostname=>"jabber.org");

     if ($Con->Connected()) {
       print "We are connected to the server...\n";
     }

     #
     # For the list of available function see Net::Jabber::Protocol.
     #

     $Con->Disconnect();

METHODS
=======

Basic Functions
---------------

     new(debuglevel=>0|1|2, - creates the Client object.  debugfile
         debugfile=>string,   should be set to the path for the debug
         debugtime=>0|1)      log to be written.  If set to "stdout"
                              then the debug will go there.  debuglevel
                              controls the amount of debug.  For more
                              information about the valid setting for
                              debuglevel, debugfile, and debugtime see
                              Net::Jabber::Debug.

     Connect(hostname=>string, - opens a connection to the server listed
     	    port=>integer)      in the host name value, on the port
                                 listed.  The defaults for the two are
     				localhost and 5222.

     Disconnect() - closes the connection to the server.

     Connected() - returns 1 if the Transport is connected to the server,
                   and 0 if not.

AUTHOR
======

   By Ryan Eatmon in May of 2000 for http://jabber.org.

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Net/Jabber/Component,  Next: Net/Jabber/Data,  Prev: Net/Jabber/Client,  Up: Module List

Jabber Component Library
************************

NAME
====

   Net::Jabber::Component - Jabber Component Library

SYNOPSIS
========

     Net::Jabber::Component is a module that provides a developer easy access
     to developing server components in the Jabber Instant Messaging protocol.

DESCRIPTION
===========

     Component.pm seeks to provide enough high level APIs and automation of
     the low level APIs that writing a Jabber Component in Perl is trivial.
     For those that wish to work with the low level you can do that too,
     but those functions are covered in the documentation for each module.

     Net::Jabber::Component provides functions to connect to a Jabber server,
     login, send and receive messages, set personal information, create
     a new user account, manage the roster, and disconnect.  You can use
     all or none of the functions, there is no requirement.

     For more information on how the details for how Net::Jabber is written
     please see the help for Net::Jabber itself.

     For a full list of high level functions available please see
     Net::Jabber::Protocol.

Basic Functions
---------------

     use Net::Jabber;

     $Con = new Net::Jabber::Component();

     $Con->Connect(hostname=>"jabber.org",
                   secret=>"foo");

     or

     $Con->Connect(connectiontype=>"exec");

     if ($Con->Connected()) {
       print "We are connected to the server...\n";
     }

     #
     # For the list of available function see Net::Jabber::Protocol.
     #

     $Con->Disconnect();

METHODS
=======

Basic Functions
---------------

     new(debuglevel=>0|1|2, - creates the Component object.  debugfile
         debugfile=>string,   should be set to the path for the debug
         debugtime=>0|1)      log to be written.  If set to "stdout"
                              then the debug will go there.  debuglevel
                              controls the amount of debug.  For more
                              information about the valid setting for
                              debuglevel, debugfile, and debugtime see
                              Net::Jabber::Debug.

     Connect(hostname=>string,       - opens a connection to the server
     	    port=>integer,            based on the value of connectiontype.
     	    secret=>string,           The two valid setings are:
     	    componentname=>string,      accept - TCP/IP remote connection
     	    connectiontype=>string)              (default)
                                         exec   - STDIN/OUT local connection
                                       If accept then it connects to the
                                       server listed in the hostname value,
                                       on the port listed.  The defaults
                                       for the two are localhost and 5222.
                                       The secret is the password needed
                                       to attach the hostname, and the
                                       componentname is the name that
                                       server and clients will know the
                                       component by (both used for security
                                       purposes).
                                       If exec then the module reads from
                                       STDIN and writes to STDOUT.  The
                                       server will start the script at run
                                       time and will restart the script if
                                       it exits or dies.  No secret is
                                       needed since this configuration is
                                       specified by the server admin and so
                                       it is assumed that they trust your
                                       script.

     Disconnect() - closes the connection to the server.

     Connected() - returns 1 if the Component is connected to the server,
                   and 0 if not.

AUTHOR
======

   By Ryan Eatmon in May of 2000 for http://jabber.org.

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Net/Jabber/Data,  Next: Net/Jabber/Data/Auth,  Prev: Net/Jabber/Component,  Up: Module List

Jabber Data Library
*******************

NAME
====

   Net::Jabber::Data - Jabber Data Library

SYNOPSIS
========

     Net::Jabber::Data is a companion to the Net::Jabber::XDB module. It
     provides the user a simple interface to set and retrieve all
     parts of a Jabber XDB Data.

DESCRIPTION
===========

     Net::Jabber::Data differs from the other Net::Jabber::* modules in that
     the XMLNS of the data is split out into more submodules under
     Data.  For specifics on each module please view the documentation
     for each Net::Jabber::Data::* module.  The available modules are:

     Net::Jabber::Data::Agent      - Agent Namespace
     Net::Jabber::Data::Agents     - Supported Agents list from server
     Net::Jabber::Data::Auth       - Simple Client Authentication
     Net::Jabber::Data::AutoUpdate - Auto-Update for clients
     Net::Jabber::Data::Filter     - Messaging Filter
     Net::Jabber::Data::Fneg       - Feature Negotiation
     Net::Jabber::Data::Oob        - Out of Bandwidth File Transfers
     Net::Jabber::Data::Register   - Registration requests
     Net::Jabber::Data::Roster     - Buddy List management
     Net::Jabber::Data::Search     - Searching User Directories
     Net::Jabber::Data::Time       - Client Time
     Net::Jabber::Data::Version    - Client Version

     Each of these modules provide Net::Jabber::Data with the functions
     to access the data.  By using delegates and the AUTOLOAD function
     the functions for each namespace is used when that namespace is
     active.

     To access a Data object you must create an XDB object and use the
     access functions there to get to the Data.  To initialize the XDB with
     a Jabber <xdb/> you must pass it the XML::Parser Tree array from the
     Net::Jabber::Client module.  In the callback function for the xdb
     you can access the data tag by doing the following:

     use Net::Jabber;

     sub xdbCB {
       my $xdb = new Net::Jabber::XDB(@_);
       my $data = $mesage->GetData();
       .
       .
       .
     }

     You now have access to all of the retrieval functions available.

     To create a new xdb to send to the server:

     use Net::Jabber;

     my $xdb = new Net::Jabber::XDB();
     $data = $xdb->NewData("jabber:xdb:register");

     Now you can call the creation functions for the Data as defined in the
     proper namespaces.  See below for the general <data/> functions, and
     in each data module for those functions.

     For more information about the array format being passed to the CallBack
     please read the Net::Jabber::Client documentation.

Retrieval functions
-------------------

     $xmlns     = $XDB->GetXMLNS();

     $str       = $XDB->GetXML();
     @xdb        = $XDB->GetTree();

Creation functions
------------------

     $Data->SetXMLNS("jabber:xdb:roster");

METHODS
=======

Retrieval functions
-------------------

     GetXMLNS() - returns a string with the namespace of the data that
                  the <xdb/> contains.

     GetXML() - returns the XML string that represents the <xdb/>. This
                is used by the Send() function in Client.pm to send
                this object as a Jabber XDB.

     GetTree() - returns an array that contains the <xdb/> tag in XML::Parser
                 Tree format.

Creation functions
------------------

     SetXMLNS(string) - sets the xmlns of the <data/> to the string.

CUSTOM Data MODULES
===================

     Part of the flexability of this module is that you can write your own
     module to handle a new namespace if you so choose.  The SetDelegates
     function is your way to register the xmlns and which module will
     provide the missing access functions.

     To register your namespace and module, you can either create an XDB
     object and register it once, or you can use the SetDelegates
     function in Client.pm to do it for you:

     my $Client = new Net::Jabber::Client();
     $Client->AddDelegate(namespace=>"blah:blah",
     			 parent=>"Net::Jabber::Data",
     			 delegate=>"Blah::Blah");
     
       or

     my $Transport = new Net::Jabber::Transport();
     $Transport->AddDelegate(namespace=>"blah:blah",
     			    parent=>"Net::Jabber::Data",
     			    delegate=>"Blah::Blah");

     Once you have the delegate registered you need to define the access
     functions.  Here is a an example module:

     package Blah::Blah;

     sub new {
       my $proto = shift;
       my $class = ref($proto) || $proto;
       my $self = { };
       $self->{VERSION} = $VERSION;
       bless($self, $proto);
       return $self;
     }

     sub SetBlah {
       shift;
       my $self = shift;
       my ($blah) = @_;
       return &Net::Jabber::SetXMLData("single",$self->{DATA},"blah","$blah",{});
     }

     sub GetBlah {
       shift;
       my $self = shift;
       return &Net::Jabber::GetXMLData("value",$self->{DATA},"blah","");
     }

     1;

     Now when you create a new Data object and call GetBlah on that object
     it will AUTOLOAD the above function and handle the request.

AUTHOR
======

   By Ryan Eatmon in May of 2000 for http://jabber.org..

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Net/Jabber/Data/Auth,  Next: Net/Jabber/Debug,  Prev: Net/Jabber/Data,  Up: Module List

Jabber XDB Authentication Module
********************************

NAME
====

   Net::Jabber::Data::Auth - Jabber XDB Authentication Module

SYNOPSIS
========

     Net::Jabber::Data::Auth is a companion to the Net::Jabber::Data module.
     It provides the user a simple interface to set and retrieve all parts
     of a Jabber Authentication data.

DESCRIPTION
===========

     To initialize the Data with a Jabber <xdb/> and then access the auth
     data you must pass it the XML::Parser Tree array from the
     Net::Jabber::Client module.  In the callback function for the xdb:

     use Net::Jabber;

     sub xdbCB {
       my $xdb = new Net::Jabber::XDB(@_);
       my $auth = $xdb->GetData();
       .
       .
       .
     }

     You now have access to all of the retrieval functions available.

     To create a new Data auth to send to the server:

     use Net::Jabber;

     $client = new Net::Jabber::Client();
     ...

     $xdb = new Net::Jabber::XDB();
     $auth = $xdb->NewData("jabber:xdb:auth");
     ...

     $client->Send($xdb);

     Using $auth you can call the creation functions below to populate the
     tag before sending it.

     For more information about the array format being passed to the CallBack
     please read the Net::Jabber::Client documentation.

Retrieval functions
-------------------

     $username = $auth->GetUsername();
     $password = $auth->GetPassword();
     $digest   = $auth->GetDigest();
     $resource = $auth->GetResource();

Creation functions
------------------

     $auth->SetAuth(resource=>'Anonymous');
     $auth->SetAuth(username=>'test',
                    password=>'user',
                    resource=>'Test Account');

     $auth->SetUsername('bob');
     $auth->SetPassword('bobrulez');
     $auth->SetDigest('');
     $auth->SetResource('Bob the Great');

Test functions
--------------

     $test = $auth->DefinedUsername();
     $test = $auth->DefinedPassword();
     $test = $auth->DefinedDigest();
     $test = $auth->DefinedResource();

METHODS
=======

Retrieval functions
-------------------

     GetUsername() - returns a string with the username in the <data/>.

     GetPassword() - returns a string with the password in the <data/>.

     GetDigest() - returns a string with the SHA-1 digest in the <data/>.

     GetResource() - returns a string with the resource in the <data/>.

Creation functions
------------------

     SetAuth(username=>string, - set multiple fields in the <xdb/> at one
             password=>string,   time.  This is a cumulative and over
             digest=>string,     writing action.  If you set the "username"
             resource=>string)   twice, the second setting is what is
                                 used.  If you set the password, and then
                                 set the resource then both will be in the
                                 <data/> tag.  For valid settings read
                                 the specific Set functions below.

     SetUsername(string) - sets the username for the account you are
                           trying to connect with.  Leave blank for
                           an anonymous account.

     SetPassword(string) - sets the password for the account you are
                           trying to connect with.  Leave blank for
                           an anonymous account.

     SetDigest(string) - sets the SHA-1 digest for the account you are
                         trying to connect with.  Leave blank for
                         an anonymous account.

     SetResource(string) - sets the resource for the account you are
                           trying to connect with.  Leave blank for
                           an anonymous account.

Test functions
--------------

     DefinedUsername() - returns 1 if <username/> exists in the <xdb/>,
                         0 otherwise.

     DefinedPassword() - returns 1 if <password/> exists in the <xdb/>,
                         0 otherwise.

     DefinedDigest() - returns 1 if <digest/> exists in the <xdb/>,
                       0 otherwise.

     DefinedResource() - returns 1 if <resource/> exists in the <xdb/>,
                         0 otherwise.

AUTHOR
======

   By Ryan Eatmon in July of 2000 for http://jabber.org..

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Net/Jabber/Debug,  Next: Net/Jabber/Dialback,  Prev: Net/Jabber/Data/Auth,  Up: Module List

Jabber Debug Library
********************

NAME
====

   Net::Jabber::Debug - Jabber Debug Library

SYNOPSIS
========

     Net::Jabber::Debug is a module that provides a developer easy access
     to logging debug information.

DESCRIPTION
===========

     Debug is a helper module for the Net::Jabber modules.  It provides
     the Net::Jabber modules with an object to control where, how, and
     what is logged.

Basic Functions
---------------

     $Debug = new Net::Jabber::Debug();

     $Debug->Init(level=>2,
     	         file=>"stdout",
       	         header=>"MyScript");

     $Debug->Log("Connection established");

METHODS
=======

Basic Functions
---------------

     new(hash) - creates the Debug object.  The hash argument is passed
                 to the Init function.  See that function description
                 below for the valid settings.

     Init(level=>integer,  - initializes the debug object.  The level
          file=>string,      determines the maximum level of debug
          header=>string,    messages to log:
          setdefault=>0|1,     0 - Base level Output (default)
          usedefault=>0|1,     1 - High level API calls
          time=>0|1)           2 - Low level API calls
                               ...
                               N - Whatever you want....
                             The file determines where the debug log
                             goes.  You can either specify a path to
                             a file, or "stdout" (the default).  "stdout"
                             tells Debug to send all of the debug info
                             sent to this object to go to stdout.
                             header is a string that will preappended
                             to the beginning of all log entries.  This
                             makes it easier to see what generated the
                             log entry (default is "Debug").
                             setdefault saves the current filehandle
                             and makes it available for other Debug
                             objects to use.  To use the default set
                             usedefault to 1.  The time parameter
                             specifies whether or not to add a timestamp
                             to the beginning of each logged line.

     LogN(array) - Logs the elements of the array at the corresponding
                   debug level N.  If you pass in a reference to an
                   array or hash then they are printed in a readable
                   way.  (ie... Log0, Log2, Log100, etc...)

EXAMPLE
=======

     $Debug = new Net::Jabber:Debug(level=>2,
                                    header=>"Example");

     $Debug->Log0("test");

     $Debug->Log2("level 2 test");

     $hash{a} = "atest";
     $hash{b} = "btest";

     $Debug->Log1("hashtest",\%hash);

     You would get the following log:

     Example: test
     Example: level 2 test
     Example: hashtest { a=>"atest" b=>"btest" }

     If you has set the level to 1 instead of 2 you would get:

     Example: test
     Example: hashtest { a=>"atest" b=>"btest" }

AUTHOR
======

   By Ryan Eatmon in May of 2000 for http://jabber.org.

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Net/Jabber/Dialback,  Next: Net/Jabber/Dialback/Result,  Prev: Net/Jabber/Debug,  Up: Module List

Jabber Dialback Module
**********************

NAME
====

   Net::Jabber::Dialback - Jabber Dialback Module

SYNOPSIS
========

     Net::Jabber::Dialback is a companion to the Net::Jabber::Server
     module.  It provides the user a simple interface to set and retrieve
     all parts of a Jabber Server Dialback.

DESCRIPTION
===========

     To initialize the Dialback with a Jabber <db:*/> you must pass it
     the XML::Parser Tree array.  For example:

     my $dialback = new Net::Jabber::Dialback(@tree);

     There has been a change from the old way of handling the callbacks.
     You no longer have to do the above, a Net::Jabber::Dialback object
     is passed to the callback function for the message:

     use Net::Jabber;

     sub dialback {
       my ($DB) = @_;
       .
       .
       .
     }

     You now have access to all of the retrieval functions available.

     To create a new message to send to the server:

     use Net::Jabber;

     $DB = new Net::Jabber::Dialback("verify");
     $DB = new Net::Jabber::Dialback("result");

     Please see the specific documentation for Net::Jabber::Dialback::Result
     and Net::Jabber::Dialback::Verify

     For more information about the array format being passed to the
     CallBack please read the Net::Jabber::Client documentation.

AUTHOR
======

   By Ryan Eatmon in January of 2001 for http://jabber.org..

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


