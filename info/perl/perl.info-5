This is Info file perl.info, produced by Makeinfo version 1.68 from the
input file bigperl.texi.

   settitle perl


File: perl.info,  Node: perldbmfilter,  Next: perlcompile,  Prev: perlfilter,  Up: Top

Perl DBM Filters
****************

NAME
====

   perldbmfilter - Perl DBM Filters

SYNOPSIS
========

     $db = tie %hash, 'DBM', ...

     $old_filter = $db->filter_store_key  ( sub { ... } ) ;
     $old_filter = $db->filter_store_value( sub { ... } ) ;
     $old_filter = $db->filter_fetch_key  ( sub { ... } ) ;
     $old_filter = $db->filter_fetch_value( sub { ... } ) ;

DESCRIPTION
===========

   The four `filter_*' methods shown above are available in all the DBM
modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File,
ODBM_File and SDBM_File.

   Each of the methods work identically, and are used to install (or
uninstall) a single DBM Filter. The only difference between them is the
place that the filter is installed.

   To summarise:

filter_store_key
     If a filter has been installed with this method, it will be invoked
     every time you write a key to a DBM database.

filter_store_value
     If a filter has been installed with this method, it will be invoked
     every time you write a value to a DBM database.

filter_fetch_key
     If a filter has been installed with this method, it will be invoked
     every time you read a key from a DBM database.

filter_fetch_value
     If a filter has been installed with this method, it will be invoked
     every time you read a value from a DBM database.

   You can use any combination of the methods from none to all four.

   All filter methods return the existing filter, if present, or undef in
not.

   To delete a filter pass undef to it.

The Filter
----------

   When each filter is called by Perl, a local copy of $_ will contain the
key or value to be filtered. Filtering is achieved by modifying the
contents of $_. The return code from the filter is ignored.

An Example - the NULL termination problem.
------------------------------------------

   DBM Filters are useful for a class of problems where you always want to
make the same transformation to all keys, all values or both.

   For example, consider the following scenario. You have a DBM database
that you need to share with a third-party C application. The C application
assumes that all keys and values are NULL terminated. Unfortunately when
Perl writes to DBM databases it doesn't use NULL termination, so your Perl
application will have to manage NULL termination itself. When you write to
the database you will have to use something like this:

     $hash{"$key\0"} = "$value\0" ;

   Similarly the NULL needs to be taken into account when you are
considering the length of existing keys/values.

   It would be much better if you could ignore the NULL terminations issue
in the main application code and have a mechanism that automatically added
the terminating NULL to all keys and values whenever you write to the
database and have them removed when you read from the database. As I'm
sure you have already guessed, this is a problem that DBM Filters can fix
very easily.

     use strict ;
     use warnings ;
     use SDBM_File ;
     use Fcntl ;

     my %hash ;
     my $filename = "/tmp/filt" ;
     unlink $filename ;

     my $db = tie(%hash, 'SDBM_File', $filename, O_RDWR|O_CREAT, 0640)
       or die "Cannot open $filename: $!\n" ;

     # Install DBM Filters
     $db->filter_fetch_key  ( sub { s/\0$//    } ) ;
     $db->filter_store_key  ( sub { $_ .= "\0" } ) ;
     $db->filter_fetch_value(
         sub { no warnings 'uninitialized' ;s/\0$// } ) ;
     $db->filter_store_value( sub { $_ .= "\0" } ) ;

     $hash{"abc"} = "def" ;
     my $a = $hash{"ABC"} ;
     # ...
     undef $db ;
     untie %hash ;

   The code above uses SDBM_File, but it will work with any of the DBM
modules.

   Hopefully the contents of each of the filters should be
self-explanatory. Both "fetch" filters remove the terminating NULL, and
both "store" filters add a terminating NULL.

Another Example - Key is a C int.
---------------------------------

   Here is another real-life example. By default, whenever Perl writes to
a DBM database it always writes the key and value as strings. So when you
use this:

     $hash{12345} = "soemthing" ;

   the key 12345 will get stored in the DBM database as the 5 byte string
"12345". If you actually want the key to be stored in the DBM database as
a C int, you will have to use pack when writing, and unpack when reading.

   Here is a DBM Filter that does it:

     use strict ;
     use warnings ;
     use DB_File ;
     my %hash ;
     my $filename = "/tmp/filt" ;
     unlink $filename ;

     my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH
       or die "Cannot open $filename: $!\n" ;

     $db->filter_fetch_key  ( sub { $_ = unpack("i", $_) } ) ;
     $db->filter_store_key  ( sub { $_ = pack ("i", $_) } ) ;
     $hash{123} = "def" ;
     # ...
     undef $db ;
     untie %hash ;

   The code above uses DB_File, but again it will work with any of the DBM
modules.

   This time only two filters have been used - we only need to manipulate
the contents of the key, so it wasn't necessary to install any value
filters.

SEE ALSO
========

   *Note DB_File: (pm.info)DB_File,, `GDBM_File' in this node, *Note
NDBM_File: (pm.info)NDBM_File,, *Note ODBM_File: (pm.info)ODBM_File, and
*Note SDBM_File: (pm.info)SDBM_File,.

AUTHOR
======

   Paul Marquess


File: perl.info,  Node: perldebguts,  Next: perlxs,  Prev: perlapio,  Up: Top

Guts of Perl debugging
**********************

NAME
====

   perldebguts - Guts of Perl debugging

DESCRIPTION
===========

   This is not the perldebug(1) manpage, which tells you how to use the
debugger.  This manpage describes low-level details ranging between
difficult and impossible for anyone who isn't incredibly intimate with
Perl's guts to understand.  Caveat lector.

Debugger Internals
==================

   Perl has special debugging hooks at compile-time and run-time used to
create debugging environments.  These hooks are not to be confused with
the *perl -Dxxx* command described in *Note Perlrun: perlrun,, which are
usable only if a special Perl built per the instructions the INSTALL
podpage in the Perl source tree.

   For example, whenever you call Perl's built-in caller function from the
package DB, the arguments that the corresponding stack frame was called
with are copied to the the @DB::args array.  The general mechanisms is
enabled by calling Perl with the -d switch, the following additional
features are enabled (cf. `$^P', *Note Perlvar: perlvar,):

   * Perl inserts the contents of `$ENV{PERL5DB}' (or `BEGIN {require
     'perl5db.pl'}' if not present) before the first line of your program.

   * The array `@{"_<$filename"}' holds the lines of $filename for all
     files compiled by Perl.  The same for evaled strings that contain
     subroutines, or which are currently being executed.  The $filename
     for evaled strings looks like `(eval 34)'.   Code assertions in
     regexes look like `(re_eval 19)'.

   * The hash `%{"_<$filename"}' contains breakpoints and actions keyed by
     line number.  Individual entries (as opposed to the whole hash) are
     settable.  Perl only cares about Boolean true here, although the
     values used by `perl5db.pl' have the form
     `"$break_condition\0$action"'.  Values in this hash are magical in
     numeric context: they are zeros if the line is not breakable.

     The same holds for evaluated strings that contain subroutines, or
     which are currently being executed.  The $filename for evaled strings
     looks like `(eval 34)' or  `(re_eval 19)'.

   * The scalar `${"_<$filename"}' contains `"_<$filename"'.  This is also
     the case for evaluated strings that contain subroutines, or which are
     currently being executed.  The $filename for evaled strings looks
     like `(eval 34)' or `(re_eval 19)'.

   * After each required file is compiled, but before it is executed,
     `DB::postponed(*{"_<$filename"})' is called if the subroutine
     `DB::postponed' exists.  Here, the $filename is the expanded name of
     the required file, as found in the values of %INC.

   * After each subroutine `subname' is compiled, the existence of
     `$DB::postponed{subname}' is checked.  If this key exists,
     `DB::postponed(subname)' is called if the `DB::postponed' subroutine
     also exists.

   * A hash %DB::sub is maintained, whose keys are subroutine names and
     whose values have the form `filename:startline-endline'.  filename
     has the form `(eval 34)' for subroutines defined inside evals, or
     `(re_eval 19)' for those within regex code assertions.

   * When the execution of your program reaches a point that can hold a
     breakpoint, the `DB::DB()' subroutine is called any of the variables
     $DB::trace, $DB::single, or $DB::signal is true.  These variables are
     not localizable.  This feature is disabled when executing inside
     `DB::DB()', including functions called from it unless `< $^D &
     (1<<30) '> is true.

   * When execution of the program reaches a subroutine call, a call to
     `&DB::sub'(args) is made instead, with $DB::sub holding the name of
     the called subroutine.  This doesn't happen if the subroutine was
     compiled in the DB package.)

   Note that if `&DB::sub' needs external data for it to work, no
subroutine call is possible until this is done.  For the standard
debugger, the  `$DB::deep' variable (how many levels of recursion deep
into the debugger you can go before a mandatory break) gives an example of
such a dependency.

Writing Your Own Debugger
-------------------------

   The minimal working debugger consists of one line

     sub DB::DB {}

   which is quite handy as contents of PERL5DB environment variable:

     $ PERL5DB="sub DB::DB {}" perl -d your-script

   Another brief debugger, slightly more useful, could be created with
only the line:

     sub DB::DB {print ++$i; scalar <STDIN>}

   This debugger would print the sequential number of encountered
statement, and would wait for you to hit a newline before continuing.

   The following debugger is quite functional:

     {
       package DB;
       sub DB  {}
       sub sub {print ++$i, " $sub\n"; &$sub}
     }

   It prints the sequential number of subroutine call and the name of the
called subroutine.  Note that `&DB::sub' should be compiled into the
package DB.

   At the start, the debugger reads your rc file (`./.perldb' or
`~/.perldb' under Unix), which can set important options.  This file may
define a subroutine `&afterinit' to be executed after the debugger is
initialized.

   After the rc file is read, the debugger reads the PERLDB_OPTS
environment variable and parses this as the remainder of a `O ...'  line
as one might enter at the debugger prompt.

   The debugger also maintains magical internal variables, such as
`@DB::dbline', %DB::dbline, which are aliases for `@{"::_<current_file"}'
`%{"::_<current_file"}'.  Here `current_file' is the currently selected
file, either explicitly chosen with the debugger's f command, or
implicitly by flow of execution.

   Some functions are provided to simplify customization.  See
`"Options"', *Note Perldebug: perldebug, for description of options parsed
by `DB::parse_options(string)'.  The function `DB::dump_trace(skip[,
count])' skips the specified number of frames and returns a list
containing information about the calling frames (all of them, if count is
missing).  Each entry is reference to a a hash with keys context (either
., `$', or `@'), sub (subroutine name, or info about eval), args (undef or
a reference to an array), file, and line.

   The function `DB::print_trace(FH, skip[, count[, short]])' prints
formatted info about caller frames.  The last two functions may be
convenient as arguments to `< < '>, `< << '> commands.

   Note that any variables and functions that are not documented in this
manpages (or in *Note Perldebug: perldebug,) are considered for internal
use only, and as such are subject to change without notice.

Frame Listing Output Examples
=============================

   The frame option can be used to control the output of frame
information.  For example, contrast this expression trace:

     $ perl -de 42
     Stack dump during die enabled outside of evals.

     Loading DB routines from perl5db.pl patch level 0.94
     Emacs support available.

     Enter h or `h h' for help.

     main::(-e:1):   0
       DB<1> sub foo { 14 }

     DB<2> sub bar { 3 }

     DB<3> t print foo() * bar()
      main::((eval 172):3):   print foo() + bar();
      main::foo((eval 168):2):
      main::bar((eval 170):2):
      42

   with this one, once the Option `frame=2' has been set:

     DB<4> O f=2
                  frame = '2'
     DB<5> t print foo() * bar()
      3:      foo() * bar()
      entering main::foo
       2:     sub foo { 14 };
      exited main::foo
      entering main::bar
       2:     sub bar { 3 };
      exited main::bar
      42

   By way of demonstration, we present below a laborious listing resulting
from setting your `PERLDB_OPTS' environment variable to the value `f=n N',
and running *perl -d -V* from the command line.  Examples use various
values of n are shown to give you a feel for the difference between
settings.  Long those it may be, this is not a complete listing, but only
excerpts.

  1.      entering main::BEGIN
           entering Config::BEGIN
            Package lib/Exporter.pm.
            Package lib/Carp.pm.
           Package lib/Config.pm.
           entering Config::TIEHASH
           entering Exporter::import
            entering Exporter::export
          entering Config::myconfig
           entering Config::FETCH
           entering Config::FETCH
           entering Config::FETCH
           entering Config::FETCH

  2.      entering main::BEGIN
           entering Config::BEGIN
            Package lib/Exporter.pm.
            Package lib/Carp.pm.
           exited Config::BEGIN
           Package lib/Config.pm.
           entering Config::TIEHASH
           exited Config::TIEHASH
           entering Exporter::import
            entering Exporter::export
            exited Exporter::export
           exited Exporter::import
          exited main::BEGIN
          entering Config::myconfig
           entering Config::FETCH
           exited Config::FETCH
           entering Config::FETCH
           exited Config::FETCH
           entering Config::FETCH

  3.      in  $=main::BEGIN() from /dev/null:0
           in  $=Config::BEGIN() from lib/Config.pm:2
            Package lib/Exporter.pm.
            Package lib/Carp.pm.
           Package lib/Config.pm.
           in  $=Config::TIEHASH('Config') from lib/Config.pm:644
           in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
            in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from li
          in  @=Config::myconfig() from /dev/null:0
           in  $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
           in  $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
           in  $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
           in  $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from lib/Config.pm:574
           in  $=Config::FETCH(ref(Config), 'osname') from lib/Config.pm:574
           in  $=Config::FETCH(ref(Config), 'osvers') from lib/Config.pm:574

  4.      in  $=main::BEGIN() from /dev/null:0
           in  $=Config::BEGIN() from lib/Config.pm:2
            Package lib/Exporter.pm.
            Package lib/Carp.pm.
           out $=Config::BEGIN() from lib/Config.pm:0
           Package lib/Config.pm.
           in  $=Config::TIEHASH('Config') from lib/Config.pm:644
           out $=Config::TIEHASH('Config') from lib/Config.pm:644
           in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
            in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/
            out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/
           out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
          out $=main::BEGIN() from /dev/null:0
          in  @=Config::myconfig() from /dev/null:0
           in  $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
           out $=Config::FETCH(ref(Config), 'package') from lib/Config.pm:574
           in  $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
           out $=Config::FETCH(ref(Config), 'baserev') from lib/Config.pm:574
           in  $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
           out $=Config::FETCH(ref(Config), 'PERL_VERSION') from lib/Config.pm:574
           in  $=Config::FETCH(ref(Config), 'PERL_SUBVERSION') from lib/Config.pm:574

  5.      in  $=main::BEGIN() from /dev/null:0
           in  $=Config::BEGIN() from lib/Config.pm:2
            Package lib/Exporter.pm.
            Package lib/Carp.pm.
           out $=Config::BEGIN() from lib/Config.pm:0
           Package lib/Config.pm.
           in  $=Config::TIEHASH('Config') from lib/Config.pm:644
           out $=Config::TIEHASH('Config') from lib/Config.pm:644
           in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
            in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/E
            out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/E
           out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
          out $=main::BEGIN() from /dev/null:0
          in  @=Config::myconfig() from /dev/null:0
           in  $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from lib/Config.pm:574
           out $=Config::FETCH('Config=HASH(0x1aa444)', 'package') from lib/Config.pm:574
           in  $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from lib/Config.pm:574
           out $=Config::FETCH('Config=HASH(0x1aa444)', 'baserev') from lib/Config.pm:574

  6.      in  $=CODE(0x15eca4)() from /dev/null:0
           in  $=CODE(0x182528)() from lib/Config.pm:2
            Package lib/Exporter.pm.
           out $=CODE(0x182528)() from lib/Config.pm:0
           scalar context return from CODE(0x182528): undef
           Package lib/Config.pm.
           in  $=Config::TIEHASH('Config') from lib/Config.pm:628
           out $=Config::TIEHASH('Config') from lib/Config.pm:628
           scalar context return from Config::TIEHASH:   empty hash
           in  $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
            in  $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/Exporter.pm:171
            out $=Exporter::export('Config', 'main', 'myconfig', 'config_vars') from lib/Exporter.pm:171
            scalar context return from Exporter::export: ''
           out $=Exporter::import('Config', 'myconfig', 'config_vars') from /dev/null:0
           scalar context return from Exporter::import: ''

        In all cases shown above, the line indentation shows the call tree.
If bit 2 of frame is set, a line is printed on exit from a subroutine as
well.  If bit 4 is set, the arguments are printed along with the caller
info.  If bit 8 is set, the arguments are printed even if they are tied or
references.  If bit 16 is set, the return value is printed, too.

   When a package is compiled, a line like this

     Package lib/Carp.pm.

   is printed with proper indentation.

Debugging regular expressions
=============================

   There are two ways to enable debugging output for regular expressions.

   If your perl is compiled with `-DDEBUGGING', you may use the *-Dr* flag
on the command line.

   Otherwise, one can `use re 'debug'', which has effects at compile time
and run time.  It is not lexically scoped.

Compile-time output
-------------------

   The debugging output at compile time looks like this:

     compiling RE `[bc]d(ef*g)+h[ij]k$'
     size 43 first at 1
        1: ANYOF(11)
       11: EXACT <d>(13)
       13: CURLYX {1,32767}(27)
       15:   OPEN1(17)
       17:     EXACT <e>(19)
       19:     STAR(22)
       20:       EXACT <f>(0)
       22:     EXACT <g>(24)
       24:   CLOSE1(26)
       26:   WHILEM(0)
       27: NOTHING(28)
       28: EXACT <h>(30)
       30: ANYOF(40)
       40: EXACT <k>(42)
       42: EOL(43)
       43: END(0)
     anchored `de' at 1 floating `gh' at 3..2147483647 (checking floating)
     				    stclass `ANYOF' minlen 7

   The first line shows the pre-compiled form of the regex.  The second
shows the size of the compiled form (in arbitrary units, usually 4-byte
words) and the label id of the first node that does a match.

   The last line (split into two lines above) contains optimizer
information.  In the example shown, the optimizer found that the match
should contain a substring `de' at offset 1, plus substring `gh' at some
offset between 3 and infinity.  Moreover, when checking for these
substrings (to abandon impossible matches quickly), Perl will check for
the substring `gh' before checking for the substring `de'.  The optimizer
may also use the knowledge that the match starts (at the first id) with a
character class, and the match cannot be shorter than 7 chars.

   The fields of interest which may appear in the last line are

`anchored' STRING at *POS*
`floating' STRING at *POS1..POS2*
     See above.

`matching floating/anchored'
     Which substring to check first.

minlen
     The minimal length of the match.

`stclass' TYPE
     Type of first matching node.

`noscan'
     Don't scan for the found substrings.

`isall'
     Means that the optimizer info is all that the regular expression
     contains, and thus one does not need to enter the regex engine at all.

`GPOS'
     Set if the pattern contains `\G'.

plus
     Set if the pattern starts with a repeated char (as in `x+y').

`implicit'
     Set if the pattern starts with `.*'.

`with eval'
     Set if the pattern contain eval-groups, such as `(?{ code })' and
     `(??{ code })'.

`anchored(TYPE)'
     If the pattern may match only at a handful of places, (with TYPE
     being BOL, `MBOL', or `GPOS'.  See the table below.

   If a substring is known to match at end-of-line only, it may be
followed by `$', as in `floating `k'$'.

   The optimizer-specific info is used to avoid entering (a slow) regex
engine on strings that will not definitely match.  If `isall' flag is set,
a call to the regex engine may be avoided even when the optimizer found an
appropriate place for the match.

   The rest of the output contains the list of *nodes* of the compiled
form of the regex.  Each line has format

   `   'id: TYPE *OPTIONAL-INFO* (*next-id*)

Types of nodes
--------------

   Here are the possible types, with short descriptions:

     # TYPE arg-description [num-args] [longjump-len] DESCRIPTION

     # Exit points
     END		no	End of program.
     SUCCEED	no	Return from a subroutine, basically.

     # Anchors:
     BOL		no	Match "" at beginning of line.
     MBOL	no	Same, assuming multiline.
     SBOL	no	Same, assuming singleline.
     EOS		no	Match "" at end of string.
     EOL		no	Match "" at end of line.
     MEOL	no	Same, assuming multiline.
     SEOL	no	Same, assuming singleline.
     BOUND	no	Match "" at any word boundary
     BOUNDL	no	Match "" at any word boundary
     NBOUND	no	Match "" at any word non-boundary
     NBOUNDL	no	Match "" at any word non-boundary
     GPOS	no	Matches where last m//g left off.

     # [Special] alternatives
     ANY		no	Match any one character (except newline).
     SANY	no	Match any one character.
     ANYOF	sv	Match character in (or not in) this class.
     ALNUM	no	Match any alphanumeric character
     ALNUML	no	Match any alphanumeric char in locale
     NALNUM	no	Match any non-alphanumeric character
     NALNUML	no	Match any non-alphanumeric char in locale
     SPACE	no	Match any whitespace character
     SPACEL	no	Match any whitespace char in locale
     NSPACE	no	Match any non-whitespace character
     NSPACEL	no	Match any non-whitespace char in locale
     DIGIT	no	Match any numeric character
     NDIGIT	no	Match any non-numeric character

     # BRANCH	The set of branches constituting a single choice are hooked
     #		together with their "next" pointers, since precedence prevents
     #		anything being concatenated to any individual branch.  The
     #		"next" pointer of the last BRANCH in a choice points to the
     #		thing following the whole choice.  This is also where the
     #		final "next" pointer of each individual branch points; each
     #		branch starts with the operand node of a BRANCH node.
     #
     BRANCH	node	Match this alternative, or the next...

     # BACK	Normal "next" pointers all implicitly point forward; BACK
     #		exists to make loop structures possible.
     # not used
     BACK	no	Match "", "next" ptr points backward.

     # Literals
     EXACT	sv	Match this string (preceded by length).
     EXACTF	sv	Match this string, folded (prec. by length).
     EXACTFL	sv	Match this string, folded in locale (w/len).

     # Do nothing
     NOTHING	no	Match empty string.
     # A variant of above which delimits a group, thus stops optimizations
     TAIL	no	Match empty string. Can jump here from outside.

     # STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
     #		BRANCH structures using BACK.  Simple cases (one character
     #		per match) are implemented with STAR and PLUS for speed
     #		and to minimize recursive plunges.
     #
     STAR	node	Match this (simple) thing 0 or more times.
     PLUS	node	Match this (simple) thing 1 or more times.

     CURLY	sv 2	Match this simple thing {n,m} times.
     CURLYN	no 2	Match next-after-this simple thing
     #			{n,m} times, set parens.
     CURLYM	no 2	Match this medium-complex thing {n,m} times.
     CURLYX	sv 2	Match this complex thing {n,m} times.

     # This terminator creates a loop structure for CURLYX
     WHILEM	no	Do curly processing and see if rest matches.

     # OPEN,CLOSE,GROUPP	...are numbered at compile time.
     OPEN	num 1	Mark this point in input as start of #n.
     CLOSE	num 1	Analogous to OPEN.

     REF		num 1	Match some already matched string
     REFF	num 1	Match already matched string, folded
     REFFL	num 1	Match already matched string, folded in loc.

     # grouping assertions
     IFMATCH	off 1 2	Succeeds if the following matches.
     UNLESSM	off 1 2	Fails if the following matches.
     SUSPEND	off 1 1	"Independent" sub-regex.
     IFTHEN	off 1 1	Switch, should be preceded by switcher .
     GROUPP	num 1	Whether the group matched.

     # Support for long regex
     LONGJMP	off 1 1	Jump far away.
     BRANCHJ	off 1 1	BRANCH with long offset.

     # The heavy worker
     EVAL	evl 1	Execute some Perl code.

     # Modifiers
     MINMOD	no	Next operator is not greedy.
     LOGICAL	no	Next opcode should set the flag only.

     # This is not used yet
     RENUM	off 1 1	Group with independently numbered parens.

     # This is not really a node, but an optimized away piece of a "long" node.
     # To simplify debugging output, we mark it as if it were a node
     OPTIMIZED	off	Placeholder for dump.

Run-time output
---------------

   First of all, when doing a match, one may get no run-time output even
if debugging is enabled.  This means that the regex engine was never
entered and that all of the job was therefore done by the optimizer.

   If the regex engine was entered, the output may look like this:

     Matching `[bc]d(ef*g)+h[ij]k$' against `abcdefg__gh__'
       Setting an EVAL scope, savestack=3
        2 <ab> <cdefg__gh_>    |  1: ANYOF
        3 <abc> <defg__gh_>    | 11: EXACT <d>
        4 <abcd> <efg__gh_>    | 13: CURLYX {1,32767}
        4 <abcd> <efg__gh_>    | 26:   WHILEM
     				0 out of 1..32767  cc=effff31c
        4 <abcd> <efg__gh_>    | 15:     OPEN1
        4 <abcd> <efg__gh_>    | 17:     EXACT <e>
        5 <abcde> <fg__gh_>    | 19:     STAR
     			     EXACT <f> can match 1 times out of 32767...
       Setting an EVAL scope, savestack=3
        6 <bcdef> <g__gh__>    | 22:       EXACT <g>
        7 <bcdefg> <__gh__>    | 24:       CLOSE1
        7 <bcdefg> <__gh__>    | 26:       WHILEM
     				    1 out of 1..32767  cc=effff31c
       Setting an EVAL scope, savestack=12
        7 <bcdefg> <__gh__>    | 15:         OPEN1
        7 <bcdefg> <__gh__>    | 17:         EXACT <e>
          restoring \1 to 4(4)..7
     				    failed, try continuation...
        7 <bcdefg> <__gh__>    | 27:         NOTHING
        7 <bcdefg> <__gh__>    | 28:         EXACT <h>
     				    failed...
     				failed...

   The most significant information in the output is about the particular
node of the compiled regex that is currently being tested against the
target string.  The format of these lines is

   `    '*STRING-OFFSET* <*PRE-STRING*> <*POST-STRING*>   |ID:  TYPE

   The TYPE info is indented with respect to the backtracking level.
Other incidental information appears interspersed within.

Debugging Perl memory usage
===========================

   Perl is a profligate wastrel when it comes to memory use.  There is a
saying that to estimate memory usage of Perl, assume a reasonable
algorithm for memory allocation, multiply that estimate by 10, and while
you still may miss the mark, at least you won't be quite so astonished.
This is not absolutely true, but may prvide a good grasp of what happens.

   Assume that an integer cannot take less than 20 bytes of memory, a
float cannot take less than 24 bytes, a string cannot take less than 32
bytes (all these examples assume 32-bit architectures, the result are
quite a bit worse on 64-bit architectures).  If a variable is accessed in
two of three different ways (which require an integer, a float, or a
string), the memory footprint may increase yet another 20 bytes.  A sloppy
malloc(3) implementation can make inflate these numbers dramatically.

   On the opposite end of the scale, a declaration like

     sub foo;

   may take up to 500 bytes of memory, depending on which release of Perl
you're running.

   Anecdotal estimates of source-to-compiled code bloat suggest an
eightfold increase.  This means that the compiled form of reasonable
(normally commented, properly indented etc.) code will take about eight
times more space in memory than the code took on disk.

   There are two Perl-specific ways to analyze memory usage:
$ENV{PERL_DEBUG_MSTATS} and *-DL* command-line switch.  The first is
available only if Perl is compiled with Perl's malloc(); the second only
if Perl was built with `-DDEBUGGING'.  See the instructions for how to do
this in the INSTALL podpage at the top level of the Perl source tree.

Using `$ENV{PERL_DEBUG_MSTATS}'
-------------------------------

   If your perl is using Perl's malloc() and was compiled with the
necessary switches (this is the default), then it will print memory usage
statistics after compiling your code hwen `< $ENV{PERL_DEBUG_MSTATS} ' 1
>>, and before termination of the program when `< $ENV{PERL_DEBUG_MSTATS}
'= 1 >>.  The report format is similar to the following example:

     $ PERL_DEBUG_MSTATS=2 perl -e "require Carp"
     Memory allocation statistics after compilation: (buckets 4(4)..8188(8192)
        14216 free:   130   117    28     7     9   0   2     2   1 0 0
     		437    61    36     0     5
        60924 used:   125   137   161    55     7   8   6    16   2 0 1
     		 74   109   304    84    20
     Total sbrk(): 77824/21:119. Odd ends: pad+heads+chain+tail: 0+636+0+2048.
     Memory allocation statistics after execution:   (buckets 4(4)..8188(8192)
        30888 free:   245    78    85    13     6   2   1     3   2 0 1
     		315   162    39    42    11
       175816 used:   265   176  1112   111    26  22  11    27   2 1 1
     		196   178  1066   798    39
     Total sbrk(): 215040/47:145. Odd ends: pad+heads+chain+tail: 0+2192+0+6144.

   It is possible to ask for such a statistic at arbitrary points in your
execution using the mstats() function out of the standard Devel::Peek
module.

   Here is some explanation of that format:

`buckets SMALLEST(APPROX)..GREATEST(APPROX)'
     Perl's malloc() uses bucketed allocations.  Every request is rounded
     up to the closest bucket size available, and a bucket is taken from
     the pool of buckets of that size.

     The line above describes the limits of buckets currently in use.
     Each bucket has two sizes: memory footprint and the maximal size of
     user data that can fit into this bucket.  Suppose in the above
     example that the smallest bucket were size 4.  The biggest bucket
     would have usable size 8188, and the memory footprint would be 8192.

     In a Perl built for debugging, some buckets may have negative usable
     size.  This means that these buckets cannot (and will not) be used.
     For larger buckets, the memory footprint may be one page greater than
     a power of 2.  If so, case the corresponding power of two is printed
     in the `APPROX' field above.

Free/Used
     The 1 or 2 rows of numbers following that correspond to the number of
     buckets of each size between `SMALLEST' and `GREATEST'.  In the first
     row, the sizes (memory footprints) of buckets are powers of two-or
     possibly one page greater.  In the second row, if present, the memory
     footprints of the buckets are between the memory footprints of two
     buckets "above".

     For example, suppose under the pervious example, the memory footprints
     were

          free:    8     16    32    64    128  256 512 1024 2048 4096 8192
          	   4     12    24    48    80

     With non-DEBUGGING perl, the buckets starting from 128 have a 4-byte
     overhead, and thus a 8192-long bucket may take up to 8188-byte
     allocations.

`Total sbrk(): SBRKed/SBRKs:CONTINUOUS'
     The first two fields give the total amount of memory perl sbrk(2)ed
     (ess-broken? :-) and number of sbrk(2)s used.  The third number is
     what perl thinks about continuity of returned chunks.  So long as
     this number is positive, malloc() will assume that it is probable
     that sbrk(2) will provide continuous memory.

     Memory allocated by external libraries is not counted.

`pad: 0'
     The amount of sbrk(2)ed memory needed to keep buckets aligned.

`heads: 2192'
     Although memory overhead of bigger buckets is kept inside the bucket,
     for smaller buckets, it is kept in separate areas.  This field gives
     the total size of these areas.

`chain: 0'
     malloc() may want to subdivide a bigger bucket into smaller buckets.
     If only a part of the deceased bucket is left unsubdivided, the rest
     is kept as an element of a linked list.  This field gives the total
     size of these chunks.

`tail: 6144'
     To minimize the number of sbrk(2)s, malloc() asks for more memory.
     This field gives the size of the yet unused part, which is sbrk(2)ed,
     but never touched.

Example of using *-DL* switch
-----------------------------

   Below we show how to analyse memory usage by

     do 'lib/auto/POSIX/autosplit.ix';

   The file in question contains a header and 146 lines similar to

     sub getcwd;

   WARNING: The discussion below supposes 32-bit architecture.  In newer
releases of Perl, memory usage of the constructs discussed here is greatly
improved, but the story discussed below is a real-life story.  This story
is mercilessly terse, and assumes rather more than cursory knowledge of
Perl internals.  Type space to continue, `q' to quit.  (Actually, you just
want to skip to the next section.)

   Here is the itemized list of Perl allocations performed during parsing
of this file:

     !!! "after" at test.pl line 3.
        Id  subtot   4   8  12  16  20  24  28  32  36  40  48  56  64  72  80 80+
      0 02   13752   .   .   .   . 294   .   .   .   .   .   .   .   .   .   .   4
      0 54    5545   .   .   8 124  16   .   .   .   1   1   .   .   .   .   .   3
      5 05      32   .   .   .   .   .   .   .   1   .   .   .   .   .   .   .   .
      6 02    7152   .   .   .   .   .   .   .   .   .   . 149   .   .   .   .   .
      7 02    3600   .   .   .   .   . 150   .   .   .   .   .   .   .   .   .   .
      7 03      64   .  -1   .   1   .   .   2   .   .   .   .   .   .   .   .   .
      7 04    7056   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   7
      7 17   38404   .   .   .   .   .   .   .   1   .   . 442 149   .   . 147   .
      9 03    2078  17 249  32   .   .   .   .   2   .   .   .   .   .   .   .   .

   To see this list, insert two `warn('!...')' statements around the call:

     warn('!');
     do 'lib/auto/POSIX/autosplit.ix';
     warn('!!! "after"');

   and run it with PErl's *-DL* option.  The first warn() will print
memory allocation info before parsing the file and will memorize the
statistics at this point (we ignore what it prints).  The second warn()
prints increments with respect to these memorized data.  This is the
printout shown above.

   Different Ids on the left correspond to different subsystems of the
perl interpreter.  They are just the first argument given to the perl
memory allocation API named New().  To find what `9 03' means, just grep
the perl source for `903'.  You'll find it in `util.c', function
savepvn().  (I know, you wonder why we told you to grep and then gave away
the answer.  That's because grepping the source is good for the soul.)
This function is used to store a copy of an existing chunk of memory.
Using a C debugger, one can see that the function was called either
directly from gv_init() or via sv_magic(), and that gv_init() is called
from gv_fetchpv()-which was itself called from newSUB().  Please stop to
catch your breath now.

   NOTE: To reach this point in the debugger and skip the calls to
savepvn() during the compilation of the main program, you should set a C
breakpoint in Perl_warn(), continue until this point is reached, and
*then* set a C breakpoint in Perl_savepvn().  Note that you may need to
skip a handful of Perl_savepvn() calls that do not correspond to mass
production of CVs (there are more `903' allocations than 146 similar lines
of `lib/auto/POSIX/autosplit.ix').  Note also that Perl_ prefixes are
added by macroization code in perl header files to avoid conflicts with
external libraries.

   Anyway, we see that `903' ids correspond to creation of globs, twice
per glob - for glob name, and glob stringification magic.

   Here are explanations for other Ids above:

`717'
     CReates bigger `XPV*' structures.  In the case above, it creates 3
     AVs per subroutine, one for a list of lexical variable names, one for
     a scratchpad (which contains lexical variables and targets), and one
     for the array of scratchpads needed for recursion.

     It also creates a GV and a CV per subroutine, all called from
     start_subparse().

`002'
     Creates a C array corresponding to the AV of scratchpads and the
     scratchpad itself.  The first fake entry of this scratchpad is
     created though the subroutine itself is not defined yet.

     It also creates C arrays to keep data for the stash.  This is one HV,
     but it grows; thus, there are 4 big allocations: the big chunks are
     not freed, but are kept as additional arenas for SV allocations.

`054'
     Creates a `HEK' for the name of the glob for the subroutine.  This
     name is a key in a stash.

     Big allocations with this Id correspond to allocations of new arenas
     to keep `HE'.

`602'
     Creates a `GP' for the glob for the subroutine.

`702'
     Creates the MAGIC for the glob for the subroutine.

`704'
     Creates *arenas* which keep SVs.

*-DL* details
-------------

   If Perl is run with *-DL* option, then warn()s that start with `!'
behave specially.  They print a list of categories of memory allocations,
and statistics of allocations of different sizes for these categories.

   If warn() string starts with

`!!!'
     print changed categories only, print the differences in counts of
     allocations.

!!
     print grown categories only; print the absolute values of counts, and
     totals.

!
     print nonempty categories, print the absolute values of counts and
     totals.

Limitations of *-DL* statistics
-------------------------------

   If an extension or external library does not use the Perl API to
allocate memory, such allocations are not counted.

SEE ALSO
========

   *Note Perldebug: perldebug,, *Note Perlguts: perlguts,, *Note Perlrun:
perlrun, *Note Re: (pm.info)re,, and `Devel::Dprof' in this node.


File: perl.info,  Node: perldebug,  Next: perldiag,  Prev: perlcompile,  Up: Top

Perl debugging
**************

NAME
====

   perldebug - Perl debugging

DESCRIPTION
===========

   First of all, have you tried using the -w switch?

The Perl Debugger
=================

   If you invoke Perl with the -d switch, your script runs under the Perl
source debugger.  This works like an interactive Perl environment,
prompting for debugger commands that let you examine source code, set
breakpoints, get stack backtraces, change the values of variables, etc.
This is so convenient that you often fire up the debugger all by itself
just to test out Perl constructs interactively to see what they do.  For
example:

     $ perl -d -e 42

   In Perl, the debugger is not a separate program the way it usually is
in the typical compiled environment.  Instead, the -d flag tells the
compiler to insert source information into the parse trees it's about to
hand off to the interpreter.  That means your code must first compile
correctly for the debugger to work on it.  Then when the interpreter
starts up, it preloads a special Perl library file containing the debugger.

   The program will halt *right before* the first run-time executable
statement (but see below regarding compile-time statements) and ask you to
enter a debugger command.  Contrary to popular expectations, whenever the
debugger halts and shows you a line of code, it always displays the line
it's *about* to execute, rather than the one it has just executed.

   Any command not recognized by the debugger is directly executed
(eval'd) as Perl code in the current package.  (The debugger uses the DB
package for keeping its own state information.)

   For any text entered at the debugger prompt, leading and trailing
whitespace is first stripped before further processing.  If a debugger
command coincides with some function in your own program, merely precede
the function with something that doesn't look like a debugger command, such
as a leading `;' or perhaps a +, or by wrapping it with parentheses or
braces.

Debugger Commands
-----------------

   The debugger understands the following commands:

h [command]
     Prints out a help message.

     If you supply another debugger command as an argument to the h
     command, it prints out the description for just that command.  The
     special argument of `h h' produces a more compact help listing,
     designed to fit together on one screen.

     If the output of the h command (or any command, for that matter)
     scrolls past your screen, precede the command with a leading pipe
     symbol so that it's run through your pager, as in

          DB> |h

     You may change the pager which is used via `O pager=...' command.

p expr
     Same as `print {$DB::OUT} expr' in the current package.  In
     particular, because this is just Perl's own print function, this
     means that nested data structures and objects are not dumped, unlike
     with the x command.

     The `DB::OUT' filehandle is opened to `/dev/tty', regardless of where
     STDOUT may be redirected to.

x expr
     Evaluates its expression in list context and dumps out the result in
     a pretty-printed fashion.  Nested data structures are printed out
     recursively, unlike the real print function in Perl.  See *Note
     Dumpvalue: (pm.info)Dumpvalue, if you'd like to do this yourself.

     The output format is governed by multiple options described under
     `"Options"' in this node.

V [pkg [vars]]
     Display all (or some) variables in package (defaulting to main) using
     a data pretty-printer (hashes show their keys and values so you see
     what's what, control characters are made printable, etc.).  Make sure
     you don't put the type specifier (like `$') there, just the symbol
     names, like this:

          V DB filename line

     Use `~pattern' and `!pattern' for positive and negative regexes.

     This is similar to calling the x command on each applicable var.

X [vars]
     Same as `V currentpackage [vars]'.

T
     Produce a stack backtrace.  See below for details on its output.

s [expr]
     Single step.  Executes until the beginning of another statement,
     descending into subroutine calls.  If an expression is supplied that
     includes function calls, it too will be single-stepped.

n [expr]
     Next.  Executes over subroutine calls, until the beginning of the
     next statement.  If an expression is supplied that includes function
     calls, those functions will be executed with stops before each
     statement.

r
     Continue until the return from the current subroutine.  Dump the
     return value if the `PrintRet' option is set (default).

<CR>
     Repeat last n or s command.

c [line|sub]
     Continue, optionally inserting a one-time-only breakpoint at the
     specified line or subroutine.

l
     List next window of lines.

l min+incr
     List `incr+1' lines starting at min.

l min-max
     List lines min through max.  `l -' is synonymous to -.

l line
     List a single line.

l subname
     List first window of lines from subroutine.  *subname* may be a
     variable that contains a code reference.

-
     List previous window of lines.

w [line]
     List window (a few lines) around the current line.

.
     Return the internal debugger pointer to the line last executed, and
     print out that line.

f filename
     Switch to viewing a different file or eval statement.  If filename is
     not a full pathname found in the values of %INC, it is considered a
     regex.

     evaled strings (when accessible) are considered to be filenames: `f
     (eval 7)' and `f eval 7\b' access the body of the 7th evaled string
     (in the order of execution).  The bodies of the currently executed
     eval and of evaled strings that define subroutines are saved and thus
     accessible.

/pattern/
     Search forwards for pattern (a Perl regex); final / is optional.

?pattern?
     Search backwards for pattern; final ? is optional.

L
     List all breakpoints and actions.

S [[!]regex]
     List subroutine names [not] matching the regex.

t
     Toggle trace mode (see also the `AutoTrace' option).

t expr
     Trace through execution of `expr'.  See `"Frame Listing Output
     Examples"', *Note Perldebguts: perldebguts, for examples.

b [line] [condition]
     Set a breakpoint before the given line.  If line is omitted, set a
     breakpoint on the line about to be executed.  If a condition is
     specified, it's evaluated each time the statement is reached: a
     breakpoint is taken only if the condition is true.  Breakpoints may
     only be set on lines that begin an executable statement.  Conditions
     don't use if:

          b 237 $x > 30
          b 237 ++$count237 < 11
          b 33 /pattern/i

b subname [condition]
     Set a breakpoint before the first line of the named subroutine.
     *subname* may be a variable containing a code reference (in this case
     condition is not supported).

b postpone subname [condition]
     Set a breakpoint at first line of subroutine after it is compiled.

b load filename
     Set a breakpoint before the first executed line of the filename,
     which should be a full pathname found amongst the %INC values.

b compile subname
     Sets a breakpoint before the first statement executed after the
     specified subroutine is compiled.

d [line]
     Delete a breakpoint from the specified line.  If line is omitted,
     deletes the breakpoint from the line about to be executed.

D
     Delete all installed breakpoints.

a [line] command
     Set an action to be done before the line is executed.  If line is
     omitted, set an action on the line about to be executed.  The
     sequence of steps taken by the debugger is

          1. check for a breakpoint at this line
          2. print the line if necessary (tracing)
          3. do any actions associated with that line
          4. prompt user if at a breakpoint or in single-step
          5. evaluate line

     For example, this will print out $foo every time line 53 is passed:

          a 53 print "DB FOUND $foo\n"

a [line]
     Delete an action from the specified line.  If line is omitted, delete
     the action on the line that is about to be executed.

A
     Delete all installed actions.

W expr
     Add a global watch-expression.  We hope you know what one of these
     is, because they're supposed to be obvious.  WARNING: It is far too
     easy to destroy your watch expressions by accidentally omitting the
     *expr*.

W
     Delete all watch-expressions.

O booloption ...
     Set each listed Boolean option to the value 1.

O anyoption? ...
     Print out the value of one or more options.

O option=value ...
     Set the value of one or more options.  If the value has internal
     whitespace, it should be quoted.  For example, you could set `O
     pager="less -MQeicsNfr"' to call less with those specific options.
     You may use either single or double quotes, but if you do, you must
     escape any embedded instances of same sort of quote you began with,
     as well as any escaping any escapes that immediately precede that
     quote but which are not meant to escape the quote itself.  In other
     words, you follow single-quoting rules irrespective of the quote; eg:
     `O option='this isn\'t bad'' or `O option="She said, \"Isn't it?\""'.

     For historical reasons, the `=value' is optional, but defaults to 1
     only where it is safe to do so-that is, mostly for Boolean options.
     It is always better to assign a specific value using =.  The option
     can be abbreviated, but for clarity probably should not be.  Several
     options can be set together.  See `"Options"' in this node for a list
     of these.

< ?
     List out all pre-prompt Perl command actions.

< [ command ]
     Set an action (Perl command) to happen before every debugger prompt.
     A multi-line command may be entered by backslashing the newlines.
     WARNING If command is missing, all actions are wiped out!

<< command
     Add an action (Perl command) to happen before every debugger prompt.
     A multi-line command may be entered by backwhacking the newlines.

> ?
     List out post-prompt Perl command actions.

> command
     Set an action (Perl command) to happen after the prompt when you've
     just given a command to return to executing the script.  A multi-line
     command may be entered by backslashing the newlines (we bet you
     couldn't've guessed this by now).  WARNING If command is missing, all
     actions are wiped out!

>> command
     Adds an action (Perl command) to happen after the prompt when you've
     just given a command to return to executing the script.  A multi-line
     command may be entered by slackbashing the newlines.

{ ?
     List out pre-prompt debugger commands.

{ [ command ]
     Set an action (debugger command) to happen before every debugger
     prompt.  A multi-line command may be entered in the customary fashion.
     WARNING If command is missing, all actions are wiped out!

     Because this command is in some senses new, a warning is issued if
     you appear to have accidentally entered a block instead.  If that's
     what you mean to do, write it as with `;{ ... }' or even `do { ... }'.

{{ command
     Add an action (debugger command) to happen before every debugger
     prompt.  A multi-line command may be entered, if you can guess how:
     see above.

! number
     Redo a previous command (defaults to the previous command).

! -number
     Redo number'th previous command.

! pattern
     Redo last command that started with pattern.  See `O recallCommand',
     too.

!! cmd
     Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT) See `O
     shellBang', also.  Note that the user's current shell (well, their
     `$ENV{SHELL}' variable) will be used, which can interfere with proper
     interpretation of exit status or signal and coredump information.

H -number
     Display last n commands.  Only commands longer than one character are
     listed.  If number is omitted, list them all.

q or ^D
     Quit.  ("quit" doesn't work for this, unless you've made an alias)
     This is the only supported way to exit the debugger, though typing
     exit twice might work.

     Set the `inhibit_exit' option to 0 if you want to be able to step off
     the end the script.  You may also need to set $finished to 0 if you
     want to step through global destruction.

R
     Restart the debugger by exec()ing a new session.  We try to maintain
     your history across this, but internal settings and command-line
     options may be lost.

     The following setting are currently preserved: history, breakpoints,
     actions, debugger options, and the Perl command-line options -w, -I,
     and -e.

|dbcmd
     Run the debugger command, piping DB::OUT into your current pager.

||dbcmd
     Same as |dbcmd but DB::OUT is temporarily selected as well.

= [alias value]
     Define a command alias, like

          = quit q

     or list current aliases.

command
     Execute command as a Perl statement.  A trailing semicolon will be
     supplied.  If the Perl statement would otherwise be confused for a
     Perl debugger, use a leading semicolon, too.

m expr
     List which methods may be called on the result of the evaluated
     expression.  The expression may evaluated to a reference to a blessed
     object, or to a package name.

man [manpage]
     Despite its name, this calls your system's default documentation
     viewer on the given page, or on the viewer itself if *manpage* is
     omitted.  If that viewer is man, the current Config information is
     used to invoke man using the proper MANPATH or -M *manpath* option.
     Failed lookups of the form XXX that match known manpages of the form
     *perlXXX* will be retried.  This lets you type `man debug' or `man
     op' from the debugger.

     On systems traditionally bereft of a usable man command, the debugger
     invokes perldoc.  Occasionally this determination is incorrect due to
     recalcitrant vendors or rather more felicitously, to enterprising
     users.  If you fall into either category, just manually set the
     $DB::doccmd variable to whatever viewer to view the Perl
     documentation on your system.  This may be set in an rc file, or
     through direct assignment.  We're still waiting for a working example
     of something along the lines of:

          $DB::doccmd = 'netscape -remote http://something.here/';

Configurable Options
--------------------

   The debugger has numerous options settable using the O command, either
interactively or from the environment or an rc file.

`recallCommand', `ShellBang'
     The characters used to recall command or spawn shell.  By default,
     both are set to !, which is unfortunate.

`pager'
     Program to use for output of pager-piped commands (those beginning
     with a | character.)  By default, `$ENV{PAGER}' will be used.
     Because the debugger uses your current terminal characteristics for
     bold and underlining, if the chosen pager does not pass escape
     sequences through unchanged, the output of some debugger commands
     will not be readable when sent through the pager.

`tkRunning'
     Run Tk while prompting (with ReadLine).

`signalLevel', `warnLevel', `dieLevel'
     Level of verbosity.  By default, the debugger leaves your exceptions
     and warnings alone, because altering them can break correctly running
     programs.  It will attempt to print a message when uncaught INT, BUS,
     or SEGV signals arrive.  (But see the mention of signals in `BUGS' in
     this node below.)

     To disable this default safe mode, set these values to something
     higher than 0.  At a level of 1, you get backtraces upon receiving
     any kind of warning (this is often annoying) or exception (this is
     often valuable).  Unfortunately, the debugger cannot discern fatal
     exceptions from non-fatal ones.  If `dieLevel' is even 1, then your
     non-fatal exceptions are also traced and unceremoniously altered if
     they came from `eval'd' strings or from any kind of eval within
     modules you're attempting to load.  If `dieLevel' is 2, the debugger
     doesn't care where they came from:  It usurps your exception handler
     and prints out a trace, then modifies all exceptions with its own
     embellishments.  This may perhaps be useful for some tracing
     purposes, but tends to hopelessly destroy any program that takes its
     exception handling seriously.

`AutoTrace'
     Trace mode (similar to t command, but can be put into `PERLDB_OPTS').

`LineInfo'
     File or pipe to print line number info to.  If it is a pipe (say,
     `|visual_perl_db'), then a short message is used.  This is the
     mechanism used to interact with a slave editor or visual debugger,
     such as the special `vi' or emacs hooks, or the `ddd' graphical
     debugger.

`inhibit_exit'
     If 0, allows *stepping off* the end of the script.

`PrintRet'
     Print return value after r command if set (default).

`ornaments'
     Affects screen appearance of the command line (see *Note
     Term/ReadLine: (pm.info)Term/ReadLine,).  There is currently no way
     to disable these, which can render some output illegible on some
     displays, or with some pagers.  This is considered a bug.

frame
     Affects the printing of messages upon entry and exit from
     subroutines.  If `frame & 2' is false, messages are printed on entry
     only. (Printing on exit might be useful if interspersed with other
     messages.)

     If `frame & 4', arguments to functions are printed, plus context and
     caller info.  If `frame & 8', overloaded stringify and tied FETCH is
     enabled on the printed arguments.  If `frame & 16', the return value
     from the subroutine is printed.

     The length at which the argument list is truncated is governed by the
     next option:

`maxTraceLen'
     Length to truncate the argument list when the frame option's bit 4 is
     set.

   The following options affect what happens with V, X, and x commands:

`arrayDepth', `hashDepth'
     Print only first N elements (" for all).

compactDump, veryCompact
     Change the style of array and hash output.  If compactDump, short
     array may be printed on one line.

`globPrint'
     Whether to print contents of globs.

`DumpDBFiles'
     Dump arrays holding debugged files.

`DumpPackages'
     Dump symbol tables of packages.

`DumpReused'
     Dump contents of "reused" addresses.

quote, `HighBit', `undefPrint'
     Change the style of string dump.  The default value for quote is
     `auto'; one can enable double-quotish or single-quotish format by
     setting it to `"' or `'', respectively.  By default, characters with
     their high bit set are printed verbatim.

`UsageOnly'
     Rudimentary per-package memory usage dump.  Calculates total size of
     strings found in variables in the package.  This does not include
     lexicals in a module's file scope, or lost in closures.

   During startup, options are initialized from `$ENV{PERLDB_OPTS}'.  You
may place the initialization options `TTY', `noTTY', ReadLine, and
`NonStop' there.

   If your rc file contains:

     parse_options("NonStop=1 LineInfo=db.out AutoTrace");

   then your script will run without human intervention, putting trace
information into the file *db.out*.  (If you interrupt it, you'd better
reset `LineInfo' to `/dev/tty' if you expect to see anything.)

`TTY'
     The TTY to use for debugging I/O.

`noTTY'
     If set, the debugger goes into `NonStop' mode and will not connect to
     a TTY.  If interrupted (or if control goes to the debugger via
     explicit setting of $DB::signal or $DB::single from the Perl script),
     it connects to a TTY specified in the `TTY' option at startup, or to
     a tty found at runtime using the `Term::Rendezvous' module of your
     choice.

     This module should implement a method named new that returns an object
     with two methods: IN and `OUT'.  These should return filehandles to
     use for debugging input and output correspondingly.  The new method
     should inspect an argument containing the value of
     `$ENV{PERLDB_NOTTY}' at startup, or `"/tmp/perldbtty$$"' otherwise.
     This file is not inspected for proper ownership, so security hazards
     are theoretically possible.

ReadLine
     If false, readline support in the debugger is disabled in order to
     debug applications that themselves use ReadLine.

`NonStop'
     If set, the debugger goes into non-interactive mode until
     interrupted, or programmatically by setting $DB::signal or
     $DB::single.

   Here's an example of using the `$ENV{PERLDB_OPTS}' variable:

     $ PERLDB_OPTS="NonStop frame=2" perl -d myprogram

   That will run the script *myprogram* without human intervention,
printing out the call tree with entry and exit points.  Note that
`NonStop=1 frame=2' is equivalent to `N f=2', and that originally, options
could be uniquely abbreviated by the first letter (modulo the `Dump*'
options).  It is nevertheless recommended that you always spell them out
in full for legibility and future compatibility.

   Other examples include

     $ PERLDB_OPTS="NonStop frame=2" perl -d myprogram

   which runs script non-interactively, printing info on each entry into a
subroutine and each executed line into the file named `listing'.  (If you
interrupt it, you would better reset `LineInfo' to something
"interactive"!)

   Other examples include (using standard shell syntax to show environment
variable settings):

     $ ( PERLDB_OPTS="NonStop frame=1 AutoTrace LineInfo=tperl.out"
         perl -d myprogram )

   which may be useful for debugging a program that uses Term::ReadLine
itself.  Do not forget to detach your shell from the TTY in the window that
corresponds to `/dev/ttyXX', say, by issuing a command like

     $ sleep 1000000

   See `"Debugger Internals"', *Note Perldebguts: perldebguts, for details.

Debugger input/output
---------------------

Prompt
     The debugger prompt is something like

          DB<8>

     or even

          DB<<17>>

     where that number is the command number, and which you'd use to
     access with the built-in *csh*-like history mechanism.  For example,
     `!17' would repeat command number 17.  The depth of the angle
     brackets indicates the nesting depth of the debugger.  You could get
     more than one set of brackets, for example, if you'd already at a
     breakpoint and then printed the result of a function call that itself
     has a breakpoint, or you step into an expression via `s/n/t
     expression' command.

Multiline commands
     If you want to enter a multi-line command, such as a subroutine
     definition with several statements or a format, escape the newline
     that would normally end the debugger command with a backslash.
     Here's an example:

          DB<1> for (1..4) {         \
          cont:     print "ok\n";   \
          cont: }
          ok
          ok
          ok
          ok

     Note that this business of escaping a newline is specific to
     interactive commands typed into the debugger.

Stack backtrace
     Here's an example of what a stack backtrace via T command might look
     like:

          $ = main::infested called from file `Ambulation.pm' line 10
          @ = Ambulation::legs(1, 2, 3, 4) called from file `camel_flea' line 7
          $ = main::pests('bactrian', 4) called from file `camel_flea' line 4

     The left-hand character up there indicates the context in which the
     function was called, with `$' and `@' meaning scalar or list contexts
     respectively, and . meaning void context (which is actually a sort of
     scalar context).  The display above says that you were in the
     function `main::infested' when you ran the stack dump, and that it
     was called in scalar context from line 10 of the file
     *Ambulation.pm*, but without any arguments at all, meaning it was
     called as `&infested'.  The next stack frame shows that the function
     `Ambulation::legs' was called in list context from the *camel_flea*
     file with four arguments.  The last stack frame shows that
     `main::pests' was called in scalar context, also from *camel_flea*,
     but from line 4.

     If you execute the T command from inside an active use statement, the
     backtrace will contain both a require frame and an eval) frame.

Line Listing Format
     This shows the sorts of output the l command can produce:

          DB<<13>> l
            101:                @i{@i} = ();
            102:b               @isa{@i,$pack} = ()
            103                     if(exists $i{$prevpack} || exists $isa{$pack});
            104             }
            105
            106             next
            107==>              if(exists $isa{$pack});
            108
            109:a           if ($extra-- > 0) {
            110:                %isa = ($pack,1);

     Breakable lines are marked with :.  Lines with breakpoints are marked
     by b and those with actions by a.  The line that's about to be
     executed is marked by `< ==' >>.

Frame listing
     When the frame option is set, the debugger would print entered (and
     optionally exited) subroutines in different styles.  See *Note
     Perldebguts: perldebguts, for incredibly long examples of these.

Debugging compile-time statements
---------------------------------

   If you have compile-time executable statements (such as code within
BEGIN and CHECK blocks or use statements), these will not be stopped by
debugger, although requires and INIT blocks will, and compile-time
statements can be traced with `AutoTrace' option set in `PERLDB_OPTS').
From your own Perl code, however, you can transfer control back to the
debugger using the following statement, which is harmless if the debugger
is not running:

     $DB::single = 1;

   If you set $DB::single to 2, it's equivalent to having just typed the n
command, whereas a value of 1 means the s command.  The $DB::trace
variable should be set to 1 to simulate having typed the t command.

   Another way to debug compile-time code is to start the debugger, set a
breakpoint on the load of some module:

     DB<7> b load f:/perllib/lib/Carp.pm
       Will stop on load of `f:/perllib/lib/Carp.pm'.

   and then restart the debugger using the R command (if possible).  One
can use `b compile subname' for the same purpose.

Debugger Customization
----------------------

   The debugger probably contains enough configuration hooks that you
won't ever have to modify it yourself.  You may change the behaviour of
debugger from within the debugger using its O command, from the command
line via the `PERLDB_OPTS' environment variable, and from customization
files.

   You can do some customization by setting up a `.perldb' file, which
contains initialization code.  For instance, you could make aliases like
these (the last one is one people expect to be there):

     $DB::alias{'len'}  = 's/^len(.*)/p length($1)/';
     $DB::alias{'stop'} = 's/^stop (at|in)/b/';
     $DB::alias{'ps'}   = 's/^ps\b/p scalar /';
     $DB::alias{'quit'} = 's/^quit(\s*)/exit/';

   You can change options from `.perldb' by using calls like this one;

     parse_options("NonStop=1 LineInfo=db.out AutoTrace=1 frame=2");

   The code is executed in the package DB.  Note that `.perldb' is
processed before processing `PERLDB_OPTS'.  If `.perldb' defines the
subroutine `afterinit', that function is called after debugger
initialization ends.  `.perldb' may be contained in the current directory,
or in the home directory.  Because this file is sourced in by Perl and may
contain arbitrary commands, for security reasons, it must be owned by the
superuser or the current user, and writable by no one but its owner.

   If you want to modify the debugger, copy `perl5db.pl' from the Perl
library to another name and hack it to your heart's content.  You'll then
want to set your PERL5DB environment variable to say something like this:

     BEGIN { require "myperl5db.pl" }

   As a last resort, you could also use PERL5DB to customize the debugger
by directly setting internal variables or calling debugger functions.

   Note that any variables and functions that are not documented in this
document (or in *Note Perldebguts: perldebguts,) are considered for
internal use only, and as such are subject to change without notice.

Readline Support
----------------

   As shipped, the only command-line history supplied is a simplistic one
that checks for leading exclamation points.  However, if you install the
Term::ReadKey and Term::ReadLine modules from CPAN, you will have full
editing capabilities much like GNU readline(3) provides.  Look for these
in the `modules/by-module/Term' directory on CPAN.  These do not support
normal *vi* command-line editing, however.

   A rudimentary command-line completion is also available.
Unfortunately, the names of lexical variables are not available for
completion.

Editor Support for Debugging
----------------------------

   If you have the FSF's version of emacs installed on your system, it can
interact with the Perl debugger to provide an integrated software
development environment reminiscent of its interactions with C debuggers.

   Perl comes with a start file for making emacs act like a
syntax-directed editor that understands (some of) Perl's syntax.  Look in
the emacs directory of the Perl source distribution.

   A similar setup by Tom Christiansen for interacting with any
vendor-shipped *vi* and the X11 window system is also available.  This
works similarly to the integrated multiwindow support that emacs provides,
where the debugger drives the editor.  At the time of this writing,
however, that tool's eventual location in the Perl distribution was
uncertain.

   Users of *vi* should also look into *vim* and *gvim*, the mousey and
windy version, for coloring of Perl keywords.

   Note that only perl can truly parse Perl, so all such CASE tools fall
somewhat short of the mark, especially if you don't program your Perl as a
C programmer might.

The Perl Profiler
-----------------

   If you wish to supply an alternative debugger for Perl to run, just
invoke your script with a colon and a package argument given to the -d
flag.  The most popular alternative debuggers for Perl is the Perl
profiler.  Devel::DProf is now included with the standard Perl
distribution.  To profile your Perl program in the file `mycode.pl', just
type:

     $ perl -d:DProf mycode.pl

   When the script terminates the profiler will dump the profile
information to a file called `tmon.out'.  A tool like dprofpp, also
supplied with the standard Perl distribution, can be used to interpret the
information in that profile.

Debugging regular expressions
=============================

   `use re 'debug'' enables you to see the gory details of how the Perl
regular expression engine works.  In order to understand this typically
voluminous output, one must not only have some idea about about how
regular expression matching works in general, but also know how Perl's
regular expressions are internally compiled into an automaton.  These
matters are explored in some detail in `"Debugging regular expressions"',
*Note Perldebguts: perldebguts,.

Debugging memory usage
======================

   Perl contains internal support for reporting its own memory usage, but
this is a fairly advanced concept that requires some understanding of how
memory allocation works.  See `"Debugging Perl memory usage"', *Note
Perldebguts: perldebguts, for the details.

SEE ALSO
========

   You did try the -w switch, didn't you?

   *Note Perldebguts: perldebguts,, *Note Re: (pm.info)re,, *Note DB:
(pm.info)DB,, `Devel::Dprof' in this node, `dprofpp' in this node, *Note
Dumpvalue: (pm.info)Dumpvalue,, and *Note Perlrun: perlrun,.

BUGS
====

   You cannot get stack frame information or in any fashion debug functions
that were not compiled by Perl, such as those from C or C++ extensions.

   If you alter your @_ arguments in a subroutine (such as with shift or
pop, the stack backtrace will not show the original values.

   The debugger does not currently work in conjunction with the -W
command-line switch, because it itself is not free of warnings.

   If you're in a slow syscall (like waiting, accepting, or reading from
your keyboard or a socket) and haven't set up your own `$SIG{INT}'
handler, then you won't be able to CTRL-C your way back to the debugger,
because the debugger's own `$SIG{INT}' handler doesn't understand that it
needs to raise an exception to longjmp(3) out of slow syscalls.


