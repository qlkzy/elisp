This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: CGI/Lite,  Next: CGI/Log,  Prev: CGI/Imagemap,  Up: Module List

Perl module to process and decode WWW forms and cookies.
********************************************************

NAME
====

   CGI::Lite - Perl module to process and decode WWW forms and cookies.

SYNOPSIS
========

     use CGI::Lite;

     $cgi = new CGI::Lite;

     $cgi->set_platform ($platform);
     
         where $platform can be one of (case insensitive):
         Unix, Windows, Windows95, DOS, NT, PC, Mac or Macintosh

     $cgi->set_file_type ('handle' or 'file');
     $cgi->add_timestamp (0, 1 or 2);

     where 0 = no timestamp
           1 = timestamp all files (default)
           2 = timestamp only if file exists

     $cgi->filter_filename (\&subroutine);

     $size = $cgi->set_buffer_size ($some_buffer_size);

     $status = $cgi->set_directory ('/some/dir');
     $cgi->set_directory ('/some/dir') || die "Directory doesn't exist.\n";

     $cgi->close_all_files;

     $cgi->add_mime_type ('application/mac-binhex40');
     $status = $cgi->remove_mime_type ('application/mac-binhex40');
     @list = $cgi->get_mime_types;

     $form = $cgi->parse_form_data;
     %form = $cgi->parse_form_data;

     or

     $form = $cgi->parse_form_data ('GET', 'HEAD' or 'POST');

     $cookies = $cgi->parse_cookies;
     %cookies = $cgi->parse_cookies;

     $status  = $cgi->is_error;
     $message = $cgi->get_error_message;

     $cgi->return_error ('error 1', 'error 2', ...);

     $keys = $cgi->get_ordered_keys;
     @keys = $cgi->get_ordered_keys;

     $cgi->print_data;

     $cgi->print_form_data;   (deprecated as of v1.8)
     $cgi->print_cookie_data; (deprecated as of v1.8)

     $new_string = $cgi->wrap_textarea ($string, $length);

     @all_values = $cgi->get_multiple_values ($reference);

     $cgi->create_variables (\%form);
     $cgi->create_variables ($form);

     $escaped_string = browser_escape ($string);

     $encoded_string = url_encode ($string);
     $decoded_string = url_decode ($string);

     $status = is_dangerous ($string);
     $safe_string = escape_dangerous_chars ($string);

DESCRIPTION
===========

   You can use this module to decode form and query information, including
file uploads, as well as cookies in a very simple manner; you need not
concern yourself with the actual details behind the decoding process.

METHODS
=======

   Here are the methods you can use to process your forms and cookies:

parse_form_data
     This will handle the following types of requests: GET, HEAD and POST.
     By default, CGI::Lite uses the environment variable REQUEST_METHOD to
     determine the manner in which the query/form information should be
     decoded. However, as of v1.8, you are allowed to pass a valid request
     method to this function to force CGI::Lite to decode the information
     in a specific manner.

     For multipart/form-data, uploaded files are stored in the user
     selected directory (see set_directory). If timestamp mode is on (see
     add_timestamp), the files are named in the following format:

          timestamp__filename

     where the filename is specified in the "Content-disposition" header.
     NOTE:, the browser URL encodes the name of the file. This module
     makes no effort to decode the information for security reasons.
     However, you can do so by creating a subroutine and then using the
     filter_filename method.

     *Return Value*

     Returns either a hash or a reference to the hash, which contains all
     of the key/value pairs. For fields that contain file information, the
     value contains either the path to the file, or the filehandle (see
     the set_file_type method).

parse_new_form_data
     As for parse_form_data, but clears the CGI object state before
     processing the request. This is useful in persistant application
     (e.g. FCGI), where the CGI object is reused for multiple requests.
     e.g.

          $CGI = new CGI::Lite;
          while (FCGI::accept > 0)
          {
          	$Query = $CGI->parse_new_form_data();
          	<process query>
          }

parse_cookies
     Decodes and parses cookies passed by the browser. This method works in
     much the same manner as parse_form_data.

is_error
     As of v1.8, errors in parsing are handled differently. You can use
     this method to check for any potential errors after you've called
     either parse_form_data or parse_cookies.

     *Return Value*

          0 Success
          1 Failure

get_error_message
     If an error occurs when parsing form/query information or cookies, you
     can use this method to retrieve the error message. Remember, you can
     check for errors by calling the is_error method.

     *Return Value*

     The error message.

return_error
     You can use this method to return errors to the browser and exit.

set_platform
     You can use this method to set the platform on which your Web server
     is running. CGI::Lite uses this information to translate end-of-line
     (EOL) characters for uploaded files (see the add_mime_type and
     remove_mime_type methods) so that they display properly on that
     platform.

     You can specify either (case insensitive):

          Unix                                  EOL: \012      = \n
          Windows, Windows95, DOS, NT, PC       EOL: \015\012  = \r\n
          Mac or Macintosh                      EOL: \015      = \r

     "Unix" is the default.

set_directory
     Used to set the directory where the uploaded files will be stored
     (only applies to the *multipart/form-data* encoding scheme).

     This function should be called before you call parse_form_data, or
     else the directory defaults to "/tmp". If the application cannot
     write to the directory for whatever reason, an error status is
     returned.

     *Return Value*

          0  Failure
          1  Success

close_all_files
     All uploaded files that are opened as a result of calling
     set_file_type with the "handle" argument can be closed in one shot by
     calling this method.

add_mime_type
     By default, EOL characters are translated for all uploaded files with
     specific MIME types (i.e text/plain, text/html, etc.). You can use
     this method to add to the list of MIME types. For example, if you
     want CGI::Lite to translate EOL characters for uploaded files of
     *application/mac-binhex40*, then you would do this:

          $cgi->add_mime_type ('application/mac-binhex40');

remove_mime_type
     This method is the converse of add_mime_type. It allows you to remove
     a particular MIME type. For example, if you do not want CGI::Lite to
     translate EOL characters for uploaded files of *text/html*, then you
     would do this:

          $cgi->remove_mime_type ('text/html');

     *Return Value*

          0  Failure
          1  Success

get_mime_types
     Returns the list, either as a reference or an actual list, of the
     MIME types for which EOL translation is performed.

set_file_type
     The names of uploaded files are returned by default, when you call
     the parse_form_data method. But,  if pass the string "handle" to this
     method, the handles to the files are returned. However, the name of
     the handle corresponds to the filename.

     This function should be called before you call parse_form_data, or
     else it will not work.

add_timestamp
     By default, a timestamp is added to the front of uploaded files.
     However, you have the option of completely turning off timestamp mode
     (value 0), or adding a timestamp only for existing files (value 2).

filter_filename
     You can use this method to change the manner in which uploaded files
     are named. For example, if you want uploaded filenames to be all
     upper case, you can use the following code:

          $cgi->filter_filename (\&make_uppercase);
          $cgi->parse_form_data;

          .
          .
          .

          sub make_uppercase
          {
              my $file = shift;

          $file =~ tr/a-z/A-Z/;
          return $file;
              }

set_buffer_size
     This method allows you to set the buffer size when dealing with
     multipart form data. However, the *actual* buffer size that the
     algorithm uses can be up to 3x the value you specify. This ensures
     that boundary strings are not "split" between multiple reads. So,
     take this into consideration when setting the buffer size.

     You cannot set a buffer size below 256 bytes and above the total
     amount of multipart form data. The default value is 1024 bytes.

     *Return Value*

     The buffer size.

get_ordered_keys
     Returns either a reference to an array or an array itself consisting
     of the form fields/cookies in the order they were parsed.

     *Return Value*

     Ordered keys.

print_data
     Displays all the key/value pairs (either form data or cookie
     information) in a ordered fashion. The methods print_form_data and
     print_cookie_data are deprecated as of version v1.8, and will be
     removed in future versions.

print_form_data
     Deprecated as of v1.8, see print_data.

print_cookie_data (deprecated as of v1.8)
     Deprecated as of v1.8, see print_data.

wrap_textarea
     You can use this function to "wrap" a long string into one that is
     separated by a combination of carriage return and newline (see
     set_platform) at fixed lengths.  The two arguments that you need to
     pass to this method are the string and the length at which you want
     the line separator added.

     *Return Value*

     The modified string.

get_multiple_values
     One of the major changes to this module as of v1.7 is that multiple
     values for a single key are returned as an reference to an array, and
     not as a string delimited by the null character ("\0"). You can use
     this function to return the actual array. And if you pass a scalar
     value to this method, it will simply return that value.

     There was no way I could make this backward compatible with versions
     older than 1.7. I apologize!

     *Return Value*

     Array consisting of the multiple values.

create_variables
     Sometimes, it is convenient to have scalar variables that represent
     the various keys in a hash. You can use this method to do just that.
     Say you have a hash like the following:

          %form = ('name'   => 'shishir gundavaram',
          	     'sport'  => 'track and field',
          	     'events' => '100m');

     If you call this method in the following manner:

          $cgi->create_variables (\%hash);

     it will create three scalar variables: $name, $sport and $events.
     Convenient, huh?

browser_escape
     Certain characters have special significance to the browser. These
     characters include: "<" and ">". If you want to display these
     "special" characters, you need to escape them using the following
     notation:

          &#ascii;

     This method does just that.

     *Return Value*

     Escaped string.

url_encode
     This method will URL encode a string that you pass it. You can use
     this to encode any data that you wish to pass as a query string to a
     CGI application.

     *Return Value*

     URL encoded string.

url_decode
     You can use this method to URL decode a string.

     *Return Value*

     URL decoded string.

is_dangerous
     This method checks for the existence of dangerous meta-characters.

     *Return Value*

          0 Safe
          1 Dangerous

escape_dangerous_chars
     You can use this method to "escape" any dangerous meta-characters.

     *Return Value*

     Escaped string.

SEE ALSO
========

   If you're looking for more comprehensive CGI modules, you can either
use the CGI::* modules or CGI.pm. Both are maintained by Dr. Lincoln Stein
*(lstein@genome.wi.mit.edu)* and can be found at your local CPAN mirror
and at his Web site:

   *http://www-genome.wi.mit.edu/WWW/tools/scripting*

ACKNOWLEDGMENTS
===============

   I'd like to thank the following for finding bugs and offering
suggestions:

Eric D. Friedman (friedman@uci.edu)
Thomas Winzig (tsw@pvo.com)
Len Charest (len@cogent.net)
Achim Bohnet (ach@rosat.mpe-garching.mpg.de)
John E. Townsend (John.E.Townsend@BST.BLS.com)
Andrew McRae (mcrae@internet.com)
Dennis Grant (dg50@chrysler.com)
Scott Neufeld (scott.neufeld@mis.ussurg.com)
Raul Almquist (imrs@ShadowMAC.org)
and many others!
COPYRIGHT INFORMATION
=====================

     Copyright (c) 1995, 1996, 1997 by Shishir Gundavaram
                     All Rights Reserved

     Permission to use, copy, and  distribute  is  hereby granted,
     providing that the above copyright notice and this permission
     appear in all copies and in supporting documentation.


File: pm.info,  Node: CGI/Log,  Next: CGI/LogCarp,  Prev: CGI/Lite,  Up: Module List

Perl extension for centralized logging of debug, error, status and success messages from scripts or other modules.
******************************************************************************************************************

NAME
====

   CGI::Log - Perl extension for centralized logging of debug, error,
status and success messages from scripts or other modules.

SYNOPSIS
========

     use CGI::Log;

     Log->debug("user: $user");		## add messages
     Log->status("Welcome $user.");
     Log->error("I'm sorry $user, but you do not have access to that area.");

     @msg = Log->get_debug();		## get messages
     @msg = Log->get_error();
     @msg = Log->get_error("UI");
     @msg = Log->get_status();

     Log->is_error;			## test for messages
     Log->is_status;
     Log->is_success;

     Log->debug_off;		## causes print() and debug() to be skipped

     Log->print();			## outputs debug and error logs in HTML
     Log->clear;			## clear all entries (current pid)

     Log->_report;			## reports the sizes of the arrays (lengths)
     Log->ui_no_error();		## turns off inclusion of $! in user error messages

DESCRIPTION
===========

   This module acts as a central repository for debug, status and error
messages.  It instantiates itself automatically (if it needs to) so you
can access the Log object functions from anywhere in you code including
other modules/objects with a simple consistent syntax.

   It was written for CGI and mod_perl programming, but it could easily be
used in any perl script where there is a need for centralized logging.
(The only function which is CGI specific is print() since it outputs the
debug and error logs with HTML formatting.)

   It was originally written to just hold debugging information, but it
has been extended to hold information that you might want to return to the
user (i.e. the user-interface).

   It is designed to be very painless to use.  Add the following to any
script or module where you want to log messages:

     use CGI::Log;

   The CGI::Log:: namespace has been aliased to Log:: in order to save a
bit of typing when adding debugging messages.  So, to add a debug message,
enter:

     Log->debug("Your message here.");
     ## note: this is equivalent to CGI::Log->debug();

   To add an error message:

     Log->error("Some information about the error goes here.");

   To add an success, or status message:

     Log->status("A status or informational message for the user.");
     Log->success("Something worked properly.");

   The following commands all retrieve the messages you've logged:

     @msg = Log->get_debug;
     @msg = Log->get_error;
     @msg = Log->get_error("UI");
     @msg = Log->get_status;
     @msg = Log->get_success;

   Note: All the get_* methods return array references when called in
scalar context.  e.g.

     $msg = Log->get_success;	## ref($msg) eq "ARRAY"

   During CGI/mod_perl development it is very handy to dump all of the
debugging messages at the bottom of the HTML page.  This is done with:

     Log->print;

   This can just be left at the bottom of your main script.  Logging can
be turned off (default is on), and when it is turned off Log->print()
doesn't do anything.

Types and Formats of Messages
-----------------------------

   Each of the four types of messages (debug, error, status, success) have
slightly different logic.  The differences are as follows:

   The debug messages are not designed to be visable by the user (and in
fact may be a security risk if you show the connection string for
databases, etc.)  The format of a debug message is:

     [caller:line [caller:line...]] message

     where:

     caller is a method name
     line is the line number from the method
     message is your debugging message

   An example will make this clearer:

     [file: test.pl]

     1:      use CGI::Log;
     2:      &foo;
     3:      sub foo
     4:      {
     5:            Log->debug("We are on line 5 of the method: foo");
     6:            &bar;
     7:      }
     8:      sub bar
     9:      {
     10:           Log->debug("line 10 method: bar process id: " . $$);
     11:           Log->error("Error on line 11 in the method: bar");
     12:     }
     13:     Log->print();

   When run it prints:

     -- DEBUG (test.pl) (pid: 3262) --
     [main:2 main::foo:5] We are on line 5 of the method: foo
     [main:2 main::foo:6 main::bar:10] line 10 method: bar process id: 456
     [ERROR] [main:2 main::foo:6 main::bar:11] This an error being called from the method: bar (No such file or directory)
     -- ERROR --
     [main:2 main::foo:6 main::bar:11] Error on line 11 in the method: bar (No such file or directory)

   (Note: the HTML in the output has been removed for clarity.)

   There are some things to note:


     Each debug message includes the context of how it came to be called.
     This allows for your debug messages to be very short - often just
     stating a simple fact such as "a is undefined" or showing the value
     of a variable.


     Error messages are duplicated in the error and debug arrays, so that
     you can determine how your error message got called, and its relation
     to any debugging messages.


     Error messages in the debug list have "[ERROR]" prepended to them.


     Error messages include the contents of the error variable $! in
     brackets.  This saves you from having to remember to include this
     variable in your error message.

   Log messages of type "status" and "success" are not manipulated or
modified.  Whatever you put in is what you get back.

   Log messages of type "error" are stored in two formats.  The first is
the format that in the output above.  The second is suitable for returning
to the user.  (It doesn't include the call trace.)  By default it includes
the error message from the variable $!.  If this is not desirable, call
Log->ui_no_error()

TIPS/TRICKS
===========


     It is nice to be able to add as many debugging messages without having
     to worry about slowing down your application when it gets deployed.
     Calling Log->debug_off will set the instance variable DEBUG_FLAG to
     undefined, and will prevent any messages in the current process from
     being stored.  e.g.

          if ($config{DEBUG} eq "Off")	## pretend %config holds global
          {				##   configuration info
          	Log->debug_off;
          }
          Log->debug("this debug message won't be saved because debugging is off.");


     Even though the debug() function won't do anything when debugging is
     turned off (it returns immediately), there is still the overhead of a
     function call for each debug message.  If you really want to get
     obsessive about performance you can try redefining the debug()
     method.  e.g.

          use CGI::Log;
          sub CGI::Log::debug () { 1 };		## redefine with prototype so it gets inlined
          					## note: I haven't tested the efficiency of this!
          					##
          					## note: prototypes are from perl 5.002 +


     It is very handy to be able to turn on debugging from the URL.  e.g.

          http://somewhere.com/cgi-bin/test.pl?debug=secret

     In your perl code you could have:

          if ($param{debug} ne "secret" 		## $param{debug} holds the CGI variable "debug"
          	|| $DEBUG != 1)			## $DEBUG is a config variable
          {
          	Log->debug_off();
          }

     This can be a huge timesaver if access to the webserver is difficult.
     This can be huge trouble if you have confidential or security related
     information in your debugging messages.  (That is why "debug" in the
     above example is the string "secret" and not "1" or something easy to
     guess.)


     You can add nice status messages to your web application by doing
     something like:

          if (Log->is_error)
          {
          	print "<font color=\"#ff0000\">ERROR</font><BR>\n";
          	for (Log->get_error) { print $_ . "<BR>\n"; }
          }
          elsif (Log->is_success)
          {
          	print "<img src=\"smiley_face.gif\">";
          	for (Log->get_success) { print $_ . "<BR>\n"; }
          }

          for (Log->get_status) { print $_ . "<BR>\n"; }


     Make sure you have "Log" and not "log" or you will get the run-time
     error:

          Can't take log of 0


     At the end of your script (whether a CGI or mod_perl) you will almost
     always want a:

          Log->clear;

   Documentation for CGI::Log was created by h2xs.

BUGS
====

   - too much noise in the debug call tracing under mod_perl. e.g.

     [main:0 (eval):0 Apache::Registry::handler:141 (eval):141 Apache::ROOT::perl::test_5flog_2epl::handler:16] debug message.

   - not thread-safe.

   - if you are using mod_perl and you do not remember to clean out the
log with Log->clean(), you will waste lots of memory.

   - CGI::Log takes the Log:: namespace by default.  This might be seen as
rude, or cause problems if it is already being used.  (Check if %Log:: is
defined???)

AUTHOR
======

   Jason Moore, 1998 <jmoore@sober.com>

SEE ALSO
========

   perl(1).

   modperl(1).


File: pm.info,  Node: CGI/LogCarp,  Next: CGI/MiniSvr,  Prev: CGI/Log,  Up: Module List

Error, log and debug streams, httpd style format
************************************************

NAME
====

   CGI::LogCarp - Error, log and debug streams, httpd style format

   CGI::LogCarp redefines the STDERR stream and allows the definition of
new STDBUG and STDLOG streams in such a way that all messages are
formatted similar to an HTTPD error log.

   Methods are defined for directing messages to STDERR, STDBUG, and
STDLOG.  Each stream can be directed to its own location independent of
the others.

   It can be used as a version-compatible drop-in replacement for the
CGI::Carp module.  This means that version 1.10 of CGI::LogCarp provides
the same functionality, usage, and features as at least version 1.10 of
CGI::Carp.

SYNOPSIS
========

     use CGI::LogCarp qw( :STDBUG fatalsToBrowser );

     print "CGI::LogCarp version: ", CGI::LogCarp::VERSION;
     DEBUGLEVEL 2;

     confess "It was my fault: $!";
     cluck "What's going on here?";

     warn "This is most unusual.";
     carp "It was your fault!";

     croak "We're outta here!";
     die "I'm dying.\n";

     debug "Just for debugging: somevar=", $somevar, "\n";
     logmsg "Just for logging: We're here.\n";
     trace "detail=", $detail, "\n";

     carpout \*ERRFILE;
     debugout \*DEBUGFILE;
     logmsgout \*LOGFILE;

     is_STDOUT(\*ERRFILE)
     is_STDERR(\*LOGFILE)
     is_STDBUG(\*LOGFILE)
     is_STDLOG(\*ERRFILE)

DESCRIPTION
===========

   CGI::LogCarp is a Perl package defining methods for directing the
existing STDERR stream as well as creating and directing two new messaging
streams, STDBUG and STDLOG.

   Their use was intended mainly for a CGI development environment, or
where separate facilities for errors, logging, and debugging output are
needed.

   This is because CGI scripts have a nasty habit of leaving warning
messages in the error logs that are neither time stamped nor fully
identified.  Tracking down the script that caused the error is a pain.
Differentiating debug output or activity logging from actual error
messages is a pain.  Logging application activity or producing debugging
output are quite different tasks than (ab)using the server's error log for
this purpose.  This module fixes all of these problems.

   Replace the usual

     use Carp;

   or

     use CGI::Carp;

   with

     use CGI::LogCarp;

   And the standard `warn()', `die()', `croak()', `confess()', `cluck()',
and `carp()' calls will automagically be replaced with methods that write
out nicely time-, process-, program-, and stream- stamped messages to the
STDERR, STDLOG, and STDBUG streams.

   The method to generate messages on the new STDLOG stream is `logmsg()'.
Calls to `logmsg()' will write out the same nicely time-, process-,
program-, and stream-stamped messages described above to both the STDLOG
and the STDBUG streams.

   The process number and the stream on which the message appeared is
embedded in the default message in order to disambiguate multiple
simultaneous executions as well as multiple streams directed to the same
location.

   Messages on multiple streams directed to the same location do not
receive multiple copies.

   Methods to generate messages on the new STDBUG stream are debug() and
`trace()'.

Creating the New Streams
------------------------

   In order to create the new streams, you must name them on the use line.
This is also referred to as importing a symbol. For example:

     use CGI::LogCarp qw( :STDERR :STDLOG :STDBUG );

   Note the :STDERR is not really necessary, as it is already defined in
perl.  Importing the :STDERR symbol will not generate an error.

   By default, the STDLOG stream is duplicated from the STDERR stream, and
the STDBUG stream is duplicated from the STDOUT stream.

Redirecting Error Messages
--------------------------

   By default, error messages are sent to STDERR. Most HTTPD servers
direct STDERR to the server's error log. Some applications may wish to
keep private error logs, distinct from the server's error log, or they may
wish to direct error messages to STDOUT so that the browser will receive
them (for debugging, not for public consumption).

   The `carpout()' method is provided for this purpose.

   Because `carpout()' is not exported by default, you must import it
explicitly by saying:

     use CGI::LogCarp qw( carpout );

   Note that for `carpout()', the STDERR stream is already defined, so
there is no need to explicitly create it by importing the STDERR symbol.
However,

     use CGI::LogCarp qw( :STDERR );

   will not generate an error, and will also import carpout for you.

   For CGI programs that need to send something to the HTTPD server's real
error log, the original STDERR stream has not been closed, it has been
saved as _STDERR. The reason for this is twofold.

   The first is that your CGI application might really need to write
something to the server's error log, unrelated to your own error log. To
do so, simply write directly to the _STDERR stream.

   The second is that some servers, when dealing with CGI scripts, close
their connection to the browser when the script closes either STDOUT or
STDERR. Some consider this a (mis)feature.

   Saving the program's initial STDERR in _STDERR is used to prevent this
from happening prematurely.

   Do not manipulate the _STDERR filehandle in any other way other than
writing to it.  For CGI applications, the `serverwarn()' method formats
and sends your message to the HTTPD error log (on the _STDERR stream).

Redirecting Log Messages
------------------------

   A new stream, STDLOG, can be defined and used for log messages.  By
default, STDLOG will be routed to STDERR. Most HTTPD servers direct STDERR
(and thus the default STDLOG also) to the server's error log.  Some
applications may wish to keep private activity logs, distinct from the
server's error log, or they may wish to direct log messages to STDOUT so
that the browser will receive them (for debugging, not for public
consumption).

   The `logmsgout()' method is provided for this purpose.

   Because `logmsgout()' is not exported by default, you must create the
STDLOG stream and import them explicitly by saying:

     use CGI::LogCarp qw( :STDLOG );

Redirecting Debug Messages
--------------------------

   A new stream, STDBUG, can be defined and used for debugging messages.
Since this stream is for producing debugging output, the default STDBUG
will be routed to STDOUT. Some applications may wish to keep private debug
logs, distinct from the application output, or CGI applications may wish
to leave debug messages directed to STDOUT so that the browser will
receive them (only when debugging).  Your program may also control the
output by manipulating DEBUGLEVEL in the application.

   The `debugout()' method is provided for this purpose.

   Because the `debugout()' method is not exported by default, you must
create the STDBUG stream and import them explicitly by saying:

     use CGI::LogCarp qw( :STDBUG );

Redirecting Messages in General
-------------------------------

   Each of these methods, `carpout()', `logmsgout()', and `debugout()',
requires one argument, which should be a reference to an open filehandle
for writing.  They should be called in a BEGIN block at the top of the
application so that compiler errors will be caught.

   This example creates and redirects the STDLOG stream, as well as
redirecting the STDERR stream to a browser, formatting the error message
as an HTML document:

     BEGIN {
         use CGI::LogCarp qw( :STDLOG fatalsToBrowser );
         # fatalsToBrowser doesn't stop messages going to STDERR,
         # rather it replicates them on STDOUT. So we stop them here.
         open(_STDERR,'>&STDERR'); close STDERR;
         open(LOG,">>/var/logs/cgi-logs/mycgi-log")
             or die "Unable to open mycgi-log: $!\n";
         logmsgout \*LOG;
     }

   NOTE: `carpout()', `logmsgout()', and `debugout()' handle file locking
on systems that support flock so multiple simultaneous CGIs are not an
issue.  However, flock might not operate as desired over network-mounted
filesystems.

   If you want to send errors to the browser, give `carpout()' a reference
to STDOUT:

     BEGIN {
       use CGI::LogCarp qw( carpout );
       carpout \*STDOUT;
     }

   If you do this, be sure to send a Content-Type header immediately -
perhaps even within the BEGIN block - to prevent server errors.  However,
you probably want to take a look at importing the `fatalsToBrowser' symbol
and closing STDERR instead of doing this.  See the example above on how to
do this.

Passing filehandles
-------------------

   You can pass filehandles to `carpout()', `logmsgout()', and `debugout()'
in a variety of ways. The "correct" way according to Tom Christiansen is
to pass a reference to a filehandle GLOB (or if you are using the
FileHandle module, a reference to a anonymous filehandle GLOB):

     carpout \*LOG;

   This looks a little weird if you haven't mastered Perl's syntax, so the
following syntaxes are accepted as well:

     carpout(LOG)          -or-  carpout(\LOG)
     carpout('LOG')        -or-  carpout(\'LOG')
     carpout(main::LOG)    -or-  carpout(\main::LOG)
     carpout('main::LOG')  -or-  carpout(\'main::LOG')
     ... and so on

   FileHandle and other objects work as well.

   Using `carpout()', `logmsgout()', and `debugout()', is not great for
performance, so they are recommended for debugging purposes or for
moderate-use applications. You can also manipulate DEBUGLEVEL to control
the output during the execution of your program.

Changing the Default Message Formats
------------------------------------

   By default, the messages sent to the respective streams are formatted
as helpful time-, process-, program-, and stream-stamped messages.

   The process number (represented in the example output below as $$) and
the stream on which the message appears are displayed in the default
message format and serve to disambiguate multiple simultaneous executions
as well as multiple streams directed to the same location.

   For example:

     [Mon Sep 15 09:04:55 1997] $$ test.pl ERR: I'm confused at test.pl line 3.
     [Mon Sep 15 09:04:55 1997] $$ test.pl BUG: answer=42.
     [Mon Sep 15 09:04:55 1997] $$ test.pl LOG: I did something.
     [Mon Sep 15 09:04:55 1997] $$ test.pl ERR: Got a warning: Permission denied.
     [Mon Sep 15 09:04:55 1997] $$ test.pl ERR: I'm dying.

   You can, however, redefine your own message formats for each stream if
you don't like this one by using the `set_message()' method.  This is not
imported by default; you should import it on the use() line like thus:

     use CGI::LogCarp qw( fatalsToBrowser set_message );
     # fatalsToBrowser doesn't stop messages going to STDERR,
     # rather it replicates them on STDOUT. So we stop them here.
     open(_STDERR,'>&STDERR'); close STDERR;
     set_message("It's not a bug, it's a feature!");

     use CGI::LogCarp qw( :STDLOG );
     set_message(STDLOG, "Control: I'm here.");

   Note the varying syntax for `set_message()'.

   The first parameter, if it is a filehandle, identifies the stream whose
message is being defined. Otherwise it specifies the message for the STDERR
stream. This non-filehandle first parameter form preserves compatibility
with CGI::Carp syntax.

   You may also pass in a code reference in order to create a custom error
message. At run time, your code will be called with the text of the error
message that caused the script

     BEGIN {
         use CGI::LogCarp qw( fatalsToBrowser set_message );
         # fatalsToBrowser doesn't stop messages going to STDERR,
         # rather it replicates them on STDOUT. So we stop them here.
         open(_STDERR,'>&STDERR'); close STDERR;
         sub handle_errors {
             my $msg = shift;
             $msg =~ s/\&/&amp;/gs;
             $msg =~ s/</&lt;/gs;
             $msg =~ s/>/&gt;/gs;
             $msg =~ s/"/&quot;/gs;
             join("\n",
                 "<h1>Aw shucks</h1>",
                 "Got an error:",
                 "<pre>", $msg, "</pre>",
             "");
         }
         set_message(\&handle_errors);
     }

   In order to correctly intercept compile-time errors, you should call
`set_message()' from within a BEGIN block.

Making perl Errors Appear in the Browser Window
-----------------------------------------------

   If you want to send fatal (die or `confess') errors to the browser, ask
to import the special `fatalsToBrowser' symbol:

     BEGIN {
         use CGI::LogCarp qw( fatalsToBrowser );
         # fatalsToBrowser doesn't stop messages going to STDERR,
         # rather it replicates them on STDOUT. So we stop them here.
         open(_STDERR,'>&STDERR'); close STDERR;
     }
     die "Bad error here";

   Fatal errors will now be sent to the browser. Any messages sent to the
STDERR stream are now *also* reproduced on the STDOUT stream.  Using
`fatalsToBrowser' also causes CGI::LogCarp to define a new message format
that arranges to send a minimal HTTP header and HTML document to the
browser so that even errors that occur early in the compile phase will be
shown. Any fatal (die) and nonfatal (warn) messages are *still* produced
on the STDERR stream. They just also go to STDOUT.

   Certain web servers (Netscape) also send CGI STDERR output to the
browser.  This causes a problem for CGI's because the STDERR stream is not
buffered, and thus if something gets sent to the STDERR stream before the
normal document header is produced, the browser will get very confused.

   The following line solves this problem. See above for examples with
context.

     open(_STDERR,'>&STDERR'); close STDERR;

Changing the fatalsToBrowser message format or document
-------------------------------------------------------

   The default message generated by `fatalsToBrowser' is not the normal
`LogCarp' logging message, but instead displays the error message followed
by a short note to contact the Webmaster by e-mail with the time and date
of the error. You can use the `set_message()' method to change it as
described above.

   The default message generated on the STDLOG and STDBUG streams is
formatted differently, and is as described earlier.

What are the Carp methods?
--------------------------

   The Carp methods that are replaced by CGI::LogCarp are useful in your
own modules, scripts, and CGI applications because they act like `die()'
or `warn()', but report where the error was in the code they were called
from.  Thus, if you have a routine `Foo()' that has a `carp()' in it, then
the `carp()' will report the error as occurring where `Foo()' was called,
not where `carp()' was called.

Forcing a Stack Trace
---------------------

   As a debugging aid, you can force `LogCarp' to treat a croak as a
`confess' and a carp as a `cluck' across all modules.  In other words,
force a detailed stack trace to be given.  This can be very helpful when
trying to understand why, or from where, a warning or error is being
generated.

   This feature is enabled by 'importing' the non-existant symbol
'verbose'. You would typically enable it on the command line by saying:

     perl -MCGI::LogCarp=verbose script.pl

   or by including the string `MCGI::LogCarp=verbose' in the PERL5OPT
environment variable.

   You would typically enable it in a CGI application by saying:

     use CGI::LogCarp qw( verbose );

   Or, during your program's run by saying:

     CGI::LogCarp::import( 'verbose' );

   and calling `CGI::LogCarp''s import function directly.

   NOTE: This is a feature that is in Carp but apparently was not
implemented in CGI::Carp (as of v1.10).

METHODS
=======

   Unless otherwise stated all methods return either a true or false value,
with true meaning that the operation was a success.  When a method states
that it returns a value, failure will be returned as undef or an empty
list.

Streams and their methods
-------------------------

   The following methods are for generating a message on the respective
stream:

     The  STDERR stream: warn() and die()
     The  STDLOG stream: logmsg()
     The  STDBUG stream: debug() and trace()
     The _STDERR stream: serverwarn()

   The following methods are for generating a message on the respective
stream, but will indicate the message location from the caller's
perspective.  See the standard Carp.pm module for details.

     The STDERR stream: carp(), croak(), cluck() and confess()

   The following methods are for manipulating the respective stream:

     The STDERR stream: carpout()
     The STDLOG stream: logmsgout()
     The STDBUG stream: debugout()

   The following methods are for manipulating the amount (or level) of
output filtering on the respective stream:

     The STDBUG stream: DEBUGLEVEL()
     The STDLOG stream: LOGLEVEL()

   The following method defines the format of messages directed to a
stream.  Often used by and/or in conjunction with `fatalsToBrowser':

     set_message()

Exported Package Methods
------------------------

   By default, the only methods exported into your namespace are:

     warn, die, carp, croak, confess, and cluck

   When you import the :STDBUG tag, these additional symbols are exported:

     *STDBUG, debugmsgout, debug, trace, and DEBUGLEVEL

   When you import the :STDLOG tag, these additional symbols are exported:

     *STDLOG, logmsgout, logmsg and LOGLEVEL

   When you import the :STDERR tag, these additional symbols are exported:

     carpout

   These additional methods are not exported by default, and must be named:

     carpout, logmsgout, debugout, set_message

   The following are pseudo-symbols, in that they change the way
CGI::LogCarp works, but to not export any symbols in and of themselves.

     verbose, fatalsToBrowser

Internal Package Methods
------------------------

   The following methods are not exported but can be accessed directly in
the CGI::LogCarp package.

   The following methods are for comparing a filehandle to the respective
stream:

     is_STDOUT()
     is_STDERR()
     is_STDBUG()
     is_STDLOG()
     is_realSTDERR()

   Each is explained in its own section below.

Exported Package Variables
--------------------------

   No variables are exported into the caller's namespace.  However, the
STDLOG and STDBUG streams are defined using typeglobs in the main
namespace.

Internal Package Variables
--------------------------

$DEBUGLEVEL
     A number indicating the level of debugging output that is to occur.
     At each increase in level, additional debugging output is allowed.

     Currently three levels are defined:

          0 - No messages are output on the STDBUG stream.
          1 - debug() messages are output on the STDBUG stream.
          2 - debug() and trace() messages are output on the STDBUG stream.

     It is recommended to use the DEBUGLEVEL method to get/set this value.

$LOGLEVEL
     A number indicating the level of logging output that is to occur.  At
     each increase in level, additional logging output is allowed.

     Currently two levels are defined:

          0 - No messages are output on the STDLOG stream.
          1 - logmsg() messages are output on the STDLOG stream.

     It is recommended to use the LOGLEVEL method to get/set this value.

RETURN VALUE
============

   The value returned by executing the package is 1 (or true).

ENVIRONMENT
===========

FILES
=====

ERRORS
======

WARNINGS
========

   Operation on Win32 platforms has not been tested.

   CGI::Carp has some references to a wrap import symbol, which appears to
be an alternate name for `fatalsToBrowser'.  Internal comments refer to
errorWrap. Since this is poorly documented, I am speculating this is
legacy and/or previous implementation coding, and as such, have chosen not
implement the wrap symbol import in `CGI::LogCarp'. If some massively
popular module(s) I am currently unaware of is/are indeed using this
undocumented interface, please let me know.

DIAGNOSTICS
===========

   See importing the verbose pseudo-symbol in Forcing a Stack Trace.

BUGS
====

   Check out what's left in the TODO file.

RESTRICTIONS
============

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

CPAN DEPENDENCIES
=================

LOCAL DEPENDENCIES
==================

SEE ALSO
========

   Carp, CGI::Carp

NOTES
=====

   carpout(), debugout(), and logmsgout() now perform file locking.

   I've attempted to track the features in `CGI::LogCarp' to the features
in the CGI::Carp module by Lincoln Stein. The version number of
`CGI::LogCarp' corresponds to the highest version of CGI::Carp module that
this module replicates all features and functionality. Thus version 1.10
of `CGI::LogCarp' can be used as a drop-in replacement for versions 1.10
or lower of CGI::Carp.

   Due to the implementation of the Symbol.pm module, I have no choice but
to replace it with a version that supports extending the list of "global"
symbols. It is part of the CGI::LogCarp distribution.

   For speed reasons, the autoflush method is implemented here instead of
pulling in the entire FileHandle module.

ACKNOWLEDGEMENTS
================

   Based heavily on the CGI::Carp module by Lincoln D. Stein (
lstein@genome.wi.mit.edu ).  Thanks to Andy Wardley ( abw@kfs.org ) for
commenting the original Carp.pm module.

   Thanks to Michael G Schwern ( schwern@starmedia.net ) for the
constructive input.

AUTHOR(S)
=========

   mak - Michael King ( mike808@mo.net )

HISTORY
=======

     CGI::LogCarp.pm
     v1.01 09/15/97 mak
     v1.12 08/14/98 mak

CHANGE LOG
==========

     1.05 first posting to CPAN
     1.12 major revision, tracking CGI::Carp

MODIFICATIONS
=============

COPYRIGHT
=========

     Copyright (C) 1997,1998 Michael King ( mike808@mo.net )
     Saint Louis, MO USA.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   This module is copyright (c) 1997,1998 by Michael King ( mike808@mo.net
) and is made available to the Perl public under terms of the Artistic
License used to cover Perl itself. See the file Artistic in the
distribution  of Perl 5.002 or later for details of copy and distribution
terms.

AVAILABILITY
============

   The latest version of this module is likely to be available from:

     http://walden.mo.net/~mike808/LogCarp

   The best place to discuss this code is via email with the author.

PACKAGE PUBLIC METHODS
======================

DEBUGLEVEL $LEVEL
-----------------

   DEBUGLEVEL is a normal get/set method.

   When the scalar argument LEVEL is present, the DEBUGLEVEL will be set
to LEVEL.  LEVEL is expected to be numeric, with the following
case-insensitive character-valued translations:

     NO,  FALSE, and OFF all equate to a value of 0 (ZERO).
     YES, TRUE,  and ON  all equate to a value of 1 (ONE).
     TRACE or TRACING equate to a value of 2 (TWO).

     Values in scientific notation equate to their numeric equivalent.

   NOTE:

     All other character values of LEVEL equate to 0 (ZERO). This
     will have the effect of turning off debug output.

   After this translation to a numeric value is performed, the DEBUGLEVEL
is set to LEVEL.

   Whenever the DEBUGLEVEL is set to a non-zero value (i.e. ON or TRACE),
the LOGLEVEL will be also set to 1 (ONE).

   The value of DEBUGLEVEL is then returned to the caller, whether or not
LEVEL is present.

LOGLEVEL $LEVEL
---------------

   LOGLEVEL is a normal get/set method.

   When the scalar argument LEVEL is present, the LOGLEVEL will be set to
LEVEL.  LEVEL is expected to be numeric, with the following
case-insensitive character-valued translations:

     NO,  FALSE, and OFF all equate to a value of 0 (ZERO).
     YES, TRUE,  and ON  all equate to a value of 1 (ONE).

     Values in scientific notation equate to their numeric equivalent.

   NOTE:

     All other character values of LEVEL equate to 0 (ZERO). This
     will have the effect of turning off log output.

   After this translation to a numeric value is performed, the LOGLEVEL is
set to LEVEL.

   The value of LOGLEVEL is then returned to the caller, whether or not
LEVEL is present.

warn @message
-------------

   This method is a replacement for Perl's builtin `warn()'.  The message
is sent to the STDERR, STDLOG, and STDBUG streams.

die @message
------------

   This method is a replacement for Perl's builtin `die()'.  The message
is sent to the STDERR, STDLOG, and STDBUG streams.

carp @message
-------------

   This method is a replacement for `Carp::carp()'.  The message is sent
to the STDERR, STDLOG, and STDBUG streams.

   # mak - this fixes a problem when you passed Carp::carp a list # like
the documentation says ( shortmess uses $_[0] and not @_ ).  # This has
been fixed in later (post-1997) versions of Carp.pm.  # Since Carp.pm has
no version, I can't tell which one you have.

croak @message
--------------

   This method is a replacement for `Carp::croak()'.  The message is sent
to the STDERR, STDLOG, and STDBUG streams.

   # mak - this fixes a problem when you passed Carp::croak a list # like
the documentation says ( shortmess uses $_[0] and not @_ ).  # This has
been fixed in later (post-1997) versions of Carp.pm.  # Since Carp.pm has
no version, I can't tell which one you have.

confess @message
----------------

   This method is a replacement for `Carp::confess()'.  The message is
sent to the STDERR, STDLOG, and STDBUG streams.

cluck @message
--------------

   This method is a replacement for `Carp::cluck()'.  The message is sent
to the STDERR, STDLOG, and STDBUG streams.

set_message $message
--------------------

set_message FILEHANDLE $message
-------------------------------

   This method is a replacement for the CGI::Carp method of the same name.
It defines the message format for the STDERR stream if FILEHANDLE is not
specified. FILEHANDLE specifies which stream is having its message
redefined. `$message' is typically a reference to a subroutine.

logmsg @message
---------------

   This method operates similarly to the `warn()' method.  The message is
sent to the STDLOG and STDBUG streams.

debug @message
--------------

   This method operates similarly to the `warn()' method.  The message is
sent to the STDBUG stream when DEBUGLEVEL > 0.

trace @message
--------------

   This method operates similarly to the `warn()' method.  The message is
sent to the STDBUG stream when DEBUGLEVEL is greater than one.

serverwarn @message
-------------------

   This method operates similarly to the `warn()' method.  The message is
sent to the STDBUG, STDLOG, STDERR and _STDERR streams.  The _STDERR
stream is typically is sent to a webserver's error log if used in a CGI
program.

carpout FILEHANDLE
------------------

   A method to redirect the STDERR stream to the given FILEHANDLE.  It
accepts FILEHANDLE as a reference or a string.

   See the section on REDIRECTING ERROR MESSAGES and the section on
*REDIRECTING MESSAGES IN GENERAL*.

logmsgout FILEHANDLE
--------------------

   A method to redirect the STDLOG stream to the given FILEHANDLE.  It
accepts FILEHANDLE as a reference or a string.

   See the section on REDIRECTING ERROR MESSAGES and the section on
*REDIRECTING MESSAGES IN GENERAL*.

debugout FILEHANDLE
-------------------

   A method to redirect the STDBUG stream to the given FILEHANDLE.  It
accepts FILEHANDLE as a reference or a string.

   See the section on REDIRECTING ERROR MESSAGES and the section on
*REDIRECTING MESSAGES IN GENERAL*.

to_filehandle EXPR
------------------

   Borrowed directly from CGI.pm by Lincoln Stein.  It converts EXPR to a
filehandle.

is_STDOUT FILEHANDLE
--------------------

   This method compares FILEHANDLE with the STDOUT stream and returns the
boolean result.

   This method is not exported by default.

is_STDERR FILEHANDLE
--------------------

   This method compares FILEHANDLE with the STDERR stream and returns the
boolean result.

   This method is not exported by default.

is_STDBUG FILEHANDLE
--------------------

   This method compares FILEHANDLE with the STDBUG stream and returns the
boolean result.

   This method is not exported by default.

is_STDLOG FILEHANDLE
--------------------

   This method compares FILEHANDLE with the STDLOG stream and returns the
boolean result.

   This method is not exported by default.

is_realSTDERR FILEHANDLE
------------------------

   This method compares FILEHANDLE with the _STDERR stream and returns the
boolean result.

   This method is not exported by default.

PRIVATE METHODS
===============

realwarn @MESSAGE
-----------------

   This private method encapsulates Perl's underlying `warn()' method,
actually producing the message on the STDERR stream.  Locking is performed
to ensure exclusive access while appending.

   This method is not exportable.

realdie @MESSAGE
----------------

   This private method encapsulates Perl's underlying `die()' method,
actually producing the message on the STDERR stream and then terminating
execution.  Locking is performed to ensure exclusive access while
appending.

   This method is not exportable.

reallog @MESSAGE
----------------

   This private method synthesizes an underlying `logmsg()' method,
actually producing the message on the STDLOG stream.  Locking is performed
to ensure exclusive access while appending.  The message will only be sent
when LOGLEVEL is greater than zero.

   This method is not exportable.

realbug @message
----------------

   This private method synthesizes an underlying debug() method, actually
producing the message on the STDBUG stream.  Locking is performed to
ensure exclusive access while appending.  The message will only be sent
when DEBUGLEVEL is greater than zero.

   This method is not exportable.

realserverwarn @message
-----------------------

   This private method synthesizes an underlying `serverwarn()' method,
actually producing the message on the _STDERR stream.  Locking is
performed to ensure exclusive access while appending.  This stream is
typically directed to the webserver's error log if used in a CGI program.

   This method is not exportable.

id $level
---------

   This private method returns the file, line, and basename of the
currently executing function.

   This method is not exportable.

stamp $stream_id
----------------

   A private method to construct a normalized timestamp prefix for a
message.

   This method is not exportable.

streams_are_equal FILEHANDLE, FILEHANDLE
----------------------------------------

   This private method compares two FILEHANDLE streams to each other and
returns the boolean result.

   This method is not exportable.

   Note: This function is probably not portable to non-Unix-based
operating systems (i.e. NT, VMS, etc.).

lock FILEHANDLE
---------------

   A private method that uses Perl's builtin flock() and `seek()' to
obtain an exclusive lock on the stream specified by FILEHANDLE.  A lock is
only attempted on actual files that are writeable.

   This method is not exportable.

unlock FILEHANDLE
-----------------

   A private method that uses Perl's builtin flock() to release any
exclusive lock on the stream specified by FILEHANDLE.  An unlock is only
attempted on actual files that are writeable.

   This method is not exportable.


