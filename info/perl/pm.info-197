This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Inline/CPP,  Next: Inline/CPR,  Prev: Inline/C-Cookbook,  Up: Module List

Write Perl subroutines and classes in C++.
******************************************

NAME
====

   Inline::CPP - Write Perl subroutines and classes in C++.

SYNOPSIS
========

     print "9 + 16 = ", add(9, 16), "\n";
     print "9 - 16 = ", subtract(9, 16), "\n";

     use Inline CPP => <<'END_OF_CPP_CODE';

     int add(int x, int y) {
        return x + y;
     }

     int subtract(int x, int y) {
        return x - y;
     }

     END_OF_CPP_CODE

DESCRIPTION
===========

   The `Inline::CPP' module allows you to put C++ source code directly
"inline" in a Perl script or module. You code classes or functions in C++,
and you can use them as if they were written in Perl.

Using Inline::CPP
=================

   Inline::CPP is very similar to Inline::C. It uses a grammar to parse
your C++ code, and binds to functions or classes which are recognized. If
a function is recognized, it will be available from Perl space. If the
function's signature is not recognized, it will not be available from Perl
space, but will be available from other functions in C++.

   Inline::CPP binds to functions using the same grammar as Inline::C.
However, it contains an extended grammar for dealing with classes. Several
features of C++ are simply not supported, such as template classes and
inline function definitions.

   The following example shows how C++ snippets map into the Perl
namespace:

   Example 1:

     use Inline CPP => <<'END';

     int doodle() { }

     class Foo {
       public:
         Foo();
         ~Foo();

     int get_data();
     void set_data(int a);
          private:
     int data;
        };

     Foo::Foo() { cout << "creating a Foo()" << endl; }
     Foo::~Foo() { cout << "deleting a Foo()" << endl; }

     int Foo::get_data() { return data; }
     int Foo::set_data(int a) { data = a; }

     END

   After running the code above, Perl's namespace would look similar to if
following code had been run:

     sub main::doodle { }

     package main::Foo;

     sub new { print "creating a Foo()\n"; bless {}, shift }
     sub DESTROY { print "deleting a Foo()\n" }

     sub get_data { my $o=shift; $o->{data} }
     sub set_data { my $o=shift; $o->{data} = shift }

   The difference, of course, is that in the latter, Perl does the work.
In the Inline::CPP example, all function calls get sent off to your C++
code. That means that things like this won't work:

     my $obj = new Foo;
     $obj->{extrafield} = 10;

   It doesn't work because $obj is not a blessed hash. It's a blessed
reference to a C++ object (and anyway, C++ wouldn't let you do that either,
since extrafield wasn't defined).

C++ Configuration Options
=========================

   For information on how to specify Inline configuration options, see
*Note Inline: Inline,. This section describes each of the configuration
options available for C. Most of the options correspond either the
MakeMaker or XS options of the same name. See *Note ExtUtils/MakeMaker:
ExtUtils/MakeMaker, and *Note Perlxs: (perl.info)perlxs,.

AUTO_INCLUDE
------------

   Specifies extra statements to be automatically included. They will be
added on to the defaults. A newline char will automatically be added.

     use Inline CPP => Config => AUTO_INCLUDE => '#include "something.h"';

BOOT
----

   Specifies code to be run when your code is loaded. May not contain any
blank lines. See *Note Perlxs: (perl.info)perlxs, for more information.

     use Inline CPP => Config => BOOT => 'foo();';

CC
--

   Specifies which compiler to use.

CCFLAGS
-------

   Specifies extra compiler flags. Corresponds to the MakeMaker option.

INC
---

   Specifies extra include directories. Corresponds to the MakeMaker
parameter.

     use Inline CPP => Config => INC => '-I/my/path';

LD
--

   Specifies the linker to use.

LDDLFLAGS
---------

   Specifies which linker flags to use.

   NOTE: These flags will completely override the existing flags, instead
of just adding to them. So if you need to use those too, you must
respecify them here.

LIBS
----

   Specifies external libraries that should be linked into your code.
Corresponds to the MakeMaker parameter.

     use Inline CPP => Config => LIBS => '-L/your/path -lyourlib';

MAKE
----

   Specifies the name of the 'make' utility to use.

MYEXTLIB
--------

   Specifies a user compiled object that should be linked in. Corresponds
to the MakeMaker parameter.

     use Inline CPP => Config => MYEXTLIB => '/your/path/something.o';

PREFIX
------

   Specifies a prefix that will automatically be stripped from C++
functions when they are bound to Perl. Less useful than in C, because C++
mangles its function names so they don't conflict with C functions of the
same name.

     use Inline CPP => Config => PREFIX => 'ZLIB_';

TYPEMAPS
--------

   Specifies extra typemap files to use. These types will modify the
behaviour of C++ parsing. Corresponds to the MakeMaker parameter.

     use Inline CPP => Config => TYPEMAPS => '/your/path/typemap';

C++-Perl Bindings
-----------------

   This section describes how the Perl variables get mapped to `C++'
variables and back again.

   Perl uses a stack to pass arguments back and forth to subroutines. When
a sub is called, it pops off all its arguments from the stack; when it's
done, it pushes its return values back onto the stack.

   XS (Perl's language for creating C or C++ extensions for Perl) uses
"typemaps" to turn SVs into C types and back again. This is done through
various XS macro calls, casts, and the Perl API. XS also allows you to
define your own mappings.

   `Inline::CPP' uses a much simpler approach. It parses the system's
typemap files and only binds to functions with supported types. You can
tell `Inline::CPP' about custom typemap files too.

   If you have very complicated data structures in either C++ or Perl, you
should just pass them as an SV* and do the conversion yourself in your C++
function.

SEE ALSO
========

   For general information about how Inline binds code to Perl, see *Note
Inline: Inline,.

   For information on using C with Perl, see *Note Inline/C: Inline/C, and
*Note Inline/C-Cookbook: Inline/C-Cookbook,. For `WMTYEWTK', see *Note
Perlxs: (perl.info)perlxs,, *Note Perlxstut: (perl.info)perlxstut,, *Note
Perlapi: (perl.info)perlapi,, and *Note Perlguts: (perl.info)perlguts,.

BUGS AND DEFICIENCIES
=====================

   When reporting a bug, please do the following:

     - Put "use Inline REPORTBUG;" at the top of your code, or
       use the command line option "perl -MInline=REPORTBUG ...".
     - Run your code.
     - Follow the printed instructions.

   Here are some things to watch out for:

  1. The grammar used for parsing C++ is very simple, and does not allow
     several important features of C++:

          o templates;
          o inheritance; and,
          o inline class methods.

     Other grammar problems will probably be noticed quickly.


AUTHOR
======

   Neil Watkiss <NEILW@cpan.org>

   Brian Ingerson <INGY@cpan.org> is the author of Inline, Inline::C and
Inline::CPR. His antics with object-oriented Perl using C convinced me it
was time to add support for C++. He was responsible for much encouragement
and many suggestions throughout the development of Inline::CPP.

COPYRIGHT
=========

   Copyright (c) 2000 - 2001, Neil Watkiss.

   All Rights Reserved. This module is free software. It may be used,
redistributed and/or modified under the terms of the Perl Artistic License.

   See http://www.perl.com/perl/misc/Artistic.html


File: pm.info,  Node: Inline/CPR,  Next: Inline/Python,  Prev: Inline/CPP,  Up: Module List

C Perl Run. Embed Perl in C, ala Inline
***************************************

NAME
====

   Inline::CPR - C Perl Run. Embed Perl in C, ala Inline

SYNOPSIS
========

     #!/usr/local/bin/cpr

     int main(void) {
     
         printf("Hello World, I'm running under Perl version %s\n",
                CPR_eval("use Config; $Config{version}")
               );

     return 0;
         }

DESCRIPTION
===========

   Is it C? Is it Perl? It's neither, it's both. It's CPR!

   CPR (C Perl Run) is a "new language" that looks like C. You don't need
to compile it. You just run it, much like Perl. As an added bonus, you'll
get access to the full internals of Perl via the CPR API.

   The idea is that you just put a CPR hashbang at the top of your C
program and run it like a script. The CPR interpreter will run your C code
under Perl.

   If your 'hash' doesn't 'bang', you can run your program like this:

     cpr synopsis.cpr

How does it work?
=================

   To understand CPR, you need to understand the Perl module, `Inline.pm'.
Inline lets you write Perl subroutines in other languages, like C. CPR is
a natural extension of this.

   The CPR interpreter (`/usr/local/bin/cpr') is a small binary program
which performs a bootstrap process that goes like this:

   - The `cpr' interpreter execs `perl' and tells it to run the script
`/usr/local/bin/cpr.pl'.

   - The name of your CPR program is passed to `cpr.pl'.

   - `cpr.pl' loads your CPR source code and uses `Inline::CPR' to compile
it and bind your `main()' function to Perl.

   - Then `cpr.pl' simply invokes the `main()' function and you're off and
running.

Notes on Usage
==============

  1. The CPR tools will get installed in the same directory as the `perl'
     binary on your system. (I just used `/usr/local/bin/' as an example)

  2. If you installed `Inline::CPR' by hand, the make command will have
     created the file `'./examples/synopsis.cpr''. This is a sample CPR
     program that you can try running. It's the same as the SYNOPSIS
     example above, except that the hashbang will point to your newly
     installed CPR interpreter.

  3. Although Inline::CPR is a module, it is only used to support the
     `cpr' interpreter program. You don't ever actually use it in a Perl
     script.

  4. You must have a `main()' function in your CPR program. This is what
     `cpr' binds to.

  5. The `cpr' interpreter internally changes your function `main()' to
     `cpr_main()'. Otherwise it would conflict with Perl's `main()'
     function.

  6. The first time you run a CPR program it will seem to "hang" for
     several seconds. This is normal. The C code is being compiled.
     Experienced Inline users will be familiar with this. (Since your
     compiled code is cached to disk, subsequent runs will be fast)

  7. CPR builds and caches your compiled CPR code in the directory
     `'./.cpr/''.

  8. CPR will return (to the system) whatever integer value your `main()'
     function returns.

  9. You don't need to `#include' most of the standard header files. These
     are automatically included by Inline::CPR.

 10. CPR will work with Perl 5.005 and higher. The CPR API will be made to
     work with those versions. (Maybe even with Perl6)


The CPR API
===========

   The CPR API is just a set of C macros that you can use to access the
internals of Perl5. You can also use the Perl5 API. See `perldoc perlapi'.

   The main focus of CPR will be to develop a wrapper API around the
current Perl5 one. It will be more consistent, flexible and easy to use.

   Since it should be well thought out, I have currently only implemented
one function: CPR_eval. But you should be able to do quite a bit with just
that one.

CPR_eval()
----------

   Eval a string (char*) in Perl and return the result as a string.

     const char* CPR_eval(char*);

Why?
====

   Several reasons, (none great).

  1. It's a cute Perl trick. After explaining CPR to an uninitiated
     friend, he said "My head feels like it's been wrapped around a
     brick". That should be reason enough :)

  2. A dead simple way to embed Perl into C. You're not really embedding
     Perl into C. Your C is being embedded seamlessly into Perl. But since
     you never see the Perl, you can just *think* of it the first way.

  3. A mechanism for designing a new Perl5 API. The current one is very
     adhoc. Some macros come from XS and others from the P5P. There's a
     lot of room for improvement. Also, with Perl6 looming, finding a
     wrapper API for Perl5 that might possibly be upwards compatible, is
     at least worth considering.

  4. Inline::CPR is a good example of how a CPAN module can be used to
     build and install a binary program. It is interesting to note that
     the C program `cpr.c' is actually generated by the Perl script
     `cpr.plc' at make time.

        Even if there is no "real world" use for the CPR language, it is
at least an easy-to-use tool for playing around with the internals of
Perl5. The more "regular people" there are playing in the guts, the more
useful we'll be for helping improve our language.

LIMITATIONS
===========

  1. CPR only binds to a `main()' function with a signature of:

          int main(void);

     It will not yet bind to:

          int main(int argc, char* argv[]);

     and friends.

  2. There is currently no way to specify configuration options. This will
     be added soon. Then you'll be able to link in shared libraries and
     such.

  3. Does not yet support MSWin32.


MAILING LIST
============

   The mailing list for `Inline.pm' and related projects is:
inline@perl.org

   To subscribe, send a message to inline-subscribe@perl.org

AUTHOR
======

   Brian Ingerson <INGY@cpan.org>

COPYRIGHT
=========

   Copyright (c) 2001, Brian Ingerson. All Rights Reserved.

   This module is free software. It may be used, redistributed and/or
modified under the terms of the Perl Artistic License.

   (see http://www.perl.com/perl/misc/Artistic.html)


File: pm.info,  Node: Inline/Python,  Next: Interpolation,  Prev: Inline/CPR,  Up: Module List

Write Perl subroutines and classes in Python.
*********************************************

NAME
====

   Inline::Python - Write Perl subroutines and classes in Python.

SYNOPSIS
========

     print "9 + 16 = ", add(9, 16), "\n";
     print "9 - 16 = ", subtract(9, 16), "\n";

     use Inline Python => <<'END_OF_PYTHON_CODE';
     def add(x,y):
        return x + y

     def subtract(x,y):
        return x - y

     END_OF_PYTHON_CODE

DESCRIPTION
===========

   The `Inline::Python' module allows you to put Python source code
directly "inline" in a Perl script or module. A Python interpreter is
loaded and the Python code is interpreted, then Perl asks the Python
interpreter what global functions and classes have been defined. Those
functions and classes are made available to your Perl program as if they
had been written in Perl.

   The process of interrogating the Python interpreter for globals only
occurs the first time you run your Python code. The namespace is cached,
and subsequent calls use the cached version.

Using the Inline::Python Module
===============================

   `Inline::Python' is driven by fundamentally the same idea as other
Inline language modules, like `Inline::C' or `Inline::CPP'.  Because
Python is interpreted, the method of getting your code is different, but
overall, using `Inline::Python' is very similar to any other Inline
language module.

   This section will explain the different ways to use Inline::Python.
For more details on Inline, see 'perldoc Inline'.

The Basics: Functions
---------------------

   The most basic form for using `Inline::Python' is:

     use Inline Python => 'Python source code';

   Of course, you can use Perl's "here document" style of quoting to make
the code slightly easier to read:

     use Inline Python => <<'END';

     Python source code goes here.

     END

   The source code can also be specified as a filename, a subroutine
reference (sub routine should return source code), or an array reference
(array contains lines of source code). This information is detailed in
'perldoc Inline'.

More Advanced: Classes and Objects
----------------------------------

   Because Python is object oriented, any interface between Perl and Python
needs to support Python classes adequately.

   Example:

     use Inline Python => <<'END';

     class Foo:
        def __init__(self):
           print "new Foo object being created"
           self.data = {}
        def get_data(self): return self.data
        def set_data(self,dat):
           self.data = dat

     END

     use Data::Dumper;
     my $obj = new Foo;
     print Dumper $obj;
     print Dumper $obj->get_data();
     $obj->set_data({string => 'hello',
                     number => 0.7574,
                     array => [1, 2, 3],
                    });
     print Dumper $obj->get_data();

   The output from this program is:

     new Foo object being created
     $VAR1 = bless( do{\(my $o = 135870536)}, 'main::Foo' );
     $VAR1 = {};
     $VAR1 = {
               'string' => 'hello',
               'array' => [
                            '1',
                            '2',
                            '3'
                          ],
               'number' => '0.7574'
             };

   `Inline::Python' created a new namespace called `main::Foo' and created
the following functions:

     sub main::Foo::new { ... }
     sub main::Foo::DESTROY { ... }
     sub main::Foo::set_data { ... }
     sub main::Foo::get_data { ... }
     sub main::Foo::__init__ { ... }

   If you don't like the fact that the "private" method __init__() was
bound to Perl, you can feed `Inline::Python' options to disable binding to
private functions. You can even specify what a private function looks like.

   Example:

     use Inline Python => <<'END', PRIVATE_PREFIXES => ['__'];

     class Foo:
        def __init__(self):
           print "new Foo object being created"
           self.data = {}
        def get_data(self): return self.data
        def set_data(self,dat):
           self.data = dat

     END

   `Inline::Python' created a new namespace called `main::Foo' and only
created the following functions:

     sub main::Foo::new { ... }
     sub main::Foo::DESTROY { ... }
     sub main::Foo::set_data { ... }
     sub main::Foo::get_data { ... }

   By default, "private" symbols are ones which begin with one underscore,
or ones that begin with two underscores. You can redefine the "prefix"
used to filter out private functions by using the `PRIV_STRING' option,
which adds new prefixes to the list of bad prefixes. You can pass a string
or an array as the argument to `PRIV_STRING'.

   Example:

     use Inline Python => <<END, PRIVATE_PREFIXES => [undef, "_priv_"];

     def _priv_function(): return None
     def public_function(): return None

     END

   This code will not bind to `_priv_function'. Notice that undef clears
the list `PRIVATE_PREFIXES'.

   If you're like every other Perl hacker, though, you'll just leave all
the functions available and let people use their own judgement.

What happens when I call a Python function?
-------------------------------------------

   When you call a "Python" function, you're actually calling a Perl
function which knows how to get into Python space and back again. For
instance, earlier we saw this example:

     use Inline Python => <<'END';

     class Foo:
        def __init__(self):
           print "new Foo object being created"
           self.data = {}
        def get_data(self): return self.data
        def set_data(self,dat):
           self.data = dat

     END

   The code which is passed to eval() is this: (beautified slightly)

     package main::Foo;

     sub new {
        shift;
        Inline::Python::_eval_python_function(__PACKAGE__,"Foo", @_)
     }

     sub DESTROY {
       Inline::Python::_destroy_python_object(@_)
     }

     sub set_data {
       Inline::Python::_eval_python_method(__PACKAGE__,"set_data",@_)
     }

     sub get_data {
       Inline::Python::_eval_python_method(__PACKAGE__,"get_data",@_);
     }

     sub __init__ {
       Inline::Python::_eval_python_method(__PACKAGE__,"__init__",@_);
     }

Can I do it myself?
-------------------

   If you just want access to Python's interpreter, `Inline::Python'
provides a function you can use to interact with Python. There are three
usages: the first one emulates Perl's own eval() - you just pass it Python
code as a string and Python runs it. The major difference between eval()
and eval_python() is that Python's eval_python returns 1 or 0, depending
on whether the code passed or failed. This may be changed in a subsequent
release.

     eval_python("python source code")

   If you want to send data between Python and Perl, you'll need more than
just a success flag. Two other usages of eval_python() are provided which
return the results of running Python code:

     eval_python("perl package", "python function", args...)

     eval_python("perl package", "python method", object, args...)

   The first argument, "perl package", is what package into which to bless
an instance of a Python class. This is required to support Object Oriented
programming properly.

   To import eval_python() into your namespace, use the following syntax:

     use Inline::Python qw(eval_python);

   This will import eval_python() into your namespace, and do nothing
else. (NB: most Inline language extensions do not support this syntax. For
instance, 'use Inline::C' will generate an error.)

SUPPORTED PLATFORMS
===================

   This is an ALPHA release of Inline::Python. Further testing and
expanded support for other operating systems and platforms will be a focus
for future releases. It has been tested on RedHat Linux 6.2 with a variety
of different Perl and Python configurations. It likely will work with many
flavours of Unix, and possibly in Windows.

SEE ALSO
========

   For information about using Inline, see *Note Inline: Inline,.

   For information about other Inline languages, see *Note Inline-Support:
Inline-Support,.

   Inline::Python's mailing list is inline@perl.org

   The subscribe, send email to inline-subscribe@perl.org

BUGS AND DEFICIENCIES
=====================

   When reporting a bug, please do the following:

     - Put "use Inline REPORTBUG;" at the top of your code, or
       use the command line option "perl -MInline=REPORTBUG ...".
     - Run your code.
     - Follow the printed instructions.

   Here are some things to watch out for:

  1. The eval_python() function only returns the result of the compilation,
     not the result of running the code. You can only get the results of
     running Python code by putting code in a function and running that.

     Example:

          use Inline::Python qw(eval_python);

          eval_python("def foo(): return {'apples': 1, 'oranges': 2}"); # returns 1
          eval_python("foo()"); # returns 1 (NOT a hash)

     What you need to do:

          use Inline::Python qw(eval_python);

          eval_python("def foo(): return {'apples': 1, 'oranges': 2}"); # returns 1
          eval_python(__PACKAGE__, "foo"); # returns a hash

     This bug will probably be fixed in a future release.

  2. Note that the namespace imported into Perl is NOT recursively
     traversed. Only Python *globals* are imported into Perl - subclasses,
     subfunctions, and other modules are not imported.

     Example:

          use Inline Python => <<'END';

          import mymodule

          class A: pass

          END

     The namespace imported into perl is ONLY that related to A. Nothing
     related to mymodule is imported, unless some Python code explictly
     copies variables from the mymodule namespace into the global namespace
     before Perl binds to it.


AUTHOR
======

   Neil Watkiss <NEILW@cpan.org>

   Brian Ingerson <INGY@cpan.org> is the author of Inline, Inline::C and
Inline::CPR. He was responsible for much encouragement and many
suggestions throughout the development of Inline::Python.

COPYRIGHT
=========

   Copyright (c) 2000, Neil Watkiss.

   All Rights Reserved. This module is free software. It may be used,
redistributed and/or modified under the terms of the Perl Artistic License.

   (see http://www.perl.com/perl/misc/Artistic.html)


File: pm.info,  Node: Interpolation,  Next: Interval,  Prev: Inline/Python,  Up: Module List

Arbitrary string interpolation semantics
****************************************

NAME
====

   Interpolation - Arbitrary string interpolation semantics

SYNOPSIS
========

     use Interpolation name => \&function, ...;
     print "la la la la $name{blah blah blah}";

     # This is like doing:
     $VAR = &function(blah blah blah);
     print "la la la la $VAR";

DESCRIPTION
===========

   Beginners always want to write this:

     print "The sum of three and four is: 3+4";

   And they want the `3+4' part to be evaluated, so that it prints this:

     The sum of three and four is: 7

   Of course, it's a double-quoted string, so it's not evaluated.  The
only things that are evaluated in double-quoted strings are variable
references.

   There are solutions to this, but most of them are ugly.  This module is
less ugly.  It lets you define arbitrary interpolation semantics.

   For example, you can say

     use Interpolation money => \&commify_with_dollar_sign,
                       E     => 'eval',
                       placename => 'ucwords',
         ;

   And then you can write these:

     print "3 + 4 = $E{3+4}";
     # Prints  ``3 + 4 = 7''

     $SALARY = 57500;
     print "The salary is $money{$SALARY}";
     # Prints  ``The salary is $57,500.00''

     $PLACE1 = 'SAN BERNADINO HIGH SCHOOL';
     $PLACE2 = 'n.y. state';
     print "$placename{$PLACE1} is not near $placename{$PLACE2}";
     # Prints  ``San Bernadino High School is not near N.Y. State";

DETAILS
=======

   The arguments to the use call should be name-function pairs.  If the
pair is `($n, $f)', then $n will be the name for the semantics provided by
$f.  $f must either be a reference to a function that you supply, or it
can be the name of one of the built-in formatting functions provided by
this package.  Interpolation will take over the `%n' hash in your package,
and tie it so that acessing `$n{X}' calls `f(X)' and yields its return
value.

   If for some reason you want to, you can add new semantics at run time
by using

     import Interpolation name => function, ...

   You can remove them again with

     unimport Interpolation 'name', ...

Built-ins
---------

   Interpolation provides a few useful built-in formatting functions; you
can refer to these by name in the use or import line.  They are:

     eval     Evaluate argument
     null     Same as eval
     identity Also the same as eval
     ucwords  Capitalize Input String Like This
     commify  1428571 => 1,428,571.00
     reverse  reverse string
     sprintf  makes "$S{'%.2f %03d'}{37.5,42}" turn into "37.50 042".
     sprintf1 makes "$S{'%.2f %03d', 37.5,42}" turn into "37.50 042".

   It's easy to forget that the index to a `$hash{...}' is an arbitrary
expression, unless it looks like an identifier.  There are two gotchas
here.

Trap 1.
          print "$X{localtime}";

     Here the X formatter is used to format the literal string localtime;
     the localtime built-in function is not invoked.  If you really want
     the current time, use one of these:

          print "$X{+localtime}";
          print "$X{localtime()}";

Trap 2.
          print "$X{What ho?}";

     This won't compile--you get `search pattern not terminated'.  Why?
     Because Perl sees the ? and interprets it as the beginning of a
     pattern match operator, similar to /.  (Ah, you forgot that ?  could
     be a pattern match delimiter even without a leading m, didn't you?)
     You really need

          print "$X{'What ho?'}";

   The rule is simple: That thing in the braces that looks like a hash key
really is a hash key, and so you need to put it in quotes under the same
circumstances that you need to put any other hash key in quotes.  You
probably wouldn't expect this to work either:

     $V = $X{What ho?};

Author
======

   Mark-Jason Dominus (`mjd-perl-interpolation@plover.com'), Plover
Systems co.

   See the `Interpolation.pm' Page at
http://www.plover.com/~mjd/perl/Interpolation for news and upgrades.

   Mark-Jason Dominus (`mjd-perl-interpolation@plover.com'), Plover
Systems co.

   See the `Interpolation.pm' Page at
http://www.plover.com/~mjd/perl/Interpolation for news and upgrades.


File: pm.info,  Node: Interval,  Next: Isam,  Prev: Interpolation,  Up: Module List

handling of temporal intervals based on Date::Manip
***************************************************

NAME
====

   Interval - handling of temporal intervals based on Date::Manip

SYNOPSIS
========

     use Interval;

     ### class methods ###
     Interval->setDefaultIntervalType ($OPEN_INT);
     $int_open = new Interval ("10/10/97", "20/10/97");
     print "$int_open\n"        # prints  '(1997-10-10, 1997-10-20)'

     $nDefaultType = Interval->getDefaultIntervalType;

     ### constructor ###
     $i1 = new Interval ("30/10/97", "01/12/98");
     $i2 = new Interval ("20/01/96", "01/11/97", $RIGHT_OPEN_INT);

     use Date::Manip;
     $date1 = &ParseDate ("10/10/97");
     $date2 = &ParseDate ("15/10/97");
     $int = new Interval ($d1, $d2);

     ### Overload operators ###
     $i3 = $i1 + $i2;          # + gives the sum of intervals if the overlap
     print "$i3\n";            # prints '[1997-01-20, 1998-12-01)'

     $i4 = $i1 - $i2;          # - gives difference of intervals of intervals
     print "$i4\n";            # prints '[1997-11-01, 1998-12-01)'
     
     $i5 = $i1 - $i1;
     print "$i5\n";            # prints '<empty>'

     ### <Allen overlap type> ###
     $X = new Interval (<parameters>);
     $Y = new Interval (<parameters>);
                               ###  relationship between intervals ###
     $Y->AllenBefore ($X);             YYYYYY XXXXXX

     $Y->AllenMeets ($X);              YYYYYYXXXXXX

     $Y->AllenLeftOverlaps ($X);          XXXXXX
                                       YYYYYY

     $Y->AllenLeftCovers ($X);            XXXXXX
                                       YYYYYYYYY

     $Y->AllenCovers ($X);                XXXXXX
                                       YYYYYYYYYYYY

     $Y->AllenStarts ($X);             XXXXXX
                                       YYY

     $Y->AllenEquals ($X);             XXXXXX
                                       YYYYYY
     
     $Y->AllenRightCovers ($X);        XXXXXX
                                       YYYYYYYYY

     $Y->AllenDuring ($X);             XXXXXX
                                        YYYY

     $Y->AllenFinishes ($X);           XXXXXX
     				        YYYY

     $Y->AllenRightOverlaps ($X);      XXXXXX
                                          YYYYYY

     $Y->AllenExtends ($X);            XXXXXXYYYYYY

     $Y->AllenAfter ($X):              XXXXXX YYYYYY

     ### <overlap type> ###
     $Y->before ($X)         same as  $Y->AllenBefore ($X)
     $Y->meets  ($X)         same as  $Y->AllenMeets ($X)

     $Y->leftOverlaps ($X)   same as  $Y->AllenLeftOverlaps ($X)  or
                                      $Y->AllenStarts ($X)

     $Y->totalOverlaps ($X)  same as  $Y->AllenCovers ($X)        or
                                      $Y->AllenLeftCovers ($X)    or
                                      $Y->AllenRightCovers ($X)   or
                                      $Y->AllenEquals ($X)

     $Y->rightOverlaps ($X)  same as  $Y->AllenFinishes ($X)      or
                                      $Y->AllenRightCovers

     $Y->during ($X)         same as  $Y->AllenDuring ($X)
     $Y->extends ($X)        same as  $Y->AllenExtends ($X)
     $Y->after ($X)          same as  $Y->AllenAfter ($X)

     ### <interval type> ###
     $closed_int = new Interval ("10/10/97", "20/10/97", $CLOSED_INT);
     print "$closed_int\n";      # prints [1997-10-10, 1997-10-20]

     $left_open_int = new Interval ("10/10/97", "20/10/97", $LEFT_OPEN_INT);
     print "$left_open_int\n";   # prints (1997-10-10, 1997-10-20]

     $right_open_int = new Interval ("10/10/97", "20/10/97", $RIGHT_OPEN_INT);
     print "$right_open_int\n";  # prints [1997-10-10, 1997-10-20)

     $open_int = new Interval ("10/10/97", "20/10/97", $OPEN_INT);
     print "$open_int\n";         # prints (1997-10-10, 1997-10-20)

     ### check and get overlapping interval ###
      $i1 = new Interval ("30/10/97", "01/12/98");
      $i2 = new Interval ("20/01/96", "01/11/97");
      $i3 = new Interval ("01/01/95", "30/04/95");

     if ($i1->overlaps ($i2)) {
         $i4 = $i1->getOverlap($i2);
         print "$i4\n";              # prints [1997-10-30, 1997-11-01)
     }
     if ($i1->overlaps ($i3)){       # tests fails, does not print anything
         $i5 = $i1->getOverlap($i2);
         print "$i5\n";
     }

DESCRIPTION
===========

     All strings which can be used to create a Date::Manip can be used
     to create an Interval. However, the start date must be larger than
     the stop date.

     The comparison of intervals is based on the 13 ways intervals can
     overlap as defined by J.F. Allen (See litteratur). Further, I have
     included a small number of interval comparison which are handy if
     you are only interested in getting the overlapping interval of two
     intervals.

Defaults
--------

     The default input format is non-us date format "10/12/97" is the
     10th of December 1997, not the 12 of October 1997. It can be
     changed by calling Date::Manip::DateInit().

     The default output format is YYYY-MM-DD. Can be changed by calling
     Interval->setDisplayFormat(<string>).

BUGS
====

     Tried my best to avoid them send me an email if you are bitten by
     a bug

TODO
====

     - Cannot take references to dates as input parameters for the
       constructors

     - Cannot subtract intervals which overlap with "during" overlaps,
       this results in two intervals (currently results in an empty interval)

LITTERATURE
===========

     Allen, J. F., "An Interval-Based Representation of Temporal Knowledge",
     Communication of the ACM, 26(11) pp. 832-843, November 1983.

AUTHOR
======

   Kristian Torp <`torp@cs.auc.dk'>


File: pm.info,  Node: Isam,  Next: Ivrs,  Prev: Interval,  Up: Module List

Perl extension for ISAM files
*****************************

NAME
====

   Isam - Perl extension for ISAM files

SYNOPSIS
========

   use Isam;

DESCRIPTION
===========

   Isam.pm is a thin wrapper to the C-ISAM functions calls.  IsamData.pm
is a facility to access the record's fields.

Exported constants
==================

     AUDGETNAME
     AUDHEADSIZE
     AUDINFO
     AUDSETNAME
     AUDSTART
     AUDSTOP
     CHARTYPE
     DECIMALTYPE
     DOUBLETYPE
     FLOATTYPE
     INTTYPE
     LONGTYPE
     MINTTYPE
     MLONGTYPE
     STRINGTYPE
     ISAUTOLOCK
     ISCLOSED
     ISCURR
     ISD1
     ISD2
     ISDD
     ISDESC
     ISDUPS
     ISEQUAL
     ISEXCLLOCK
     ISFIRST
     ISFIXLEN
     ISGREAT
     ISGTEQ
     ISINOUT
     ISINPUT
     ISLAST
     ISLCKW
     ISLOCK
     ISMANULOCK
     ISMASKED
     ISNEXT
     ISNOCARE
     ISNODUPS
     ISNOLOG
     ISOUTPUT
     ISPREV
     ISRDONLY
     ISSYNCWR
     ISTRANS
     ISVARCMP
     ISVARLEN
     ISWAIT

AUTHOR
======

   Philippe Chane-You-Kaye, philippe.cyk@wanadoo.fr

METHODS
=======

   Isam.pm module include class methods indicated by Isam->method and
object methods indicated by $fd->method where $fd is a reference to an
instance obtained by isopen, isbuild or iscluster eg. my $fd =
Isam->isopen("myfile",&ISINOUT);

Isam->iserrno([INTVALUE])
     Returns the value of the global Isam variable iserrno unless
     `INTVALUE' is specified, in which case, sets the value of iserrno.

Isam->isrecnum([LONGVALUE])
     Returns the value of the global Isam variable isrecnum unless
     `LONGVALUE' is specified, in which case, sets the value of isrecnum.

Isam->isreclen([INTVALUE])
     Returns the value of the global Isam variable isreclen unless
     `INTVALUE' is specified, in which case, sets the value of isreclen.

Isam->iserrio([INTVALUE])
     Returns the value of the global Isam variable iserrio unless
     `INTVALUE' is specified, in which case, sets the value of iserrio.

$fd->fd
     Returns Isam file descriptor

$fd->name   Returns the filename
$fd->isaddindex(KEYDESC)
     Returns TRUE if successfully adds an index to $fd

Isam->isbuild(NAME, LEN, KEYDESC, MODE)
     Returns a reference to an Isam object or undef if unsuccessful

Isam->iscleanup
     Returns TRUE if successful

$fd->isclose
     Returns TRUE if successful

$fd->iscluster(KEYDESC)
     KEYDESC is a reference to a Keydesc object.  Returns a reference to
     an Isam object or undef if unsuccessful

Isam->iscommit
     Returns TRUE if successful

$fd->isdelcurr
     Returns TRUE if successful

$fd->isdelete(DATA)
     DATA is a reference to a scalar. Returns TRUE if successful

$fd->isdelindex(KEYDESC)
     KEYDESC is a reference to a Keydesc object.  Returns TRUE if
     successful

$fd->isdelrec(RECNUM)
     RECNUM is a long integer Returns TRUE if successful

Isam->iserase(NAME)
     NAME is a filename. Returns TRUE if successful

$fd->isflush
     Returns TRUE if successful

$fd->isindexinfo(IDX)
     IDX is an integer. returns undef if unsuccessful.  If IDX == 0,
     returns a reference to a Dictinfo object.  If IDX > 0, returns a
     reference to a Keydesc object

$fd->islock
     Returns TRUE if successful

Isam->islogclose
     Returns TRUE if successful

Isam->islogopen
     Returns TRUE if successful

Isam->isopen(NAME, MODE)
     NAME is a filename, MODE is an integer Returns undef if unsuccessful,
     otherwise returns a reference to an Isam object

$fd->isread(DATA, MODE)
     DATA is a reference to a scalar. MODE is an integer.  Returns TRUE if
     successful

Isam->isrecover
     Returns TRUE if successful

$fd->isrelease
     Returns TRUE if successful

Isam->isrename(OLDNAME, NEWNAME)
     Returns TRUE if successful

$fd->isrewcurr(DATA)
     DATA is a reference to a scalar. Returns TRUE if successful

$fd->isrewrec(RECNUM, DATA)
     RECNUM is the record number, DATA is a reference to the Data.
     Returns TRUE if successful

$fd->isrewrite(DATA)
     DATA is a reference to the Data. Returns TRUE if successful

Isam->isrollback
     Returns TRUE if successful

$fd->issetunique(UNIQUEID)
     UNIQUEID is an integer scalar. Returns TRUE if successful

$fd->isstart(KEYDESC, LENGTH, DATA, MODE)
     KEYDESC is a reference to a Keydesc object, LENGTH is 0 or the number
     of bytes of the key, DATA is a reference to a scalar, MODE is an
     integer value.

     Returns TRUE if successful

$fd->isuniqueid
     Returns undef if unsuccessful or an long value

$fd->isunlock
     Returns TRUE if successful

$fd->iswrcurr(DATA)
     DATA is a reference to a scalar. Returns TRUE if successful

$fd->iswrite(DATA)   DATA is a reference to a scalar. Returns TRUE if successful
SEE ALSO
========

   perl(1).  IsamData.


File: pm.info,  Node: Ivrs,  Next: JListbox,  Prev: Isam,  Up: Module List

Perl extension for Interactive Voice Response System.
*****************************************************

NAME
====

   Ivrs - Perl extension for Interactive Voice Response System.

SYNOPSIS
========

   $iv = new Ivrs($portname,$vdir);

DESCRIPTION
===========

   This module provides the complete interface to voice modem for
Interactive Voice Response System (IVRS). The IVRS are widely used for
telebanking, product inforamtion, tele marketing, voice mail, fax servers,
and many more.  All these can be implemented using this module and with
very few lines of Perl code. This module takes care of all low level
functions of serial port and modem.  A log file defined by the
$logfile="/var/log/Ivrs_Log.ttyS*" will be opened for logging IVRS
activity. Set $Babble =0 if you do not want to log all the messages
(default is 1).

EXAMPLE
=======

   The demo files explains the working of various subroutines of the
module.

   demo1 - A simple voice interaction.

   demo2 - Message recording and playback.

   demo3 - Fax server.

METHODS
=======

   $iv = new Ivrs('ttyS1',$vdir);

   The first variable is the port name for modem and serial port (ttyS0 or
ttyS1)

   The second variable $vdir is voice file directory.  You must specify
$vdir if you want to use other than  default directory ( sfiles/ ). If you
are running IVRS from /etc/inittab (YES!! you can do) then absolute path
for voice files will be rquired.

Initilization.
--------------

   $iv->setport('38400','none','8','1','rts','8096');

   The serial port parameters are set here. These parameters are carefully
worked out after extensive trials. Change these only if you know what are
you doing or if these settings do not work on your modem.

   $iv->initmodem;

   This will put the modem in voice mode. Number of AT commands are
required to set this. You may comment out the AT commands which do not
start with AT# if your modem fails to respond. Some modem uses AT+ for
voice commands.  In that case you will have to replace all AT# with AT+.

   $cid=$iv->waitring;

   This will put the modem in answer mode and wait for the ring. When the
ring comes, call will be received on the first ring and Caller ID will be
returned in $cid (not tested so far).

   If you want to play a message directly (without some one calling)
through Modem speaker then skip it and put $iv->atcomm("AT#VTX","CONNECT");
but then you will not be able to punch DTMF codes.

Play messages.
--------------

   $iv->playfile("$msgfile","$dtmf")

   This requires a bit of explanation.  From version 0.06, the use of lin
file is removed and all files are raw modem data (Rockwell Modem, 7200
samples per second with compression Type 4) type only, So pvftools are no
longer required to run the IVRS.

   The $msgfile contains the message file to be played.  You can specify
the full path of the file like, /home/Ivrs-0.07/sfiles/greet or only file
name (like greet) from voice file directory. If no file name is specified,
it will play special file contained in $tmpmsg. I will discuss this file
in next section.

   Another variable required is $dtmf, which is number of dtmf codes to be
accpeted from the user while playing the file.

   If $dtmf=0 then playing of file will not be stopped even if caller
presses any key.

   If $dtmf=1, then playing of file will be immidiately stopped if the
caller presses first dtmf code and $iv->playfile will return the digit
pressed.

   If $dtmf=2 or more, then playing of specified file will be stopped when
caller presses first digit and next a silence (tsil15) of 15 seconds will
played, for caller to enter remaining digits. When caller has pressed
required number of digits ($dtmf) then playing will be stopped and
$iv->playfile will return with complete dtmf digits.

   $iv->addmsg($msg)

   $iv->addval($val)

   $iv->addmil($val)

   $iv->addtxt("ABCDEF")

   $iv->addate("20001212")

   IVRS requires many messages to generated on the fly and then played to
caller, like numbers in numerical format, date etc. The default voice
directory sfiles/ has number of rmd files with 32 bytes of header striped.
These header less files can be cut and pasted as required. The rmd file
header ( $rmdhdr ) is added to it before playing these file in
$iv-playfile.  The above mentioned routines adds up various rmd files to a
file specified by $tmpmsg, and finally this file along with header is
played to caller.  For example to play number 123 to caller, files (from
sfiles/) '1','hundred', '20' and '3' will be added to $tmpmsg, and then
played.

   $iv->addmsg($msg)

   Add a message from sfiles/

   $iv->addval($val)

   Add a numeric value in Indian format (using lacs and crore)

   $iv->addmil($val)

   Same as above but with International format (using milions and billions)

   $iv->addtxt("ABCDEF")

   Add characters (A-Z and 0-9)

   $iv->addate("20001212")

   Add date in yyyymmdd format.

Record Messages.
----------------

   $iv->recfile($filename,$duration)

   This will record the file $filename in rmd format with proper header
for a period of $duration seconds. This rmd file can be converted to any
format using pvftools.

Other Functions.
----------------

   $iv->dialout

   For dialing out a number - NOT IMPLEMENTED YET.

   $iv->callxfer

   For transfering the call to another extension - NOT IMPLEMENTED YET.

   $iv->faxmode

   This will put the modem in fax mode and you can run efix and efax to
send the fax. This should be last instruction in your script. Also install
efax or copy these files from bin/ directory to your /usr/bin.

Close.
------

   $iv->closep

   This will do some cleanup, hangup the line and reset the modem.

THANKS
======

   I thank Bill Birthisel, wcbirthisel@alum.mit.edu, for serial port code
taken from SerialPort.pm,

COPYRIGHT
=========

   Copyright (c) 2000 Mukund Deshmukh. All rights reserved. This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

AUTHOR
======

   Mukund Deshmukh <betacomp@nagpur.dot.net.in>

SEE ALSO
========

   SerialPort.pm, pvftools


File: pm.info,  Node: JListbox,  Next: Jail,  Prev: Ivrs,  Up: Module List

JListbox
========

   JListbox - justify text within a Listbox

SYNOPSIS
========

     use JListbox;
     $dw = $parent->JListbox(-justify=>'center', -popupmenu=>1);
     $dw->pack;

DESCRIPTION
===========

   JListbox is identical to a Listbox, but has two addtional options:
-justify and -popupmenu.

-justify
........

   Possible values for '-justify' are 'left', 'center' and 'right'.  The
default is 'left'.  All text within the Listbox will be justified
according to the option you set.

   The widget automatically checks for variable or fixed width fonts and
adjusts accordingly.

   You cannot justify individual entries separately (as of version .02).

   Your text will remain justified appropriately, even if you set the
'-expand' and '-fill' options.

   The justification ability is provided via plain old pixel and character
counting (depending on whether you are using a variable or fixed width
font).  There have been no underlying changes in the C code to the Tcl
Listbox.

-popupmenu
..........

   If the -popupmenu option is used, a "Cut, Copy, Paste" menu will appear
when the user right-clicks anywhere on the JListbox.

   The "Cut" option will remove the item from the JListbox, copy it to the
clipboard and the remaining items will shift up automatically.

   The "Copy" option simply copies the selected value to the clipboard.

   The "Paste" option, if selected, will bring up a Dialog window that
gives the user the option to paste (insert) above or below the selected
item, as well as on the same line, either to the left or right of the
selected item.

   One whitespace character is automatically separates the pasted value if
the 'left' or 'right' option is chosen.

   If you wish to modify the popup menu itself, you can retrieve it using
the Subwidget method with 'popupmenu' as the widget name.

   $menu = $dw->Subwidget('popupmenu');

KNOWN BUGS
==========

   If using a variable width font, you may encounter a problem with the
last character disappearing off the right side of the listbox when you use
right justify.  I think I fixed this, so let me know if you have any
problems.

   If the text you insert into the listbox includes characters that have
special meaning in regular expressions (e.g. '*', '?'), you will need to
escape them using the '\' character or your app may crash.

   e.g. $dw->insert('end', "What did you say\?");

PLANNED CHANGES
===============

   Fix the regular expression issue mentioned above.

   Allow individual entries to be justified.

   Add the 'addMenuItem' and 'deleteMenuItem' methods to allow greater
configurability of the right-click menu.

AUTHOR
======

   Daniel J. Berger djberg96@hotmail.com

   Thanks goes to Damion K. Wilson for his help with creating widgets.

SEE ALSO
========

   Listbox


File: pm.info,  Node: Jail,  Next: Java,  Prev: JListbox,  Up: Module List

SGIPerl extension for grabbing video, modifying images and display images
*************************************************************************

NAME
====

   Jail - SGIPerl extension for grabbing video, modifying images and
display images

SYNOPSIS
========

   `use Jail;'

   `$font = openBDF Font ("helvetica50.bdf");' `if ($font->getStatus) {' `
  print $font->getErrorString() . "\n";' `    exit(1);' `}'

   `$dateStr = localtime(time);' `$glArray =
$font->`getText("$dateStr",$count)';' `$glyph   = merge Glyph ($glArray,
$count);'

   `$glyph->setForeground(255,255,255,0);'

   `$jg = new JailGlyph();' `$jg->addGlyph($glyph);' `if
($jg->getStatus()) {' `    print $jg->getErrorString() . "\n";' `
exit(1);' `}'

   `$imgStream = new JailArray();' `if (!$imgStream->getVideoStream(2)) {'
`    $imgStream->printError();' `    exit(1);' `}'

   `$image = $imgStream->pop();'

   `$wi = $image->getWidth();' `$hi = $image->getHeight();' `$wg =
$jg->getWidth();' `$hg = $jg->getHeight();'

   `if (!$jg->blittInImage($image, $wi - $wg, $hi - $hg)) {' `    print
"BLITT1: ";' `    print $jg->getErrorString() . "\n";' `    print
$image->getErrorString() . "\n";' `    exit(1);' `}
C<$image->blur(180,5,5);' `$image->rotateZoom(45, 0.6, 0.6);' ` C<if
(!$image->save("/tmp/jail_2.sgi","SGI")) {' `    $image->printError();' `
 exit(1);' C<}

   `$image = $imgStream->pop();' `$image->sharp(2.5);' `$wi =
$image->getWidth();' `$hi = $image->getHeight();'

   `if (!$jg->blittInImage($image, $wi - $wg, $hi - $hg)) {' `    print
"BLITT2: ";' `    print $jg->getErrorString() . "\n";' `    print
$image->getErrorString() . "\n";' `    exit(1);' `} C<if
(!$image->save("/tmp/jail_1.gif","GIF")) {' `    $image->printError();' `
 exit(1);' `}'

DESCRIPTION
===========

     Jail - Just an_other Image Library

     This extension is running _only_ on SGI IRIX systems. You need the
     Image Vision Library, Video Library and STL.
     You need a X11 Display _only_ if you want to display an image.

     The newest version you can get under http://www.artcom.net/~karo/Jail/.
     You can get there also a precompiled version.

CLASS INTERFACE
===============

   A 'better' documentation are may be the examples.

Exported functions and flags
============================

     The package C<Jail> exports the following functions

Jail Object
-----------

new Jail(...)
load(filename)
     Load an existing image. The method guesses the right file type.

save(filename, imgFormat)
     Save this image with a given filename. The imgFormat is one of the
     supported file formats from the *Image Vision Library*. Have a look
     under `File Formats' or execute the *imgformats* command.

saveFile(filehandle, imgFormat)
     Save this image to a already opened filehandle. For the imgFormat see
     above.  This function works only for the GIF format. The *IL* seeks
     during saving on the filedescriptor, I try to get the *IL* output
     over a pipe. That does not work. YET

getWidth()
     Returns the width of the image in pixels.

getHeight()
     Returns the height of the image in pixels.

getChannels()
     Returns for the image the amount of channels.

getImageFormatName()
     This method is usefull if you have loaded an image. So you can get
     the file format for that image.

copyTile(destX, destY, width, height, srcImage, srcX, srcY)
     Copy a tile from `srcImage' with the given coord. to this image.

add(addImg, [bias])
     Add a image logical to this image.

setPixel(x,y, r,g,b,[a])
     Set a pixel with the given color

duplicate()
     Get a copy of this image.

getVideoSnapshot()
     Get a image from the default video input.  See also videoin(1) and
     videopanel(1).

rotateZoom(angle, zoomX, zoomY, [resample])
     Rotate this image with a given angle. And/Or zoom this image.   0 <=
     angle < 360  0.0 < zoomFactor <= 1.0 See also ilRotZoomImg(3)

blur(blur, width, height, [bias], [edgeMode])
     This method blurs an image by convolving it with a 2D gaussian kernel.
     Parameter:   blur         : the degree of blur   width,height : the
     kernel size

     See also ilGBlurImg(3)

sharp(sharpness, [radius], [edgeMode])
     This method sharpens the source image, by convolving it with a special
     sharpening kernel.  The size of the kernel and the degree of sharpness
     can be controlled by the radius and sharpness parameters.

     See also ilSharpenImg(3)

compass(angle, [bias], [kernSize], [edgeMode])
     This method performs a directional gradient transform of the image.
     This is similar to doing a first derivative operation in the
     direction of the gradient.  Given a direction, a square kernel is
     generated and then the source image is convolved with this kernel.  A
     kernel size and additive bias can be supplied.

     See also ilCompassImg(3)

laplace([bias], [edgeMode], [kern])
     This method performs a 2D convolution on an image using one of two
     predefined 3x3 Laplacian kernels. The resulting image is
     edge-enhanced.

     kern := 1 | 2

     See also ilLaplaceImg(3)

edgeDetection([biasVal], [edgeMode])
     This method performs two orthogonal 2D convolutions on an image using
     two predefined 2x2 Roberts kernels. The resulting image is edge
     enhanced.

     See also ilRobertsImg(3)

blendImg(doImg, alphaValue | alphaImg,[compose])
     This method takes an other image which will be blend into this image.
     If you specify the alphaValue indicate thatthe alpha values are to be
     taken from the alpha channel of the foreground and background images.
     The alpha pixels are normalized to the range (0.0-1.0), based on the
     minimum and maximum pixel values of the foreground and background
     images.  If you specify an alphaImg the first channel of that is
     interpreted as alpha channel for the blending.

     See also ilBlendImg(3)

display()
     This displays the image in a window.. damn this is totaly buggy

printError()
getStatus()
     Normaly the return value is 0. Otherwise an error occured.

getErrorString()
JailArray Object
----------------

new JailArray
size()
     Returns the amount of images.

push(Jail)
     Push an image to the end of the array.

Jail pop()
     Pops and returns the last image in the array.

Jail shift()
     Shifts the first image of the array off and returns it.

unshift(Jail)
     Prepends an other image to the front of the array.

loadIndexed(prefix,startSuffix,suffix,amount)
     Loads images with a given prefix, an additional number and a given
     suffix.  For Example:   prefix:      blub   startSuffix: 23   suffix:
         .gif   amount:      3

          So the method would load 3 images: blub23.gif, blub24.gif and blub25.gif

saveIndexed(prefix,startSuffix,suffix)
     Saves images with the same name convention as loadIndexed.

getVideoStream(amount)
     Get a videostream of `amount' images.

printError()
getStatus()
getErrorString()
Font Object
-----------

openBDF(filename)
     This static factory method loads a BDF font with the given filename
     and returns a Font Object. BDF stands for Glyph Bitmap Distribution
     Format.  See:
     http://www.adobe.com/supportservice/devrelations/typeforum/ftypes.html
     You can get BDF fonts from the X source or get them from your X
     server, have a look: fstobdf(1), xfontsel(1)

getText(text, countVar)
     This methods builds a GlyphArray Object from a given text. In the
     countVar Variable will be the amount of found Glyphs returned.

getCharsetEncoding()
     Returns the encoding value for the font.

getName()
     Returns the name.

getStatus()
getErrorString()
Glyph Object
------------

merge(GlyphArray, count)
     This static factory method returns a new Glyph Object which is build
     from the given GlyphArray.

setName(name)
     You set the Name for the Glyph object.

getName()
getEncoding()
     Get the char encoding for the Glyph. For a merged Glyph it is always
     0.

getBBXW()
     Get the width of the Bounding Box.

getBBXH()
     Get the height of the Bounding Box.

getBBXXO()
     Get the X coord. of the virtual point Zero of the BBX.

getBBXYO()
     Get the Y coord. of the virtual point Zero of the BBX.

setForeground(r,g,b,[a])
     Select a color for the foreground of the Glyph. Every '1' in the
     Glyph will be treated as foreground.If you select for 'a' color a
     255, the foreground will not be painted.

setBackground(r,g,b,[a])
     Select a color for the background of the Glyph. Every '0' in the
     Glyph will be treated as background.If you select for 'a' color a
     255, the background will not be painted.

getForegroundR()
getForegroundG()
getForegroundB()
getForegroundA()
getBackgroundR()
getBackgroundG()
getBackgroundB()
getBackgroundA()
print()
     This is for debuging. This prints the glyph in ascii.

GlyphArray Object
-----------------

JailGlyph Object
----------------

new JailGlyph()
addGlyph(glyph)
     This method collects Glyph objects.

createImg()
     This method returns a Jail object. The returned object depends on the
     added Glyphs.

blittInImage(img, x, y)
     This method expect a Jail object and a x and y coord. The added
     Glyphs will be rendered in the given Jail image.

getWidth()
     This returns the witdh, for that the JailGlyph will create a Imgage.
     Thats the same as:     $jailObj = $JailglyphObj->createImg();  ->>
     $jailObj->getWidth();

getHeight()
getCurX()
     Get the X coord of the virtual point zero.

getCurY()
printError()
getStatus()
getErrorString()
Special Parameter
-----------------

bias
     In general, bias is a constant value added to each pixel luminance
     value to make it scale correctly. If, for example, the raw pixel
     luminance covers values between 100 and 200, some operators are able
     to scale the luminance values over the entire depth of pixel
     luminance values, for example, 0 - 255.  When you scale the luminance
     values in this way, you need a bias value that adjusts the initial,
     raw luminance value, 100, in this example, to zero.

edgeMode
     Specifies how the neighborhood is defined for pixels at the edge of
     the image.  Have look at the EDGE_* Flags.

resample
     Determining the procedure used by IL to alter the geometric aspects
     of an image Have a look under Flags RT_*

kernSize
     SGI Docs: The kernel is the group or neighborhood of pixels used in
     calculations to sharpen or blur an image. Generally, the larger the
     kernel radius, the more pronounced the effect of either sharpening or
     blurring the image using the Enhance subpanel. However, using a
     larger kernel radius also results in a more time-consuming process.

compose
     arg, thats heavy to explain shortly please have look at ilBlendImg(3)
     and in /usr/include/il/ilTypes.h

Flags
-----

EDGE_NOPAD
     No padding is done, and the output image shrinks by the size of the
     kernel minus one in each dimension.

EDGE_PADSRC
     The edge of the input image is padded with the input images fill
     value so that a full-sized output image can be processed.

EDGE_PADDST
     Similar to ilNoPad, except that the output, images border is
     sufficiently padded with its fill value so that the final image is
     the same size as the source image.

EDGE_WRAP
     Sufficient data is taken from the opposite edge of the source image
     so that a full-sized output image can be processed.

EDGE_REFLECT
     Sufficient data near the edge of the image is reflected so that a
     full-sized output image can be processed without producing artifacts
     at the image edge.  This mode gives the best results for most
     operators.

RT_NEARNB
     Nearest, standing for Nearest Neighbor, works quickly but produces
     lower-quality results.

RT_BILINEAR
     Bilinear uses more complex, time-consuming methods than Nearest
     Neighbor, but produces higher-quality results.

RT_BIBUBIC
     Bicubic is more time-consuming than either Nearest Neighbor or
     Bilinear, but produces the best results.

     If you choose the Bicubic resampling method, you can also choose the
     specific Bicubic Family, each of which produces a somewhat different
     effect: B-Spline, which is the default option, produces smoother
     images.  Catmul produces more sharpening. Mitchell results in an
     effect between that of the other two.

RT_MINIFY
     The Minify method produces the best results if you are reducing the
     magnification of an image. Again, however, it is a more
     time-consuming process.

Image Formats
-------------

   See also imgformats(1)

PNG
     PNG implements the PNG file format using version 0.88 of the Portable
     Network Graphics library, libpng, and version 1.0 of the ZIP
     deflate/inflate compression library, libzlib.

GIF
     The GIF file format is used to read image files stored in the
     CompuServe Graphics Image File (GIF) format. GIF does not support
     paging. It stores images in palette-color-compressed using the
     Lempel-Ziv & Welch algorithmThe compression algorithm has become the
     focus of patent infringement litigation which has inspired the
     creation of a new image format to replace GIF. This new format is the
     Portable Network Graphics (PNG) image format. It is also supported by
     Jail.

RGB
SGI
     SGI is the first format defined by Silicon Graphics for storing image
     data. SGI files are typically stored in files suffixed by .bw, .rgb,
     .rgba, .sgi, or .screen. SGI files support full color, color palette,
     and monochrome images of either one or two bytes per color component.
     Image data can be stored in either raw form or run-length encoding
     (RLE) compression. You can create SGI files with RLE compression but
     you cannot later rewrite a portion of a compressed SGI file.

TIFF
     The TIFF file format, created by Aldus Corporation, is an extended
     version of the Tag Image File Format, using version 3.4beta24 of Sam
     Lefflers TIFF library, libtiff. This library implements version 6.0
     of the TIFF specification.

JFIF
     JFIF implements the JPEG file format using the JPEG library, libjpeg,
     made available by the Independent JPEG Group. In addition to
     providing the IFL image I/O abstraction, the entire JPEG library is
     provided as is for use by software that has been developed for use
     with libjpeg.

PPM
     PPM, PGM, and PBM implement the PPM, PGM, and PBM file formats using
     release 7, December 1993 of the NETPBM libraries, libppm, libpgm, and
     libpbm.

Alias
     The Alias file format supports both variations of the format: 8-bit
     RGB  and 8-bit matte.

SOFTIMAGE
     The SOFTIMAGE file format supports reading all types of image files
     and writes only mixed RLE compressed. There is no current support for
     depth buffer files or rendered subregions.

YUV
     The YUV file format is the standard 8-bit 4:2:2 (YUV) format used by
     the Sirius board and almost all digital disk recorders ( Abekas,
     Accom etc ).

PCD
     The PCD file format supports image files produced by the Kodak Photo
     CD system.  Photo CD establishes a system for storing
     high-resolution, digital photographic images on compact discs.

PCDO
     Every Kodak Photo CD contains a file in the Kodak Photo CD Overview
     Pac format.  This format contains a low resolution representation of
     each image on the Photo CD.

FIT
Todo
----

search for memory leaks
     There is a small memory leak somewhere in the save routine. Do not
     know if it is in my or in the SGI IL routines.

thrash hold
     add a thrash hold operator

more filter

Bit dithering
add some primitive geometry painting
Display
     The display object is _VERY_ buggy and not finished yet.

Jail::saveFile() can only save GIF\'s and JPG\'s
     Thats a SGI IFL Bug.

GIF -> GIF improvement
     The Problem is the IL core dumpes if I am trying to copy a GIF. So i
     have to convert GIF->RGB->GIF.

documentation
     Write a better documentation

BUGS
====

     Oh, yes there are some. Especially in the display routine.
     Please, please, please, send me a short note if you found a bug.

AUTHOR
======

     This module has been written by Benjamin Pannier (B<karo@artcom.net>).

SEE ALSO
========

   http://www.artcom.net/~karo/Jail/ perl(1), il(3), ifl(3), vl(3)


