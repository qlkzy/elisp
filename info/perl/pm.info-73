This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Boulder/Store,  Next: Boulder/Stream,  Prev: Boulder/Omim,  Up: Module List

Simple persistent storage for Stone tag/value objects
*****************************************************

NAME
====

   Boulder::Store - Simple persistent storage for Stone tag/value objects

SYNOPSIS
========

     Boulder:Store;

     my $store=new Boulder::Store('test.db',1);
     my $s = new Stone (Name=>'george',
     	            Age=>23,
     		    Sex=>M,
     		    Address=>{
     			   Street=>'29 Rockland drive',
     			   Town=>'Fort Washington',
     			   ZIP=>'77777'
     			   }
     		       );
     $store->put($s);
     $store->put(new Stone(Name=>'fred',
     		       Age=>30,
     		       Sex=>M,
     		       Address=>{
                                       Street=>'19 Gravel Path',
     				   Town=>'Bedrock',
     				   ZIP=>'12345'},
     		       Phone=>{
     				 Day=>'111-1111',
     				 Eve=>'222-2222'
     				 }
     			     ));
     $store->put(new Stone(Name=>'andrew',
     		       Age=>18,
     		       Sex=>M));

     $store->add_index('Name');

     my $stone = $store->get(0);
     print "name = ",$stone->Name;

DESCRIPTION
===========

   Boulder::Store provides persistent storage for Boulder objects using a
simple DB_File implementation.  To use it, you need to have Berkeley db
installed (also known as libdb), and the Perl DB_File module.  See the
DB_File package for more details on obtaining Berkeley db if you do not
already have it.

   Boulder::Store provides an unsophisticated query mechanism which takes
advantage of indexes that you specify.  Despite its lack of
sophistication, the query system is often very helpful.

CLASS METHODS
=============

$store = Boulder::Store->new("database/path",$writable)
     The new() method creates a new Boulder::Store object and associates
     it with the database file provided in the first parameter (undef is a
     valid pathname, in which case all methods work but the data isn't
     stored).  The second parameter should be a *true* value if you want
     to open the database for writing.  Otherwise it's opened read only.

     Because the underlying storage implementation is not multi-user, only
     one process can have the database for writing at a time.  A
     *fcntl()*-based locking mechanism is used to give a process that has
     the database opened for writing exclusive access to the database.
     This also prevents the database from being opened for reading while
     another process is writing to it (this is a *good* thing).  Multiple
     simultaneous processes can open the database read only.

     Physically the data is stored in a human-readable file with the
     extension ".data".

OBJECT METHODS
==============

$stone = $store->read_record(@taglist)
     The semantics of this call are exactly the same as in
     Boulder::Stream.  Stones are returned in sequential order, starting
     with the first record.  In addition to their built-in tags, each stone
     returned from this call has an additional tag called "record_no".
     This is the zero-based record number of the stone in the database.
     Use the reset() method to begin iterating from the beginning of the
     database.

     If called in an array context, *read_record()* returns a list of all
     stones in the database that contains one or more of the provided tags.

$stone = $store->write_record($stone [,$index])
     This has the same semantics as Boulder::Stream.  A stone is appended
     to the end of the database.  If successful, this call returns the
     record number of the new entry.  By providing an optional second
     parameter, you can control where the stone is entered.  A positive
     numeric index will write the stone into the database at that position.
     A value of -1 will use the Stone's internal record number (if present)
     to determine where to place it.

$stone = $store->get($record_no)
     This is random access to the database.  Provide a record number and
     this call will return the stone stored at that position.

$record_number = $store->put($stone,$record_no)
     This is a random write to the database.  Provide a record number and
     this call stores the stone at the indicated position, replacing
     whatever was there before.

     If no record number is provided, this call will look for the presence
     of a 'record_no' tag in the stone itself and put it back in that
     position.  This allows you to pull a stone out of the database, modify
     it, and then put it back in without worrying about its record number.
     If no record is found in the stone, then the effect is identical to
     write_record().

     The record number of the inserted stone is returned from this call, or
     -1 if an error occurred.

$store->delete($stone),Boulder::Store::delete($record_no)
     These method calls delete a stone from the database.  You can provide
     either the record number or a stone containing the 'record_no' tag.
     Warning: if the database is heavily indexed deletes can be
     time-consuming as it requires the index to be brought back into synch.

$record_count = $store->length()
     This returns the length of the database, in records.

$store->reset()
     This resets the database, nullifying any queries in effect, and
     causing read_record() to begin fetching stones from the first record.

$store->query(%query_array)
     This creates a query on the database used for selecting stones in
     *read_record()*.  The query is an associative array.  Three types of
     keys/value pairs are allowed:

    (1) $index=>$value
          This instructs Boulder::Store to look for stones containing the
          specified tags in which the tag's value (determined by the Stone
          *index()* method) exactly matches the provided value.  Example:

               $db->query('STS.left_primer.length'=>30);

          Only the non-bracketed forms of the index string are allowed
          (this is probably a bug...)

          If the tag path was declared to be an index, then this search
          will be fast.  Otherwise Boulder::Store must iterate over every
          record in the database.

    (2) EVAL=>'expression'
          This instructs Boulder::Store to look for stones in which the
          provided expression evaluates to *true*.  When the expression is
          evaluated, the variable $s will be set to the current record's
          stone.  As a shortcut, you can use "<index.string>" as shorthand
          for "$s->index('index.string')".

    (3) EVAL=>['expression1','expression2','expression3'...]
          This lets you provide a whole bunch of expressions, and is
          exactly equivalent to EVAL=>'(expression1) && (expression2) &&
          (expression3)'.

     You can mix query types in the parameter provided to query().  For
     example, here's how to look up all stones in which the sex is male
     and the age is greater than 30:

          $db->query('sex'=>'M',EVAL=>'<age> > 30');

     When a query is in effect, *read_record()* returns only Stones that
     satisfy the query.  In an array context, *read_record()* returns a
     list of all Stones that satisfy the query.  When no more satisfactory
     Stones are found, *read_record()* returns undef until a new query is
     entered or reset() is called.

$store->add_index(@indices)
     Declare one or more tag paths to be a part of a fast index.
     *read_record()* will take advantage of this record when processing
     queries.  For example:

          $db->add_index('age','sex','person.pets');

     You can add indexes any time you like, when the database is first
     created or later.  There is a trade off:  *write_record()*, put(),
     and other data-modifying calls will become slower as more indexes are
     added.

     The index is stored in an external file with the extension ".index".
     An index file is created even if you haven't indexed any tags.

$store->reindex_all()
     Call this if the index gets screwed up (or lost).  It rebuilds it
     from scratch.

CAVEATS
=======

   Boulder::Store makes heavy use of the flock() call in order to avoid
corruption of DB_File databases when multiple processes try to write
simultaneously.  flock() may not work correctly across NFS mounts,
particularly on Linux machines that are not running the rpc.lockd daemon.
Please confirm that your flock() works across NFS before attempting to use
Boulder::Store.  If the store.t test hangs during testing, this is the
likely culprit.

AUTHOR
======

   Lincoln D. Stein <lstein@cshl.org>, Cold Spring Harbor Laboratory, Cold
Spring Harbor, NY.  This module can be used and distributed on the same
terms as Perl itself.

SEE ALSO
========

   *Note Boulder: Boulder,, *Note Boulder/Stream: Boulder/Stream,, *Note
Stone: Stone,


File: pm.info,  Node: Boulder/Stream,  Next: Boulder/Swissprot,  Prev: Boulder/Store,  Up: Module List

Read and write tag/value data from an input stream
**************************************************

NAME
====

   Boulder::Stream - Read and write tag/value data from an input stream

SYNOPSIS
========

     #!/bin/perl
     # Read a series of People records from STDIN.
     # Add an "Eligible" tag to all those whose
     # Age >= 35 and Friends list includes "Fred"
     use Boulder::Stream;
     
     my $stream = Boulder::Stream->newFh;
     
     while ( my $record = <$stream> ) {
        next unless $record->Age >= 35;
        my @friends = $record->Friends;
        next unless grep {$_ eq 'Fred'} @friends;

     $record->insert(Eligible => 'yes');
     print $stream $record;
         }

DESCRIPTION
===========

   Boulder::Stream provides stream-oriented access to *Note Boulder:
Boulder, IO hierarchical tag/value data.  It can be used in a magic tied
filehandle mode, as shown in the synopsis, or in object-oriented mode.
Using tied filehandles, *Note Stone: Stone, objects are read from input
using the standard <> operator.  Stone objects printed to the tied
filehandle appear on the output stream in *Note Boulder: Boulder, format.

   By default, data is read from the magic ARGV filehandle (STDIN or a
list of files provided on the command line) and written to STDOUT.  This
can be changed to the filehandles of your choice.

Pass through behavior
---------------------

   When using the object-oriented form of Boulder::Stream, tags which
aren't specifically requested by the get() method are passed through to
output unchanged.  This allows pipes of programs to be constructed easily.
Most programs will want to put the tags back into the boulder stream once
they're finished, potentially adding their own.  Of course some programs
will want to behave differently.  For example, a database query program
will generate but not read a *boulderio* stream, while a report generator
will read but not write the stream.

   This convention allows the following type of pipe to be set up:

     query_database | find_vector | find_dups | \
       | blast_sequence | pick_primer | mail_report

   If all the programs in the pipe follow the conventions, then it will be
possible to interpose other programs, such as a repetitive element finder,
in the middle of the pipe without disturbing other components.

SKELETON BOULDER PROGRAM
========================

   Here is a skeleton example.

     #!/bin/perl
     use Boulder::Stream;
     
     my $stream = Boulder::Stream->newFh;
     
     while ( my $record = <$stream> ) {
        next unless $record->Age >= 35;
        my @friends = $record->Friends;
        next unless grep {$_ eq 'Fred'} @friends;

     $record->insert(Eligible => 'yes');
     print $stream $record;
         }

   The code starts by creating a Boulder::Stream object to handle the I/O.
It reads from the stream one record at a time, returning a *Note Stone:
Stone, object.  We recover the *Age* and *Friends* tags, and continue
looping unless the Age is greater or equal to 35, and the list of Friends
contains "Fred".  If these criteria match, then we insert a new tag named
Eligible and print the record to the stream.  The output may look like
this:

     Name=Janice
     Age=36
     Eligible=yes
     Friends=Susan
     Friends=Fred
     Friends=Ralph
     =
     Name=Ralph
     Age=42
     Eligible=yes
     Friends=Janice
     Friends=Fred
     =
     Name=Susan
     Age=35
     Eligible=yes
     Friends=Susan
     Friends=Fred
     =

   Note that in this case only records that meet the criteria are echoed
to standard output.  The object-oriented version of the program looks like
this:

     #!/bin/perl
     use Boulder::Stream;
     
     my $stream = Boulder::Stream->new;
     
     while ( my $record = $stream->get('Age','Friends') ) {
        next unless $record->Age >= 35;
        my @friends = $record->Friends;
        next unless grep {$_ eq 'Fred'} @friends;

     $record->insert(Eligible => 'yes');
     $stream->put($record);
         }

   The get() method is used to fetch Stones containing one or more of the
indicated tags.  The put() method is used to send the result to standard
output.  The pass-through behavior might produce a set of records like
this one:

     Name=Janice
     Age=36
     Eligible=yes
     Friends=Susan
     Friends=Fred
     Friends=Ralph
     =
     Name=Phillip
     Age=30
     =
     Name=Ralph
     Age=42
     Eligible=yes
     Friends=Janice
     Friends=Fred
     =
     Name=Barbara
     Friends=Agatha
     Friends=Janice
     =
     Name=Susan
     Age=35
     Eligible=yes
     Friends=Susan
     Friends=Fred
     =

   Notice that there are now two records ("Phillip" and "Barbara") that do
not contain the Eligible tag.

Boulder::Stream METHODS
=======================

$stream = Boulder::Stream->new(*IN,*OUT)
----------------------------------------

$stream = Boulder::Stream->new(-in=>*IN,-out=>*OUT)
---------------------------------------------------

   The new() method creates a new Boulder::Stream object.  You can provide
input and output filehandles. If you leave one or both undefined new()
will default to standard input or standard output.  You are free to use
files, pipes, sockets, and other types of file handles.  You may provide
the filehandle arguments as bare words, globs, or glob refs. You are also
free to use the named argument style shown in the second heading.

$fh = Boulder::Stream->newFh(-in=>*IN, -out=>*OUT)
--------------------------------------------------

   Returns a filehandle object tied to a Boulder::Stream object.  Reads on
the filehandle perform a get().  Writes invoke a put().

   To retrieve the underlying Boulder::Stream object, call Perl's built-in
tied() function:

     $stream = tied $fh;

$stone = $stream->get(@taglist)
-------------------------------

@stones = $stream->get(@taglist)
--------------------------------

   Every time get() is called, it will return a new Stone object.  The
Stone will be created from the input stream, using just the tags provided
in the argument list.  Pass no tags to receive whatever tags are present
in the input stream.

   If none of the tags that you specify are in the current boulder record,
you will receive an empty *Stone*.  At the end of the input stream, you
will receive undef.

   If called in an array context, get() returns a list of all stones from
the input stream that contain one or more of the specified tags.

$stone = $stream->read_record(@taglist)
---------------------------------------

   Identical to get(>, but the name is longer.

$stream->put($stone)
--------------------

   Write a *Stone* to the output filehandle.

$stream->write_record($stone)
-----------------------------

   Identical to put(), but the name is longer.

Useful State Variables in a Boulder::Stream
-------------------------------------------

   Every Boulder::Stream has several state variables that you can adjust.
Fix them in this fashion:

     $a = new Boulder::Stream;
     $a->{delim}=':';
     $a->{record_start}='[';
     $a->{record_end}=']';
     $a->{passthru}=undef;

   * delim

     This is the delimiter character between tags and values, "=" by
     default.

   * record_start

     This is the start of nested record character, "{" by default.

   * record_end

     This is the end of nested record character, "}" by default.

   * passthru

     This determines whether unrecognized tags should be passed through
     from the input stream to the output stream.  This is 'true' by
     default.  Set it to undef to override this behavior.

BUGS
====

   Because the delim, record_start and record_end characters in the
Boulder::Stream object are used in optimized (once-compiled) pattern
matching, you cannot change these values once get() has once been called.
To change the defaults, you must create the Boulder::Stream, set the
characters, and only then begin reading from the input stream.  For the
same reason, different Boulder::Stream objects cannot use different
delimiters.

AUTHOR
======

   Lincoln D. Stein <lstein@cshl.org>, Cold Spring Harbor Laboratory, Cold
Spring Harbor, NY.  This module can be used and distributed on the same
terms as Perl itself.

SEE ALSO
========

   *Note Boulder: Boulder,, *Note Boulder/Blast: Boulder/Blast,, *Note
Boulder/Genbank: Boulder/Genbank,, *Note Boulder/Medline:
Boulder/Medline,, *Note Boulder/Unigene: Boulder/Unigene,, *Note
Boulder/Omim: Boulder/Omim,, `Boulder::SwissProt' in this node


File: pm.info,  Node: Boulder/Swissprot,  Next: Boulder/Unigene,  Prev: Boulder/Stream,  Up: Module List

Fetch SwissProt data records as parsed Boulder Stones
*****************************************************

NAME
====

   Boulder::SwissProt - Fetch SwissProt data records as parsed Boulder
Stones

SYNOPSIS
========

     == missing ==

DESCRIPTION
===========

     == missing ==

SEE ALSO
========

   *Note Boulder: Boulder,, *Note Boulder/Blast: Boulder/Blast,, *Note
Boulder/Genbank: Boulder/Genbank,

AUTHOR
======

   Lincoln Stein <lstein@cshl.org>.  Luca I.G. Toldo <luca.toldo@merck.de>

   Copyright (c) 1997 Lincoln D. Stein Copyright (c) 1999 Luca I.G. Toldo

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Boulder/Unigene,  Next: Boulder/XML,  Prev: Boulder/Swissprot,  Up: Module List

Fetch Unigene data records as parsed Boulder Stones
***************************************************

NAME
====

   Boulder::Unigene - Fetch Unigene data records as parsed Boulder Stones

SYNOPSIS
========

     # parse a file of Unigene records
     $ug = new Boulder::Unigene(-accessor=>'File',
                                -param => '/data/unigene/Hs.dat');
     while (my $s = $ug->get) {
       print $s->Identifier;
       print $s->Gene;
     }

     # parse flatfile records yourself
     open (UG,"/data/unigene/Hs.dat");
     local $/ = "*RECORD*";
     while (<UG>) {
        my $s = Boulder::Unigene->parse($_);
        # etc.
     }

DESCRIPTION
===========

   Boulder::Unigene provides retrieval and parsing services for UNIGENE
records

   Boulder::Unigene provides retrieval and parsing services for NCBI
Unigene records.  It returns Unigene entries in *Note Stone: Stone,
format, allowing easy access to the various fields and values.
Boulder::Unigene is a descendent of Boulder::Stream, and provides a
stream-like interface to a series of Stone objects.

   Access to Unigene is provided by one *accessors*, which give access to
local Unigene database.  When you create a new Boulder::Unigene stream,
you provide the accessors, along with accessor-specific parameters that
control what entries to fetch.  The accessors is:

File
     This provides access to local Unigene entries by reading from a flat
     file (typically Hs.dat file downloadable from NCBI's Ftp site).  The
     stream will return a Stone corresponding to each of the entries in
     the file, starting from the top of the file and working downward.  The
     parameter is the path to the local file.

   It is also possible to parse a single Unigene entry from a text string
stored in a scalar variable, returning a Stone object.

Boulder::Unigene methods
------------------------

   This section lists the public methods that the Boulder::Unigene class
makes available.

new()
          # Local fetch via File
          $ug=new Boulder::Unigene(-accessor  =>  'File',
                                   -param     =>  '/data/unigene/Hs.dat');

     The new() method creates a new Boulder::Unigene stream on the
     accessor provided.  The only possible accessors is File.  If
     successful, the method returns the stream object.  Otherwise it
     returns undef.

     new() takes the following arguments:

          -accessor	Name of the accessor to use
          -param		Parameters to pass to the accessor

     Specify the accessor to use with the *-accessor* argument.  If not
     specified, it defaults to File.

     *-param* is an accessor-specific argument.  The possibilities is:

     For File, the *-param* argument must point to a string-valued scalar,
     which will be interpreted as the path to the file to read Unigene
     entries from.

get()
     The get() method is inherited from Boulder::Stream, and simply
     returns the next parsed Unigene Stone, or undef if there is nothing
     more to fetch.  It has the same semantics as the parent class,
     including the ability to restrict access to certain top-level tags.

put()
     The put() method is inherited from the parent Boulder::Stream class,
     and will write the passed Stone to standard output in Boulder format.
     This means that it is currently not possible to write a
     Boulder::Unigene object back into Unigene flatfile form.

OUTPUT TAGS
===========

   The tags returned by the parsing operation are taken from the names
shown in the Flat file Hs.dat since no better description of them is
provided yet by the database source producer.

Top-Level Tags
--------------

   These are tags that appear at the top level of the parsed Unigene entry.

Identifier
     The Unigene identifier of this entry.  Identifier is a single-value
     tag.

     Example:

     my $identifierNo = $s->Identifier;

Title
     The Unigene title for this entry.

     Example:       my $titledef=$s->Title;

Gene The Gene associated with   this Unigene entry
     Example:       my $thegene=$s->Gene;

Cytoband The cytological band position of this entry
     Example:       my $thecytoband=$s->Cytoband;

Counts The number of EST in this record
     Example:       my $thecounts=$s->Counts;

LocusLink The id of the LocusLink entry associated with this record
     Example:       my $thelocuslink=$s->LocusLink;

Chromosome This field contains a list, of the chromosomes numbers in which this entry has been linked
     Example:       my @theChromosome=$s->Chromosome;

STS      Multiple records in the form ^STS     ACC=XXXXXX NAME=YYYYYY
---------------------------------------------------------------------

ACC
NAME
TXMAP Multiple records in the form  ^TXMAP  XXXXXXX; MARKER=YYYYY; RHPANEL=ZZZZ
-------------------------------------------------------------------------------

   The TXMAP tag points to a Stone record that contains multiple subtags.
Each subtag is the name of a feature which points, in turn, to a Stone
that describes the feature's location and other attributes.

   Each feature will contain one or more of the following subtags:

MARKER
RHPANEL
PROTSIM Multiple records in the form ^PROTSIM ORG=XXX; PROTID=DBID:YYY; PCT=ZZZ; ALN=QQQQ Where DBID is  	PID for indicate presence of GenPept identifier,  	SP to indicate SWISSPROT identifier, 	PIR to indicate PIR identifier, 	PRF to indicate ???
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ORG
PROTID
PCT
ALN
SEQUENCE Multiple records in the form ^SEQUENCE ACC=XXX; NID=YYYY; PID = CLONE= END= LID=
-----------------------------------------------------------------------------------------

ACC
NID
PID
CLONE
END
LID
SEE ALSO
========

   *Note Boulder: Boulder,, *Note Boulder/Blast: Boulder/Blast,, *Note
Boulder/Genbank: Boulder/Genbank,

AUTHOR
======

   Lincoln Stein <lstein@cshl.org>.  Luca I.G. Toldo <luca.toldo@merck.de>

   Copyright (c) 1997 Lincoln D. Stein Copyright (c) 1999 Luca I.G. Toldo

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Boulder/XML,  Next: Bundle/ABH,  Prev: Boulder/Unigene,  Up: Module List

XML format input/output for Boulder streams
*******************************************

NAME
====

   Boulder::XML - XML format input/output for Boulder streams

SYNOPSIS
========

     use Boulder::XML;
     
     $stream = Boulder::XML->newFh;

     while ($stone = <$stream>) {
          print $stream $stone;
     }

DESCRIPTION
===========

   Boulder::XML generates BoulderIO streams from XML files and/or streams.
It is also able to output Boulder Stones in XML format.  Its semantics
are similar to those of Boulder::Stream, except that there is never any
pass-through behavior.

   Because XML was not designed for streaming, some care must be taken
when reading an XML document into a series of Stones.  Consider this XML
document:

     <?xml version="1.0" standalone="yes"?>

     <Paper>
       <Author>Lincoln Stein</Author>
       <Author>Jean Siao</Author>
       <Date>September 29, 1999</Date>
       <Copyright copyrighted="yes">1999 Lincoln Stein</Copright>
       <Abstract>
           This is the abstract.  It is not anything very fancy,
           but it will do.
       </Abstract>
       <Citation>
            <Author>Fitchberg J</Author>
            <Journal>Journal of Irreproducible Results</Journal>
            <Volume>23</Volume>
            <Year>1998</Volume>
       </Citation>
       <Citation>
            <Author>Clemenson V</Author>
            <Journal>Ecumenica</Journal>
            <Volume>10</Volume>
            <Year>1968</Volume>
       </Citation>
       <Citation>
            <Author>Ruggles M</Author>
            <Journal>Journal of Aesthetic Surgery</Journal>
            <Volume>10</Volume>
            <Year>1999</Volume>
       </Citation>
     </Paper>

   Ordinarily the document will be construed as a single Paper tag
containing subtags Author, Date, Copyright, Abstract, and so on.  However
it might be desirable to fetch out just the citation tags as a series of
Stones.  In this case, you can declare Citation to be the top level tag by
passing the *-tag* argument to new(). Now calling get() will return each
of the three Citation sections in turn.  If no tag is explicitly declared
to be the top level tag, then Boulder::XML will take the first tag it sees
in the document.

   It is possible to stream XML files.  You can either separate them into
separate documents and use the automatic ARGV processing features of the
BoulderIO library, or separate the XML documents using a delimiter string
similar to the delimiters used in MIME multipart documents.  By default,
BoulderIO uses a delimiter of <!-Boulder::XML->.

   *This is not a general XML parsing engine!* Instead, it is a way to
represent BoulderIO tag/value streams in XML format.  The module uses
XML::Parser to parse the XML streams, and therefore any syntactic error in
the stream can cause the XML parser to quit with an error.  Another thing
to be aware of is that there are certain XML constructions that will not
translate into BoulderIO format, specifically free text that contains
embedded tags.  This is OK:

     <Author>Jean Siao</Author>

   but this is not:

     <Author>The <Emphatic>extremely illustrious</Emphatic> Jean Siao</Author>

   In BoulderIO format, tags can contain other tags or text, but cannot
contain a mixture of tags and text.

CONSTRUCTORS
------------

$stream = Boulder::XML->new(*IN,*OUT);
$stream = Boulder::XML->new(-in=>*IN,-out=>*OUT,-tag=>$tag,-delim=>$delim,-strip=>$strip)
     new() creates a new Boulder::XML stream that can be read from or
     written to.  All arguments are optional.

          -in    Filehandle to read from.
                 If a file name is provided, will open the file.
                 Defaults to the magic <> filehandle.

          -out   Filehandle to write to.
                 If a file name is provided, will open the file for writing.
                 Defaults to STDOUT

          -tag   The top-level XML tag to consider as the Stone record.  Defaults
                 to the first tag seen when reading from an XML file, or to
                 Less_Than_Special_SequenceStoneGreater_Than_Special_Sequence when writing to an output stream without
                 previously having read.

          -delim Delimiter to use for delimiting multiple Stone objects in an
                 XML stream.

          -strip If true, automatically strips leading and trailing whitespace
                 from text contained within tags.

$fh = Boulder::XML->newFh(*IN,*OUT);
$fh = Boulder::XML->newFh(-in=>*IN,-out=>*OUT,-tag=>$tag,-delim=>$delim,-strip=>$strip)
     The newFh() constructor creates a tied filehandle that can read and
     write Boulder::XML streams.  Invoking <> on the filehandle will
     perform a get(), returning a Stone object.  Calling print() on the
     filehandle will perform a put(), writing a Stone object to output in
     XML format.

METHODS
-------

$stone = $stream->get()
$stream->put($stone)
$done = $stream->done
     All these methods have the same semantics as the similar methods in
     *Note Boulder/Stream: Boulder/Stream,, except that pass-through
     behavior doesn't apply.

AUTHOR
======

   Lincoln D. Stein <lstein@cshl.org>, Cold Spring Harbor Laboratory, Cold
Spring Harbor, NY.  This module can be used and distributed on the same
terms as Perl itself.

SEE ALSO
========

   *Note Boulder: Boulder,, *Note Boulder/Stream: Boulder/Stream,, *Note
Stone: Stone,


File: pm.info,  Node: Bundle/ABH,  Next: Bundle/AO/Base,  Prev: Boulder/XML,  Up: Module List

A bundle to install all Ask's favorite modules
**********************************************

NAME
====

   Bundle::ABH - A bundle to install all Ask's favorite modules

SYNOPSIS
========

     perl -MCPAN -e 'install Bundle::ABH'

CONTENTS
========

   Bundle::CPAN

   Bundle::libnet

   Bundle::LWP

   CGI

   ExtUtils::Embed

   Mail::Send

   Getopt::Long

   DB_File

   Bundle::DBI

   Devel::Peek

   MIME::Base64

   IO::ScalarArray      - For MIME::Tools

   MIME::Tools

   Tie::Handle

   Time::HiRes

   GD

   Storable

   HTML::Parser

   Data::ShowTable

   LWP::Parallel

   Date::Format

   Tie::IxHash

   Devel::Symdump

   Image::Size

   Convert::Translit

   Text::Soundex

   Font::AFM           - Some of my favorite modules are using this

   Pod::Parser         - For cpan-upload and more

   HTML::TreeBuilder

   Net::DNS

   Text::Template

   App::Config         - For cpan-upload

   Bit::Vector         - For MIME::Lite

   MIME::Lite          - So nice and easy to send a MIME thingy

   Set::IntRange

   XML::Parser

   Date::Calc

   Number::Format

   Event

DESCRIPTION
===========

   This bundle defines most of the modules Ask Bjoern Hansen usually
install/upgrade with CPAN.pm.

AUTHOR
======

   Ask Bjoern Hansen <ask@netcetera.dk>


File: pm.info,  Node: Bundle/AO/Base,  Next: Bundle/AO/Standard,  Prev: Bundle/ABH,  Up: Module List

libraries needed for AO servlet engine
**************************************

NAME
====

   Bundle::AO::Base - libraries needed for AO servlet engine

DESCRIPTION
===========

   This bundle specifies the libraries needed for the AO servlet engine.
It won't run without them.

SYNOPSIS
========

     perl -MCPAN -e 'install Bundle::AO::Base'

CONTENTS
========

   Storable

   Apache::Session 1.51

   XML::Parser

   XML::XPath

   File::Spec


File: pm.info,  Node: Bundle/AO/Standard,  Next: Bundle/Apache,  Prev: Bundle/AO/Base,  Up: Module List

libraries needed by standard AO interceptors
********************************************

NAME
====

   Bundle::AO::Standard - libraries needed by standard AO interceptors

DESCRIPTION
===========

   This bundle specifies the libraries needed by the standard AO
interceptors. You should install this stuff if you want AO to work out of
the box. If you are developing new interceptors, this bundle probably
doesn't apply to you.

SYNOPSIS
========

     perl -MCPAN -e 'install Bundle::AO::Standard'

CONTENTS
========

   Apache::Request

   HTML::Mason

   DBI


File: pm.info,  Node: Bundle/Apache,  Next: Bundle/Apache/ASP,  Prev: Bundle/AO/Standard,  Up: Module List

Install Apache mod_perl and related modules
*******************************************

NAME
====

   Bundle::Apache - Install Apache mod_perl and related modules

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::Apache''

CONTENTS
========

   MIME::Base64       - Used in authentication headers

   Digest::MD5        - Needed to do Digest authentication

   URI 0.10           - There are URIs everywhere

   Net::FTP 2.00      - If you want ftp://-support

   HTML::HeadParser   - To get the correct $res->base

   LWP                - The reason why you need the modules above

   Devel::Symdump - Symbol table browsing with Apache::Status

   Data::Dumper - Used by Apache::PerlSections->dump

   CGI - CGI.pm

   Tie::IxHash - For order in <Perl> sections

   Apache - Perl interface to Apache server API

   Apache::DBI   - Wrapper around DBI->connect to transparently maintain
persistent connections

   Apache::DB - Run the interactive Perl debugger under mod_perl

   Apache::Stage - Management of document staging directories

   Apache::Sandwich - Layered document maker

   Apache::Request - Effective methods for dealing with client request data

DESCRIPTION
===========

   This bundle contains modules used by Apache mod_perl.

   Asking CPAN.pm to install a bundle means to install the bundle itself
along with all the modules contained in the CONTENTS section above.
Modules that are up to date are not installed, of course.

AUTHOR
======

   Doug MacEachern


File: pm.info,  Node: Bundle/Apache/ASP,  Next: Bundle/BioPerl,  Prev: Bundle/Apache,  Up: Module List

Install Apache::ASP and related modules
***************************************

NAME
====

   Bundle::Apache::ASP - Install Apache::ASP and related modules

SYNOPSIS
========

     perl -MCPAN -e 'install Bundle::Apache::ASP'

CONTENTS
========

   MLDBM		  - This is used for reading and writing multi-level
hashes on disk

   Data::Dumper	  - Serializes data for MLDBM

   MD5		  - 32 byte hash algorithm for cookie session-id

   CGI		  - Required for file upload, make test, and command line ./cgi/asp
script

   HTML::Clean	  - Compress text/html with Clean config or
$Response->{Clean} set to 1-9

   Net::SMTP	  - Runtime errors can be mailed to the webmaster with
MailErrorTo config

   HTTP::Date	  - Provides mapping between Perl time() and HTTP
dates

   Devel::Symdump	  - Used for StatINC setting, which reloads modules
dynamically

   Apache::DBI	  - Cache database connections per process

   Compress::Zlib    - Gzip compress HTML output on the fly

   Tie::Cache        - XLSTCacheSize, XSLT caching support

   Time::HiRes       - Sub second timing of execution with Debug 3 enabled

   HTML::Parser      - Required for HTML::FillInForm

   HTML::FillInForm  - FormFill functionality which autofills HTML forms
from form data

   Apache::ASP	  - A perl ASP port to Apache

DESCRIPTION
===========

   This bundle contains modules used by Apache::ASP.

AUTHOR
======

   Joshua Chamas


File: pm.info,  Node: Bundle/BioPerl,  Next: Bundle/Bugzilla,  Prev: Bundle/Apache/ASP,  Up: Module List

A bundle to install external CPAN modules used by BioPerl
*********************************************************

NAME
====

   Bundle::BioPerl - A bundle to install external CPAN modules used by
BioPerl

SYNOPSIS
========

     Perl one liner using CPAN.pm:

     perl -MCPAN -e 'install Bundle::BioPerl'

   Use of CPAN.pm in interactive mode:

     $> perl -MCPAN -e shell
     cpan> install Bundle::BioPerl
     cpan> quit

   Just like the manual installation of perl modules, the user may need
root access during this process to insure write permission is allowed
within the intstallation directory.

CONTENTS
========

   Bundle::LWP		- recommended, used for network access

   File::Temp		- generally required after bioperl release 0.6.2

   IO::Scalar		- optional, used only in
Bio::Tools::Blast::Run::WebBlast.pm

   IO::String		- recommended, used by Bio::DB:WebDBSeqI

   HTTP::Request::Common   - recommended, used for web access

   HTTP::Status            - recommended, used for web access

   LWP::UserAgent          - recommended, used for web access

   URI::Escape             - recommended, used for web access

   XML::Parser		- recommended for bioperl releases after 0.6.2

   XML::Parser::PerlSAX	- recommended for bioperl releases after 0.6.2

   XML::Writer		- recommended for bioperl releases after 0.6.2

   XML::Node		- recommended for bioperl releases after 0.6.2

DESCRIPTION
===========

   The BioPerl distribution from http://bioperl.org contains code and
modules that may use or require additional 'external' perl modules for
advanced functionality. Many of the external modules are not contained
within the standard Perl distribution.

   These external modules can be obtained from the Comprehensive Perl
Archive Network (CPAN) located at http://www.cpan.org.

   This perl module (Bundle::BioPerl) contains NO functionality or real
code at all. It is essentially a special perl module meant to be used by
the CPAN.pm module to simplify the task of automatically installing
multiple modules in one easy step.

   Essentially users can tell CPAN.pm to 'install Bundle::BioPerl' and
CPAN.pm will download, install and configure all of the modules listed in
the BioPerl Bundle module. See the SYNOPSIS section or do `perldoc CPAN'
to learn about how to use the CPAN.pm module to install bundles.

   NOTE: This process is complicated by the fact that some BioPerl
external modules themselves have their own dependencies and prerequisites.
In particular the XML::Parser module requires the prior installation of
the 'xpat' package which resides outside of CPAN at
http://sourceforge.net/projects/expat/.

   The `install Bundle::BioPerl' process may need to be repeated several
times to complete the full installation of all listed modules.

   NOTE: This Bundle does not install BioPerl :) Just the additional
modules that BioPerl code ocasionally makes use of. You will still need to
get the BioPerl distribution from CPAN or http://bioperl.org and install
it the usual way:

     perl Makefile.PL
     make
     make test
     make install

   CPAN.pm has many features - including the ability to download but not
install the modules listed in the BioPerl bundle.

   `perldoc CPAN' is your friend :)

AUTHOR
======

   Chris Dagdigian <`dag@sonsorol.org'> (Author only of this bundle, not
any the modules it lists)


File: pm.info,  Node: Bundle/Bugzilla,  Next: Bundle/Bundle-Expect,  Prev: Bundle/BioPerl,  Up: Module List

A bundle of the modules required for Bugzilla.
**********************************************

NAME
====

   Bundle::Bugzilla - A bundle of the modules required for Bugzilla.

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::Bugzilla''

CONTENTS
========

   DBI

   Data::Dumper

   DBD::mysql

   Chart::Base

   Date::Parse

DESCRIPTION
===========

   This bundle installs the prerequisites for Bugzilla.

   After installing this bundle, it is recommended that you run the magic
checksetup.pl script to check that all modules are in place and setup the
tables in the database. Then, you will need to edit the file called
'localconfig' with your settings for bugzilla. After this, log in to your
installation and make yourself an account. Run checksetup.pl again and you
will become the superuser for your bugzilla installation. Still confused?
Read the INSTALL and README for more information.

DBI This module is used to connect to the database that Bugzilla uses  to store its information.
Data::Dumper The Data::Dumper module provides data structure persistence for Perl (similar to Java's serialization).  It comes with later sub-releases of Perl 5.004, but a re-installation just to be sure it's available won't hurt anything. Data::Dumper is used by the MySQL related Perl modules.
DBD::mysql This module is used to connect to the mysql database that Bugzilla uses  to store its information.
Chart::Base Used to create the bug charts in the reporting functions in reports.cgi.
Date::Parse Enables SQL-style search query statements for Bugzilla.
AUTHOR
======

   Zach Lipton, <zach@zachlipton.com>


File: pm.info,  Node: Bundle/Bundle-Expect,  Next: Bundle/CPAN,  Prev: Bundle/Bugzilla,  Up: Module List

Everything that Expect.pm needs
*******************************

NAME
====

   Bundle::Expect - Everything that Expect.pm needs

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::Expect''

CONTENTS
========

   Expect

   IO::Stty

   IO::Tty

   IO::Pty

DESCRIPTION
===========

   Everything that Expect.pm needs. What can I say more?

AUTHOR
======

   Roland Giersig <RGiersig@users.sourceforge.net>


File: pm.info,  Node: Bundle/CPAN,  Next: Bundle/Cisco/Conf,  Prev: Bundle/Bundle-Expect,  Up: Module List

A bundle to play with all the other modules on CPAN
***************************************************

NAME
====

   Bundle::CPAN - A bundle to play with all the other modules on CPAN

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::CPAN''

CONTENTS
========

   File::Spec

   MD5

   Compress::Zlib

   Archive::Tar

   Bundle::libnet

   Term::ReadKey

   Term::ReadLine::Perl # sorry, I'm discriminating the ::Gnu module

   CPAN::WAIT

   CPAN

DESCRIPTION
===========

   This bundle includes CPAN.pm as the base module and CPAN::WAIT, a
plugin for the first WAIT based CPAN search engine.

   When CPAN installs this bundle it tries immediately to enable
Term::ReadLine so that you do not need to restart your CPAN session.

   Compress::Zlib needs as a prerequisite the zlib library. Currently
(January 1998) this library is not shipped with the Compress::Zlib
distribution.

   In this bundle Term::ReadLine::Perl is preferred over
Term::ReadLine::Gnu because I expect that it gives less problems on
portability.

   Note that all modules in this Bundle are not strict prerequisites to
get a working CPAN.pm. CPAN.pm can work quite well without the other
modules (except for Net::FTP which is really highly recommended). The
other modules are just goodies that make using CPAN.pm more fun.

AUTHOR
======

   Andreas König


File: pm.info,  Node: Bundle/Cisco/Conf,  Next: Bundle/DBD/CSV,  Prev: Bundle/CPAN,  Up: Module List

A bundle to install the Cisco::Conf module.
*******************************************

NAME
====

   Bundle::Cisco::Conf - A bundle to install the Cisco::Conf module.

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::Cisco::Conf''

CONTENTS
========

   Data::Dumper

   Net::Cmd

   Net::Telnet

   IO::AtomicFile

DESCRIPTION
===========

   This bundle includes all that's needed to run the Cisco::Conf module.


File: pm.info,  Node: Bundle/DBD/CSV,  Next: Bundle/HTML/EP,  Prev: Bundle/Cisco/Conf,  Up: Module List

A bundle to install the DBD::CSV driver
***************************************

NAME
====

   Bundle::DBD::CSV - A bundle to install the DBD::CSV driver

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::DBD::CSV''

CONTENTS
========

   DBI 1.02

   Text::CSV_XS 0.14

   SQL::Statement 0.1006

   DBD::CSV

DESCRIPTION
===========

   This bundle includes all that's needed to access so-called CSV (Comma
Separated Values) files via a pseudo SQL engine (SQL::Statement) and DBI.


File: pm.info,  Node: Bundle/HTML/EP,  Next: Bundle/HTML/Mason,  Prev: Bundle/DBD/CSV,  Up: Module List

A bundle to install the HTML::EP package
****************************************

NAME
====

   Bundle::HTML::EP - A bundle to install the HTML::EP package

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::HTML::EP''

CONTENTS
========

   DBI 1.02

   Data::Dumper

   Storable

   CGI::Cookie

   Bundle::LWP

   Net::SMTP

   Mail::Internet 1.32

   HTML::EP

DESCRIPTION
===========

   This bundle includes all that's needed to run the HTML::EP package with
your WWW server.


File: pm.info,  Node: Bundle/HTML/Mason,  Next: Bundle/Interchange,  Prev: Bundle/HTML/EP,  Up: Module List

A bundle to install the HTML::Mason package
*******************************************

NAME
====

   Bundle::HTML::Mason - A bundle to install the HTML::Mason package

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::HTML::Mason''

CONTENTS
========

   Data::Dumper

   MLDBM

   HTML::Mason

DESCRIPTION
===========

   This bundle includes all that's needed to run the HTML::Mason package.


File: pm.info,  Node: Bundle/Interchange,  Next: Bundle/IspMailGate,  Prev: Bundle/HTML/Mason,  Up: Module List

A bundle of the modules nice to have for Interchange.
*****************************************************

NAME
====

   Bundle::Interchange - A bundle of the modules nice to have for
Interchange.

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::Interchange''

CONTENTS
========

   MD5

   MIME::Base64

   Bundle::LWP

   Term::ReadKey

   Term::ReadLine::Perl

   Business::UPS

   SQL::Statement

   Storable

   DBI

   Safe::Hole

DESCRIPTION
===========

   This bundle installs the prerequisites for Interchange as well as some
modules that are not strictly necessary.

   (Interchange was formerly known as Minivend.)

   After installing this bundle, it is recommended that you quit the
current session and then run Interchange's `makecat' program. That will
give you the benefit of line completion and history.

   The core functions of Interchange *will* run with a stock Perl, but to
use some features of Interchange (like the administrative interface) you
will need these modules.

MD5 This module is used to generate unique cache keys. If you don't have it, then keys will be computed with a checksum that has a very low but not infinitesimal chance of causing a cache conflict.
Bundle::LWP Certain parts of these modules (URI::URL and MIME::Base64) are required for Interchange's internal HTTP server. Also, Business::UPS, for calculating shipping, requires this.
Storable If you have this module session save speed increases by anywhere from 25-60%. Highly recommended for busy systems.
Business::UPS Enables lookup of shipping costs directly from www.ups.com.
SQL::Statement Enables SQL-style search query statements for Interchange.
Safe::Hole This helps Interchange deal with the object-creation restrictions of *Safe.pm*, used to encourage security.
DBI Most people want to use SQL with Interchange, and this is a requirement. You will also need the appropriate DBD module, i.e. DBD::mysql to support *MySQL*.
Term::ReadKey Helps Term::ReadLine::Perl generate completions and editing.
Term::ReadLine::Perl Gives you filename completion and command history in the makecat program. Not used otherwise.
AUTHOR
======

   Mike Heins, <heins@akopia.com>


File: pm.info,  Node: Bundle/IspMailGate,  Next: Bundle/LWP,  Prev: Bundle/Interchange,  Up: Module List

A bundle to install the IspMailGate email filter.
*************************************************

NAME
====

   Bundle::IspMailGate - A bundle to install the IspMailGate email filter.

SYNOPSIS
========

   `perl -MCPAN -e 'install IspMailGate''

CONTENTS
========

   MD5

   MIME::Base64

   Net::SMTP

   Mail::Internet

   MIME::Tools

   IO::Tee

DESCRIPTION
===========

   This bundle includes all that's needed to run the HTML::EP package with
your WWW server.


File: pm.info,  Node: Bundle/LWP,  Next: Bundle/MP3,  Prev: Bundle/IspMailGate,  Up: Module List

A bundle to install all libwww-perl related modules
***************************************************

NAME
====

   Bundle::LWP - A bundle to install all libwww-perl related modules

SYNOPSIS
========

     perl -MCPAN -e 'install Bundle::LWP'

CONTENTS
========

   URI 1.10           - There are URIs everywhere

   Net::FTP 2.00      - If you want ftp://-support

   MIME::Base64       - Used in authentication headers

   Digest::MD5        - Needed to do Digest authentication

   HTML::Tagset       - Needed by HTML::Parser

   HTML::Parser       - Need by HTML::HeadParser

   HTML::HeadParser   - To get the correct $res->base

   LWP                - The reason why you need the modules above

DESCRIPTION
===========

   This bundle defines all reqreq modules for libwww-perl.

AUTHOR
======

   Gisle Aas <gisle@aas.no>


File: pm.info,  Node: Bundle/MP3,  Next: Bundle/Mail/IspMailGate,  Prev: Bundle/LWP,  Up: Module List

A bundle to install all MP3-related modules
*******************************************

NAME
====

   Bundle::MP3 - A bundle to install all MP3-related modules

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::MP3''

CONTENTS
========

   MP3::Info               - For MP3::Info by Chris Sandor

   Digest::MD5		- Used by MP3::Napster

   MP3::Napster		- For MP3::Napster by Lincoln Stein

   Bundle::Xmms            - For Xmms by Doug MacEachern

DESCRIPTION
===========

   This bundle installs a bunch of modules related to sharing and playing
MP3 files, including MP3::Info by Chris Sandor, MP3::Napster, by Lincoln
Stein, and the Xmms bundle by Doug MacEachern.

AUTHOR
======

   Lincoln Stein <`lstein@cshl.org'>


File: pm.info,  Node: Bundle/Mail/IspMailGate,  Next: Bundle/Minivend,  Prev: Bundle/MP3,  Up: Module List

A bundle to install the IspMailGate
***********************************

NAME
====

   Bundle::Mail::IspMailGate - A bundle to install the IspMailGate

SYNOPSIS
========

   `perl -MCPAN -e 'install Bundle::Mail::IspMailGate''

CONTENTS
========

   IO::Scalar

   IO::Tee

   Net::SMTP

   Mail::Internet

   Digest::MD5

   MIME::Base64

   MIME::Tools

DESCRIPTION
===========

   This bundle includes all that's needed to install the IspMailGate.
Usage:

     perl -MCPAN -e shell
     install Bundle::Mail::IspMailGate


