This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: CGI/BasePlus,  Next: CGI/CIPP,  Prev: CGI/Base,  Up: Module List

HTTP CGI Base Class with Handling of Multipart Forms
****************************************************

NAME
====

   CGI::BasePlus - HTTP CGI Base Class with Handling of Multipart Forms

DESCRIPTION
===========

   This module implements a CGI::BasePlus object that is identical in
behavior to CGI::Base except that it provides special handling for
postings of MIME type multipart/form-data (which may get very long).  In
the case of these types of postings, parts that are described as being
from a file upload are copied into a temporary file in /usr/tmp, a
filehandle is opened on the temporary files, and the name of the
filehandle is returned to the caller in the $CGI::Base:QUERY_STRING
variable.

   Please see *Note CGI/Base: CGI/Base, for more information.

SEE ALSO
--------

   URI::URL, CGI::Request, CGI::MiniSvr, CGI::Base


File: pm.info,  Node: CGI/CIPP,  Next: CGI/Cache,  Prev: CGI/BasePlus,  Up: Module List

Use CIPP embedded HTML Pages in a CGI environment
*************************************************

NAME
====

   CGI::CIPP - Use CIPP embedded HTML Pages in a CGI environment

DESCRIPTION
===========

   CGI::CIPP is a Perl module which enables you to use CIPP on every CGI
capable webserver. It is based on a central wrapper script, which does all
the preprocessing. It executes the generated Perl code directly afterwards.

   Additionally, it implements a filesystem based cache for the generated
code. Preprocessing is done only when the corresponding CIPP source code
changed on disk, otherwise this step is skipped.

WHAT IS CIPP?
=============

   CIPP is a Perl module for translating CIPP sources to pure Perl
programs. CIPP defines a HTML embedding language also called CIPP which
has powerful features for CGI and database developers.

   Many standard CGI and database operations (and much more) are covered
by CIPP, so the developer does not need to code them again and again.

   CIPP is not part of this distribution, please download it from CPAN.

SIMPLE CIPP EXAMPLE
===================

   To give you some imagination of what you can do with CIPP: here is a
(really) simple example of using CIPP in a HTML source to retrieve some
information from a database. Think this as a HTML page which is "executed"
on the fly by your webserver.

   Note: there is no code to connect to the database. This is done
implicitely. The configuration is taken from the central CGI::CIPP wrapper
srcipt.

     # print table of users who match the given parameter
     
     <?INTERFACE INPUT="$search_name">

     <HTML>
     <HEAD><TITLE>tiny litte CIPP example</TITLE></HEAD>
     <BODY>
     <H1>Users matching '$search_name'</H1>
     <P>

     <TABLE BORDER=1>
     <TR><TD>Name</TD><TD>Adress</TD><TD>Phone</TD></TR>
     <?SQL SQL="select name, adress, phone
                from   people
     	     where  name like '%' || ? || '%'"
           PARAMS="$search_name"
     	MY VAR="$n, $a, $p">
       <TR><TD>$n</TD><TD>$a</TD><TD>$p</TD></TR>
     <?/SQL>
     </TABLE>

     </BODY>
     </HTML>

SYNOPSIS
========

   Create a CGI program in a directory, where CGI programs usually reside
on your server (e.g. /cgi-bin/cipp), or configure this program another way
to be a CGI program (see sections beyond for details).

   This program is the central CGI::CIPP wrapper. It only consists of a
single function call to the CGI::CIPP module, with a hash of parameters
for configuration. This is a example:

     #!/usr/local/bin/perl

     use strict;
     use CGI::CIPP;

     # this program has the URL /cgi-bin/cipp

     CGI::CIPP->request (
     	document_root  => '/www/cippfiles',
     	directoy_index => 'index.cipp',
     	cache_dir      => '/tmp/cipp_cache',
     	databases      => {
     		test => {
     			data_source => 'dbi:mysql:test',
     			user        => 'dbuser',
     			password    => 'dbpassword',
     			auto_commit => 1
     		},
     		foo => {
     			...
     		}
     	}
     	default_database => 'test',
     	lang => 'EN'
     );

   A brief description of the parameters passed to the CGI::CIPP->request
call follows:

document_root
     This is the base directory where all your CIPP files resides.  You
     will place CIPP programs, Includes and Config files inside this
     subdirectory. Using subdirectories is permitted. If you use the
     Apache webserver you should point this to your Apache DocumentRoot
     and set up a extra handler for CIPP. See the Apache chapter beyond
     for details.

d*irectory_index*
     If you want CGI::CIPP to treat a special filename as a directory
     index file, pass this filename here. If you access a directory with
     CGI::CIPP and a according index file is found there, it will be
     executed.

cache_dir
     This names the directory where CGI::CIPP can store the preprocessed
     CIPP programs. If the directory does not exist it will be created.
     Aware, that the directory must have write access for the user under
     which your webserver software is running.

databases
     This parameter contains a hash reference, which defines several
     database configurations. The key of this hash is the CIPP internal
     name of the database, which can be addressed by the DB parameter of
     all CIPP SQL commands. The value is a hash reference with the
     following keys defined.

*  data_source*
     This must be a DBI conforming data source string. Please refer to the
     DBI documentation for details about this.

*  user*
     This is the username CIPP uses to connect to the database

*  password*
     This password is used for the database user.

*  auto_commit*
     This parameter sets the initial state of the AutoCommit flag.  Please
     refer to the description of the <?AUTOCOMMIT> command or the DBI
     documentation for details about AutoCommit.

default_database
     This takes the name of the default database. This database is always
     used, if a CIPP SQL command ommits the DB parameter.  The value
     passed here must be a defined key in the databases hash.

lang
     CIPP has multilanguage support for its error messages, actually
     english ('EN') and german ('DE') are supported.

   The CGI wrapper program uses the CGI feature PATH_INFO to determine
which page should be executed. To execute the CIPP page 'test.cipp'
located in '/www/htdocs/cippfiles/foo/test.cipp' you must specify the
following URL (assuming the configuration of the example above):

     http://somehost/cgi-bin/cipp/foo/test.cipp

   You simply add the path of your page (relative to the path you
specified with the document_root parameter) to the URL of the CGI wrapper.

   Be aware of the real URL of your page if you use relative URL's to non
CIPP pages in your CIPP page. In the above example relative URL's must
consider that the CGI wrapper program is located in a different location
as the directory you declared as the CIPP document root. This implies that
it is not possible to place CIPP program files and traditional static HTML
documents or images into the same directory.

APACHE CONFIGURATION
====================

   If you're using the Apache webserver (what is always recommended :) you
can avoid the above stated disadvantages. In this case you should
configure your CIPP CGI wrapper program as a extra handler.

   Simply add the following directives to your appropriate Apache config
file:

     AddHandler x-cipp-execute cipp
     Action x-cipp-execute /cgi-bin/cipp

   The CGI wrapper program is still located in a extra cgi-bin directory.
But now all files with the extension .cipp are handled through it.

   The CGI::CIPP configuration slightly changes, we reasign the
document_root:

     document_root	/www/htdocs

   We now declare the Apache DocumentRoot also to be the document_root of
CGI::CIPP, so no special subdirectory is needed.

   This is a example URL for a CIPP page located in
/www/htdocs/foo/test.cipp

     http://somehost/foo/test.cipp

   Now you are able to place CIPP files on your webserver wherever you
want, because there is no special CIPP directory anymore. Only the suffix
.cipp is relevant, due to the AddHandler directive above. So you can mix
traditional static documents with CIPP files and relative URL adressing is
no problem at all.

Security Hint
-------------

   To prevent users from viewing your Include or Config files, you should
configure your webserver to forbid access to these files. In case of
Apache add the following contatiner to your Apache configuration:

     <Location ~ "\.(conf|inc)$">
       Order allow,deny
       Deny from all
     </Location>

   This assumes that you name your Config files *.conf and your Include
*.inc. CIPP does not care about the extensions of your Config and Include
files. To make your life easier, you should ;)

CGI::SpeedyCGI and CIPP::CGI
============================

   There exists a really nice module called CGI::SpeedyCGI, which is
available freely via CPAN. It implements a nifty way of making Perl CGI
processes persistent, so subseqeuent CGI calls are answered much more
faster.

   Using CIPP::CGI together with CGI::SpeedyCGI is easy. Simply replace
the perl interpreter path in the shebang line `#!/usr/local/bin/perl' with
the according path to the speedy program, e.g.: `#!/usr/local/bin/speedy'.

   Refer to the CGI::SpeedyCGI documentation for details about configuring
SpeedyCGI. I recommend the usage of the -r and -t switch, so you are able
to control the number of parallel living speedy processes, e.g.

     #!/usr/local/bin/speedy -- -r30 -t120

   Each speedy process now answeres a maximum of 30 requests and then dies.
If a process is idle for longer than 120 secs it dies also.

AUTHOR
======

   Joern Reder <joern@dimedis.de>

COPYRIGHT
=========

   Copyright 1998-1999 Joern Reder, All Rights Reserved

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   perl(1), CIPP(3pm), Apache::CIPP(3pm), CGI::SpeedyCGI(3pm)


File: pm.info,  Node: CGI/Cache,  Next: CGI/Carp,  Prev: CGI/CIPP,  Up: Module List

Perl extension to help cache output of time-intensive CGI scripts so that subsequent visits to such scripts will not cost as much time.
***************************************************************************************************************************************

NAME
====

   CGI::Cache - Perl extension to help cache output of time-intensive CGI
scripts so that subsequent visits to such scripts will not cost as much
time.

WARNING
=======

   The interface as of version 1.01 has changed considerably and is NOT
compatible with earlier versions.

SYNOPSIS
========

     use CGI;
     use CGI::Cache;

     my $query = new CGI;

     # Set up a cache in /tmp/CGI_Cache/demo_cgi, with publicly
     # read/writable cache entries, a maximum size of 20 megabytes,
     # and a time-to-live of 6 hours.
     CGI::Cache::setup( { cache_key => '/tmp/CGI_Cache',
                          namespace => 'demo_cgi',
                          filemode => 0666,
                          max_size => 20 * 1024 * 1024,
                          expires_in => 6 * 60 * 60,
                        } );

     # CGI::Vars requires CGI version 2.50 or better
     CGI::Cache::set_key($query->Vars);
     CGI::Cache::start();

     print "Content-type: text/html\n\n";

     print <<EOF;
     <html><body>
     This prints to STDOUT, which will be cached.
     If the next visit is within 6 hours, the cached STDOUT
     will be served instead of executing these 'prints'.
     </body></html>
     EOF

DESCRIPTION
===========

   This module is intended to be used in a CGI script that may benefit
from caching its output. Some CGI scripts may take longer to execute
because the data needed in order to construct the page may not be readily
available. Such a script may need to query a remote database, or may rely
on data that doesn't arrive in a timely fashion, or it may just be
computationally intensive.  Nonetheless, if you can afford the tradeoff of
showing older, cached data vs. CGI execution time, then this module will
perform that function.

   This module was written such that any existing CGI code could benefit
from caching without really changing any of existing CGI code guts.  The
CGI script can do just what it has always done, that is, construct an html
page and print it to the STDOUT file descriptor, then exit.  What you'll
do in order to cache pages is include the module, specify some cache
options and the cache key, and then call start() to begin caching output.

   Internally, the CGI::Cache module ties the STDOUT file descriptor to an
internal variable to which all output to STDOUT is saved. When the user
calls stop() (or the END{} block of CGI::Cache is executed during script
shutdown) the contents of the variable are inserted into the cache using
the cache key the user specified earlier with set_key().

   Once a page has been cached in this fashion, then a subsequent visit to
that CGI script will check for an existing cache entry for the given key
before continuing through the code. If the file exists, then the cache
file's content is printed to the real STDOUT and the process exits before
executing the regular CGI code.

CHOOSING A CACHE KEY
--------------------

   The cache key is used by CGI::Cache to determine when cached output can
be used. The key should be a unique data structure that fully describes
the execution of the script. Conveniently, CGI::Cache can take the CGI
module's parameters (using CGI::Vars) as the key. However, in some cases
you may want to specially construct the key.

   For example, say we have a CGI script "airport" that computes the
number of miles between major airports. You supply two airport codes to
the script and it builds a web pages that reports the number of miles by
air between those two locations. In addition, there is a third parameter
which tells the script whether to write debugging information to a log
file. Suppose the URL for Indianapolis Int'l to Chicago O'Hare looked like:

     http://www.some.machine/cgi/airport?from=IND&to=ORD&debug=1

   We might want to remove the debug parameter because the output from the
user's perspective is the same regardless of whether a log file is written:

     my $params = $query->Vars;
     delete $params->{'debug'};
     CGI::Cache::set_key($params);
     CGI::Cache::start();

THE CGI::CACHE ROUTINES
-----------------------

setup( \%options );
     Sets up the cache. The parameters are the same as the parameters for
     the File::Cache module's new() method, with the same defaults. Below
     is a brief overview of the options and their defaults. This overview
     may be out of date with your version of File::Cache. Consult *perldoc
     File::Cache* for more accurate information.

     NOTE: If you plan to modify warn() or die() (i.e. redefine
     $SIG{__WARN__} or $SIG{__DIE__}) so that they no longer print to
     STDERR, you must do so before calling setup(). For example, if you do
     a "require CGI::Carp qw( fatalsToBrowser)", make sure you do it
     before calling CGI::Cache::setup().

    $options{cache_key}
          The cache_key is the location of the cache. Here cache_key is
          used in keeping with the terminology used by File::Cache, and is
          different from the key referred to in set_key below.

    $options{namespace}
          Namespaces provide isolation between cache objects. It is
          recommended that you use a namespace that is unique to your
          script. That way you can have multiple scripts whose output is
          cached by CGI::Cache, and they will not collide. This value
          defaults to a subdirectory of your temp directory whose name
          matches the name of your script (as reported by
          $ENV{SCRIPT_NAME}, or $0 if $ENV{SCRIPT_NAME} is not defined).

    $options{expires_in}
          If the "expires_in" option is set, all objects in this cache
          will be cleared after that number of seconds. If expires_in is
          not set, the web pages will never expire. The default is 24
          hours.

    $options{cache_key}
          The "cache_key" is used to determine the underlying filesystem
          namespace to use. Leaving this unset will cause the cache to be
          created in a subdirectory of your temporary directory called
          CGI_Cache. (The term "key" here is a bit misleading in light of
          the usage of the term earlier-this is really the path to the
          cache.)

    $options{max_size}
          "max_size" specifies the maximum size of the cache, in bytes.
          Cache objects are removed during the set() operation in order to
          reduce the cache size before the new cache value is added. The
          max_size will be maintained regardless of the value of
          auto_remove_stale. The default size is unlimited.

set_key ( <data> );
     set_key takes any type of data (e.g. a list, a string, a reference to
     a complex data structure, etc.) and uses it to create a unique key to
     use when caching the script's output.

start();
     Could you guess that the start() routine is what does all the work? It
     is this call that actually looks for an existing cache file, returning
     its content if it exists, then exits. If the cache file does not
     exist, then it captures the STDOUT filehandle and allows the CGI
     script's normal STDOUT be redirected to the cache file.

stop( [<cache_output> = 1] );     <cache_output> - do we write the captured STDOUT to a  cache file?
     The stop() routine tells us to stop capturing STDOUT.  The argument
     "cache_output" tells us whether or not to store the captured output in
     the cache. By default this argument is 1, since this is usually what
     we want to do. In an error condition, however, we may not want to
     cache the output.  A cache_output argument of 0 is used in this case.

     You don't have to call the stop() routine if you simply want to catch
     all STDOUT that the script generates for the duration of its
     execution.  If the script exits without calling stop(), then the END{}
     block of the module will check to see of stop() has been called, and
     if not, it will call it. Note that CGI::Cache will detect whether your
     script is exiting as the result of an error, and will not cache the
     output in this case.

BUGS
====

   Contact david@coppit.org for bug reports and suggestions.

AUTHOR
======

   The original code (written before October 1, 2000) was written by Broc
Seib, and is copyright (c) 1998 Broc Seib. All rights reserved.

   Maintenance of CGI::Cache is now being done by David Coppit
(david@coppit.org).

   This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

     File::Cache
     perldoc -f open


File: pm.info,  Node: CGI/Carp,  Next: CGI/ClientError,  Prev: CGI/Cache,  Up: Module List

CGI routines for writing to the HTTPD (or other) error log
**********************************************************

NAME
====

   CGI::Carp - CGI routines for writing to the HTTPD (or other) error log

SYNOPSIS
========

     use CGI::Carp;

     croak "We're outta here!";
     confess "It was my fault: $!";
     carp "It was your fault!";
     warn "I'm confused";
     die  "I'm dying.\n";

     use CGI::Carp qw(cluck);
     cluck "I wouldn't do that if I were you";

     use CGI::Carp qw(fatalsToBrowser);
     die "Fatal error messages are now sent to browser";

DESCRIPTION
===========

   CGI scripts have a nasty habit of leaving warning messages in the error
logs that are neither time stamped nor fully identified.  Tracking down
the script that caused the error is a pain.  This fixes that.  Replace the
usual

     use Carp;

   with

     use CGI::Carp

   And the standard warn(), die (), croak(), confess() and carp() calls
will automagically be replaced with functions that write out nicely
time-stamped messages to the HTTP server error log.

   For example:

     [Fri Nov 17 21:40:43 1995] test.pl: I'm confused at test.pl line 3.
     [Fri Nov 17 21:40:43 1995] test.pl: Got an error message: Permission denied.
     [Fri Nov 17 21:40:43 1995] test.pl: I'm dying.

REDIRECTING ERROR MESSAGES
==========================

   By default, error messages are sent to STDERR.  Most HTTPD servers
direct STDERR to the server's error log.  Some applications may wish to
keep private error logs, distinct from the server's error log, or they may
wish to direct error messages to STDOUT so that the browser will receive
them.

   The `carpout()' function is provided for this purpose.  Since carpout()
is not exported by default, you must import it explicitly by saying

     use CGI::Carp qw(carpout);

   The carpout() function requires one argument, which should be a
reference to an open filehandle for writing errors.  It should be called
in a BEGIN block at the top of the CGI application so that compiler errors
will be caught.  Example:

     BEGIN {
       use CGI::Carp qw(carpout);
       open(LOG, ">>/usr/local/cgi-logs/mycgi-log") or
         die("Unable to open mycgi-log: $!\n");
       carpout(LOG);
     }

   carpout() does not handle file locking on the log for you at this point.

   The real STDERR is not closed - it is moved to CGI::Carp::SAVEERR.  Some
servers, when dealing with CGI scripts, close their connection to the
browser when the script closes STDOUT and STDERR.  CGI::Carp::SAVEERR is
there to prevent this from happening prematurely.

   You can pass filehandles to carpout() in a variety of ways.  The
"correct" way according to Tom Christiansen is to pass a reference to a
filehandle GLOB:

     carpout(\*LOG);

   This looks weird to mere mortals however, so the following syntaxes are
accepted as well:

     carpout(LOG);
     carpout(main::LOG);
     carpout(main'LOG);
     carpout(\LOG);
     carpout(\'main::LOG');

     ... and so on

   FileHandle and other objects work as well.

   Use of carpout() is not great for performance, so it is recommended for
debugging purposes or for moderate-use applications.  A future version of
this module may delay redirecting STDERR until one of the CGI::Carp
methods is called to prevent the performance hit.

MAKING PERL ERRORS APPEAR IN THE BROWSER WINDOW
===============================================

   If you want to send fatal (die, confess) errors to the browser, ask to
import the special "fatalsToBrowser" subroutine:

     use CGI::Carp qw(fatalsToBrowser);
     die "Bad error here";

   Fatal errors will now be echoed to the browser as well as to the log.
CGI::Carp arranges to send a minimal HTTP header to the browser so that
even errors that occur in the early compile phase will be seen.  Nonfatal
errors will still be directed to the log file only (unless redirected with
carpout).

Changing the default message
----------------------------

   By default, the software error message is followed by a note to contact
the Webmaster by e-mail with the time and date of the error.  If this
message is not to your liking, you can change it using the set_message()
routine.  This is not imported by default; you should import it on the
use() line:

     use CGI::Carp qw(fatalsToBrowser set_message);
     set_message("It's not a bug, it's a feature!");

   You may also pass in a code reference in order to create a custom error
message.  At run time, your code will be called with the text of the error
message that caused the script to die.  Example:

     use CGI::Carp qw(fatalsToBrowser set_message);
     BEGIN {
        sub handle_errors {
           my $msg = shift;
           print "<h1>Oh gosh</h1>";
           print "Got an error: $msg";
       }
       set_message(\&handle_errors);
     }

   In order to correctly intercept compile-time errors, you should call
set_message() from within a BEGIN{} block.

MAKING WARNINGS APPEAR AS HTML COMMENTS
=======================================

   It is now also possible to make non-fatal errors appear as HTML
comments embedded in the output of your program.  To enable this feature,
export the new "warningsToBrowser" subroutine.  Since sending warnings to
the browser before the HTTP headers have been sent would cause an error,
any warnings are stored in an internal buffer until you call the
warningsToBrowser() subroutine with a true argument:

     use CGI::Carp qw(fatalsToBrowser warningsToBrowser);
     use CGI qw(:standard);
     print header();
     warningsToBrowser(1);

   You may also give a false argument to warningsToBrowser() to prevent
warnings from being sent to the browser while you are printing some
content where HTML comments are not allowed:

     warningsToBrowser(0);    # disable warnings
     print "<SCRIPT type=javascript><!--\n";
     print_some_javascript_code();
     print "//--></SCRIPT>\n";
     warningsToBrowser(1);    # re-enable warnings

   Note: In this respect warningsToBrowser() differs fundamentally from
fatalsToBrowser(), which you should never call yourself!

CHANGE LOG
==========

   1.05 carpout() added and minor corrections by Marc Hedlund
<hedlund@best.com> on 11/26/95.

   1.06 fatalsToBrowser() no longer aborts for fatal errors within
eval() statements.

   1.08 set_message() added and carpout() expanded to allow for FileHandle
    objects.

   1.09 set_message() now allows users to pass a code REFERENCE for
really custom error messages.  croak and carp are now      exported by
default.  Thanks to Gunther Birznieks for the      patches.

   1.10 Patch from Chris Dean (ctdean@cogit.com) to allow      module to
run correctly under mod_perl.

   1.11 Changed order of &gt; and &lt; escapes.

   1.12 Changed die() on line 217 to CORE::die to avoid -w warning.

   1.13 Added cluck() to make the module orthogonal with Carp.       More
mod_perl related fixes.

   1.20 Patch from Ilmari Karonen (perl@itz.pp.sci.fi):  Added
warningsToBrowser().  Replaced <CODE> tags with <PRE> in
fatalsToBrowser() output.

AUTHORS
=======

   Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   Address bug reports and comments to: lstein@cshl.org

SEE ALSO
========

   Carp, CGI::Base, CGI::BasePlus, CGI::Request, CGI::MiniSvr, CGI::Form,
CGI::Response


File: pm.info,  Node: CGI/ClientError,  Next: CGI/ConvertParam,  Prev: CGI/Carp,  Up: Module List

send minimalistic error messages to the browser
***********************************************

NAME
====

     CGI::ClientError - send minimalistic error messages to the browser

SYNOPSIS
========

     use CGI::ClientError;
     &CGI::ClientError::setheaderfile('/path/to/some/header');
     &CGI::ClientError::setfooterfile('/path/to/some/footer');
     &CGI::ClientError::setheader("Content-Type: text/plain\n\nYou've done something wrong: ");
     &CGI::ClientError::setfooter("If this is unclear, go hang yourself.");

     &CGI::ClientError::sethandler(sub { die; });

     (...)

     if (clientisadork) { &CGI::ClientError::error("You are a dork!");
     # or
     if (clientisadork) { &cgi_report_error("You are a dork!");

DESCRIPTION
===========

   Errors might appear in a CGI.  If the script knows what is wrong, it
should tell what is wrong.  But I think it's important to separate between
when it should tell the client, and when it should tell the webmaster.
The user/client shouldn't be get error messages that are irrelevant or
meaningless or even possibly exploitable - as "out of disk", "out of
memory", "core dumped", etc.  Instead, the script should die, the error
should be logged, and perhaps even sent by mail to the webmaster - and
perhaps even to his cellphone.  The user should get an 500 and a clear,
friendly message that the problem is at the server side and probably will
be dealt with ("try again later, or mail webmaster").

   Anyway, sometimes the client is to blame for the error.  He has typed
in a text string in a number box, he claims beeing born in 2019-14-14, he
has been typing in a long URL with illegal parameters, etc. Then the
client should get an informative error message.  That's what this small
module is for.

   Three variables might be set by the caller program, header, footer and
handler. The header and footer is what to output before and after the
error message. The default header is:   Content-Type: text/html
<H1>Error</h1>   Here is an error message for you:<br>   <i>

   The default footer is:   </i><br>   If something is unclear, feel free
to contact the   webmaster.

   The default handler is ... do nothing.

   Somebody has probably written scientific papers about how to be
respectfully and pedagogic when telling a user that he has done an error.
I think it is wise to be humble, don't expect too much - remember, the
average web user of today is not a typical unix user.  I don't know.  I
don't care.

   This module probably stinks - but the idea itself doesn't; I think it's
proper to use "die" if it's a real server error, and some other sub /
method if it's actually a client error.

AUTHOR
======

   Tobias Brox <tobix@irctos.org>


File: pm.info,  Node: CGI/ConvertParam,  Next: CGI/Cookie,  Prev: CGI/ClientError,  Up: Module List

Decorator class which adds several hook to CGI::param().
********************************************************

NAME
====

   CGI::ConvertParam - Decorator class which adds several hook to
CGI::param().

SYNOPSIS
========

     package CGI::ConvertParam::OngetUTF8;
     use base 'CGI::ConvertParam';
     use Jcode;

     sub do_convert_on_get
     {
         my $self = shift;
         my $parameter_value = shift;
         return Jcode->new($parameter_value)->utf8;
     }
     1;

     package client;
     use CGI;
     use CGI::ConvertParam::OngetUTF8;

     $query = CGI::ConvertParam::OngetUTF8->new(CGI->new);
     print $query->param('parameter_foo');

DESCRIPTION
===========

   CGI::ConvertParam and the subclass are Decorator which adds some hooks
to the CGI::param() method.

EXAMPLE
=======

All parameters are converted to EUC-JP
--------------------------------------

     package CGI::ConvertParam::EUC;
     use base 'CGI::ConvertParam';
     use Jcode;

     sub initialize
     {
         my $self = shift;
         $self->convert_all_param;
     }

     sub do_convert_all
     {
         my $self    = shift;
         my $strings = shift;
         return Jcode->new($strings)->euc;
     }
     1;

     package main;
     use CGI;
     use CGI::ConvertParam::EUC;
     my $query = CGI::ConvertParam::EUC->new(CGI->new);
     print 'Name(EUC-JP):', $query->param('NAME');

Convert Shift-JIS on Setting the value or values of a named parameter:
----------------------------------------------------------------------

     package CGI::ConvertParam::OnsetShiftJIS;
     use base 'CGI::ConvertParam';
     use Jcode;

     sub do_convert_on_set
     {
         my $self    = shift;
         my $strings = shift;
         return Jcode->new($strings)->sjis;
     }
     1;

     package main;
     use CGI;
     use CGI::ConvertParam::OnsetShiftJIS;
     my $query = CGI::ConvertParam::OnsetShiftJIS->new(CGI->new);
     $query->param(NAME => $value);
     print 'Name(Shift-JIS):', $query->param('NAME');

Convert UTF-8 on Fetching the value or values of a named parameter:
-------------------------------------------------------------------

     package CGI::ConvertParam::OngetUTF8;
     use base 'CGI::ConvertParam';
     use Jcode;

     sub do_convert_on_get
     {
         my $self    = shift;
         my $strings = shift;
         return Jcode->new($strings)->utf8;
     }
     1;

     package main;
     use CGI;
     use CGI::ConvertParam::OngetUTF8;
     my $query = CGI::ConvertParam::OngetUTF8->new(CGI->new);
     $query->param(NAME => $value);
     print 'Name(UTF-8):', $query->param('NAME');

METHOD
======

Class method
------------

new(*CGI_OBJECT*)
     The new() method is the constructor for a CGI::ConvertParam and
     sub-class. *CGI_BOJECT* is the reference of the CGI instance. It
     return a specialized CGI instance.

Instance method
---------------

convert_all_param()
     This method is convert the all named parameter.

Subclassing and Override methods
--------------------------------

   CGI::ConvertParam implements some methods which are expected to be
overridden by implementing them in your subclass module. These methods are
as follows:

initialize()
     This method is colled by the inherited new() constructor method. The
     initialize() method should be used to define the following
     property/methods:

do_convert_on_set()
     This method is called by *param('name' => $value)* method. The
     do_convert_on_set() method shuld be used to define the converter.

do_convert_on_get()
     This method is called by *param('name')* method. The
     do_convert_on_get() method shuld be used to define the converter.

do_convert_all_param
     This method is called by convert_all_param() method. The
     *do_convert_all_param()* method shuld be used to define the converter.

Data-access method
------------------

query()
     This method is return the original CGI instance.

SEE ALSO
========

   *Note CGI: CGI,

AUTHOR
======

   OYAMA Hiroyuki <oyama@crayfish.co.jp> http://perl.infoware.ne.jp/

COPYRIGHT
=========

   Copyright(c) 2000, OYAMA Hiroyuki. Japan. All rights reserved.

   CGI::ConvertParam class may be copied only under the terms of either
the Artistic License or the GNU General Public License, which may be found
in the Perl 5 source kit.


File: pm.info,  Node: CGI/Cookie,  Next: CGI/Debug,  Prev: CGI/ConvertParam,  Up: Module List

Interface to Netscape Cookies
*****************************

NAME
====

   CGI::Cookie - Interface to Netscape Cookies

SYNOPSIS
========

     use CGI qw/:standard/;
     use CGI::Cookie;

     # Create new cookies and send them
     $cookie1 = new CGI::Cookie(-name=>'ID',-value=>123456);
     $cookie2 = new CGI::Cookie(-name=>'preferences',
                                -value=>{ font => Helvetica,
                                          size => 12 }
                                );
     print header(-cookie=>[$cookie1,$cookie2]);

     # fetch existing cookies
     %cookies = fetch CGI::Cookie;
     $id = $cookies{'ID'}->value;

     # create cookies returned from an external source
     %cookies = parse CGI::Cookie($ENV{COOKIE});

DESCRIPTION
===========

   CGI::Cookie is an interface to Netscape (HTTP/1.1) cookies, an
innovation that allows Web servers to store persistent information on the
browser's side of the connection.  Although CGI::Cookie is intended to be
used in conjunction with CGI.pm (and is in fact used by it internally),
you can use this module independently.

   For full information on cookies see

     http://www.ics.uci.edu/pub/ietf/http/rfc2109.txt

USING CGI::Cookie
=================

   CGI::Cookie is object oriented.  Each cookie object has a name and a
value.  The name is any scalar value.  The value is any scalar or array
value (associative arrays are also allowed).  Cookies also have several
optional attributes, including:

*1. expiration date*
     The expiration date tells the browser how long to hang on to the
     cookie.  If the cookie specifies an expiration date in the future, the
     browser will store the cookie information in a disk file and return it
     to the server every time the user reconnects (until the expiration
     date is reached).  If the cookie species an expiration date in the
     past, the browser will remove the cookie from the disk file.  If the
     expiration date is not specified, the cookie will persist only until
     the user quits the browser.

*2. domain*
     This is a partial or complete domain name for which the cookie is
     valid.  The browser will return the cookie to any host that matches
     the partial domain name.  For example, if you specify a domain name
     of ".capricorn.com", then Netscape will return the cookie to Web
     servers running on any of the machines "www.capricorn.com",
     "ftp.capricorn.com", "feckless.capricorn.com", etc.  Domain names
     must contain at least two periods to prevent attempts to match on top
     level domains like ".edu".  If no domain is specified, then the
     browser will only return the cookie to servers on the host the cookie
     originated from.

*3. path*
     If you provide a cookie path attribute, the browser will check it
     against your script's URL before returning the cookie.  For example,
     if you specify the path "/cgi-bin", then the cookie will be returned
     to each of the scripts "/cgi-bin/tally.pl", "/cgi-bin/order.pl", and
     "/cgi-bin/customer_service/complain.pl", but not to the script
     "/cgi-private/site_admin.pl".  By default, the path is set to "/", so
     that all scripts at your site will receive the cookie.

*4. secure flag*
     If the "secure" attribute is set, the cookie will only be sent to your
     script if the CGI request is occurring on a secure channel, such as
     SSL.

Creating New Cookies
--------------------

     $c = new CGI::Cookie(-name    =>  'foo',
                                  -value   =>  'bar',
                                  -expires =>  '+3M',
                                  -domain  =>  '.capricorn.com',
                                  -path    =>  '/cgi-bin/database'
                                  -secure  =>  1
                         );

   Create cookies from scratch with the new method.  The *-name* and
*-value* parameters are required.  The name must be a scalar value.  The
value can be a scalar, an array reference, or a hash reference.  (At some
point in the future cookies will support one of the Perl object
serialization protocols for full generality).

   *-expires* accepts any of the relative or absolute date formats
recognized by CGI.pm, for example "+3M" for three months in the future.
See CGI.pm's documentation for details.

   *-domain* points to a domain name or to a fully qualified host name.
If not specified, the cookie will be returned only to the Web server that
created it.

   *-path* points to a partial URL on the current server.  The cookie will
be returned to all URLs beginning with the specified path.  If not
specified, it defaults to '/', which returns the cookie to all pages at
your site.

   *-secure* if set to a true value instructs the browser to return the
cookie only when a cryptographic protocol is in use.

Sending the Cookie to the Browser
---------------------------------

   Within a CGI script you can send a cookie to the browser by creating
one or more Set-Cookie: fields in the HTTP header.  Here is a typical
sequence:

     my $c = new CGI::Cookie(-name    =>  'foo',
                             -value   =>  ['bar','baz'],
                             -expires =>  '+3M');

     print "Set-Cookie: $c\n";
     print "Content-Type: text/html\n\n";

   To send more than one cookie, create several Set-Cookie: fields.
Alternatively, you may concatenate the cookies together with "; " and send
them in one field.

   If you are using CGI.pm, you send cookies by providing a -cookie
argument to the header() method:

     print header(-cookie=>$c);

   Mod_perl users can set cookies using the request object's header_out()
method:

     $r->header_out('Set-Cookie',$c);

   Internally, Cookie overloads the "" operator to call its as_string()
method when incorporated into the HTTP header.  as_string() turns the
Cookie's internal representation into an RFC-compliant text
representation.  You may call as_string() yourself if you prefer:

     print "Set-Cookie: ",$c->as_string,"\n";

Recovering Previous Cookies
---------------------------

     %cookies = fetch CGI::Cookie;

   fetch returns an associative array consisting of all cookies returned
by the browser.  The keys of the array are the cookie names.  You can
iterate through the cookies this way:

     %cookies = fetch CGI::Cookie;
     foreach (keys %cookies) {
        do_something($cookies{$_});
             }

   In a scalar context, fetch() returns a hash reference, which may be more
efficient if you are manipulating multiple cookies.

   CGI.pm uses the URL escaping methods to save and restore reserved
characters in its cookies.  If you are trying to retrieve a cookie set by
a foreign server, this escaping method may trip you up.  Use raw_fetch()
instead, which has the same semantics as fetch(), but performs no
unescaping.

   You may also retrieve cookies that were stored in some external form
using the parse() class method:

     $COOKIES = `cat /usr/tmp/Cookie_stash`;
     %cookies = parse CGI::Cookie($COOKIES);

Manipulating Cookies
--------------------

   Cookie objects have a series of accessor methods to get and set cookie
attributes.  Each accessor has a similar syntax.  Called without
arguments, the accessor returns the current value of the attribute.
Called with an argument, the accessor changes the attribute and returns
its new value.

name()
     Get or set the cookie's name.  Example:

          $name = $c->name;
          $new_name = $c->name('fred');

value()
     Get or set the cookie's value.  Example:

          $value = $c->value;
          @new_value = $c->value(['a','b','c','d']);

     value() is context sensitive.  In a list context it will return the
     current value of the cookie as an array.  In a scalar context it will
     return the first value of a multivalued cookie.

domain()
     Get or set the cookie's domain.

path()
     Get or set the cookie's path.

expires()
     Get or set the cookie's expiration time.

AUTHOR INFORMATION
==================

   Copyright 1997-1998, Lincoln D. Stein.  All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   Address bug reports and comments to: lstein@cshl.org

BUGS
====

   This section intentionally left blank.

SEE ALSO
========

   *Note CGI/Carp: CGI/Carp,, *Note CGI: CGI,


File: pm.info,  Node: CGI/Debug,  Next: CGI/EncryptForm,  Prev: CGI/Cookie,  Up: Module List

module for CGI programs debugging
*********************************

NAME
====

   CGI::Debug - module for CGI programs debugging

SYNOPSIS
========

     use CGI::Debug;

     use CGI::Debug( report => ['errors', 'empty_body', 'time',
     			    'params', 'cookies', 'environment',
     			    ],
     		 on     => 'fatals',
     		 to     => { browser => 1,
     			     log     => 1,
     			     file    => '/tmp/my_error',
     			     mail    => ['staff@company.orb',
     					 'webmaster',
     					 ],
     			 },
     		 header => 'control',
     		 set    => { error_document => 'oups.html' },
     		 );

DESCRIPTION
===========

   CGI::Debug will catch (almost) all compilation and runtime errors and
warnings and will display them in the browser.

   Just "use CGI::Debug" on the second row in your program.  The module
will not change the behaviour of your cgi program. As long as your program
works, you will not notice the modules presence.

   At any time you can remove the "use CGI::Debug" without changing the
behaviour of your program. It will only start faster.

   The actions of CGI::Debug is determined by, in order:   1. cookie
control variables   2. environment control variables   3. the import
control parameters   4. the defaults

Default behaviour
-----------------

   Report to browser:

   * bad HTTP-headers

   * empty HTTP-body

   * warnings and errors

   * elapsed time

   * query parameters

   * cookies

   * environment variables (max 60 chars in value)

EXAMPELS
========

   Only report errors:     use CGI::Debug( report => 'errors' );

   Do not bother about warnings:     use CGI::Debug( on => 'fatals' );

   Allways show complete debugging info:     use CGI::Debug( report =>
'everything', on => 'anything' );

   Send debug data as mail to file owner:     use CGI::Debug( to => 'mail'
);

CONTROL PARAMETERS
==================

   Cookie control variables makes it possible to control the debugging
environment from a program in another browser window. This would be
prefereble with complex web pages (framesets, etc). The page is viewd as
normal in one window. All debugging data is shown i another window, that
also provides controls to alter the debugging environment. (But this
external debugging program is not yet implemented.)

   Environment control variables makes it more easy to globaly set the
debugging environment for a web site. It is also a way for the target
program to control the CGI::Debug module actions.

   The four methods can be mixed. (Cookies, enviroment, import parameters
and defaults.) The module will try to make sense with whatever you give
it. The possibilites of control are more limitied in the Cookie / ENV
version.

report errors
-------------

     Cookie / ENV: CGI-Debug-report=errors

     Import: report => 'errors'
     	  report => [ 'errors', ... ]

   Report the content of STDERR.

   This will allways be reported. This control is for saying that none of
the other defualt things will be reported. This will only override the
default. Other report controls will be accumulated.

report empty_body
-----------------

     Cookie / ENV: CGI-Debug-report=empty_body

     Import: report => 'empty_body'
     	  report => [ 'empty_body', ... ]

   Report if HTTP-body is empty.

   This requires that "header control" is set.

report time
-----------

     Cookie / ENV: CGI-Debug-report=time

     Import: report => 'time'
     	  report => [ 'time', ... ]

   Report the elapsed time from beginning to end of execution.

   If Time::Hires is found, this will be given with subsecond precision.

report params
-------------

     Cookie / ENV: CGI-Debug-report=params

     Import: report => 'params'
     	  report => [ 'params', ... ]

   Report a table of all name/value pairs, as given by the CGI module.

   Multiple values will be reported as distinct pairs, in order.  Values
will be truncated to the "set param_length" number of chars. The total
length is shown for each value.

report cookies
--------------

     Cookie / ENV: CGI-Debug-report=cookies

     Import: report => 'cookies'
     	  report => [ 'cookies', ... ]

   Report a table of all cookies, as given by the CGI module.

   Multiple values will be reported as distinct pairs, in order.  Values
will be truncated to the "set param_length" number of chars. The total
length is shown for each value.

report environment
------------------

     Cookie / ENV: CGI-Debug-report=environment

     Import: report => 'environment'
     	  report => [ 'environment', ... ]

   Report a table of all environment varialbes INCLUDING empty_body, time,
params, cookies.

report everything
-----------------

     Cookie / ENV: CGI-Debug-report=everything

     Import: report => 'everything'
     	  report => [ 'everything', ... ]

   Report environment and all what that includes.

   (The plan is for this control to include the contorl of HTML
compliance.)

report internals
----------------

     Cookie / ENV: CGI-Debug-report=internals

     Import: report => 'internals'
     	  report => [ 'internals', ... ]

   Report data for the debugging of the module itself, including
everything else.  Data::Dumper will be used, if found.

   If the module itself dies, you will probably not get any output at al.
You can check for errors in the file /tmp/CGI-Debug-error-$$.  In order to
see what error CGI::Debug is generating, you could changing $DEBUG to 2 or
more, in the module file itself. Please email the author about any
problems.

on fatals
---------

     Cookie / ENV: CGI-Debug-on=fatals

     Import: on => 'fatals'

   Only deliver report on fatal errors.

   This will ignore warnings. CGI::Debug checks the exit value.  Reports
will also be delivered if an empty body is detected, in case "header
control" is set.

on warnings
-----------

     Cookie / ENV: CGI-Debug-on=warnings

     Import: on => 'warnings'

   Only deliver report on fatals or if there was any output to STDERR.

on anything
-----------

     Cookie / ENV: CGI-Debug-on=anything

     Import: on => 'anything'

   Always deliver reports, even if there was no errors.

to browser
----------

     Cookie / ENV: CGI-Debug-to=browser

     Import: to => 'browser'
             to => [ 'browser', ... ]
             to => { 'browser' => 1, ... }

   Send report to browser.

   The report will come after any program output. The module will assume
the page is in text/html, unless "header control" is set, in case this
will be checked. (In none HTML mode, the header and delimiter will be
ASCII.)

   There is many cases in which faulty or bad HTML will hide the report.
This could be controled with "report html_compliance" (which is not yet
implemented).

to log
------

     Cookie / ENV: CGI-Debug-to=log

     Import: to => 'log'
             to => [ 'log', ... ]
             to => { 'log' => 1, ... }

   Send report to the standard error log.

   This will easily result in a huge log.

to file
-------

     Cookie / ENV: CGI-Debug-to=file
                   CGI-Debug-to-file=filename

     Import: to => 'file'
             to => [ 'file', ... ]
             to => { 'file' => 'filename', ... }
             to => { 'file' => [ 'filename1', 'filename2', ... ] ... }

   Save report to filename.

   Default filename is "/tmp/CGI-Debug-error.txt". The file will be
overwritten by the next report. This solution is to be used for debugging
with an external program. (To be used with cookies.)

   This will not work well with framesets that generates multipple reports
at a time. The action of this control may change in future versions.

to mail
-------

     Cookie / ENV: CGI-Debug-to=mail
                   CGI-Debug-to-mail=mailaddress

     Import: to => 'mail'
             to => [ 'mail', ... ]
             to => { 'mail' => 'mailaddress', ... }
             to => { 'mail' => [ 'mailaddress1', 'mailaddress2', ... ] ... }

   Send report with email.

   The default mailaddress is the owner of the cgi program.  This function
requires the Mail::Send module. If there is any problem with the default
behaviour of Mail::Send, set the enviroment variables, as described in the
POD for Mail::Mailer, either for the HTTP server, or before "use
CGI::Debug" in a BEGIN block.

   The idea is to specify an email address that will be used if anybody
besides yourself is getting an error. You will not get your own errors as
email if you overide that action with a control cookie.

header control
--------------

     Cookie / ENV: CGI-Debug-header=control

     Import: header => 'control'

   Controls that the HTTP-header is correct.

   This control will follow the HTTP RFC to the point. It reports if the
header is ok, if the content-type is text/html, and the length of the
HTTP-body. That information will be used by other parts of CGI::Debug.
This is done by redirecting STDOUT to a temporary file.  This is the only
control that must be set in the beginning of the program.  All other
controls can be changed during before the end of the program.

header ignore
-------------

     Cookie / ENV: CGI-Debug-header=ignore

     Import: header => 'ignore'

   Assume that the HTTP-header is correct and specifies text/html.

   This will tell CGI::Debug to ignore the STDOUT. A server generated
error response will result if the program compile ok but does not produce
a valid HTTP-header.

header minimal
--------------

     Cookie / ENV: CGI-Debug-header=minimal

     Import: header => 'minimal'

   Generates a simple text/html HTTP-header for you.

   This is the only action that CHANGES THE BEHAVIOUR of your program.
You will have to insert your own header if you remove the CGI::Debug row.
But this action will guarantee that you have a valid header, without the
need to save STDOUT to a temporary file.

set param_length
----------------

     Cookie / ENV: CGI-Debug-set-param_length=value

     Import: set => { param_length => 'value', ... }

   Set the max length of the parameter values.

   The default length is 60 chars. This is used for query parameters,
cookies and environment. The purpose is to give you a table that looks
good.

set error_document
------------------

     Cookie / ENV: CGI-Debug-set-error_document=value

     Import: set => { error_document => 'value', ... }

   Set what page to redirect to if there was an error report, not sent to
browser.

   This will show up in the browser if the error is going somewhere else.
If no page is specified, a short generic CGI error response will show up.
But if the CGI program succeeded in printing a valid http header and
something in the body, that will be showed instead, even if the program
later crashed.

MOD_PERL
========

   CGI::Debug will not function under mod_perl. The only solution to get
similar functionality is to develop a replacement for Apache::Registry,
with integrated debugging features.  The configuration interface can not
include the "use CGI::Debug ( report => ... )" style, in a mod_perl
version.

   If you run CGI::Debug under mod_perl, it will do nothing, except
sending a warning to STDERR.

TODO
====

   These are things that could be done to make CGI::Debug even better.  I
have no plan to add new features myself.  Feel free to contribute.

   * Clean up and generalize configuration

   * Test on non-*nix platforms

   * Implement HTML_compliance controls (using HTML::validate)

   * Implement function for debugging in a separate window

COPYRIGHT
=========

   Copyright (c) 1999-2000 Jonas Liljegren. All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

AUTHOR
======

   Jonas Liljegren <jonas@paranormal.se>

SEE ALSO
========

   CGI, Mail::Send, Time::Hires, Data::Dumper, perl


