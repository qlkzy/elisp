This is Info file perl.info, produced by Makeinfo version 1.68 from the
input file bigperl.texi.

   settitle perl


File: perl.info,  Node: perlfaq7,  Next: Top,  Prev: Top,  Up: Top

Perl Language Issues ($Revision: 1.28 $, $Date: 1999/05/23 20:36:18 $)
**********************************************************************

NAME
====

   perlfaq7 - Perl Language Issues ($Revision: 1.28 $, $Date: 1999/05/23
20:36:18 $)

DESCRIPTION
===========

   This section deals with general Perl language issues that don't clearly
fit into any of the other sections.

Can I get a BNF/yacc/RE for the Perl language?
----------------------------------------------

   There is no BNF, but you can paw your way through the yacc grammar in
perly.y in the source distribution if you're particularly brave.  The
grammar relies on very smart tokenizing code, so be prepared to venture
into toke.c as well.

   In the words of Chaim Frenkel: "Perl's grammar can not be reduced to
BNF.  The work of parsing perl is distributed between yacc, the lexer,
smoke and mirrors."

What are all these $@%&* punctuation signs, and how do I know when to use them?
-------------------------------------------------------------------------------

   They are type specifiers, as detailed in *Note Perldata: perldata,:

     $ for scalar values (number, string or reference)
     @ for arrays
     % for hashes (associative arrays)
     & for subroutines (aka functions, procedures, methods)
     * for all types of that symbol name.  In version 4 you used them like
       pointers, but in modern perls you can just use references.

   A couple of others that you're likely to encounter that aren't really
type specifiers are:

     <> are used for inputting a record from a filehandle.
     \  takes a reference to something.

   Note that <FILE> is *neither* the type specifier for files nor the name
of the handle.  It is the `< <' >> operator applied to the handle FILE.
It reads one line (well, record - see `$', *Note Perlvar: perlvar,) from
the handle FILE in scalar context, or all lines in list context.  When
performing open, close, or any other operation besides `< <' >> on files,
or even talking about the handle, do not use the brackets.  These are
correct: `eof(FH)', `seek(FH, 0, 2)' and "copying from STDIN to FILE".

Do I always/never have to quote my strings or use semicolons and commas?
------------------------------------------------------------------------

   Normally, a bareword doesn't need to be quoted, but in most cases
probably should be (and must be under `use strict').  But a hash key
consisting of a simple word (that isn't the name of a defined subroutine)
and the left-hand operand to the `< =' >> operator both count as though
they were quoted:

     This                    is like this
     ------------            ---------------
     $foo{line}              $foo{"line"}
     bar => stuff            "bar" => stuff

   The final semicolon in a block is optional, as is the final comma in a
list.  Good style (see *Note Perlstyle: perlstyle,) says to put them in
except for one-liners:

     if ($whoops) { exit 1 }
     @nums = (1, 2, 3);

     if ($whoops) {
         exit 1;
     }
     @lines = (
     	"There Beren came from mountains cold",
     	"And lost he wandered under leaves",
     );

How do I skip some return values?
---------------------------------

   One way is to treat the return values as a list and index into it:

     $dir = (getpwnam($user))[7];

   Another way is to use undef as an element on the left-hand-side:

     ($dev, $ino, undef, undef, $uid, $gid) = stat($file);

How do I temporarily block warnings?
------------------------------------

   If you are running Perl 5.6.0 or better, the `use warnings' pragma
allows fine control of what warning are produced.  See *Note Perllexwarn:
perllexwarn, for more details.

     {
     	no warnings;          # temporarily turn off warnings
     	$a = $b + $c;         # I know these might be undef
     }

   If you have an older version of Perl, the $^W variable (documented in
*Note Perlvar: perlvar,) controls runtime warnings for a block:

     {
     	local $^W = 0;        # temporarily turn off warnings
     	$a = $b + $c;         # I know these might be undef
     }

   Note that like all the punctuation variables, you cannot currently use
my() on $^W, only local().

What's an extension?
--------------------

   A way of calling compiled C code from Perl.  Reading *Note Perlxstut:
perlxstut, is a good place to learn more about extensions.

Why do Perl operators have different precedence than C operators?
-----------------------------------------------------------------

   Actually, they don't.  All C operators that Perl copies have the same
precedence in Perl as they do in C.  The problem is with operators that C
doesn't have, especially functions that give a list context to everything
on their right, eg print, chmod, exec, and so on.  Such functions are
called "list operators" and appear as such in the precedence table in
*Note Perlop: perlop,.

   A common mistake is to write:

     unlink $file || die "snafu";

   This gets interpreted as:

     unlink ($file || die "snafu");

   To avoid this problem, either put in extra parentheses or use the super
low precedence or operator:

     (unlink $file) || die "snafu";
     unlink $file or die "snafu";

   The "English" operators (and, or, xor, and not) deliberately have
precedence lower than that of list operators for just such situations as
the one above.

   Another operator with surprising precedence is exponentiation.  It
binds more tightly even than unary minus, making `-2**2' product a
negative not a positive four.  It is also right-associating, meaning that
`2**3**2' is two raised to the ninth power, not eight squared.

   Although it has the same precedence as in C, Perl's `?:' operator
produces an lvalue.  This assigns $x to either $a or $b, depending on the
trueness of $maybe:

     ($maybe ? $a : $b) = $x;

How do I declare/create a structure?
------------------------------------

   In general, you don't "declare" a structure.  Just use a (probably
anonymous) hash reference.  See *Note Perlref: perlref, and *Note Perldsc:
perldsc, for details.  Here's an example:

     $person = {};                   # new anonymous hash
     $person->{AGE}  = 24;           # set field AGE to 24
     $person->{NAME} = "Nat";        # set field NAME to "Nat"

   If you're looking for something a bit more rigorous, try *Note
Perltoot: perltoot,.

How do I create a module?
-------------------------

   A module is a package that lives in a file of the same name.  For
example, the Hello::There module would live in Hello/There.pm.  For
details, read *Note Perlmod: perlmod,.  You'll also find *Note Exporter:
(pm.info)Exporter, helpful.  If you're writing a C or mixed-language
module with both C and Perl, then you should study *Note Perlxstut:
perlxstut,.

   Here's a convenient template you might wish you use when starting your
own module.  Make sure to change the names appropriately.

     package Some::Module;  # assumes Some/Module.pm

     use strict;
     use warnings;

     BEGIN {
     	use Exporter   ();
     	our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);

     ## set the version for version checking; uncomment to use
     ## $VERSION     = 1.00;

     # if using RCS/CVS, this next line may be preferred,
     # but beware two-digit versions.
     $VERSION = do{my@r=q$Revision: 1.28 $=~/\d+/g;sprintf '%d.'.'%02d'x$#r,@r};

     @ISA         = qw(Exporter);
     @EXPORT      = qw(&func1 &func2 &func3);
     %EXPORT_TAGS = ( );  	# eg: TAG => [ qw!name1 name2! ],

     # your exported package globals go here,
     # as well as any optionally exported functions
     @EXPORT_OK   = qw($Var1 %Hashit);
         }
         our @EXPORT_OK;

     # non-exported package globals go here
     our @more;
     our $stuff;

     # initialize package globals, first exported ones
     $Var1   = '';
     %Hashit = ();

     # then the others (which are still accessible as $Some::Module::stuff)
     $stuff  = '';
     @more   = ();

     # all file-scoped lexicals must be created before
     # the functions below that use them.

     # file-private lexicals go here
     my $priv_var    = '';
     my %secret_hash = ();

     # here's a file-private function as a closure,
     # callable as &$priv_func;  it cannot be prototyped.
     my $priv_func = sub {
         # stuff goes here.
     };

     # make all your functions, whether exported or not;
     # remember to put something interesting in the {} stubs
     sub func1      {}	 # no prototype
     sub func2()    {}	 # proto'd void
     sub func3($$)  {}	 # proto'd to 2 scalars

     # this one isn't exported, but could be called!
     sub func4(\%)  {}    # proto'd to 1 hash ref

     END { }       # module clean-up code here (global destructor)

     1;            # modules must return true

   The h2xs program will create stubs for all the important stuff for you:

     % h2xs -XA -n My::Module

How do I create a class?
------------------------

   See *Note Perltoot: perltoot, for an introduction to classes and
objects, as well as *Note Perlobj: perlobj, and *Note Perlbot: perlbot,.

How can I tell if a variable is tainted?
----------------------------------------

   See `"Laundering and Detecting Tainted Data"', *Note Perlsec: perlsec,.
Here's an example (which doesn't use any system calls, because the kill()
is given no processes to signal):

     sub is_tainted {
     	return ! eval { join('',@_), kill 0; 1; };
     }

   This is not -w clean, however.  There is no -w clean way to detect
taintedness - take this as a hint that you should untaint all
possibly-tainted data.

What's a closure?
-----------------

   Closures are documented in *Note Perlref: perlref,.

   *Closure* is a computer science term with a precise but hard-to-explain
meaning. Closures are implemented in Perl as anonymous subroutines with
lasting references to lexical variables outside their own scopes.  These
lexicals magically refer to the variables that were around when the
subroutine was defined (deep binding).

   Closures make sense in any programming language where you can have the
return value of a function be itself a function, as you can in Perl.  Note
that some languages provide anonymous functions but are not capable of
providing proper closures; the Python language, for example.  For more
information on closures, check out any textbook on functional programming.
Scheme is a language that not only supports but encourages closures.

   Here's a classic function-generating function:

     sub add_function_generator {
       return sub { shift + shift };
     }

     $add_sub = add_function_generator();
     $sum = $add_sub->(4,5);                # $sum is 9 now.

   The closure works as a *function template* with some customization
slots left out to be filled later.  The anonymous subroutine returned by
add_function_generator() isn't technically a closure because it refers to
no lexicals outside its own scope.

   Contrast this with the following make_adder() function, in which the
returned anonymous function contains a reference to a lexical variable
outside the scope of that function itself.  Such a reference requires that
Perl return a proper closure, thus locking in for all time the value that
the lexical had when the function was created.

     sub make_adder {
         my $addpiece = shift;
         return sub { shift + $addpiece };
     }

     $f1 = make_adder(20);
     $f2 = make_adder(555);

   Now `&$f1($n)' is always 20 plus whatever $n you pass in, whereas
`&$f2($n)' is always 555 plus whatever $n you pass in.  The $addpiece in
the closure sticks around.

   Closures are often used for less esoteric purposes.  For example, when
you want to pass in a bit of code into a function:

     my $line;
     timeout( 30, sub { $line = <STDIN> } );

   If the code to execute had been passed in as a string, `< '$line =
<STDIN'' >>, there would have been no way for the hypothetical timeout()
function to access the lexical variable $line back in its caller's scope.

What is variable suicide and how can I prevent it?
--------------------------------------------------

   Variable suicide is when you (temporarily or permanently) lose the
value of a variable.  It is caused by scoping through my() and local()
interacting with either closures or aliased foreach() iterator variables
and subroutine arguments.  It used to be easy to inadvertently lose a
variable's value this way, but now it's much harder.  Take this code:

     my $f = "foo";
     sub T {
       while ($i++ < 3) { my $f = $f; $f .= "bar"; print $f, "\n" }
     }
     T;
     print "Finally $f\n";

   The $f that has "bar" added to it three times should be a new $f (`my
$f' should create a new local variable each time through the loop).  It
isn't, however.  This was a bug, now fixed in the latest releases (tested
against 5.004_05, 5.005_03, and 5.005_56).

How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?
---------------------------------------------------------------------------

   With the exception of regexes, you need to pass references to these
objects.  See `"Pass by Reference"', *Note Perlsub: perlsub, for this
particular question, and `"Pass by Reference"', *Note Perlref: perlref,
for information on references.

Passing Variables and Functions
     Regular variables and functions are quite easy: just pass in a
     reference to an existing or anonymous variable or function:

          func( \$some_scalar );

          func( \@some_array  );
          func( [ 1 .. 10 ]   );

          func( \%some_hash   );
          func( { this => 10, that => 20 }   );

          func( \&some_func   );
          func( sub { $_[0] ** $_[1] }   );

Passing Filehandles
     To pass filehandles to subroutines, use the `*FH' or `\*FH' notations.
     These are "typeglobs" - see `"Typeglobs and Filehandles"', *Note
     Perldata: perldata, and especially `"Pass by Reference"', *Note
     Perlsub: perlsub, for more information.

     Here's an excerpt:

     If you're passing around filehandles, you could usually just use the
     bare typeglob, like *STDOUT, but typeglobs references would be better
     because they'll still work properly under `use strict 'refs''.  For
     example:

          splutter(\*STDOUT);
          sub splutter {
              my $fh = shift;
              print $fh "her um well a hmmm\n";
          }

          $rec = get_rec(\*STDIN);
          sub get_rec {
              my $fh = shift;
              return scalar <$fh>;
          }

     If you're planning on generating new filehandles, you could do this:

          sub openit {
              my $name = shift;
              local *FH;
              return open (FH, $path) ? *FH : undef;
          }
          $fh = openit('< /etc/motd');
          print <$fh>;

Passing Regexes
     To pass regexes around, you'll need to be using a release of Perl
     sufficiently recent as to support the `qr//' construct, pass around
     strings and use an exception-trapping eval, or else be very, very
     clever.

     Here's an example of how to pass in a string to be regex compared
     using `qr//':

          sub compare($$) {
              my ($val1, $regex) = @_;
              my $retval = $val1 =~ /$regex/;
          	return $retval;
          }
          $match = compare("old McDonald", qr/d.*D/i);

     Notice how `qr//' allows flags at the end.  That pattern was compiled
     at compile time, although it was executed later.  The nifty `qr//'
     notation wasn't introduced until the 5.005 release.  Before that, you
     had to approach this problem much less intuitively.  For example, here
     it is again if you don't have `qr//':

          sub compare($$) {
              my ($val1, $regex) = @_;
              my $retval = eval { $val1 =~ /$regex/ };
          	die if $@;
          	return $retval;
          }

          $match = compare("old McDonald", q/($?i)d.*D/);

     Make sure you never say something like this:

          return eval "\$val =~ /$regex/";   # WRONG

     or someone can sneak shell escapes into the regex due to the double
     interpolation of the eval and the double-quoted string.  For example:

          $pattern_of_evil = 'danger ${ system("rm -rf * &") } danger';

          eval "\$string =~ /$pattern_of_evil/";

     Those preferring to be very, very clever might see the O'Reilly book,
     *Mastering Regular Expressions*, by Jeffrey Friedl.  Page 273's
     Build_MatchMany_Function() is particularly interesting.  A complete
     citation of this book is given in *Note Perlfaq2: perlfaq2,.

Passing Methods
     To pass an object method into a subroutine, you can do this:

          call_a_lot(10, $some_obj, "methname")
          sub call_a_lot {
              my ($count, $widget, $trick) = @_;
              for (my $i = 0; $i < $count; $i++) {
                  $widget->$trick();
              }
          }

     Or you can use a closure to bundle up the object and its method call
     and arguments:

          my $whatnot =  sub { $some_obj->obfuscate(@args) };
          func($whatnot);
          sub func {
              my $code = shift;
              &$code();
          }

     You could also investigate the can() method in the UNIVERSAL class
     (part of the standard perl distribution).

How do I create a static variable?
----------------------------------

   As with most things in Perl, TMTOWTDI.  What is a "static variable" in
other languages could be either a function-private variable (visible only
within a single function, retaining its value between calls to that
function), or a file-private variable (visible only to functions within
the file it was declared in) in Perl.

   Here's code to implement a function-private variable:

     BEGIN {
         my $counter = 42;
         sub prev_counter { return --$counter }
         sub next_counter { return $counter++ }
     }

   Now prev_counter() and next_counter() share a private variable $counter
that was initialized at compile time.

   To declare a file-private variable, you'll still use a my(), putting it
at the outer scope level at the top of the file.  Assume this is in file
Pax.pm:

     package Pax;
     my $started = scalar(localtime(time()));

     sub begun { return $started }

   When `use Pax' or `require Pax' loads this module, the variable will be
initialized.  It won't get garbage-collected the way most variables going
out of scope do, because the begun() function cares about it, but no one
else can get it.  It is not called $Pax::started because its scope is
unrelated to the package.  It's scoped to the file.  You could conceivably
have several packages in that same file all accessing the same private
variable, but another file with the same package couldn't get to it.

   See `"Persistent Private Variables"', *Note Perlsub: perlsub, for
details.

What's the difference between dynamic and lexical (static) scoping?  Between local() and my()?
----------------------------------------------------------------------------------------------

   `local($x)' saves away the old value of the global variable $x, and
assigns a new value for the duration of the subroutine, *which is visible
in other functions called from that subroutine*.  This is done at
run-time, so is called dynamic scoping.  local() always affects global
variables, also called package variables or dynamic variables.

   `my($x)' creates a new variable that is only visible in the current
subroutine.  This is done at compile-time, so is called lexical or static
scoping.  my() always affects private variables, also called lexical
variables or (improperly) static(ly scoped) variables.

   For instance:

     sub visible {
     	print "var has value $var\n";
     }

     sub dynamic {
     	local $var = 'local';	# new temporary value for the still-global
     	visible();              #   variable called $var
     }

     sub lexical {
     	my $var = 'private';    # new private variable, $var
     	visible();              # (invisible outside of sub scope)
     }

     $var = 'global';

     visible();      		# prints global
     dynamic();      		# prints local
     lexical();      		# prints global

   Notice how at no point does the value "private" get printed.  That's
because $var only has that value within the block of the lexical()
function, and it is hidden from called subroutine.

   In summary, local() doesn't make what you think of as private, local
variables.  It gives a global variable a temporary value.  my() is what
you're looking for if you want private variables.

   See `"Private Variables via my()"', *Note Perlsub: perlsub, and
`"Temporary Values via local()"', *Note Perlsub: perlsub, for excruciating
details.

How can I access a dynamic variable while a similarly named lexical is in scope?
--------------------------------------------------------------------------------

   You can do this via symbolic references, provided you haven't set `use
strict "refs"'.  So instead of $var, use `${'var'}'.

     local $var = "global";
     my    $var = "lexical";

     print "lexical is $var\n";

     no strict 'refs';
     print "global  is ${'var'}\n";

   If you know your package, you can just mention it explicitly, as in
$Some_Pack::var.  Note that the notation $::var is not the dynamic $var in
the current package, but rather the one in the main package, as though you
had written $main::var.  Specifying the package directly makes you
hard-code its name, but it executes faster and avoids running afoul of
`use strict "refs"'.

What's the difference between deep and shallow binding?
-------------------------------------------------------

   In deep binding, lexical variables mentioned in anonymous subroutines
are the same ones that were in scope when the subroutine was created.  In
shallow binding, they are whichever variables with the same names happen
to be in scope when the subroutine is called.  Perl always uses deep
binding of lexical variables (i.e., those created with my()).  However,
dynamic variables (aka global, local, or package variables) are
effectively shallowly bound.  Consider this just one more reason not to
use them.  See the answer to `"What's a closure?"' in this node.

Why doesn't "my($foo) = <FILE>;" work right?
--------------------------------------------

   my() and `local()' give list context to the right hand side of =.  The
<FH> read operation, like so many of Perl's functions and operators, can
tell which context it was called in and behaves appropriately.  In
general, the scalar() function can help.  This function does nothing to
the data itself (contrary to popular myth) but rather tells its argument
to behave in whatever its scalar fashion is.  If that function doesn't
have a defined scalar behavior, this of course doesn't help you (such as
with sort()).

   To enforce scalar context in this particular case, however, you need
merely omit the parentheses:

     local($foo) = <FILE>;	    # WRONG
     local($foo) = scalar(<FILE>);   # ok
     local $foo  = <FILE>;	    # right

   You should probably be using lexical variables anyway, although the
issue is the same here:

     my($foo) = <FILE>;	# WRONG
     my $foo  = <FILE>;	# right

How do I redefine a builtin function, operator, or method?
----------------------------------------------------------

   Why do you want to do that? :-)

   If you want to override a predefined function, such as open(), then
you'll have to import the new definition from a different module.  See
`"Overriding Built-in Functions"', *Note Perlsub: perlsub,.  There's also
an example in `"Class::Template"', *Note Perltoot: perltoot,.

   If you want to overload a Perl operator, such as + or `**', then you'll
want to use the `use overload' pragma, documented in *Note Overload:
(pm.info)overload,.

   If you're talking about obscuring method calls in parent classes, see
`"Overridden Methods"', *Note Perltoot: perltoot,.

What's the difference between calling a function as &foo and foo()?
-------------------------------------------------------------------

   When you call a function as `&foo', you allow that function access to
your current @_ values, and you by-pass prototypes.  That means that the
function doesn't get an empty @_, it gets yours!  While not strictly
speaking a bug (it's documented that way in *Note Perlsub: perlsub,), it
would be hard to consider this a feature in most cases.

   When you call your function as `&foo()', then you do get a new @_, but
prototyping is still circumvented.

   Normally, you want to call a function using `foo()'.  You may only omit
the parentheses if the function is already known to the compiler because
it already saw the definition (use but not require), or via a forward
reference or `use subs' declaration.  Even in this case, you get a clean
@_ without any of the old values leaking through where they don't belong.

How do I create a switch or case statement?
-------------------------------------------

   This is explained in more depth in the *Note Perlsyn: perlsyn,.
Briefly, there's no official case statement, because of the variety of
tests possible in Perl (numeric comparison, string comparison, glob
comparison, regex matching, overloaded comparisons, ...).  Larry couldn't
decide how best to do this, so he left it out, even though it's been on the
wish list since perl1.

   The general answer is to write a construct like this:

     for ($variable_to_test) {
     	if    (/pat1/)  { }     # do something
     	elsif (/pat2/)  { }     # do something else
     	elsif (/pat3/)  { }     # do something else
     	else            { }     # default
     }

   Here's a simple example of a switch based on pattern matching, this
time lined up in a way to make it look more like a switch statement.
We'll do a multi-way conditional based on the type of reference stored in
$whatchamacallit:

     SWITCH: for (ref $whatchamacallit) {

     /^$/		&& die "not a reference";

     /SCALAR/	&& do {
     			print_scalar($$ref);
     			last SWITCH;
     		};

     /ARRAY/		&& do {
     			print_array(@$ref);
     			last SWITCH;
     		};

     /HASH/		&& do {
     			print_hash(%$ref);
     			last SWITCH;
     		};

     /CODE/		&& do {
     			warn "can't print function ref";
     			last SWITCH;
     		};

     # DEFAULT

     warn "User defined type skipped";

     }

   See `perlsyn/"Basic BLOCKs and Switch Statements"' for many other
examples in this style.

   Sometimes you should change the positions of the constant and the
variable.  For example, let's say you wanted to test which of many answers
you were given, but in a case-insensitive way that also allows
abbreviations.  You can use the following technique if the strings all
start with different characters, or if you want to arrange the matches so
that one takes precedence over another, as `"SEND"' has precedence over
`"STOP"' here:

     chomp($answer = <>);
     if    ("SEND"  =~ /^\Q$answer/i) { print "Action is send\n"  }
     elsif ("STOP"  =~ /^\Q$answer/i) { print "Action is stop\n"  }
     elsif ("ABORT" =~ /^\Q$answer/i) { print "Action is abort\n" }
     elsif ("LIST"  =~ /^\Q$answer/i) { print "Action is list\n"  }
     elsif ("EDIT"  =~ /^\Q$answer/i) { print "Action is edit\n"  }

   A totally different approach is to create a hash of function references.

     my %commands = (
         "happy" => \&joy,
         "sad",  => \&sullen,
         "done"  => sub { die "See ya!" },
         "mad"   => \&angry,
     );

     print "How are you? ";
     chomp($string = <STDIN>);
     if ($commands{$string}) {
         $commands{$string}->();
     } else {
         print "No such command: $string\n";
     }

How can I catch accesses to undefined variables/functions/methods?
------------------------------------------------------------------

   The AUTOLOAD method, discussed in `"Autoloading"', *Note Perlsub:
perlsub, and `"AUTOLOAD: Proxy Methods"', *Note Perltoot: perltoot,, lets
you capture calls to undefined functions and methods.

   When it comes to undefined variables that would trigger a warning under
-w, you can use a handler to trap the pseudo-signal `__WARN__' like this:

     $SIG{__WARN__} = sub {

     for ( $_[0] ) {		# voici un switch statement

     /Use of uninitialized value/  && do {
     		# promote warning to a fatal
     		die $_;
     };

     # other warning cases to catch could go here;

     warn $_;
     	}

     };

Why can't a method included in this same file be found?
-------------------------------------------------------

   Some possible reasons: your inheritance is getting confused, you've
misspelled the method name, or the object is of the wrong type.  Check out
*Note Perltoot: perltoot, for details on these.  You may also use `print
ref($object)' to find out the class $object was blessed into.

   Another possible reason for problems is because you've used the
indirect object syntax (eg, `find Guru "Samy"') on a class name before
Perl has seen that such a package exists.  It's wisest to make sure your
packages are all defined before you start using them, which will be taken
care of if you use the use statement instead of require.  If not, make
sure to use arrow notation (eg, `< Guru-'find("Samy") >>) instead.  Object
notation is explained in *Note Perlobj: perlobj,.

   Make sure to read about creating modules in *Note Perlmod: perlmod, and
the perils of indirect objects in `"WARNING"', *Note Perlobj: perlobj,.

How can I find out my current package?
--------------------------------------

   If you're just a random program, you can do this to find out what the
currently compiled package is:

     my $packname = __PACKAGE__;

   But if you're a method and you want to print an error message that
includes the kind of object you were called on (which is not necessarily
the same as the one in which you were compiled):

     sub amethod {
     	my $self  = shift;
     	my $class = ref($self) || $self;
     	warn "called me from a $class object";
     }

How can I comment out a large block of perl code?
-------------------------------------------------

   Use embedded POD to discard it:

     # program is here

     =for nobody
     This paragraph is commented out

     # program continues

     =begin comment text

     all of this stuff

     here will be ignored
     by everyone

     =end comment text

     =cut

   This can't go just anywhere.  You have to put a pod directive where the
parser is expecting a new statement, not just in the middle of an
expression or some other arbitrary yacc grammar production.

How do I clear a package?
-------------------------

   Use this code, provided by Mark-Jason Dominus:

     sub scrub_package {
     	no strict 'refs';
     	my $pack = shift;
     	die "Shouldn't delete main package"
     	    if $pack eq "" || $pack eq "main";
     	my $stash = *{$pack . '::'}{HASH};
     	my $name;
     	foreach $name (keys %$stash) {
     	    my $fullname = $pack . '::' . $name;
     	    # Get rid of everything with that name.
     	    undef $$fullname;
     	    undef @$fullname;
     	    undef %$fullname;
     	    undef &$fullname;
     	    undef *$fullname;
     	}
     }

   Or, if you're using a recent release of Perl, you can just use the
Symbol::delete_package() function instead.

How can I use a variable as a variable name?
--------------------------------------------

   Beginners often think they want to have a variable contain the name of
a variable.

     $fred    = 23;
     $varname = "fred";
     ++$$varname;         # $fred now 24

   This works *sometimes*, but it is a very bad idea for two reasons.

   The first reason is that they *only work on global variables*.  That
means above that if $fred is a lexical variable created with my(), that
the code won't work at all: you'll accidentally access the global and skip
right over the private lexical altogether.  Global variables are bad
because they can easily collide accidentally and in general make for
non-scalable and confusing code.

   Symbolic references are forbidden under the `use strict' pragma.  They
are not true references and consequently are not reference counted or
garbage collected.

   The other reason why using a variable to hold the name of another
variable a bad idea is that the question often stems from a lack of
understanding of Perl data structures, particularly hashes.  By using
symbolic references, you are just using the package's symbol-table hash
(like `%main::') instead of a user-defined hash.  The solution is to use
your own hash or a real reference instead.

     $fred    = 23;
     $varname = "fred";
     $USER_VARS{$varname}++;  # not $$varname++

   There we're using the %USER_VARS hash instead of symbolic references.
Sometimes this comes up in reading strings from the user with variable
references and wanting to expand them to the values of your perl program's
variables.  This is also a bad idea because it conflates the
program-addressable namespace and the user-addressable one.  Instead of
reading a string and expanding it to the actual contents of your program's
own variables:

     $str = 'this has a $fred and $barney in it';
     $str =~ s/(\$\w+)/$1/eeg;		  # need double eval

   Instead, it would be better to keep a hash around like %USER_VARS and
have variable references actually refer to entries in that hash:

     $str =~ s/\$(\w+)/$USER_VARS{$1}/g;   # no /e here at all

   That's faster, cleaner, and safer than the previous approach.  Of
course, you don't need to use a dollar sign.  You could use your own
scheme to make it less confusing, like bracketed percent symbols, etc.

     $str = 'this has a %fred% and %barney% in it';
     $str =~ s/%(\w+)%/$USER_VARS{$1}/g;   # no /e here at all

   Another reason that folks sometimes think they want a variable to
contain the name of a variable is because they don't know how to build
proper data structures using hashes.  For example, let's say they wanted
two hashes in their program: %fred and %barney, and to use another scalar
variable to refer to those by name.

     $name = "fred";
     $$name{WIFE} = "wilma";     # set %fred

     $name = "barney";
     $$name{WIFE} = "betty";	# set %barney

   This is still a symbolic reference, and is still saddled with the
problems enumerated above.  It would be far better to write:

     $folks{"fred"}{WIFE}   = "wilma";
     $folks{"barney"}{WIFE} = "betty";

   And just use a multilevel hash to start with.

   The only times that you absolutely must use symbolic references are
when you really must refer to the symbol table.  This may be because it's
something that can't take a real reference to, such as a format name.
Doing so may also be important for method calls, since these always go
through the symbol table for resolution.

   In those cases, you would turn off `strict 'refs'' temporarily so you
can play around with the symbol table.  For example:

     @colors = qw(red blue green yellow orange purple violet);
     for my $name (@colors) {
         no strict 'refs';  # renege for the block
         *$name = sub { "<FONT COLOR='$name'>@_</FONT>" };
     }

   All those functions (red(), blue(), green(), etc.) appear to be
separate, but the real code in the closure actually was compiled only once.

   So, sometimes you might want to use symbolic references to directly
manipulate the symbol table.  This doesn't matter for formats, handles, and
subroutines, because they are always global - you can't use my() on them.
But for scalars, arrays, and hashes - and usually for subroutines - you
probably want to use hard references only.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.


File: perl.info,  Node: perlfaq8,  Next: Top,  Prev: Top,  Up: Top

System Interaction ($Revision: 1.39 $, $Date: 1999/05/23 18:37:57 $)
********************************************************************

NAME
====

   perlfaq8 - System Interaction ($Revision: 1.39 $, $Date: 1999/05/23
18:37:57 $)

DESCRIPTION
===========

   This section of the Perl FAQ covers questions involving operating
system interaction.  This involves interprocess communication (IPC),
control over the user-interface (keyboard, screen and pointing devices),
and most anything else not related to data manipulation.

   Read the FAQs and documentation specific to the port of perl to your
operating system (eg, *Note Perlvms: perlvms,, `perlplan9' in this node,
...).  These should contain more detailed information on the vagaries of
your perl.

How do I find out which operating system I'm running under?
-----------------------------------------------------------

   The $^O variable ($OSNAME if you use English) contains an indication of
the name of the operating system (not its release number) that your perl
binary was built for.

How come exec() doesn't return?
-------------------------------

   Because that's what it does: it replaces your currently running program
with a different one.  If you want to keep going (as is probably the case
if you're asking this question) use system() instead.

How do I do fancy stuff with the keyboard/screen/mouse?
-------------------------------------------------------

   How you access/control keyboards, screens, and pointing devices
("mice") is system-dependent.  Try the following modules:

Keyboard
          Term::Cap			Standard perl distribution
          Term::ReadKey		CPAN
          Term::ReadLine::Gnu		CPAN
          Term::ReadLine::Perl	CPAN
          Term::Screen		CPAN

Screen
          Term::Cap			Standard perl distribution
          Curses			CPAN
          Term::ANSIColor		CPAN

Mouse
     * Menu:
     
     * perl:: 	Perl overview (this section)
     * perldelta:: 	Perl changes since previous version
     * perl5005delta:: Perl changes in version 5.005
     * perl5004delta:: Perl changes in version 5.004
     * perlfaq:: 	Perl frequently asked questions
     * perltoc:: 	Perl documentation table of contents
     
     * perldata:: 	Perl data structures
     * perlsyn:: 	Perl syntax
     * perlop:: 	Perl operators and precedence
     * perlre:: 	Perl regular expressions
     * perlrun:: 	Perl execution and options
     * perlfunc:: 	Perl builtin functions
     * perlopentut:: 	Perl open() tutorial
     * perlvar:: 	Perl predefined variables
     * perlsub:: 	Perl subroutines
     * perlmod:: 	Perl modules: how they work
     * perlmodlib:: 	Perl modules: how to write and use
     * perlmodinstall:: Perl modules: how to install from CPAN
     * perlform:: 	Perl formats
     * perlunicode:: 	Perl unicode support
     * perllocale:: 	Perl locale support
     
     * perlreftut:: 	Perl references short introduction
     * perlref:: 	Perl references, the rest of the story
     * perldsc:: 	Perl data structures intro
     * perllol:: 	Perl data structures: arrays of arrays
     * perlboot:: 	Perl OO tutorial for beginners
     * perltoot:: 	Perl OO tutorial, part 1
     * perltootc:: 	Perl OO tutorial, part 2
     * perlobj:: 	Perl objects
     * perltie:: 	Perl objects hidden behind simple variables
     * perlbot:: 	Perl OO tricks and examples
     * perlipc:: 	Perl interprocess communication
     * perlfork:: 	Perl fork() information
     * perlthrtut:: 	Perl threads tutorial
     * perllexwarn:: 	Perl warnings and their control
     * perlfilter:: 	Perl source filters
     * perldbmfilter:: Perl DBM filters
     
     * perlcompile:: 	Perl compiler suite intro
     * perldebug:: 	Perl debugging
     * perldiag:: 	Perl diagnostic messages
     * perlnumber:: 	Perl number semantics
     * perlsec:: 	Perl security
     * perltrap:: 	Perl traps for the unwary
     * perlport:: 	Perl portability guide
     * perlstyle:: 	Perl style guide
     
     * perlpod:: 	Perl plain old documentation
     * perlbook:: 	Perl book information
     
     * perlembed:: 	Perl ways to embed perl in your C or C++ application
     * perlapio:: 	Perl internal IO abstraction interface
     * perldebguts:: 	Perl debugging guts and tips
     * perlxs:: 	Perl XS application programming interface
     * perlxstut:: 	Perl XS tutorial
     * perlguts:: 	Perl internal functions for those doing extensions
     * perlcall:: 	Perl calling conventions from C
     * perlapi:: 	Perl API listing (autogenerated)
     * perlintern:: 	Perl internal functions (autogenerated)
     
     * perltodo:: 	Perl things to do
     * perlhack:: 	Perl hackers guide
     * perlhist:: 	Perl history records
     
     * perlamiga:: 	Perl notes for Amiga
     * perlcygwin:: 	Perl notes for Cygwin
     * perldos:: 	Perl notes for DOS
     * perlhpux:: 	Perl notes for HP-UX
     * perlmachten:: 	Perl notes for Power MachTen
     * perlos2:: 	Perl notes for OS/2
     * perlos390:: 	Perl notes for OS/390
     * perlvms:: 	Perl notes for VMS
     * perlwin32:: 	Perl notes for Windows
     
     * Tk:: 			CPAN
     
     
     * Module List:(pm.info)Module List. Got your modules, right here
     * Function Index:: Perl functions and operators
     * Predefined Variable Index:: Perl predefined variables
     * Diagnostics Index:: Perl diagnostic messages

   Some of these specific cases are shown below.

How do I print something out in color?
--------------------------------------

   In general, you don't, because you don't know whether the recipient has
a color-aware display device.  If you know that they have an ANSI terminal
that understands color, you can use the Term::ANSIColor module from CPAN:

     use Term::ANSIColor;
     print color("red"), "Stop!\n", color("reset");
     print color("green"), "Go!\n", color("reset");

   Or like this:

     use Term::ANSIColor qw(:constants);
     print RED, "Stop!\n", RESET;
     print GREEN, "Go!\n", RESET;

How do I read just one key without waiting for a return key?
------------------------------------------------------------

   Controlling input buffering is a remarkably system-dependent matter.
On many systems, you can just use the *stty* command as shown in `getc',
*Note Perlfunc: perlfunc,, but as you see, that's already getting you into
portability snags.

     open(TTY, "+</dev/tty") or die "no tty: $!";
     system "stty  cbreak </dev/tty >/dev/tty 2>&1";
     $key = getc(TTY);		# perhaps this works
     # OR ELSE
     sysread(TTY, $key, 1);	# probably this does
     system "stty -cbreak </dev/tty >/dev/tty 2>&1";

   The Term::ReadKey module from CPAN offers an easy-to-use interface that
should be more efficient than shelling out to *stty* for each key.  It
even includes limited support for Windows.

     use Term::ReadKey;
     ReadMode('cbreak');
     $key = ReadKey(0);
     ReadMode('normal');

   However, that requires that you have a working C compiler and can use it
to build and install a CPAN module.  Here's a solution using the standard
POSIX module, which is already on your systems (assuming your system
supports POSIX).

     use HotKey;
     $key = readkey();

   And here's the HotKey module, which hides the somewhat mystifying calls
to manipulate the POSIX termios structures.

     # HotKey.pm
     package HotKey;

     @ISA = qw(Exporter);
     @EXPORT = qw(cbreak cooked readkey);

     use strict;
     use POSIX qw(:termios_h);
     my ($term, $oterm, $echo, $noecho, $fd_stdin);

     $fd_stdin = fileno(STDIN);
     $term     = POSIX::Termios->new();
     $term->getattr($fd_stdin);
     $oterm     = $term->getlflag();

     $echo     = ECHO | ECHOK | ICANON;
     $noecho   = $oterm & ~$echo;

     sub cbreak {
         $term->setlflag($noecho);  # ok, so i don't want echo either
         $term->setcc(VTIME, 1);
         $term->setattr($fd_stdin, TCSANOW);
     }

     sub cooked {
         $term->setlflag($oterm);
         $term->setcc(VTIME, 0);
         $term->setattr($fd_stdin, TCSANOW);
     }

     sub readkey {
         my $key = '';
         cbreak();
         sysread(STDIN, $key, 1);
         cooked();
         return $key;
     }

     END { cooked() }

     1;

How do I check whether input is ready on the keyboard?
------------------------------------------------------

   The easiest way to do this is to read a key in nonblocking mode with the
Term::ReadKey module from CPAN, passing it an argument of -1 to indicate
not to block:

     use Term::ReadKey;

     ReadMode('cbreak');

     if (defined ($char = ReadKey(-1)) ) {
         # input was waiting and it was $char
     } else {
         # no input was waiting
     }

     ReadMode('normal');                  # restore normal tty settings

How do I clear the screen?
--------------------------

   If you only have do so infrequently, use system:

     system("clear");

   If you have to do this a lot, save the clear string so you can print it
100 times without calling a program 100 times:

     $clear_string = `clear`;
     print $clear_string;

   If you're planning on doing other screen manipulations, like cursor
positions, etc, you might wish to use Term::Cap module:

     use Term::Cap;
     $terminal = Term::Cap->Tgetent( {OSPEED => 9600} );
     $clear_string = $terminal->Tputs('cl');

How do I get the screen size?
-----------------------------

   If you have Term::ReadKey module installed from CPAN, you can use it to
fetch the width and height in characters and in pixels:

     use Term::ReadKey;
     ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

   This is more portable than the raw ioctl, but not as illustrative:

     require 'sys/ioctl.ph';
     die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
     open(TTY, "+</dev/tty")                     or die "No tty: $!";
     unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
         die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
     }
     ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
     print "(row,col) = ($row,$col)";
     print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
     print "\n";

How do I ask the user for a password?
-------------------------------------

   (This question has nothing to do with the web.  See a different FAQ for
that.)

   There's an example of this in `crypt', *Note Perlfunc: perlfunc,).
First, you put the terminal into "no echo" mode, then just read the
password normally.  You may do this with an old-style ioctl() function,
POSIX terminal control (see `crypt', *Note POSIX: (pm.info)POSIX,, and
Chapter 7 of the Camel), or a call to the *stty* program, with varying
degrees of portability.

   You can also do this for most systems using the Term::ReadKey module
from CPAN, which is easier to use and in theory more portable.

     use Term::ReadKey;

     ReadMode('noecho');
     $password = ReadLine(0);

How do I read and write the serial port?
----------------------------------------

   This depends on which operating system your program is running on.  In
the case of Unix, the serial ports will be accessible through files in
/dev; on other systems, the devices names will doubtless differ.  Several
problem areas common to all device interaction are the following

lockfiles
     Your system may use lockfiles to control multiple access.  Make sure
     you follow the correct protocol.  Unpredictable behaviour can result
     from multiple processes reading from one device.

open mode
     If you expect to use both read and write operations on the device,
     you'll have to open it for update (see `"open"', *Note Perlfunc:
     perlfunc, for details).  You may wish to open it without running the
     risk of blocking by using sysopen() and `O_RDWR|O_NDELAY|O_NOCTTY'
     from the Fcntl module (part of the standard perl distribution).  See
     `"sysopen"', *Note Perlfunc: perlfunc, for more on this approach.

end of line
     Some devices will be expecting a "\r" at the end of each line rather
     than a "\n".  In some ports of perl, "\r" and "\n" are different from
     their usual (Unix) ASCII values of "\012" and "\015".  You may have to
     give the numeric values you want directly, using octal ("\015"), hex
     ("0x0D"), or as a control-character specification ("\cM").

          print DEV "atv1\012";	# wrong, for some devices
          print DEV "atv1\015";	# right, for some devices

     Even though with normal text files, a "\n" will do the trick, there is
     still no unified scheme for terminating a line that is portable
     between Unix, DOS/Win, and Macintosh, except to terminate ALL line
     ends with "\015\012", and strip what you don't need from the output.
     This applies especially to socket I/O and autoflushing, discussed
     next.

flushing output
     If you expect characters to get to your device when you print() them,
     you'll want to autoflush that filehandle.  You can use select() and
     the $| variable to control autoflushing (see `$|', *Note Perlvar:
     perlvar, and `select', *Note Perlfunc: perlfunc,):

          $oldh = select(DEV);
          $| = 1;
          select($oldh);

     You'll also see code that does this without a temporary variable, as
     in

          select((select(DEV), $| = 1)[0]);

     Or if you don't mind pulling in a few thousand lines of code just
     because you're afraid of a little $| variable:

          use IO::Handle;
          DEV->autoflush(1);

     As mentioned in the previous item, this still doesn't work when using
     socket I/O between Unix and Macintosh.  You'll need to hardcode your
     line terminators, in that case.

non-blocking input
     If you are doing a blocking read() or sysread(), you'll have to
     arrange for an alarm handler to provide a timeout (see `alarm', *Note
     Perlfunc: perlfunc,).  If you have a non-blocking open, you'll likely
     have a non-blocking read, which means you may have to use a 4-arg
     select() to determine whether I/O is ready on that device (see
     `"select"', *Note Perlfunc: perlfunc,.

   While trying to read from his caller-id box, the notorious Jamie
Zawinski <jwz@netscape.com>, after much gnashing of teeth and fighting
with sysread, sysopen, POSIX's tcgetattr business, and various other
functions that go bump in the night, finally came up with this:

     sub open_modem {
     	use IPC::Open2;
     	my $stty = `/bin/stty -g`;
     	open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2>&1");
     	# starting cu hoses /dev/tty's stty settings, even when it has
     	# been opened on a pipe...
     	system("/bin/stty $stty");
     	$_ = <MODEM_IN>;
     	chop;
     	if ( !m/^Connected/ ) {
     	    print STDERR "$0: cu printed `$_' instead of `Connected'\n";
     	}
     }

How do I decode encrypted password files?
-----------------------------------------

   You spend lots and lots of money on dedicated hardware, but this is
bound to get you talked about.

   Seriously, you can't if they are Unix password files - the Unix
password system employs one-way encryption.  It's more like hashing than
encryption.  The best you can check is whether something else hashes to
the same string.  You can't turn a hash back into the original string.
Programs like Crack can forcibly (and intelligently) try to guess
passwords, but don't (can't) guarantee quick success.

   If you're worried about users selecting bad passwords, you should
proactively check when they try to change their password (by modifying
passwd(1), for example).

How do I start a process in the background?
-------------------------------------------

   You could use

     system("cmd &")

   or you could use fork as documented in `"fork"', *Note Perlfunc:
perlfunc,, with further examples in `"fork"', *Note Perlipc: perlipc,.
Some things to be aware of, if you're on a Unix-like system:

STDIN, STDOUT, and STDERR are shared
     Both the main process and the backgrounded one (the "child" process)
     share the same STDIN, STDOUT and STDERR filehandles.  If both try to
     access them at once, strange things can happen.  You may want to close
     or reopen these for the child.  You can get around this with opening
     a pipe (see `"open"', *Note Perlfunc: perlfunc,) but on some systems
     this means that the child process cannot outlive the parent.

Signals
     You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too.
     SIGCHLD is sent when the backgrounded process finishes.  SIGPIPE is
     sent when you write to a filehandle whose child process has closed (an
     untrapped SIGPIPE can cause your program to silently die).  This is
     not an issue with `system("cmd&")'.

Zombies
     You have to be prepared to "reap" the child process when it finishes

          $SIG{CHLD} = sub { wait };

     See `"Signals"', *Note Perlipc: perlipc, for other examples of code
     to do this.  Zombies are not an issue with `system("prog &")'.

How do I trap control characters/signals?
-----------------------------------------

   You don't actually "trap" a control character.  Instead, that character
generates a signal which is sent to your terminal's currently foregrounded
process group, which you then trap in your process.  Signals are
documented in `"Signals"', *Note Perlipc: perlipc, and chapter 6 of the
Camel.

   Be warned that very few C libraries are re-entrant.  Therefore, if you
attempt to print() in a handler that got invoked during another stdio
operation your internal structures will likely be in an inconsistent
state, and your program will dump core.  You can sometimes avoid this by
using syswrite() instead of print().

   Unless you're exceedingly careful, the only safe things to do inside a
signal handler are: set a variable and exit.  And in the first case, you
should only set a variable in such a way that malloc() is not called (eg,
by setting a variable that already has a value).

   For example:

     $Interrupted = 0;	# to ensure it has a value
     $SIG{INT} = sub {
         $Interrupted++;
     	syswrite(STDERR, "ouch\n", 5);
     }

   However, because syscalls restart by default, you'll find that if
you're in a "slow" call, such as <FH>, read(), connect(), or wait(), that
the only way to terminate them is by "longjumping" out; that is, by
raising an exception.  See the time-out handler for a blocking flock() in
`"Signals"', *Note Perlipc: perlipc, or chapter 6 of the Camel.

How do I modify the shadow password file on a Unix system?
----------------------------------------------------------

   If perl was installed correctly, and your shadow library was written
properly, the getpw*() functions described in *Note Perlfunc: perlfunc,
should in theory provide (read-only) access to entries in the shadow
password file.  To change the file, make a new shadow password file (the
format varies from system to system - see `passwd(5)' in this node for
specifics) and use pwd_mkdb(8) to install it (see `pwd_mkdb(8)' in this
node for more details).

How do I set the time and date?
-------------------------------

   Assuming you're running under sufficient permissions, you should be
able to set the system-wide date and time by running the date(1) program.
(There is no way to set the time and date on a per-process basis.)  This
mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent
is `set time'.

   However, if all you want to do is change your timezone, you can
probably get away with setting an environment variable:

     $ENV{TZ} = "MST7MDT";		   # unixish
     $ENV{'SYS$TIMEZONE_DIFFERENTIAL'}="-5" # vms
     system "trn comp.lang.perl.misc";

How can I sleep() or alarm() for under a second?
------------------------------------------------

   If you want finer granularity than the 1 second that the sleep()
function provides, the easiest way is to use the select() function as
documented in `"select"', *Note Perlfunc: perlfunc,.  If your system has
itimers and syscall() support, you can check out the old example in
http://www.perl.com/CPAN/doc/misc/ancient/tutorial/eg/itimers.pl .

How can I measure time under a second?
--------------------------------------

   In general, you may not be able to.  The Time::HiRes module (available
from CPAN) provides this functionality for some systems.

   If your system supports both the syscall() function in Perl as well as
a system call like gettimeofday(2), then you may be able to do something
like this:

     require 'sys/syscall.ph';

     $TIMEVAL_T = "LL";

     $done = $start = pack($TIMEVAL_T, ());

     syscall(&SYS_gettimeofday, $start, 0) != -1
                or die "gettimeofday: $!";

     ##########################
     # DO YOUR OPERATION HERE #
     ##########################

     syscall( &SYS_gettimeofday, $done, 0) != -1
            or die "gettimeofday: $!";

     @start = unpack($TIMEVAL_T, $start);
     @done  = unpack($TIMEVAL_T, $done);

     # fix microseconds
     for ($done[1], $start[1]) { $_ /= 1_000_000 }

     $delta_time = sprintf "%.4f", ($done[0]  + $done[1]  )
                                             -
                                  ($start[0] + $start[1] );

How can I do an atexit() or setjmp()/longjmp()? (Exception handling)
--------------------------------------------------------------------

   Release 5 of Perl added the END block, which can be used to simulate
atexit().  Each package's END block is called when the program or thread
ends (see *Note Perlmod: perlmod, manpage for more details).

   For example, you can use this to make sure your filter program managed
to finish its output without filling up the disk:

     END {
     	close(STDOUT) || die "stdout close failed: $!";
     }

   The END block isn't called when untrapped signals kill the program,
though, so if you use END blocks you should also use

     use sigtrap qw(die normal-signals);

   Perl's exception-handling mechanism is its eval() operator.  You can
use eval() as setjmp and die() as longjmp.  For details of this, see the
section on signals, especially the time-out handler for a blocking flock()
in `"Signals"', *Note Perlipc: perlipc, and chapter 6 of the Camel.

   If exception handling is all you're interested in, try the
exceptions.pl library (part of the standard perl distribution).

   If you want the atexit() syntax (and an rmexit() as well), try the
AtExit module available from CPAN.

Why doesn't my sockets program work under System V (Solaris)? What does the error message "Protocol not supported" mean?
------------------------------------------------------------------------------------------------------------------------

   Some Sys-V based systems, notably Solaris 2.X, redefined some of the
standard socket constants.  Since these were constant across all
architectures, they were often hardwired into perl code.  The proper way
to deal with this is to "use Socket" to get the correct values.

   Note that even though SunOS and Solaris are binary compatible, these
values are different.  Go figure.

How can I call my system's unique C functions from Perl?
--------------------------------------------------------

   In most cases, you write an external module to do it - see the answer
to "Where can I learn about linking C with Perl? [h2xs, xsubpp]".
However, if the function is a system call, and your system supports
syscall(), you can use the syscall function (documented in *Note Perlfunc:
perlfunc,).

   Remember to check the modules that came with your distribution, and
CPAN as well - someone may already have written a module to do it.

Where do I get the include files to do ioctl() or syscall()?
------------------------------------------------------------

   Historically, these would be generated by the h2ph tool, part of the
standard perl distribution.  This program converts cpp(1) directives in C
header files to files containing subroutine definitions, like
&SYS_getitimer, which you can use as arguments to your functions.  It
doesn't work perfectly, but it usually gets most of the job done.  Simple
files like `errno.h', `syscall.h', and `socket.h' were fine, but the hard
ones like `ioctl.h' nearly always need to hand-edited.  Here's how to
install the *.ph files:

     1.  become super-user
     2.  cd /usr/include
     3.  h2ph *.h */*.h

   If your system supports dynamic loading, for reasons of portability and
sanity you probably ought to use h2xs (also part of the standard perl
distribution).  This tool converts C header files to Perl extensions.  See
*Note Perlxstut: perlxstut, for how to get started with h2xs.

   If your system doesn't support dynamic loading, you still probably
ought to use h2xs.  See *Note Perlxstut: perlxstut, and *Note
ExtUtils/MakeMaker: (pm.info)ExtUtils/MakeMaker, for more information (in
brief, just use *make perl* instead of a plain make to rebuild perl with a
new static extension).

Why do setuid perl scripts complain about kernel problems?
----------------------------------------------------------

   Some operating systems have bugs in the kernel that make setuid scripts
inherently insecure.  Perl gives you a number of options (described in
*Note Perlsec: perlsec,) to work around such systems.

How can I open a pipe both to and from a command?
-------------------------------------------------

   The IPC::Open2 module (part of the standard perl distribution) is an
easy-to-use approach that internally uses pipe(), fork(), and exec() to do
the job.  Make sure you read the deadlock warnings in its documentation,
though (see *Note IPC/Open2: (pm.info)IPC/Open2,).  See `"Bidirectional
Communication with Another Process"', *Note Perlipc: perlipc, and
`"Bidirectional Communication with Yourself"', *Note Perlipc: perlipc,

   You may also use the IPC::Open3 module (part of the standard perl
distribution), but be warned that it has a different order of arguments
from IPC::Open2 (see *Note IPC/Open3: (pm.info)IPC/Open3,).

Why can't I get the output of a command with system()?
------------------------------------------------------

   You're confusing the purpose of system() and backticks (").  system()
runs a command and returns exit status information (as a 16 bit value: the
low 7 bits are the signal the process died from, if any, and the high 8
bits are the actual exit value).  Backticks (") run a command and return
what it sent to STDOUT.

     $exit_status   = system("mail-users");
     $output_string = `ls`;

How can I capture STDERR from an external command?
--------------------------------------------------

   There are three basic ways of running external commands:

     system $cmd;		# using system()
     $output = `$cmd`;		# using backticks (``)
     open (PIPE, "cmd |");	# using open()

   With system(), both STDOUT and STDERR will go the same place as the
script's versions of these, unless the command redirects them.  Backticks
and open() read *only* the STDOUT of your command.

   With any of these, you can change file descriptors before the call:

     open(STDOUT, ">logfile");
     system("ls");

   or you can use Bourne shell file-descriptor redirection:

     $output = `$cmd 2>some_file`;
     open (PIPE, "cmd 2>some_file |");

   You can also use file-descriptor redirection to make STDERR a duplicate
of STDOUT:

     $output = `$cmd 2>&1`;
     open (PIPE, "cmd 2>&1 |");

   Note that you *cannot* simply open STDERR to be a dup of STDOUT in your
Perl program and avoid calling the shell to do the redirection.  This
doesn't work:

     open(STDERR, ">&STDOUT");
     $alloutput = `cmd args`;  # stderr still escapes

   This fails because the open() makes STDERR go to where STDOUT was going
at the time of the open().  The backticks then make STDOUT go to a string,
but don't change STDERR (which still goes to the old STDOUT).

   Note that you must use Bourne shell (sh(1)) redirection syntax in
backticks, not csh(1)!  Details on why Perl's system() and backtick and
pipe opens all use the Bourne shell are in
http://www.perl.com/CPAN/doc/FMTEYEWTK/versus/csh.whynot .  To capture a
command's STDERR and STDOUT together:

     $output = `cmd 2>&1`;                       # either with backticks
     $pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
     while (<PH>) { }                            #    plus a read

   To capture a command's STDOUT but discard its STDERR:

     $output = `cmd 2>/dev/null`;                # either with backticks
     $pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
     while (<PH>) { }                            #    plus a read

   To capture a command's STDERR but discard its STDOUT:

     $output = `cmd 2>&1 1>/dev/null`;           # either with backticks
     $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
     while (<PH>) { }                            #    plus a read

   To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out our old STDERR:

     $output = `cmd 3>&1 1>&2 2>&3 3>&-`;        # either with backticks
     $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&-|");# or with an open pipe
     while (<PH>) { }                            #    plus a read

   To read both a command's STDOUT and its STDERR separately, it's easiest
and safest to redirect them separately to files, and then read from those
files when the program is done:

     system("program args 1>/tmp/program.stdout 2>/tmp/program.stderr");

   Ordering is important in all these examples.  That's because the shell
processes file descriptor redirections in strictly left to right order.

     system("prog args 1>tmpfile 2>&1");
     system("prog args 2>&1 1>tmpfile");

   The first command sends both standard out and standard error to the
temporary file.  The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.

Why doesn't open() return an error when a pipe open fails?
----------------------------------------------------------

   Because the pipe open takes place in two steps: first Perl calls fork()
to start a new process, then this new process calls exec() to run the
program you really wanted to open.  The first step reports success or
failure to your process, so open() can only tell you whether the fork()
succeeded or not.

   To find out if the exec() step succeeded, you have to catch SIGCHLD and
wait() to get the exit status.  You should also catch SIGPIPE if you're
writing to the child-you may not have found out the exec() failed by the
time you write.  This is documented in *Note Perlipc: perlipc,.

   In some cases, even this won't work.  If the second argument to a piped
open() contains shell metacharacters, perl fork()s, then exec()s a shell
to decode the metacharacters and eventually run the desired program.  Now
when you call wait(), you only learn whether or not the *shell* could be
successfully started.  Best to avoid shell metacharacters.

   On systems that follow the spawn() paradigm, open() *might* do what you
expect-unless perl uses a shell to start your command. In this case the
fork()/exec() description still applies.

What's wrong with using backticks in a void context?
----------------------------------------------------

   Strictly speaking, nothing.  Stylistically speaking, it's not a good
way to write maintainable code because backticks have a (potentially
humongous) return value, and you're ignoring it.  It's may also not be very
efficient, because you have to read in all the lines of output, allocate
memory for them, and then throw it away.  Too often people are lulled to
writing:

     `cp file file.bak`;

   And now they think "Hey, I'll just always use backticks to run
programs."  Bad idea: backticks are for capturing a program's output; the
system() function is for running programs.

   Consider this line:

     `cat /etc/termcap`;

   You haven't assigned the output anywhere, so it just wastes memory (for
a little while).  Plus you forgot to check $? to see whether the program
even ran correctly.  Even if you wrote

     print `cat /etc/termcap`;

   In most cases, this could and probably should be written as

     system("cat /etc/termcap") == 0
     	or die "cat program failed!";

   Which will get the output quickly (as it is generated, instead of only
at the end) and also check the return value.

   system() also provides direct control over whether shell wildcard
processing may take place, whereas backticks do not.

How can I call backticks without shell processing?
--------------------------------------------------

   This is a bit tricky.  Instead of writing

     @ok = `grep @opts '$search_string' @filenames`;

   You have to do this:

     my @ok = ();
     if (open(GREP, "-|")) {
         while (<GREP>) {
     	    chomp;
             push(@ok, $_);
         }
     	close GREP;
     } else {
         exec 'grep', @opts, $search_string, @filenames;
     }

   Just as with system(), no shell escapes happen when you exec() a list.
Further examples of this can be found in `"Safe Pipe Opens"', *Note
Perlipc: perlipc,.

   Note that if you're stuck on Microsoft, no solution to this vexing issue
is even possible.  Even if Perl were to emulate fork(), you'd still be
hosed, because Microsoft gives no argc/argv-style API.  Their API always
reparses from a single string, which is fundamentally wrong, but you're
not likely to get the Gods of Redmond to acknowledge this and fix it for
you.

Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?
-----------------------------------------------------------------------------------

   Because some stdio's set error and eof flags that need clearing.  The
POSIX module defines clearerr() that you can use.  That is the technically
correct way to do it.  Here are some less reliable workarounds:

  1. Try keeping around the seekpointer and go there, like this:

          $where = tell(LOG);
          seek(LOG, $where, 0);

  2. If that doesn't work, try seeking to a different part of the file and
     then back.

  3. If that doesn't work, try seeking to a different part of the file,
     reading something, and then seeking back.

  4. If that doesn't work, give up on your stdio package and use sysread.


How can I convert my shell script to perl?
------------------------------------------

   Learn Perl and rewrite it.  Seriously, there's no simple converter.
Things that are awkward to do in the shell are easy to do in Perl, and
this very awkwardness is what would make a shell->perl converter nigh-on
impossible to write.  By rewriting it, you'll think about what you're
really trying to do, and hopefully will escape the shell's pipeline
datastream paradigm, which while convenient for some matters, causes many
inefficiencies.

Can I use perl to run a telnet or ftp session?
----------------------------------------------

   Try the Net::FTP, TCP::Client, and Net::Telnet modules (available from
CPAN).  http://www.perl.com/CPAN/scripts/netstuff/telnet.emul.shar will
also help for emulating the telnet protocol, but Net::Telnet is quite
probably easier to use..

   If all you want to do is pretend to be telnet but don't need the
initial telnet handshaking, then the standard dual-process approach will
suffice:

     use IO::Socket; 	    	# new in 5.004
     $handle = IO::Socket::INET->new('www.perl.com:80')
     	    || die "can't connect to port 80 on www.perl.com: $!";
     $handle->autoflush(1);
     if (fork()) { 	    	# XXX: undef means failure
     	select($handle);
     	print while <STDIN>;    # everything from stdin to socket
     } else {
     	print while <$handle>;  # everything from socket to stdout
     }
     close $handle;
     exit;

How can I write expect in Perl?
-------------------------------

   Once upon a time, there was a library called chat2.pl (part of the
standard perl distribution), which never really got finished.  If you find
it somewhere, *don't use it*.  These days, your best bet is to look at the
Expect module available from CPAN, which also requires two other modules
from CPAN, IO::Pty and IO::Stty.

Is there a way to hide perl's command line from programs such as "ps"?
----------------------------------------------------------------------

   First of all note that if you're doing this for security reasons (to
avoid people seeing passwords, for example) then you should rewrite your
program so that critical information is never given as an argument.
Hiding the arguments won't make your program completely secure.

   To actually alter the visible command line, you can assign to the
variable $0 as documented in *Note Perlvar: perlvar,.  This won't work on
all operating systems, though.  Daemon programs like sendmail place their
state there, as in:

     $0 = "orcus [accepting connections]";

I {changed directory, modified my environment} in a perl script.  How come the change disappeared when I exited the script?  How do I get my changes to be visible?
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Unix
     In the strictest sense, it can't be done - the script executes as a
     different process from the shell it was started from.  Changes to a
     process are not reflected in its parent, only in its own children
     created after the change.  There is shell magic that may allow you to
     fake it by eval()ing the script's output in your shell; check out the
     comp.unix.questions FAQ for details.

How do I close a process's filehandle without waiting for it to complete?
-------------------------------------------------------------------------

   Assuming your system supports such things, just send an appropriate
signal to the process (see `"kill"', *Note Perlfunc: perlfunc,.  It's
common to first send a TERM signal, wait a little bit, and then send a
KILL signal to finish it off.

How do I fork a daemon process?
-------------------------------

   If by daemon process you mean one that's detached (disassociated from
its tty), then the following process is reported to work on most Unixish
systems.  Non-Unix users should check their Your_OS::Process module for
other solutions.

   * Open /dev/tty and use the TIOCNOTTY ioctl on it.  See `tty(4)' in
     this node for details.  Or better yet, you can just use the
     POSIX::setsid() function, so you don't have to worry about process
     groups.

   * Change directory to /

   * Reopen STDIN, STDOUT, and STDERR so they're not connected to the old
     tty.

   * Background yourself like this:

          fork && exit;

   The Proc::Daemon module, available from CPAN, provides a function to
perform these actions for you.

How do I make my program run with sh and csh?
---------------------------------------------

   See the `eg/nih' script (part of the perl source distribution).

How do I find out if I'm running interactively or not?
------------------------------------------------------

   Good question.  Sometimes `-t STDIN' and `-t STDOUT' can give clues,
sometimes not.

     if (-t STDIN && -t STDOUT) {
     	print "Now what? ";
     }

   On POSIX systems, you can test whether your own process group matches
the current process group of your controlling terminal as follows:

     use POSIX qw/getpgrp tcgetpgrp/;
     open(TTY, "/dev/tty") or die $!;
     $tpgrp = tcgetpgrp(fileno(*TTY));
     $pgrp = getpgrp();
     if ($tpgrp == $pgrp) {
         print "foreground\n";
     } else {
         print "background\n";
     }

How do I timeout a slow event?
------------------------------

   Use the alarm() function, probably in conjunction with a signal
handler, as documented in `"Signals"', *Note Perlipc: perlipc, and chapter
6 of the Camel.  You may instead use the more flexible Sys::AlarmCall
module available from CPAN.

How do I set CPU limits?
------------------------

   Use the BSD::Resource module from CPAN.

How do I avoid zombies on a Unix system?
----------------------------------------

   Use the reaper code from `"Signals"', *Note Perlipc: perlipc, to call
wait() when a SIGCHLD is received, or else use the double-fork technique
described in `fork', *Note Perlfunc: perlfunc,.

How do I use an SQL database?
-----------------------------

   There are a number of excellent interfaces to SQL databases.  See the
DBD::* modules available from http://www.perl.com/CPAN/modules/DBD .  A
lot of information on this can be found at
http://www.symbolstone.org/technology/perl/DBI/

How do I make a system() exit on control-C?
-------------------------------------------

   You can't.  You need to imitate the system() call (see *Note Perlipc:
perlipc, for sample code) and then have a signal handler for the INT
signal that passes the signal on to the subprocess.  Or you can check for
it:

     $rc = system($cmd);
     if ($rc & 127) { die "signal death" }

How do I open a file without blocking?
--------------------------------------

   If you're lucky enough to be using a system that supports non-blocking
reads (most Unixish systems do), you need only to use the O_NDELAY or
O_NONBLOCK flag from the Fcntl module in conjunction with sysopen():

     use Fcntl;
     sysopen(FH, "/tmp/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
         or die "can't open /tmp/somefile: $!":

How do I install a module from CPAN?
------------------------------------

   The easiest way is to have a module also named CPAN do it for you.
This module comes with perl version 5.004 and later.  To manually install
the CPAN module, or any well-behaved CPAN module for that matter, follow
these steps:

  1. Unpack the source into a temporary area.

  2.      perl Makefile.PL

  3.      make

  4.      make test

  5.      make install

        If your version of perl is compiled without dynamic loading, then
you just need to replace step 3 (make) with *make perl* and you will get a
new `perl' binary with your extension linked in.

   See *Note ExtUtils/MakeMaker: (pm.info)ExtUtils/MakeMaker, for more
details on building extensions.  See also the next question.

What's the difference between require and use?
----------------------------------------------

   Perl offers several different ways to include code from one file into
another.  Here are the deltas between the various inclusion constructs:

     1)  do $file is like eval `cat $file`, except the former:
     	1.1: searches @INC and updates %INC.
     	1.2: bequeaths an *unrelated* lexical scope on the eval'ed code.

     2)  require $file is like do $file, except the former:
     	2.1: checks for redundant loading, skipping already loaded files.
     	2.2: raises an exception on failure to find, compile, or execute $file.

     3)  require Module is like require "Module.pm", except the former:
     	3.1: translates each "::" into your system's directory separator.
     	3.2: primes the parser to disambiguate class Module as an indirect object.

     4)  use Module is like require Module, except the former:
     	4.1: loads the module at compile time, not run-time.
     	4.2: imports symbols and semantics from that package to the current one.

   In general, you usually want use and a proper Perl module.

How do I keep my own module/library directory?
----------------------------------------------

   When you build modules, use the PREFIX option when generating Makefiles:

     perl Makefile.PL PREFIX=/u/mydir/perl

   then either set the PERL5LIB environment variable before you run
scripts that use the modules/libraries (see *Note Perlrun: perlrun,) or say

     use lib '/u/mydir/perl';

   This is almost the same as:

     BEGIN {
     	unshift(@INC, '/u/mydir/perl');
     }

   except that the lib module checks for machine-dependent subdirectories.
See Perl's *Note Lib: (pm.info)lib, for more information.

How do I add the directory my program lives in to the module/library search path?
---------------------------------------------------------------------------------

     use FindBin;
     use lib "$FindBin::Bin";
     use your_own_modules;

How do I add a directory to my include path at runtime?
-------------------------------------------------------

   Here are the suggested ways of modifying your include path:

     the PERLLIB environment variable
     the PERL5LIB environment variable
     the perl -Idir command line flag
     the use lib pragma, as in
         use lib "$ENV{HOME}/myown_perllib";

   The latter is particularly useful because it knows about machine
dependent architectures.  The lib.pm pragmatic module was first included
with the 5.002 release of Perl.

What is socket.ph and where do I get it?
----------------------------------------

   It's a perl4-style file defining values for system networking
constants.  Sometimes it is built using h2ph when Perl is installed, but
other times it is not.  Modern programs `use Socket;' instead.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.


