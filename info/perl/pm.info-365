This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Test/Unit/Assert,  Next: Test/Unit/Exception,  Prev: Test/Unit,  Up: Module List

unit testing framework assertion class
**************************************

NAME
====

     Test::Unit::Assert - unit testing framework assertion class

SYNOPSIS
========

     # this class is not intended to be used directly,
     # normally you get the functionality by subclassing from
     # Test::Unit::TestCase

     use Test::Unit::TestCase;
     
     # more code here ...
     
     $self->assert($your_condition_here, $your_optional_message_here);

     # NOTE: if you want to use regexes in comparisons, do it like this:

     $self->assert(scalar("foo" =~ /bar/), $your_optional_message_here);

DESCRIPTION
===========

     This class is used by the framework to assert boolean conditions
     that determine the result of a given test. The optional message
     will be displayed if the condition fails. Normally, it is not
     used directly, but you get the functionality by subclassing from
     Test::Unit::TestCase.

     There is one problem with assert(): the arguments to assert() are
     evaluated in list context, e.g. making a failing regex "pull" the
     message into the place of the first argument. Since this is ususally
     just plain wrong, please use scalar() to force the regex comparison
     to yield a useful boolean value. I currently do not see a way around
     this, since function prototypes don't work for object methods, and
     any other tricks (counting argument number, and complaining if there
     is only one argument and it looks like a string, etc.) don't appeal
     to me. Thanks to Matthew Astley for noting this effect.

     The procedural interface to this framework, Test::Unit, does not have
     this problem, as it exports a "normal" assert() function, and that can
     and does use a function prototype to correct the problem.

AUTHOR
======

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

     Thanks for patches go to:
     Matthew Astley, David Esposito.

SEE ALSO
========

     - Test::Unit::TestCase
     - Test::Unit::Exception
     - The framework self-testing suite (Test::Unit::tests::AllTests)


File: pm.info,  Node: Test/Unit/Exception,  Next: Test/Unit/ExceptionError,  Prev: Test/Unit/Assert,  Up: Module List

unit testing framework exception class
**************************************

NAME
====

     Test::Unit::Exception - unit testing framework exception class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to communicate the result
     of assertions, which will throw an instance of a subclass
     of this class in case of errors or failures.

AUTHOR
======

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

     Thanks for patches go to:
     Matthew Astley.

SEE ALSO
========

     - Test::Unit::Assert
     - Test::Unit::ExceptionError
     - Test::Unit::ExceptionFailure


File: pm.info,  Node: Test/Unit/ExceptionError,  Next: Test/Unit/ExceptionFailure,  Prev: Test/Unit/Exception,  Up: Module List

unit testing framework exception class
**************************************

NAME
====

     Test::Unit::ExceptionError - unit testing framework exception class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to communicate the result
     of assertions, which will throw an instance of this class
     in case of errors (that is, syntax errors and the like, not
     failed tests, as these are classified as failures).

AUTHOR
======

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::Exception
     - Test::Unit::Assert


File: pm.info,  Node: Test/Unit/ExceptionFailure,  Next: Test/Unit/HarnessUnit,  Prev: Test/Unit/ExceptionError,  Up: Module List

unit testing framework exception class
**************************************

NAME
====

     Test::Unit::ExceptionFailure - unit testing framework exception class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to communicate the result
     of assertions, which will throw an instance of this class
     in case of failures (that is, failed tests, not syntax errors
     and the like, these are classified as errors).

AUTHOR
======

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::Exception
     - Test::Unit::Assert


File: pm.info,  Node: Test/Unit/HarnessUnit,  Next: Test/Unit/InnerClass,  Prev: Test/Unit/ExceptionFailure,  Up: Module List

unit testing framework helper class
***********************************

NAME
====

     Test::Unit::HarnessUnit - unit testing framework helper class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This is a test runner which outputs in the same format that
     Test::Harness expects.

AUTHOR
======

     Copyright (c) 2000 Brian Ewins.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Christian Lemburg, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::UnitHarness
     - Test::Unit::TestRunner
     - Test::Unit::TkTestRunner


File: pm.info,  Node: Test/Unit/InnerClass,  Next: Test/Unit/Test,  Prev: Test/Unit/HarnessUnit,  Up: Module List

unit testing framework helper class
***********************************

NAME
====

     Test::Unit::InnerClass - unit testing framework helper class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to emulate the anonymous
     inner classes feature of Java. It is much easier to port Java
     to Perl using this class.

AUTHOR
======

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - the JUnit testing framework by Kent Beck and Erich Gamma


File: pm.info,  Node: Test/Unit/Test,  Next: Test/Unit/TestCase,  Prev: Test/Unit/InnerClass,  Up: Module List

unit testing framework abstract base class
******************************************

NAME
====

     Test::Unit::Test - unit testing framework abstract base class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to define the interface
     of a test. It is an abstract base class implemented by
     Test::Unit::TestCase and Test::Unit::TestSuite.

     Due to the nature of the Perl OO implementation, this class
     is not really needed, but rather serves as documentation
     of the interface.

AUTHOR
======

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::Assert
     - Test::Unit::TestCase
     - Test::Unit::TestSuite


File: pm.info,  Node: Test/Unit/TestCase,  Next: Test/Unit/TestFailure,  Prev: Test/Unit/Test,  Up: Module List

unit testing framework base class
*********************************

NAME
====

     Test::Unit::TestCase - unit testing framework base class

SYNOPSIS
========

     package FooBar;
     use base qw(Test::Unit::TestCase);
     
     sub new {
         my $self = shift()->SUPER::new(@_);
         # your state for fixture here
         return $self;
     }
     
     sub set_up {
         # provide fixture
     }
     sub tear_down {
         # clean up after test
     }
     sub test_foo {
         # test the foo feature
     }
     sub test_bar {
         # test the bar feature
     }

DESCRIPTION
===========

     (Taken from the JUnit TestCase class documentation)

     A test case defines the "fixture" (resources need for testing)
     to run multiple tests. To define a test case:

     1) implement a subclass of TestCase
     2) define instance variables that store the state of the fixture
     3) initialize the fixture state by overriding set_up()
     4) clean-up after a test by overriding tear_down().

     Each test runs in its own fixture so there can be no side
     effects among test runs. Here is an example:

     package MathTest;
     use base qw(Test::Unit::TestCase);

     sub new {
     	  my $self = shift()->SUPER::new(@_);
     	  $self->{value_1} = 0;
     	  $self->{value_2} = 0;
     	  return $self;
     }
     
     sub set_up {
     	  my $self = shift;
     	  $self->{value_1} = 2;
     	  $self->{value_2} = 3;
     }
     
         For each test implement a method which interacts with the
         fixture.  Verify the expected results with assertions specified
         by calling $self->assert() with a boolean value.

     sub test_add {
     	  my $self = shift;
     	  my $result = $self->{value_1} + $self->{value_2};
     	  $self->assert($result == 5);
     }
     
         Once the methods are defined you can run them. The normal way to
         do this uses reflection to implement run_test. It dynamically
         finds and invokes a method. For this the name of the test case
         has to correspond to the test method to be run. The tests to be
         run can be collected into a TestSuite. The framework provides
         different test runners, which can run a test suite and collect
         the results. A test runner either expects a method suite()
         as the entry point to get a test to run or it will extract the
         suite automatically.

     If you do not like the rather verbose backtrace that appears
     when a test fails, you can use the quell_backtrace() method.
     You will get any message provided, but not the backtrace.

AUTHOR
======

     Framework JUnit authored by Kent Beck and Erich Gamma.

     Ported from Java to Perl by Christian Lemburg.

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

     Thanks for patches go to:
     Matthew Astley.

SEE ALSO
========

     - Test::Unit::TestSuite
     - Test::Unit::TestRunner
     - Test::Unit::TkTestRunner
     - For further examples, take a look at the framework self test
       collection (Test::Unit::tests::AllTests).


File: pm.info,  Node: Test/Unit/TestFailure,  Next: Test/Unit/TestListener,  Prev: Test/Unit/TestCase,  Up: Module List

unit testing framework helper class
***********************************

NAME
====

     Test::Unit::TestFailure - unit testing framework helper class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to record the results
     of failed tests, which will throw an instance of a subclass of
     Test::Unit::Exception in case of errors or failures.

AUTHOR
======

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::TestResult
     - Test::Unit::Exception


File: pm.info,  Node: Test/Unit/TestListener,  Next: Test/Unit/TestLoader,  Prev: Test/Unit/TestFailure,  Up: Module List

unit testing framework abstract base class
******************************************

NAME
====

     Test::Unit::TestListener - unit testing framework abstract base class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to define the interface
     of a test listener. It is an abstract base class implemented by
     the test runners.

     Due to the nature of the Perl OO implementation, this class
     is not really needed, but rather serves as documentation
     of the interface.

     Each of the add_ methods gets two arguments: 'test' and
     'exception'.  The test is a Test::Unit::Test and the exception
     is a Test::Unit::Exception.  Typically you want to display
     test->name() and keep the rest as details.

AUTHOR
======

     Copyright (c) 2000 Brian Ewins, Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::Exception
     - Test::Unit::TestRunner
     - Test::Unit::TkTestRunner


File: pm.info,  Node: Test/Unit/TestLoader,  Next: Test/Unit/TestResult,  Prev: Test/Unit/TestListener,  Up: Module List

unit testing framework helper class
***********************************

NAME
====

     Test::Unit::TestLoader - unit testing framework helper class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to load testcase classes
     into the runtime environment. It handles testcase class names
     (that is, classes inheriting from Test::Unit::TestCase),
     Test::Harness style test files, and directory names.
     
     =head1 AUTHOR

     Copyright (c) 2000 Brian Ewins.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Christian Lemburg, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::TestCase
     - Test::Unit::UnitHarness
     - Test::Unit::TkTestRunner


File: pm.info,  Node: Test/Unit/TestResult,  Next: Test/Unit/TestRunner,  Prev: Test/Unit/TestLoader,  Up: Module List

unit testing framework helper class
***********************************

NAME
====

     Test::Unit::TestResult - unit testing framework helper class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This class is used by the framework to record the results
     of tests, which will throw an instance of a subclass of
     Test::Unit::Exception in case of errors or failures.

     To achieve this, this class gets called with a test case
     as argument. It will call this test case's run method back
     and catch any exceptions thrown.

     This is the quintessential call tree of the communication
     needed to record the results of a given test:

     $aTestCase->run() {
     	# creates result
     	$aTestResult->run($aTestCase) {
     	    # catches exception and records it
     	    $aTestCase->run_bare() {
     		# runs test method inside eval
     		$aTestCase->run_test() {
     		    # calls method $aTestCase->name()
     		    # and propagates exception
     		    # method will call Assert::assert()
     		    # to cause failure if test fails on
     		    # test assertion
     		    # it finds this because $aTestCase is-a Assert
     		}
     	    }
     	}
     }

AUTHOR
======

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::Assert
     - Test::Unit::TestCase
     - Test::Unit::Exception


File: pm.info,  Node: Test/Unit/TestRunner,  Next: Test/Unit/TestSuite,  Prev: Test/Unit/TestResult,  Up: Module List

unit testing framework helper class
***********************************

NAME
====

     Test::Unit::TestRunner - unit testing framework helper class

SYNOPSIS
========

     use Test::Unit::TestRunner;

     my $testrunner = Test::Unit::TestRunner->new();
     $testrunner->start($my_testcase_class);

DESCRIPTION
===========

     This class is the test runner for the command line style use
     of the testing framework.

     It is used by simple command line tools like the TestRunner.pl
     script provided.

     The class needs one argument, which is the name of the class
     encapsulating the tests to be run.
     
     Options:
     	-wait : wait for user confirmation between tests
     	-v    : Version info

AUTHOR
======

     Framework JUnit authored by Kent Beck and Erich Gamma.

     Ported from Java to Perl by Christian Lemburg.

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::TestCase
     - Test::Unit::TestListener
     - Test::Unit::TestSuite
     - Test::Unit::TestResult
     - Test::Unit::TkTestRunner
     - For further examples, take a look at the framework self test
       collection (Test::Unit::tests::AllTests).


File: pm.info,  Node: Test/Unit/TestSuite,  Next: Test/Unit/TkTestRunner,  Prev: Test/Unit/TestRunner,  Up: Module List

unit testing framework base class
*********************************

NAME
====

     Test::Unit::TestSuite - unit testing framework base class

SYNOPSIS
========

     use Test::Unit::TestSuite;

     # more code here ...

     sub suite {
     	my $class = shift;

     # create an empty suite
     my $suite = Test::Unit::TestSuite->empty_new("A Test Suite");
     
     # get and add an existing suite
     $suite->add_test(Test::Unit::TestSuite->new("MyModule::Suite_1"));

     # extract suite by way of suite method and add
     $suite->add_test(MyModule::Suite_2->suite());
     
     # get and add another existing suite
     $suite->add_test(Test::Unit::TestSuite->new("MyModule::TestCase_2"));

     # return the suite built
     return $suite;
         }

DESCRIPTION
===========

     This class is normally not used directly, but it can be used
     for creating your own custom built aggregate suites.

     Normally, this class just provides the functionality of
     auto-building a test suite by extracting methods with a name
     prefix of "test" from a given package to the test runners.

AUTHOR
======

     Framework JUnit authored by Kent Beck and Erich Gamma.

     Ported from Java to Perl by Christian Lemburg.

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::TestRunner
     - Test::Unit::TkTestRunner
     - For further examples, take a look at the framework self test
       collection (Test::Unit::tests::AllTests).


File: pm.info,  Node: Test/Unit/TkTestRunner,  Next: Test/Unit/Tutorial,  Prev: Test/Unit/TestSuite,  Up: Module List

unit testing framework helper class
***********************************

NAME
====

     Test::Unit::TkTestRunner - unit testing framework helper class

SYNOPSIS
========

     use Test::Unit::TkTestRunner;
     Test::Unit::TkTestRunner::main($my_testcase_class);

DESCRIPTION
===========

     This class is the test runner for the GUI style use
     of the testing framework.

     It is used by simple command line tools like the TkTestRunner.pl
     script provided.

     The class needs as arguments the names of the classes
     encapsulating the tests to be run.
     
     =head1 AUTHOR

     Framework JUnit authored by Kent Beck and Erich Gamma.

     Copyright (c) 2000 Brian Ewins.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Christian Lemburg, Cayte Lindner, J.E. Fritz, Zhon Johansen.

     Thanks for patches go to:
     David Esposito.

SEE ALSO
========

     - Test::Unit::TestLoader
     - Test::Unit::TestListener
     - Test::Unit::TestResult
     - Test::Unit::TestRunner
     - Test::Unit::TestCase
     - Test::Unit::TestSuite
     - For further examples, take a look at the framework self test
       collection (Test::Unit::tests::AllTests).


File: pm.info,  Node: Test/Unit/Tutorial,  Next: Test/Unit/UnitHarness,  Prev: Test/Unit/TkTestRunner,  Up: Module List

Tutorial on unit testing
************************

NAME
====

     Test::Unit::Tutorial - Tutorial on unit testing

SYNOPSIS
========

     perldoc Test::Unit::Tutorial

DESCRIPTION
===========

     Here should be extensive documentation on what unit testing is,
     why it is useful, and how to do it with the Test::Unit collection
     of modules.

     Sorry for not implementing this yet.

     Please have a look at the examples in the examples directory
     and read the README file that came with this distribution.

     A short tutorial on how to use the unit testing framework is
     included in the Test::Unit::TestCase documentation.

     Further examples can be found by looking at the self test
     collection, starting in Test::Unit::tests::AllTests.

AUTHOR
======

     Christian Lemburg <lemburg@acm.org>

SEE ALSO
========

     - The module documentation for all modules in the Test::Unit tree.
     - Refactoring. Improving The Design Of Existing Code. Martin Fowler.
       Addison-Wesley, 1999.
     - The JUnit (unit testing framework for Java) documentation.
     - http://www.xProgramming.com/


File: pm.info,  Node: Test/Unit/UnitHarness,  Next: Test/Unit/tests/AllTests,  Prev: Test/Unit/Tutorial,  Up: Module List

unit testing framework helper class
***********************************

NAME
====

     Test::Unit::UnitHarness - unit testing framework helper class

SYNOPSIS
========

     # this class is not intended to be used directly

DESCRIPTION
===========

     This is a makeover of Test::Harness to allow its tests
     to be retrofitted as unit tests.

AUTHOR
======

     Copyright (c) 2000 Brian Ewins.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Christian Lemburg, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::UnitHarness
     - Test::Unit::TestRunner
     - Test::Unit::TkTestRunner


File: pm.info,  Node: Test/Unit/tests/AllTests,  Next: Text/Abbrev,  Prev: Test/Unit/UnitHarness,  Up: Module List

unit testing framework self tests
*********************************

NAME
====

     Test::Unit::tests::AllTests - unit testing framework self tests

SYNOPSIS
========

     # command line style use

     perl TestRunner.pl Test::Unit::tests::AllTests

     # GUI style use

     perl TkTestRunner.pl Test::Unit::tests::AllTests

DESCRIPTION
===========

     This class is used by the unit testing framework to encapsulate
     all the self tests of the framework.
     
     =head1 AUTHOR

     Framework JUnit authored by Kent Beck and Erich Gamma.

     Ported from Java to Perl by Christian Lemburg.

     Copyright (c) 2000 Christian Lemburg, <lemburg@acm.org>.

     All rights reserved. This program is free software; you can
     redistribute it and/or modify it under the same terms as
     Perl itself.

     Thanks go to the other PerlUnit framework people:
     Brian Ewins, Cayte Lindner, J.E. Fritz, Zhon Johansen.

SEE ALSO
========

     - Test::Unit::TestCase
     - Test::Unit::TestSuite


File: pm.info,  Node: Text/Abbrev,  Next: Text/Annotated/Line,  Prev: Test/Unit/tests/AllTests,  Up: Module List

create an abbreviation table from a list
****************************************

NAME
====

   abbrev - create an abbreviation table from a list

SYNOPSIS
========

     use Text::Abbrev;
     abbrev $hashref, LIST

DESCRIPTION
===========

   Stores all unambiguous truncations of each element of LIST as keys in
the associative array referenced by $hashref.  The values are the original
list elements.

EXAMPLE
=======

     $hashref = abbrev qw(list edit send abort gripe);

     %hash = abbrev qw(list edit send abort gripe);

     abbrev $hashref, qw(list edit send abort gripe);

     abbrev(*hash, qw(list edit send abort gripe));


File: pm.info,  Node: Text/Annotated/Line,  Next: Text/Annotated/Reader,  Prev: Text/Abbrev,  Up: Module List

strings with annotation about their origin
******************************************

NAME
====

   Text::Annotated::Line - strings with annotation about their origin

SYNOPSIS
========

     use Text::Annotated::Line;
     
     # construct a line
     $line = new Text::Annotated::Line(
          filename => 'foo',
          linenr   => 23,
          content  => 'This is the line content',
     );

     # print the line, with annotation
     print $line->stringify_annotated, "\n";

     # print the line without annotation
     print $line, "\n";

DESCRIPTION
===========

FIELDS
------

   All of the following fields must be set through the constructor new():

filename
     name of the file the string originates from

linenr
     number of the line in the file the string is located

content
     the actual content of the string

METHODS
-------

new()
     Constructs a new Text::Annotated::Line object. Fields can be set by
     passing them as a hash to new().

stringify()
     Returns the line without annotations. This method is used for
     overloading, so you implicitly call it in any circumstance where you
     use a Text::Annotated::Line object where a string is expected.

stringify_annotated()
     Returns a string with the content AND the annotation if the format
     `[filename#linenr]content'. Trailing newlines in the content are
     omitted.

SEE ALSO
========

   Filters for handling annotated lines are described in *Note
Text/Annotated/Reader: Text/Annotated/Reader, and *Note
Text/Annotated/Writer: Text/Annotated/Writer,.

CVS VERSION
===========

   This is CVS version $Revision: 1.3 $, last updated at $Date: 2000/12/05
15:45:10 $.

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright (c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: Text/Annotated/Reader,  Next: Text/Annotated/Writer,  Prev: Text/Annotated/Line,  Up: Module List

a filter for annotating lines coming from a file
************************************************

NAME
====

   Text::Annotated::Reader - a filter for annotating lines coming from a
file

SYNOPSIS
========

     use Text::Annotated::Reader;

     my $reader = new Text::Annotated::Reader(input => 'text.in');
     $reader->read();
     $ra_annotated_lines = $reader->{annotated_lines};

DESCRIPTION
===========

   Text::Annotated::Reader is a subclass of Text::Filter, with as purpose
the reading of lines from a file, and annotating the filename and
linenumber for each line. The following issues are specific to
Text::Annotated::Reader:

   * The set_input() method only accepts filenames as a valid input
     argument.  This requirement is also imposed on the input argument
     passed to new(), as new() invokes set_input().

   * The read() method executes the input operation. run() is an alias for
     read().

   * The reader() method builds a Text::Annotated::Reader filter with the
     supplied arguments, calls read() and finally returns the filter. It
     is thus possible to combine the whole input operation in a single
     statement like

          my $ra_annotated_lines =
            Text::Annotated::Reader->reader(input => 'text.in')->{annotated_lines};

SEE ALSO
========

   More info on using filters is available from *Note Text/Filter:
Text/Filter,.

   *Note Text/Annotated/Line: Text/Annotated/Line, describes annotated
lines.

CVS VERSION
===========

   This is CVS version $Revision: 1.4 $, last updated at $Date: 2000/12/05
15:45:11 $.

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright (c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: Text/Annotated/Writer,  Next: Text/Autoformat,  Prev: Text/Annotated/Reader,  Up: Module List

filter for writing Text::Annotated lines
****************************************

NAME
====

   Text::Annotated::Writer - filter for writing Text::Annotated lines

SYNOPSIS
========

     use Text::Annotated::Writer;

     my $writer = new Text::Annotated::Writer(
          input  => $ra_annotated_lines, # ref to array with Text::Annotated objects
     	 output => 'text.out', # output file
          no_annotation => 1,   # suppresses writing of the annotations
     );
     $writer->write(); # actually writes the lines to file

DESCRIPTION
===========

   Text::Annotated::Writer is a subclass of Text::Filter, with as purpose
the dumping of annotated lines to an array of ASCII lines or a file. The
following issues are specific to Text::Annotated::Writer:

   * The list of allowed arguments to new() includes the `no_annotation'
     flag. When set to a true value, the annotation of the lines is
     suppressed in the output, and only the ASCII content is shown. The
     default behaviour is to output the annotation with each line.

   * The write() method executes the output operation. run() is an alias
     for write().

   * The writer() method builds a Text::Annotated::Writer filter with the
     supplied arguments, calls write() and finally returns the filter. It
     is thus possible to combine the whole output operation in a single
     statement like

          Text::Annotated::Writer->writer(
          	input  => $ra_annotated_lines,
              output => 'text.out',
              no_annotation => 1,
          );

SEE ALSO
========

   More info on using filters is available from *Note Text/Filter:
Text/Filter,.

   *Note Text/Annotated/Line: Text/Annotated/Line, describes annotated
lines.

CVS VERSION
===========

   This is CVS version $Revision: 1.4 $, last updated at $Date: 2000/12/05
15:45:11 $.

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright (c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: Text/Autoformat,  Next: Text/Balanced,  Prev: Text/Annotated/Writer,  Up: Module List

Automatic and manual text wrapping and reformating formatting
*************************************************************

NAME
====

   Text::Autoformat - Automatic and manual text wrapping and reformating
formatting

VERSION
=======

   This document describes version 1.04 of Text::Autoformat, released
December  5, 2000.

SYNOPSIS
========

     # Minimal use: read from STDIN, format to STDOUT...

     use Text::Autoformat;
     autoformat;

     # In-memory formatting...

     $formatted = autoformat $rawtext;

     # Configuration...

     $formatted = autoformat $rawtext, { %options };

     # Margins (1..72 by default)...

     $formatted = autoformat $rawtext, { left=>8, right=>70 };

     # Justification (left by default)...

     $formatted = autoformat $rawtext, { justify => 'left' };
     $formatted = autoformat $rawtext, { justify => 'right' };
     $formatted = autoformat $rawtext, { justify => 'full' };
     $formatted = autoformat $rawtext, { justify => 'centre' };

     # Filling (does so by default)...

     $formatted = autoformat $rawtext, { fill=>0 };

     # Squeezing whitespace (does so by default)...

     $formatted = autoformat $rawtext, { squeeze=>0 };

     # Case conversions...

     $formatted = autoformat $rawtext, { case => 'lower' };
     $formatted = autoformat $rawtext, { case => 'upper' };
     $formatted = autoformat $rawtext, { case => 'sentence' };
     $formatted = autoformat $rawtext, { case => 'title' };
     $formatted = autoformat $rawtext, { case => 'highlight' };

BACKGROUND
==========

The problem
-----------

   Perl plaintext formatters just aren't smart enough. Given a typical
piece of plaintext in need of formatting:

     In comp.lang.perl.misc you wrote:
     : > <CN = Clooless Noobie> writes:
     : > CN> PERL sux because:
     : > CN>    * It doesn't have a switch statement and you have to put $
     : > CN>signs in front of everything
     : > CN>    * There are too many OR operators: having |, || and 'or'
     : > CN>operators is confusing
     : > CN>    * VB rools, yeah!!!!!!!!!
     : > CN> So anyway, how can I stop reloads on a web page?
     : > CN> Email replies only, thanks - I don't read this newsgroup.
     : >
     : > Begone, sirrah! You are a pathetic, Bill-loving, microcephalic
     : > script-infant.
     : Sheesh, what's with this group - ask a question, get toasted! And how
     : *dare* you accuse me of Ianuphilia!

   both the venerable Unix `fmt' in this node tool and Perl's standard
Text::Wrap module produce:

     In comp.lang.perl.misc you wrote:  : > <CN = Clooless Noobie>
     writes:  : > CN> PERL sux because:  : > CN>    * It doesn't
     have a switch statement and you have to put $ : > CN>signs in
     front of everything : > CN>    * There are too many OR
     operators: having |, || and 'or' : > CN>operators is confusing
     : > CN>    * VB rools, yeah!!!!!!!!!  : > CN> So anyway, how
     can I stop reloads on a web page?  : > CN> Email replies only,
     thanks - I don't read this newsgroup.  : > : > Begone, sirrah!
     You are a pathetic, Bill-loving, microcephalic : >
     script-infant.  : Sheesh, what's with this group - ask a
     question, get toasted! And how : *dare* you accuse me of
     Ianuphilia!

   Other formatting modules - such as Text::Correct and Text::Format -
provide more control over their output, but produce equally poor results
when applied to arbitrary input. They simply don't understand the
structural conventions of the text they're reformatting.

The solution
------------

   The Text::Autoformat module provides a subroutine named `autoformat'
that wraps text to specified margins. However, `autoformat' reformats its
input by analysing the text's structure, so it wraps the above example
like so:

     In comp.lang.perl.misc you wrote:
     : > <CN = Clooless Noobie> writes:
     : > CN> PERL sux because:
     : > CN>    * It doesn't have a switch statement and you
     : > CN>      have to put $ signs in front of everything
     : > CN>    * There are too many OR operators: having |, ||
     : > CN>      and 'or' operators is confusing
     : > CN>    * VB rools, yeah!!!!!!!!! So anyway, how can I
     : > CN>      stop reloads on a web page? Email replies
     : > CN>      only, thanks - I don't read this newsgroup.
     : >
     : > Begone, sirrah! You are a pathetic, Bill-loving,
     : > microcephalic script-infant.
     : Sheesh, what's with this group - ask a question, get toasted!
     : And how *dare* you accuse me of Ianuphilia!

   Note that the various quoting conventions have been observed. In fact,
their structure has been used to determine where some paragraphs begin.
Furthermore `autoformat' correctly distinguished between the leading '*'
bullets of the nested list (which were outdented) and the leading emphatic
'*' of "*dare*" (which was inlined).

DESCRIPTION
===========

Paragraphs
----------

   The fundamental task of the `autoformat' subroutine is to identify and
rearrange independent paragraphs in a text. Paragraphs typically consist
of a series of lines containing at least one non-whitespace character,
followed by one or more lines containing only optional whitespace.  This
is a more liberal definition than many other formatters use: most require
an empty line to terminate a paragraph. Paragraphs may also be denoted by
bulleting, numbering, or quoting (see the following sections).

   Once a paragraph has been isolated, `autoformat' fills and re-wraps its
lines according to the margins that are specified in its argument list.
These are placed after the text to be formatted, in a hash reference:

     $tidied = autoformat($messy, {left=>20, right=>60});

   By default, `autoformat' uses a left margin of 1 (first column) and a
right margin of 72.

   Normally, `autoformat' only reformats the first paragraph it encounters,
and leaves the remainder of the text unaltered. This behaviour is useful
because it allows a one-liner invoking the subroutine to be mapped onto a
convenient keystroke in a text editor, to provide one-paragraph-at-a-time
reformatting:

     % cat .exrc

     map f !Gperl -MText::Autoformat -e'autoformat'

   (Note that to facilitate such one-liners, if `autoformat' is called in
a void context without any text data, it takes its text from STDIN and
writes its result to STDOUT).

   To enable `autoformat' to rearrange the entire input text at once, the
all argument is used:

     $tidied_all = autoformat($messy, {left=>20, right=>60, all=>1});

Bulleting and (re-)numbering
----------------------------

   Often plaintext will include lists that are either:

     * bulleted,
     * simply numbered (i.e. 1., 2., 3., etc.), or
     * hierarchically numbered (1, 1.1, 1.2, 1.3, 2, 2.1. and so forth).

   In such lists, each bulleted item is implicitly a separate paragraph,
and is formatted individually, with the appropriate indentation:

     * bulleted,
     * simply numbered (i.e. 1., 2., 3.,
       etc.), or
     * hierarchically numbered (1, 1.1,
       1.2, 1.3, 2, 2.1. and so forth).

   More importantly, if the points are numbered, the numbering is checked
and reordered. For example, a list whose points have been rearranged:

     2. Analyze problem
     3. Design algorithm
     1. Code solution
     5. Test
     4. Ship

   would be renumbered automatically by `autoformat':

     1. Analyze problem
     2. Design algorithm
     3. Code solution
     4. Ship
     5. Test

   The same reordering would be performed if the "numbering" was by letters
(`a.' `b.' `c.' etc.) or Roman numerals (`i.' `ii.' `iii.)' or by some
combination of these (`1a.' `1b.' `2a.' `2b.' etc.) Handling disordered
lists of letters and Roman numerals presents an interesting challenge. A
list such as:

     C. Put cat in box.
     D. Close lid.
     E. Activate Geiger counter.

   should be reordered as `A.' `B.' `C.,' whereas:

     C. Put cat in box.
     D. Close lid.
     XLI. Activate Geiger counter.

   should be reordered `I.' `II.' `III.'

   The `autoformat' subroutine solves this problem by always interpreting
alphabetic bullets as being letters, unless the full list consists only of
valid Roman numerals, at least one of which is two or more characters long.

Quoting
-------

   Another case in which contiguous lines may be interpreted as belonging
to different paragraphs, is where they are quoted with distinct quoters.
For example:

     : > CN> So anyway, how can I stop reloads on a web page?
     : > CN> Email replies only, thanks - I don't read this newsgroup.
     : > Begone, sirrah! You are a pathetic, Bill-loving,
     : > microcephalic script-infant.
     : Sheesh, what's with this group - ask a question, get toasted!
     : And how *dare* you accuse me of Ianuphilia!

   `autoformat' recognizes the various quoting conventions used in this
example and treats it as three paragraphs to be independently reformatted.

   Block quotations present a different challenge. A typical formatter
would render the following quotation:

     "We are all of us in the gutter,
      but some of us are looking at the stars"
                             -- Oscar Wilde

   like so:

     "We are all of us in the gutter, but some of us are looking at
     the stars" -- Oscar Wilde

   `autoformat' recognizes the quotation structure by matching the
following regular expression against the text component of each paragraph:

     / \A(\s*)               # leading whitespace for quotation
       (["']|``)             # opening quotemark
       (.*)                  # quotation
       (''|\2)               # closing quotemark
       \s*?\n                # trailing whitespace after quotation
       (\1[ ]+)              # leading whitespace for attribution
                             #   (must be indented more than quotation)
       (--|-)                # attribution introducer
       ([^\n]*?\n)           # first attribution line
       ((\5[^\n]*?$)*)       # other attribution lines
                             #   (indented no less than first line)
       \s*\Z                 # optional whitespace to end of paragraph
     /xsm

   When reformatted (see below), the indentation and the attribution
structure will be preserved:

     "We are all of us in the gutter, but some of us are looking
      at the stars"
                             -- Oscar Wilde

Widow control
-------------

   Note that in the last example, `autoformat' broke the line at column
68, four characters earlier than it should have. It did so because, if the
full margin width had been used, the formatting would have left the last
two words by themselves on an oddly short last line:

     "We are all of us in the gutter, but some of us are looking at
      the stars"

   This phenomenon is known as "widowing" and is heavily frowned upon in
typesetting circles. It looks ugly in plaintext too, so `autoformat'
avoids it by stealing extra words from earlier lines in a paragraph, so as
to leave enough for a reasonable last line. The heuristic used is that
final lines must be at least 10 characters long (though this number may be
adjusted by passing a `widow => *minlength*' argument to `autoformat').

   If the last line is too short, the paragraph's right margin is reduced
by one column, and the paragraph is reformatted. This process iterates
until either the last line exceeds nine characters or the margins have
been narrowed by 10% of their original separation. In the latter case, the
reformatter gives up and uses its original formatting.

Justification
-------------

   The `autoformat' subroutine also takes a named argument: `{justify =>
*type*}', which specifies how each paragraph is to be justified.  The
options are: `'left'' (the default), `'right',' `'centre'' (or
`'center''), and `'full''. These act on the complete paragraph text (but
not on any quoters before that text). For example, with `'right''
justification:

     R3>     Now is the Winter of our discontent made
     R3> glorious Summer by this son of York. And all
     R3> the clouds that lour'd upon our house In the
     R3>              deep bosom of the ocean buried.

   Full justification is interesting in a fixed-width medium like plaintext
because it usually results in uneven spacing between words. Typically,
formatters provide this by distributing the extra spaces into the first
available gaps of each line:

     R3> Now  is  the  Winter  of our discontent made
     R3> glorious Summer by this son of York. And all
     R3> the  clouds  that  lour'd  upon our house In
     R3> the deep bosom of the ocean buried.

   This produces a rather jarring visual effect, so `autoformat' reverses
the strategy and inserts extra spaces at the end of lines:

     R3> Now is the Winter  of  our  discontent  made
     R3> glorious Summer by this son of York. And all
     R3> the clouds that lour'd  upon  our  house  In
     R3> the deep bosom of the ocean buried.

   Most readers find this less disconcerting.

Implicit centring
-----------------

   Even if explicit centring is not specified, `autoformat' will attempt
to automatically detect centred paragraphs and preserve their
justification. It does this by examining each line of the paragraph and
asking: "if this line were part of a centred paragraph, where would the
centre line have been?"

   The answer can be determined by adding the length of leading whitespace
before the first word, plus half the length of the full set of words on
the line. That is, for a single line:

     $line =~ /^(\s*)(.*?)(\s*)$/
     $centre = length($1)+0.5*length($2);

   By making the same estimate for every line, and then comparing the
estimates, it is possible to deduce whether all the lines are centred with
respect to the same axis of symmetry (with an allowance of E<plusminus>1
to cater for the inevitable rounding when the centre positions of
even-length rows were originally computed). If a common axis of symmetry
is detected, `autoformat' assumes that the lines are supposed to be
centred, and switches to centre-justification mode for that paragraph.

Case transformations
--------------------

   The `autoformat' subroutine can also optionally perform case conversions
on the text it processes. The `{case => *type*}' argument allows the user
to specify five different conversions:

`'upper''
     This mode unconditionally converts every letter in the reformatted
     text to upper-case;

`'lower''
     This mode unconditionally converts every letter in the reformatted
     text to lower-case;

`'sentence''
     This mode attempts to generate correctly-cased sentences from the
     input text.  That is, the first letter after a sentence-terminating
     punctuator is converted to upper-case. Then, each subsequent word in
     the sentence is converted to lower-case, unless that word is
     originally mixed-case or contains punctuation.  For example, under
     `{case => 'sentence'}':

          'POVERTY, MISERY, ETC. are the lot of the PhD candidate. alas!'

     becomes:

          'Poverty, misery, etc. are the lot of the PhD candidate. Alas!'

     Note that `autoformat' is clever enough to recognize that the period
     after abbreviations such as etc. is not a sentence terminator.

     If the argument is specified as `'sentence  '' (with one or more
     trailing whitespace characters) those characters are used to replace
     the single space that appears at the end of the sentence. For example,
     `autoformat($text, {case=>'sentence  '}') would produce:

          'Poverty, misery, etc. are the lot of the PhD candidate.  Alas!'

'title'
     This mode behaves like `'sentence'' except that the first letter of
     every word is capitalized:

          'What I Did On My Summer Vacation In Monterey'

`'highlight''
     This mode behaves like 'title' except that trivial words are not
     capitalized:

          'What I Did on my Summer Vacation in Monterey'

OTHER FEATURES
==============

The form sub
------------

   The `form()' subroutine may be exported from the module.  It takes a
series of format (or "picture") strings followed by replacement values,
interpolates those values into each picture string, and returns the
result. The effect is similar to the inbuilt perl format mechanism,
although the field specification syntax is simpler and some of the
formatting behaviour is more sophisticated.

   A picture string consists of sequences of the following characters:

<
     Left-justified field indicator.  A series of sequential <'s specify a
     left-justified field to be filled by a subsequent value.

>
     Right-justified field indicator.  A series of sequential >'s specify
     a right-justified field to be filled by a subsequent value.

^
     Centre-justified field indicator.  A series of sequential ^'s specify
     a centred field to be filled by a subsequent value.

>>>.<<<<
     A numerically formatted field with the specified number of digits to
     either side of the decimal place. See `Numerical formatting' in this
     node below.

[
     Left-justified block field indicator.  Just like a < field, except it
     repeats as required on subsequent lines. See below.

]
     Right-justified block field indicator.  Just like a > field, except
     it repeats as required on subsequent lines. See below.

|
     Centre-justified block field indicator.  Just like a ^ field, except
     it repeats as required on subsequent lines. See below.

]]].[[[[
     A numerically formatted block field with the specified number of
     digits to either side of the decimal place.  Just like a >>>.<<<<
     field, except it repeats as required on subsequent lines. See below.

\
     Literal escape of next character (e.g. `\|' is formatted as '|', not
     a one character wide centre-justified block field).

Any other character
     That literal character.

   Any substitution value which is undef (either explicitly so, or because
it is missing) is replaced by an empty string.

Controlling line filling.
-------------------------

   Note that, unlike the a perl format, form preserves whitespace
(including newlines) unless called with certain options.

   The "squeeze" option (when specified with a true value) causes any
sequence of spaces and/or tabs (but not newlines) in an interpolated
string to be replaced with a single space.

   The "fill" option causes newlines to also be squeezed.

   Hence:

     $frmt = "# [[[[[[[[[[[[[[[[[[[[[";
     $data = "h  e\t \tl lo\nworld\t\t\t\t\t";

     print form $frmt, $data;
     # h  e            l lo
     # world

     print form {squeeze=>1}, $frmt, $data;
     # h e l lo
     # world

     print form {fill=>1}, $frmt, $data;
     # h  e            l lo world

     print form {squeeze=>1, fill=>1}, $frmt, $data;
     # h e l lo world

   Whether or not filling or squeezing is in effect, form can also be
directed to trim any extra whitespace from the end of each line it
formats, using the "trim" option. If this option is specified with a true
value, every line returned by form will automatically have the
substitution `s/[ \t]+$//gm' applied to it.

   Hence:

     print length form "[[[[[[[[[[", "short";
     # 11

     print length form {trim=>1}, "[[[[[[[[[[", "short";
     # 6

Temporary and permanent default options
---------------------------------------

   If form is called with options, but no template string or data, it
resets it's defaults to the options specified. If called in a void context:

     form { squeeze => 1, trim => 1 };

   the options become permanent defaults.

   However, when called with only options in non-void context, form resets
its defaults to those options and returns an object. The reset default
values persist only until that returned object is destroyed.  Hence to
temporarily reset form's defaults within a single subroutine:

     sub single {
             my $tmp = form { squeeze => 1, trim => 1 };

     # do formatting with the obove defaults

     } # form's defaults revert to previous values as $tmp object destroyed

How form hyphenates
-------------------

   Any line with a block field repeats on subsequent lines until all block
fields on that line have consumed all their data. Non-block fields on
these lines are replaced by the appropriate number of spaces.

   Words are wrapped whole, unless they will not fit into the field at
all, in which case they are broken and (by default) hyphenated. Simple
hyphenation is used (i.e. break at the *N-1*th character and insert a
'-'), unless a suitable alternative subroutine is specified instead.

   Words will not be broken if the break would leave less than 2
characters on the current line. This minimum can be varied by setting the
'minbreak' option to a numeric value indicating the minumum total broken
characters (including hyphens) required on the current line. Note that,
for very narrow fields, words will still be broken (but *unhyphenated*).
For example:

     print form '|', 'split';

   would print:

     s
     p
     l
     i
     t

   whilst:

     print form {minbreak=>1}, '|', 'split';

   would print:

     s-
     p-
     l-
     i-
     t

   Alternative breaking subroutines can be specified using the "break"
option in a configuration hash. For example:

     form { break => \&my_line_breaker }
          $format_str,
          @data;

   form expects any user-defined line-breaking subroutine to take three
arguments (the string to be broken, the maximum permissible length of the
initial section, and the total width of the field being filled).  The
`hypenate' sub must return a list of two strings: the initial (broken)
section of the word, and the remainder of the string respectively).

   For example:

     sub tilde_break = sub($$$)
     {
             (substr($_[0],0,$_[1]-1).'~', substr($_[0],$_[1]-1));
     }

     form { break => \&tilde_break }
          $format_str,
          @data;

   makes '~' the hyphenation character, whilst:

     sub wrap_and_slop = sub($$$)
     {
             my ($text, $reqlen, $fldlen) = @_;
             if ($reqlen==$fldlen) { $text =~ m/\A(\s*\S*)(.*)/s }
             else                  { ("", $text) }
     }

     form { break => \&wrap_and_slop }
          $format_str,
          @data;

   wraps excessively long words to the next line and "slops" them over the
right margin if necessary.

   The Text::Autoformat package provides three functions to simplify the
use of variant hyphenation schemes. The exportable subroutine
`Text::Autoformat::break_wrap' generates a reference to a subroutine
implementing the "wrap-and-slop" algorithm shown in the last example,
which could therefore be rewritten:

     use Text::Autoformat qw( form break_wrap );

     form { break => break_wrap }
          $format_str,
          @data;

   The subroutine `Text::Autoformat::break_with' takes a single string
argument and returns a reference to a sub which hyphenates with that
string. Hence the first of the two examples could be rewritten:

     use Text::Autoformat qw( form break_wrap );

     form { break => break_with('~') }
          $format_str,
          @data;

   The subroutine `Text::Autoformat::break_TeX' returns a reference to a
sub which hyphenates using Jan Pazdziora's TeX::Hyphen module. For example:

     use Text::Autoformat qw( form break_wrap );

     form { break => break_TeX }
          $format_str,
          @data;

   Note that in the previous examples there is no leading '\&' before
`break_wrap', `break_with', or `break_TeX', since each is being directly
*called* (and returns a reference to some other suitable subroutine);

The form formatting algorithm
-----------------------------

   The algorithm form uses is:

     1. split the first string in the argument list
        into individual format lines and add a terminating
        newline (unless one is already present).

     2. for each format line...

     2.1. determine the number of fields and shift
          that many values off the argument list and
          into the filling list. If insufficient
          arguments are available, generate as many
          empty strings as are required.

     2.2. generate a text line by filling each field
          in the format line with the initial contents
          of the corresponding arg in the filling list
          (and remove those initial contents from the arg).

     2.3. replace any <,>, or ^ fields by an equivalent
          number of spaces. Splice out the corresponding
          args from the filling list.

     2.4. Repeat from step 2.2 until all args in the
          filling list are empty.

     3. concatenate the text lines generated in step 2

     4. repeat from step 1 until the argument list is empty

form examples
-------------

   As an example of the use of form, the following:

     $count = 1;
     $text = "A big long piece of text to be formatted exquisitely";

     print form q
     {
             ||||  <<<<<<<<<<
             ----------------
             ^^^^  ]]]]]]]]]]\|
                             =
             ]]].[[[
     
     }, $count, $text, $count+11, $text, "123 123.4\n123.456789";

   produces the following output:

     1    A big long
                     ----------------
     12     piece of|
          text to be|
           formatted|
          exquisite-|
                  ly|
                    =
                     123.0
                     123.4
                     123.456

   Picture strings and replacement values can be interleaved in the
traditional format format, but care is needed to ensure that the correct
number of substitution values are provided. For example:

     $report = form
             'Name           Rank    Serial Number',
             '====           ====    =============',
             '<<<<<<<<<<<<<  ^^^^    <<<<<<<<<<<<<',
              $name,         $rank,  $serial_number,
             ''
             'Age    Sex     Description',
             '===    ===     ===========',
             '^^^    ^^^     [[[[[[[[[[[',
              $age,  $sex,   $description;

How form consumes strings
-------------------------

   Unlike format, within form non-block fields do consume the text they
format, so the following:

     $text = "a line of text to be formatted over three lines";
     print form "<<<<<<<<<<\n  <<<<<<<<\n    <<<<<<\n",
                 $text,        $text,        $text;

   produces:

     a line of
       text to
         be fo-

   not:

     a line of
       a line
         a line

   To achieve the latter effect, convert the variable arguments to
independent literals (by double-quoted interpolation):

     $text = "a line of text to be formatted over three lines";
     print form "<<<<<<<<<<\n  <<<<<<<<\n    <<<<<<\n",
                "$text",      "$text",      "$text";

   Although values passed from variable arguments are progressively
consumed *within* form, the values of the original variables passed to form
are not altered.  Hence:

     $text = "a line of text to be formatted over three lines";
     print form "<<<<<<<<<<\n  <<<<<<<<\n    <<<<<<\n",
                 $text,        $text,        $text;
     print $text, "\n";

   will print:

     a line of
       text to
         be fo-
     a line of text to be formatted over three lines

   To cause form to consume the values of the original variables passed to
it, pass them as references. Thus:

     $text = "a line of text to be formatted over three lines";
     print form "<<<<<<<<<<\n  <<<<<<<<\n    <<<<<<\n",
                 \$text,       \$text,       \$text;
     print $text, "\n";

   will print:

     a line of
       text to
         be fo-
     rmatted over three lines

   Note that, for safety, the "non-consuming" behaviour takes precedence,
so if a variable is passed to form both by reference and by value, its
final value will be unchanged.

Numerical formatting
--------------------

   The ">>>.<<<" and "]]].[[[" field specifiers may be used to format
numeric values about a fixed decimal place marker. For example:

     print form '(]]]]].[[)', <<EONUMS;
                1
                1.0
                1.001
                1.009
                123.456
                1234567
                one two
     EONUMS

   would print:

   (    1.0 )         (    1.0 )         (    1.00)         (    1.01)
   (  123.46)         (#####.##)         (?????.??)          (?????.??)

   Fractions are rounded to the specified number of places after the
decimal, but only significant digits are shown. That's why, in the above
example, 1 and 1.0 are formatted as "1.0", whilst 1.001 is formatted as
"1.00".

   You can specify that the maximal number of decimal places always be used
by giving the configuration option 'numeric' a value that matches
/\bAllPlaces\b/i. For example:

     print form { numeric => AllPlaces },
                '(]]]]].[[)', <<'EONUMS';
                1
                1.0
     EONUMS

   would print:

   (    1.00)         (    1.00)

   Note that although decimal digits are rounded to fit the specified
width, the integral part of a number is never modified. If there are not
enough places before the decimal place to represent the number, the entire
number is replaced with hashes.

   If a non-numeric sequence is passed as data for a numeric field, it is
formatted as a series of question marks. This querulous behaviour can be
changed by giving the configuration option 'numeric' a value that matches
/\bSkipNaN\b/i in which case, any invalid numeric data is simply ignored.
For example:

     print form { numeric => 'SkipNaN' }
                '(]]]]].[[)',
                <<EONUMS;
                1
                two three
                4
     EONUMS

   would print:

   (    1.0 )         (    4.0 )

Filling block fields with lists of values
-----------------------------------------

   If an argument corresponding to a field is an array reference, then form
automatically joins the elements of the array into a single string,
separating each element with a newline character. As a result, a call like
this:

     @values = qw( 1 10 100 1000 );
     print form "(]]]].[[)", \@values;

   will print out

     (   1.00)
     (  10.00)
     ( 100.00)
     (1000.00)

   as might be expected.

   Note however that arrays must be passed by reference (so that form
knows that the entire array holds data for a single field). If the previous
example had not passed @values by reference:

     @values = qw( 1 10 100 1000 );
     print form "(]]]].[[)", @values;

   the output would have been:

     (   1.00)
     10
     100
     1000

   This is because @values would have been interpolated into form's
argument list, so only $value[0] would have been used as the data for the
initial format string. The remaining elements of @value would have been
treated as separate format strings, and printed out "verbatim".

   Note too that, because arrays must be passed using a reference, their
original contents are consumed by form, just like the contents of scalars
passed by reference.

   To avoid having an array consumed by form, pass it as an anonymous
array:

     print form "(]]]].[[)", [@values];

Headers, footers, and pages
---------------------------

   The form subroutine can also insert headers, footers, and page-feeds as
it formats. These features are controlled by the "header", "footer",
"pagefeed", "pagelen", and "pagenum" options.

   The "pagenum" option takes a scalar value or a reference to a scalar
variable and starts page numbering at that value. If a reference to a
scalar variable is specified, the value of that variable is updated as the
formatting proceeds, so that the final page number is available in it
after formatting. This can be useful for multi-part reports.

   The "pagelen" option specifies the total number of lines in a page
(including headers, footers, and page-feeds).

   If the "header" option is specified with a string value, that string is
used as the header of every page generated. If it is specified as a
reference to a subroutine, that subroutine is called at the start of every
page and its return value used as the header string. When called, the
subroutine is passed the current page number.

   Likewise, if the "footer" option is specified with a string value, that
string is used as the footer of every page generated. If it is specified
as a reference to a subroutine, that subroutine is called at the start of
every page and its return value used as the footer string. When called,
the footer subroutine is passed the current page number. If the option is
specified as a hash, it acts as described above for the "header" option.

   Both the header and footer options can also be specified as hash
references.  In this case the hash entires for keys "left", "centre" (or
"center"), and "right" specify what is to appear on the left, centre, and
right of the header/footer. The entry for the key "width" specifies how
wide the footer is to be. The  "left", "centre", and "right" values may be
literal strings, or subroutines (just as a normal header/footer
specification may be.) See the second example, below.

   The "pagefeed" option acts in exactly the same way, to produce a
pagefeed which is appended after the footer. But note that the pagefeed is
not counted as part of the page length.

   All three of these page components are recomputed at the start of each
new page, before the page contents are formatted (recomputing the header
and footer makes it possible to determine how many lines of data to format
so as to adhere to the specified page length).

   When the call to form is complete and the data has been fully formatted,
the footer subroutine is called one last time, with an extra argument of 1.
The string returned by this final call is used as the final footer.

   So for example, a 60-line per page report, starting at page 7, with
appropriate headers and footers might be set up like so:

     $page = 7;

     form { header => sub { "Page $_[0]\n\n" },
            footer => sub { return "" if $_[1];
                            "-"x50 . "\n" . form ">"x50", "...".($_[0]+1);
                          },
            pagefeed => "\n\n",
            pagelen  => 60
            pagenum  => \$page,
          },
          $template,
          @data;

   Note the recursive use of form within the "footer" option.

   Alternatively, to set up headers and footers such that the running head
is right justified in the header and the page number is centred in the
footer:

     form { header => { right => "Running head" },
            footer => { centre => sub { "Page $_[0]" } },
            pagelen  => 60
          },
          $template,
          @data;

The tag sub
-----------

   The tag subroutine may be exported from the module.  It takes two
arguments: a tag specifier and a text to be entagged. The tag specifier
indicates the indenting of the tag, and of the text. The sub generates an
end-tag (using the usual "/tag" variant), unless an explicit end-tag is
provided as the third argument.

   The tag specifier consists of the following components (in order):

An optional vertical spacer (zero or more whitespace-separated newlines)
     One or more whitespace characters up to a final mandatory newline.
     This vertical space is inserted before the tag and after the end-tag

An optional tag indent
     Zero or more whitespace characters. Both the tag and the end-tag are
     indented by this whitespace.

An optional left (opening) tag delimiter
     Zero or more non-"word" characters (not alphanumeric or '_').  If the
     opening delimiter is omitted, the character '<' is used.

A tag
     One or more "word" characters (alphanumeric or '_').

Optional tag arguments
     Any number of any characters

An optional right (closing) tag delimiter
     Zero or more non-"word" characters which balance some sequential
     portion of the opening tag delimiter. For example, if the opening
     delimiter is "<-(" then any of the following are acceptible closing
     delimiters: ")->", "->", or ">".  If the closing delimiter is
     omitted, the "inverse" of the opening delimiter is used (for example,
     ")->"),

An optional vertical spacer (zero or more newlines)
     One or more whitespace characters up to a mandatory newline. This
     vertical space is inserted before and after the complete text.

An optional text indent
     Zero or more space of tab characters. Each line of text is indented
     by this whitespace (in addition to the tag indent).

   For example:

     $text = "three lines\nof tagged\ntext";

     print tag "A HREF=#nextsection", $text;

   prints:

     <A HREF=#nextsection>three lines
     of tagged
     text</A>

   whereas:

     print tag "[-:GRIN>>>\n", $text;

   prints:

     [-:GRIN>>>:-]
     three lines
     of tagged
     text
     [-:/GRIN>>>:-]

   and:

     print tag "\n\n   <BOLD>\n\n   ", $text, "<END BOLD>";

   prints:

    

     <BOLD>

     three lines
     of tagged
     text

     <END BOLD>

    

   (with the indicated spacing fore and aft).

AUTHOR
======

   Damian Conway (damian@conway.org)

BUGS
====

   There are undoubtedly serious bugs lurking somewhere in code this funky
:-) Bug reports and other feedback are most welcome.

COPYRIGHT
=========

   Copyright (c) 1997-2000, Damian Conway. All Rights Reserved.  This
module is free software. It may be used, redistributed and/or modified
under the terms of the Perl Artistic License   (see
http://www.perl.com/perl/misc/Artistic.html)


