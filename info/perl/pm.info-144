This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Filter/Simple,  Next: Filter/Util/Call,  Prev: Filter/Handle,  Up: Module List

Simplified source filtering
***************************

NAME
====

   Filter::Simple - Simplified source filtering

SYNOPSIS
========

     # in MyFilter.pm:

     package MyFilter;

     use Filter::Simple sub { ... };

     # in user's code:

     use MyFilter;

     # this code is filtered

     no MyFilter;

     # this code is not

DESCRIPTION
===========

The Problem
-----------

   Source filtering is an immensely powerful feature of recent versions of
Perl.  It allows one to extend the language itself (e.g. the Switch
module), to simplify the language (e.g. Language::Pythonesque), or to
completely recast the language (e.g. Lingua::Romana::Perligata).
Effectively, it allows one to use the full power of Perl as its own,
recursively applied, macro language.

   The excellent Filter::Util::Call module (by Paul Marquess) provides a
usable Perl interface to source filtering, but it is often too powerful
and not nearly as simple as it could be.

   To use the module it is necessary to do the following:

  1. Download, build, and install the Filter::Util::Call module.

  2. Set up a module that does a use Filter::Util::Call.

  3. Within that module, create an import subroutine.

  4. Within the import subroutine do a call to `filter_add', passing it
     either a subroutine reference.

  5. Within the subroutine reference, call filter_read or
     `filter_read_exact' to "prime" $_ with source code data from the
     source file that will use your module. Check the status value
     returned to see if any source code was actually read in.

  6. Process the contents of $_ to change the source code in the desired
     manner.

  7. Return the status value.

  8. If the act of unimporting your module (via a no) should cause source
     code filtering to cease, create an `unimport' subroutine, and have it
     call filter_del. Make sure that the call to filter_read or
     `filter_read_exact' in step 5 will not accidentally read past the no.
     Effectively this limits source code filters to line-by-line
     operation, unless the import subroutine does some fancy
     pre-pre-parsing of the source code it's filtering.

        For example, here is a minimal source code filter in a module named
BANG.pm. It simply converts every occurrence of the sequence `BANG\s+BANG'
to the sequence `die 'BANG' if $BANG' in any piece of code following a
`use BANG;' statement (until the next `no BANG;' statement, if any):

     package BANG;
     
     use Filter::Util::Call ;

     sub import {
         filter_add( sub {
             my $caller = caller;
             my ($status, $no_seen, $data);
             while ($status = filter_read()) {
                     if (/^\s*no\s+$caller\s*;\s*$/) {
                             $no_seen=1;
                             last;
                     }
                     $data .= $_;
                     $_ = "";
             }
             $_ = $data;
             s/BANG\s+BANG/die 'BANG' if \$BANG/g
                     unless $status < 0;
             $_ .= "no $class;\n" if $no_seen;
             return 1;
         })
     }

     sub unimport {
         filter_del();
     }

     1 ;

   This level of sophistication puts filtering out of the reach of many
programmers.

A Solution
----------

   The Filter::Simple module provides a simplified interface to
Filter::Util::Call; one that is sufficient for most common cases.

   Instead of the above process, with Filter::Simple the task of setting up
a source code filter is reduced to:

  1. Set up a module that does a `use Filter::Simple sub { ... }'.

  2. Within the anonymous subroutine passed to `use Filter::Simple',
     process the contents of $_ to change the source code in the desired
     manner.

        In other words, the previous example, would become:

     package BANG;
     
     use Filter::Simple sub {
         s/BANG\s+BANG/die 'BANG' if \$BANG/g;
     };

     1 ;

How it works
------------

   The Filter::Simple module exports into the package that uses it (e.g.
package "BANG" in the above example) two automagically constructed
subroutines - import and `unimport' - which take care of all the nasty
details.

   In addition, the generated import subroutine passes its own argument
list to the filtering subroutine, so the BANG.pm filter could easily be
made parametric:

     package BANG;
     
     use Filter::Simple sub {
         my ($die_msg, $var_name) = @_;
         s/BANG\s+BANG/die '$die_msg' if \${$var_name}/g;
     };

     # and in some user code:

     use BANG "BOOM", "BAM;  # "BANG BANG" becomes: die 'BOOM' if $BAM

   The specified filtering subroutine is called every time a `use BANG' is
encountered, and passed all the source code following that call, up to
either the next `no BANG;' call or the end of the source file (whichever
occurs first). Currently, any `no BANG;' call must appear by itself on a
separate line, or it is ignored.

AUTHOR
======

   Damian Conway (damian@conway.org)

COPYRIGHT
=========

     Copyright (c) 2000, Damian Conway. All Rights Reserved.
     This module is free software. It may be used, redistributed
     and/or modified under the terms of the Perl Artistic License
         (see http://www.perl.com/perl/misc/Artistic.html)


File: pm.info,  Node: Filter/Util/Call,  Next: Filter/Util/Exec,  Prev: Filter/Simple,  Up: Module List

Perl Source Filter Utility Module
*********************************

NAME
====

   Filter::Util::Call - Perl Source Filter Utility Module

SYNOPSIS       use Filter::Util::Call ;
=======================================

DESCRIPTION
===========

   This module provides you with the framework to write *Source Filters*
in Perl.

   An alternate interface to Filter::Util::Call is now available. See
*Note Filter/Simple: Filter/Simple, for more details.

   A *Perl Source Filter* is implemented as a Perl module. The structure
of the module can take one of two broadly similar formats. To distinguish
between them, the first will be referred to as *method filter* and the
second as *closure filter*.

   Here is a skeleton for the *method filter*:

     package MyFilter ;
     
     use Filter::Util::Call ;

     sub import
     {
         my($type, @arguments) = @_ ;
         filter_add([]) ;
     }
     
     sub filter
     {
         my($self) = @_ ;
         my($status) ;
     
         $status = filter_read() ;
         $status ;
     }
     
     1 ;

   and this is the equivalent skeleton for the *closure filter*:

     package MyFilter ;
     
     use Filter::Util::Call ;

     sub import
     {
         my($type, @arguments) = @_ ;
     
         filter_add(
             sub
             {
                 my($status) ;
                 $status = filter_read() ;
                 $status ;
             } )
     }
     
     1 ;

   To make use of either of the two filter modules above, place the line
below in a Perl source file.

     use MyFilter;

   In fact, the skeleton modules shown above are fully functional *Source
Filters*, albeit fairly useless ones. All they does is filter the source
stream without modifying it at all.

   As you can see both modules have a broadly similar structure. They both
make use of the `Filter::Util::Call' module and both have an import
method. The difference between them is that the *method filter* requires a
filter method, whereas the *closure filter* gets the equivalent of a
filter method with the anonymous sub passed to *filter_add*.

   To make proper use of the *closure filter* shown above you need to have
a good understanding of the concept of a *closure*. See *Note Perlref:
(perl.info)perlref, for more details on the mechanics of *closures*.

use Filter::Util::Call
----------------------

   The following functions are exported by `Filter::Util::Call':

     filter_add()
     filter_read()
     filter_read_exact()
     filter_del()

import()
--------

   The import method is used to create an instance of the filter. It is
called indirectly by Perl when it encounters the `use MyFilter' line in a
source file (See `import', *Note Perlfunc: (perl.info)perlfunc, for more
details on import).

   It will always have at least one parameter automatically passed by Perl
- this corresponds to the name of the package. In the example above it
will be `"MyFilter"'.

   Apart from the first parameter, import can accept an optional list of
parameters. These can be used to pass parameters to the filter. For
example:

     use MyFilter qw(a b c) ;

   will result in the `@_' array having the following values:

     @_ [0] => "MyFilter"
     @_ [1] => "a"
     @_ [2] => "b"
     @_ [3] => "c"

   Before terminating, the import function must explicitly install the
filter by calling `filter_add'.

   *filter_add()*

   The function, `filter_add', actually installs the filter. It takes one
parameter which should be a reference. The kind of reference used will
dictate which of the two filter types will be used.

   If a CODE reference is used then a *closure filter* will be assumed.

   If a CODE reference is not used, a *method filter* will be assumed.  In
a *method filter*, the reference can be used to store context information.
The reference will be blessed into the package by `filter_add'.

   See the filters at the end of this documents for examples of using
context information using both *method filters* and *closure filters*.

filter() and anonymous sub
--------------------------

   Both the filter method used with a *method filter* and the anonymous
sub used with a *closure filter* is where the main processing for the
filter is done.

   The big difference between the two types of filter is that the *method
filter* uses the object passed to the method to store any context data,
whereas the *closure filter* uses the lexical variables that are
maintained by the closure.

   Note that the single parameter passed to the *method filter*, `$self',
is the same reference that was passed to `filter_add' blessed into the
filter's package. See the example filters later on for details of using
`$self'.

   Here is a list of the common features of the anonymous sub and the
`filter()' method.

$_
     Although $_ doesn't actually appear explicitly in the sample filters
     above, it is implicitly used in a number of places.

     Firstly, when either filter or the anonymous sub are called, a local
     copy of $_ will automatically be created. It will always contain the
     empty string at this point.

     Next, both filter_read and `filter_read_exact' will append any source
     data that is read to the end of $_.

     Finally, when filter or the anonymous sub are finished processing,
     they are expected to return the filtered source using $_.

     This implicit use of $_ greatly simplifies the filter.

$status
     The status value that is returned by the user's filter method or
     anonymous sub and the filter_read and `read_exact' functions take the
     same set of values, namely:

          < 0  Error
          = 0  EOF
          > 0  OK

filter_read and *filter_read_exact*
     These functions are used by the filter to obtain either a line or
     block from the next filter in the chain or the actual source file if
     there aren't any other filters.

     The function filter_read takes two forms:

          $status = filter_read() ;
          $status = filter_read($size) ;

     The first form is used to request a line, the second requests a block.

     In line mode, filter_read will append the next source line to the end
     of the $_ scalar.

     In block mode, filter_read will append a block of data which is <=
     $size to the end of the $_ scalar. It is important to emphasise the
     that filter_read will not necessarily read a block which is
     *precisely* $size bytes.

     If you need to be able to read a block which has an exact size, you
     can use the function `filter_read_exact'. It works identically to
     filter_read in block mode, except it will try to read a block which
     is exactly $size bytes in length. The only circumstances when it will
     not return a block which is $size bytes long is on EOF or error.

     It is *very* important to check the value of $status after every call
     to filter_read or `filter_read_exact'.

filter_del
     The function, filter_del, is used to disable the current filter. It
     does not affect the running of the filter. All it does is tell Perl
     not to call filter any more.

     See `Example 4: Using filter_del' in this node for details.

EXAMPLES
========

   Here are a few examples which illustrate the key concepts - as such
most of them are of little practical use.

   The examples sub-directory has copies of all these filters implemented
both as *method filters* and as *closure filters*.

Example 1: A simple filter.
---------------------------

   Below is a *method filter* which is hard-wired to replace all
occurrences of the string `"Joe"' to `"Jim"'. Not particularly Useful, but
it is the first example and I wanted to keep it simple.

     package Joe2Jim ;
     
     use Filter::Util::Call ;

     sub import
     {
         my($type) = @_ ;
     
         filter_add(bless []) ;
     }
     
     sub filter
     {
         my($self) = @_ ;
         my($status) ;
     
         s/Joe/Jim/g
             if ($status = filter_read()) > 0 ;
         $status ;
     }
     
     1 ;

   Here is an example of using the filter:

     use Joe2Jim ;
     print "Where is Joe?\n" ;

   And this is what the script above will print:

     Where is Jim?

Example 2: Using the context
----------------------------

   The previous example was not particularly useful. To make it more
general purpose we will make use of the context data and allow any
arbitrary from and to strings to be used. This time we will use a *closure
filter*. To reflect its enhanced role, the filter is called `Subst'.

     package Subst ;
     
     use Filter::Util::Call ;
     use Carp ;
     
     sub import
     {
         croak("usage: use Subst qw(from to)")
             unless @_ == 3 ;
         my ($self, $from, $to) = @_ ;
         filter_add(
             sub
             {
                 my ($status) ;
                 s/$from/$to/
                     if ($status = filter_read()) > 0 ;
                 $status ;
             })
     }
     1 ;

   and is used like this:

     use Subst qw(Joe Jim) ;
     print "Where is Joe?\n" ;

Example 3: Using the context within the filter
----------------------------------------------

   Here is a filter which a variation of the `Joe2Jim' filter. As well as
substituting all occurrences of `"Joe"' to `"Jim"' it keeps a count of the
number of substitutions made in the context object.

   Once EOF is detected ($status is zero) the filter will insert an extra
line into the source stream. When this extra line is executed it will
print a count of the number of substitutions actually made.  Note that
$status is set to 1 in this case.

     package Count ;
     
     use Filter::Util::Call ;
     
     sub filter
     {
         my ($self) = @_ ;
         my ($status) ;
     
         if (($status = filter_read()) > 0 ) {
             s/Joe/Jim/g ;
     	    ++ $$self ;
         }
     	elsif ($$self >= 0) { # EOF
             $_ = "print q[Made ${$self} substitutions\n]" ;
             $status = 1 ;
     	    $$self = -1 ;
         }

     $status ;
         }
     
         sub import
         {
     my ($self) = @_ ;
     my ($count) = 0 ;
     filter_add(\$count) ;
         }
     
         1 ;

   Here is a script which uses it:

     use Count ;
     print "Hello Joe\n" ;
     print "Where is Joe\n" ;

   Outputs:

     Hello Jim
     Where is Jim
     Made 2 substitutions

Example 4: Using filter_del
---------------------------

   Another variation on a theme. This time we will modify the `Subst'
filter to allow a starting and stopping pattern to be specified as well as
the from and to patterns. If you know the *vi* editor, it is the
equivalent of this command:

     :/start/,/stop/s/from/to/

   When used as a filter we want to invoke it like this:

     use NewSubst qw(start stop from to) ;

   Here is the module.

     package NewSubst ;
     
     use Filter::Util::Call ;
     use Carp ;
     
     sub import
     {
         my ($self, $start, $stop, $from, $to) = @_ ;
         my ($found) = 0 ;
         croak("usage: use Subst qw(start stop from to)")
             unless @_ == 5 ;
     
         filter_add(
             sub
             {
                 my ($status) ;
     
                 if (($status = filter_read()) > 0) {
     
                     $found = 1
                         if $found == 0 and /$start/ ;
     
                     if ($found) {
                         s/$from/$to/ ;
                         filter_del() if /$stop/ ;
                     }
     
                 }
                 $status ;
             } )
     
     }
     
     1 ;

Filter::Simple
==============

   If you intend using the Filter::Call functionality, I would strongly
recommend that you check out Damian Conway's excellent Filter::Simple
module. This module provides a much cleaner interface than
Filter::Util::Call. Although it doesn't allow the fine control that
Filter::Util::Call does, it should be adequate for the majority of
applications. It's available at

     http://www.cpan.org/modules/by-author/Damian_Conway/Filter-Simple.tar.gz
     http://www.csse.monash.edu.au/~damian/CPAN/Filter-Simple.tar.gz

AUTHOR
======

   Paul Marquess

DATE
====

   26th January 1996


File: pm.info,  Node: Filter/Util/Exec,  Next: Filter/cpp,  Prev: Filter/Util/Call,  Up: Module List

exec source filter
******************

NAME
====

   Filter::Util::Exec - exec source filter

SYNOPSIS       use Filter::Util::Exec;
======================================

DESCRIPTION
===========

   This module is provides the interface to allow the creation of *Source
Filters* which use a Unix coprocess.

   See *Note Filter/exec: Filter/exec,, *Note Filter/cpp: Filter/cpp, and
*Note Filter/sh: Filter/sh, for examples of the use of this module.

AUTHOR
======

   Paul Marquess

DATE
====

   11th December 1995.


File: pm.info,  Node: Filter/cpp,  Next: Filter/decrypt,  Prev: Filter/Util/Exec,  Up: Module List

cpp source filter
*****************

NAME
====

   Filter::cpp - cpp source filter

SYNOPSIS
========

     use Filter::cpp ;

DESCRIPTION
===========

   This source filter pipes the current source file through the C
pre-processor (cpp) if it is available.

   As with all source filters its scope is limited to the current source
file only. Every file you want to be processed by the filter must have a

     use Filter::cpp ;

   near the top.

   Here is an example script which uses the filter:

     use Filter::cpp ;

     #define FRED 1
     $a = 2 + FRED ;
     print "a = $a\n" ;
     #ifdef FRED
     print "Hello FRED\n" ;
     #else
     print "Where is FRED\n" ;
     #endif

   And here is what it will output:

     a = 3
     Hello FRED

   This example below, provided by Michael G Schwern, shows a clever way
to get Perl to use a C pre-processor macro when the Filter::cpp module is
available, or to use a Perl sub when it is not.

     # use Filter::cpp if we can.
     BEGIN { eval 'use Filter::cpp' }

     sub PRINT {
         my($string) = shift;

     #define PRINT($string) \
         (print $string."\n")
     }
     
     PRINT("Mu");

   Look at Michael's Tie::VecArray module for a practical use.

AUTHOR
======

   Paul Marquess

DATE
====

   11th December 1995.


File: pm.info,  Node: Filter/decrypt,  Next: Filter/exec,  Prev: Filter/cpp,  Up: Module List

template for a decrypt source filter
************************************

NAME
====

   Filter::decrypt - template for a decrypt source filter

SYNOPSIS
========

     use Filter::decrypt ;

DESCRIPTION
===========

   This is a sample decrypting source filter.

   Although this is a fully functional source filter and it does implement
a *very* simple decrypt algorithm, it is not intended to be used as it is
supplied. Consider it to be a template which you can combine with a proper
decryption algorithm to develop your own decryption filter.

WARNING
=======

   It is important to note that a decryption filter can never provide
complete security against attack. At some point the parser within Perl
needs to be able to scan the original decrypted source. That means that at
some stage fragments of the source will exist in a memory buffer.

   Also, with the introduction of the Perl Compiler backend modules, and
the B::Deparse module in particular, using a Source Filter to hide source
code is becoming an increasingly futile exercise.

   The best you can hope to achieve by decrypting your Perl source using a
source filter is to make it unavailable to the casual user.

   Given that proviso, there are a number of things you can do to make
life more difficult for the prospective cracker.

  1. Strip the Perl binary to remove all symbols.

  2. Build the decrypt extension using static linking. If the extension is
     provided as a dynamic module, there is nothing to stop someone from
     linking it at run time with a modified Perl binary.

  3. Do not build Perl with `-DDEBUGGING'. If you do then your source can
     be retrieved with the `-Dp' command line option.

     The sample filter contains logic to detect the DEBUGGING option.

  4. Do not build Perl with C debugging support enabled.

  5. Do not implement the decryption filter as a sub-process (like the cpp
     source filter). It is possible to peek into the pipe that connects to
     the sub-process.

  6. Check that the Perl Compiler isn't being used.

     There is code in the BOOT: section of decrypt.xs that shows how to
     detect the presence of the Compiler. Make sure you include it in your
     module.

     Assuming you haven't taken any steps to spot when the compiler is in
     use and you have an encrypted Perl script called "myscript.pl", you
     can get access the source code inside it using the perl Compiler
     backend, like this

          perl -MO=Deparse myscript.pl

     Note that even if you have included the BOOT: test, it is still
     possible to use the Deparse module to get the source code for
     individual subroutines.

  7. Do not use the decrypt filter as-is. The algorithm used in this filter
     has been purposefully left simple.

        If you feel that the source filtering mechanism is not secure
enough you could try using the unexec/undump method. See the Perl FAQ for
further details.

AUTHOR
======

   Paul Marquess

DATE
====

   19th December 1995


File: pm.info,  Node: Filter/exec,  Next: Filter/sh,  Prev: Filter/decrypt,  Up: Module List

exec source filter
******************

NAME
====

   Filter::exec - exec source filter

SYNOPSIS
========

     use Filter::exec qw(command parameters) ;

DESCRIPTION
===========

   This filter pipes the current source file through the program which
corresponds to the command parameter.

   As with all source filters its scope is limited to the current source
file only. Every file you want to be processed by the filter must have a

     use Filter::exec qw(command ) ;

   near the top.

   Here is an example script which uses the filter:

     use Filter::exec qw(tr XYZ PQR) ;
     $a = 1 ;
     print "XYZ a = $a\n" ;

   And here is what it will output:

     PQR = 1

WARNING
=======

   You should be *very* careful when using this filter. Because of the way
the filter is implemented it is possible to end up with deadlock.

   Be especially careful when stacking multiple instances of the filter in
a single source file.

AUTHOR
======

   Paul Marquess

DATE
====

   11th December 1995.


File: pm.info,  Node: Filter/sh,  Next: Filter/tee,  Prev: Filter/exec,  Up: Module List

sh source filter
****************

NAME
====

   Filter::sh - sh source filter

SYNOPSIS
========

     use Filter::sh 'command' ;

DESCRIPTION
===========

   This filter pipes the current source file through the program which
corresponds to the command parameter using the Bourne shell.

   As with all source filters its scope is limited to the current source
file only. Every file you want to be processed by the filter must have a

     use Filter::sh 'command' ;

   near the top.

   Here is an example script which uses the filter:

     use Filter::sh 'tr XYZ PQR' ;
     $a = 1 ;
     print "XYZ a = $a\n" ;

   And here is what it will output:

     PQR = 1

WARNING
=======

   You should be *very* careful when using this filter. Because of the way
the filter is implemented it is possible to end up with deadlock.

   Be especially careful when stacking multiple instances of the filter in
a single source file.

AUTHOR
======

   Paul Marquess

DATE
====

   11th December 1995.


File: pm.info,  Node: Filter/tee,  Next: Finance/Bank/Sporo,  Prev: Filter/sh,  Up: Module List

tee source filter
*****************

NAME
====

   Filter::tee - tee source filter

SYNOPSIS
========

     use Filter::tee 'filename' ;
     use Filter::tee '>filename' ;
     use Filter::tee '>>filename' ;

DESCRIPTION
===========

   This filter copies all text from the line after the use in the current
source file to the file specified by the parameter filename.

   By default and when the filename is prefixed with a '>' the output file
will be emptied first if it already exists.

   If the output filename is prefixed with '>>' it will be opened for
appending.

   This filter is useful as a debugging aid when developing other source
filters.

AUTHOR
======

   Paul Marquess

DATE
====

   20th June 1995.


File: pm.info,  Node: Finance/Bank/Sporo,  Next: Finance/Bank/TB,  Prev: Filter/tee,  Up: Module List

Perl extension for *SporoPay* of Slovenska Sporitelna.
******************************************************

NAME
====

     Finance::Bank::Sporo - Perl extension for B<SporoPay> of Slovenska Sporitelna.

VERSION
=======

     0.16

SYNOPSIS
========

     use Finance::Bank::Sporo;

     $sporo_obj = Bank::Sporo->new($prenumber,$number);

     $sporo_obj->configure(
     	      amt	=> $amt,
     	      vs	=> $vs,
     	      ss	=> $ss,
     	      rurl	=> $rurl,
     	      param	=> $param,
     );

     print $sporo_obj->pay_form();

DESCRIPTION
===========

     Module for generating pay forms and links for B<SporoPay> of Slovenska
     Sporitelna (http://www.slsp.sk/).

USE
===

Functions ( or Methods ? )
--------------------------

new
          $sporo_obj  = Finance::Bank::Sporo->new($prenumber,$number);

     This creates a new Finance::Bank::Sporo object using $prenumber as a
     "Predcisle uctu" and $number as a "Cislo uctu"

configure
          $sporo_obj->configure(
                amt	=> $amt,
                vs	=> $vs,
                ss	=> $ss,
                rurl	=> $rurl,
                param	=> $param,
                        image_src => '/PICS/sporopay_logo.gif',
                  );

     Set correct values to object.  Possible parameters is:        amt =>
     Amount         vs => Variable Symbol         ss => Specific Symbol
       rurl => Redirect URL  image_src => Path to image ( relative to
     DocumentRoot )      param => any parameter

     Possible but default correct parameter is:

          action_url => SporoPayPay action URL
          default:
            https://ib.slsp.sk/epayment/epayment/epayment.xml

          image_src => Path to image ( relative to DocumentRoot )
          default:
            /PICS/sporopay_logo.gif


pay_form
          print $sporo_obj->pay_form();

          Return HTML FORM.

generic_pay_form
          print $sporo_obj->generic_pay_form($type);

          Return HTML FORM for payment with submit button.

pay_link
          print $sporo_obj->pay_link();

          Return URL for payment.

EXAMPLES
========

     Look at B<SYNOPSIS>, t/*, examples/* and use the source.
     ( lookin for a volunteer for writing documentation and man pages)

AUTHOR INFORMATION
==================

     Copyright 2000 Jan ' Kozo ' Vajda, Jan.Vajda@alert.sk. All rights
     reserved.  It may be used and modified freely, but I do request that this
     copyright notice remain attached to the file.  You may modify this module as
     you wish, but if you redistribute a modified version, please attach a note
     listing the modifications you have made.

   Address bug reports and comments to: Jan.Vajda@alert.sk

CREDITS
=======

   Thanks very much to:

my wife Erika & kozliatko
     for patience and love

SEE ALSO
========

     perl(1),Finance::Bank::TB(1).


File: pm.info,  Node: Finance/Bank/TB,  Next: Finance/Currency/Convert,  Prev: Finance/Bank/Sporo,  Up: Module List

Perl extension for *TatraPay* and *CardPay* of Tatrabanka and *EliotPay* of .eliot.
***********************************************************************************

NAME
====

   Finance::Bank::TB - Perl extension for *TatraPay* and *CardPay* of
Tatrabanka and *EliotPay* of .eliot.

VERSION
=======

     0.23

SYNOPSIS
========

     use Finance::Bank::TB;

     $tb_obj = Finance::Bank::TB->new($mid,$key);

     $tb_obj->configure(
     	      cs	=> $cs,
     	      vs	=> $vs,
     	      amt	=> $amt,
     	      rurl	=> $rurl,
     	      image_src => '/PICS/tatrapay_logo.gif',
     );

     my $send_sign = $tb_obj->get_send_sign();
     my $recv_sign = $tb_obj->get_recv_sign();
     my $new_cs = $tb_obj->cs($cs);
     
     or

     use Finance::Bank::TB;

     $tb_obj = Finance::Bank::TB->new($mid,$key);

     $tb_obj->configure(
     	      cs	=> $cs,
     	      vs	=> $vs,
     	      amt	=> $amt,
     	      rurl	=> $rurl,
     	      desc	=> $description,
     	      rsms	=> $mobilephonenumber,
     	      rem	=> $remote_mail,
     	      image_src => '/PICS/tatrapay_logo.gif',
     );

     print $tb_obj->pay_form();

DESCRIPTION
===========

   Module for generating signatures and pay forms for *TatraPay* and
*CardPay* of Tatra Banka ( http://www.tatrabanka.sk/ ) and for *EliotPay*
of .eliot.  ( http://www.eliot.sk/ )

   The current version of Finance::Bank::TB is available at

     http://rodney.alert.sk/perl/

USE
===

Functions ( or Methods ? )
--------------------------

new
          $tb_obj  = Finance::Bank::TB->new($mid,$key);

     This creates a new Finance::Bank::TB object using $mid as a MID (
     MerchantID ) and $key as a DES PassPhrase.

configure
          $tb_obj->configure(
          	cs        => $cs,
          	vs        => $vs,
          	amt       => $amt,
          	rurl      => $rurl,
          	image_src => '/PICS/tatrapay_logo.gif',
          );

          Set correct values to object.
          Possible parameters is:
                  cs => Constant Symbol
                  vs => Variable Symbol
                 amt => Amount
                rurl => Redirect URL
           image_src => Path to image ( relative to DocumentRoot )
                desc => Description
                rsms => Mobile Number for SMS notification
                 rem => E-mail address for email notification
                 ipc => IP address of Client
                name => Name of client
                 res => Result Code of transaction
                  ac => Approval Code
          
          Possible but default correct parameters is:
            tatra_action_url => TatraPay action URL
            default:
              https://moja.tatrabanka.sk/cgi-bin/ibanking/start/e-commerce.jsp

          eliot_action_url => EliotPay action URL
          default:
            https://moja.tatrabanka.sk/cgi-bin/ibanking/start/eliotpay.jsp

          action_url => default action URL
          default:
            https://moja.tatrabanka.sk/cgi-bin/ibanking/start/e-commerce.jsp

          image_src => Path to image ( relative to DocumentRoot )
          default:
            /PICS/tatrapay_logo.gif


calculate_signatures
          $tb_obj->calculate_signatures();
          print $tb_obj->send_sign;
          print $tb_obj->recv_sign;
          print $tb_obj->card_sign;

     Calculate Send, Card and Receive Signature from parameters of  object
     and set send_sign, card_sign and recv_sign.

get_send_sign
          print $tb_obj->get_send_sign();
          
          Calculate and return send signature.  Set $tb_obj->send_sign.

get_card_sign
          print $tb_obj->get_card_sign();
          
          Calculate and return CardPay signature. Set $tb_obj->card_sign.

get_recv_sign
          print $tb_obj->get_send_sign();
          
          Calculate and return receive signature. Set $tb_obj->recv_sign.

pay_form
          print $tb_obj->pay_form($type);

     Type is "tatra" or "eliot" or null. Default is null (action_url).
     Recomended is null.

     Return HTML FORM.

card_form
          print $tb_obj->card_form();

     Return CardPay HTML FORM.

pay_link
          print $tb_obj->pay_link($type);

     Type is "tatra" or "eliot" or null. Default is null (action_url).
     Recomended is null.

     Return URL for payment.

card_link
          print $tb_obj->card_link();

     Return CardPay URL for payment.

generic_pay_form
          print $tb_obj->generic_pay_form($type);

     Type is "tatra" or "eliot" or null. Default is null (action_url).
     Recomended is null.

     Return HTML FORM for payment with submit button.

generic_cardpay_form
          print $tb_obj->generic_cardpay_form();

     Return HTML FORM for CardPay with submit button.

EXAMPLES
========

   Look at SYNOPSIS, *t/**, *examples/** and use the source.  (lookin for
a volunteer for writing documentation and man pages)

AUTHOR INFORMATION
==================

   Copyright 2000 Jan ' Kozo ' Vajda, Jan.Vajda@alert.sk. All rights
reserved.  This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, but I do request that this
copyright notice remain attached to the file. You may modify this module
as you wish, but if you redistribute a modified version, please attach a
note listing the modifications you have made.

   Address bug reports and comments to: Jan.Vajda@alert.sk

CREDITS
=======

   Thanks very much to:

my wife Erika & kozliatko
     for patience and love

Gildir ( gildir@alert.sk )
     for debugging

M. Sulik from TatraBanka
     for documentation, C examples and mail helpdesk.

SEE ALSO
========

     perl(1),Digest::SHA1(1),Crypt::DES(1).


File: pm.info,  Node: Finance/Currency/Convert,  Next: Finance/HSHrates,  Prev: Finance/Bank/TB,  Up: Module List

Convert currencies and fetch their exchange rates (with Finance::Quote)
***********************************************************************

NAME
====

   Finance::Currency::Convert - Convert currencies and fetch their
exchange rates (with Finance::Quote)

SYNOPSIS
========

     use Finance::Currency::Convert;
     my $converter = new Finance::Currency::Convert;

     $amount_euro = $converter->convert(100, "DEM", "EUR");
     $amount_euro = $converter->convertToEuro(100, "DEM");
     $amount_dem = $converter->convertFromEuro(100, "DEM");

     $converter->updateRates("EUR", "DEM", "USD");

     $converter->setRatesFile(".rates");
     $converter->writeRatesFile();

DESCRIPTION
===========

   This module converts currencies. It has built in the fixed exchange
rates for all Euro currencies (as of November 2000). If you wish to use
other / more currencies, you can automatically fetch their exchange rates
from the internet and (optionally) store them in a file for later
reference.

   Use this module if you have large volumes of currency data to convert.
Using the exchange rates from memory makes it a lot faster than using
Finance::Quote directly and will save you the duty of storing the exchange
rates yourself.

CURRENCY SYMBOLS
----------------

   Finance::Currency::Convert uses the three character ISO currency codes
used by  Finance::Quote.  Here is a list of currency codes.

   Currencies with built-in rates (complete):

     EUR		Euro
     ATS		Austrian Schilling
     BEF		Belgiam Franc
     DEM		German Mark
     ESP		Spanish Peseta
     FIM		Finnish Mark
     FRF		French Franc
     GRD		Greek Drachma
     IEP		Irish Punt
     ITL		Italian Lira
     LUF		Luxembourg Franc
     NLG		Dutch Guilder
     PTE		Portuguese Escudo

   Other currencies (incomplete):

     AUD		Australian Dollar
     USD		US Dollar

AVAILABLE METHODS
=================

NEW
---

     my $converter = new Finance::Currency::Convert;

   The newly created conversion object will by default only know how to
convert Euro currencies. To "teach" it more currencies use updateRates.

CONVERT
-------

     $amount_euro = $converter->convert(100, "DEM", "EUR");

   This will convert 100 German Marks into the equivalent amount Euro.

CONVERTTOEURO
-------------

     $amount_euro = $converter->convertToEuro(100, "DEM");

   This will convert 100 German Marks into the equivalent amount Euro.
This function is simply shorthand for calling convert directly with "EUR"
als the second (target) currency.

CONVERTFROMEURO
---------------

     $amount_dem = $converter->convertFromEuro(100, "DEM");

   This will convert 100 Eurointo the equivalent amount German Marks.
This function is simply shorthand for calling convert directly with "EUR"
als the first (source) currency.

UPDATERATES
-----------

     $converter->updateRates("USD");
     $converter->updateRates("EUR", "DEM", "USD");

   This will fetch the exchange rates for one or more currencies using
Finance::Quote and update the exchange rates in memory.  This method will
fetach all combinations of exchange rates between the named currencies and
the ones already in memory.  This may result in a large number of requests
to Finance::Quote.  To avoid network overhead you can store the retrieved
rates with setRatesFile() / writeRatesFile() once you have retrieved them
and load them again with setRatesFile().

SETUSERAGENT
------------

     $converter->setUserAgent("MyCurrencyAgent 1.0");

   Set the user agent string to be used by Finance::Quote.

SETRATE
-------

     $converter->setRate("EUR", "USD", 999);

   Set one exchange rate. Used internally by updateRates, but may be of
use if you have to add a rate manually.

SETRATESFILE
------------

     $converter->setRatesFile(".rates");

   Name the file where exchange rates are stored. If it already exists it
will be read into memory.

READRATESFILE
-------------

     $converter->readRatesFile();

   Usually called internally by setRatesFile, but may also be called
directly to revert to the rates stored in the file.  Calling
readRatesFile() will erase all existing exchange rates in memory.

WRITERATESFILE
--------------

     $converter->writeRatesFile();

   Call this function to save table with exchange rates from memory to the
file named by setRatesFile() eg. after fetching new rates with updateRates.

AUTHOR
======

     Jan Willamowius <jan@willamowius.de>, http://www.willamowius.de

SEE ALSO
========

   Finance::Quote

   This module is only needed for fetching exchange rates.  There is no
need to install it when only Euro currencies are used.


File: pm.info,  Node: Finance/HSHrates,  Next: Finance/Huntington/Statement,  Prev: Finance/Currency/Convert,  Up: Module List

Get current US Mortgage Rates from HSH
**************************************

NAME
====

   Finance::HSHrates - Get current US Mortgage Rates from HSH

SYNOPSIS
========

     use Finance::HSHrates;
     @rates = getrates;

DESCRIPTION
===========

   This module gets the current US Mortgage rages from HSH.  The *getrates*
function will return an array with the following elements:

     0 30 Year Fixed - Rate
     1 30 Year Fixed - Points
     2 15 Year Fixed - Rate
     3 15 Year Fixed - Points
     4 1 Year Adjustable - Rate
     5 1 Year Adjustable - Points

COPYRIGHT
=========

   Copyright 2000, Dj Padzensky

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

   The information that you obtain with this library may be copyrighted by
HSH Associates, Financial Publishers, and is governed by their usage
license.

AUTHOR
======

   Dj Padzensky (`djpadz@padz.net'), PadzNet, Inc.

   The Finance::HSHrates home page can be found at
http://www.padz.net/~djpadz/HSHrates/


File: pm.info,  Node: Finance/Huntington/Statement,  Next: Finance/MoneyNetSymbolLookup,  Prev: Finance/HSHrates,  Up: Module List

Perl extension for parsing html bank statements from the Huntington Bank website.
*********************************************************************************

NAME
====

   Finance::Huntington::Statement - Perl extension for parsing html bank
statements from the Huntington Bank website.

SYNOPSIS
========

     use Finance::Huntington::Statement;
     $obj = new Finance::Huntington::Statement;
     $obj->parse_file (<open file handle | path to file>);

     print $obj->{account_name};
     print $obj->{account_number};
     print $obj->{last_updated}; (a time value)
     print $obj->{current_statement_balance};
     print $obj->{available_statement_balance};
     print $obj->{current_register_balance};
     @atms = %{$obj->{atms}};
     foreach (@atms) {
             print $_->{number};
             print $_->{date};
             print $_->{payee};
             print $_->{category};
             print $_->{amount};
     }
     # The following arrays may be accessed in the same way as 'atms':
     # checks
     # debit_cards
     # epays
     # mdcs
     @deposits = %{$obj->{deposits}};
     foreach (@deposits) {
             print $_->{number};
             print $_->{date};
             print $_->{payor}; # NOTE: only diff from others
             print $_->{category};
             print $_->{amount};
     }

DESCRIPTION
===========

   This version of Statement will parse Huntington online bank statements
as of 09/2000.  If the statement format changes, this gets broken.  Look
for later versions of this module for updates to correspond with current
statements.

   After parsing supplied html statement, $obj will hold a data structure
representing the information extracted from the page.

EXPORT
------

   None by default.

AUTHOR
======

   Chad Lavy, chad@chadlavy.com

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Finance/MoneyNetSymbolLookup,  Next: Finance/Options/Calc,  Prev: Finance/Huntington/Statement,  Up: Module List

Look up a stock symbol from MoneyNet
************************************

NAME
====

   Finance::MoneyNetSymbolLookup - Look up a stock symbol from MoneyNet

SYNOPSIS
========

     use Finance::MoneyNetSymbolLookup;
     @symbols = symbollookup $searchstring; # Look up stock symbols

DESCRIPTION
===========

   This module looks up stock symbols from MoneyNet.  The *symbollookup*
function will return an array of lists, each containing the following
items:

     0 Symbol
     1 Company name
     2 Security type (typically B<STOCK> or B<MUTUAL FUND>)

EXAMPLE
=======

     use Finance::MoneyNetSymbolLookup;
     @foo = symbollookup("apple");
     foreach (@foo) {
       print "Symbol: ${$_}[0]; Company: ${$_}[1]; Type: ${$_}[2]\n";
     }

COPYRIGHT
=========

   Copyright 1998, Dj Padzensky

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

   The information that you obtain with this library may be copyrighted by
Reuters, Inc., and is governed by their usage license.  See
http://www.moneynet.com/home/MONEYNET/info/moneynetcopyright.asp for more
information.

AUTHOR
======

   Dj Padzensky (`djpadz@padz.net'), PadzNet, Inc.

   The Finance::MoneyNetSymbolLookup home page can be found at
http://www.padz.net/~djpadz/MoneyNetSymbolLookup/


File: pm.info,  Node: Finance/Options/Calc,  Next: Finance/Quote,  Prev: Finance/MoneyNetSymbolLookup,  Up: Module List

Option analysis based on different option pricing models.
*********************************************************

NAME
====

   `Finance::Options::Calc' - Option analysis based on different option
pricing models.

SYNOPSIS
========

     use Finance::Options::Calc;
     
     print b_s_call(90, 80, 20, 30, 4.5);
     print b_s_put (90, 80, 20, 30, 4.5);
     print call_delta(90, 80, 20, 30, 4.5);
     print put_delta(90, 80, 20, 30, 4.5);
     print call_theta(90, 80, 20, 30, 4.5);
     print put_theta(90, 80, 20, 30, 4.5);
     print gamma(90, 80, 20, 30, 4.5);
     print vega(90, 80, 20, 30, 4.5);
     print call_rho(90, 80, 20, 30, 4.5);
     print put_rho(90, 80, 20, 30, 4.5);

DESCRIPTION
===========

   b_s_call() subroutines returns theorical value of the call option based
on Black_Scholes model. The arguments are current stock price, strike
price, time to expiration (calender days, note this module does NOT use
business days), volatility(%), annual interest rate(%) in order.

   b_s_put() subroutines returns theorical value of the put option based on
Black_Scholes model. The arguments are current stock price, strike price,
time to expiration (calender days, note this module does NOT use business
days), volatility(%), annual interest rate(%) in order.

   call_delta() returns call delta.

   put_delta() returns put delta.

   Other methods are similar.

TODO
====

   more calculation models will be included.

AUTHOR
======

   Chicheng Zhang

   chichengzhang@hotmail.com


File: pm.info,  Node: Finance/Quote,  Next: Finance/Quote/ASX,  Prev: Finance/Options/Calc,  Up: Module List

Get stock and mutual fund quotes from various exchanges
*******************************************************

NAME
====

   Finance::Quote - Get stock and mutual fund quotes from various exchanges

SYNOPSIS
========

     use Finance::Quote;
     $q = Finance::Quote->new;

     $q->timeout(60);

     $conversion_rate = $q->currency("AUD","USD");
     $q->set_currency("EUR");  # Return all info in Euros.

     $q->require_labels(qw/price date high low volume/);

     $q->failover(1);	# Set failover support (on by default).

     %quotes  = $q->fetch("nasdaq",@stocks);
     $hashref = $q->fetch("nyse",@stocks);

DESCRIPTION
===========

   This module gets stock quotes from various internet sources, including
Yahoo! Finance, Fidelity Investments, and the Australian Stock Exchange.
There are two methods of using this module - a functional interface that
is depreciated, and an object-orientated method that provides greater
flexibility and stability.

   With the exception of straight currency exchange rates, all information
is returned as a two-dimensional hash (or a reference to such a hash, if
called in a scalar context).  For example:

     %info = $q->fetch("australia","CML");
     print "The price of CML is ".$info{"CML","price"};

   The first part of the hash (eg, "CML") is referred to as the stock.
The second part (in this case, "price") is referred to as the label.

LABELS
------

   When information about a stock is returned, the following standard
labels may be used.  Some custom-written modules may use labels not
mentioned here.  If you wish to be certain that you obtain a certain set
of labels for a given stock, you can specify that using require_labels().

     name         Company or Mutual Fund Name
     last         Last Price
     high	 Highest trade today
     low		 Lowest trade today
     date         Last Trade Date  (MM/DD/YY format)
     time         Last Trade Time
     net          Net Change
     p_change     Percent Change from previous day's close
     volume       Volume
     avg_vol      Average Daily Vol
     bid          Bid
     ask          Ask
     close        Previous Close
     open         Today's Open
     day_range    Day's Range
     year_range   52-Week Range
     eps          Earnings per Share
     pe           P/E Ratio
     div_date     Dividend Pay Date
     div          Dividend per Share
     div_yield    Dividend Yield
     cap          Market Capitalization
     ex_div	 Ex-Dividend Date.
     nav          Net Asset Value
     yield        Yield (usually 30 day avg)
     exchange	 The exchange the information was obtained from.
     success	 Did the stock successfully return information? (true/false)
     errormsg	 If success is false, this field may contain the reason why.
     method	 The module (as could be passed to fetch) which found
     		 this information.

   If all stock lookups fail (possibly because of a failed connection) then
the empty list may be returned, or undef in a scalar context.

AVAILABLE METHODS
=================

NEW
---

     my $q = Finance::Quote->new;
     my $q = Finance::Quote->new("ASX");
     my $q = Finance::Quote->new("-defaults", "CustomModule");

   With no arguents, this creates a new Finance::Quote object with the
default methods.  If the environment variable FQ_LOAD_QUOTELETS is set,
then the contents of FQ_LOAD_QUOTELETS (split on whitespace) will be used
as the argument list.  This allows users to load their own custom modules
without having to change existing code.  If you do not want users to be
able to load their own modules at run-time, pass an explicit argumetn to
->new() (usually "-defaults").

   When new() is passed one or more arguments, an object is created with
only the specified modules loaded.  If the first argument is "-defaults",
then the default modules will be loaded first, followed by any other
specified modules.

   Note that the FQ_LOAD_QUOTELETS environment variable must begin with
"-defaults" if you wish the default modules to be loaded.

   Any modules specified will automatically be looked for in the
Finance::Quote:: module-space.  Hence, Finance::Quote->new("ASX") will
load the module Finance::Quote::ASX.

   Please read the Finance::Quote hacker's guide for information on how to
create new modules for Finance::Quote.

FETCH
-----

     my %stocks  = $q->fetch("usa","IBM","MSFT","LNUX");
     my $hashref = $q->fetch("usa","IBM","MSFT","LNUX");

   Fetch takes an exchange as its first argument.  The second and remaining
arguments are treated as stock-names.  In the standard Finance::Quote
distribution, the following exchanges are recognised:

     australia		Australan Stock Exchange
     dwsfunds		Deutsche Bank Gruppe funds
     fidelity		Fidelity Investments
     tiaacref		TIAA-CREF
     troweprice		T. Rowe Price
     europe		European Markets
     canada		Canadian Markets
     usa			USA Markets
     nyse		New York Stock Exchange
     nasdaq		NASDAQ
     uk_unit_trusts	UK Unit Trusts
     vanguard		Vanguard Investments
     vwd			Vereinigte Wirtschaftsdienste GmbH

   When called in an array context, a hash is returned.  In a scalar
context, a reference to a hash will be returned.  The structure of this
hash is described earlier in this document.

   The fetch method automatically arranges for failover support and
currency conversion if requested.

   If you wish to fetch information from only one particular source, then
consult the documentation of that sub-module for further information.

CURRENCY
--------

     $conversion_rate = $q->currency("USD","AUD");

   The currency method takes two arguments, and returns a conversion rate
that can be used to convert from the first currency into the second.  In
the example above, we've requested the factor that would convert US
dollars into Australian dollars.

   The currency method will return a false value if a given currency
conversion cannot be fetched.

   At the moment, currency rates are fetched from Yahoo!, and the
information returned is governed by Yahoo!'s terms and conditions.  See
Finance::Quote::Yahoo for more information.

SET_CURRENCY
------------

     $q->set_currency("FRF");	# Get results in French Francs.

   The set_currency method can be used to request that all information be
returned in the specified currency.  Note that this increases the chance
stock-lookup failure, as remote requests must be made to fetch both the
stock information and the currency rates.  In order to improve reliability
and speed performance, currency conversion rates are cached and are
assumed not to change for the duration of the Finance::Quote object.

   At this time, currency conversions are only looked up using Yahoo!'s
services, and hence information obtained with automatic currency
conversion is bound by Yahoo!'s terms and conditions.

FAILOVER
--------

     $q->failover(1);	# Set automatic failover support.
     $q->failover(0);	# Disable failover support.

   The failover method takes a single argument which either sets (if true)
or unsets (if false) automatic failover support.  If automatic failover
support is enabled (default) then multiple information sources will be
tried if one or more sources fail to return the requested information.
Failover support will significantly increase the time spent looking for a
non-existant stock.

   If the failover method is called with no arguments, or with an
undefined argument, it will return the current failover state (true/false).

USER_AGENT
----------

     my $ua = $q->user_agent;

   The user_agent method returns the LWP::UserAgent object that
Finance::Quote and its helpers use.  Normally this would not be useful to
an application, however it is possible to modify the user-agent directly
using this method:

     $q->user_agent->timeout(10);	# Set the timeout directly.

SCALE_FIELD
-----------

     my $pounds = $q->scale_field($item_in_pence,0.01);

   The scale_field() function is a helper that can scale complex fields
such as ranges (eg, "102.5 - 103.8") and other fields where the numbers
should be scaled but any surrounding text preserved.  It's most useful in
writing new Finance::Quote modules where you may retrieve information in a
non-ISO4217 unit (such as cents) and would like to scale it to a more
useful unit (like dollars).

ENVIRONMENT
===========

   Finance::Quote respects all environment that your installed version of
LWP::UserAgent respects.  Most importantly, it respects the http_proxy
environment variable.

BUGS
====

   There are no ways for a user to define a failover list.

   The two-dimensional hash is a somewhat unwieldly method of passing
around information when compared to references.  A future release is
planned that will allow for information to be returned in a more flexible
$hash{$stock}{$label} style format.

   There is no way to override the default behaviour to cache currency
conversion rates.

COPYRIGHT
=========

     Copyright 1998, Dj Padzensky
     Copyright 1998, 1999 Linas Vepstas
     Copyright 2000, Yannick LE NY (update for Yahoo Europe and YahooQuote)
     Copyright 2000, Paul Fenwick (updates for ASX, maintainence and release)
     Copyright 2000, Brent Neal (update for TIAA-CREF)

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

   Currency information fetched through this module is bound by Yahoo!'s
terms and conditons.

   Other copyrights and conditions may apply to data fetched through this
module.  Please refer to the sub-modules for further information.

AUTHORS
=======

     Dj Padzensky (C<djpadz@padz.net>), PadzNet, Inc.
     Linas Vepstas (C<linas@linas.org>)
     Yannick LE NY (C<y-le-ny@ifrance.com>)
     Paul Fenwick (C<pjf@schools.net.au>)
     Brent Neal (C<brentn@users.sourceforge.net>)
     Volker Stuerzl (C<volker.stuerzl@gmx.de>)
     Keith Refson (C<Keith.Refson#earth.ox.ac.uk>)

   The Finance::Quote home page can be found at
http://finance-quote.sourceforge.net/

   The Finance::YahooQuote home page can be found at
http://www.padz.net/~djpadz/YahooQuote/

   The GnuCash home page can be found at http://www.gnucash.org/

SEE ALSO
========

   Finance::Quote::Yahoo, Finance::Quote::ASX, Finance::Quote::Fidelity,
Finance::Quote::Tiaacref, Finance::Quote::Troweprice, LWP::UserAgent,
Finance::Quote::DWS, Finance::Quote::VWD, Finance::Quote::Trustnet

   You should have also received the Finance::Quote hacker's guide with
this package.  Please read it if you are interested in adding extra
methods to this package.  The hacker's guide can also be found on the
Finance::Quote website, http://finance-quote.sourceforge.net/


