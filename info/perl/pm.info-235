This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Mail/POP3Client,  Next: Mail/Procmail,  Prev: Mail/MsgStore,  Up: Module List

Perl 5 module to talk to a POP3 (RFC1939) server
************************************************

NAME
====

   Mail::POP3Client - Perl 5 module to talk to a POP3 (RFC1939) server

SYNOPSIS
========

     use Mail::POP3Client;
     $pop = new Mail::POP3Client( USER     => "me",
     			       PASSWORD => "mypassword",
     			       HOST     => "pop3.do.main" );
     for( $i = 1; $i <= $pop->Count(); $i++ ) {
       foreach( $pop->Head( $i ) ) {
         /^(From|Subject):\s+/i && print $_, "\n";
       }
     }
     $pop->Close();
     # OR
     $pop2 = new Mail::POP3Client( HOST  => "pop3.otherdo.main" );
     $pop2->User( "somebody" );
     $pop2->Pass( "doublesecret" );
     $pop2->Connect() || die $pop2->Message();
     $pop2->Close();

DESCRIPTION
===========

   This module implements an Object-Oriented interface to a POP3 server.
It implements RFC1939 (http://www.faqs.org/rfcs/rfc1939.html)

EXAMPLES
========

   Here is a simple example to list out the From: and Subject: headers in
your remote mailbox:

     #!/usr/local/bin/perl
     
     use Mail::POP3Client;
     
     $pop = new Mail::POP3Client( USER     => "me",
     			       PASSWORD => "mypassword",
     			       HOST     => "pop3.do.main" );
     for ($i = 1; $i <= $pop->Count(); $i++) {
       foreach ( $pop->Head( $i ) ) {
         /^(From|Subject):\s+/i and print $_, "\n";
       }
       print "\n";
     }

CONSTRUCTORS
============

   Old style (deprecated):    new Mail::POP3Client( USER, PASSWORD [,
HOST, PORT, DEBUG, AUTH_MODE] );

   New style (shown with defaults):    new Mail::POP3Client( USER      =>
"",                          PASSWORD  => "",
HOST      => "pop3",                          PORT      => 110,
             AUTH_MODE => 'BEST',                          DEBUG     => 0,
                        TIMEOUT   => 60,                        );

   * USER is the userID of the account on the POP server

   * PASSWORD is the cleartext password for the userID

   * HOST is the POP server name or IP address (default = 'pop3')

   * PORT is the POP server port (default = 110)

   * DEBUG - any non-null, non-zero value turns on debugging (default = 0)

   * AUTH_MODE - pass 'APOP' to force APOP (MD5) authorization. (default
     is 'BEST')

   * TIMEOUT - set a timeout value for socket operations (default = 60)

METHODS
=======

   These commands are intended to make writing a POP3 client easier.  They
do not necessarily map directly to POP3 commands defined in RFC1081 or
RFC1939, although all commands should be supported.  Some commands return
multiple lines as an array in an array context.

new( USER => 'user', PASSWORD => 'password', HOST => 'host',               PORT => 110, DEBUG => 0, AUTH_MODE => 'BEST', TIMEOUT => 60 )
     Construct a new POP3 connection with this.  You should use the
     hash-style constructor.  *The old positional constructor is
     deprecated and will be removed in a future release.  It is strongly
     recommended that you convert your code to the new version.*

     You should give it at least 2 arguments: USER and PASSWORD.  The
     default HOST is 'pop3' which may or may not work for you.  You can
     specify a different PORT (be careful here).

     new will attempt to Connect to and Login to the POP3 server if you
     supply a USER and PASSWORD.  If you do not supply them in the
     constructor, you will need to call Connect yourself.

     The valid values for AUTH_MODE are 'BEST', 'PASS' and 'APOP'.  BEST
     says to try APOP if the server appears to support it and it can be
     used to successfully log on, otherwise revert to PASS.  APOP implies
     that an MD5 checksum will be used instead of sending your password in
     cleartext.  However, *if the server does not claim to support APOP,
     the cleartext method will be used.  Be careful.* There are a few
     servers that will send a timestamp in the banner greeting, but APOP
     will not work with them (for instance if the server does not know your
     password in cleartext).  If you think your authentication information
     is correct, run in DEBUG mode and look for errors regarding
     authorization.  If so, then you may have to use 'PASS' for that
     server.

     If you enable debugging with DEBUG => 1, socket traffic will be echoed
     to STDERR.

     Another warning, it's impossible to differentiate between a timeout
     and a failure.

*Head*( MESSAGE_NUMBER )
     Get the headers of the specified message, either as an array or as a
     string, depending on context.

     You can also specify a number of preview lines which will be returned
     with the headers.  This may not be supported by all POP3 server
     implementations as it is marked as optional in the RFC.  Submitted by
     Dennis Moroney <dennis@hub.iwl.net>.

Body( MESSAGE_NUMBER )
     Get the body of the specified message, either as an array of lines or
     as a string, depending on context.

*BodyToFile*( FILE_HANDLE, MESSAGE_NUMBER )
     Get the body of the specified message and write it to the given file
     handle.  my $fh = new IO::Handle(); $fh->fdopen( fileno( STDOUT ),
     "w" ); $pop->BodyToFile( $fh, 1 );

     Does no stripping of NL or CR.

*HeadAndBody*( MESSAGE_NUMBER [, PREVIEW_LINES ] )
     Get the head and body of the specified message, either as an array of
     lines or as a string, depending on context.

    Example
          foreach ( $pop->HeadAndBody( 1, 10 ) )    print $_, "\n";

          prints out a preview of each message, with the full header and
          the first 10 lines of the message (if supported by the POP3
          server).

*HeadAndBodyToFile*( FILE_HANDLE, MESSAGE_NUMBER )
     Get the head and body of the specified message and write it to the
     given file handle.  my $fh = new IO::Handle(); $fh->fdopen( fileno(
     STDOUT ), "w" ); $pop->HeadAndBodyToFile( $fh, 1 );

     Does no stripping of NL or CR.  Since you have to create the file
     handle yourself, there is no HeadAndBodyToFile or HeadToFile.

*Retrieve*( MESSAGE_NUMBER )
     Same as HeadAndBody.

*RetrieveToFile*( FILE_HANDLE, MESSAGE_NUMBER )
     Same as HeadAndBodyToFile.

Delete( MESSAGE_NUMBER )
     Mark the specified message number as DELETED.  Becomes effective upon
     QUIT.  Can be reset with a Reset message.

Connect
     Start the connection to the POP3 server.  You can pass in the host and
     port.

Close
     Close the connection gracefully.  POP3 says this will perform any
     pending deletes on the server.

Alive
     Return true or false on whether the connection is active.

Socket
     Return the file descriptor for the socket.

Size
     Set/Return the size of the remote mailbox.  Set by POPStat.

Count
     Set/Return the number of remote messages.  Set during Login.

Message
     The last status message received from the server.

State
     The internal state of the connection: DEAD, AUTHORIZATION,
     TRANSACTION.

POPStat
     Return the results of a POP3 STAT command.  Sets the size of the
     mailbox.

List([message_number])
     Returns the size of the given message number when called with an
     argument using the following format:

          <message_number> <size_in_bytes>

     If message_number is omitted, List behaves the same as ListArray,
     returning an indexed array of the sizes of each message in the same
     format.

     You can parse the size in bytes using split:  ($msgnum, $size) =
     split ' ', $pop -> List( n )

ListArray
     Return a list of sizes of each message.  This returns an indexed
     array, with each message number as an index (starting from 1) and the
     value as the next entry on the line.  Beware that some servers send
     additional info for each message for the list command.  That info may
     be lost.

*Uidl*( [MESSAGE_NUMBER] )
     Return the unique ID for the given message (or all of them).  Returns
     an indexed array with an entry for each valid message number.
     Indexing begins at 1 to coincide with the server's indexing.

Last
     Return the number of the last message, retrieved from the server.

Reset
     Tell the server to unmark any message marked for deletion.

User( [USER_NAME] )
     Set/Return the current user name.

Pass( [PASSWORD] )
     Set/Return the current user name.

Login
     Attempt to login to the server connection.

Host( [HOSTNAME] )
     Set/Return the current host.

Port( [PORT_NUMBER] )
     Set/Return the current port number.

AUTHOR
======

   Sean Dowd <pop3client@dowds.net>

CREDITS
=======

   Based loosely on News::NNTPClient by Rodger Anderson
<rodger@boi.hp.com>.

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Mail/Procmail,  Next: Mail/QuoteWrap,  Prev: Mail/POP3Client,  Up: Module List

Procmail-like facility for creating easy mail filters.
******************************************************

NAME
====

   Mail::Procmail - Procmail-like facility for creating easy mail filters.

SYNOPSIS
========

     use Mail::Procmail;

     # Set up. Log everything up to log level 3.
     my $m_obj = pm_init ( loglevel  => 3 );

     # Pre-fetch some interesting headers.
     my $m_from		    = pm_gethdr("from");
     my $m_to		    = pm_gethdr("to");
     my $m_subject	    = pm_gethdr("subject");

     # Default mailbox.
     my $default = "/var/spool/mail/".getpwuid($>);

     pm_log(1, "Mail from $m_from");

     pm_ignore("Non-ASCII in subject")
       if $m_subject =~ /[\232-\355]{3}/;

     pm_resend("jojan")
       if $m_to =~ /jjk@/i;

     # Make sure I see these.
     pm_deliver($default, continue => 1)
       if $m_subject =~ /getopt(ions|(-|::)?long)/i;

     # And so on ...

     # Final delivery.
     pm_deliver($default);

DESCRIPTION
===========

   `procmail' is a great mail filter program, but it has weird recipe
format. It's pattern matching capabilities are basic and often
insufficient. I wanted something flexible whereby I could filter my mail
using the power of Perl.

   I've been considering to write a procmail replacement in Perl for a
while, but it was Simon Cozen's `Mail::Audit' module, and his article in
The Perl Journal #18, that set it off.

   I first started using Simon's great module, and then decided to write
my own since I liked certain things to be done differently. And I couldn't
wait for his updates. Currently, Simon and I are in the process of
considering to port my enhancements to his code as well.

   `Mail::Procmail' allows a piece of email to be logged, examined,
delivered into a mailbox, filtered, resent elsewhere, rejected, and so on.
It is designed to allow you to easily create filter programs to stick in a
`.forward' or `.procmailrc' file, or similar.

DIFFERENCES WITH MAIL::AUDIT
============================

   Note that several changes are due to personal preferences and do not
necessarily imply deficiencies in `Mail::Audit'.

General
     Not object oriented. Procmail functionality typically involves one
     single message. All (relevant) functions are exported.

Delivery
     Each of the delivery methods is able to continue (except pm_reject
     and pm_ignore).

     Each of the delivery methods is able to pretend they did it (for
     testing a new filter).

     No default file argument for mailbox delivery, since this is system
     dependent.

     Each of the delivery methods logs the line number in the calling
     program so one can deduce which 'rule' caused the delivery.

     Message IDs can be checked to suppress duplicate messages.

     System commands can be executed for their side-effects.

     pm_ignore logs a reason as well.

     pm_reject will fake a "No such user" status to the mail transfer
     agent.

Logging
     The logger function is exported as well. Logging is possible to a
     named file, STDOUT or STDERR.

     Since several deliveries can take place in parallel, logging is
     protected against concurrent access, and a timestamp/pid is included
     in log messages.

     A log reporting tool is included.

Robustness
     Exit with TEMPFAIL instead of die in case of problems.

     pm_pipe_to ignores  SIGPIPE.

     pm_pipe_to returns the command exit status if continuation is
     selected.

     Commands and pipes can be protected  against concurrent access using
     lockfiles.

EXPORTED ROUTINES
=================

   Note that most delivery routines exit the program unless the attribute
"continue=>1" is passed.

   Also, the delivery routines log the line number in the calling program
so it is easy to find out which 'rule' caused a specific delivery to take
place.

pm_init
-------

   This routine performs the basic initialisation. It must be called once.

   Example:

     pm_init (logfile => "my.log", loglevel => 3, test => 1);

   Attributes:

   * logfile

     The name of a file to log messages to. Each message will have a
     timestamp attached.

     The attribute may be 'STDOUT' or 'STDERR' to achieve logging to
     standard output or error respectively.

   * loglevel

     The amount of information that will be logged.

   * test

     If true, no actual delivery will be done. Suitable to test a new
     setup.  Note that file locks are done, so lockfiles may be created
     and deleted.

   * debug

     Provide some debugging info.

   * trace

     Provide some tracing info, eventually.

   * verbose

     Produce verbose information, eventually.

pm_gethdr
---------

   This routine fetches the contents of a header. The result will have
excess whitepace tidied up.

   The header is reported using warn() if the debug attribute was passed
(with a true value) to pm_init();

   Example:

     $m_rcvd = pm_gethdr("received");	# get first (or only) Received: header
     $m_rcvd = pm_gethdr("received",2);	# get 3rd Received: header
     @m_rcvd = pm_gethdr("received");	# get all Received: headers

pm_deliver
----------

   This routine performs delivery to a Unix style mbox file, or maildir.

   In case of an mbox file, the file is locked first by acquiring
exclusive access. Note that older style locking, with a lockfile with
`.lock' extension, is not supported.

   Example:

     pm_deliver("/var/spool/mail/".getpwuid($>));

   Attributes:

   * continue

     If true, processing will continue after delivery. Otherwise the
     program will exit with a DELIVERED status.

pm_pipe_to
----------

   This routine performs delivery to a command via a pipe.

   Return the command exit status if the continue attribute is supplied.
If execution is skipped due to test mode, the return value will be 0.  See
also attribute `testalso' below.

   If the name of a lockfile is supplied, multiple deliveries are
throttled.

   Example:

     pm_pipe_to("my_filter", lockfile => "/tmp/pm.lock");

   Attributes:

   * lockfile

     The name of a file that is used to guard against multiple deliveries.
     The program will try to exclusively create this file before proceding.
     Upon completion, the lock file will be removed.

   * continue

     If true, processing will continue after delivery. Otherwise the
     program will exit with a DELIVERED status, *even when the command
     failed*.

   * testalso

     Do this, even in test mode.

pm_command
----------

   Executes a system command for its side effects.

   If the name of a lockfile is supplied, multiple executes are throttled.
This would be required if the command manipulates external data in an
otherwise unprotected manner.

   Example:

     pm_command("grep foo some.dat > /tmp/pm.dat",
                lockfile => "/tmp/pm.dat.lock");

   Attributes:

   * lockfile

     The name of a file that is used to guard against multiple executions.
     The program will try to exclusively create this file before proceding.
     Upon completion, the lock file will be removed.

     testalso

     Do this, even in test mode.

pm_resend
---------

   Send this message through to some other user.

   Example:

     pm_resend("root");

   Attributes:

   * continue

     If true, processing will continue after delivery. Otherwise the
     program will exit with a DELIVERED status.

pm_reject
---------

   Reject a message. The sender will get a mail back with the reason for
the rejection (unless stderr has been redirected).

   Example:

     pm_reject("Non-existent address");

pm_ignore
---------

   Ignore a message. The program will do nothing and just exit with a
DELIVERED status. A descriptive text may be passed to log the reason for
ignoring.

   Example:

     pm_ignore("Another make money fast message");

pm_dupcheck
-----------

   Check for duplicate messages. Reject the message if its message ID has
already been received.

   Example:

     pm_dupcheck(pm_gethdr("msg-id"));

   Attributes:

   * dbm

     The name of a DBM file (created if necessary) to store the message
     IDs.  The default name is `.msgids' in the HOME directory.

   * retain

     The amount of time, in days, that subsequent identical message IDs are
     considered duplicates. Each new occurrence will refresh the time
     stamp.  The default value is 14 days.

   * continue

     If true, the routine will return true or false depending on the
     message ID being duplicate. Otherwise, if it was duplicate, the
     program will exit with a DELIVERED status.

   *Warning: In the current implementation, the DBM file will grow
unlimited. A separate tool will be supplied to expire old message IDs.*

pm_lockfile
-----------

   The program will try to get an exclusive lock using this file.

   Example:

     $lock_id = pm_lockfile("my.mailbox.lock");

   The lock id is returned, or undef on failure.

pm_unlockfile
-------------

   Unlocks a lock acquired earlier using pm_lockfile().

   Example:

     pm_unlockfile($lock_id);

   If unlocking succeeds, the lock file is removed.

pm_log
------

   Logging facility. If pm_init() was supplied the name of a log file,
this file will be opened, created if necessary. Every log message written
will get a timestamp attached. The log level (first argument) must be less
than or equal to the loglevel attribute used with pm_init(). If not, this
message will be skipped.

   Example:

     pm_log(2,"Retrying");

pm_report
---------

   pm_report() produces a summary report from log files from
Mail::Procmail applications.

   Example:

     pm_report(logfile => "pmlog");

   The report shows the deliveries, and the rules that caused the
deliveries. For example:

     393  393  deliver[203]  /home/jv/Mail/perl5-porters.spool
     370  370  deliver[203]  /home/jv/Mail/perl6-language.spool
     174  174  deliver[203]  /home/jv/Mail/perl6-internals.spool
     160   81  deliver[311]  /var/spool/mail/jv
     	46  deliver[337]
     	23  deliver[363]
     	10  deliver[165]

   The first column is the total number of deliveries for this target.
The second column is the number of deliveries triggered by the indicated
rule. If more rules apply to a target, this line is followed by additional
lines with an empty first and last column.

   Attributes:

   * logfile

     The name of the logfile to process.

   If no logfile attribute is passed, pm_report() reads all files supplied
on the command line. This makes it straighforward to run from the command
line:

     $ perl -MMail::Procmail -e 'pm_report()' syslog/pm_logs/*

USING WITH PROCMAIL
===================

   The following lines at the start of .procmailrc will cause a copy of
each incoming message to be saved in $HOME/syslog/mail, after which the
procmail-pl is run as a TRAP program (see the procmailrc documentation).
As a result, procmail will transfer the exit status of procmail-pl to the
mail transfer agent that invoked procmail (e.g., sendmail, or postfix).

     LOGFILE=$HOME/syslog/procmail
     VERBOSE=off
     LOGABSTRACT=off
     EXITCODE=
     TRAP=$HOME/bin/procmail-pl

     :0:
     $HOME/syslog/mail

   The original contents of the .procmailrc can be safely left in place
after these lines.

EXAMPLE
=======

   An extensive example can be found in the examples directory of the
`Mail::Procmail' kit.

SEE ALSO
========

   *Note Mail/Internet: Mail/Internet,

   *Note LockFile/Simple: LockFile/Simple,

   procmail documentation.

AUTHOR
======

   Johan Vromans, Squirrel Consultancy <jvromans@squirrel.nl>

   Some parts are shamelessly stolen from Mail::Audit by Simon Cozens
<simon@cpan.org>, who admitted that he stole most of it from programs by
Tom Christiansen.

COPYRIGHT and DISCLAIMER
========================

   This program is Copyright 2000 by Squirrel Consultancy. All rights
reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of either: a) the GNU General Public License as published
by the Free Software Foundation; either version 1, or (at your option) any
later version, or b) the "Artistic License" which comes with Perl.

   This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See either the GNU General Public
License or the Artistic License for more details.


File: pm.info,  Node: Mail/QuoteWrap,  Next: Mail/RBL,  Prev: Mail/Procmail,  Up: Module List

Provides quotification functionality for Usenet articles and mail.
******************************************************************

NAME
====

   *Mail::QuoteWrap* - Provides quotification functionality for Usenet
articles and mail.

SYNOPSIS
========

     use Mail::QuoteWrap;
     
     ...

     my $columns = 72;                     # maximum column width of the post
     my $output_quotechar = ">";           # character to prepend to
                                           # quoted lines -- see quotify()
     my $input_quotechars = "<>:";         # characters to be recognized as
                                           # quotifiers when judging the
                                           # generation of a quote

     my $text = $news_article->body();     # get some body text somehow

     my $body = create Mail::QuoteWrap ($text, $columns, $output_quotechar,
                                      $input_quotechars, {});

     $body->quotify();
     $body->append("Me too!");

     my $newtext = $body->format();

DESCRIPTION
===========

   A *Mail::QuoteWrap* object expects its text member to contain a
reference to a list of lines of text, such as the output of methods like
`body News::Article()'.  It can then produce quotified output, optionally
prepended with the quote mark designated by output_quotechar, within the
width specified by columns.

   *Mail::QuoteWrap* specificially does not solve the following problems:


     It does not handle munged quote characters, such as those produced by
     the AOHell newsreader or similar gunge:

          >> This >is a second-generation quote, but it
          > looks >>like a nasty mix of first- and second->
          > generation >>material.


     It does not automatically detect and bypass news or mail headers.
     That is not the role of this object.


     It assumes a paragraph structure to the quoted text and doesn't try
     to enforce any other.  If you want a module that detects document
     structure and deals well with it, look at *Text::Autoformat*.

REQUIRES
========

   This module uses *Text::Format*.

BUGS
====


     If input_quotechars or output_quotechar contain suckful characters
     that regexp thinks it understands, all hell can break loose.


     *Mail::QuoteWrap* may not deal well with Supercite-style
     quotification:

          Chuck> I believe everything I see written on toilet paper

     is thought to be zeroth-generation (unquoted) material.

AUTHOR
======

   Chuck Hardin <chardin@savageoasis.fc.net>

COPYRIGHT
=========

   This module is copyright 2000, Chuck Hardin.

LICENSE
=======

   This module is distributed under version 2 of the GNU Public License.

Public class method
===================

create
------

     public class
     (Mail::QuoteWrap) create(string[] text [,integer columns]
                              [,string output_quotechar] [,string input_quotechars]
                              [,hashref format_params])

   This method creates a *Mail::QuoteWrap* object populated with the
parameters passed in.  It returns a NULL object if any of the provided
parameters are invalid.

   The meanings of the members are as follows:

text
     The body text of the message.

columns
     The width to which the message should be justified.  NOTE:  If any
     line consisting of the quotification string and the first word is
     wider than this, then the line will be generated with that
     quotification string and that word, and it will overflow.  Life is
     hard.

output_quotechar
     The quotification character to prepend to the text when quoting.  See
     `quotify()'.

input_quotechars
     The set of characters to be recognized as quotification marks when
     determining how to group quoted material.

format_params
     Miscellaneous parameters to pass for formatting.  See the
     documentation for the *Text::Format* module.

Private class method
====================

new
---

     private class
     (Mail::QuoteWrap) new(hashref params)

   Creates a *Mail::QuoteWrap* object populated by the data in params.

Public instance methods
=======================

text
----

     public instance
     (string []) text()

   Returns the text member of the current *Mail::QuoteWrap* object.

set_text
--------

     public instance
     (string) set_text(string[] text)

   Sets the text member of the current *Mail::QuoteWrap* object.  Returns
a NULL string if it succeeds, or a descriptive error message otherwise.

columns
-------

     public instance
     (integer) columns()

   Returns the columns member of the current *Mail::QuoteWrap* object.

set_columns
-----------

     public instance
     (string) set_columns(integer columns)

   Sets the columns member of the current *Mail::QuoteWrap* object.
Returns a NULL string if it succeeds, or a descriptive error message
otherwise.

input_quotechars
----------------

     public instance
     (string) input_quotechars()

   Returns the input_quotechars member of the current *Mail::QuoteWrap*
object.

set_input_quotechars
--------------------

     public instance
     (string) set_input_quotechars(string input_quotechars)

   Sets the input_quotechars member of the current *Mail::QuoteWrap*
object.  Returns a NULL string if it succeeds, or a descriptive error
message otherwise.

output_quotechar
----------------

     public instance
     (string) output_quotechar()

   Returns the output_quotechar member of the current *Mail::QuoteWrap*
object.

set_output_quotechar
--------------------

     public instance
     (string) set_output_quotechar(string output_quotechar)

   Sets the output_quotechar member of the current *Mail::QuoteWrap*
object.  Returns a NULL string if it succeeds, or a descriptive error
message otherwise.

format_params
-------------

     public instance
     (hashref) format_params()

   Returns the format_params member of the current *Mail::QuoteWrap*
object.

set_format_params
-----------------

     public instance
     (string) set_format_params(hashref format_params)

   Sets the format_params member of the current *Mail::QuoteWrap* object.
Returns a NULL string if it succeeds, or a descriptive error message
otherwise.

quotify
-------

     public instance
     (string) quotify()

   Quotifies all current text with the string in `output_quotechar()'.
Modifies the input_quotechars member to reflect that the text is now
quotified.  Returns a NULL string if it succeeds, or a descriptive error
message otherwise.

format
------

     public instance
     (string) format()

   This method alters the text member of the current *Mail::QuoteWrap*
object to conform to the constraints implied in the columns and
format_params members.  It recognizes the quotification characters in
input_quotechars and uses them to lump related quoted material together.
`format()' will use the same quotification character at the beginning of
each line within a block of quoted material which it believes to be
related.  Returns a NULL string if it succeeds, or a descriptive error
message otherwise.

Private utility methods
=======================

parse_quotification
-------------------

     private
     (string, string) parse_quotification (string text, string quotechars)

   Returns two strings:  the quotification part of the line of text
(consisting of all characters at the beginning of the line which are tabs,
spaces, or characters in *quotechars*), and the remainder of the line.
Returns two NULL strings if this matching does not work out.

break_text_into_blocks
----------------------

     private
     (hashref []) break_text_into_blocks (string[] text, string quotechars)

   Breaks text into a list of elements, each of which is a hash with the
following elements:

quotification
     Quotification string to use for this block.

message
     Array ref containing the message text; undef if the message portion
     is blank.

   Each message element is guaranteed to consist of lines of
same-generation quotage - i.e., a block will contain only first-generation
quotes, second-generation, zeroth-generation, or what have you.  Each line
with blank message text gets its own block, to preserve vertical
whitespace.

copy_and_push
-------------

     private
     (string) copy_and_push(hashref current_block, arrayref outlist)

   Pushes a copy of the contents of *current_block* onto outlist.
*current_block* is assumed to have two members as described in the
documentation for `break_text_into_blocks()' above.  Returns a NULL string
if it succeeds, or a descriptive error message otherwise.

break_block_into_paragraphs
---------------------------

     private
     (string[]) break_block_into_paragraphs(string[] block)

   Breaks the block into paragraphs according to the following rule:

   If the previous line ended with a period and the current line begins
with a tab or at least three spaces, the current line begins a new
paragraph.


File: pm.info,  Node: Mail/RBL,  Next: Mail/Send,  Prev: Mail/QuoteWrap,  Up: Module List

Perl extension to access RBL-style host verification services
*************************************************************

NAME
====

   Mail::RBL - Perl extension to access RBL-style host verification
services

SYNOPSIS
========

     use Mail::RBL;

     my $list = new Mail::RBL('list.org');

     if ($list->check($host)) {
         print "$host is in the list";
     }

DESCRIPTION
===========

   This module eases the task of checking if a given host is in the list.
The methods available are described below:

`->new(suffix)'
     Creates a list handle. The suffix parameter is mandatory and
     specifies which suffix to append to the queries.

`->check($host)'
     $host can be either a hostname or an IP address. In the case of an IP
     Address, any trailing netmask (anything after a '/' character) will
     be ignored. In the case of a hostname, all the IP addresses will be
     looked up and checked against the list. If any of the addresses is in
     the list, the host will be considered in the list as a whole.

AUTHOR
======

   Luis E. Munoz <lem@cantv.net>

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Mail/Send,  Next: Mail/Sender,  Prev: Mail/RBL,  Up: Module List

Simple electronic mail interface
********************************

NAME
====

   Mail::Send - Simple electronic mail interface

SYNOPSIS
========

     require Mail::Send;

     $msg = new Mail::Send;

     $msg = new Mail::Send Subject=>'example subject', To=>'timbo';

     $msg->to('user@host');
     $msg->subject('example subject');
     $msg->cc('user@host');
     $msg->bcc('someone@else');

     $msg->set($header, @values);
     $msg->add($header, @values);
     $msg->delete($header);

     # Launch mailer and set headers. The filehandle returned
     # by open() is an instance of the Mail::Mailer class.

     $fh = $msg->open;

     print $fh "Body of message";

     $fh->close;         # complete the message and send it

     $fh->cancel;        # not yet implemented

DESCRIPTION
===========

SEE ALSO
========

   Mail::Mailer

AUTHORS
=======

   Maintained by Graham Barr <`gbarr@pobox.com'>

   Original code written by Tim Bunce <`Tim.Bunce@ig.co.uk'>, with a kick
start from Graham Barr <`gbarr@pobox.com'>. With contributions by Gerard
Hickey <`hickey@ctron.com'>

   For support please contact comp.lang.perl.misc or Graham Barr
<`gbarr@pobox.com'>


File: pm.info,  Node: Mail/Sender,  Next: Mail/Sendmail,  Prev: Mail/Send,  Up: Module List

module for sending mails with attachments through an SMTP server
****************************************************************

NAME
====

   Mail::Sender - module for sending mails with attachments through an
SMTP server

   Version 0.7.06

SYNOPSIS
========

     use Mail::Sender;
     $sender = new Mail::Sender
      {smtp => 'mail.yourdomain.com', from => 'your@address.com'};
     $sender->MailFile({to => 'some@address.com',
      subject => 'Here is the file',
      msg => "I'm sending you the list you wanted.",
      file => 'filename.txt'});

DESCRIPTION
===========

   `Mail::Sender' provides an object oriented interface to sending mails.
It doesn't need any outer program. It connects to a mail server directly
from Perl, using Socket.

   Sends mails directly from Perl through a socket connection.

CONSTRUCTORS
============

`new Mail::Sender'
          new Mail::Sender ([from [,replyto [,to [,smtp [,subject [,headers [,boundary]]]]]]])
          new Mail::Sender {[from => 'somebody@somewhere.com'] , [to => 'else@nowhere.com'] [...]}

     Prepares a sender. This doesn't start any connection to the server.
     You have to use `$Sender-'Open> or `$Sender-'OpenMultipart> to start
     talking to the server.

     The parameters are used in subsequent calls to `$Sender-'Open> and
     `$Sender-'OpenMultipart>. Each such call changes the saved variables.
     You can set smtp,from and other options here and then use the info in
     all messages.

          from      = the senders e-mail address

          fake_from = the address that will be shown in headers
                      If not specified we use the value of "from"

          replyto   = the reply-to address

          to        = the recipient's address(es)

          fake_to   = the address that will be shown in headers
                      If not specified we use the value of "to"

          cc        = address(es) to send a copy (carbon copy)

          fake_cc   = the address that will be shown in headers
                      If not specified we use the value of "cc"

          bcc       = address(es) to send a copy (blind carbon copy)
                      these addresses will not be visible in the mail!

          smtp      = the IP or domain address of your SMTP (mail) server
                      This is the name of your LOCAL mail server, do not try to guess
                      and contact directly the adressee's mailserver!

          subject   = the subject of the message

          headers   = the additional headers

          boundary  = the message boundary

          multipart = the MIME subtype for the whole message (Mixed/Related/Alternative)
           you may need to change this setting if you want to send a HTML body with some
           inline images, or if you want to post the message in plain text as well as
           HTML (alternative). See the examples at the end of the docs.
           You may also use the nickname "subtype".

          type      = the content type of a multipart message, may be usefull for
                      multipart/related

          ctype     = the content type of a single part message

          Please do not confuse these two. The 'type' parameter is used to specify
          the overall content type of a multipart message (for example a HTML document
          with inlined images) while ctype is an ordinary content type for a single
          part message. For example a HTML mail message.

          encoding  = encoding of a single part message or the body of a multipart
           message. If the text of the message contains some extended characters or
           very long lines you should use 'encoding => "Quoted-printable"' in the
           call to Open(), OpenMultipart(), MailMsg() or MailFile().
           Keep in mind that if you use some encoding you should either use SendEnc()
           or encode the data yourself !

          charset   = the charset of the message

          client     = the name of the client computer. During the connection you send
           the mailserver your name. Usualy a "localhost" is sufficient, but sometimes
           you need to specify some real name. Usualy something like
           `hostname`.'.mycompany.com'. But I leave this for you.
           Mail::Sender doesn't try to guess the name, it sends "localhost" if you do
           not specify otherwise.

          priority   = 1 = highest, 2 = high, 3 = normal
           "X-Priority: 1 (Highest)";

          return codes:
           ref to a Mail::Sender object =  success
           -1 = $smtphost unknown
           -2 = socket() failed
           -3 = connect() failed
           -4 = service not available
           -5 = unspecified communication error
           -6 = local user $to unknown on host $smtp
           -7 = transmission of message failed
           -8 = argument $to empty
           -9 = no message specified in call to MailMsg or MailFile
           -10 = no file name specified in call to SendFile or MailFile
           -11 = file not found
           -12 = not available in singlepart mode
            $Mail::Sender::Error contains a textual description of last error.

METHODS
=======

Open
          Open([from [, replyto [, to [, smtp [, subject [, headers]]]]]])
          Open({[from => "somebody@somewhere.com"] , [to => "else@nowhere.com"] [...]})

     Opens a new message. If some parameters are unspecified or empty, it
     uses the parameters passed to the "`$Sender=new Mail::Sender(...)'";

     see `new Mail::Sender' for info about the parameters.

OpenMultipart
          OpenMultipart([from [, replyto [, to [, smtp [, subject [, headers [, boundary]]]]]]])
          OpenMultipart({[from => "somebody@somewhere.com"] , [to => "else@nowhere.com"] [...]})

     Opens a multipart message. If some parameters are unspecified or
     empty, it uses the parameters passed to the `$Sender=new
     Mail::Sender(...)'.

     see `new Mail::Sender' for info about the parameters.

MailMsg
          MailMsg([from [, replyto [, to [, smtp [, subject [, headers]]]]]], message)
          MailMsg({[from => "somebody@somewhere.com"]
                   [, to => "else@nowhere.com"] [...], msg => "Message"})

     Sends a message. If a mail in $sender is opened it gets closed and a
     new mail is created and sent. $sender is then closed.  If some
     parameters are unspecified or empty, it uses the parameters passed to
     the "`$Sender=new Mail::Sender(...)'";

     see `new Mail::Sender' for info about the parameters.

     The module was made so that you could create an object initialized
     with all the necesary options and then send several messages without
     need to specify the SMTP server and others each time. If you need to
     send only one mail using MailMsg() or MailFile() you do not have to
     create a named object and then call the method. You may do it like
     this :

          (new Mail::Sender)->MailMsg({smtp => 'mail.company.com', ...});

MailFile
          MailFile([from [, replyto [, to [, smtp [, subject [, headers]]]]]], message, file(s))
          MailFile({[from => "somebody@somewhere.com"]
                    [, to => "else@nowhere.com"] [...],
                    msg => "Message", file => "File"})

     Sends one or more files by mail. If a mail in $sender is opened it
     gets closed and a new mail is created and sent. $sender is then
     closed.  If some parameters are unspecified or empty, it uses the
     parameters passed to the "`$Sender=new Mail::Sender(...)'";

     The file parameter may be a "filename", a "list, of, file, names" or
     a \@list of file names.

     see `new Mail::Sender' for info about the parameters.

     Just keep in mind that parameters like ctype, charset and encoding
     will be used for the attached file, not the body of the message.  If
     you want to specify those parameters for the body you have to use
     b_ctype, b_charset and b_encoding. Sorry.

Send
          Send(@strings)

     Prints the strings to the socket. Doesn't add any end-of-line
     characters.  You should use `\r\n' as the end-of-line. IF YOU ARE NOT
     SURE ABOUT THIS USE SendEx() INSTEAD!

SendLine
          SendLine(@strings)

     Prints the strings to the socket. Adds the end-of-line character at
     the end.

SendEnc
          SendEnc(@strings)

     Prints the strings to the socket. Doesn't add any end-of-line
     characters.  You should use `\r\n' as the end-of-line.  Encodes the
     text using the selected encoding (Base64/Quoted-printable)

SendLineEnc
          SendLineEnc(@strings)

     Prints the strings to the socket. Add the end-of-line character at
     the end.  Encodes the text using the selected encoding
     (Base64/Quoted-printable)

     Do NOT mix up Send[Line][Ex] and Send[Line]Enc! SendEnc does some
     buffering necessary for correct Base64 encoding, and Send is not
     aware of that!

     Usage of Send[Line][Ex] in non 7BIT parts not recommended.  Using
     `Send(encode_base64($string))' may, but may NOT work!  In particular
     if you use several such to create one part, the data is very likely
     to get crippled.

SendEx
          SendEx(@strings)

     Prints the strings to the socket. Doesn't add any end-of-line
     characters.  Changes all end-of-lines to `\r\n'. YOU'D BETTER USE
     THIS METHOD THAN JUST Send(), SOME E-MAIL SERVERS ARE PICKY AND WOUNT
     ACCEPT THE MESSAGE IF YOU DO NOT USE CRLF (\r\n) AS THE END-OF-LINE !

SendLineEx
          SendLineEx(@strings)

     Prints the strings to the socket. Doesn't add any end-of-line
     characters.  Changes all end-of-lines to `\r\n'.

Part
          Part( I<description>, I<ctype>, I<encoding>, I<disposition> [, I<content_id>]);
          Part( [description => "desc"], [ctype], [encoding], [disposition], [content_id]});

          Prints a part header for the multipart message.
          The undef or empty variables are ignored.

    description
          The title for this part.

    ctype
          the content type (MIME type) of this part. May contain some other
          parameters, such as charset or name.

          Defaults to "application/octet-stream".

    encoding
          the encoding used for this part of message. Eg. Base64,
          Uuencode, 7BIT ...

          Defaults to "7BIT".

    disposition
          This parts disposition. Eg: 'attachment; filename="send.pl"'.

          Defaults to "attachment". If you specify "none" or "", the
          Content-disposition: line will not be included in the headers.

    content_id
          The content id of the part, used in multipart/related.  If not
          specified, the header is not included.

Body
          Body([charset [, encoding [, content-type]]]);

     Sends the head of the multipart message body. You can specify the
     charset and the encoding. Default is "US-ASCII","7BIT",'text/plain'.

     If you pass undef or zero as the parameter, this function uses the
     default value:

          Body(0,0,'text/html');

SendFile
          SendFile( I<description>, I<ctype>, I<encoding>, I<disposition>, I<file>);
          SendFile( { [description => "desc"] , [ctype => "ctype"], [encoding => "encoding"],
                      [disposition => "disposition"], file => "file"});

          Sends a file as a separate part of the mail message. Only in multipart mode.

    description
          The title for this part.

    ctype
          the content type (MIME type) of this part. May contain some other
          parameters, such as charset or name.

          Defaults to "application/octet-stream".

    encoding
          the encoding used for this part of message. Eg. Base64,
          Uuencode, 7BIT ...

          Defaults to "Base64".

    disposition
          This parts disposition. Eg: 'attachment; filename="send.pl"'. If
          you use 'attachment; filename=*' the * will be replaced by the
          respective names of the sent files.

          Defaults to "attachment; filename=*". If you do not want to
          include this header use "" as the value.

    file
          The name of the file to send or a 'list, of, names' or a
          ['reference','to','a','list','of','filenames']. Each file will
          be sent as a separate part.

    content_id
          The content id of the message part. Used in multipart/related.

               Special values:
                "*" => the name of the file
                "#" => autoincremented number (starting from 0)

Close
          $sender->Close;

     Close and send the mail. This method should be called automatically
     when destructing the object, but you should call it yourself just to
     be sure it gets called.  And you should do it as soon as possible to
     close the connection and free the socket.

     The mail is being sent to server, but is not processed by the server
     till the sender object is closed!

Cancel
          $sender->Cancel;

     Cancel an opened message.

     SendFile and other methods may set $sender->{'error'}.  In that case
     "undef $sender" calls `$sender-'>Cancel not `$sender-'>Close!!!

@Mail::Sender::Errors
     Contains the description of errors returned by functions in
     Mail::Sender.

     Usage: @Mail::Sender::Errors[$sender->{error}]

CONFIG
======

   If you create a file named Sender.config in the same directory where
Sender.pm resides, this file will be "require"d as soon as you "use
Mail::Sender" in your script. Of course the Sender.config MUST "return a
true value", that is it has to be succesfully compiled and the last
statement must return a true value. You may use this to forbide the use of
Mail::Sender to some users.

   You may define the default settings for new Mail::Sender objects and do
a few more things.

   The default options are stored in hash %Mail::Sender::default. You may
use all the examples you'd use in new, Open, OpenMultipart, MailMsg or
MailFile.

     Eg.
      %default = (
        smtp => 'mail.mccann.cz',
        from => Win32::LoginName.'@mccann.cz',
        client => Win32::NodeName.'mccann.cz'
      );
      # of course you will use your own mail server here !

   The other options you may set here (or later of course) are
$Mail::Sender::SITE_HEADERS and $Mail::Sender::NO_X_MAILER.

   The $Mail::Sender::SITE_HEADERS may contain headers that will be added
to each mail message sent by this script, the $Mail::Sender::NO_X_MAILER
disables the header item specifying that the message was sent by
Mail::Sender.

   !!! $Mail::Sender::SITE_HEADERS may NEVER end with \r\n !!!

   If you want to set the $Mail::Sender::SITE_HEADERS for every script sent
from your server without your users being able to change it you may use
this hack:

     $loginname = something_that_identifies_the_user();
     eval qq{*Mail::Sender::SITE_HEADERS = 'X-Sender: $loginname via $0'};

   You may even "install" your custom function that will be evaluated for
each message just before contacting the server. You may change all the
options from within as well as stop sending the message.

   All you have to do is to create a function named SiteHook in
Mail::Sender package. This function will get the Mail::Sender object as
its first argument. If it returns a TRUE value the message is sent, if it
returns FALSE the sending is canceled and the user gets "Site specific
error" error message.

   If you want to give some better error message you may do it like this :

     sub SiteHook {
      my $self = shift;
      if (whatever($self)) {
        $self->{'error'} = SITEERROR;
        $Mail::Sender::Error = "I don't like this mail";
        return 0
      } else {
        return 1;
      }
     }

   This example will ensure the from address is the users real address :

     sub SiteHook {
      my $self = shift;
      $self->{fromaddr} = getlogin.'@yoursite.com';
      $self->{from} = getlogin.'@yoursite.com';
      1;
     }

   Please note that at this stage the from address is in two different
object properties.

   $self->{from} is the address as it will appear in the mail, that is it
may include the full name of the user or any other comment ( "Jan Krynicky
<jenda@krynicky.cz>" for example), while the $self->{fromaddr} is realy
just the email address per se and it will be used in conversation with the
SMTP server. It must be without comments ("jenda@krynicky.cz" for example)!

   Without write access to .../lib/Mail/Sender.pm or
.../lib/Mail/Sender.config your users will then be unable to get rid of
this header. Well ... everything is doable, if he's cheeky enough ... :-(

   So if you take care of some site with virtual servers for several
clients and implement some policy via SiteHook() or
$Mail::Sender::SITE_HEADERS search the clients' scripts for "SiteHook" and
"SITE_HEADERS" from time to time. To see who's cheating.

EXAMPLES
========

     use Mail::Sender;

     #$sender = new Mail::Sender { from => 'somebody@somewhere.com',
        smtp => 'ms.chipnet.cz', boundary => 'This-is-a-mail-boundary-435427'};
     # # if you do not care about errors.
     # # otherwise use
     #
     ref ($sender = new Mail::Sender { from => 'somebody@somewhere.com',
           smtp => 'ms.chipnet.cz', boundary => 'This-is-a-mail-boundary-435427'})
     or die "Error($sender) : $Mail::Sender::Error\n";

     $sender->Open({to => 'friend@other.com', subject => 'Hello dear friend'});
     $sender->SendLine("How are you?");
     $sender->SendLine;
     $sender->Send(<<'*END*');
     I've found these jokes.

     Doctor, I feel like a pack of cards.
     Sit down and I'll deal with you later.

     Doctor, I keep thinking I'm a dustbin.
     Don't talk rubbish.

     Hope you like'em. Jenda
     *END*

     $sender->Close;

     $sender->Open({to => 'mama@home.org, papa@work.com',
                    cc => 'somebody@somewhere.com',
                    subject => 'Sorry, I'll come later.'});
     $sender->SendLine("I'm sorry, but due to a big load of work,
        I'll come at 10pm at best.");
     $sender->SendLine("\nHi, Jenda");

     $sender->Close;

     $sender->OpenMultipart({to => 'Perl-Win32-Users@activeware.foo',
                             subject => 'Mail::Sender.pm - new module'});
     $sender->Body;
     $sender->Send(<<'*END*');
     Here is a new module Mail::Sender.
     It provides an object based interface to sending SMTP mails.
     It uses a direct socket connection, so it doesn't need any
     additional program.

     Enjoy, Jenda
     *END*
     $sender->SendFile(
      {description => 'Perl module Mail::Sender.pm',
       ctype => 'application/x-zip-encoded',
       encoding => 'Base64',
       disposition => 'attachment; filename="Sender.zip"; type="ZIP archive"',
       file => 'sender.zip'
      });
     $sender->Close;

     _END_

   If everything you need is to send a simple message you may use:

     use Mail::Sender;

     ref ($sender = new Mail::Sender({from => 'somebody@somewhere.com',smtp
     => 'ms.chipnet.cz'})) or die "$Mail::Sender::Error\n";

     (ref ($sender->MailMsg({to =>'Jenda@Krynicky.cz', subject => 'this is a test',
                             msg => "Hi Johnie.\nHow are you?"}))
      and print "Mail sent OK."
     )
     or die "$Mail::Sender::Error\n";
     __END__

   If you want to attach some files:

     use Mail::Sender;

     ref ($sender = new Mail::Sender({from => 'somebody@somewhere.com',smtp
     => 'mail.yourdomain.com'})) or die "$Mail::Sender::Error\n";

     (ref ($sender->MailFile(
      {to =>'you@address.com', subject => 'this is a test',
       msg => "Hi Johnie.\nI'm sending you the pictures you wanted.",
       file => 'image1.jpg,image2.jpg'
      }))
      and print "Mail sent OK."
     )
     or die "$Mail::Sender::Error\n";
     __END__

   If you want to send a HTML mail:

     use Mail::Sender;
     open IN, $htmlfile or die "Cannot open $htmlfile : $!\n";
     $sender = new Mail::Sender {smtp => 'mail.yourdomain.com'};
     $sender->Open({ from => 'your@address.com', to => 'other@address.com', subject => 'HTML test',
            headers => "MIME-Version: 1.0\r\nContent-type: text/html\r\nContent-Transfer-Encoding: 7bit"
     }) or die $Mail::Sender::Error,"\n";

     while (<IN>) { $sender->Send($_) };
     close IN;
     $sender->Close();
     __END__

   If you want to send a HTML with some inline images :

     use strict;
     use Mail::Sender;
     my $recipients = 'somebody@somewhere.com';
     my $sender = new Mail::Sender {smtp => 'your.mailhost.com'};
     if ($sender->OpenMultipart({from => 'itstech2@gate.net', to => $recipients,
                           subject => 'Embedded Image Test', subtype => 'related',
                           boundary => 'boundary-test-1',
                           type => 'multipart/related'}) > 0) {
      $sender->SendFile(
             {description => 'html body',
             ctype => 'text/html; charset=us-ascii',
             encoding => '7bit',
             disposition => 'NONE',
             file => 'test.html'
       });
      $sender->SendFile(
       {description => 'ed\'s gif',
        ctype => 'image/gif',
        encoding => 'base64',
        disposition => "inline; filename=\"apache_pb.gif\";\r\nContent-ID: <ed1>",
        file => 'apache_pb.gif'
       });
      $sender->Close() or die "Close failed! $Mail::Sender::Error\n";
     } else {
      die "Cannot send mail: $Mail::Sender::Error\n";
     }
     __END__

   In the HTML you'll have this :  ... <IMG src="cid:ed1"> ...

   Please keep in mind that the image name is unimportant, the Content-ID
is what counts!

   If you want to send a mail with an attached file you just got from a
HTML form:

     #!perl

     use CGI;
     use Mail::Sender;

     $query = new CGI;

     # uploading the file...
     $filename = $query->param('mailformFile');
     if ($filename ne ""){
      $tmp_file = $query->tmpFileName($filename);
     }

     $sender = new Mail::Sender {from => 'script@mccann.cz',smtp => 'mail.mccann.cz'};
     $sender->OpenMultipart({to=> 'jenda@mccann.cz',subject=> 'test CGI attach'});
     $sender->Body();
     $sender->Send(<<"*END*");
     This is just a test of mail with an uploaded file.

     Jenda
     *END*
     $sender->SendFile(
              {encoding => 'Base64',
        description => $filename,
        ctype => $query->uploadInfo($filename)->{'Content-Type'},
        disposition => "attachment; filename = $filename",
               file => $tmp_file
              });
     $sender->Close();

     print "Content-type: text/plain\n\nYes, it's sent\n\n";

WARNING
-------

   DO NOT mix Open(Multipart)|Send(Line)(Ex)|Close with MailMsg or
MailFile.  Both Mail(Msg/File) close any Open-ed mail.  Do not try this:

     $sender = new Mail::Sender ...;
     $sender->OpenMultipart...;
     $sender->Body;
     $sender->Send("...");
     $sender->MailFile({file => 'something.ext');
     $sender->Close;

   This WON'T work!!!

BUGS
====

   This module (as well as those I used as an example when I wrote it)
doesn't work with qmail.  To make this clear, the local SMTP server you
contact directly from the script (Open({smtp => ...})) may not be qmail.
The problem is that the module expects a one-line response from the server
and gets confused if it gets a longer response.  If you set up qmail to
send only one-line responses you shell be OK.  Otherwise you need to use a
different SMTP server. Sorry, I'll fix this as soon as I have some spare
time.

DISCLAIMER
==========

   This module is based on SendMail.pm Version : 1.21 that appeared in
Perl-Win32-Users@activeware.com mailing list. I don't remember the name of
the poster and it's not mentioned in the script. Thank you mr. undef.

AUTHOR
======

   Jan Krynicky <Jenda@Krynicky.cz>

   With help of Rodrigo Siqueira <rodrigo@insite.com.br>, Ed McGuigan
<itstech1@gate.net>, and others.

COPYRIGHT
=========

   Copyright (c) 1997-1999 Jan Krynicky <Jenda@Krynicky.cz>. All rights
reserved.

   This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


