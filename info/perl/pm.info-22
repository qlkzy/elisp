This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Apache/HeavyCGI/Date,  Next: Apache/HeavyCGI/Debug,  Prev: Apache/HeavyCGI,  Up: Module List

represent a date as both unix time and HTTP time
************************************************

NAME
====

   Apache::HeavyCGI::Date - represent a date as both unix time and HTTP
time

SYNOPSIS
========

     my $date = Apache::HeavyCGI::Date->new;

     $date->unix(time);   # set
     print $date->unix;   # get
     print $date->http;   # get as http
     print $date;         # same thing due to overloading

DESCRIPTION
===========

   This class implements a simple dual value date variable. There are only
two accessor methods that let you set and get dates. unix() sets and gets
the UNIX time, and http() gets and sets the HTTP time.  Whenever a time is
set the other time gets undefined. Retrieving an undefined time triggers a
conversion from the other time. That way the two times are always synced.

PREREQUISITES
=============

   The class uses HTTP::Date internally.

AUTHOR
======

   andreas koenig <andreas.koenig@anima.de>


File: pm.info,  Node: Apache/HeavyCGI/Debug,  Next: Apache/HeavyCGI/Exception,  Prev: Apache/HeavyCGI/Date,  Up: Module List

inspect the Pseudohash as Hash with Data::Dumper
************************************************

NAME
====

   Apache::HeavyCGI::Debug - inspect the Pseudohash as Hash with
Data::Dumper

SYNOPSIS
========

     push @layout, "<BR><PRE>",
                   $self->instance_of("Apache::HeavyCGI::Debug"),
                   "</PRE><BR>\n";

DESCRIPTION
===========

   Can be used to inspect the application object within an output page.
The Class is just implemented as an illustration.


File: pm.info,  Node: Apache/HeavyCGI/Exception,  Next: Apache/HeavyCGI/ExePlan,  Prev: Apache/HeavyCGI/Debug,  Up: Module List

exception class for Apache::HeavyCGI
************************************

NAME
====

     Apache::HeavyCGI::Exception - exception class for Apache::HeavyCGI

SYNOPSIS
========

     die Apache::HeavyCGI::Exception->new(HTTP_STATUS => status);
     die Apache::HeavyCGI::Exception->new(ERROR => [error, ...]);

DESCRIPTION
===========

   The execution of the Apache::HeavyCGI::prepare method is protected by
an eval. Within that block the above mentioned exceptions can be thrown.
For a discussion of the semantics of these errors, see *Note
Apache/HeavyCGI: Apache/HeavyCGI,.

   You need not require the Apache::HeavyCGI::Error module, it is already
required by Apache::HeavyCGI.


File: pm.info,  Node: Apache/HeavyCGI/ExePlan,  Next: Apache/HeavyCGI/IfModified,  Prev: Apache/HeavyCGI/Exception,  Up: Module List

Creates an execution plan for Apache::HeavyCGI
**********************************************

NAME
====

   Apache::HeavyCGI::ExePlan - Creates an execution plan for
Apache::HeavyCGI

SYNOPSIS
========

     use Apache::HeavyCGI::ExePlan;
     my $plan = Apache::HeavyCGI::ExePlan->new(
        METHODS => ["header", "parameter"],
        CLASSES => ["my_application::foo", "my_application::bar", ... ]
        DEBUG    => 1
     );

     $plan->walk;

DESCRIPTION
===========

   When an execution plan object is instantiated, it immediately visits
all specified classes, collects the singleton objects for these classes,
and checks if the classes define the specified methods. It creates an
array of objects and methods or an array of code references.

   The walk method walks through the execution plan in the stored order
and sends each singleton object the appropriate method and passes the
application object as the first argument.

   Normally, every application has its own execution plan. If the
execution plan is calculated at load time of the application class, all
objects of this class can share a common execution plan, thus speeding up
the requests. Consequently it is recommended to have an initialization in
all applications that instantiates an execution plan and passes it to all
application objects in the constructor.

   head1 BUGS

   It's not a bug, it's a feature: if new methods and classes are
dynamically created in an application, the execution plan object won't
take note.


File: pm.info,  Node: Apache/HeavyCGI/IfModified,  Next: Apache/HeavyCGI/Layout,  Prev: Apache/HeavyCGI/ExePlan,  Up: Module List

Within Apache::HeavyCGI return 304
**********************************

NAME
====

   Apache::HeavyCGI::IfModified - Within Apache::HeavyCGI return 304

SYNOPSIS
========

     require Apache::HeavyCGI::IfModified;
     push @{$mgr->{HANDLER}},
         "Apache::HeavyCGI::IfModified"; # $mgr is an Apache::HeavyCGI object

DESCRIPTION
===========

   If-modified-since is tricky. We have pages with very differing last
modification. Some are modified NOW, some are old, most are MADE now but
would have been just the same many hours ago.

   Because it's the recipe that is used for the composition of a page, it
may well be that a page that has never been generated before, nonetheless
has a Last-Modified date in the past. The Last-Modified header acts as a
weak validator for cache activities, and the older a document appears to
be, the longer the cache will store it for us by default. When the cache
revisits us after it has got a valid Last-Modified header, it will use an
If-Modified-Since header and if we carefully determine our own
Last-Modified time, we can spare a lot of processing by returning a Not
Modified response instead of working.

   IfModified should be one of the last handlers in any Apache::HeavyCGI
environment, at least it must be processed after all the handlers that
might set the LAST_MODIFIED date.


File: pm.info,  Node: Apache/HeavyCGI/Layout,  Next: Apache/HeavyCGI/SquidRemoteAddr,  Prev: Apache/HeavyCGI/IfModified,  Up: Module List

Represent a page layout in an array
***********************************

NAME
====

   Apache::HeavyCGI::Layout - Represent a page layout in an array

SYNOPSIS
========

     my $layout = Apache::HeavyCGI::Layout->new(@array);

     $layout->prejoin;  # make the array more compact

     my @array = $layout->content;
     my $string = $layout->as_string($object);

DESCRIPTION
===========

   The constructor new() takes as an argument an array of elements.
Elements may be strings and objects in any order.

   The content() method returns the array of elements.

   The prejoin() method joins adjacent string elements, leaving at most
one string element between objects in the array.

   The as_string() method takes an object, say $mgr, as an argument and
joins all elements of the array such that all chunks that represent an
object are called with

     $chunk->as_string($mgr)

   and all chunks that represent a string are fillers in between. Objects
that do not understand the as_string method are just filled in as strings,
leaving room for debugging or overloading or whatever.


File: pm.info,  Node: Apache/HeavyCGI/SquidRemoteAddr,  Next: Apache/HeavyCGI/UnmaskQuery,  Prev: Apache/HeavyCGI/Layout,  Up: Module List

Pass X-Forwarded-For Header through as remote_ip
************************************************

NAME
====

   Apache::HeavyCGI::SquidRemoteAddr - Pass X-Forwarded-For Header through
as remote_ip

SYNOPSIS
========

     PerlPostReadRequestHandler  Apache::HeavyCGI::SquidRemoteAddr

DESCRIPTION
===========

   Author Vivek Khera, taken from his mod_perl_tuning document.


File: pm.info,  Node: Apache/HeavyCGI/UnmaskQuery,  Next: Apache/Htaccess,  Prev: Apache/HeavyCGI/SquidRemoteAddr,  Up: Module List

Allow queries without a questionmark
************************************

NAME
====

   Apache::HeavyCGI::UnmaskQuery - Allow queries without a questionmark

SYNOPSIS
========

     <Perl>
     require Apache::HeavyCGI::UnmaskQuery;
     $PerlPostReadRequestHandler = "Apache::HeavyCGI::UnmaskQuery";
     </Perl>

     -or-

     PerlModule Apache::HeavyCGI::UnmaskQuery
     PerlPostReadRequestHandler Apache::HeavyCGI::UnmaskQuery

DESCRIPTION
===========

   This Apache Handler can be used from apache 1.3 (when post_read_request
was introduced) upwards to turn a request that looks like an ordinary
static request to the unsuspecting observer into a query that can be
handled by the CGI or Apache::Request module or by the $r->args method.

   The reason why you might want to do this lies in the fact that many
cache servers in use today (1999) are configured wrongly in that they
disallow caching of URIs with a questionmark in them. By composing URIs
with a semicolon instead of a questionmark, these cache servers can be
tricked into working correctly.

   Thus this handler replaces the first semicolon in any request for an
URI with a questionmark (unless that URI does already contain a
questionmark). As this is being done in the very early stage of apache's
handling phase, namely in a PerlPostReadRequestHandler, all subsequent
phases can be tricked into seeing the request as a query.

   Unfortunately the last paragraph is not completely true. Apache 1.3.4
is not allowing `%2F' (a slash in ASCII) and `%00' (a binary 0) in the
path section of the HTTP URI, only in the *searchoart* section. Apparently
the URL is parsed before the during read_request....

     Breakpoint 1, 0x80b9d05 in ap_unescape_url ()
     (gdb) bt
     #0  0x80b9d05 in ap_unescape_url ()
     #1  0x80b5a56 in ap_some_auth_required ()
     #2  0x80b5fb0 in ap_process_request ()
     #3  0x80adbcd in ap_child_terminate ()
     #4  0x80add58 in ap_child_terminate ()
     #5  0x80adeb3 in ap_child_terminate ()
     #6  0x80ae490 in ap_child_terminate ()
     #7  0x80aecc3 in main ()
     (gdb) c

   So if any parameter needs to contain a slash or a binary 0, we must
resort to a different escape method. Now it's turning ridiculous quickly.
I believe, this is a bug in apache and must be fixed there. But what if
the apche group doesn't listen to us?

   Easy answer: don't escape slashes if you want to use this technique.
Don't dare to need binary nulls in your parameters. Until it is figured
out if apache group sees this as a bug or not.


File: pm.info,  Node: Apache/Htaccess,  Next: Apache/Htgroup,  Prev: Apache/HeavyCGI/UnmaskQuery,  Up: Module List

Create and modify Apache .htaccess files
****************************************

NAME
====

   Apache::Htaccess - Create and modify Apache .htaccess files

SYNOPSIS
========

     use Apache::Htaccess;

     my $obj = Apache::Htaccess->new("htaccess");
     die($Apache::Htaccess::ERROR) if $Apache::Htaccess::ERROR;

     $obj->global_requires(@groups);

     $obj->add_global_require(@groups);

     $obj->directives(CheckSpelling => 'on');

     $obj->add_directive(CheckSpelling => 'on');
     
     $obj->requires('admin.cgi',@groups);

     $obj->add_require('admin.cgi',@groups);

     $obj->save();
     die($Apache::Htaccess::ERROR) if $Apache::Htaccess::ERROR;

DESCRIPTION
===========

   This module provides an OO interface to Apache .htaccess files.
Currently the ability exists to read and write simple htaccess files.

AUTHOR
======

   Matt Cashner <matt@cre8tivegroup.com>

COPYRIGHT
=========

   All code is copyright (c) 2000 by The Creative Group. It may be
distributed under the terms of Perl itself.

METHODS
=======

new()
-----

     my $obj = Apache::Htaccess->new($path_to_htaccess);

   Creates a new Htaccess object either with data loaded from an existing
htaccess file or from scratch

save()
------

     $obj->save();

   Saves the htaccess file to the filename designated at object creation.
This method is automatically called on object destruction.

global_requires()
-----------------

     $obj->global_requires(@groups);

   Sets the global group requirements. If no params are provided, will
return a list of the current groups listed in the global require. Note: as
of 0.3, passing this method a parameter list causes the global requires
list to be overwritten with your parameters. see `add_global_require()' in
this node.

add_global_require()
--------------------

     $obj->add_global_require(@groups);

   Sets a global require (or requires) nondestructively. Use this if you
just want to add a few global requires without messing with all of the
global requires entries.

requires()
----------

     $obj->requires($file,@groups);

   Sets a group requirement for a file. If no params are given, returns a
list of the current groups listed in the files require directive.  Note:
as of 0.3, passing this method a parameter list causes the requires list
to be overwritten with your parameters. see `add_require()' in this node.

add_require()
-------------

     $obj->add_require($file,@groups);

   Sets a require (or requires) nondestructively. Use this if you just
want to add a few requires without messing with all of the requires
entries.

directives()
------------

     $obj->directives(CheckSpelling => 'on');

   Sets misc directives not directly supported by the API. If no params
are given, returns a list of current directives and their values. Note: as
of 0.2, passing this method a parameter list causes the directive list to
be overwritten with your parameters. see `add_directive()' in this node.

add_directive()
---------------

     $obj->add_directive(CheckSpelling => 'on');

   Sets a directive (or directives) nondestructively. Use this if you just
want to add a few directives without messing with all of the directive
entries.

HISTORY
=======

     $Log: Htaccess.pm,v $
     Revision 1.13  2000/09/29 16:22:46  matt
     fixed bug in parser that caused global_reqs to be dumped. ARGH
     
     Revision 1.12  2000/09/29 15:51:04  matt
     added global ERROR variable, changed global_require() to global_requires()
     
     Revision 1.11  2000/09/29 15:36:53  matt
     think i finally squashed the undef problem with requires()
     
     Revision 1.10  2000/09/29 15:20:36  matt
     made global_requires destructive and created add_global_require(), added better error responses to new() and save()
     
     Revision 1.9  2000/09/29 14:31:35  matt
     added new methods to the synopsis
     
     Revision 1.8  2000/09/29 14:25:46  matt
     made requires nondestructive and added add_require()
     
     Revision 1.7  2000/09/29 12:50:11  matt
     made directives() destructive and created the add_directive method()
     
     Revision 1.6  2000/09/27 18:43:23  matt
     added more return values. its amazing the little things i forget
     
     Revision 1.5  2000/09/27 18:30:34  matt
     fixed silly pod problem
     
     Revision 1.4  2000/09/27 18:23:46  matt
     added useful return values to save().
     
     Revision 1.3  2000/09/27 18:19:34  matt
     parse now works and can parse htaccess files the module has created (or very similar files). added more docs
     
     Revision 1.2  2000/09/27 14:19:26  matt
     deparse now working, additional docs added
     
     Revision 1.1  2000/09/26 21:20:24  matt
     first nonfunctional version :)  data structures are set up and accessor methods to those structures are ready. input and output of the file (note: the useful sections) are not yet written.


File: pm.info,  Node: Apache/Htgroup,  Next: Apache/Htpasswd,  Prev: Apache/Htaccess,  Up: Module List

Manage Apache authentication group files
****************************************

NAME
====

   Apache::Htgroup - Manage Apache authentication group files

SYNOPSIS
========

     use Apache::Htgroup;
     $htgroup = Apache::Htgroup->load($path_to_groupfile);
     &do_something if $htgroup->ismember($user, $group);
     $htgroup->adduser($user, $group);
     $htgroup->deleteuser($user, $group);
     $htgroup->save;

Important notes about versions 1.x
==================================

   There has been a change to the API since the 0.9 version. The 0.9
version sucked a lot, and this should be a big improvement in a lot of
ways. Please feel free to contact me and yell at me about these changes if
you like. If there are enough complaints, I'll try to make it backward
compatible. However, given a little work, I think you'll find the new
version superior in every way.

DESCRIPTION
===========

   Manage Apache htgroup files

   Please note that this is not a mod_perl module. Please also note that
there is another module that does similar things (HTTPD::UserManage) and
that this is a more simplistic module, not doing all the things that one
does.

   Please also note that, in contrast to Version 0.9, changes to the
object are only saved to disk when you call the save method.

load
          $htgroup = Apache::Htgroup->load($path_to_groupfile);
               $htgroup = Apache::Htgroup->new();

     Returns an Apache::Htgroup object.

     Calling new() without an argument creates an empty htgroup object
     which you can save to a file once you're done with it.

adduser
          $htgroup->adduser( $username, $group );

     Adds the specified user to the specified group.

deleteuser
          $htgroup->deleteuser($user, $group);

     Removes the specified user from the group.

groups
          $groups = $htgroup->groups;

     Returns a (reference to a) hash of the groups. The key is the name of
     the group. Each value is a hashref, the keys of which are the group
     members. I suppose there may be some variety of members method in the
     future, if anyone thinks that would be useful.

     It is expected that this method will not be called directly, and it
     is provided as a convenience only.

     Please see the section below about internals for an example of the
     data structure.

reload
          $self->reload;

     If you have not already called save(), you can call reload() and get
     back to the state of the object as it was loaded from the original
     file.

save
          $htgroup->save;
               $htgroup->save($file);

     Writes the current contents of the htgroup object back to the file.
     If you provide a $file argument, save will attempt to write to that
     location.

ismember
          $foo = $htgroup->ismember($user, $group);

     Returns true if the username is in the group, false otherwise

Internals
=========

   Although this was not the case in earlier versions, the internal data
structure of the object looks something like the following:

     $obj = { groupfile => '/path/to/groupfile',
              groups => { group1 => { 'user1' => 1,
                                      'user2' => 1,
                                      'user3' => 1
                                    },
                          group2 => { 'usera' => 1,
                                      'userb' => 1,
                                      'userc' => 1
                                    },
                        }
            };

   Note that this data structure is subject to change in the future, and
is provided mostly so that I can remember what the heck I was thinking
when I next have to look at this code.

Adding groups
=============

   A number of folks have asked for a method to add a new group. This is
unnecessary. To add a new group, just start adding users to a new group,
and the new group will magically spring into existance.

ToDo
====

   Need to add a decent test suite, but apart from that, I think that this
is pretty good.

AUTHOR
======

   Rich Bowen, rbowen@rcbowen.com

HISTORY
=======

     $Log: Htgroup.pm,v $
     Revision 1.14  2001/02/24 21:27:50  rbowen
     Added space between "group:" and the first user, as per the documentation.

     Revision 1.13  2001/02/23 04:13:12  rbowen
     Apparently Perl 5.005_02 was getting grumpy about my use of $Revision: 1.14 $
     to set the VERSION number. Fixed.

     Revision 1.12  2001/02/23 03:16:58  rbowen
     Fixed bug in reload that was effectively breaking everything else.
     It would let you build files from scratch, but not load existing
     files correctly. Added test suite also, which should help

     Revision 1.11  2001/02/21 03:14:04  rbowen
     Fixed reload to work as advertised. groups now calls reload internally
     the first time you call it.

     Version 0.9 -> 1.10 contains a number of important changes.
     As mentioned above, the API has changed, as well as the internal
     data structure. Please read the documentation very carefully.


File: pm.info,  Node: Apache/Htpasswd,  Next: Apache/Icon,  Prev: Apache/Htgroup,  Up: Module List

Manage Unix crypt-style password file.
**************************************

NAME
====

   Apache::Htpasswd - Manage Unix crypt-style password file.

SYNOPSIS
========

     use Apache::Htpasswd;

     $foo = new Apache::Htpasswd("path-to-file");

     # Add an entry
     $foo->htpasswd("zog", "password");

     # Change a password
     $foo->htpasswd("zog", "new-password", "old-password");
     
     # Change a password without checking against old password
     # The 1 signals that the change is being forced.
     
     $foo->htpasswd("zog", "new-password", 1);
     
     # Check that a password is correct
     $pwdFile->htCheckPassword("zog", "password");

     # Fetch an encrypted password
     $foo->fetchPass("foo");
     
     # Delete entry
     $foo->htDelete("foo");

     # If something fails, check error
     $foo->error;

     # Write in the extra info field
     $foo->writeInfo("login", "info");

     # Get extra info field for a user
     $foo->fetchInfo("login");

DESCRIPTION
===========

   This module comes with a set of methods to use with htaccess password
files. These files (and htaccess) are used to do Basic Authentication on a
web server.

   The passwords file is a flat-file with login name and their associated
crypted password. You can use this for non-Apache files if you wish, but
it was written specifically for .htaccess style files.

FUNCTIONS
---------

htaccess->new("path-to-file");
     "path-to-file" should be the path and name of the file containing the
     login/password information.

error;
     If a method returns an error, or a method fails, the error can be
     retrived by calling error()

htCheckPassword("login", "password");
     Finds if the password is valid for the given login.

     Returns 1 if passes.  Returns 0 if fails.

htpasswd("login", "password");
     This will add a new user to the password file.  Returns 1 if succeeds.
     Returns undef on failure.

htDelete("login")
     Delete users entry in password file.

     Returns 1 on success Returns undef on failure.

htpasswd("login", "new-password", "old-password");
     If the *old-password* matches the *login's* password, then it will
     replace it with *new-password*. If the *old-password* is not correct,
     will return 0.

htpasswd("login", "new-password", 1);
     Will replace the password for the login. This will force the password
     to be changed. It does no verification of old-passwords.

     Returns 1 if succeeds Returns undef if fails

fetchPassword("login");
     Returns *encrypted* password if succeeds.  Returns 0 if login is
     invalid.  Returns undef otherwise.

fetchInfo("login");
     Returns additional information if succeeds.  Returns 0 if login is
     invalid.  Returns undef otherwise.

writeInfo("login", "info");
     Will replace the additional information for the login.  Returns 0 if
     login is invalid.  Returns undef otherwise.

CryptPasswd("password", "salt");
     Will return an encrypted password using 'crypt'. If *salt* is
     ommitted, a salt will be given by the subroutine using the first 2
     character of $0.

INSTALLATION
============

   You install Apache::Htpasswd, as you would install any perl module
library, by running these commands:

     perl Makefile.PL
     make
     make test
     make install
     make clean

DOCUMENTATION
=============

   POD style documentation is included in the module.  These are normally
converted to manual pages and installed as part of the "make install"
process.  You should also be able to use the 'perldoc' utility to extract
and read documentation from the module files directly.

AVAILABILITY
============

   The latest version of Apache::Htpasswd should always be available from:

     $CPAN/modules/by-authors/id/K/KM/KMELTZ/

   Visit <URL:http://www.perl.com/CPAN/> to find a CPAN site near you.

VERSION
=======

   $Revision: 1.3 $ $Date: 2000/04/04 15:00:13 $

CHANGES
=======

   $Log: Htpasswd.pm,v $

   Revision 1.4  2001/02/23 08:23:46 kevin Added support for extra info
fields

   Revision 1.3  2000/04/04 15:00:15 meltzek Made file locking safer to
avoid race conditions. Fixed typo in docs.

   Revision 1.2  1999/01/28 22:43:45  meltzek Added slightly more verbose
error croaks. Made sure error from htCheckPassword is only called when
called directly, and not by $self.

   Revision 1.1  1998/10/22 03:12:08  meltzek Slightly changed how files
lock.  Made more use out of carp and croak.  Made sure there were no ^M's
as per Randal Schwartz's request.

BUGS
====

   None knows at time of writting.

AUTHOR INFORMATION
==================

   Copyright 1998..2001, Kevin Meltzer.  All rights reserved.  It may be
used and modified freely, but I do request that this copyright notice
remain attached to the file.  You may modify this module as you wish, but
if you redistribute a modified version, please attach a note listing the
modifications you have made.

   This is released under the same terms as Perl itself.

   Address bug reports and comments to: perlguy@perlguy.com

   The author makes no warranties, promises, or gaurentees of this
software. As with all software, use at your own risk.

SEE ALSO
========

   *Note Apache/Htgroup: Apache/Htgroup,


File: pm.info,  Node: Apache/Icon,  Next: Apache/Include,  Prev: Apache/Htpasswd,  Up: Module List

Lookup icon images
******************

NAME
====

   Apache::Icon - Lookup icon images

SYNOPSIS
========

     use Apache::Icon ();
     my $icon = Apache::Icon->new($subr);
     my $img = $icon->find || $icon->default;
     my $alt = $icon->alt;

DESCRIPTION
===========

   This module rips out the icon guts of mod_autoindex and provides a Perl
interface for looking up icon images.  The motivation is to piggy-back the
existing AddIcon and related directives for mapping file extensions and
names to icons, while keeping things as small and fast as mod_autoindex
does.

METHODS
=======

new
     Create a new *Apache::Icon* object with the given *Apache::SubRequest*
     object.  Example:

          for my $entry (sort $dh->read) {
          	next if $entry eq '.';
          	my $subr = $r->lookup_file($entry);
              my $icon = Apache::Icon->new($subr);
          	...

find
     Lookup icon image associated with the subrequest.

          my $img = $icon->find;

default
     Lookup the default icon images.

          my $img = $icon->default; #DefaultIcon (unknown.gif)
          my $img = $icon->default("^^DIRECTORY^^"); #folder.gif
          my $img = $icon->default("^^BLANKICON^^"); #blank.gif

alt
     Lookup the text alternative specified by the AddAlt directive.

          my $alt = $icon->alt || $img;

DIRECTIVES
==========

   Refer to the *mod_autoindex* documentation for directives listed here
with no description.

IconDouble
     This directive can be set to On or *Off*.  The default is On if
     *mod_autoindex* is configured with the server, *Off* otherwise.  When
     the directive is On, *mod_icon* directive handlers will return
     *DECLINE_CMD* after processing which allows *mod_autoindex* to also
     handle the various Icon and *Alt* directives.

AddIcon
AddIconByType
AddIconByEncoding
AddAlt
AddAltByType
AddAltByEncoding
DefaultIcon
SEE ALSO
========

   Apache::AutoIndex(3)

AUTHOR
======

   Doug MacEachern

   C code based on mod_autoindex by the Apache Group


File: pm.info,  Node: Apache/Include,  Next: Apache/Keywords,  Prev: Apache/Icon,  Up: Module List

Utilities for mod_perl/mod_include integration
**********************************************

NAME
====

   Apache::Include - Utilities for mod_perl/mod_include integration

SYNOPSIS
========

     <!--#perl sub="Apache::Include" arg="/perl/ssi.pl" -->

DESCRIPTION
===========

   The *Apache::Include* module provides a handler, making it simple to
include Apache::Registry scripts with the mod_include perl directive.

   Apache::Registry scripts can also be used in mod_include parsed
documents using 'virtual include'.

METHODS
=======

Apache::Include->virtual($uri)
     The `virtual' method may be called to include the output of a given
     uri in your Perl scripts.  Example:

          use Apache::Include ();

          print "Content-type: text/html\n\n";

          print "before include\n";

          my $uri = "/perl/env.pl";

          Apache::Include->virtual($uri);

          print "after include\n";

SEE ALSO
========

   perl(1), mod_perl(3), mod_include

AUTHOR
======

   Doug MacEachern


File: pm.info,  Node: Apache/Keywords,  Next: Apache/Language,  Prev: Apache/Include,  Up: Module List

Store keywords as a personal profile in a cookie.
*************************************************

NAME
====

   Apache::Keywords - Store keywords as a personal profile in a cookie.

CONTENTS
========

   The package Apache::Keywords contains:

     Makefile.PL
     lib/Apache/Keywords.pm
     README
     MANIFEST

PREREQUISITES
=============

   You need Apache::Constants and Apache::Cookie to use Apache::Keywords.

INSTALLATION
============

     tar zxf Apache-Keywords-0.1.tar.gz
     perl Makefile.PL
     make
     make install

SYNOPSIS
========

   In a dynamic mod_perl source-file:

     use Apache::Keywords;

     # Create a keywords object
     $k = new Apache::Keywords;

     # Set different parameters
     $k->name('PersonalProfile');
     $k->expires('+1M');
     $k->path("/");
     $k->domain('xxx.com');

     # Get parameters
     print $k->expires;
     print $k->path;
     ...

     # Add new keywords to the profile
     $k->new_keywords($r,"horse, dog");
     # Special version for Apache::ASP
     $k->new_keywords_asp($Request,"cars, motorcycles");

     # Return the content of the cookie profile
     $hashref = $k->profile($r);
     print $hashref->{'horse'};
     %hash = %$hashref;
     # Special version for Apache::ASP
     $k->profile_asp($Request);

   In a the .htaccess for apache static-files, e.g. .html-files:
<Files ~ (\.html)>         SetHandler perl-script         PerlFixupHandler
Apache::Keywords         PerlSetVar KeywordsName "PersonalProfile"
PerlSetVar KeywordsExpires "+1M"         PerlSetVar KeywordsPath "/"
 PerlSetVar KeywordsDomain "xxx.com"     </Files>

DESCRIPTION
===========

   An Apache::Keywords class object will generate/update a cookie. The
cookie contains a personal profile, e.g. counts the different keywords
that are added to it. The module could be configured as a
"PerlFixupHandler" for a static file in mod_perl, e.g. HTML-files. It
could also be used in web scripts, like mod_perl scripts that uses
Apache::ASP or Apache::Registry. In the static version, Apache::Keywords
fetches the keywords from phrases like <META NAME="keywords"
CONTENT="cars, motorcycles">.

METHODS
=======

   The following methods could be use in dynamic web scripts:

$k = new Apache::Keywords;
     Make a new Apache::Keywords object and return it.

$k->name(<name>);
     Sets the name of the cookie that is used for the personal profile.
     Without argument, the function returns the name of the cookie.

$k->expires(<expiration time>);
     Sets the cookie parameter for expiration. Without argument, the
     function returns the expiration time already set.

$k->path(<path>);
     Sets the path to be associated with the cookie. Without argument, the
     function returns the path already set.

$k->domain(<domain name>);
     Sets the domain name to be associated with the cookie.  Without
     argument, the function returns the domain name already set.

$k->new_keywords($r,<string with keywords>);
     Add the new keywords of this HTTP-call. The argument is a string with
     the different words separated with space. $r is the Apache mod_perl
     request object.

$k->new_keywords_asp($Request,<string with keywords>);
     A special version of new_keywords() suited for Apache::ASP. The
     $Request object is special for Apache::ASP.

$k->profile;
     Return the profile in a hash reference, e.g. profile->{'horse'} == 3,
     profile->{'dog'} == 2.

$k->profile_asp
     A special version of profile() suited for Apache::ASP. The $Request
     is special for Apache::ASP.

AUTHOR
======

   Copyright 2000 Magnus Cedergren, mace@lysator.liu.se

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Apache/Language,  Next: Apache/Language/Constants,  Prev: Apache/Keywords,  Up: Module List

Perl transparent language support for Apache modules and mod_perl scripts
*************************************************************************

NAME
====

   Apache::Language - Perl transparent language support for Apache modules
and mod_perl scripts

SYNOPSIS
========

     In YourModule.pm:
     
     sub handler {
     my $r = shift;
     use Apache::Language;
     my $lang = Apache::Language->new($extra_args);
     #$lang is now a hash ref that will automacigally pick the right language
     
     print $lang->{'Error01'} if exists $lang->{'Error01'};
     
     foreach ( keys %$lang ){
       print "$_ is " . $lang->{$_};
       }
     
     [...]
     }

DESCRIPTION
===========

   The goal of this module is to provide a simple way for mod_perl module
writers to include support for multiple language requests.

   This is version 0.03, and it's a complete rewrite from the ground-up of
the previous release.  It's still backward-compatible with the other
releases, but now it's much more advanced.

   An Apache::Language object acts like a language-aware hash.  It stores
key/language/values triplets. Using the Accept-Language: field sent by the
web-client, it can pick the best fit language for that specific client.
It's usage is transparent and should prove to be quite convenient (and
hopefully, efficient).

   The method used to store/fetch information is now completely modular
and will allow easy creation of new storage methods thru a simple API (see
the API section).

BASIC USAGE EXAMPLE
-------------------

   This section will describe the easiest way to start using
Apache::Language.

   Apache::Language is used to create a hash that will contain
key/language/value triplets.  Say you are building a module that prints a
few error messages, but since your users speak 3 different languages, you'd
like your module to be nice to them and print the messages in their native
language.

   For this approach to work, a few things are needed.  First, the client
software (Netscape/IE/lynx, etc.) should send an Accept-Language: header
telling the webserver what languages it's user understands.  This might
sound simple, but as a web-surfer, did you set that language setting in
your browser?  Most likely, you didn't.  So the first step is to correctly
configure your browser and try to make sure your users/visitors will have
done the same, or they might not get what you want them to read.

   Secondly, you must store the messages you want to display in each
avaliable languages.  For this example, we will use the default
LanguageHandler Apache::Language::PlainFile that ships with this
distribution.  To do that, suppose your module is named Apache::MyModule
and it's stored in a file named MyModule.pm.  You will only need to edit a
file named MyModule.dic in the same place your module is stored.  The
format of that file is : (for more information see *Note
Apache/Language/PlainFile: Apache/Language/PlainFile,(3)).

     error01:en

     Error Message 01

     error01:fr

     Message d'erreur 01

     error02:en

     Error Message 02

   Once that file contains your error messages, you're all set.  Just add
this to the top of your module:

     use Apache::Language
     my $lang = Apache::Language::new($extra_args)

   Then $lang will be a language-enabled hash reference that you can use
like this:

     print $lang->{error01}

   That line will print your error message 01 in the best language for the
client that your module served. Of course, there are a lot more things you
can do with Apache::Language.  All these features are explained below.

DETAILLED USAGE
===============

   The key to using Apache::Language is to understand the the data
retrieving/storing is now done in a manner similar to mod_perl content
handlers.  That's why I called them Language Handlers.  A language handler
is a perl module that is specialized in storing/fetching
key/language/values triplets.

   Apache::Language simply manages those modules and makes interaction
with other modules painless.  For every request, Apache::Language
maintains a stack of the LanguageHandlers configured for that request's
location.  Asking each of them in order to try finding a value for the
requested key that would satisfy the client acceptable languages.

   That way you can have a number of language handlers, one looking up in
a system-wide dictionnary, one looking up in a module-specific dictionnary
and one looking up a RDBM.  Each of them would be queried until an
acceptable response is found.  This makes maintaining language definitions
pretty versatile and configurable.

   With this package is shipped 2 basic LanguageHandlers: *Note
Apache/Language/PlainFile: Apache/Language/PlainFile, and *Note
Apache/Language/DBI: Apache/Language/DBI,.  Check out their respective man
pages for more specific information.  And more of those LanguageHandlers
will be shipped in future versions and if you need a specific language
handling module, simply write your own.  Read the API section for more
information about writing your own LanguageHandlers and check the 2
mentionned above, they are nice examples.

CONFIGURATION DIRECTIVES
========================

   There are a some configurations directives you can use to customize how
Apache::Language handles requests.

LanguageHandler
     This is the main directive.  It sets the language handlers for a
     specific location.  It's usage is like IndexOptions.  Meaning it
     supports +/- notations.

     With a list of handlers without any +/- signs it simply sets the
     handler stack for the current location to those.

     With a list of handlers all with +/- signs, it merges them with the
     parent configuration:

          LanguageHandler Apache::Language::handler1 Apache::Language::handler2
          <Location /test/>
          LanguageHandler +Apache::Language::handler3 -Apache::Language::handler2
          </Location>

     Will result in a handler stack of [Apache::Language::Handler1 ,
     Apache::Language::Handler3] for requests in the /test/ directory

     2 things to note though:

     The default handler (Apache::Language::PlainFile) will always be the
     last handler in the stack.

     If a module isn't found, it will be tried again with
     Apache::Language:: prepended to it, so you can write LanguageHandler
     handler2 instead of LanguageHandler Apache::Language::handler2

LanguageForced
     This directive is given a list of languages that should exclusively
     be tried to please the client.  This a way to mark a certain
     <Location> as specifically danish, for example.  If no definition is
     found for that language, the standard 'sorry, no language definition
     found' message is printed.

LanguageDefault
     Provided with a list of languages, this directives sets the default
     languages it should try to send if none of the languages requested by
     the client can be found.

DefaultLanguage
     This is a not an Apache::Language directive, but in the absence of a
     LanguageDefault directive, that setting will be used to set the
     default languages

LanguageDebug
     This will set the level of debugging information sent to the
     apachelog.  Values ranges from 0-4. 4 being *very* noisy and 0 very
     quiet.  0 will still warn you about fatal errors.  A setting of -1
     simply doesn't log anything. Nothing.

     There are also a few other debugging options avaliable

     LanguageDebug Prefix=( LanguageDebug Postfix=) LanguageDebug
     NotFoundPrefix=[[[ LanguageDebug NotFoundPostfix=]]]

     They will prefix/postfix language tokens with the specified
     delimiters with special symbols, usefull for debugging

STATUS Handler
==============

   If you have the Apache::Status module loaded before Apache::Language, a
custom status module will be installed.  Usually accessed thru
/perl-status, it will give you an Apache::Language menu with quite a few
bits of interesting information about Apache::Language status.

API
===

   The Apache::Language API is pretty simple and might evolve in future
versions.  The first argument to all function calls will be the class name
of the handler.

   The API was developped to provide for: 1. abstraction of the data
storage/retrieval and 2.  an easy way for other developpers to write new
containers without having to modify the whole package.

   If you want to write your own Language::Handler, read on.  You might
also find more interesting information by looking at the couple of
LanguageHandlers distributed as part of the Apache::Language package.  I
also think that new LanguageHandlers should be named under the
Apache::Language::* namaspace for simplicity.  As of this writing I am
have quite a few other LanguageHandlers on the way, so if you are planning
on writing a new one, get in touch with me before, maybe I already have
some work done I'd be happy to send you.

   There is one thing that you must understand before writing your own
LanguageHandler.  It's how Apache::Language caches information about
LanguageHandlers.  For performance reasons, and since most mod_perl
scripts/modules will want to have their own language definitions,
information is cached on a per-Module/script basis.  This means that
suppose the module Apache::MyHandler uses Apache::Language, all
LanguageHandlers serving requests for Apache::MyHandler will be given
access to a cache ($data) that's specific to Apache::MyHandler and to
another cache that's specific to Apache::MyHandler and the current
LanguageHandler.  In the case that a certain handler doesn't want this
degree of encapsulation (i.e. a dictionnary of common used error messages,
system wide) it's free to maintain it's own cache (in it's namespace) and
disregard the Module & Handler specific cache.  That cache is merely
provided so LanguageHandler writers won't have to deal with per Module
cache themselves.  But you can do without it.

   This is what a small dump of the cache might look like : (For the
visual types)

   #Cached information for the mod_perl Handler Apache::MyHandler1 $VAR1 =
'Apache::MyHandler1'; $VAR2 = bless( {      #current LanguageHandler stack
    'Handlers' => [                      'Apache::Language::Handler1',
                 'Apache::Language::Handler2'                    ],
'Request' => [Apache $r object]      #Filename of the Calling package
'Filename' => '/usr/lib/perl5/Apache/MyHandler1.pm',      #Language
requested by the client      'Lang' => [                  'en',
     'fr-ca',                  'fr'                ],       #Package name
of the Calling package      'Package' => 'Apache::MyHandler1',
#Specific data for LanguageHandler Apache::Language::Handler1
'Apache::Language::Handler1' => {           #Is the LanguageHandler a
listable one?            'listable' => 1,           'DATA' => {  #this is
the $cfg object passed to the handler                        #it's
completely private to the Language::Handler                       'dbname'
=> 'DBI::Pg',                       'query' => 'select value from language
where key=? and lang=?'                      },            #Is the
LanguageHandler a storable one?            'storable' => 1            },
    #Specific data for LanguageHandler Apache::Language::Handler2
'Apache::Language::Handler2' => {           #Is the LanguageHandler a
listable one?            'listable' => 0,           'DATA' => {  #this is
the $cfg object passed to the handler                        #it's
completely private to the Language::Handler
'option1' => 'read/write',                       'debug'   => 1
        },           #Is the LanguageHandler a storable one?
'storable' => 1           },      'Config' =>  [Opaque structure for
directory configuration]

     }, 'Apache::Language' );

   #Cached information for the mod_perl Handler Apache::MyHandler2 $VAR3 =
'Apache::MyHandler2'; $VAR4 = bless( {      #current LanguageHandler stack
    'Handlers' => [                      'Apache::Language::Handler2'
              ],      'Request' => [Apache $r object]      #Filename of
the Calling package      'Filename' =>
'/usr/lib/perl5/Apache/MyHandler1.pm',      #Language requested by the
client      'Lang' => [                  'en',                  'fr-ca',
              'fr'                ],      #Package name of the Calling
package      'Package' => 'Apache::MyHandler1',

     #Specific data for LanguageHandler Apache::Language::Handler2
     'Apache::Language::Handler2' => {
          #Is the LanguageHandler a listable one?
          'listable' => 0,
          'DATA' => {  #this is the $cfg object passed to the handler
                       #it's completely private to the Language::Handler
                      'dbname' => 'DBI::mysql',
                      'query' => 'select value from language2 where key=? and lang=?'
                    },
          #Is the LanguageHandler a storable one?
          'storable' => 1
          },
     'Config' =>  [Opaque structure for directory configuration]
        }, 'Apache::Language' );

API data structures
-------------------

   All functions calls to LanguageHandlers are passed these 2 data
structures as the second and third arguments.  The first argument always
being the class name of the LanguageHandler.

   $data

   This is the data associated with the particular http request.  It's
also unique to the currently served Module, so it can be used to store
some information, but since Apache::Language stores a few things of itself
there, be carefull to use keys unique to your module (i.e.
$data->{"Apache::Language::YourHandler::key"} = "private data") It's an
Apache::Language object with the following calls avaliable:

lang()
     returns a preference-sorted list of the language the clients
     requested.

handlers()
     returns the current LanguageHandler stack (list)

request()
     returns the current request (Apache::Request)

package()
     returns the name of the package handling the request

filename()
     returns the filename of the package handling the request

extra_args()
     returns a reference to a list of what was passed to the new
     constructor

   *$cfg*

   This is a private storage space for the current Handler.  Handlers can
store whatever they want there.  That data will be preserved for this
Handler/(Calling module/package) pair.  Look in
Apache::Language::PlainFile for a good exapmle of using that.

Required API functions
----------------------

initialize ($data, $cfg)
     This is called for the first request so a LanguageHandler can do it's
     initialization.  This will also be called each time a call to the
     modified() function informs Apache::Language that something has
     changed.

     It has the opportnity to examine the requesting conditions and if it
     chooses not to be involved in the handling of that specific
     requesting Module, it should return anything but L_OK.  That way it
     will be removed from the LanguageHandler stack for that Module and
     therefore will not be called for that Module anymore

modified ($data, $cfg)
     This is called for each request to know if the datasource changed and
     should be re-initialized.  It should return true if something is
     modified and re-initialization is needed.

fetch ($data, $cfg, $key, $lang)
     This function can be called in 2 ways.  First if there $lang is
     defined, the LanguageHandler is requested to produce that exact
     language version for the key $key. This happends if a user requested
     a specific language with $lang->{key/lang} or to find an entry for
     the default language if everything else failed to produce a value.
     It should return undef if unknown.

     Second, if $lang is undefined, this means that the Handler should try
     to return the best possible match for the current request.
     $data->lang will return the list of language the client understands,
     sorted preferred first.  But since language-tags allow for variants
     and dialects, it's now always easy for a module to determine what
     language it should pick if it knows 'en-us' and 'en' and the clients
     understands 'en-ca' and 'de'.

Everything else
     If a call is made to an unknown routine, Apache::Language will try to
     call it on each Handler in the current handler stack until someone
     can deal with that function call.  The call is made with ($data,
     $cfg, @args) as arguments.   @args being the arguments passed to that
     function by the calling user.  Remember that to get at the new()
     arguments, you just have to do a @args = @{$data->extra_args()};

     To simplyfy some things, there is the helper function
     $data->best_lang described below.

Helper API Functions
--------------------

$data->best_lang(@avaliable_language)
     This is the generic best-language picking routine.  This function
     given the list of known languages to the handler, returns the best
     language based on the client's request.

     For example, a simple handler could handle queries like this:

          sub fetch {
             my ($class, $data, $cfg, $key, $lang) = @_;
             #the language information is kept in the $cfg hash

          #if a specific language is asked for:
          return $cfg->{$key}{$lang} if $lang;

          #we must choose the right language ourself.
          #(keys % {$cfg->{$key}}) produces the list of languages in wich $key is known
          my $variant = $data->best_lang(keys % {$cfg->{$key}});
          
          #$variant now holds the best pick for us, or undef if nothing matches..
          return $cfg->{$key}{$variant} if $variant;
          
          #give up
          return undef;
           }

Optionnal API Functions (store)
-------------------------------

   store ($data, $cfg ,$key, $lang, $value)

   If this function is present, the handler will be makred as 'storable'
and any assignments to the language hash will call this function.  Storing
in a language hash should be done by providing a key/language pair as key
to the hash (ie. $lang->{key01/en-us} = "string").  This should return
L_OK on success and L_ERROR in case of an error.

Optionnal API Functions (firstkey/nextkey)
------------------------------------------

   This are functions necessary to make the Language hash listable (i.e.
keys and each).  The tricky thing is that since LanguageHandlers are
stackable and often each have a change at the request, listing a specific
language hash is ambiguious.  The way it's handled is straightforward.
The first listable module that returns something else than undef on the
call to firstkey is the chosen one.  It will be used to list the hash
until it's nextkey function returns undef, and all subsequent list request
will be handled by that module.

   It should be noted that I don't really know what might happend in the
case of recursive/re-entrant lists, so if you don't want to spend time
fixing it yourself, be carefull about that.

   These functions follow exactly the same rules as the generic TIEHASH
mechanism.  So, for more information see *Note Perltie: (perl.info)perltie,

firstkey ($data, $cfg)
     This will be called first when a list request is encountered.  It
     should return the first key of the hash and set up things for the
     nextkey calls.

nextkey ($data, $cfg, $lastkey)
     This will be called once the listing of the language hash has
     started.  Make sure it will eventually return undef to mark the end
     of the list or else you will end up in an infinite loop.

TODO
====

   * Find and correct bugs.

   * Find new features to add.

SEE ALSO
========

   perl(1), *Note Apache: Apache,(3), *Note Apache/Language/Constants:
Apache/Language/Constants,(3), and all `Apache::Language::*' in this node.

SUPPORT
=======

   Please send any questions or comments to the Apache modperl mailing
list <modperl@apache.org> or to me at <gozer@ectoplasm.dyndns.com>

NOTES
=====

   This code was made possible by :

   * Doug MacEachern <dougm@pobox.com>  Creator of mod_perl.  That should
     mean enough.

   * Andreas Koenig <koenig@kulturbox.de> The one I got the idea from in
     the first place.

   * The mod_perl mailing-list at <modperl@apache.org> for all your
     mod_perl related problems.

AUTHOR
======

   Philippe M. Chiasson <gozer@ectoplasm.dyndns.com>

VERSION
=======

   This is revision $Id: Language.pod,v 1.2 1999/04/18 22:02:37 gozer Exp $

COPYRIGHT
=========

   Copyright (c) 1999 Philippe M. Chiasson. All rights reserved. This
program is free software, you can redistribute it and/or modify it under
the same terms as Perl itself.


