This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: XML/UM,  Next: XML/ValidWriter,  Prev: XML/Twig,  Up: Module List

Convert UTF-8 strings to any encoding supported by XML::Encoding
****************************************************************

NAME
====

   XML::UM - Convert UTF-8 strings to any encoding supported by
XML::Encoding

SYNOPSIS
========

     use XML::UM;

     # Set directory with .xml files that comes with XML::Encoding distribution
     # Always include the trailing slash!
     $XML::UM::ENCDIR = '/home1/enno/perlModules/XML-Encoding-1.01/maps/';

     # Create the encoding routine
     my $encode = XML::UM::get_encode (
     	Encoding => 'ISO-8859-2',
     	EncodeUnmapped => \&XML::UM::encode_unmapped_dec);

     # Convert a string from UTF-8 to the specified Encoding
     my $encoded_str = $encode->($utf8_str);

     # Remove circular references for garbage collection
     XML::UM::dispose_encoding ('ISO-8859-2');

DESCRIPTION
===========

   This module provides methods to convert UTF-8 strings to any XML
encoding that *Note XML/Encoding: XML/Encoding, supports. It creates
mapping routines from the .xml files that can be found in the maps/
directory in the *Note XML/Encoding: XML/Encoding, distribution. Note that
the XML::Encoding distribution does install the .enc files in your perl
directory, but not the.xml files they were created from. That's why you
have to specify $ENCDIR as in the SYNOPSIS.

   This implementation uses the XML::Encoding class to parse the .xml file
and creates a hash that maps UTF-8 characters (each consisting of up to 4
bytes) to their equivalent byte sequence in the specified encoding.  Note
that large mappings may consume a lot of memory!

   Future implementations may parse the .enc files directly, or do the
conversions entirely in XS (i.e. C code.)

get_encode (Encoding => STRING, EncodeUnmapped => SUB)
======================================================

   The central entry point to this module is the XML::UM::get_encode()
method.  It forwards the call to the global $XML::UM::FACTORY, which is
defined as an instance of XML::UM::SlowMapperFactory by default. Override
this variable to plug in your own mapper factory.

   The XML::UM::SlowMapperFactory creates an instance of
XML::UM::SlowMapper (and caches it for subsequent use) that reads in the
.xml encoding file and creates a hash that maps UTF-8 characters to
encoded characters.

   The get_encode() method of XML::UM::SlowMapper is called, finally, which
generates an anonimous subroutine that uses the hash to convert
multi-character UTF-8 blocks to the proper encoding.

dispose_encoding ($encoding_name)
=================================

   Call this to free the memory used by the SlowMapper for a specific
encoding.  Note that in order to free the big conversion hash, the user
should no longer have references to the subroutines generated by
get_encode().

   The parameters to the get_encode() method (defined as name/value pairs)
are:

   * Encoding

     The name of the desired encoding, e.g. 'ISO-8859-2'

   * EncodeUnmapped (Default: \&XML::UM::encode_unmapped_dec)

     Defines how Unicode characters not found in the mapping file (of the
     specified encoding) are printed.  By default, they are converted to
     decimal entity references, like '&#123;'

     Use \&XML::UM::encode_unmapped_hex for hexadecimal constants, like
     '&#xAB;'

CAVEATS
=======

   I'm not exactly sure about which Unicode characters in the range (0 ..
127) should be mapped to themselves. See comments in XML/UM.pm near
%DEFAULT_ASCII_MAPPINGS.

   The encodings that expat supports by default are currently not
supported, (e.g. UTF-16, ISO-8859-1), because there are no .enc files
available for these encodings.  This module needs some more work. If you
have the time, please help!

AUTHOR
======

   Send bug reports, hints, tips, suggestions to Enno Derksen at
<`enno@att.com'>.


File: pm.info,  Node: XML/ValidWriter,  Next: XML/Writer,  Prev: XML/UM,  Up: Module List

DOCTYPE driven valid XML output
*******************************

NAME
====

   XML::ValidWriter - DOCTYPE driven valid XML output

SYNOPSIS
========

     ## As a normal perl object:
     $writer = XML::ValidWriter->new(
        DOCTYPE => $xml_doc_type,
        OUTPUT => \*FH
     ) ;
     $writer->startTag( 'b1' ) ;
     $writer->startTag( 'c2' ) ;
     $writer->end ;

     ## Writing to a scalar:
     $writer = XML::ValidWriter->new(
        DOCTYPE => $xml_doc_type,
        OUTPUT => \$buf
     ) ;

     ## Or, in scripting mode:
     use XML::Doctype         NAME => a, SYSTEM_ID => 'a.dtd' ;
     use XML::ValidWriter qw( :all :dtd_tags ) ;
     b1 ;                # Emits <a><b1>
     c2( attr=>"val" ) ; # Emits </b1><b2><c2 attr="val">
     endAllTags ;        # Emits </c2></b2></a>

     ## If you've got an XML::Doctype object handy:
     use XML::ValidWriter qw( :dtd_tags ), DOCTYPE => $doctype ;

     ## If you've saved a preparsed DTD as a perl module
     use FooML::Doctype::v1_0001 ;
     use XML::ValidWriter qw( :dtd_tags ) ;

     #
     # This all assumes that the DTD contains:
     #
     #   <!ELEMENT a ( b1, b2?, b3* ) >
     #	  <!ATTLIST   a aa1 CDATA       #REQUIRED >
     #   <!ELEMENT b1 ( c1 ) >
     #   <!ELEMENT b2 ( c2 ) >
     #

STATUS
======

   Alpha.  Use and patch, don't depend on things not changing drastically.

   Many methods supplied by XML::Writer are not yet supplied here.

DESCRIPTION
===========

   This module uses the DTD contained in an XML::Doctype to enable compile-
and run-time checks of XML output validity.  It also provides methods and
functions named after the elements mentioned in the DTD.  If an
XML::ValidWriter uses a DTD that mentions the element type TABLE, that
instance will provide the methods

     $writer->TABLE( $content, ...attrs... ) ;
     $writer->start_TABLE( ...attrs... ) ;
     $writer->end_TABLE() ;
     $writer->empty_TABLE( ...attrs... ) ;

   .  These are created for undeclared elements-those elements not
explicitly declared with an <!ELEMENT ..> declaration-as well.  If an
element type name conflicts with a method, it will not override the
internal method.

   When an XML::Doctype is parsed, the name of the doctype defines the root
node of the document.  This name can be changed, though, see *Note
XML/Doctype: XML/Doctype, for details.

   In addition to the object-oriented API, a function API is also provided.
This allows you to import most of the methods of XML::ValidWriter as
functions using standard import specifications:

     use XML::ValidWriter qw( :all ) ; ## Could list function names instead

   :all does not import the functions named after elements mentioned in
the DTD, you need to import those tags using `:dtd_tags':

     use XML::Doctype NAME => 'foo', SYSTEM_ID => 'fooml.dtd' ;
     use XML::ValidWriter qw( :all :dtd_tags ) ;

   or

     BEGIN {
        $doctype = XML::Doctype->new( ... ) ;
     }

     use XML::ValidWriter DOCTYPE => $doctype, qw( :all :dtd_tags ) ;

XML::Writer API compatibility
-----------------------------

   Much of the interface is patterned after XML::Writer so that it can
possibly be used as a drop-in replacement.  It will take awhile before
this module emulates enough of XML::Writer to be a drop-in replacement in
situations where the more advanced XML::Writer methods are used.  If you
find you need a method not suported here, write it and send it in!

   This was not derived from XML::Writer because XML::Writer does not
expose it's stack.  Even if it did, it's might be difficult to store
enough state in it's stack.

   Unlike XML::Writer, this does not call in all of the IO::* family, and
method dispatch should be faster.  DTD-specific methods are also supported
(see `' in this node).

Quick and Easy Unix Filter Apps
-------------------------------

   For quick applications that provide Unix filter application
functionality, XML::ValidWriter and XML::Doctype cooperate to allow you to

  1. Parse a DTD at compile-time and set that as the default DTD for the
     current package.  This is done using the

          use XML::Doctype NAME => 'FooML, SYSTEM_ID => 'fooml.dtd' ;

     syntax.

  2. Define and export a set of functions corresponding to start and end
     tags for all declared and undeclared ELEMENTs in the DTD.  This is
     done by using the `:dtd_tags' export symbol like so:

          use XML::Doctype     NAME => 'FooML, SYSTEM_ID => 'fooml.dtd' ;
          use XML::ValidWriter qw(:dtd_tags) ;

     If the elements a, b_c, and d-e are referred to in the DTD, the
     following functions will be exported:

          a()        end_a()       # like startTag( 'a', ... ) and endTag( 'a' )
          b_c()      end_b_c()
          d_e()      end_d_e()     {'d-e'}()     {'end_d-e'}()

     These functions emit only tags, unlike the similar functions found in
     CGI.pm and XML::Generator, which also allow you to pass content in as
     parameters.

     See below for details on conflict resolution in the mapping of entity
     names containing /\W/ to Perl subroutine names.

     If the elements declared in the DTD might conflict with functions in
     your package namespace, simple put them in some safe namespace:

          package FooML ;
          use XML::Doctype         NAME => 'FooML', SYSTEM_ID => 'fooml.dtd' ;
          use XML::ValidWriter qw(:dtd_tags) ;

          package Whatever ;

     The advantage of importing these subroutine names is that perl can
     then detect use of unknown tags at compile time.

     If you don't want to use the default DTD, use the `-dtd' option:

          BEGIN { $dtd = XML::Doctype->new( .... ) }
          use XML::ValidWriter qw(:dtd_tags), -dtd => \$dtd ;

  3. Use the default DTD to validate emitted XML.  startTag() and endTag()
     will check the tag being emitted against the list of currently open
     tags and either emit a minimal set of missing end and start tags
     necessary to achieve document validity or produce errors or warnings.

     Since the functions created by the `:dtd_tags' export symbol are
     wrappers around startTag() and endTag(), they provide this
     functionality as well.

     So, if you have a DTD like

          <!ELEMENT a ( b1, b2?, b3* ) >

          <!ATTLIST   a aa1 CDATA       #REQUIRED >

          <!ELEMENT b1 ( c1 ) >
          <!ELEMENT b2 ( c2 ) >
          <!ELEMENT b3 ( c3 ) >

     you can do this:

          use XML::Doctype     NAME => 'a', SYSTEM_ID => 'a.dtd' ;
          use XML::ValidWriter ':dtd_tags' ;

          getDoctype->element_decl('a')->attdef('aa1')->default_on_write('foo') ;

          a ;
             b1 ;
          	 c1 ;
          	 end_c1 ;
             end_b1 ;
             b3 ;
          	 c3( -attr => val ) ;
          	 end_c3 ;
             end_b3 ;
          end_a ;

     and emit a document like

          <a aa1="foo">
             <b1>
                <c1 />
             </b1>
             <b3>
                <c3 attr => "val" />
             </b3>
          </a>

     .


OUTPUT OPTIMIZATION
===================

   XML is a very simple langauge and does not offer a lot of room for
optimization.  As the spec says "Terseness in XML markup is of minimal
importance."  XML::ValidWriter does optimize the following on output:

   `<a...></a>'   becomes '<a... />'

   Spurious emissions of `]]><![CDATA[' are supressed.

   XML::ValidWriter chooses whether or not to use a <![CDATA[...]]> section
or simply escape '<' and '&'.  If you are emitting content for an element
in multiple calls to `' in this node, the first call decides whether or
not to use CDATA, so it's to your advantage to emit as much in the first
call as possible.  You can do

     characters( @lots_of_segments ) ;

   if it helps.

METHODS AND FUNCTIONS
=====================

   All of the routines in this module can be called as either functions or
methods unless otherwise noted.

   To call these routines as functions use either the DOCTYPE or :dtd_tags
options in the parameters to the use statement:

     use XML::ValidWriter DOCTYPE => XML::Doctype->new( ... ) ;
     use XML::ValidWriter qw( :dtd_tags ) ;

   This associates an XML::ValidWriter and an XML::Doctype with the
package.  These are used by the routines when called as functions.

new
          $writer = XML::ValidWriter->new( DTD => $dtd, OUTPUT => \*FH ) ;

     Creates an XML::ValidWriter.

     The value passed for OUTPUT may be:

    a SCALAR ref
          if you want to direct output to append to a scalar.  This scalar
          is truncated whenever the XML::ValidWriter object is reset() or
          DESTROY()ed

    a file handle glob ref or a reference to an IO object
          XML::ValidWriter does not load IO.  This is the only mode
          compatible with XML::Writer.

    a file name
          A simple scalar is taken to be a filename to be created or
          truncated and emitted to.  This file will be closed when the
          XML::ValidWriter object is reset or deatroyed.

     NOTE: if you leave OUTPUT undefined, then the currently select()ed
     output is used at each emission (ie calling select() can alter the
     destination mid-stream).  This eases writing command line filter
     applications, the select() interaction is unintentional, and please
     don't depend on it.  I reserve the right to cache the select()ed
     filehandle at creation time or at time of first emission at some
     point in the future.

import
     Can't think of why you'd call this method directly, it gets called
     when you use this module:

          use XML::ValidWriter qw( :all ) ;

     In addition to the normal functionality of exporting functions like
     startTag() and endTag(), XML::ValidWriter's import() can create
     functions corresponding to all elements in a DTD.  This is done using
     the special `:dtd_tags' export symbol.  For example,

          use XML::Doctype     NAME => 'FooML', SYSTEM_ID => 'fooml.dtd' ;
          use XML::ValidWriter qw( :dtd_tags ) ;

     where fooml.dtd referse to a tag type of 'blurb' causes these
     functions to be imported:

          blurb()         # calls defaultWriter->startTag( 'blurb', @_ ) ;
          blurb_element() # calls defaultWriter->dataElement( 'blurb', @_ ) ;
          empty_blurb()   # calls defaultWriter->emptyTag( 'blurb', @_ ) ;
          end_blurb()     # calls defaultWriter->endTag( 'blurb' ) ;
          
          The range of characters for element types is much larger than
          the range of characters for bareword perl subroutine names, which
          are limited to [a-zA-Z0-9_].  In this case, XML::ValidWriter will
          export an oddly named function that you can use a symbolic reference
          to call (you will need C<no strict 'refs' ;> if you are doing
          a C<use strict ;>):

          &{"space-1999:moonbase"}( ...attributes ... ) ;

     .  XML::ValidWriter will also try to fold the name in to bareword
     space by converting /\W/ symbols to '_'.  If the resulting function
     name,

          space_1999_moonbase( ...attributes... ) ;
          
          has not been generated and is not the name of an element type, then
          it will also be exported.

     If you are using a DTD that might introduce function names that
     conflict with existing ones, simple export them in to their own
     namespace:

          package ML ;

          use XML::Doctype     NAME => 'foo', SYSTEM_ID => 'fooml.dtd' ;
          use XML::ValidWriter qw( :dtd_tags ) ;

          package main ;

          use XML::ValidWriter qw( :all ) ;

          ML::foo ;
          ML::c2 ;
          ML::c1 ;
          ML::end_a ;

     I gave serious thought to converting ':' in element names to '::' in
     function declarations, which might work well in the
     functions-in-their-own- namespace case, but not in the default case,
     since Perl does not (yet) have relative namespaces. Another
     alternative is to allow a mapping of XML namespaces to Perl
     namespaces to be done.

characters
          characters( "escaped text", "& more" ) ;
          $writer->characters( "escaped text", "& more" ) ;

     Emits character data.  Character data will be escaped before output,
     by either transforming '<' and '&' to &lt; and &amp;, or by enclosing
     in a '`<![CDATA[...]]>'' bracket, depending on which will be more
     human-readable, according to the module.

dataElement
          $writer->dataElement( $tag ) ;
          $writer->dataElement( $tag, $content ) ;
          $writer->dataElement( $tag, $content, attr1 => $val1, ... ) ;
          dataElement( $tag ) ;
          dataElement( $tag, $content ) ;
          dataElement( $tag, $content, attr1 => $val1, ... ) ;

     Does the equivalent to

          ## Split the optional args in to attributes and elements arrays.
          $writer->startTag( $tag, @attributes ) ;
          $writer->characters( $content ) ;
          $writer->endTag( $tag ) ;

     This function is exportable as dataElement(), and is also exported
     for each element 'foo' found in the DTD as foo().

defaultWriter
          $writer = defaultWriter ;       ## Not a method!
          $writer = defaultWriter( 'Foo::Bar' ) ;

     Returns the default XML::ValidWriter for the given package, or the
     current package if none is specified.  This is useful for getting at
     methods like reset that are not also functions.

     Croaks if no default writer has been defined (see `' in this node).

doctype
          # Using the writer's associated DTD:
          doctype ;

          # Ignoring the writer's associated DTD:
          doctype( $type ) ;
          doctype( $type, undef, $system ) ;
          doctype( $type, $public, $system ) ;

          $writer->doctype ;
          ...etc

     See `' in this node to emit the entire DTD in the document.

     This checks to make sure that no doctype or elements have been
     emitted.

     A warning is emitted if standalone="yes" was specified in the
     <?xml..?> declaration and a system id is specified.  This is
     extremely likely to be an error.  If you need to silence the warning,
     write me (see below).

     Passing " or '0' (zero) as a $public_id or as a $system_id also
     generates a warning, as these are extremely likely to be errors.

emptyTag
          emptyTag( $tag[, attr1 => $val1... ] ) ;
          $writer->emptyTag( $tag[, attr1 => $val1... ] ) ;

     Emits an empty tag like '<foo />'.  The extra space is for
     compatibility with XHTML.

endTag
          endTag ;
          endTag( 'a' ) ;
          $writer->endTag ;
          $writer->endTag( 'a' ) ;

     Prints one or more end tags.  The tag name is optional and defaults
     to the most recently emitted start tag if not present.

     This will emit as many close tags as necessary to close the supplied
     tag name, or will emit an error if the tag name specified is not open
     in the output document.

end
          $writer->end ;      # Not a function!!

     Emits all necessary end tags to close the document.  Available as a
     method only, since 'end' is a little to generic to be exported as a
     function name, IMHO.  See 'endAllTags' for the plain function
     equivalent function.

endAllTags
          endAllTags ;
          $writer->endAllTags ;

     A plain function that emits all necessart end tags to close the
     document.  Corresponds to the method end, but is exportable as a
     function/

exportDTDTags
          $writer->exportDTDTags() ;
          $writer->exportDTDTags( $to_pkg ) ;

     Exports the tags found in the DTD to the caller's namespace.

getDataMode
          $m = getDataMode ;
          $m = $writer->getDataMode ;

     Returns TRUE if the writer is in DATA_MODE.

getDoctype
          $dtd = getDoctype ;
          $dtd = $writer->getDoctype ;

     This is used to get the writer's XML::Doctype object.

getOutput
          $fh = getOutput ;
          $fh = $writer->getOutput ;

     Gets the filehandle an XML::ValidWriter sends output to.

rawCharacters
          rawCharacters( "<unescaped text>", "& more text" ) ;
          $writer->rawCharacters( "<unescaped text>", "& more text" ) ;

     This allows you to emit raw text without any escape processing.  The
     text is not examined for tags, so you can invalidate your document
     and even corrupt it's well-formedness.

reset
          $writer->reset ;        # Not a function!

     Resets a writer to be initialized, but not have emitted anything.

     This is useful if you need to abort output, but want to reuse the
     XML::ValidWriter.

setDataMode
          setDataMode( 1 ) ;
          $writer->setDataMode( 1 ) ;

     Enable or disable data mode.

setDoctype
          setDoctype $doctype ;
          $writer->setDoctype( $doctype ) ;

     This is used to set the doctype object.

select_xml
          select_xml OUTHANDLE ;  # Nnot a method!!

     Selects a filehandle to send the XML output to when not using the
     object oriented interface.  This is similar to perl's builtin select,
     but only affects startTag and endTag functions, (not methods).

     This is only needed if you want to interleave output to the selected
     output files (usually STDOUT, see `select', *Note Perlfunc:
     (perl.info)perlfunc, and to an XML file on another filehandle.

     If you want to redirect all output (yours and XML::Writer's) to the
     same file, just use Perl's built-in select(), since startTag and
     endTag emit to the currently selected filehandle by default.

     Like select, this returns the old value.

setOutput
          setOutput( \*FH ) ;
          $writer->setOutput( \*FH ) ;

     Sets the filehandle an XML::ValidWriter sends output to.

startTag
          startTag( 'a', attr => val ) ;  # use default XML::ValidWriter for
                                          # current package.
          $writer->startTag( 'a', attr => val ) ;

     Emits a named start tag with optional attributes.  If the named tag
     cannot be a child of the most recently started tag, then any tags
     that need to be opened between that one and the named tag are opened.

     If the named tag cannot be enclosed within the most recently opened
     tag, no matter how deep, then startTag() tries to end as few started
     tags as necessary to allow the named tag to be emitted within a tag
     already on the stack.

     This warns (once) if no <?xml?> declaration has been emitted.  It
     does not check to see if a <!DOCTYPE...> has been emitted.  It dies
     if an attempt is made to emit a second root element.

xmlDecl([[$encoding][, $standalone])
          xmlDecl ;
          xmlDecl( "UTF-8" ) ;
          xmlDecl( "UTF-8", "yes" ) ;
          $writer->xmlDecl( ... ) ;

     Emits an XML declaration.  Must be called before any of the other
     output routines.

     If $encoding is not defined, it is not output.  This is slightly
     different than XML::Writer, which outputs 'UTF-8' if you pass in
     undef, 0, or ".

     If $encoding is " or 0, then it is output as "" or "0" and a warning
     is generated.

     If $standalone is defined and is not 'no', 0, or ", it is output as
     'yes'.  If it is 'no', then it is output as 'no'.  If it's 0 or " it
     is not output.

AUTOLOAD
     This function is called whenever a function or method is not found in
     XML::ValidWriter.

     If it was a method being called, and the desired method name is a
     start or end tag found in the DTD, then a method is cooked up on the
     fly.

     These methods are slower than normal methods, but they are cached so
     that they don't need to be recompiled.  The speed penalty is probably
     not significant since they do I/O and are thus usually orders of
     magnitude slower than normal Perl methods.

DESTROY
     DESTROY is called when an XML::ValidWriter is cleaned up.  This is
     used to automatically close all tags that remain open.  This will not
     work if you have closed the output filehandle that the ValidWriter was
     using.

     This method will also warn if anything was emitted bit no root node
     was emitted.  This warning can be silenced by calling

          $writer->reset() ;

     when you abandon output.

AUTHOR
======

   Barrie Slaymaker <barries@slaysys.com>

COPYRIGHT
=========

   This module is Copyright 2000, Barrie Slaymaker.  All rights reserved.

   This module is licensed under the GPL, version 2.  Please contact me if
this does not suit your needs.


File: pm.info,  Node: XML/Writer,  Next: XML/XPath,  Prev: XML/ValidWriter,  Up: Module List

Perl extension for writing XML documents.
*****************************************

NAME
====

   XML::Writer - Perl extension for writing XML documents.

SYNOPSIS
========

     use XML::Writer;
     use IO;

     my $output = new IO::File(">output.xml");

     my $writer = new XML::Writer(OUTPUT => $output);
     $writer->startTag("greeting",
                       "class" => "simple");
     $writer->characters("Hello, world!");
     $writer->endTag("greeting");
     $writer->end();
     $output->close();

DESCRIPTION
===========

   XML::Writer is a helper module for Perl programs that write an XML
document.  The module handles all escaping for attribute values and
character data and constructs different types of markup, such as tags,
comments, and processing instructions.

   By default, the module performs several well-formedness checks to catch
errors during output.  This behaviour can be extremely useful during
development and debugging, but it can be turned off for production-grade
code.

   The module can operate either in regular mode in or Namespace
processing mode.  In Namespace mode, the module will generate Namespace
Declarations itself, and will perform additional checks on the output.

   Additional support is available for a simplified data mode with no
mixed content: newlines are automatically inserted around elements and
elements can optionally be indented based as their nesting level.

METHODS
=======

Writing XML
-----------

new([$params])
     Create a new XML::Writer object:

          my $writer = new XML::Writer(OUTPUT => $output, NEWLINES => 1);

     Arguments are an anonymous hash array of parameters:

    OUTPUT
          An object blessed into IO::Handle or one of its subclasses (such
          as IO::File); if this parameter is not present, the module will
          write to standard output.

    NAMESPACES
          A true (1) or false (0, undef) value; if this parameter is
          present and its value is true, then the module will accept
          two-member array reference in the place of element and attribute
          names, as in the following example:

               my $rdfns = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
               my $writer = new XML::Writer(NAMESPACES => 1);
               $writer->startTag([$rdfns, "Description"]);

          The first member of the array is a namespace URI, and the second
          part is the local part of a qualified name.  The module will
          automatically generate appropriate namespace declarations and
          will replace the URI part with a prefix.

    PREFIX_MAP
          A hash reference; if this parameter is present and the module is
          performing namespace processing (see the NAMESPACES parameter),
          then the module will use this hash to look up preferred prefixes
          for namespace URIs:

               my $rdfns = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
               my $writer = new XML::Writer(NAMESPACES => 1,
                                            PREFIX_MAP => {$rdfns => 'rdf'});

          The keys in the hash table are namespace URIs, and the values
          are the associated prefixes.  If there is not a preferred prefix
          for the namespace URI in this hash, then the module will
          automatically generate prefixes of the form "__NS1", "__NS2",
          etc.

          To set the default namespace, use " for the prefix.

    NEWLINES
          A true or false value; if this parameter is present and its
          value is true, then the module will insert an extra newline
          before the closing delimiter of start, end, and empty tags to
          guarantee that the document does not end up as a single, long
          line.  If the paramter is not present, the module will not
          insert the newlines.

    UNSAFE
          A true or false value; if this parameter is present and its
          value is true, then the module will skip most well-formedness
          error checking.  If the parameter is not present, the module
          will perform the well-formedness error checking by default.
          Turn off error checking at your own risk!

    DATA_MODE
          A true or false value; if this parameter is present and its
          value is true, then the module will enter a special data mode,
          inserting newlines automatically around elements and (unless
          UNSAFE is also specified) reporting an error if any element has
          both characters and elements as content.

    DATA_INDENT
          A numeric value; if this parameter is present, it represents the
          indent step for elements in data mode (it will be ignored when
          not in data mode).

end()
     Finish creating an XML document.  This method will check that the
     document has exactly one document element, and that all start tags are
     closed:

          $writer->end();

xmlDecl([$encoding, $standalone])
     Add an XML declaration to the beginning of an XML document.  The
     version will always be "1.0".  If you provide a non-null encoding or
     standalone argument, its value will appear in the declaration (and
     non-null value for standalone except 'no' will automatically be
     converted to 'yes').

          $writer->xmlDecl("UTF-8");

doctype($name, [$publicId, $systemId])
     Add a DOCTYPE declaration to an XML document.  The declaration must
     appear before the beginning of the root element.  If you provide a
     publicId, you must provide a systemId as well, but you may provide
     just a system ID.

          $writer->doctype("html");

comment($text)
     Add a comment to an XML document.  If the comment appears outside the
     document element (either before the first start tag or after the last
     end tag), the module will add a carriage return after it to improve
     readability:

          $writer->comment("This is a comment");

pi($target [, $data])
     Add a processing instruction to an XML document:

          $writer->pi('xml-stylesheet', 'href="style.css" type="text/css"');

     If the processing instruction appears outside the document element
     (either before the first start tag or after the last end tag), the
     module will add a carriage return after it to improve readability.

     The $target argument must be a single XML name.  If you provide the
     $data argument, the module will insert its contents following the
     $target argument, separated by a single space.

startTag($name [, $aname1 => $value1, ...])
     Add a start tag to an XML document.  Any arguments after the element
     name are assumed to be name/value pairs for attributes: the module
     will escape all '&', '<', '>', and '"' characters in the attribute
     values using the predefined XML entities:

          $writer->startTag('doc', 'version' => '1.0',
                                   'status' => 'draft',
                                   'topic' => 'AT&T');

     All start tags must eventually have matching end tags.

emptyTag($name [, $aname1 => $value1, ...])
     Add an empty tag to an XML document.  Any arguments after the element
     name are assumed to be name/value pairs for attributes (see startTag()
     for details):

          $writer->emptyTag('img', 'src' => 'portrait.jpg',
                                   'alt' => 'Portrait of Emma.');

endTag([$name])
     Add an end tag to an XML document.  The end tag must match the closest
     open start tag, and there must be a matching and properly-nested end
     tag for every start tag:

          $writer->endTag('doc');

     If the $name argument is omitted, then the module will automatically
     supply the name of the currently open element:

          $writer->startTag('p');
          $writer->endTag();

dataElement($name, $data [, $aname1 => $value1, ...])
     Print an entire element containing only character data.  This is
     equivalent to

          $writer->startTag($name [, $aname1 => $value1, ...]);
          $writer->characters($data);
          $writer->endTag($name);

characters($data)
     Add character data to an XML document.  All '<', '>', and '&'
     characters in the $data argument will automatically be escaped using
     the predefined XML entities:

          $writer->characters("Here is the formula: ");
          $writer->characters("a < 100 && a > 5");

     You may invoke this method only within the document element (i.e.
     after the first start tag and before the last end tag).

     In data mode, you must not use this method to add whitespace between
     elements.

setOutput($output)
     Set the current output destination, as in the OUTPUT parameter for the
     constructor.

getOutput()
     Return the current output destination, as in the OUTPUT parameter for
     the constructor.

setDataMode($mode)
     Enable or disable data mode, as in the DATA_MODE parameter for the
     constructor.

getDataMode()
     Return the current data mode, as in the DATA_MODE parameter for the
     constructor.

setDataIndent($step)
     Set the indent step for data mode, as in the DATA_INDENT parameter for
     the constructor.

getDataIndent()
     Return the indent step for data mode, as in the DATA_INDENT parameter
     for the constructor.

Querying XML
------------

in_element($name)
     Return a true value if the most recent open element matches $name:

          if ($writer->in_element('dl')) {
            $writer->startTag('dt');
          } else {
            $writer->startTag('li');
          }

within_element($name)
     Return a true value if any open elemnet matches $name:

          if ($writer->within_element('body')) {
            $writer->startTag('h1');
          } else {
            $writer->startTag('title');
          }

current_element()
     Return the name of the currently open element:

          my $name = $writer->current_element();

     This is the equivalent of

          my $name = $writer->ancestor(0);

ancestor($n)
     Return the name of the nth ancestor, where $n=0 for the current open
     element.

Additional Namespace Support
----------------------------

   WARNING: you must not use these methods while you are writing a
document, or the results will be unpredictable.

addPrefix($uri, $prefix)
     Add a preferred mapping between a Namespace URI and a prefix.  See
     also the PREFIX_MAP constructor parameter.

     To set the default namespace, omit the $prefix parameter or set it to
     ".

removePrefix($uri)
     Remove a preferred mapping between a Namespace URI and a prefix.

     To set the default namespace, omit the $prefix parameter or set it to
     ".

ERROR REPORTING
===============

   With the default settings, the XML::Writer module can detect several
basic XML well-formedness errors:

   * Lack of a (top-level) document element, or multiple document elements.

   * Unclosed start tags.

   * Misplaced delimiters in the contents of processing instructions or
     comments.

   * Misplaced or duplicate XML declaration(s).

   * Misplaced or duplicate DOCTYPE declaration(s).

   * Mismatch between the document type name in the DOCTYPE declaration and
     the name of the document element.

   * Mismatched start and end tags.

   * Attempts to insert character data outside the document element.

   * Duplicate attributes with the same name.

   During Namespace processing, the module can detect the following
additional errors:

   * Attempts to use PI targets or element or attribute names containing a
     colon.

   * Attempts to use attributes with names beginning "xmlns".

   To ensure full error detection, a program must also invoke the end
method when it has finished writing a document:

     $writer->startTag('greeting');
     $writer->characters("Hello, world!");
     $writer->endTag('greeting');
     $writer->end();

   This error reporting can catch many hidden bugs in Perl programs that
create XML documents; however, if necessary, it can be turned off by
providing an UNSAFE parameter:

     my $writer = new XML::Writer(OUTPUT => $output, UNSAFE => 1);

AUTHOR
======

   David Megginson, david@megginson.com

SEE ALSO
========

   XML::Parser


File: pm.info,  Node: XML/XPath,  Next: XML/XPath/Boolean,  Prev: XML/Writer,  Up: Module List

a set of modules for parsing and evaluating XPath statements
************************************************************

NAME
====

   XML::XPath - a set of modules for parsing and evaluating XPath
statements

DESCRIPTION
===========

   This module aims to comply exactly to the XPath specification at
http://www.w3.org/TR/xpath and yet allow extensions to be added in the
form of functions. Modules such as XSLT and XPointer may need to do this
as they support functionality beyond XPath.

SYNOPSIS
========

     use XML::XPath;
     use XML::XPath::XMLParser;
     
     my $xp = XML::XPath->new(filename => 'test.xhtml');
     
     my $nodeset = $xp->find('/html/body/p'); # find all paragraphs
     
     foreach my $node ($nodeset->get_nodelist) {
         print "FOUND\n\n",
             XML::XPath::XMLParser::as_string($node),
             "\n\n";
     }

DETAILS
=======

   There's an awful lot to all of this, so bear with it - if you stick it
out it should be worth it. Please get a good understanding of XPath by
reading the spec before asking me questions. All of the classes and parts
herein are named to be synonimous with the names in the specification, so
consult that if you don't understand why I'm doing something in the code.

API
===

   The API of XML::XPath itself is extremely simple to allow you to get
going almost immediately. The deeper API's are more complex, but you
shouldn't have to touch most of that.

new()
-----

   This constructor follows the often seen named parameter method call.
Parameters you can use are: filename, parser, xml, ioref and context.  The
filename parameter specifies an XML file to parse. The xml parameter
specifies a string to parse, and the ioref parameter specifies an ioref to
parse. The context option allows you to specify a context node. The
context node has to be in the format of a node as specified in *Note
XML/XPath/XMLParser: XML/XPath/XMLParser,. The 4 parameters filename, xml,
ioref and context are mutually exclusive - you should only specify one (if
you specify anything other than context, the context node is the root of
your document).  The parser option allows you to pass in an already
prepared XML::Parser object, to save you having to create more than one in
your application (if, for example, you're doing more than just XPath).

     my $xp = XML::XPath->new( context => $node );

   It is very much recommended that you use only 1 XPath object throughout
the life of your application. This is because the object (and it's
sub-objects) maintain certain bits of state information that will be
useful (such as XPath variables) to later calls to find(). It's also a
good idea because you'll use less memory this way.

*nodeset* = find($path, [$context])
-----------------------------------

   The find function takes an XPath expression (a string) and returns
either an XML::XPath::NodeSet object containing the nodes it found (or
empty if no nodes matched the path), or one of XML::XPath::Literal (a
string), XML::XPath::Number, or XML::XPath::Boolean. It should always
return something - and you can use ->isa() to find out what it returned.
If you need to check how many nodes it found you should check
$nodeset->size.  See *Note XML/XPath/NodeSet: XML/XPath/NodeSet,. An
optional second parameter of a context node allows you to use this method
repeatedly, for example XSLT needs to do this.

findnodes($path, [$context])
----------------------------

   Returns a list of nodes found by $path, optionally in context $context.
In scalar context returns an XML::XPath::NodeSet object.

findnodes_as_string($path, [$context])
--------------------------------------

   Returns the nodes found reproduced as XML. The result is not guaranteed
to be valid XML though.

findvalue($path, [$context])
----------------------------

   Returns either a `XML::XPath::Literal', a `XML::XPath::Boolean' or a
`XML::XPath::Number' object. If the path returns a NodeSet,
$nodeset->to_literal is called automatically for you (and thus a
`XML::XPath::Literal' is returned). Note that for each of the objects
stringification is overloaded, so you can just print the value found, or
manipulate it in the ways you would a normal perl value (e.g. using
regular expressions).

matches($node, $path, [$context])
---------------------------------

   Returns true if the node matches the path (optionally in context
$context).

set_namespace($prefix, $uri)
----------------------------

   Sets the namespace prefix mapping to the uri.

   Normally in XML::XPath the prefixes in XPath node tests take their
context from the current node. This means that foo:bar will always match
an element <foo:bar> regardless of the namespace that the prefix foo is
mapped to (which might even change within the document, resulting in
unexpected results). In order to make prefixes in XPath node tests
actually map to a real URI, you need to enable that via a call to the
set_namespace method of your XML::XPath object.

clear_namespaces()
------------------

   Clears all previously set namespace mappings.

$XML::XPath::Namespaces
-----------------------

   Set this to 0 if you *don't* want namespace processing to occur. This
will make everything a little (tiny) bit faster, but you'll suffer for it,
probably.

Node Object Model
=================

   See *Note XML/XPath/Node: XML/XPath/Node,, *Note
XML/XPath/Node/Element: XML/XPath/Node/Element,, *Note
XML/XPath/Node/Text: XML/XPath/Node/Text,, *Note XML/XPath/Node/Comment:
XML/XPath/Node/Comment,, *Note XML/XPath/Node/Attribute:
XML/XPath/Node/Attribute,, *Note XML/XPath/Node/Namespace:
XML/XPath/Node/Namespace,, and *Note XML/XPath/Node/PI: XML/XPath/Node/PI,.

On Garbage Collection
=====================

   XPath nodes work in a special way that allows circular references, and
yet still lets Perl's reference counting garbage collector to clean up the
nodes after use. This should be totally transparent to the user, with one
caveat: *If you free your tree before letting go of a sub-tree, consider
that playing with fire and you may get burned*. What does this mean to the
average user? Not much. Provided you don't free (or let go out of scope)
either the tree you passed to XML::XPath->new, or if you didn't pass a
tree, and passed a filename or IO-ref, then provided you don't let the
XML::XPath object go out of scope before you let results of find() and its
friends go out of scope, then you'll be fine. Even if you do let the tree
go out of scope before results, you'll probably still be fine. The only
case where you may get stung is when the last part of your path/query is
either an ancestor or parent axis. In that case the worst that will happen
is you'll end up with a circular reference that won't get cleared until
interpreter destruction time. You can get around that by explicitly
calling $node->DESTROY on each of your result nodes, if you really need to
do that.

   Mail me direct if that's not clear. Note that it's not doom and gloom.
It's by no means perfect, but the worst that will happen is a long running
process could leak memory. Most long running processes will therefore be
able to explicitly be careful not to free the tree (or XML::XPath object)
before freeing results. AxKit, an application that uses XML::XPath, does
this and I didn't have to make any changes to the code - it's already
sensible programming.

   If you *really* don't want all this to happen, then set the variable
$XML::XPath::SafeMode, and call $xp->cleanup() on the XML::XPath object
when you're finished, or $tree->dispose() if you have a tree instead.

Example
=======

   Please see the test files in t/ for examples on how to use XPath.

Support/Author
==============

   This module is copyright 2000 AxKit.com Ltd. This is free software, and
as such comes with NO WARRANTY. No dates are used in this module. You may
distribute this module under the terms of either the Gnu GPL,  or the
Artistic License (the same terms as Perl itself).

   For support, please subscribe to the Perl-XML mailing list at the URL
http://listserv.activestate.com/mailman/listinfo/perl-xml

   Matt Sergeant, matt@sergeant.org

SEE ALSO
========

   *Note XML/XPath/Literal: XML/XPath/Literal,, *Note XML/XPath/Boolean:
XML/XPath/Boolean,, *Note XML/XPath/Number: XML/XPath/Number,, *Note
XML/XPath/XMLParser: XML/XPath/XMLParser,, *Note XML/XPath/NodeSet:
XML/XPath/NodeSet,, *Note XML/XPath/PerlSAX: XML/XPath/PerlSAX,, *Note
XML/XPath/Builder: XML/XPath/Builder,.


File: pm.info,  Node: XML/XPath/Boolean,  Next: XML/XPath/Builder,  Prev: XML/XPath,  Up: Module List

Boolean true/false values
*************************

NAME
====

   XML::XPath::Boolean - Boolean true/false values

DESCRIPTION
===========

   XML::XPath::Boolean objects implement simple boolean true/false objects.

API
===

XML::XPath::Boolean->True
-------------------------

   Creates a new Boolean object with a true value.

XML::XPath::Boolean->False
--------------------------

   Creates a new Boolean object with a false value.

value()
-------

   Returns true or false.

to_literal()
------------

   Returns the string "true" or "false".


File: pm.info,  Node: XML/XPath/Builder,  Next: XML/XPath/Literal,  Prev: XML/XPath/Boolean,  Up: Module List

SAX handler for building an XPath tree
**************************************

NAME
====

   XML::XPath::Builder - SAX handler for building an XPath tree

SYNOPSIS
========

     use AnySAXParser;
     use XML::XPath::Builder;

     $builder = XML::XPath::Builder->new();
     $parser = AnySAXParser->new( Handler => $builder );

     $root_node = $parser->parse( Source => [SOURCE] );

DESCRIPTION
===========

   `XML::XPath::Builder' is a SAX handler for building an XML::XPath tree.

   `XML::XPath::Builder' is used by creating a new instance of
`XML::XPath::Builder' and providing it as the Handler for a SAX parser.
Calling `parse()' on the SAX parser will return the root node of the tree
built from that parse.

AUTHOR
======

   Ken MacLeod, <ken@bitsko.slc.ut.us>

SEE ALSO
========

   perl(1), XML::XPath(3)

   PerlSAX.pod in libxml-perl

   Extensible Markup Language (XML) <http://www.w3c.org/XML>


File: pm.info,  Node: XML/XPath/Literal,  Next: XML/XPath/Node,  Prev: XML/XPath/Builder,  Up: Module List

Simple string values.
*********************

NAME
====

   XML::XPath::Literal - Simple string values.

DESCRIPTION
===========

   In XPath terms a Literal is what we know as a string.

API
===

new($string)
------------

   Create a new Literal object with the value in $string. Note that &quot;
and &apos; will be converted to " and ' respectively. That is not part of
the XPath specification, but I consider it useful. Note though that you
have to go to extraordinary lengths in an XML template file (be it XSLT or
whatever) to make use of this:

     <xsl:value-of select="&quot;I'm feeling &amp;quot;sad&amp;quot;&quot;"/>

   Which produces a Literal of:

     I'm feeling "sad"

value()
-------

   Also overloaded as stringification, simply returns the literal string
value.

cmp($literal)
-------------

   Returns the equivalent of perl's cmp operator against the given
$literal.


File: pm.info,  Node: XML/XPath/Node,  Next: XML/XPath/Node/Attribute,  Prev: XML/XPath/Literal,  Up: Module List

internal representation of a node
*********************************

NAME
====

   XML::XPath::Node - internal representation of a node

API
===

   The Node API aims to emulate DOM to some extent, however the API isn't
quite compatible with DOM. This is to ease transition from XML::DOM
programming to XML::XPath. Compatibility with DOM may arise once XML::DOM
gets namespace support.

new
---

   Creates a new node. See the sub-classes for parameters to pass to new().

getNodeType
-----------

   Returns one of ELEMENT_NODE, TEXT_NODE, COMMENT_NODE, ATTRIBUTE_NODE,
PROCESSING_INSTRUCTION_NODE or NAMESPACE_NODE. UNKNOWN_NODE is returned if
the sub-class doesn't implement getNodeType - but that means something is
broken! The constants are exported by default from XML::XPath::Node. The
constants have the same numeric value as the XML::DOM versions.

getParentNode
-------------

   Returns the parent of this node, or undef if this is the root node. Note
that the root node is the root node in terms of XPath - not the root
element node.

to_sax ( $handler | %handlers )
-------------------------------

   Generates sax calls to the handler or handlers. See the PerlSAX docs for
details (not yet implemented correctly).

MORE INFO
=========

   See the sub-classes for the meaning of the rest of the API:

   * *Note XML/XPath/Node/Element: XML/XPath/Node/Element,

   * *Note XML/XPath/Node/Attribute: XML/XPath/Node/Attribute,

   * *Note XML/XPath/Node/Namespace: XML/XPath/Node/Namespace,

   * *Note XML/XPath/Node/Text: XML/XPath/Node/Text,

   * *Note XML/XPath/Node/Comment: XML/XPath/Node/Comment,

   * *Note XML/XPath/Node/PI: XML/XPath/Node/PI,


File: pm.info,  Node: XML/XPath/Node/Attribute,  Next: XML/XPath/Node/Comment,  Prev: XML/XPath/Node,  Up: Module List

a single attribute
******************

NAME
====

   Attribute - a single attribute

API
===

new ( key, value, prefix )
--------------------------

   Create a new attribute node.

getName
-------

   Returns the key for the attribute

getValue / getData
------------------

   Returns the value

getPrefix
---------

   Returns the prefix

toString
--------

   Generates key="value", encoded correctly.


