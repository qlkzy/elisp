This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Cwd,  Next: Cz/Cstocs,  Prev: Curses/Widgets,  Up: Module List

get pathname of current working directory
*****************************************

NAME
====

   getcwd - get pathname of current working directory

SYNOPSIS
========

     use Cwd;
     $dir = cwd;

     use Cwd;
     $dir = getcwd;

     use Cwd;
     $dir = fastgetcwd;

     use Cwd 'chdir';
     chdir "/tmp";
     print $ENV{'PWD'};

     use Cwd 'abs_path';	    # aka realpath()
     print abs_path($ENV{'PWD'});

     use Cwd 'fast_abs_path';
     print fast_abs_path($ENV{'PWD'});

DESCRIPTION
===========

   The getcwd() function re-implements the getcwd(3) (or getwd(3))
functions in Perl.

   The abs_path() function takes a single argument and returns the
absolute pathname for that argument.  It uses the same algorithm as
getcwd().  (Actually, getcwd() is abs_path("."))  Symbolic links and
relative-path components ("." and "..") are resolved to return the
canonical pathname, just like realpath(3).  Also callable as realpath().

   The fastcwd() function looks the same as getcwd(), but runs faster.
It's also more dangerous because it might conceivably chdir() you out of a
directory that it can't chdir() you back into.  If fastcwd encounters a
problem it will return undef but will probably leave you in a different
directory.  For a measure of extra security, if everything appears to have
worked, the fastcwd() function will check that it leaves you in the same
directory that it started in. If it has changed it will die with the
message "Unstable directory path, current directory changed unexpectedly".
That should never happen.

   The fast_abs_path() function looks the same as abs_path(), but runs
faster.  And like fastcwd() is more dangerous.

   The cwd() function looks the same as getcwd and fastgetcwd but is
implemented using the most natural and safe form for the current
architecture. For most systems it is identical to `pwd` (but without the
trailing line terminator).

   It is recommended that cwd (or another *cwd() function) is used in all
code to ensure portability.

   If you ask to override your chdir() built-in function, then your PWD
environment variable will be kept up to date.  (See `Overriding Builtin
Functions', *Note Perlsub: (perl.info)perlsub,.) Note that it will only be
kept up to date if all packages which use chdir import it from Cwd.


File: pm.info,  Node: Cz/Cstocs,  Next: Cz/Sort,  Prev: Cwd,  Up: Module List

conversions of charset encodings for the Czech language
*******************************************************

NAME
====

   Cz::Cstocs - conversions of charset encodings for the Czech language

SYNOPSIS
========

     use Cz::Cstocs;
     my $il2_to_ascii = new Cz::Cstocs 'il2', 'ascii';
     while (<>)
     	{ print &$il2_to_ascii($_); }

     use Cz::Cstocs 'il2_ascii';
     while (<>)
     	{ print il2_ascii($_); }

     use Cz::Cstocs;
     sub il2toascii;
     	# inform the parser that there is a function il2toascii
     *il2toascii = new Cz::Cstocs 'il2', 'ascii';
     	# now define the function
     print il2toascii $data;
     	# thanks to Jan Krynicky for poining this out

DESCRIPTION
===========

   This module helps in converting texts between various charset
encodings, used for Czech and Slovak languages. The instance of the object
*Cz::Cstocs* is created using method new. It takes at least two parameters
for input and output encoding and can be afterwards used as a function
reference to convert strings/lists.  Cz::Cstocs supports fairly free form
of aliases, so iso8859-2, ISO-8859-2, iso88592 and il2 are all aliases of
the same encoding.  For backward compatibility, method *conv* is supported
as well, so the example above could also read

     while (<>)
     	{ print $il2_to_ascii->conv($_); }

   You can also use typeglob syntax.

   The conversion function takes a list and returns list of converted
strings (in the list context) or one string consisting of concatenated
results (in the scalar context).

   You can modify the behaviour of the conversion function by specifying
hash of other options after the encoding names in call to new.

fillstring
     Gives alternate string that will replace characters from input
     encoding that are not present in the output encoding. Default is
     space.

use_accent
     Defines whether the accent file should be used. Default is 1 (true).

nofillstring
     When 1 (true), will keep characters that do not have friends in
     accent nor output encoding, will no replace them with fillstring.
     Default is 0 except for tex, because you probably rather want to keep
     backslashed symbols than loose them.

cstocsdir
     Alternate location for encoding and accent files. The default is the
     `Cz/Cstocs/enc' directory in Perl library tree. This location can
     also be changed with the *CSTOCSDIR* environment variable.

   There is an alternate way to define the conversion function: any
arguments after use Cz::Cstocs that have form encoding_encoding or
encoding_to_encoding are processed and the appropriate functions are
imported. So,

     use Cz::Cstocs qw(pc2_to_il2 il2_ascii);

   define two functions, that are loaded into caller's namespace and can
be used directly. In this case, you cannot specify additional options, you
only have default behaviour.

ERROR HANDLING
==============

   If you request an unknown encoding in the call to new Cz::Cstocs, the
conversion object is not defined and the variable $Cz::Cstocs::errstr is
set to the error message. When you specify unknown encoding in the use
call style (like `use Cz::Cstocs 'il2_ascii';'), the die is called.

AUTHOR
======

   Jan Pazdziora, adelton@fi.muni.cz, created the module version.

   Jan "Yenya" Kasprzak has done the original Un*x implementation.

VERSION
=======

   3.182

SEE ALSO
========

   cstocs(1), perl(1).


File: pm.info,  Node: Cz/Sort,  Next: Cz/Time,  Prev: Cz/Cstocs,  Up: Module List

Czech sort
**********

NAME
====

   Cz::Sort - Czech sort

SYNOPSIS
========

     use Cz::Sort;
     my $result = czcmp("_x j&á", "_&p");
     my @sorted = czsort qw(plachta plaòka Plánièka plánièka plánì);
     print "@sorted\n";

DESCRIPTION
===========

   Implements czech sorting conventions, indepentent on current locales in
effect, which are often bad. Does the four-pass sort. The idea and the
base of the conversion table comes from Petr Olsak's program *csr* and the
code is as compliant with CSN 97 6030 as possible.

   The basic function provided by this module, is *czcmp*. If compares two
scalars and returns the (-1, 0, 1) result. The function can be called
directly, like

     my $result = czcmp("_x j&á", "_&p");

   But for convenience and also because of compatibility with older
versions, there is a function *czsort*. It works on list of strings and
returns that list, hmm, sorted. The function is defined simply like

     sub czsort
     	{ sort { czcmp($a, $b); } @_; }

   standard use of user's function in sort. Hashes would be simply sorted

     @sorted = sort { czcmp($hash{$a}, $hash{$b}) }
     					keys %hash;

   Both *czcmp* and *czsort* are exported into caller's namespace by
default, as well as *cscmp* and *cssort* that are just aliases.

   This module comes with encoding table prepared for ISO-8859-2 (Latin-2)
encoding. If your data come in different one, you might want to check the
module *Cstocs* which can be used for reencoding of the list's data prior
to calling *czsort*, or reencode this module to fit your needs.

VERSION
=======

   0.68

SEE ALSO
========

   perl(1), Cz::Cstocs(3).

AUTHOR
======

   (c) 1997-2000 Jan Pazdziora <adelton@fi.muni.cz>,
http://www.fi.muni.cz/~adelton/

   at Faculty of Informatics, Masaryk University, Brno


File: pm.info,  Node: Cz/Time,  Next: D/oh,  Prev: Cz/Sort,  Up: Module List

Routines for printing dates in Czech
************************************

NAME
====

   Cz::Time - Routines for printing dates in Czech

SYNOPSIS
========

     use Cz::Time;
     my $today = cz_wday() . " " . cz_date();
     my $new_year = " 1. " . cz_month_base(1);

DESCRIPTION
===========

   Implements czech names of months and weekdays. The following functions
are exported:

cz_date
     Converts time (localtime if not specified) into Czech string, eg.
     15. ledna 1997.

cz_month_base, cz_month
     Czech names of months (1..12)

cz_wday, cz_ab_wday
     Czech names of weekdays and weekdays' abreviation.

   By default they are returned in ISO-8859-2.

AUTHORS
=======

   (c) 1997 Jan Pazdziora <adelton@fi.muni.cz>,     1997 Michael Mráka
<michael@fi.muni.cz>

   at Faculty of Informatics, Masaryk University, Brno

VERSION
=======

   0.02

SEE ALSO
========

   perl(1), Cz::Cstocs(3).


File: pm.info,  Node: D/oh,  Next: D/oh/Year,  Prev: Cz/Time,  Up: Module List

Debug module
************

NAME
====

   D'oh - Debug module

SYNOPSIS
========

     #!/usr/bin/perl -w
     use D'oh;
     D'oh::stderr();
     D'oh::stderr('/tmp/stderr');

     #print date and script name/pid to STDERR
     D'oh::date();

     #redirect STDOUT
     D'oh::stdout();
     D'oh::stdout('/tmp/stdout');
     D'oh::date('STDOUT');

     print "hellloooooo\n";
     die "world";

     __END__

     tail /tmp/stdout
     #===== myscript [1743]: Mon Feb  2 11:27:41 1998 =====#
     hellloooooo

     tail /tmp/stderr
     #===== myscript [1743]: Wed Apr  1 11:24:39 1998 =====#
     # world.
     File '/export/home/chrisn/bin/myscript'; Line 15

DESCRIPTION
===========

   The module, when used, prints all `STDERR' (or STDOUT) to a given file,
which is by default `/tmp/D'oh'.

BUGS
====

   Also, multiple scripts can write simultaneously to the same error file,
making it really messy.  If you don't like this, then select different
files for each script or whatever.

Mac OS
======

   Mac OS does not like to have multiple opens to the same file.  Use
different files.  The default directory for the files is `$ENV{TMPDIR}' in
MacPerl, not `/tmp'.

AUTHOR
======

   Chris Nandor, pudge@pobox.com, http://pudge.net/

   Copyright (c) 1998 Chris Nandor.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

VERSION
=======

   Version 0.05 (02 February 1998)


File: pm.info,  Node: D/oh/Year,  Next: DB,  Prev: D/oh,  Up: Module List

Catch stupid mistakes when mucking with years, like Y2K bugs
************************************************************

NAME
====

   D'oh::Year - Catch stupid mistakes when mucking with years, like Y2K
bugs

SYNOPSIS
========

     use D'oh::Year;
     
     ($year) = (localtime)[5];
     print "We're going to party like its 19$year";  # No you're not.
     
     print "Welcome to the year 20$year!";   # Sorry, Buck.

DESCRIPTION
===========

   NO, PERL DOES NOT HAVE A Y2K BUG! but alot of people seem determined to
add it.  Perl, and most other languges through various historical reasons,
like to return years in the form of the number of years since 1900.  This
has led to the false assumption that its actually returning the last two
digits of the current year (1999 => 99) and the mistaken assumption that
you can set the current year as "19$year".

   This is a Y2K bug, the honor is not just given to COBOL progrmamers.

   Bugs of this nature can easily be detected (most of the time) by an
automated process.  This is it.

   When D'oh::Year is used, it provides special versions of localtime() and
gmtime() which return a rigged value for the year.  When used properly
(usually 1900 + $year) you'll notice no difference.  But when used for
*EVIL* it will die with a message about misuse of the year.

   The following things are naughty (where $year is from gmtime() or
localtime()):

     "19$year",  19.$year
     "20$year",  20.$year
     "200$year", 200.$year
     $year -= 100, $year = $year - 100;

   *THE FOLLOWING ARE THE CORRECT WAYS TO MANIPULATE THE DATE* Take note,
please.

     $year += 1900;  # Get the complete year.
     $year %= 100;   # Get the last two digits of the year.
                     # ie "01" in 2001 and "99" in 1999

USAGE
=====

   Its simple.  Just use (do not require!) the module.  If it detects a
problem, it will cause your program to abort with an error.  If you don't
like this, you can use the module with the `:WARN' tag like so:

     use D'oh::Year qw(:WARN);

   and it will warn upon seeing a year mishandling instead of dying.

   Because there is a *slight* performance loss when using D'oh::Year, you
might want to only use it during development and testing.  A few
suggestions for use...

*Shove it down their throats*
     Set up /usr/bin/perl on your development machine as a shell wrapper
     around perl which always uses D'oh::Year:

          #!/bin/sh

          perl -MD::oh::Year $@

     This might be a little draconian for normal usage.

*Add it to your test harness*
*Make a quick check*
     `perl -MD::oh::Year myprogram'

CAVEATS
=======

   This program does its checking at *run time* not compile time.  Thus it
is not simply enough to slap D'oh::Year on a program, run it once and
expect it to find everything.  For a thourough scrubbing you must make
sure every line of code is excersied... but you already have test
harnesses set up to do that, RIGHT?!

TODO
====

*sort @times*
     Sorting time()'s as strings is a common mistake.  I can't detect it
     without some XS code to look at the op stack.

*printf "19%02d", $year*
     I can't handle this without being able to override printf(), but can't
     do that because it has a complex prototype.  This could be handled,
     but it would require a patch to pp_printf.  I can do sprintf(), but I
     don't think its wise to be non-orthoganal and lead non-doc readers on
     that if sprintf() is handled, printf() should be, too.

AUTHOR
======

   Original idea by Andrew Langmead

   Original code by Mark "The Ominous" Dominous

   Cleaned up and maintained by Michael G Schwern <schwern@pobox.com>.


File: pm.info,  Node: DB,  Next: DBD/CSV,  Prev: D/oh/Year,  Up: Module List

programmatic interface to the Perl debugging API (draft, subject to change)
***************************************************************************

NAME
====

   DB - programmatic interface to the Perl debugging API (draft, subject to
change)

SYNOPSIS
========

     package CLIENT;
     use DB;
     @ISA = qw(DB);

     # these (inherited) methods can be called by the client

     CLIENT->register()      # register a client package name
     CLIENT->done()          # de-register from the debugging API
     CLIENT->skippkg('hide::hide')  # ask DB not to stop in this package
     CLIENT->cont([WHERE])       # run some more (until BREAK or another breakpt)
     CLIENT->step()              # single step
     CLIENT->next()              # step over
     CLIENT->ret()               # return from current subroutine
     CLIENT->backtrace()         # return the call stack description
     CLIENT->ready()             # call when client setup is done
     CLIENT->trace_toggle()      # toggle subroutine call trace mode
     CLIENT->subs([SUBS])        # return subroutine information
     CLIENT->files()             # return list of all files known to DB
     CLIENT->lines()             # return lines in currently loaded file
     CLIENT->loadfile(FILE,LINE) # load a file and let other clients know
     CLIENT->lineevents()        # return info on lines with actions
     CLIENT->set_break([WHERE],[COND])
     CLIENT->set_tbreak([WHERE])
     CLIENT->clr_breaks([LIST])
     CLIENT->set_action(WHERE,ACTION)
     CLIENT->clr_actions([LIST])
     CLIENT->evalcode(STRING)  # eval STRING in executing code's context
     CLIENT->prestop([STRING]) # execute in code context before stopping
     CLIENT->poststop([STRING])# execute in code context before resuming

     # These methods will be called at the appropriate times.
     # Stub versions provided do nothing.
     # None of these can block.

     CLIENT->init()          # called when debug API inits itself
     CLIENT->stop(FILE,LINE) # when execution stops
     CLIENT->idle()          # while stopped (can be a client event loop)
     CLIENT->cleanup()       # just before exit
     CLIENT->output(LIST)    # called to print any output that API must show

DESCRIPTION
===========

   Perl debug information is frequently required not just by debuggers,
but also by modules that need some "special" information to do their job
properly, like profilers.

   This module abstracts and provides all of the hooks into Perl internal
debugging functionality, so that various implementations of Perl debuggers
(or packages that want to simply get at the "privileged" debugging data)
can all benefit from the development of this common code.  Currently used
by Swat, the perl/Tk GUI debugger.

   Note that multiple "front-ends" can latch into this debugging API
simultaneously.  This is intended to facilitate things like debugging with
a command line and GUI at the same time, debugging debuggers etc.  [Sounds
nice, but this needs some serious support - GSAR]

   In particular, this API does not provide the following functions:

   * data display

   * command processing

   * command alias management

   * user interface (tty or graphical)

   These are intended to be services performed by the clients of this API.

   This module attempts to be squeaky clean w.r.t `use strict;' and when
warnings are enabled.

Global Variables
----------------

   The following "public" global names can be read by clients of this API.
Beware that these should be considered "readonly".

$DB::sub
     Name of current executing subroutine.

%DB::sub
     The keys of this hash are the names of all the known subroutines.
     Each value is an encoded string that has the sprintf(3) format
     `("%s:%d-%d", filename, fromline, toline)'.

$DB::single
     Single-step flag.  Will be true if the API will stop at the next
     statement.

$DB::signal
     Signal flag. Will be set to a true value if a signal was caught.
     Clients may check for this flag to abort time-consuming operations.

$DB::trace
     This flag is set to true if the API is tracing through subroutine
     calls.

@DB::args
     Contains the arguments of current subroutine, or the `@ARGV' array if
     in the toplevel context.

@DB::dbline
     List of lines in currently loaded file.

%DB::dbline
     Actions in current file (keys are line numbers).  The values are
     strings that have the sprintf(3) format `("%s\000%s", breakcondition,
     actioncode)'.

$DB::package
     Package namespace of currently executing code.

$DB::filename
     Currently loaded filename.

$DB::subname
     Fully qualified name of currently executing subroutine.

$DB::lineno
     Line number that will be executed next.

API Methods
-----------

   The following are methods in the DB base class.  A client must access
these methods by inheritance (*not* by calling them directly), since the
API keeps track of clients through the inheritance mechanism.

CLIENT->register()
     register a client object/package

CLIENT->evalcode(STRING)
     eval STRING in executing code context

CLIENT->skippkg('D::hide')
     ask DB not to stop in these packages

CLIENT->run()
     run some more (until a breakpt is reached)

CLIENT->step()
     single step

CLIENT->next()
     step over

CLIENT->done()
     de-register from the debugging API

Client Callback Methods
-----------------------

   The following "virtual" methods can be defined by the client.  They will
be called by the API at appropriate points.  Note that unless specified
otherwise, the debug API only defines empty, non-functional default
versions of these methods.

CLIENT->init()
     Called after debug API inits itself.

CLIENT->prestop([STRING])
     Usually inherited from DB package.  If no arguments are passed,
     returns the prestop action string.

CLIENT->stop()
     Called when execution stops (w/ args file, line).

CLIENT->idle()
     Called while stopped (can be a client event loop).

CLIENT->poststop([STRING])
     Usually inherited from DB package.  If no arguments are passed,
     returns the poststop action string.

CLIENT->evalcode(STRING)
     Usually inherited from DB package.  Ask for a STRING to be eval-ed in
     executing code context.

CLIENT->cleanup()
     Called just before exit.

CLIENT->output(LIST)
     Called when API must show a message (warnings, errors etc.).

BUGS
====

   The interface defined by this module is missing some of the later
additions to perl's debugging functionality.  As such, this interface
should be considered highly experimental and subject to change.

AUTHOR
======

   Gurusamy Sarathy	gsar@activestate.com

   This code heavily adapted from an early version of perl5db.pl
attributable to Larry Wall and the Perl Porters.


File: pm.info,  Node: DBD/CSV,  Next: DBD/File,  Prev: DB,  Up: Module List

DBI driver for CSV files
************************

NAME
====

   DBD::CSV - DBI driver for CSV files

SYNOPSIS
========

     use DBI;
     $dbh = DBI->connect("DBI:CSV:f_dir=/home/joe/csvdb")
         or die "Cannot connect: " . $DBI::errstr;
     $sth = $dbh->prepare("CREATE TABLE a (id INTEGER, name CHAR(10))")
         or die "Cannot prepare: " . $dbh->errstr();
     $sth->execute() or die "Cannot execute: " . $sth->errstr();
     $sth->finish();
     $dbh->disconnect();

     # Read a CSV file with ";" as the separator, as exported by
     # MS Excel. Note we need to escape the ";", otherwise it
     # would be treated as an attribute separator.
     $dbh = DBI->connect(qq{DBI:CSV:csv_sep_char=\\;});
     $sth = $dbh->prepare("SELECT * FROM info");

     # Same example, this time reading "info.csv" as a table:
     $dbh = DBI->connect(qq{DBI:CSV:csv_sep_char=\\;});
     $dbh->{'csv_tables'}->{'info'} = { 'file' => 'info.csv'};
     $sth = $dbh->prepare("SELECT * FROM info");

WARNING
=======

   THIS IS ALPHA SOFTWARE. It is *only* 'Alpha' because the interface (API)
is not finalized. The Alpha status does not reflect code quality or
stability.

DESCRIPTION
===========

   The DBD::CSV module is yet another driver for the DBI (Database
independent interface for Perl). This one is based on the SQL "engine"
SQL::Statement and the abstract DBI driver DBD::File and implements access
to so-called CSV files (Comma separated values). Such files are mostly
used for exporting MS Access and MS Excel data.

   See `DBI(3)' in this node for details on DBI, `SQL::Statement(3)' in
this node for details on SQL::Statement and `DBD::File(3)' in this node
for details on the base class DBD::File.

Prerequisites
-------------

   The only system dependent feature that DBD::File uses, is the flock()
function. Thus the module should run (in theory) on any system with a
working flock(), in particular on all Unix machines and on Windows NT.
Under Windows 95 and MacOS the use of flock() is disabled, thus the module
should still be usable,

   Unlike other DBI drivers, you don't need an external SQL engine or a
running server. All you need are the following Perl modules, available
from any CPAN mirror, for example

     ftp://ftp.funet.fi/pub/languages/perl/CPAN/modules/by-module

DBI
     the DBI (Database independent interface for Perl), version 1.00 or a
     later release

SQL::Statement
     a simple SQL engine

Text::CSV_XS
     this module is used for writing rows to or reading rows from CSV
     files.

Installation
------------

   Installing this module (and the prerequisites from above) is quite
simple.  You just fetch the archive, extract it with

     gzip -cd DBD-CSV-0.1000.tar.gz | tar xf -

   (this is for Unix users, Windows users would prefer WinZip or something
similar) and then enter the following:

     cd DBD-CSV-0.1000
     perl Makefile.PL
     make
     make test

   If any tests fail, let me know. Otherwise go on with

     make install

   Note that you almost definitely need root or administrator permissions.
If you don't have them, read the ExtUtils::MakeMaker man page for details
on installing in your own directories. *Note ExtUtils/MakeMaker:
ExtUtils/MakeMaker,.

Creating a database handle
--------------------------

   Creating a database handle usually implies connecting to a database
server.  Thus this command reads

     use DBI;
     my $dbh = DBI->connect("DBI:CSV:f_dir=$dir");

   The directory tells the driver where it should create or open tables
(a.k.a. files). It defaults to the current directory, thus the following
are equivalent:

     $dbh = DBI->connect("DBI:CSV:");
     $dbh = DBI->connect("DBI:CSV:f_dir=.");

   You may set other attributes in the DSN string, separated by semicolons.

Creating and dropping tables
----------------------------

   You can create and drop tables with commands like the following:

     $dbh->do("CREATE TABLE $table (id INTEGER, name CHAR(64))");
     $dbh->do("DROP TABLE $table");

   Note that currently only the column names will be stored and no other
data.  Thus all other information including column type (INTEGER or
CHAR(x), for example), column attributes (NOT NULL, PRIMARY KEY, ...) will
silently be discarded. This may change in a later release.

   A drop just removes the file without any warning.

   See `DBI(3)' in this node for more details.

   Table names cannot be arbitrary, due to restrictions of the SQL syntax.
I recommend that table names are valid SQL identifiers: The first
character is alphabetic, followed by an arbitrary number of alphanumeric
characters. If you want to use other files, the file names must start with
'/', './' or '../' and they must not contain white space.

Inserting, fetching and modifying data
--------------------------------------

   The following examples insert some data in a table and fetch it back:
First all data in the string:

     $dbh->do("INSERT INTO $table VALUES (1, "
              . $dbh->quote("foobar") . ")");

   Note the use of the quote method for escaping the word 'foobar'. Any
string must be escaped, even if it doesn't contain binary data.

   Next an example using parameters:

     $dbh->do("INSERT INTO $table VALUES (?, ?)", undef,
     	     2, "It's a string!");

   Note that you don't need to use the quote method here, this is done
automatically for you. This version is particularly well designed for
loops. Whenever performance is an issue, I recommend using this method.

   You might wonder about the undef. Don't wonder, just take it as it is.
:-) It's an attribute argument that I have never ever used and will be
parsed to the prepare method as a second argument.

   To retrieve data, you can use the following:

     my($query) = "SELECT * FROM $table WHERE id > 1 ORDER BY id";
     my($sth) = $dbh->prepare($query);
     $sth->execute();
     while (my $row = $sth->fetchrow_hashref) {
         print("Found result row: id = ", $row->{'id'},
               ", name = ", $row->{'name'});
     }
     $sth->finish();

   Again, column binding works: The same example again.

     my($query) = "SELECT * FROM $table WHERE id > 1 ORDER BY id";
     my($sth) = $dbh->prepare($query);
     $sth->execute();
     my($id, $name);
     $sth->bind_columns(undef, \$id, \$name);
     while ($sth->fetch) {
         print("Found result row: id = $id, name = $name\n");
     }
     $sth->finish();

   Of course you can even use input parameters. Here's the same example
for the third time:

     my($query) = "SELECT * FROM $table WHERE id = ?";
     my($sth) = $dbh->prepare($query);
     $sth->bind_columns(undef, \$id, \$name);
     for (my($i) = 1;  $i <= 2;   $i++) {
     	$sth->execute($id);
     	if ($sth->fetch) {
     	    print("Found result row: id = $id, name = $name\n");
     	}
         $sth->finish();
     }

   See `DBI(3)' in this node for details on these methods. See
`SQL::Statement(3)' in this node for details on the WHERE clause.

   Data rows are modified with the UPDATE statement:

     $dbh->do("UPDATE $table SET id = 3 WHERE id = 1");

   Likewise you use the DELETE statement for removing rows:

     $dbh->do("DELETE FROM $table WHERE id > 1");

Error handling
--------------

   In the above examples we have never cared about return codes. Of course,
this cannot be recommended. Instead we should have written (for example):

     my($query) = "SELECT * FROM $table WHERE id = ?";
     my($sth) = $dbh->prepare($query)
         or die "prepare: " . $dbh->errstr();
     $sth->bind_columns(undef, \$id, \$name)
         or die "bind_columns: " . $dbh->errstr();
     for (my($i) = 1;  $i <= 2;   $i++) {
     	$sth->execute($id)
     	    or die "execute: " . $dbh->errstr();
     	if ($sth->fetch) {
     	    print("Found result row: id = $id, name = $name\n");
     	}
     }
     $sth->finish($id)
         or die "finish: " . $dbh->errstr();

   Obviously this is tedious. Fortunately we have DBI's *RaiseError*
attribute:

     $dbh->{'RaiseError'} = 1;
     $@ = '';
     eval {
         my($query) = "SELECT * FROM $table WHERE id = ?";
         my($sth) = $dbh->prepare($query);
         $sth->bind_columns(undef, \$id, \$name);
         for (my($i) = 1;  $i <= 2;   $i++) {
     	    $sth->execute($id);
     	    if ($sth->fetch) {
     	        print("Found result row: id = $id, name = $name\n");
     	    }
         }
         $sth->finish($id);
     };
     if ($@) { die "SQL database error: $@"; }

   This is not only shorter, it even works when using DBI methods within
subroutines.

Metadata
--------

   The following attributes are handled by DBI itself and not by DBD::File,
thus they all work as expected:

     Active
     ActiveKids
     CachedKids
     CompatMode             (Not used)
     InactiveDestroy
     Kids
     PrintError
     RaiseError
     Warn                   (Not used)

   The following DBI attributes are handled by DBD::File:

AutoCommit
     Always on

ChopBlanks
     Works

NUM_OF_FIELDS
     Valid after `$sth->execute'

NUM_OF_PARAMS
     Valid after `$sth->prepare'

NAME
     Valid after `$sth->execute'; undef for Non-Select statements.

NULLABLE
     Not really working. Always returns an array ref of one's, as DBD::CSV
     doesn't verify input data. Valid after `$sth->execute'; undef for
     non-Select statements.

   These attributes and methods are not supported:

     bind_param_inout
     CursorName
     LongReadLen
     LongTruncOk

   In addition to the DBI attributes, you can use the following dbh
attributes:

f_dir
     This attribute is used for setting the directory where CSV files are
     opened. Usually you set it in the dbh, it defaults to the current
     directory ("."). However, it is overwritable in the statement handles.

csv_eol
csv_sep_char
csv_quote_char
csv_escape_char
csv_class
csv_csv
     The attributes csv_eol, csv_sep_char, csv_quote_char and
     csv_escape_char are corresponding to the respective attributes of the
     Text::CSV_XS object. You want to set these attributes if you have
     unusual CSV files like `/etc/passwd' or MS Excel generated CSV files
     with a semicolon as separator. Defaults are "\015\012", ';', '"' and
     '"', respectively.

     The attributes are used to create an instance of the class csv_class,
     by default Text::CSV_XS. Alternatively you may pass an instance as
     csv_csv, the latter takes precedence. Note that the binary attribute
     must be set to a true value in that case.

     Additionally you may overwrite these attributes on a per-table base in
     the csv_tables attribute.

csv_tables
     This hash ref is used for storing table dependent metadata. For any
     table it contains an element with the table name as key and another
     hash ref with the following attributes:

    file
          The tables file name; defaults to

               "$dbh->{f_dir}/$table"

    eol
    sep_char
    quote_char
    escape_char
    class
    csv
          These correspond to the attributes csv_eol, csv_sep_char,
          csv_quote_char, csv_escape_char, csv_class and csv_csv.  The
          difference is that they work on a per-table base.

    col_names
    skip_first_row
          By default DBD::CSV assumes that column names are stored in the
          first row of the CSV file. If this is not the case, you can
          supply an array ref of table names with the col_names attribute.
          In that case the attribute skip_first_row will be set to FALSE.

          If you supply an empty array ref, the driver will read the first
          row for you, count the number of columns and create column names
          like `col0', `col1', ...

   Example: Suggest you want to use `/etc/passwd' as a CSV file. :-) There
simplest way is:

     require DBI;
     my $dbh = DBI->connect("DBI:CSV:f_dir=/etc;csv_eol=\n;"
                            . "csv_sep_char=:;csv_quote_char=;"
                            . "csv_escape_char=");
     $dbh->{'csv_tables'}->{'passwd'} = {
         'col_names' => ["login", "password", "uid", "gid", "realname",
                         "directory", "shell"]
     };
     $sth = $dbh->prepare("SELECT * FROM passwd");

   Another possibility where you leave all the defaults as they are and
overwrite them on a per table base:

     require DBI;
     my $dbh = DBI->connect("DBI:CSV:");
     $dbh->{'csv_tables'}->{'passwd'} = {
         'eol' => "\n",
         'sep_char' => ":",
         'quote_char' => undef,
         'escape_char' => undef,
         'file' => '/etc/passwd',
         'col_names' => ["login", "password", "uid", "gid", "realname",
                         "directory", "shell"]
     };
     $sth = $dbh->prepare("SELECT * FROM passwd");

Driver private methods
----------------------

   These methods are inherited from DBD::File:

data_sources
     The data_sources method returns a list of subdirectories of the
     current directory in the form "DBI:CSV:directory=$dirname".

     If you want to read the subdirectories of another directory, use

          my($drh) = DBI->install_driver("CSV");
          my(@list) = $drh->data_sources('f_dir' => '/usr/local/csv_data' );

list_tables
     This method returns a list of file names inside $dbh->{'directory'}.
     Example:

          my($dbh) = DBI->connect("DBI:CSV:directory=/usr/local/csv_data");
          my(@list) = $dbh->func('list_tables');

     Note that the list includes all files contained in the directory, even
     those that have non-valid table names, from the view of SQL. See
     `Creating and dropping tables' in this node above.

Data restrictions
-----------------

   When inserting and fetching data, you will sometimes be surprised:
DBD::CSV doesn't correctly handle data types, in particular NULLs. If you
insert integers, it might happen, that fetch returns a string. Of course,
a string containing the integer, so that's perhaps not a real problem. But
the following will never work:

     $dbh->do("INSERT INTO $table (id, name) VALUES (?, ?)",
              undef, "foo bar");
     $sth = $dbh->prepare("SELECT * FROM $table WHERE id IS NULL");
     $sth->execute();
     my($id, $name);
     $sth->bind_columns(undef, \$id, \$name);
     while ($sth->fetch) {
         printf("Found result row: id = %s, name = %s\n",
               defined($id) ? $id : "NULL",
               defined($name) ? $name : "NULL");
     }
     $sth->finish();

   The row we have just inserted, will never be returned! The reason is
obvious, if you examine the CSV file: The corresponding row looks like

     "","foo bar"

   In other words, not a NULL is stored, but an empty string. CSV files
don't have a concept of NULL values. Surprisingly the above example works,
if you insert a NULL value for the name! Again, you find the explanation
by examining the CSV file:

     ""

   In other words, DBD::CSV has "emulated" a NULL value by writing a row
with less columns. Of course this works only if the rightmost column is
NULL, the two rightmost columns are NULL, ..., but the leftmost column
will never be NULL!

   See `Creating and dropping tables' in this node above for table name
restrictions.

TODO
====

   Extensions of DBD::CSV:

CSV file scanner
     Write a simple CSV file scanner that reads a CSV file and attempts to
     guess sep_char, quote_char, escape_char and eol automatically.

   These are merely restrictions of the DBD::File or SQL::Statement
modules:

Joins
     The current version of the module works with single table SELECTs
     only, although the basic design of the SQL::Statement module allows
     joins and the like.

Table name mapping
     Currently it is not possible to use files with names like `names.csv'.
     Instead you have to use soft links or rename files. As an alternative
     one might use, for example a dbh attribute 'table_map'. It might be a
     hash ref, the keys being the table names and the values being the file
     names.

Column name mapping
     Currently the module assumes that column names are stored in the first
     row. While this is fine in most cases, there should be a possibility
     of setting column names and column number from the programmer: For
     example MS Access doesn't export column names by default.

KNOWN BUGS
==========

   * The module is using flock() internally. However, this function is not
     available on platforms. Using flock() is disabled on MacOS and Windows
     95: There's no locking at all (perhaps not so important on these
     operating systems, as they are for single users anyways).

AUTHOR AND COPYRIGHT
====================

   This module is Copyright (C) 1998 by

     Jochen Wiedmann
     Am Eisteich 9
     72555 Metzingen
     Germany

     Email: joe@ispsoft.de
     Phone: +49 7123 14887

   All rights reserved.

   You may distribute this module under the terms of either the GNU
General Public License or the Artistic License, as specified in the Perl
README file.

SEE ALSO
========

   `DBI(3)' in this node, `Text::CSV_XS(3)' in this node,
`SQL::Statement(3)' in this node

   For help on the use of DBD::CSV, see the DBI users mailing list:

     http://www.isc.org/dbi-lists.html

   For general information on DBI see

     http://www.symbolstone.org/technology/perl/DBI


File: pm.info,  Node: DBD/File,  Next: DBD/JDBC,  Prev: DBD/CSV,  Up: Module List

Base class for writing DBI drivers for plain files
**************************************************

NAME
====

   DBD::File - Base class for writing DBI drivers for plain files

SYNOPSIS
========

     use DBI;
     $dbh = DBI->connect("DBI:File:f_dir=/home/joe/csvdb")
         or die "Cannot connect: " . $DBI::errstr;
     $sth = $dbh->prepare("CREATE TABLE a (id INTEGER, name CHAR(10))")
         or die "Cannot prepare: " . $dbh->errstr();
     $sth->execute() or die "Cannot execute: " . $sth->errstr();
     $sth->finish();
     $dbh->disconnect();

DESCRIPTION
===========

   The DBD::File module is not a true DBI driver, but an abstract base
class for deriving concrete DBI drivers from it. The implication is, that
these drivers work with plain files, for example CSV files or INI files.
The module is based on the SQL::Statement module, a simple SQL engine.

   See `DBI(3)' in this node for details on DBI, `SQL::Statement(3)' in
this node for details on SQL::Statement and `DBD::CSV(3)' in this node or
`DBD::IniFile(3)' in this node for example drivers.

Metadata
--------

   The following attributes are handled by DBI itself and not by DBD::File,
thus they all work like expected:

     Active
     ActiveKids
     CachedKids
     CompatMode             (Not used)
     InactiveDestroy
     Kids
     PrintError
     RaiseError
     Warn                   (Not used)

   The following DBI attributes are handled by DBD::File:

AutoCommit
     Always on

ChopBlanks
     Works

NUM_OF_FIELDS
     Valid after `$sth-'execute>

NUM_OF_PARAMS
     Valid after `$sth-'prepare>

NAME
     Valid after `$sth-'execute>; undef for Non-Select statements.

NULLABLE
     Not really working, always returns an array ref of one's, as DBD::CSV
     doesn't verify input data. Valid after `$sth-'execute>; undef for
     Non-Select statements.

   These attributes and methods are not supported:

     bind_param_inout
     CursorName
     LongReadLen
     LongTruncOk

   Additional to the DBI attributes, you can use the following dbh
attribute:

f_dir
     This attribute is used for setting the directory where CSV files are
     opened. Usually you set it in the dbh, it defaults to the current
     directory ("."). However, it is overwritable in the statement handles.

Driver private methods
----------------------

data_sources
     The data_sources method returns a list of subdirectories of the
     current directory in the form "DBI:CSV:f_dir=$dirname".

     If you want to read the subdirectories of another directory, use

          my($drh) = DBI->install_driver("CSV");
          my(@list) = $drh->data_sources('f_dir' => '/usr/local/csv_data' );

list_tables
     This method returns a list of file names inside $dbh->{'f_dir'}.
     Example:

          my($dbh) = DBI->connect("DBI:CSV:f_dir=/usr/local/csv_data");
          my(@list) = $dbh->func('list_tables');

     Note that the list includes all files contained in the directory, even
     those that have non-valid table names, from the view of SQL. See
     `Creating and dropping tables' in this node above.

TODO
====

Joins
     The current version of the module works with single table SELECT's
     only, although the basic design of the SQL::Statement module allows
     joins and the likes.

Table name mapping
     Currently it is not possible to use files with names like `names.csv'.
     Instead you have to use soft links or rename files. As an alternative
     one might use, for example a dbh attribute 'table_map'. It might be a
     hash ref, the keys being the table names and the values being the file
     names.

KNOWN BUGS
==========

   * The module is using flock() internally. However, this function is not
     available on all platforms. Using flock() is disabled on MacOS and
     Windows 95: There's no locking at all (perhaps not so important on
     MacOS and Windows 95, as there's a single user anyways).

AUTHOR AND COPYRIGHT
====================

   This module is Copyright (C) 1998 by

     Jochen Wiedmann
     Am Eisteich 9
     72555 Metzingen
     Germany

     Email: joe@ispsoft.de
     Phone: +49 7123 14887

   All rights reserved.

   You may distribute this module under the terms of either the GNU
General Public License or the Artistic License, as specified in the Perl
README file.

SEE ALSO
========

   `DBI(3)' in this node, `Text::CSV_XS(3)' in this node,
`SQL::Statement(3)' in this node


File: pm.info,  Node: DBD/JDBC,  Next: DBD/Ovrimos,  Prev: DBD/File,  Up: Module List

JDBC proxy driver for the DBI module
************************************

NAME
====

   DBD::JDBC - JDBC proxy driver for the DBI module

SYNOPSIS
========

     use DBI;
     
     $dbh = DBI->connect("dbi:JDBC:hostname=$hostname;port=$port;url=$url",
                         $user, $password);

     # See the DBI module documentation.

REQUIRES
========

     Perl 5.004 or higher
     DBI 1.13 or higher
     Convert::BER 1.31
     Java Virtual Machine compatible with JDK 1.1
     A JDBC driver

DESCRIPTION
===========

   DBD::JDBC is a Perl module which works in conjunction with a server
written in Java to provide a DBI front end to a JDBC driver. The Perl
module and Java server may be installed on different machines, as long as
socket connections are allowed. The Java server portion is multi-threaded
and supports multiple simultaneous connections.

   This driver currently supports JDBC drivers which implement the JDBC
1.22 interface.  JDBC 2.0-compatible drivers are expected to work, but no
JDBC 2.0 functionality is explicitly exposed via DBD::JDBC. The DBI
`$h->func' method exposes additional JDBC and driver-specific methods.
Only Java methods with primitive or String parameters and return types are
currently supported in this way.

   The expected use for this module is as a DBI interface to databases
with JDBC drivers but no DBI drivers. The implementation of this module
was originally done for a non-SQL database in order to take advantage of
the existing SQL parser in the database's JDBC driver.

   The Java classes provided with this module also allow a Java
application or servlet to create a JDBC connection and then execute a Perl
script which can use that pre-existing JDBC connection via DBI. This
particular functionality was implemented in order to allow Perl
customizations to a Java servlet-based application. See the example in the
`example/' directory.

CONNECTING
==========

   Before using DBD::JDBC, you must start the DBD::JDBC server.

Starting the server
-------------------

   The DBD::JDBC server is a Java application intended to be run from the
command line. It may be installed, along with whatever JDBC driver you
wish to use, on any host capable of accessing the database you wish to use
via JDBC. Perl applications using DBD::JDBC will open a socket connection
to this server. You will need to know the hostname and port where this
server is running.

   To start the server,

  1. Place the dbd_jdbc.jar file and your database's JDBC driver on the
     machine where you wish to run the server.

  2. Add dbd_jdbc.jar and your database's JDBC driver to your classpath.
     Follow any other instructions which came with your JDBC driver. For
     example, a type 2 JDBC driver may require that the database's native
     libraries be added to your path or library path.

  3. Start the server, providing at least the required system properties
     on the command line:

    jdbc.drivers *(required)*
          This should be set to the complete class name of your JDBC
          driver. If you want to use more than one JDBC driver, use a
          colon-separated list of driver names. See the standard Javadoc
          documentation for `java.sql.DriverManager' for an example.

    dbd.port *(required)*
          This is the port to which this server will listen. Your Perl
          client applications will need to know this in order to connect.

    dbd.trace
          If set, this value indicates the tracing level for the server.
          Tracing output will be written to stderr. Legal values are
          silent (the default), `brief', verbose, `tedious', and `abusive'.

        Example

     java -Djdbc.drivers=foo.bar.Driver -Ddbd.port=12345 com.vizdom.dbd.jdbc.Server

   Here is a simple example shell script for running the server (written
for bash).

     export CLASSPATH=dbd_jdbc.jar:/oracle/jdbc/classes111.zip:$CLASSPATH
     DRIVERS=oracle.jdbc.driver.OracleDriver
     java -Djdbc.drivers=$DRIVERS -Ddbd.port=9001 -Ddbd.trace=tedious com.vizdom.dbd.jdbc.Server

Connecting to the server
------------------------

   A dsn for DBD::JDBC has the following form:

     dbi:JDBC:hostname=$host;port=$port;url=$url;jdbc_character_set=$charset

   where

   * $host is the hostname on which the DBD::JDBC server is running
     (optionally followed by `:$port'; if so, the port name/value pair is
     optional).

   * $port is the port on which the DBD::JDBC server is running.

   * `$url' is a complete JDBC url for your JDBC driver. You might want to
     test this URL in a Java application (in the same environment in which
     you intend to run the DBD::JDBC server) before attempting to connect
     from Perl. Your JDBC url may need to include your database host and
     port information; these values are distinct from those needed in the
     DBD::JDBC dsn, which are for the DBD::JDBC server, not the database.

     If the JDBC url contains the characters ';' or '=', those characters
     must be URL-encoded. For example,

          $url =~ s/([=;])/uc sprintf("%%%02x",ord($1))/eg;

     The driver will unescape the url before sending it to the JDBC
     driver. [See the driver code if you really want to know why.]

   * $charset is the character set used by your DBI application (i.e. the
     character set in use on whichever machine is running Perl, not the
     machine running the DBD::JDBC server, unless they're the same). This
     should be specified in the form of a valid Java character encoding
     name. If no character set is given, the driver defaults to ISO8859_1.
     See
     http://java.sun.com/products/jdk/1.1/docs/guide/intl/encoding.doc.html
     for a list of supported encodings. The character set name must be
     encoded in ASCII so that the server can appropriately decode it.

     Any strings sent to the DBD::JDBC server as parameter values will be
     converted from this encoding to Unicode (Java's native encoding). Use
     `bind_param' and a type hint to avoid character set conversion of
     binary data. Data being returned as strings (everything other than
     binary columns) will be converted to this encoding.

     The character set in use will be available as the database handle
     attribute 'jdbc_character_set'. Changing this attribute will have no
     effect on character conversion; the character set is established at
     connection time.

   Example

     $dsn = "dbi:JDBC:hostname=myhost;port=12345;url=jdbc:odbc:mydatasource";
     $dsn = "dbi:JDBC:hostname=myhost:12345;url=jdbc:oracle:thin:\@mydbhost:1521:test;jdbc_character_set=ASCII";

USAGE NOTES
===========

Calling JDBC methods
--------------------

   JDBC methods are exposed using the DBI `$h->func' method and Java
reflection. This feature is not intended to replace any existing DBI
methods, merely to provide access to JDBC-specific methods with no DBI
equivalent. Reflection, rather than explicit methods corresponding to
methods in the JDBC API, is used in order to allow access to
driver-specific methods not in the JDBC API.

   The following limitations apply:

   * Only public methods can be called.

   * In general, only methods whose parameters and return values are
     primitive types (int, boolean, void, etc.) or Strings can be called.
     See below for more details.

   * DBD::JDBC doesn't know which methods are being called when reflection
     is used. This means that interleaving DBI methods and calls to JDBC
     methods using `func' may leave DBD::JDBC in an inconsistent state.
     One example of this is `$sth->rows': if you've called
     `ResultSet.next' directly, rather than using `$sth->fetch', the row
     count will not accurately reflect the rows in the result set.

   * Methods can only be called on the Connection, Statement, ResultSet,
     and ResultSetMetaData objects.

   The JDBC method name is used as the func method name. Parameters are
passed as strings by default. To pass parameters of other types, pass the
parameter as reference to an array in which the first element is the
parameter and the second is one of the DBI SQL_XXX typecodes. For example,

     $h->func("string parameter", [11 => SQL_INTEGER],
              [1 => SQL_BIT], "method_name");

   It is very important to use the correct typecodes for the actual
parameter types of the Java method in order to enable Java reflection to
locate the correct method. The method will be looked up using the
`java.lang.class.getMethod(String, Class[])' method, so if the parameter
types don't match the actual method parameters, the method won't be found.

   SQL types are mapped to Java types by mapping the DBI constants to
values from java.sql.Types, then mapping the `java.sql.Types' values to
Java types.

     DBI constant           java.sql.Types constant    Java type
     -----------------------------------------------------------
     SQL_CHAR               CHAR                       String
     SQL_VARCHAR            VARCHAR                    String
     SQL_LONGVARCHAR        LONGVARCHAR                String
     SQL_BINARY             BINARY                     byte[]
     SQL_VARBINARY          VARBINARY                  byte[]
     SQL_LONGVARBINARY      LONGVARBINARY              byte[]
     SQL_BIT                BIT                        boolean
     SQL_TINYINT            TINYINT                    byte
     SQL_SMALLINT           SMALLINT                   short
     SQL_INTEGER            INTEGER                    int
     SQL_BIGINT             BIGINT                     long
     SQL_REAL               REAL                       float
     SQL_FLOAT              FLOAT                      double
     SQL_DOUBLE             DOUBLE                     double
     SQL_NUMERIC            NUMERIC                    java.math.BigDecimal
     SQL_DECIMAL            DECIMAL                    java.math.BigDecimal
     SQL_DATE               DATE                       java.sql.Date
     SQL_TIME               TIME                       java.sql.Time
     SQL_TIMESTAMP          TIMESTAMP                  java.sql.Timestamp

   The mapping from `java.sql.Types' to Java types is taken from Table
21.6.1 in *JDBC Data Access with Java*, by Hamilton, Cattell, and Fisher.
See also Table 47.9.1 in *JDBC API Tutorial and Reference, Second
Edition*, by White, Fisher, Cattell, Hamilton, and Hapner.

   For `SQL_DATE', `SQL_TIME', and `SQL_TIMESTAMP' parameters, the default
JDBC string representations for these types must be used.

     SQL_DATE: yyyy-mm-dd
     SQL_TIME: hh:mm:ss
     SQL_TIMESTAMP: yyyy-mm-dd hh:mm:ss.f

   (The `.f' portion of the timestamp format is in nanoseconds and is
optional.)

   Possible return values from `$h->func' are undef if the Java method
returned null or had a void return type, 1 or 0 if the Java method had a
boolean return type, or a scalar for any other return type (the Object
returned by `java.lang.reflect.Method.invoke' will be converted to a String
by calling its toString method).

   You are not limited to calling methods defined by the JDBC API. Any
public method defined by your JDBC driver on the available objects, with
parameters and return type as described above, may be called.

   *Important*: You must check for errors explicitly after calling `func'.
For example,

     $h->func("method");
     if ($h->err) {
        ## handle error
     }

   *Connection methods*

   To call JDBC methods on the JDBC Connection object, use the `func'
method on the $dbh handle.

   Examples

     $ret = $dbh->func("getAutoCommit");
         $dbh->func([1 => SQL_BIT], "setAutoCommit");
         $ret = $dbh->func("select * from client", "nativeSQL");
         $dbh->func([4 => SQL_INTEGER], "setTransactionIsolation");

   *Statement, ResultSet, and ResultSetMetaData methods*

   To call JDBC methods on the JDBC Statement, ResultSet, and
ResultSetMetaData objects, use the `func' method on the $sth handle and
prefix the method name with one of the listed interface names. You may use
either Statement or PreparedStatement to indicate the current
PreparedStatement object, since DBD::JDBC uses PreparedStatements
internally.

   ResultSet and ResultSetMetaData methods are not available until after
`$sth->execute' has been called.

   Examples

     $ret = $sth->func("Statement.getMaxFieldSize");
     $sth1->func("mycursor", "Statement.setCursorName");
     $sth1->func([22 => SQL_INTEGER], "Statement.setMaxFieldSize");

     $ret = $sth1->func("ResultSet.next");
     $ret = $sth1->func("cname", "ResultSet.getString");
     $ret = $sth2->func("eno", [5003 => SQL_INTEGER], "ResultSet.updateInt");

     $ret = $sth1->func([1 => SQL_INTEGER], "ResultSetMetaData.getSchemaName");

   Notes

   If for some reason you reach the end of a ResultSet using
`$sth->func("ResultSet.next")' rather than one of the standard DBI methods
(fetch, etc.), the DBI statement handle will continue to think that it's
active. You must call `$sth->finish' explicitly in this case.

   Be aware of which JDBC methods are called by the standard DBI methods.
For example, `$sth->fetch' calls next and reads all the columns in the
current row. With some JDBC drivers, you will not be able to call
$sth->fetch followed by `$sth->func("column_name", "ResultSet.getString")'
because all the data for the row has already been read.

   If you are using a JDBC driver with scrollable result sets, please note
that support for such is provided purely through `func', not through any
explicit DBD::JDBC support. This means that a loop over the set, such as

     while ($row = $sth->fetch()) {
         # do something
     }

   will cause DBD::JDBC to mark the statement handle as inactive at the
end of the loop (`$sth->{Active}' will be false). You can still use `func'
to operate on the underlying ResultSet, but you can't continue to use any
DBI method which requires that the statement handle be active. The
following sequence seems to work, though perhaps it shouldn't:

     while ($row = $sth->fetch()) {
         # do something
     }
     $sth->func("ResultSet.beforeFirst");
     while ($row = $sth->fetch()) {
         # do something else
     }

   Some sort of explicit support for scrollable result sets will probably
be implemented at a later date.

Closing cursors
---------------

   When a statement handle goes out of scope, Perl will call its DESTROY
method. This method will cause `Statement.close' to be called on the
associated Java Statement object in the DBD::JDBC server. For many
applications, this is sufficient. However, if you find that statement
handles are not being destroyed quickly enough, or you are maintaining a
collection of statements for repeated use, you may choose to close the
ResultSet associated with the Statement explicitly using `func'. Closing
the ResultSet will not prevent you from executing the statement again, but
it will release any database resources held by the ResultSet.

   Typical usage:

     $sth = $dbh->prepare("select id from sched");
     $sth->execute();
     while ($row = $sth->fetch()) {
         # do something
     }
     # At this point, the statement handle is no longer active, but
     # the ResultSet still exists on the server.
     $sth->func("ResultSet.close");

   DBD::JDBC does not close ResultSet objects when `$sth->finish' is
called (whether it is called implicitly when the end of the result set is
reached or explicitly in your program) in order to support scrollable
result sets. With a scrollable result set, reaching the end of the data
does not mean that the ResultSet is unusable, so calling close would be
unfortunate.

Character sets
--------------

   You can find out what character set Java thinks your platform uses by
examining the value of the system property `file.encoding'.

     System.out.println("This system uses: " + System.getProperty("file.encoding"));

   Local experimentation (in the US) indicates that Windows NT uses
"Cp1252" (Windows Latin-1) and Unix variants (AIX, Solaris) use
"ISO8859_1".

jdbc_error
----------

   When a JDBC exception is thrown in the server, the exception and any
exceptions chained to the original are returned and placed in the
jdbc_error attribute of the most-recently-used handle. This attribute will
contain an array of hashrefs with keys err, `errstr', and state. The first
error's values will also be available via `$h->err', `$h->errstr', and
`$h->state'.

     foreach $err (@{$sth->{jdbc_error}}) {
         print "Error: ($err->{err}/$err->{state}) $err->{errstr}\n";
     }

DBI to JDBC method mappings
---------------------------

   What follows is a guide to the JDBC methods being called when a DBI
method or property is accessed. See the source code for
`com.vizdom.dbd.jdbc.Connection' for details.

DBI->connect
          DriverManager.getConnection(url, username, password)
          Connection.setAutoCommit   [if AutoCommit was specified]

$dbh->prepare
          Connection.prepareStatement(statement)

$dbh->commit
          Connection.commit()

$dbh->rollback
          Connection.rollback()

$dbh->disconnect
          PreparedStatement.close()   [for each open statement]
          Connection.close()

$dbh->ping
          Connection.isClosed()

$dbh->{AutoCommit}
          Connection.getAutoCommit()
          Connection.setAutoCommit()

$sth->execute
          PreparedStatement.setXXX(value)   [if there are any parameters]
          PreparedStatement.execute()
          PreparedStatement.getResultSet()
          PreparedStatement.getUpdateCount()

$sth->fetch
          ResultSet.next()
          ResultSet.getXXX

$sth->{CursorName}
          ResultSet.getCursorName()

$sth->{NAME}
          ResultSetMetaData.getColumnName()

$sth->{TYPE}
          ResultSetMetaData.getColumnType()

$sth->{PRECISION}
          ResultSetMetaData.getPrecision()

$sth->{SCALE}
          ResultSetMetaData.getScale()

$sth->{NULLABLE}
          ResultSetMetaData.isNullable()

$sth->DESTROY
          [This is called automatically when a statement handle
          goes out of scope]

          Statement.close()

Statement parameters and column values
--------------------------------------

   Parameter values are sent to the DBD::JDBC server as a sequence of
bytes. Numeric parameters are encoded as strings rather than numbers (so
11 is sent as the two characters '1' '1').

   When the DBD::JDBC server receives the parameter values, the bytes are
converted to a Java String (using the character encoding specified at
connection time by the jdbc_character_set value) and the
PreparedStatement.setString() method is used to set the parameter value.

   If a type hint (one of the SQL_XXX types you can import from the DBI
module) is supplied along with a parameter in `$sth->bind_param()', the
type code will be mapped to the corresponding JDBC type code and passed
along to the DBD::JDBC server. The JDBC type will be used to determine
which PreparedStatement.setXXX method to call. The mapping from type hint
to setXXX method is taken from Table 21.2, p. 394, in *JDBC Data Access
with Java*.

     BINARY, VARBINARY, LONGVARBINARY: setBytes
     TINYINT, SMALLINT: setShort
     INTEGER: setInt
     BIGINT: setLong
     REAL: setFloat
     FLOAT, DOUBLE: setDouble
     DECIMAL, NUMERIC: setBigDecimal
     BIT: setBoolean
     CHAR, VARCHAR, LONGVARCHAR, DATE, TIME, TIMESTAMP: setString

   Type hints are required for binary data in order to avoid having binary
parameter values passed through the default character conversion process.
In other cases, they are generally optional and may in fact reduce
performance by causing unneccessary data conversions. For example, if your
database's JDBC driver passes all data to the database as strings, the
JDBC driver will have to convert numbers back to strings anyway.

   A call to `$sth->fetch' will cause the DBD:JDBC server to use the
column type information from ResultSetMetaData to determine how to
retrieve column data.

     Column type         Method used
     BINARY, VARBINARY   getBytes
     LONGVARBINARY       getBinaryStream
     LONGVARCHAR         getUnicodeStream
     all others          getString

   Once retrieved, the data is returned to Perl as a sequence of bytes.
The caller may choose whether to treat the returned scalar as a character
string, number, or byte string.

NUM_OF_PARAMS implementation
----------------------------

   The statement attribute NUM_OF_PARAMS is set when `$dbh->prepare' is
called. Since JDBC doesn't expose this information about
PreparedStatements, DBD::JDBC uses a simple '?'  counting method which may
fail to provide an accurate count if the parameter marker is not '?' or
the syntax does not conform to standard SQL (and possibly even if it does,
if I've interpreted the SQL grammar poorly). Depending on this value to be
accurate is not recommended, although you may find that it is sufficient
for your use.

DIAGNOSTICS
===========

   All errors generated by DBD::JDBC have IJDBC as the SQLSTATE. If a
SQLException was thrown by the JDBC driver without a SQLSTATE, DBD::JDBC
will set the SQLSTATE to IDRVR.

Errors generated by the Perl driver
-----------------------------------

Unsupported AutoCommit value  (no error number)
     If you attempt to set AutoCommit to anything other than 0 or 1, the
     driver will die with this error.

Error code 100
     An error occurred while sending a request to the server.

Error code 101
     An error occurred while receiving a response from the server.

Error code 102
     There was a problem decoding a server response packet.

Error code 103
     The dsn supplied to connect is missing one or more required values.

Error code 104
     A connection to the server could not be established. The server may
     not be running, or the host or port information may be incorrect.

Error code 105
     An `$sth->execute' call caused the server to return an invalid
     response. This is an internal error.

Errors generated by the Java server
-----------------------------------

Error code 1
     The client requested an operation on a statement object which does not
     exist on the serer.

Error code 2
     fetch was called on a statement which has no data. For example, this
     error might result if fetch is called before a statement is executed.

Error code 3
     The server was asked to return the value of an unknown attribute.

Error code 4
     This error code indicates that the client attempted to do something
     which requires a cursor (a ResultSet) on the server, but no cursor is
     present.

Error code 5
     No metadata is currently available. This error will result if a
     request is made for a statement attribute at a time when no ResultSet
     is associated with the statement.

Error code 6
     This error code indicates that the client sent a message to the
     server which the server does not understand.

Error code 7
     The server was unable to respond to the client's request. This error
     would likely be sent as the result of another, undetected, error on
     the server.

Error code 8
     This error code is used when the server wishes to send a random error
     string to the client. For example, arbitrary Java exceptions may be
     sent with this error code.

Error code 9
     An error occurred during fetch. The error text will describe the
     actual error.

Error code 10
     This error code indicates that the client's requested character
     encoding is not supported.

Error code 11
     An error occurred while setting a statement parameter.

Error code 12
     A long field was truncated during fetch.

Error code 13
     A reflection request was made, but there's no object on which to call
     the indicated method. For example, trying to call `ResultSet.next'
     before calling `$sth->execute' will cause this error to be reported,
     since no ResultSet exists.

Error code 14
     An unknown class name was passed to `$sth->func'.

Error code 15
     A Java exception related to reflection was thrown. This may include,
     for example, `NoSuchMethodException' if the requested method can't be
     located.

TO DO
=====

   See the ToDo file included with the distribution. Highlights include

   * Make the complete JDBC interface available from DBI.

   * DBI metadata methods, cancel, row cache.

   * Better handling of long fields via some sort of streaming interface.

   * JDBC 2.0 support.

SEE ALSO
========

   perldoc DBI

   For general DBI information and questions, see the DBI home page at

     http://www.symbolstone.org/technology/perl/DBI/index.html

   This site contains pointers to archives of the DBI mailing lists and
list subscription information. DBI in general is primarily supported
through the dbi-users mailing list.

AUTHOR
======

   Gennis Emerson <gemerson@vizdom.com>

COPYRIGHT
=========

   Copyright 1999-2000 Vizdom Software, Inc. All Rights Reserved.

   This program is free software; you can redistribute it and/or modify it
under the same terms as the Perl Kit, namely, under the terms of either:

   a) the GNU General Public License as published       by the Free
Software Foundation; either version 1       of the License, or (at your
option) any later       version, or

   b) the "Artistic License" that comes with the       Perl Kit.

   This program is distributed in the hope that it will be seful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See either the GNU General Public
License or the Artistic License for more details.


