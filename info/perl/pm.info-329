This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Rc,  Next: Rcs,  Prev: Randomize,  Up: Module List

parser and backends for 'rc' shell
**********************************

NAME
====

   Rc - parser and backends for 'rc' shell

SYNOPSIS
========

   If you need a synposis, you should start with an easier project.

DESCRIPTION
===========

   The design of this module is similar to the design of *Note B: B,, the
perl compiler backend.

WHY RC?
=======

   'rc' has a cleaner syntax in comparison to sh or csh.  If your going to
go through the unpleasantness of learning to program in a shell, it might
as well be 'rc'.

SUPPORT
=======

   Send any questions or comments to envy@listbox.com!

   If you'd like to subscribe to this mailing list send email to
majordomo@listbox.com.  Thanks!

AUTHOR
======

   Copyright © 1998 Joshua Nathaniel Pritikin.  All rights reserved.

   This package is free software and is provided "as is" without express
or implied warranty.  It may be used, redistributed and/or modified under
the terms of the Perl Artistic License (see
http://www.perl.com/perl/misc/Artistic.html)

   Portions of this sortware include source code from the 'rc' shell.
These portions are Copyright © 1991 Byron Rakitzis.  'rc' is free,
open-source package and is available at most ftp sites that distribute GNU
software.


File: pm.info,  Node: Rcs,  Next: Regex/PreSuf,  Prev: Rc,  Up: Module List

Perl Object Class for Revision Control System (RCS).
****************************************************

NAME
====

   Rcs - Perl Object Class for Revision Control System (RCS).

SYNOPSIS
========

     use Rcs;

DESCRIPTION
===========

   This Perl module provides an object oriented interface to access
*Revision Control System (RCS)* utilities.  RCS must be installed on the
system prior to using this module.  This module should simplify the
creation of an RCS front-end.

OBJECT CONSTRUCTOR
------------------

   The new method may be used as either a class method or an object method
to create a new object.

     # called as class method
     $obj = Rcs->new;

     # called as object method
     $newobj = $obj->new;

CLASS METHODS
-------------

   Besides the object constructor, there are three class methods provided
which effect any newly created objects.

   The *arcext* method sets the RCS archive extension, which is ',v' by
default.

     # set/unset RCS archive extension
     Rcs->arcext('');            # set no archive extension
     Rcs->arcext(',v');          # set archive extension to ',v'
     $arc_ext = Rcs->arcext();   # get current archive extension

   The *bindir* method sets the directory path where the RCS executables
(i.e. rcs, ci, co) are located.  The default location is '/usr/local/bin'.

     # set RCS bin directory
     Rcs->bindir('/usr/bin');

     # access RCS bin directory
     $bin_dir = Rcs->bindir;

   The quiet method sets/unsets the quiet mode for the RCS executables.
Quiet mode is set by default.

     # set/unset RCS quiet mode
     Rcs->quiet(0);      # unset quiet mode
     Rcs->quiet(1);      # set quiet mode

     # access RCS quiet mode
     $quiet_mode = Rcs->quiet;

   These methods may also be called as object methods.

     $obj->arcext('');
     $obj->bindir('/usr/bin');
     $obj->quiet(0);

OBJECT ATTRIBUTE METHODS
------------------------

   These methods set the attributes of the RCS object.

   The file method is used to set the name of the RCS working file.  The
filename must be set before invoking any access of modifier methods on the
object.

     $obj->file('mr_anderson.pl');

   The *arcfile* method is used to set the name of the RCS archive file.
Using this method is optional, as the other methods will assume the archive
filename is the same as the working file unless specified otherwise.  The
RCS archive extension (default ',v') is automatically added to the
filename.

     $obj->arcfile('principle_mcvicker.pl');

   The *workdir* methods set the path of the RCS working directory.  If not
specified, default path is '.' (current working directory).

     $obj->workdir('/usr/local/source');

   The *rcsdir* methods set the path of the RCS archive directory.  If not
specified, default path is './RCS'.

     $obj->rcsdir('/usr/local/archive');

RCS PARSE METHODS
-----------------

   This class provides methods to directly parse the RCS archive file.

   The access method returns a list of all user on the access list.

     @access_list = $obj->access;

   The author method returns the author of the revision.  The head revision
is used if no revision argument is passed to method.

     # returns the author of revision '1.3'
     $author = $obj->author('1.3');

     # returns the authos of the head revision
     $author = $obj->author;

   The head method returns the head revision.

     $head = $obj->head;

   The lock method returns the locker of the revision.  The method returns
null if the revision is unlocked.  The head revision is used if no revision
argument is passed to method.

     # returns locker of revision '1.3'
     $locker = $obj->lock('1.3');

     # returns locker of head revision
     $locker = $obj->lock;

   The *revisions* method returns a list of all revisions of archive file.

     @revisions = $obj->revisions;

   The state method returns the state of the revision. The head revision
is used if no revision argument is passed to method.

     # returns state of revision '1.3'
     $state = $obj->state('1.3');

     # returns state of head revision
     $state = $obj->state;

   The symbol method returns the symbol(s) associated with a revision.  If
called in list context, method returns all symbols associated with
revision.  If called in scalar context, method returns last symbol
assciated with a revision.  The head revision is used if no revision
argument is passed to method.

     # list context, returns all symbols associated with revision 1.3
     @symbols = $obj->symbol('1.3');

     # list context, returns all symbols associated with head revision
     @symbols = $obj->symbol;

     # scalar context, returns last symbol associated with revision 1.3
     $symbol = $obj->symbol('1.3');

     # scalar context, returns last symbol associated with head revision
     $symbol = $obj->symbol;

   The symbols method returns a hash, keyed by symbol, of all of the
revisions associated with the file.

     %symbols = $obj->symbols;
     foreach $sym (keys %symbols) {
         $rev = $symbols{$sym};
     }

   The *revdate* method returns the date of a revision.  The returned date
format is the same as the localtime format.  When called as a scalar, it
returns the system date number.  If called is list context, the list
($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) is returned.

     # scalar mode
     $scalar_date = $obj->revdate;
     print "Scalar date number = $scalar_date\n";
     $date_str = localtime($scalar_date);
     print "Scalar date string = $date_str\n";

     # list mode
     @list_date = $obj->revdate;
     print "List date = @list_date\n";

   The *dates* method returns a hash of revision dates, keyed on revision.
The hash values are system date numbers.  When called in scalar mode, the
method returns the most recent revision date.

     # list mode
     %DatesHash = obj->dates;
     @dates_list = sort {$b<=>$a} values %DatesHash;
     $MostRecent = $dates_list[0];

     # scalar mode
     $most_recent = $obj->dates;
     print "Most recent date = $most_recent\n";
     $most_recent_str = localtime($most_recent);
     print "Most recent date string = $most_recent_str\n";

   The *symrev* method returns the revision against which a specified
symbol was defined. If the symbol was not defined against any version of
this file, 0 is returned.

     # gets revision that has 'MY_SYMBOL' defined against it
     $rev = $obj->symrev('MY_SYMBOL');

   The *daterev* method returns revisions which were created before a
specified date.  Method may take one or six arguments.  If one arguments
is passed, then the argument is a date number.  If six arguments are
passed, then they represent a date string.

     # one argument, date number
     # gets revisions created before Sun Sep  6 22:23:47 1998
     @revs = $obj->daterev(841436420);

     # six argument
     # gets revisions created before 25th June 1998 16:45:30
     @revs = $obj->daterev(1998, 6, 25, 16, 45, 30);

   The comments method returns a hash of revision comments, keyed on
revision.  A key value of 0 returns the description.

     %comments = $obj->comments;
     $description = $comments{0};
     $comment_1_3 = $comments{'1.3'};

RCS SYSTEM METHODS
------------------

   These methods invoke the RCS system utilities.

   The ci method calls the RCS ci program.

     # check in, and then check out in unlocked state
     $obj->ci('-u');

   The co method calls the RCS co program.

     # check out in locked state
     $obj->co('-l');

   The *rcs* method calls the RCS rcs program.

     # lock file
     $obj->rcs('-l');

   The *rcsdiff* method calls the RCS rcsdiff program.  When called in
list context, this method returns the outpout of the rcsdiff program.
When called in scalar context, this method returns the return status of
the rcsdiff program.  The return status is 0 for the same, 1 for some
differences, and 2 for error condition.

   When called without parameters, rcsdiff does a diff between the current
working file, and the last revision checked in.

     # call in list context
     @diff_output = $obj->rcsdiff;

     # call in scalar context
     $changed = $obj->rcsdiff;
     if ($changed) {
         print "Working file has changed\n";
     }

   Call rcsdiff with parameters to do a diff between any two revisions.

     @diff_output = $obj->rcsdiff('-r1.2', '-r1.1');

   The *rlog* method calls the RCS rlog program.  This method returns the
output of the rlog program.

     # get complete log output
     @rlog_complete = $obj->rlog;

     # called with '-h' switch outputs only header information
     @rlog_header = $obj->rlog('-h');
     print @rlog_header;

   The *rcsclean* method calls the RCS rcsclean program.

     # remove working file
     $obj->rcsclean;

EXAMPLES
========

CREATE ACCESS LIST
------------------

   Using method *rcs* with the -a switch allows you to add users to the
access list of an RCS archive file.

     use Rcs;
     $obj = Rcs->new;

     $obj->rcsdir("./project_tree/archive");
     $obj->workdir("./project_tree/src");
     $obj->file("cornholio.pl");

   Methos *rcs* invokes the RCS utility rcs with the same parameters.

     @users = qw(beavis butthead);
     $obj->rcs("-a@users");

   Calling method access returns list of users on access list.

     $filename = $obj->file;
     @access_list = $obj->access;
     print "Users @access_list are on the access list of $filename\n";

PARSE RCS ARCHIVE FILE
----------------------

   Set class variables and create 'RCS' object.  Set bin directory where
RCS programs (e.g. rcs, ci, co) reside.  The default is '/usr/local/bin'.
This sets the bin directory for all objects.

     use Rcs;
     Rcs->bindir('/usr/bin');
     $obj = Rcs->new;

   Set information regarding RCS object.  This information includes name
of the working file, directory of working file ('.' by default), and RCS
archive directory ('./RCS' by default).

     $obj->rcsdir("./project_tree/archive");
     $obj->workdir("./project_tree/src");
     $obj->file("cornholio.pl");

     $head_rev = $obj->head;
     $locker = $obj->lock;
     $author = $obj->author;
     @access = $obj->access;
     @revisions = $obj->revisions;

     $filename = $obj->file;

     if ($locker) {
         print "Head revision $head_rev is locked by $locker\n";
     }
     else {
         print "Head revision $head_rev is unlocked\n";
     }

     if (@access) {
         print "\nThe following users are on the access list of file $filename\n";
         map { print "User: $_\n"} @access;
     }

     print "\nList of all revisions of $filename\n";
     foreach $rev (@revisions) {
         print "Revision: $rev\n";
     }

CHECK-IN FILE
-------------

   Set class variables and create 'RCS' object.  Set bin directory where
RCS programs (e.g. rcs, ci, co) reside.  The default is '/usr/local/bin'.
This sets the bin directory for all objects.

     use Rcs;
     Rcs->bindir('/usr/bin');
     Rcs->quiet(0);      # turn off quiet mode
     $obj = Rcs->new;

   Set information regarding RCS object.  This information includes name of
working file, directory of working file ('.' by default), and RCS archive
directory ('./RCS' by default).

     $obj->file('cornholio.pl');

     # Set RCS archive directory, is './RCS' by default
     $obj->rcsdir("./project_tree/archive");

     # Set working directory, is '.' by default
     $obj->workdir("./project_tree/src");

   Check in file using -u switch.  This will check in the file, and will
then check out the file in an unlocked state.  The -m switch is used to
set the revision comment.

   Command:

     $obj->ci('-u', '-mRevision Comment');

   is equivalent to commands:

     $obj->ci('-mRevision Comment');
     $obj->co;

CHECK-OUT FILE
--------------

   Set class variables and create 'RCS' object.  Set bin directory where
RCS programs (e.g. rcs, ci, co) reside.  The default is '/usr/local/bin'.
This sets the bin directory for all objects.

     use Rcs;
     Rcs->bindir('/usr/bin');
     Rcs->quiet(0);      # turn off quiet mode
     $obj = Rcs->new;

   Set information regarding RCS object.  This information includes name of
working file, directory of working file ('.' by default), and RCS archive
directory ('./RCS' by default).

     $obj->file('cornholio.pl');

     # Set RCS archive directory, is './RCS' by default
     $obj->rcsdir("./project_tree/archive");

     # Set working directory, is '.' by default
     $obj->workdir("./project_tree/src");

   Check out file read-only:

     $obj->co;

   or check out and lock file:

     $obj->co('-l');

RCSDIFF
-------

   Method *rcsdiff* does an diff between revisions.

     $obj = Rcs->new;
     $obj->bindir('/usr/bin');

     $obj->rcsdir("./project_tree/archive");
     $obj->workdir("./project_tree/src");
     $obj->file("cornholio.pl");

     print "Diff of current working file\n";
     if ($obj->rcsdiff) {       # scalar context
         print $obj->rcsdiff;   # list context
     }
     else {
        print "Versions are Equal\n";
     }

     print "\n\nDiff of revisions 1.2 and 1.1\n";
     print $obj->rcsdiff('-r1.2', '-r1.1');

RCSCLEAN
--------

   Method *rcsclean* will remove an unlocked working file.

     use Rcs;
     Rcs->bindir('/usr/bin');
     Rcs->quiet(0);      # turn off quiet mode
     $obj = Rcs->new;

     $obj->rcsdir("./project_tree/archive");
     $obj->workdir("./project_tree/src");
     $obj->file("cornholio.pl");

     print "Quiet mode NOT set\n" unless Rcs->quiet;

     $obj->rcsclean;

AUTHOR
======

   Craig Freter, <`craig@freter.com'>

CONTRIBUTORS
============

   David Green, <`greendjf@cvhp152.gpt.co.uk'>

   Jamie O'Shaughnessy, <`jamie@thanatar.demon.co.uk'>

COPYRIGHT
=========

   Copyright (C) 1997,1998 Craig Freter.  All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.


File: pm.info,  Node: Regex/PreSuf,  Next: Regexp,  Prev: Rcs,  Up: Module List

create regular expressions from word lists
******************************************

NAME
====

   Regex::PreSuf - create regular expressions from word lists

SYNOPSIS
========

     use Regex::PreSuf;
     
     my $re = presuf(qw(foobar fooxar foozap));

     # $re should be now 'foo(?:zap|[bx]ar)'

DESCRIPTION
===========

   The *presuf()* subroutine builds regular expressions out of 'word
lists', lists of strings.  The regular expression matches the same words
as the word list.  These regular expressions normally run faster than a
simple-minded '|'-concatenation of the words.

   Examples:

   *      'foobar fooxar' => 'foo[bx]ar'

   *      'foobar foozap' => 'foo(?:bar|zap)'

   *      'foobar fooar'  => 'foob?ar'

   The downsides:

   * The original order of the words is not necessarily respected, for
     example because the character class matches are collected together,
     separate from the '|' alternations.

   * The module blithely ignores any specialness of any regular expression
     metacharacters such as the `.*?+{}[]^$', they are just plain ordinary
     boring characters.

   For the second downside there is an exception.  The module has some
rudimentary grasp of how to use the 'any character' metacharacter.  If you
call *presuf()* like this:

     my $re = presuf({ anychar=>1 }, qw(foobar foo.ar fooxar));

     # $re should be now 'foo.ar'

   The module finds out the common prefixes and suffixes of the words and
then recursively looks at the remaining differences.  However, by default
only common prefixes are used because for many languages (natural or
artificial) this seems to produce the fastest matchers.  To allow also for
suffixes use

     my $re = presuf({ suffixes=>1 }, ...);

   To use *only* suffixes use

     my $re = presuf({ prefixes=>0 }, ...);

   (this implicitly enables suffixes)

Debugging
---------

   In case you want to flood your session without debug messages you can
turn on debugging by saying

     Regex::PreSuf::debug(1);

   How to turn them off again is left as an exercise for the kind reader.

COPYRIGHT
=========

   Jarkko Hietaniemi

   This code is distributed under the same copyright terms as Perl itself.


File: pm.info,  Node: Regexp,  Next: Regexp/Common,  Prev: Regex/PreSuf,  Up: Module List

Object Oriented interface to perl's regular expression code
***********************************************************

NAME
====

   Regexp - Object Oriented interface to perl's regular expression code

SYNOPSIS
========

     use Regexp;

     my $re = new Regexp q/Some Pattern/;

     if (match $re "Some String") { ... }

     $re->prematch

     $re->postmatch

     $re->pattern

     my @info  = $re->backref
     my $count = $re->backref

DESCRIPTION
===========

CONSTRUCTORS
============

new ( PATTERN [, FLAGS ] )
     new compiles the given PATTERN into a new Regexp object.  See *Note
     Perlre: (perl.info)perlre, for a description of PATTERN

     A second optional parameter, FLAGS, can be used to control how the
     pattern is compiled. FLAGS is a numeric value which can be
     constructed by or-ing together constants which Regexp conditionally
     exports. The constants are :

    FOLD
          Perform case-insensitive matches. See `/i' in *Note Perlre:
          (perl.info)perlre,

    NOCASE
          A synonym for FOLD

    MULTILINE
          Treat strings as multiple lines, See `/m' in *Note Perlre:
          (perl.info)perlre,

    SINGLELINE
          Treat strings as single lines, See `/s' in *Note Perlre:
          (perl.info)perlre,

    EXTENDED
          Use extended patter formats to increase legibility, See `/x' in
          *Note Perlre: (perl.info)perlre,

current
     Returns an object which represents the current (last) pattern.

METHODS
=======

minlength
     Returns the minimum length that a string has to be before it will
     match the regular expression

pattern
     Returns the pattern text

match ( STRING [, OFFSET [, FLAGS]] )
     match is like the `=~' operator in perl. STRING is the string which
     the regexp is to be applied. `OFFEST' and FLAGS are both optional.

     In a scalar context match returns a true or false value depending on
     whether the match was sucessful. In an array context match returns an
     array of the contents of all the backreferences, or an empty array.

     `OFFSET', if given, directs the regexp code to start trying to match
     the regexp at the given offset from the start of STRING

     FLAGS is a numeric value which can be constructed by or-ing together
     constants which Regexp conditionally exports. The constants are :

    GLOBAL
          Match as many times as possible, starting each time where the
          previous match ended. See `/g' option in *Note Perlre:
          (perl.info)perlre,.

          If match is called in an array context and the GLOBAL flag is
          set then the result will be an array of all the backreferences
          from all the matches.

nparens
     Returns the number of parentheses in the expression

lastparen
     Returns the number of the last parentheses that matched.

backref ( [INDEX] )
     The result of backref is sensetive to how it is called.

     If called with a single argument then backref returns the text for
     the given backreference in the pattern. Backreferences are numbered
     from 1 as with `$1..$9'.

     If called with a single argument of zero, then backref will return
     the text of the last match. (Same as lastmatch)

     If called without any arguments, and in a scalar context, then
     backref will return the number of backreferences that there are in
     the Regexp object. (Same as nparens)

     If called without any arguments, and in aN array context, then
     backref will return a list of all the backreference values from the
     last match.

prematch
     Returns the text preceeding the text of the last match

lastmatch
     Returns the text of the last match

postmatch
     Returns the text following the text of the last match

startpos
     Returns the offset into the original string to the start of the text
     in the last match.

length
     Returns the length of the text in the last match

endpos
     Returns the offset into the original string to the end of the text in
     the last match.

AUTHORS
=======

   Regexp is a combination of work by Nick Ing-Simmons
<`nick@ni-s.u-net.com'> and Ilya Zakharevich <`ilya@math.ohio-state.edu'>
brought together and improved by Graham Barr <`bodg@tiuk.ti.com'>


File: pm.info,  Node: Regexp/Common,  Next: Regexp/Shellish,  Prev: Regexp,  Up: Module List

Provide commonly requested regular expressions
**********************************************

NAME
====

   Regexp::Common - Provide commonly requested regular expressions

SYNOPSIS
========

     # STANDARD USAGE

     use Regexp::Common;

     while (<>) {
     	/$RE{num}{real}/ 		and print q{a number\n};
     	/$RE{quoted}			and print q{a ['"`] quoted string\n};
     	/$RE{delimited}{-delim=>'/'}/	and print q{a /.../ sequence\n};
     	/$RE{balanced}{-parens=>'()'}/	and print q{balanced parentheses\n};
     	/$RE{profanity}/ 		and print q{a #*@%-ing word\n};
     }

     # SUBROUTINE-BASED INTERFACE

     use Regexp::Common 'RE';

     while (<>) {
     	$_ =~ RE_num_real() 		 and print q{a number\n};
     	$_ =~ RE_quoted()		 and print q{a ['"`] quoted string\n};
     	$_ =~ RE_delimited(-delim=>'/')	 and print q{a /.../ sequence\n};
     	$_ =~ RE_balanced(-parens=>'()'} and print q{balanced parentheses\n};
     	$_ =~ RE_profanity() 		 and print q{a #*@%-ing word\n};
     }

     # IN-LINE MATCHING...

     if ( $RE{num}{int}->matches($text} ) {...}

     # ...AND SUBSTITUTION

     my $cropped = $RE{ws}{crop}->subs($uncropped);

     # ROLL-YOUR-OWN PATTERNS

     use Regexp::Common 'pattern';

     pattern name   => ['name', 'mine'],
     	 create => '(?i:J[.]?\s+A[.]?\s+Perl-Hacker)',
     	 ;

     my $name_matcher = $RE{name}{mine};

     pattern name    => [ 'lineof', '-char=_' ],
     	 create  => sub {
     			my $flags = shift;
     			my $char = quotemeta $flags->{-char};
     			return '(?:^$char+$)';
     		    },
     	 matches => sub {
        			my ($self, $str) = @_;
        			return $str !~ /[^$self->{flags}{-char}]/;
     		    },
     	 subs   => sub {
     			my ($self, $str, $replacement) = @_;
     			$_[1] =~ s/^$self->{flags}{-char}+$//g;
     		   },
     	 ;

     my $asterisks = $RE{lineof}{-char=>'*'};

DESCRIPTION
===========

   By default, this module exports a single hash (`%RE') that stores or
generates commonly needed regular expressions (see `"List of available
patterns"' in this node).

   There is an alternative, subroutine-based syntax described in
`"Subroutine-based interface"' in this node.

General syntax for requesting patterns
--------------------------------------

   To access a particular pattern, `%RE' is treated as a hierarchical hash
of hashes (of hashes...), with each successive key being an identifier. For
example, to access the pattern that matches real numbers, you specify:

     $RE{num}{real}
     
     and to access the pattern that matches integers:

     $RE{num}{int}

   Deeper layers of the hash are used to specify flags: arguments that
modify the resulting pattern in some way. The keys used to access these
layers are prefixed with a minus sign and may include a value that is
introduced by an equality sign. For example, to access the pattern that
matches base-2 real numbers with embedded commas separating groups of
three digits (e.g. 10,101,110.110101101):

     $RE{num}{real}{'-base=2'}{'-sep=,'}{'-group=3'}

   Through the magic of Perl, these flag layers may be specified in any
order (and even interspersed through the identifier keys!)  so you could
get the same pattern with:

     $RE{num}{real}{'-sep=,'}{'-group=3'}{'-base=2'}

   or:

     $RE{num}{'-base=2'}{real}{'-group=3'}{'-sep=,'}

   or even:

     $RE{'-base=2'}{'-group=3'}{'-sep=,'}{num}{real}

   etc.

   Note, however, that the relative order of amongst the identifier keys
*is* significant. That is:

     $RE{list}{set}

   would not be the same as:

     $RE{set}{list}

Alternative flag syntax
-----------------------

   As the examples in the previous section indicate, the syntax for
specifying flags is somewhat cumbersome, because of the need to quote the
entire (non-identifier) key-plus-value. To make such specifications less
ugly, Regexp::Common permanently changes the value of the magical $;
variable (setting it to the character `'=''), so that flags can also be
specified like so:

     $RE{num}{real}{-base=>2}{-group=>3}{-sep=>','}

   This syntax is preferred, and is used throughout the rest of this
document.

   In the unlikely case that the non-standard value of $; breaks your
program, this behaviour can be disabled by importing the module as:

     use Regexp::Common 'clean';

Universal flags
---------------

   Normally, flags are specific to a single pattern.  However, there is
one flag that all patterns may specify.

   By default, the patterns provided by `%RE' contain no capturing
parentheses. However, if the `-keep' flag is specified (it requires no
value) then any significant substrings that the pattern matches are
captured. For example:

     if ($str =~ $RE{num}{real}{-keep}) {
             $number   = $1;
             $whole    = $3;
             $decimals = $5;
     }

   Special care is needed if a "kept" pattern is interpolated into a
larger regular expression, as the presence of other capturing parentheses
is likely to change the "number variables" into which significant
substrings are saved.

   See also `"Adding new regular expressions"' in this node, which
describes how to create new patterns with "optional" capturing brackets
that respond to `-keep'.

OO interface and inline matching/substitution
---------------------------------------------

   The patterns returned from `%RE' are objects, so rather than writing:

     if ($str =~ /$RE{some}{pattern}/ ) {...}

   you can write:

     if ( $RE{some}{pattern}->matches($str) ) {...}

   For matching this would seem to have no great advantage apart from
readability (but see below).

   For substitutions, it has other significant benefits. Frequently you
want to perform a substitution on a string without changing the original.
Most people use this:

     $changed = $original;
     $changed =~ s/$RE{some}{pattern}/$replacement/;

   The more adept use:

     ($changed = $original) =~ s/$RE{some}{pattern}/$replacement/;

   Regexp::Common allows you do write this:

     $changed = $RE{some}{pattern}->subs($original=>$replacement);

   Apart from reducing precedence-angst, this approach has the daded
advantages that the substitution behaviour can be optimized fro the
regular expression, and the replacement string can be provided by default
(see `"Adding new regular expressions"' in this node).

   For example, in the implementation of this substitution:

     $cropped = $RE{ws}{crop}->subs($uncropped);

   the default empty string is provided automatically, and the
substitution is optimized to use:

     $uncropped =~ s/^\s+//;
     $uncropped =~ s/\s+$//;

   rather than:

     $uncropped =~ s/^\s+|\s+$//g;

Subroutine-based interface
--------------------------

   The hash-based interface was chosen because it allows regexes to be
effortlessly interpolated, and because it also allows them to be
"curried". For example:

     my $num = $RE{num}{int};

     my $comma'd    = $num->{-sep=>','}{-group=>3};
     my $duodecimal = $num->{-base=>12};

   However, the use of tied hashes does make the access to Regexp::Common
patterns slower than it might otherwise be. In contexts where impatience
overrules laziness, Regexp::Common provides an additional subroutine-based
interface.

   For each (sub-)entry in the `%RE' hash (`$RE{key1}{key2}{etc}'), there
is a corresponding exportable subroutine: `RE_key1_key2_etc()'. The name of
each subroutine is the underscore-separated concatenation of the *non-flag*
keys that locate the same pattern in `%RE'. Flags are passed to the
subroutine in its argument list. Thus:

     use Regexp::Common qw( RE_ws_crop RE_num_real RE_profanity );

     $str =~ RE_ws_crop() and die "Surrounded by whitespace";

     $str =~ RE_num_real(-base=>8, -sep=>" ") or next;

     $offensive = RE_profanity(-keep);
     $str =~ s/$offensive/$bad{$1}++; "<expletive deleted>"/ge;

   Note that, unlike the hash-based interface (which returns objects),
these subroutines return ordinary qr'd regular expressions. Hence they do
not curry, nor do they provide the OO match and substitution inlining
described in the previous section.

   It is also possible to export subroutines for all available patterns
like so:

     use Regexp::Common 'RE_ALL';

Adding new regular expressions
------------------------------

   You can add your own regular expressions to the `%RE' hash at run-time,
using the exportable pattern subroutine. It expects a hash-like list of
key/value pairs that specify the behaviour of the pattern. The various
possible argument pairs are:

`name => [ @list ]'
     A required argument that specifies the name of the pattern, and any
     flags it may take, via a reference to a list of strings. For example:

          pattern name => [qw( line of -char )],
                  # other args here
                  ;

     This specifies an entry `$RE{line}{of}', which may take a `-char'
     flag.

     Flags may also be specified with a default value, which is then used
     whenever the flag is omitted, or specified without an explicit value.
     For example:

          pattern name => [qw( line of -char=_ )],
                  # default char is '_'
                  # other args here
                  ;

`create => $sub_ref_or_string'
     A required argument that specifies either a string that is to be
     returned as the pattern:

          pattern name    => [qw( line of underscores )],
                  create  => q/(?:^_+$)/
                  ;

     or a reference to a subroutine that will be called to create the
     pattern:

          pattern name    => [qw( line of -char=_ )],
                  create  => sub {
                                  my ($self, $flags) = @_;
                                  my $char = quotemeta $flags->{-char};
                                  return '(?:^$char+$)';
                              },
                  ;

     If the subroutine version is used, the subroutine will be called with
     three arguments: a reference to the pattern object itself, a reference
     to a hash containing the flags and their values, and a reference to
     an array containing the non-flag keys.

     Whatever the subroutine returns is stringified as the pattern.

     No matter how the pattern is created, it is immediately postprocessed
     to include or exclude capturing parentheses (according to the value
     of the `-keep' flag). To specify such "optional" capturing
     parentheses within the regular expression associated with create, use
     the notation `(?k:...)'. Any parentheses of this type will be
     converted to `(...)'  when the `-keep' flag is specified, or
     `(?:...)' when it is not.  It is a Regexp::Common convention that the
     outermost capturing parentheses always capture the entire pattern,
     but this is not enforced.

`matches => $sub_ref'
     An optional argument that specifies a subroutine that is to be called
     when the `$RE{...}->matches(...)' method of this pattern is invoked.

     The subroutine should expect two arguments: a reference to the
     pattern object itself, and the string to be matched against.

     It should return the same types of values as a `m/.../' does.

          pattern name    => [qw( line of -char )],
                  create  => sub {...},
                  matches => sub {
                                  my ($self, $str) = @_;
                                  return $str !~ /[^$self->{flags}{-char}]/;
                             },
                  ;

`subs => $sub_ref'
     An optional argument that specifies a subroutine that is to be called
     when the `$RE{...}->subs(...)' method of this pattern is invoked.

     The subroutine should expect three arguments: a reference to the
     pattern object itself, the string to be changed, and the value to be
     substituted into it.  The third argument may be undef, indicating the
     default substitution is required.

     The subroutine should return the same types of values as an
     `s/.../.../' does.

     For example:

          pattern name    => [ 'lineof', '-char=_' ],
                  create  => sub {...},
                  subs   => sub {
                                  my ($self, $str, $ignore_replacement) = @_;
                                  $_[1] =~ s/^$self->{flags}{-char}+$//g;
                            },
                   ;

     Note that such a subroutine will almost always need to modify `$_[1]'
     directly.

`version => $minimum_perl_version'
     If this argument is given, it specifies the minimum version of perl
     required to use the new pattern. Attempts to use the pattern with
     earlier versions of perl will generate a fatal diagnostic.

List of available patterns
--------------------------

   The following patterns are currently available:

`$RE{balanced}{-parens}'
     Returns a pattern that matches a string that starts with the nominated
     opening parenthesis or bracket, contains characters and properly
     nested parenthesized subsequences, and ends in the matching
     parenthesis.

     More than one type of parenthesis can be specified:

          $RE{balanced}{-parens=>'(){}'}

     in which case all specified parenthesis types must be correctly
     balanced within the string.

     Under `-keep':

    $1
          captures the entire expression

`$RE{num}{int}{-sep}{-group}'
     Returns a pattern that matches a decimal integer.

     If `-sep=*P*' is specified, the pattern P is required as a grouping
     marker within the number.

     If `-group=*N*' is specified, digits between grouping markers must be
     grouped in sequences of exactly N characters. The default value of N
     is 3.

     For example:

          $RE{num}{int}                            # match 1234567
          $RE{num}{int}{-sep=>','}                 # match 1,234,567
          $RE{num}{int}{-sep=>',?'}                # match 1234567 or 1,234,567
          $RE{num}{int}{-sep=>'.'}{-group=>4}      # match 1.2345.6789

     Under `-keep':

    $1
          captures the entire number

    $2
          captures the optional sign number

    $3
          captures the complete set of digits

`$RE{num}{real}{-base}{-radix}{-places}{-sep}{-group}{-expon}'
     Returns a pattern that matches a floating-point number.

     If `-base=*N*' is specified, the number is assumed to be in that base
     (with A..Z representing the digits for 11..36). By default, the base
     is 10.

     If `-radix=*P*' is specified, the pattern P is used as the radix
     point for the number (i.e. the "decimal point" in base 10). The
     default is `qr/[.]/'.

     If `-places=*N*' is specified, the number is assumed to have exactly
     N places after the radix point.  If `-places=*M,N*' is specified, the
     number is assumed to have between M and N places after the radix
     point.  By default, the number of places is unrestricted.

     If `-sep=*P*' specified, the pattern P is required as a grouping
     marker within the pre-radix section of the number. By default, no
     separator is allowed.

     If `-group=*N*' is specified, digits between grouping separators must
     be grouped in sequences of exactly N characters. The default value of
     N is 3.

     If `-expon=*P*' is specified, the pattern P is used as the exponential
     marker.  The default value of P is C<qr/[Ee]/.

     For example:

          $RE{num}{real}                  # matches 123.456 or -0.1234567
          $RE{num}{real}{-places=2}       # matches 123.45 or -0.12
          $RE{num}{real}{-places='0,3'}   # matches 123.456 or 0 or 9.8
          $RE{num}{real}{-sep=>'[,.]?'}   # matches 123,456 or 123.456
          $RE{num}{real}{-base=>3'}       # matches 121.102

     Under `-keep':

    $1
          captures the entire match

    $2
          captures the optional sign

    $3
          captures the complete mantissa

    $4
          captures the whole number portion of the mantissa

    $5
          captures the radix point

    $6
          captures the fractional portion of the mantissa

    $7
          captures the optional exponent marker

    $8
          captures the entire exponent value

    $9
          captures the optional sign of the exponent

    $10
          captures the digits of the exponent

`$RE{num}{dec}{-radix}{-places}{-sep}{-group}{-expon}'
     A synonym for `$RE{num}{real}{-base='10}{...}>

`$RE{num}{oct}{-radix}{-places}{-sep}{-group}{-expon}'
     A synonym for `$RE{num}{real}{-base='8}{...}>

`$RE{num}{bin}{-radix}{-places}{-sep}{-group}{-expon}'
     A synonym for `$RE{num}{real}{-base='2}{...}>

`$RE{num}{hex}{-radix}{-places}{-sep}{-group}{-expon}'
     A synonym for `$RE{num}{real}{-base='16}{...}>

`$RE{comment}{*language*}'
     A comment string in the nominated language.

     Available languages are:

          $RE{comment}{C}
          $RE{comment}{C++}
          $RE{comment}{shell}
          $RE{comment}{Perl}

     Under `-keep':

    $1
          captures the entire match

    $2
          captures the opening comment marker (except for
          `$RE{comment}{C++}')

    $3
          captures the contents of the comment (except for
          `$RE{comment}{C++}')

    $4
          captures the  closing comment marker (except for
          `$RE{comment}{C++}')

$RE{profanity}
     Returns a pattern matching words - such as Carlin's "big seven" - that
     are most likely to give offense. Note that correct anatomical terms
     are deliberately not included in the list.

     Under `-keep':

    $1
          captures the entire word

`$RE{profanity}{contextual}'
     Returns a pattern matching words that are likely to give offense when
     used in specific contexts, but which also have genuinely
     non-offensive meanings.

     Under `-keep':

    $1
          captures the entire word

`$RE{ws}{crop}'
     Returns a pattern that identifies leading or trailing whitespace.

     For example:

          $str =~ s/$RE{ws}{crop}//g;     # Delete surrounding whitespace

     The call:

          $RE{ws}{crop}->subs($str);

     is optimized (but probably still slower than doing the s///g
     explicitly).

     This pattern does not capture under `-keep'.

`$RE{delimited}{-delim}{-esc}'
     Returns a pattern that matches a single-character-delimited substring,
     with optional internal escaping of the delimiter.

     When `-delim=*S*' is specified, each character in the sequence S is a
     possible delimiter. There is no default delimiter, so this flag must
     always be specified.

     If `-esc=*S*' is specified, each character in the sequence S is the
     delimiter for the corresponding character in the `-delim=*S*' list.
     The default escape is backslash.

     For example:

          $RE{delimited}{-delim=>'"'}             # match "a \" delimited string"
          $RE{delimited}{-delim=>'"'}{-esc=>'"'}  # match "a "" delimited string"
          $RE{delimited}{-delim=>'/'}             # match /a \/ delimited string/
          $RE{delimited}{-delim=>q{'"}}           # match "string" or 'string'

     Under `-keep':

    $1
          captures the entire match

    $2
          captures the opening delimiter (provided only one delimiter was
          specified)

    $3
          captures delimited portion of the string (provided only one
          delimiter was specified)

    $4
          captures the closing delimiter (provided only one delimiter was
          specified)

$RE{quoted}{-esc}
     A synonym for `$RE{delimited}{q{-delim='"`}{...}}'

`$RE{list}{-pat}{-sep}{-lastsep}'
     Returns a pattern matching a list of (at least two) substrings.

     If `-pat=*P*' is specified, it defines the pattern for each substring
     in the list. By default, P is `qr/.*?/'.

     If `-sep=*P*' is specified, it defines the pattern P to be used as a
     separator between each pair of substrings in the list, except the
     final two.  By default P is `qr/\s*,\s*/'.

     If `-lastsep=*P*' is specified, it defines the pattern P to be used as
     a separator between the final two substrings in the list.  By default
     P is the same as the pattern specified by the `-sep' flag.

     For example:

          $RE{list}{-pat=>'\w+'}                # match a list of word chars
          $RE{list}{-pat=>$RE{num}{real}}       # match a list of numbers
          $RE{list}{-sep=>"\t"}                 # match a tab-separated list
          $RE{list}{-lastsep=>',\s+and\s+'}     # match a proper English list

     Under `-keep':

    $1
          captures the entire list

    $2
          captures the last separator

`$RE{list}{conj}{-word=*PATTERN*}'
     An alias for `$RE{list}{-lastsep=''\s*,?\s*PATTERN\s*'}>

     If `-word' is not specified, the default pattern is `qr/and|or/'.

     For example:

          $RE{list}{conj}{-word=>'et'}             # match Jean, Paul, et Satre
          $RE{list}{conj}{-word=>'oder'}           # match Bonn, Koln oder Hamburg

`$RE{list}{and}'
     An alias for `$RE{list}{conj}{-word=''and'}>

`$RE{list}{or}'
     An alias for `$RE{list}{conj}{-word=''or'}>

`$RE{net}{IPv4}'
     Returns a pattern that matches a valid IP address in "dotted decimal"

     For this pattern and the next four, under `-keep':

    $1
          captures the entire match

    $2
          captures the first component of the address

    $3
          captures the second component of the address

    $4
          captures the third component of the address

    $5
          captures the final component of the address

`$RE{net}{IPv4}{dec}{-sep}'
     Returns a pattern that matches a valid IP address in "dotted decimal"

     If `-sep=*P*' is specified the pattern P is used as the separator.
     By default P is `qr/[.]/'.

`$RE{net}{IPv4}{hex}{-sep}'
     Returns a pattern that matches a valid IP address in "dotted
     hexadecimal"

     If `-sep=*P*' is specified the pattern P is used as the separator.
     By default P is `qr/[.]/'. `-sep='""> and `-sep='" "> are useful
     alternatives.

`$RE{net}{IPv4}{oct}{-sep}'
     Returns a pattern that matches a valid IP address in "dotted octal"

     If `-sep=*P*' is specified the pattern P is used as the separator.
     By default P is `qr/[.]/'.

`$RE{net}{IPv4}{bin}{-sep}'
     Returns a pattern that matches a valid IP address in "dotted binary"

     If `-sep=*P*' is specified the pattern P is used as the separator.
     By default P is `qr/[.]/'.

Forthcoming patterns and features
---------------------------------

   Future releases of the module will also provide patterns for the
following:

     * email addresses
     * HTML/XML tags
     * more numerical matchers,
     * mail headers (including multiline ones),
     * URLS (various genres)
     * telephone numbers of various countries
     * currency (universal 3 letter format, Latin-1, currency names)
     * dates
     * binary formats (e.g. UUencoded, MIMEd)

   If you have other patterns or pattern generators that you think would be
generally useful, please send them to the author - preferably as source
code using the pattern subroutine. Submissions that include a set of
tests, will be especially welcome.

DIAGNOSTICS
===========

`Can't export unknown subroutine %s'
     The subroutine-based interface didn't recognize the requested
     subroutine.  Often caused by a spelling mistake or an incompletely
     specified name.

          =item C<Can't create unknown regex: $RE{...}>

     Regexp::Common doesn't have a generator for the requested pattern.
     Often indicates a mispelt or missing parameter.

`Perl %f does not support the pattern $RE{...}. You need Perl %f or later'
     The requested pattern requires advanced regex features (e.g.
     recursion) that not available in your version of Perl. Time to
     upgrade.

`pattern() requires argument: name =' [ @list ]>
     Every user-defined pattern specification must have a name.

`pattern() requires argument: create =' $sub_ref_or_string>
     Every user-defined pattern specification must provide a pattern
     creation mechanism: either a pattern string or a reference to a
     subroutine that returns the pattern string.

`Base must be between 1 and 36'
     The `$RE{num}{real}{-base=''N'}> pattern uses the characters [0-9A-Z]
     to represent the digits of various bases. Hence it only produces
     regular expressions for bases up to hexatricensimal.

`Must specify delimiter in $RE{delimited}'
     The pattern has no default delimiter.  You need to write:
     `$RE{delimited}{-delim='X'}> for some character X

ACKNOWLEDGEMENTS
================

   Deepest thanks to the many people who have encouraged and contributed
to this project, especially: Elijah, Jarkko, Tom, Nat, Ed, and Vivek.

AUTHOR
======

   Damian Conway (damian@conway.org)

BUGS AND IRRITATIONS
====================

   Bound to be plenty.

   For a start, there are many common regexes missing.  Send them in!

COPYRIGHT
=========

     Copyright (c) 2001, Damian Conway. All Rights Reserved.
            This module is free software. It may be used, redistributed
           and/or modified under the terms of the Perl Artistic License
        (see http://www.perl.com/perl/misc/Artistic.html)


File: pm.info,  Node: Regexp/Shellish,  Next: Register,  Prev: Regexp/Common,  Up: Module List

Shell-like regular expressions
******************************

NAME
====

   Regexp::Shellish - Shell-like regular expressions

SYNOPSIS
========

     use Regexp::Shellish qw( :all ) ;

     $re = compile_shellish( 'a/c*d' ) ;

     ## This next one's like 'a*d' except that it'll
     ## match 'a/d'.
     $re = compile_shellish( 'a**d' ) ;

     ## And here '**' won't match 'a/d', but behaves
     ## like 'a*d', except for the possibility of high
     ## cpu time consumption.
     $re = compile_shellish( 'a**d', { star_star => 0 } ) ;

     ## The next two result in identical $re1 and $re2.
     ## The second is a noop so that Regexp references can
     ## be easily accomodated.
     $re1 = compile_shellish( 'a{b,c}d' ) ;
     $re2 = compile_shellish( qr/\A(?:a(?:b|c)d)\Z/ ) ;

     @matches = shellish_glob( $re, @possibilities ) ;

DESCRIPTION
===========

   Provides shell-like regular expressions.  The wildcards provided are
'?', '*' and '**', where '**' is like '*' but matches '/'.  See `' in this
node for details.

   Case sensitivity and treatment of conreucts like '**', '(a*b)', and
'{a,b,c}' can be controlled.

compile_shellish
     Compiles a string containing a shellish regular expression a,
     returning a Regexp reference.  Regexp references passed in are passed
     through unmolested.

     Here are the transformation rules:

          '*'  => '[^/]*'
          '?'  => '.'
          '**' => '.*'               ## unless { star_star => 0 }

          '('  => '('                ## unless { parens => 0 }
          ')'  => ')'                ## unless { parens => 0 }

          '{a,b,c}' => '(?:a|b|c)'   ## unless { braces => 0 }

          '\a' => 'a'                ## These are de-escaped and
          '\*' => '\*'               ## passed to quotemeta()

     The wildcards treat newlines as normal characters.

     Parens group in to $1..$n, since they are passed through unmolested
     (unless option parens => 0 is passed).  This is useless when using
     glob_shellish(), though.

     The final parameter can be a hash reference containing options:

          compile_shellish(
             '**',
             {
                anchors        => 0,   ## Doesn't put ^ and $ around the
          	                        ## resulting regexp
                case_sensitive => 0,   ## Make case insensitive
                star_star      => 0,   ## '**' is now two '*' wildcards
          	 parens         => 0,   ## '(', ')' are now regular chars
          	 braces         => 0,   ## '{', '}' are now regular chars
             }
          ) ;

     No option affects Regexps passed through.

shellish_glob
     Pass a regular expression and a list of possible values, get back a
     list of matching values.

          my @matches = shellish_glob( '*/*', @possibilities ) ;
          my @matches = shellish_glob( '*/*', @possibilities, %options ) ;

AUTHOR
======

   Barrie Slaymaker <barries@slaysys.com>


