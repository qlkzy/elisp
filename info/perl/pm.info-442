This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: XML/miniXQL,  Next: XMLNews/HTMLTemplate,  Prev: XML/XSLT,  Up: Module List

Module for doing stream based XML queries
*****************************************

NAME
====

   XML::miniXQL - Module for doing stream based XML queries

SYNOPSIS
========

     use XML::miniXQL;

     my $results = XML::miniXQL::queryXML({Style => 'Hash'}, $xml, @searches);

DESCRIPTION
===========

   This module provides a simplistic XQL like search engine for XML files.
It only supports a subset of XQL, because it does all it's searching on
streams, not on the document as a whole (unlike XML::XQL). For this
reason, only ancestor relationships are supported, not sibling or child
relationships. XML::miniXQL also doesn't return nodes, it only returns the
value (text) found as the result of the query. As a result, you can't use
this module for node manipulation, however it's faster than XML::XQL, so
it can be used on a web backend or some such environment. Xmerge is
provided as an example of usage.

   The queries are passed in as an array of queries, and the results
passed out as either a simple tuple list (each alternate value is either
the query or the result respectively), or as a hash with the values being
an array. See xmerge.pl as an example of the Hash style.  The List style
is the default.

AUTHOR
======

   Matt Sergeant matt@sergeant.org

SEE ALSO
========

   perl(1).


File: pm.info,  Node: XMLNews/HTMLTemplate,  Next: XMLNews/Meta,  Prev: XML/miniXQL,  Up: Module List

A module for converting NITF to HTML.
*************************************

NAME
====

   XMLNews::HTMLTemplate - A module for converting NITF to HTML.

SYNOPSIS
========

     use XMLNews::HTMLTemplate;

     my $template = new XMLNews::HTMLTemplate();
     $template->readTemplate("mytemplate.html");

     $template->applyTemplate("output.html", "story.xml", "story.rdf");

DESCRIPTION
===========

   NOTE: this module requires the XML::Parser and XMLNews::Meta modules.

   WARNING: this module is not thread-safe or re-entrant.

   The XMLNews::HTMLTemplate module provides a simple mechanism for
creating HTML pages from XML/NITF news stories and/or XML/RDF metadata
files based on a user-supplied template file.  The template is a simple
HTML file (SGML or XML flavour) using special template commands, which the
user includes as processing instructions, as in the following example:

     <h1><?XNews insert headline?></h1>

   To create an HTML page, you must first create an empty HTMLTemplate
object:

     my $template = new XMLNews::HTMLTemplate();

   Next, you load the HTML template into the object:

     $template->readTemplate("mytemplate.html");

   Now, you can apply the same compiled template object repeatedly to
different XML/NITF and/or XML/RDF documents to generate HTML pages:

     $template->applyTemplate("outfile.html", "newsstory.xml", "newsstory.rdf");

   In this example, the module will read the XML/NITF news story in
newstory.xml and the XML/RDF metadata in newstory.rdf, and write an HTML
page at outfile.html.

METHODS
=======

new ()
     Construct a new, empty instance of an XMLNews::HTMLTemplate object:

          my $template = new XMLNews::HTMLTemplate();

readTemplate(TEMPLATE)
     Compile a template file into the current object, discarding any
     existing compiled template:

          $template->readTemplate("news-template.htm");

     The TEMPLATE argument may be either a string containing a file name or
     an IO::Handle object.

     You must compile a template before you can use it, but once you have
     compiled the template, you may use it to create many different HTML
     pages.

applyTemplate(OUT_FILE, NITF_FILE, RDF_FILE)
     Apply the compiled template to an NITF-format news story and/or and
     RDF-format metadata file, filling in the fields in the template
     commands using the properties found in these files:

          $template->applyTemplate("story999.html", "story999.xml", "story999.rdf");

     The three arguments may be either strings containing file names or
     IO::Handle objects.  If the file specified by OUT_FILE already exists,
     this method will overwrite its contents.

     Either or both of the NITF_FILE or the RDF_FILE parameters may be
     omitted if desired.

HTML TEMPLATE FORMAT
====================

   An XMLNews template file is an HTML file containing special processing
instructions, beginning with "<?XNews " and ending with ">" or "?>".
Following the word "XNews", each processing instruction contains
whitespace and a command word, followed optionally by command parameters,
as in the following example:

     <?XNews insert headline?>

   Typically, the template would include this processing instruction
within an HTML element:

     <h1><?XNews insert headline?></h1>

   All processing instructions beginning with characters other than
"XNews" will be ignored and passed through as-is (they may be used for
other sorts of processing).

Template Commands
-----------------

   Any of the following six command words may follow the word "XNews" in a
processing instruction (all commands are case-sensitive):

namespace PREFIX=URI
     Declare a prefix representing a namespace:

          <?XNews namespace xn=http://www.xmlnews.org/namespaces/meta#?>

     Once the prefix is declared, you can use it to point to properties in
     the RDF file:

          <?XNews insert xn:person?>

     Note that it is the namespace URIs rather than the prefixes that are
     matched against RDF; the following would work identically with the
     same RDF file:

          <?XNews namespace aBcDe=http://www.xmlnews.org/namespaces/meta#?>
          <?XNews insert aBcDe:person?>

     All namespace declarations have global scope from the point of
     declaration forward; it is usually best to include all of the
     declarations at the top of the template.

insert PROPERTY
     Insert the value of PROPERTY at this point in the generated document:

          <?XNews insert dateline?>

     If there is more than one value available for the property, all of the
     values will be inserted in random order, separated by spaces, unless
     this processing instruction occurs within a "foreach" block (see
     below).

if PROPERTY
     Begin a conditional statement:

          <?XNews if byline?>
           <h2><?XNews insert byline?></h2>
          <?XNews end?>

     Everything between this processing instruction and the matching "end"
     instruction will be included only if [property] has a non-null value.

     "if" commands may be nested.

else
     Specify the default action for when an "if" command fails:

          <?XNews if date?>
           <p>Date: <?XNews insert date?></p>
          <?XNews else?>
           <p>Undated.</p>
          <?XNews end?>

foreach PROPERTY
     Iterate over multiple values for a property:

          <?XNews foreach http://www.inews.org/props/CompanyCode?>
          <p>Ticker: <?XNews insert http://www.inews.org/props/CompanyCode?></p>
          <?XNews end?>

     These instructions will create a separate <p> element for every
     CompanyCode (ticker) value available.

end
     Terminate an "if" or "foreach" statement:

          <?XNews if dateline?>
          <p>Dateline: <?XNews insert dateline?></p>
          <?XNews end?>

Property Names
--------------

   Property names consist of two parts: a namespace and a base name.
Properties derived from the NITF document have null namespace parts;
properties derived from the RDF metadata have non-null namespace parts.
To specify a property with a non-null namespace part, you must first
declare a namespace prefix, and then include the prefix before the
property name separated with a colon:

     <?XNews namespace xn=http://www.xmlnews.org/namespaces/meta#?>

     <?XNews insert xn:companyCode?>

   These commands insert the value of the property "companyCode" in the
http://www.xmlnews.org/namespaces/meta# namespace, as found in the RDF
metadata file.  You may access any property specified in the news story's
RDF metadata file in this way (such as ticker symbols, dates, and the
language of the resource).

   In addition to the metadata properties in the RDF file, there are nine
special pseudo-properties that have a NULL namespace (most of these
duplicate properties in the RDF, but their values are also given in the
news story):

headline
          The text of the story's headline, if any.

subheadline
          The text of the story's subheadline(s), if any.  There may be more
          than one value for this property, so it is best to include it in a
          "foreach" block.

byline
          The text of the story's byline(s), if any.  There may be more than
          one value for this property, so it is best to include it in a
          "foreach" block.

distributor
          The text of the distributor's name, if any.

dateline
          The text of the story's dateline, if any.

series.name
          The name of the series to which this story belongs, if any.

series.part
          The position of this story in a series, if any.

series.totalpart
          The total number of stories in this series, if any.

body
          HTML markup for the body of the story, divided into paragraphs.

Sample Template
---------------

   Here is a simple sample template for a news story (using XML/HTML
syntax); it does not use any RDF properties:

     <?xml version="1.0"?>

     <html>
     <head>
     <title>News Story: <?XNews insert headline?></title>
     </head>
     <body>
     <h1><?XNews insert headline?></h1>

     <?XNews foreach subheadline?>
     <h2><?XNews insert subheadline?></h2>
     <?XNews end?>

     <?XNews foreach byline?>
     <p><em><?XNews insert byline?></em></p>
     <?XNews end?>

     <p>(Dateline: <?XNews insert dateline?>)</p>

     <?XNews insert body?>

     </body>
     </html>

CONFORMANCE NOTE
================

   The processing instruction target is "XNews" rather than XMLNews so
that template files can be well-formed XML if desired (XML reserves all
processing-instruction targets beginning with [xX][mM][lL]).

   Given the wide variations in common HTML usage, this module uses
pattern matching on the HTML templates rather than trying to parse them as
SGML or XML documents.  As a result, it will recognise template commands
even within comments and attribute values, places where they are not
properly recognised in SGML or XML.

AUTHOR
======

   This module was originally written by David Megginson
(david@megginson.com).


File: pm.info,  Node: XMLNews/Meta,  Next: XSLoader,  Prev: XMLNews/HTMLTemplate,  Up: Module List

A module for reading and writing XMLNews metadata files.
********************************************************

NAME
====

   XMLNews::Meta - A module for reading and writing XMLNews metadata files.

SYNOPSIS
========

     use XMLNews::Meta;

     my $namespace = "http://www.xmlnews.org/namespaces/meta#";

     # Create a Meta object.
       my $meta = new XMLNews::Meta();

     # Read in the metadata file.
       $meta->importRDF("data.rdf");

     # Look up a singleton value.
       my $expireTime = $meta->getValue($namespace, "expireTime");

     # Add a new value to a property.
       $meta->addValue($namespace, "companyCode", "WAVO");

     # Write the metadata back out.
       $meta->exportRDF("data.rdf");

DESCRIPTION
===========

   NOTE: This module requires the XML::Parser module, version 2.19 or
higher.

   WARNING: This module is not re-entrant or thread-safe due to the use of
static variables while importing XML.

   The XMLNews::Meta module handles the import, export, and programmatic
manipulation of metadata for XMLNews resources.  You can read or write a
metadata file using a single method call, and can easily add or remove
values.

   Traditionally, resource files consist of simple pairs of the form

     NAME = VALUE

   XMLNews metadata, which is based on the W3C's Resource Description
Format (RDF), allows richer metadata in two ways:

  1. Property names are partitioned into namespaces, so that two different
     providers can use the same property name without fear of collision (a
     namespaces is simply a URI (URL or URN); following RDF practice, the
     URI should end with the fragment separator "#".  To look up a
     property, you always need to use both the namespace and the property
     name:

          $xn_ns = "http://www.xmlnews.org/namespaces/meta#";

          # Use getValue only for
          # singleton values!!!
            $title = $meta->getValue($xn_ns, "title");
            $creator = $meta->getValue($xn_ns, "creator");

  2. The same property can have more than one value, which the getValues
     method will deliver as an array:

          $xn_ns = "http://www.xmlnews.org/namespaces/meta#";
          @companyCodes = $meta->getValues($xn_ns, 'companyCodes');


METHODS
=======

new()
     Create a new (empty) metadata collection:

          use XMLNews::Meta;
          my $meta = new XMLNews::Meta();

     Once you have created the collection, you can add values manually
     using the addValue() method, or import one or more files into the
     collection using the importRDF() method.

importRDF(INPUT)
     Read an RDF file from the IO::Handle input stream provided, and add
     its properties to this metadata collection:

          $meta->importRDF($handle);

     If INPUT is a string, it will be treated as a file name; otherwise, it
     will be treated as an instance of IO::Handle.

     Note that duplicate properties will not be filtered out, so it is
     possible to have the same property with the same value more than once.
     Importing a file does not remove any properties already in the
     collection.

exportRDF(OUTPUT)
     Export all of the properties in the collection to an IO::Handle output
     stream of some sort:

          $meta->exportRDF($output);

     If OUTPUT is a string, it will be treated as a file name; otherwise,
     it will be treated as an instance of IO::Handle.

     The XML::Meta module will create its own namespace prefixes for the
     different namespaces in the document, but the namespaces themselves
     will not be changed.

getValues(NAMESPACE, PROPERTY)
     Return all of the values for a property in a namespace as an array.
     If the property does not exist, return an empty array:

          my $namespace = "http://www.xmlnews.org/namespaces/meta#";
          my @people = $meta->getValues($namespace, 'personName');
          foreach $person (@people) {
            print "This resource mentions $person\n";
          }

     Note that it is always necessary to provide a namespace as well as a
     property name; the property 'personName' might have a different
     meaning in another namespace.

     (When you know for certain that a property will never have more than
     one value, you can use the getValue() method instead to avoid dealing
     with an array.)

getValue(NAMESPACE, PROPERTY)
     Return a single value (or undef) for a property in a namespace:

          my $resourceId = $meta->getValue($namespace, 'resourceId');

     This method is convenient for properties (like XMLNews's 'resourceId')
     which should never have more than one value.

     NOTE: If there is more than one value present for the resource, the
     getValue() method will croak().

hasValue(NAMESPACE, PROPERTY)
     Return true if the specified property has one or more values, and
     false otherwise:

          unless ($meta->hasValue($namespace, 'provider')) {
            print "No provider information available\n";
          }

getNamespaces()
     Return an array containing all of the namespaces used in the metadata
     collection:

          my @namespaces = $meta->getNamespaces();

     Each namespace is a URI (URL or URN) represented as a string.

getProperties(NAMESPACE)
     Return an array containing all of the properties defined for a
     specific namespace in the metadata collection:

          my @properties = $meta->getProperties($namespace);

     If the namespace does not exist, this method will croak().

addValue(NAMESPACE, PROPERTY, VALUE)
     Add a value for a property in a namespace:

          $meta->addValue($namespace, "locationName", "Salt Lake City");

removeValue(NAMESPACE, PROPERTY, VALUE)
     Remove a value for a property in a namespace:

          $meta->removeValue($namespace, "locationName", "Dallas");

     If the namespace, property, or value does not exist, this method will
     croak().

CONFORMANCE NOTE
================

   The XMLNews metadata format is based on RDF, but this tool is not a
general RDF processor; instead, it relies on a particular usage profile
and a particular abbreviated syntax, like the following:

     <?xml version="1.0"?>
     <xn:Resource xmlns:xn="http://www.xmlnews.org/namespaces/meta#">
      <xn:resourceId>12345</xn:resourceId>
      <xn:title>Sample</xn:title>
      <xn:description>Sample resource.</xn:description>
      <xn:rendition>12345.xml</xn:rendition>
      <xn:rendition>12345.html</xn:rendition>
     </xn:Resource>

AUTHOR
======

   This module was originally written for WavePhore by David Megginson
(david@megginson.com).


File: pm.info,  Node: XSLoader,  Next: XTM,  Prev: XMLNews/Meta,  Up: Module List

Dynamically load C libraries into Perl code
*******************************************

NAME
====

   XSLoader - Dynamically load C libraries into Perl code

SYNOPSIS
========

     package YourPackage;
     use XSLoader;

     XSLoader::load 'YourPackage', @args;

DESCRIPTION
===========

   This module defines a standard *simplified* interface to the dynamic
linking mechanisms available on many platforms.  Its primary purpose is to
implement cheap automatic dynamic loading of Perl modules.

   For more complicated interface see *Note DynaLoader: DynaLoader,.

AUTHOR
======

   Ilya Zakharevich: extraction from DynaLoader.


File: pm.info,  Node: XTM,  Next: XTM/Log,  Prev: XSLoader,  Up: Module List

Topic Map management
********************

NAME
====

   XTM - Topic Map management

SYNOPSIS
========

     use XTM;

     $tm = new XTM; # creating an empty map

     # reading a topic map description from an XML file
     use XTM::XML;
     $xml = new XTM::XML (file => 'mymap.tm'); # create an XML channel, see XTM::XML
     $tm  = new XTM (tie => $xml); # binds variable to channel

     # primitive accessor to fetch/set the memory representation of the map
     print Dumper $tm->memory;
     # basic statistics about a map
     print Dumper $tm->info;

DESCRIPTION
===========

   Topic Maps are a means for layering multidimensional topic spaces on
top of information assets. The standard covers concepts like topics,
associations, scopes and occurrences. Topic Maps are expected to have a
major impact on future information systems (semantic web).

   See http://www.topicmaps.org/xtm/1.0/ for more information.

   Topic maps can be loaded from an XML based resource (local or remote
via an URL) as prescribed by the XTM standard. There is also a way to tie
a map to a persistent medium. The latter is especially interesting when
running this module along with a (web) server.

PACKAGES
========

   Following package come with this distribution (`XTM::Server' in this
node is in preparation):

     XTM                          this package, toplevel wrapper for (non-threaded) maps
     XTM::Memory                  in-memory representation of a map

     XTM::XML::PSI                PSI definitions
     XTM::XML                     XML parser
     XTM::XML::Latin1Parser
     XTM::XML::UTF8
     XTM::XML::Grove2TM

     XTM::Log                     logging facility will be used by others

     XTM::generic                 accessor functions for all below
     XTM::topic                   implementation of the 'topic' class
     XTM::association             implementation of the 'association' class

     XTM::topicRef                generic class definition
     XTM::baseName                generic class definition
     XTM::scope                   generic class definition
     XTM::resourceRef             generic class definition
     XTM::instanceOf              generic class definition
     XTM::subjectIdentity         generic class definition
     XTM::subjectIndicatorRef     generic class definition
     XTM::variant                 generic class definition
     XTM::variantName             generic class definition
     XTM::parameters              generic class definition
     XTM::roleSpec                generic class definition
     XTM::member                  generic class definition
     XTM::mergeMap                generic class definition
     XTM::resourceData            generic class definition
     XTM::baseNameString          generic class definition
     XTM::occurrence              generic class definition

INTERFACE
=========

Constructor
-----------

   The constructor expects no mandatory parameters but you can provide a
hash with the following fields:

tie:
     If you provide a tieable object (*Note XTM/XML: XTM/XML,, ...), then
     this object is bound to the topic map.

*staleness*: (not implemented in this public version)
     This additional field  lets you specify how strong the relationship
     between the original source (say, XML file) and the map is. Whenever
     the time difference between memory copy and the copy on the tie-ed
     medium exceeds the *staleness* given, then a sync (either in or out)
     will be done.

     $tm = new XTM ();
     $tm = new XTM (tie => new XTM::XML (file => 'map.xtm'));

Methods
=======

   All, except the methods below, are handed over to the corresponding
memory component.

memory
     returns/sets the *Note XTM/Memory: XTM/Memory, component. Setting
     will NOT check the consistency with the other components.

info
     returns some meta/statistical information about the map in form of a
     hash reference.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/Log,  Next: XTM/Memory,  Prev: XTM,  Up: Module List

Topic Map Logger
****************

NAME
====

   XTM::Log - Topic Map Logger

SYNOPSIS
========

     use XTM::Log;

DESCRIPTION
===========

   This package provides some logging facilities for the XTM::* packages.
Basically, it provides STDERR and file based logging.

INTERFACE
=========

Global Variables
----------------

   Following variables can be set to control the behavior of this package:

logfile (xtmd.log)
`loglevel' (1)
Methods
=======

flog
     provides some basic file logging facilities. Please refer to the
     global variables for configuration.  It logs messages to the current
     logfile whenever called and the passed loglevel is at least the
     minimum (as configured via the global variable `loglevel').
     Parameters are:

    entity
          Here you can provide some descriptive text of the module logging.

    `loglevel'
          current loglevel

     Any additional parameters are copied (for SCALARs) or output via
     Data::Dumper::Dumper.

     Example:

          flog ('MyProgram', 4, 'Logging a line', $line, \%context);

elog
     provides some basic STDERR logging facilities. Otherwise see flog.

     Example:

          elog ('MyProgram', 4, 'Logging a line', $line, \%context);

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/Memory,  Next: XTM/XML,  Prev: XTM/Log,  Up: Module List

Topic Map management, in-memory data structure.
***********************************************

NAME
====

   XTM - Topic Map management, in-memory data structure.

SYNOPSIS
========

     use XTM::Memory;
     $tm = new XTM::Memory ();

     # adding something
     $tm->add (new XTM::topic (id => "t-beatles", ...));
     $tm->add (new XTM::association (....));

     # removing something
     $tm->remove ('t-beatles');

     # checking something
     print "Hurray" if
      $tm->is_topic ('t-john-lennon') ||
      $tm->is_association ('a-played-in');

     # finding something
     @rumstis = @{$tm->topics ( "baseName regexps /rumsti.*/" )};

     # fetching names for a scope
     @names = @{$tm->baseNames ([ 't-paul-mccartney', 't-john-lennon' ],
     			      [ 'http://www.topicmaps.org/xtm/language.xtm#en' ]);}

DESCRIPTION
===========

   This package provides an in-memory data structure for topic maps.
Basically, the object maintains a hash of topics and a hash of
associations. The interface provides for basic operations to add/delete
topics/associations and to query the map via a query language.

INTERFACE
=========

   The interface offers basic access function but also some sophisticated
filters to create sub maps. More convenient functions to retrieve topic
and association information can be found in the `XTM::Server' in this node
package distributed seperately.

Constructor
-----------

   The constructor expects only one optional parameter, id. If not
provided, the id will remain undefined.

     $tm = new XTM::Memory ();

Methods
-------

add
     Adds a (list of) topics, associations and/or maps to the map object
     with the following rules:

       1. If a particular topic/association id does already exist in the
          map object, the corresponding topic will simply be
          *overwritten*. This also happens when another map with such a
          topic/association is merged.

       2. No topic merging will (yet) occur.

          Examples:

          $t = new XTM::topic (id => "t-portishead", ...);
          $a = new XTM::association (....);
          $tm->add ($t);
          $tm->add ($t1, $t2);
          $a = new XTM::association (....);
          $tm->add ($a);
          $tm->add ($a, $t);
          $tm2 = new XTM::Memory;
          ...
          $tm->add ($tm2);

     If a parameter is neither a topic nor an association nor a topic map,
     an exception will be raised.

remove
     removes particular topics and associations specified by their id.
     You can provide a list here. The method will return a list references
     of object (references), which were removed from the map during this
     operation. ids not identifying any topic or association in the map,
     are ignored.

     Examples:

          # get rid of a particular topic
          $tm->remove ('t-portishead');

*is_topic*, *is_association*
     check whether a particular topic/association with a given id exists
     in the map.  Returns 1 in that case, undef otherwise.

     Examples:

          print "Hurray" if $tm->is_topic ('t-john-lennon') ||
                            $tm->is_association ('a-played-in');

topics
     returns a list reference of topic ids for this given map. An optional
     filter specification can filter only relevant topics:

     Example:

          # get all of them (or at least what the implementation is willing to give)
          $tm->topics ();
          # only with some name
          $tm->topics ( "baseName regexps /rumsti.*/" );

     The filter specifications follow the syntax:

          filter        -> clause { 'AND' clause }
          clause        -> 'baseName'   'regexps' regexp_string                               |
                           'occurrence' 'regexps' regexp_string                               |
                           'text'       'regexps' regexp_string                               | # any text within the topic
                           'id'         'regexps' regexp_string                               |
                           'id'         'eq'      ''' string '''                              |
                           'assocs' [ 'via' topic_id ] [ 'with' topic_id ] [ 'transitively' ] |
                           'is-a'  topic_id                                                   |
          ##                 'instanceOfs' ( '<=' | '==' | '>=' )  set_of_topic_ids | NOT IMPLEMENTED
          ##                 'scoped_by' topic_id   ## NOT IMPLEMENTED
          regexp_string -> '/' regexp '/'
          regexp        -> <a perl pattern>
          topic_id      -> <id of a topic>
          string        -> <any string with no \' in it>

associations
     returns the ids of associations. An optional filter specification can
     filter only relevant associations:

     Examples:

          # get _all_  from the map
          @assocs = @{$tm->associations()};
          # get only these matching a specific regexp for the id
          @assocs = @{$tm->associations ('id  regexps /^#a-some-assoc/')};
          # get only these containing a particular topic as a role player
          @assocs = @{$tm->associations ('has_role t-some-role')};
          # get only these containing a particular topic as a member
          @assocs = @{$tm->associations ('has_member t-some-topic AND has_role t-some-role')};
          # with a specific type
          @assocs = @{$tm->associations ('is-a at-relation')};

     The filter specifications follow the syntax:

          filter        -> clause { 'AND' clause }
          clause        -> 'id'    'regexps' regexp_string      |
                           'id'    'eq'      ''' string '''     |
                           'has-role'        topic_id           |
                           'has-member'      topic_id           |
                           'is-a'            topic_id           |
          regexp_string -> '/' regexp '/'
          regexp        -> <a perl pattern>
          topic_id      -> <id of a topic>

topic, *association*
     return a topic/association object (reference) for a given id. If
     there is no such id, an exception will be raised.

          my $john = $tm->topic ('t-john-lennon');

`topic_tree'
     computes a tree of topics based on a starting topic, an association
     type and two roles. Whenever an association of the given type is
     found and the given topic appears in the role given in this very
     association, then all topics appearing in the other given role are
     regarded to be children in the result tree. There is also an optional
     depth parameter. If it is not defined, no limit applies. If there are
     loops implied by this relation, so be it.

     Examples:

          $hierachy = $tm->topic_tree (topic      => $start_node,
          			       assoc_type => 'at-relation',
          			       a_role     => 'tt-parent',
          			       b_role     => 'tt-child' );
            $yhcareih = $tm->topic_tree (topic      => $start_node,
          			       assoc_type => 'at-relation',
          			       b_role     => 'tt-parent',
          			       a_role     => 'tt-child',
          			       depth      => 42 );

`baseNames'
     receives a list reference containing topic ids. It returns a hash
     reference containing the baseName for each topic as a value with the
     topic id the key. The additional parameter is interpreted as list
     reference to scoping topics. If this list is undef, then any basename
     may be returned. If the list is empty ([]), then NO basename will
     ever be returned. If it is non-empty, then - according to the order in
     this list - the first basename matching will be selected.

     Example:

          $names_ref = $tm->baseNames ([ 't-topic1', 't-topic-2' ],
          				[ 'http://www.topicmaps.org/xtm/language.xtm#en' ]);

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/XML,  Next: XTM/XML/Grove2TM,  Prev: XTM/Memory,  Up: Module List

Topic Map management, syncing with XML data
*******************************************

NAME
====

   XTM::XML - Topic Map management, syncing with XML data

SYNOPSIS
========

     use XTM::XML;

     # reading a topic map description from an XML file
     $xml = new XTM::XML (file => 'mymap.tm');

DESCRIPTION
===========

   This package provides an abstract class to deal with TMs stored in XML
form, be it on files or as a string.

INTERFACE
=========

Constructor
-----------

   The constructor expects a hash as parameter containing one of the
following fields:

url:
     If given then the XML data will be read/written from/to this url.

file:
     If given then the XML data will be read/written from/to this file
     (This is just a convenience function as it will be mapped to url).

text:
     If given then the XML data will be read/written from/to this text.
     (See method text how to retrieve the current value).

   If several fields are specified, an exception will be raised.

   Examples:

     $xtm = new XTM::XML (file => 'here.xml');
     $xtm = new XTM::XML (url  => 'file:here.xml');  # the same
     $xtm = new XTM::XML (text => '<?xml version="1.0"?><topicmap> ...</topicmap>');

Methods
-------

   The methods `sync_in', `sync_out' and `last_mod' implement the methods
from the abstract class.

`last_mod'
     returns the UNIX time when the resource has been modified last. undef
     is returned if the result cannot be determined.

`sync_in'
     actually loads an XTM resource and returns a *Note XTM/Memory:
     XTM/Memory, object.

`sync_out'
     is currently not implemented.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/XML/Grove2TM,  Next: XTM/XML/Latin1Parser,  Prev: XTM/XML,  Up: Module List

XTM XML parser
**************

NAME
====

     XTM::XML::Grove2TM - XTM XML parser

SYNOPSIS
========

     use XTM::XML::Latin1Parser;
     my $grove_builder = XTM::XML::Latin1Parser->new;
     my $parser = XML::Parser::PerlSAX->new ( Handler => $grove_builder );
     my $grove;
     $grove  = $parser->parse ( Source => { String => $stream,
                                            Encoding => 'ISO-8859-1' } );
     use Data::Grove::Visitor;
     my $tm = new XTM::Memory;
     use XTM::XML::Grove2TM;
     $grove->accept_name (XTM::XML::Grove2TM->new, $tm);

DESCRIPTION
===========

   Once you have a grove with parsed XML data, you can iterate over this
grove, letting the package do the work of creating a *Note XTM/Memory:
XTM/Memory, structure.

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/XML/Latin1Parser,  Next: XTM/XML/PSI,  Prev: XTM/XML/Grove2TM,  Up: Module List

XTM generic XML first pass parser.
**********************************

NAME
====

   XTM::XML::Latin1Parser - XTM generic XML first pass parser.

SYNOPSIS
========

   # Just here to silence pod2man. This is very much an internal package

DESCRIPTION
===========

   none.

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/XML/PSI,  Next: XTM/XML/UTF8,  Prev: XTM/XML/Latin1Parser,  Up: Module List

Topic Map management, published subject identifiers
***************************************************

NAME
====

   XTM::XML::PSI - Topic Map management, published subject identifiers

SYNOPSIS
========

     use XTM::XML::PSI;
     print $psi{'universal_scope'};

DESCRIPTION
===========

   This package contains a hash with some PSIs. See

     http://www.topicmaps.org/xtm/1.0/psi1.xtm

   for an everchanging list.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/XML/UTF8,  Next: XTM/association,  Prev: XTM/XML/PSI,  Up: Module List

XTM backwards compatible UTF support
************************************

NAME
====

   XTM::XML::UTF - XTM backwards compatible UTF support

DESCRIPTION
===========

   This package contains auxiliary functions to convert from UTF8 to Latin1
characters and vice-versa.

SYNOPSIS
========

     $s = "..some ugly characters ...";
     $t = utf82iso ($s);

     unless ($s eq iso2utf8 ($t)) {
       print STDERR "maybe you should not use iso2utf8\n";
     }

INTERFACE
=========

utf82iso
     converts an array and/or a single UTF-8 scalar into its ISOLatin
     equivalent.

iso2utf8
     and the other way round.

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/association,  Next: XTM/baseName,  Prev: XTM/XML/UTF8,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::association - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/baseName,  Next: XTM/baseNameString,  Prev: XTM/association,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::baseName - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/baseNameString,  Next: XTM/generic,  Prev: XTM/baseName,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::baseNameString - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/generic,  Next: XTM/instanceOf,  Prev: XTM/baseNameString,  Up: Module List

XTM generic accessor
********************

NAME
====

   XTM::generic - XTM generic accessor

SYNOPSIS
========

     # very much an internal package...

DESCRIPTION
===========

   Generic provider for accessor functions.

   Instead of hard-coding simple accessor functions into trivial packages,
these packages can inherit the methods from this package.

INTERFACE
=========

Constructor
-----------

   The constructor just returns a blessed object reference to the class in
question. All parameters - given in a hash - will be components of the
resulting object.

Methods
-------

   AUTOLOAD will capture most of the access.

   If the method name begins with 'add_'. If it ends with '_s' then the
provided values will be added to a list component. Otherwise it is
regarded as a single value.

   If the method does not begin with 'add_' then a simple read access is
assumed. Again, if the name ends with '_s' then a list will be returned.

   The component name will be derived from the rest of the method name, if
that is non-empty (like in 'add_rumsti_s'). If the name is empty
('add__s') then the component name will be derived from the parameters
class name ('XYZ::rumsti' will result in a component name 'rumsti').

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/instanceOf,  Next: XTM/member,  Prev: XTM/generic,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::instanceOf - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/member,  Next: XTM/mergeMap,  Prev: XTM/instanceOf,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::member - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/mergeMap,  Next: XTM/occurrence,  Prev: XTM/member,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::mergeMap - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/occurrence,  Next: XTM/parameters,  Prev: XTM/mergeMap,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::occurrence - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/parameters,  Next: XTM/resourceData,  Prev: XTM/occurrence,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::parameters - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/resourceData,  Next: XTM/resourceRef,  Prev: XTM/parameters,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::resourceData - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/resourceRef,  Next: XTM/roleSpec,  Prev: XTM/resourceData,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::resourceRef - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/roleSpec,  Next: XTM/scope,  Prev: XTM/resourceRef,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::roleSpec - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/scope,  Next: XTM/subjectIdentity,  Prev: XTM/roleSpec,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::scope - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/subjectIdentity,  Next: XTM/subjectIndicatorRef,  Prev: XTM/scope,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::subjectIdentity - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/subjectIndicatorRef,  Next: XTM/topic,  Prev: XTM/subjectIdentity,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::subjectIndicatorRef - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/topic,  Next: XTM/topicRef,  Prev: XTM/subjectIndicatorRef,  Up: Module List

Topic Map management, Topic
***************************

NAME
====

   XTM::topic - Topic Map management, Topic

SYNOPSIS
========

     use XTM::topic;

     my $t = new XTM::topic;
     ...
     print join (",", @{$t->occurrences()});
     print "bliss and happiness" if $t->has_instanceOf ('t-billionair');

     # see XTM::generic for more

DESCRIPTION
===========

   This package provides the primitive class Topic for Topic Maps.

INTERFACE
=========

Constructor
-----------

   The constructor expects a hash with following (optional) fields:

id: a topic id (unique in the map in use), if not given, it will be generated
     $t = new XTM::topic ('id' => '#123');

Methods
-------

occurrences
     returns the occurrences of the topic as a list reference. If provided
     with a parameter, this value will be used as new occurrences list
     reference (no validation will happen).

map
     is an accessor method for the map component.

has_instanceOf
     returns true if the topic is a direct subtype of a topic specified as
     tid for the only parameter.

     Example:

          print "bliss and happiness" if $t->has_instanceOf ('t-billionair');

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/topicRef,  Next: XTM/variant,  Prev: XTM/topic,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::topicRef - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: XTM/variant,  Next: XTM/variantName,  Prev: XTM/topicRef,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::variant - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


