This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Chart/Graph,  Next: Chart/PNGgraph,  Prev: Chart,  Up: Module List

Perl extension for a front-end to gnuplot and XRT.
**************************************************

NAME
====

     Chart::Graph - Perl extension for a front-end to gnuplot and XRT.

     23/4/99
     Version 1.1

SYNOPSIS
========

     #make sure to include Chart::Graph
     use Chart::Graph;

     gnuplot(\%global_options, [\%data_set_options, \@matrix],
                               [\%data_set_options, \@x_column, \@y_column],
                               [\%data_set_options, < filename >], ... );

     #make sure to include Chart::Graph
     use Chart::Graph;

     xrt3d(\%options, \@data_set);

     #say for example we have a 3 by 4 matrix -> dataxy
     xrt3d(\%options,
           [[data11, data12, data13, data14],
           [data21, data22, data23, data24],
           [data31, data32, data33, data34]])

DESCRIPTION
===========

     use Chart::Graph;

     Graph.pm is a module that allows easy generation of graphs within
     perl. Currently Graph.pm supports two packages, gnuplot and xrt,
     both of which you need to have installed on your system.

     Currently the xrt3d package is not being supported, although
     it works. It is still in the development stage. Feel free to
     give it a try though.

INSTALLATION
============

     To install Graph.pm on your system you need to run:

     perl Makefile.PL
     make
     make install

     If you want to use the xrt3d package, you need to build the "graph"
     binary in the xrt3d directory.

USAGE
=====

     Graph.pm will probe your path if you do not supply paths to the
     programs that it needs.

     You need to set these variables if they are not in your path:

     For gnuplot():
     $Chart::Graph::gnuplot    # path to gnuplot
     $Chart::Graph::ppmtogif   # path to ppmtogif

     For xrt():
     $Chart::Graph::ppmtogif   # path to ppmtogif
     $Chart::Graph::xrt        # path to "graph"(the xrt wrapper)
     $Chart::Graph::xwdtopnm   # path to xwdtopnm
     $Chart::Graph::xvfb       # path to Xvfb(the virtual frame
                                # buffer required by XRT)

     Currently Chart::Graph supports two levels of debug, 0
     (no debug msgs) and 1(debug msgs). You need to set the
     $Graph::debug flag accordingly. If you are having problems
     with Graph.pm set the debug flag to 1. Also Graph.pm will check
     $ENV{TMPDIR} for the temporary file storage. If you do not
     specify, it will be set to /tmp automatically.
     
     All the documentation(in HTML, with examples) for Graph.pm
     is located in doc/. Documentation is also available online
     at http://www.caida.org/Tools/Graph.

CONTENT SUMMARY
===============

     Graph.pm        - top level file of Chart::Graph
     Graph/          - sub modules of Chart::Graph
     doc/            - documentation in HTML
     graph_xrt/      - xrt wrapper executable code
     test_Graph.pl   - the test script used for debugging

MORE INFO
=========

     For more information on gnuplot, please see the gnuplot web page:
     http://www.cs.dartmouth.edu/gnuplot_info.html.

CONTACT
=======

     Send email to graph-request@caida.org is you have problems,
     questions, or comments. To subscribe to the mailing list send
     mail to graph-request@caida.org with a body of
     "subscribe your@email.com"

AUTHOR
======

     Michael Young - mhyoung@caida.org

SEE ALSO
========

     gnuplot(1).


File: pm.info,  Node: Chart/PNGgraph,  Next: Chart/PNGgraph/colour,  Prev: Chart/Graph,  Up: Module List

Graph Plotting Module (deprecated)
**********************************

NAME
====

   Chart::PNGgraph - Graph Plotting Module (deprecated)

SYNOPSIS
========

   use Chart::PNGgraph::moduleName;

DESCRIPTION
===========

   *Chart::PNGgraph* is a *perl5* module to create PNG output for a graph.

   Chart::PNGgraph is nothing more than a wrapper around GD::Graph, and its
use is deprecated. It only exists for backward compatibility. The
documentation for all the functionality can be found in *Note GD/Graph:
GD/Graph,.

   This module should work with all versions of GD, but it has only been
tested with version 1.19 and above. Version 1.19 is the last version that
produces GIF output, and requires a conversion step. The default
distribution of Chart::PNGgraph uses Image::Magick for this. If you'd like
to use something else, please replace the sub png2gif in
Chart::PNGgraph::Convert with something more to your liking.

NOTES
=====

   Note that if you use Chart::PNGgraph with a GD version 1.19 or lower
that any included logos will have to be in the GIF format. The only time
that PNG comes into play is _after_ GD has done its work, and the GIF gets
converted to PNG. There are no plans to change that behaviour; it's too
much work, and you should really be upgrading to a version of GD that
produces PNG directly.

SEE ALSO
========

   GD::Graph(3), GIFgraph(3).

AUTHOR
======

   Martien Verbruggen ported to GD 1.20+ (PNG) by Steve Bonds

Contact info
------------

   for Chart::PNGgraph questions: email: sbonds@agora.rdrop.com

   for GIFgraph or GD::Graph questions: email: mgjv@comdyn.com.au

Copyright
---------

   Copyright (c) 1999 Steve Bonds Copyright (c) 1995-1999 Martien
Verbruggen.  All rights reserved.  This package is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.


File: pm.info,  Node: Chart/PNGgraph/colour,  Next: Chart/Plot,  Prev: Chart/PNGgraph,  Up: Module List

Colour manipulation routines for use with Chart::PNGgraph
*********************************************************

NAME
====

   Colour - Colour manipulation routines for use with Chart::PNGgraph

SYNOPSIS
========

   use Chart::PNGgraph::colour qw( :colours :lists :files );

DESCRIPTION
===========

   The *Colour* Package provides a few routines to convert some colour
names to RGB values. Also included are some functions to calculate the hue
and luminance of the colours, mainly to be able to sort them.

   The :colours tags can be used to import the *_rgb*, *_hue*, and
*_luminance* functions, the :lists tag for *colour_list* and
*sorted_colour_list*, and the :files tag exports the *read_rgb* function.

FUNCTIONS
=========

Colour::colour_list( *number of colours* )
     Returns a list of *number of colours* colour names known to the
     package.

Colour::sorted_colour_list( *number of colours* )
     Returns a list of *number of colours* colour names known to the
     package, sorted by luminance or hue.  *NB.* Right now it always sorts
     by luminance. Will add an option in a later stage to decide sorting
     method at run time.

Colour::_rgb( *colour name* )
     Returns a list of the RGB values of *colour name*.

Colour::_hue( *R,G,B* )
     Returns the hue of the colour with the specified RGB values.

Colour::_luminance( *R,G,B* )
     Returns the luminance of the colour with the specified RGB values.

Colour::read_rgb( `file name' )
     Reads in colours from a rgb file as used by the X11 system.

     Doing something like:

          use Chart::PNGgraph::bars;
          use Chart::PNGgraph::colour;

          Chart::PNGgraph::colour::read_rgb("rgb.txt") or die "cannot read colours";

     Will allow you to use any colours defined in rgb.txt in your graph.

PREDEFINED COLOUR NAMES
=======================

   white, lgray, gray, dgray, black, lblue, blue, dblue, gold, lyellow,
yellow, dyellow, lgreen, green, dgreen, lred, red, dred, lpurple, purple,
dpurple, lorange, orange, pink, dpink, marine, cyan, lbrown, dbrown.


File: pm.info,  Node: Chart/Plot,  Next: Chart/ThreeD/Pie,  Prev: Chart/PNGgraph/colour,  Up: Module List

Plot two dimensional data in an image. Version 0.10.
****************************************************

NAME
====

   Chart::Plot - Plot two dimensional data in an image. Version 0.10.

SYNOPSIS
========

     use Chart::Plot;
     
     my $img = Chart::Plot->new();
     my $anotherImg = Chart::Plot->new ($image_width, $image_height);
     
     $img->setData (\@dataset) or die( $img->error() );
     $img->setData (\@xdataset, \@ydataset);
     $img->setData (\@anotherdataset, 'red_dashedline_points');
     $img->setData (\@xanotherdataset, \@yanotherdataset,
                    'Blue SolidLine NoPoints');
     
     my ($xmin, $ymin, $xmax, $ymax) = $img->getBounds();
     
     $img->setGraphOptions ('horGraphOffset' => 75,
     			    'vertGraphOffset' => 100,
     			    'title' => 'My Graph Title',
     			    'horAxisLabel' => 'my X label',
     			    'vertAxisLabel' => 'my Y label' );
     
     print $img->draw();

DESCRIPTION
===========

   I wrote *Chart::Plot* to create images of some simple graphs of two
dimensional data. The other graphing interface modules to GD.pm I saw on
CPAN either could not handle negative data, or could only chart evenly
spaced horizontal data. (If you have evenly spaced or nonmetric horizontal
data and you want a bar or pie chart, I have successfully used the
GIFgraph and Chart::* modules, available on CPAN.)

   *Chart::Plot* will plot multiple data sets in the same graph, each with
some negative or positive values in the independent or dependent
variables. Each dataset can be a scatter graph (data are represented by
graph points only) or with lines connecting successive data points, or
both. Colors and dashed lines are supported, as is scientific notation
(1.7E10). Axes are scaled and positioned automatically and 5-10 ticks are
drawn and labeled on each axis.

   You must have already installed the *GD.pm* library by Lincoln Stein,
available on CPAN or at http://stein.cshl.org/WWW/software/GD/ Versions of
GD below 1.19 supported only gif image format. Versions between 1.20 and
1.26 support only png format. GD version 1.27 supports either png or jpg
image formats. Chart::Plot will draw whichever format your version of GD
will draw. (See below for a method to determine which format your version
supports.)

USAGE
=====

Create an image object: new()
-----------------------------

     use Chart::Plot;

     my $img = Chart::Plot->new;
     my $img = Chart::Plot->new ( $image_width, $image_height );
     my $anotherImg = new Chart::Plot;

   Create a new empty image with the new() method. It will be transparent
and interlaced if your version of GD supports gif format.  png does not
yet support either. If image size is not specified, the default is 400 x
300 pixels, or you can specify a different image size. You can also create
more than one image in the same script.

Acquire a dataset: setData()
----------------------------

     $img->setData (\@data);
     $img->setData (\@xdata, \@ydata);
     $img->setData (\@data, 'red_dashedline_points');
     $img->setData (\@xdata, \@ydata, 'blue solidline');

   The setData() method reads in a two-dimensional dataset to be plotted
into the image. You can pass the dataset either as one flat array
containing the paired x,y data or as two arrays, one each for the x and y
data.

   As a single array, in your script construct a flat array of the form
(x0, y0, ..., xn, yn) containing n+1 x,y data points .  Then plot the
dataset by passing a reference to the data array to the setData() method.
(If you do not know what a reference is, just put a backslash (\) in front
of the name of your data array when you pass it as an argument to
setData().) Like this:

     my @data = qw( -3 9   -2 4   -1 1   0 0   1 1  2 4  3 9);
     $img->setData (\@data);

   Or, you may find it more convenient to construct two equal length
arrays, one for the horizontal and one for the corresponding vertical
data. Then pass references to both arrays (horizontal first) to setData():

     my @xdata = qw( -3  -2  -1  0  1  2  3 );
     my @ydata = qw(  9   4   1  0  1  4  9 );
     $img->setData (\@xdata, \@ydata);

   In the current version, if you pass a reference to a single, flat array
to setData(), then only a reference to the data array is stored internally
in the plot object, not a copy of the array. The object does not modify
your data, but you can and the modified data will be drawn.  On the other
hand, if you pass references to two arrays, then copies of the data are
stored internally, and you cannot modify them from within your script.
This inconsistent behavior is probably a bug, though it might be useful
from time to time.

   You can also plot multiple datasets in the same graph by calling
`$img->setData()' repeatedly on different datasets.

   *Error checking:* The setData() method returns a postive integer on
success and 0 on failure. If setData() fails, you can recover an error
message about the most recent failure with the error() method. The error
string returned will either be "The data set does not contain an equal
number of x and y values." or "The data element ... is non-numeric."

     $p->setData (\@data) or die( $p->error() );

   In the current version, only numerals, decimal points (apologies to
Europeans), minus signs, and more generally, scientific notation (+1.7E-10
or -.298e+17) are supported. Commas (,), currencies ($), time (11:23am) or
dates (23/05/98) are not yet supported and will generate errors. I hope to
figure these out sometime in the future.

   Be cautious with scientific notation, since the axis tick labels will
probably become unwieldy. Consider rescaling your data by orders of
magnitude or using logarithmic transforms before plotting them. Or
experiment with image size and graph offset.

   *Style options:* You can also specify certain graphing style options
for each dataset by passing an optional final string argument to setData()
with a concatenated list of selections from each of the following groups:

     BLACK           SOLIDLINE            POINTS
     red		    dashedline           nopoints
     green 	    noline
     blue

   The capitalized options in each group are the default for that group.
If you do not specify any options, you will get black solid lines
connecting successive data points with dots at each data point
('black_solidline_points'). If you want a red scatter plot (red dots but
no lines) you could specify either

     $p->setData (\@data, 'redNOLINE');
     $p->setData (\@xdata, \@ydata, 'Points Noline Red');

   Options are detected by a simple regexp match, so order does not matter
in the option string, options are not case sensitive and extraneous
characters between options are ignored. There is no harm in specifying a
default. There is also no error checking.

Obtain current graph boundaries: getBounds()
--------------------------------------------

     my ($xmin, $ymin, $xmax, $ymax) = $img->getBounds;

   This method returns the data values of the lower left corner and upper
right corner of the graph, based on the datasets so far set.  If you have
only positive data, then $xmin and $ymin will be 0. The upper values will
typically not be the data maxima, since axis tick ranges are usually a
little beyond the range of the data.  If you add another dataset, these
values may become inaccurate, so you will need to call the method again.
As an example, I use this to draw a least squares regression line (using
Statistics::OLS) through a scatter plot of the data, running from the
edges of the graph rather than from the bounds of the data.

Graph-wide options: setGraphOptions()
-------------------------------------

     $img->setGraphOptions ('title' => 'My Graph Title',
     		         'horAxisLabel' => 'my X label',
     		         'vertAxisLabel' => 'my Y label'
     			 'horGraphOffset' => $numHorPixels,
     	                 'vertGraphOffset' => $numvertPixels);

     my %xTickLabels = qw (1 One o'clock 2 Two o'clock 3 Three o'clock);
     my %yTickLabels = qw (1 Jan 2 Feb 3 Mar);
     $img->setGraphOptions ('xTickLabels' => \%xTickLabels,
                            'yTickLabels' => \%yTickLabels)
        or die ($img->error);

   This method and each of its arguments are optional.  You can call it
with one, some or all options, or you can call it repeatedly to set or
change options. This method will also accept a hash.

   In the current version, Chart::Plot is a little smarter about placement
of text, but is still not likely to satisfy everyone, If you are not
constructing images on the fly, you might consider leaving these blank and
using a paint program to add text by hand. Or place descriptive text in a
caption outside the image.

   Titles and Axis labels are blank, by default. The title will be
centered in the margin space below the graph. A little extra vertical
offset space (the margin between the edges of the graph proper and the
image) is added to allow room. There is no support for multi-line strings.
You can specify empty strings for one or the other of the axis labels.
The vertical label will be centered or left justified above the vertical
axis; the horizontal label will be placed below the end of the horizontal
axis, centered or right justified.

   By default, the graph will be centered within the image, with 50 pixels
offset distance from its edges to the edges of the image (though a title
will increase the vertical offset). Axis and tick labels and the title
will appear in this margin (assuming all data are positive). You can
obtain more space for a title or a horizontal label by increasing the
image size (method new() ) and adjusting the offset.

   *Custom Tick Labels:* Normally, Chart::Plot will draw five to ten ticks
on each axis and label them with their corresponding data values. You can
override this and supply your own custom tick labels to either axis in a
hash reference, in which the axis position (eg, the axis data coordinate)
is the key and the label at that distance along the axis is its value.  If
a key is not a number, an error message is set to the effect that a tick
label is non-numeric. If you supply an empty hash reference, all ticks
will be suppressed.

Draw the image: draw()
----------------------

     $img->draw();
     $img->draw('jpeg') or die "$img->error()";

   This method draws the image and returns it as a string, which you can
print to a file or to STDOUT. (This should be the last method called from
the $img object.)  You will generally need to know which image format your
version of GD supports: if it supports png, then to save the image in a
file:

     open (WR,'>plot.png') or die ("Failed to write file: $!");
     binmode WR;            # for DOSish platforms
     print WR $img->draw();
     close WR;

   Or, to return the graph from a cgi script:

     print "Content-type: image/png\n\n";
     print  $img->draw();

   Or, to pipe it to a viewing program which accepts STDIN (such as xv on
Unix)

     open (VIEWER,'| /usr/X11R6/bin/xv -') or die ("Failed to open viewer: $!");
     print VIEWER $img->draw();
     close VIEWER;

   Of course, if you have a version of GD which supports only gif, change
the file names and types to gif.  GD version 1.19 and below supported only
gif image format. Versions between 1.20 and 1.26 support only png format.
If you are not sure, or suspect the supported formats may change in the
future, you can use

     $extension = $img->image_type();
     open (WR,">plot.$extension");

   to obtain the type, 'png' or 'gif'. Often, you must know the type to
write the correct file extension or to return the correct content type
from a cgi script.

   GD version 1.27 supports both png and jpeg image formats. For this
version, draw() will default to 'png' unless you supply 'jpeg' as the
argument.  `image_type()' will return 'png' in scalar context and the list
of all supported formats `(png,jpeg)' in array context.

   If the argument to draw() is not a supported image format by the local
version of GD, draw() will return undef and an error message will be set.
error() will return 'The image format ... is not supported by this version
... of GD.'

Accessing the GD object directly
--------------------------------

   Chart::Plot is a front end to GD and creates an internal GD object. You
can access the GD object directly, to use GD methods to draw on it in ways
that Chart::Plot does not anticipate. The `getGDobject()' method in
Chart::Plot returns the object reference to its internal GD object.

     my $GDobject = $img->getGDobject();
     my ($GDobject, $black, $white, $red, $green, $blue)
         = $img->getGDObject();

   In scalar context, this method returns only the reference to the GD
object. It can also return a list containing the reference to the image
object and the colors already created by Chart::Plot for that GD onject,
in the order specified above.  If you do not obtain these colors, you will
need to allocate your own colors before drawing, example below.

   When you call the draw() method of Chart::Plot (typically the last step
in your script) any drawing you have done in your script with GD on the GD
object will also be drawn.

   Since Chart::Plot works with data values and GD works with pixel
values, you will need the `data2pxl()' method of Chart::Plot to translate
(x,y) pairs of data values to (px,py) pairs of pixel values. (You call
this method on the Chart::Plot object, not the GD object.) You must call
this method only after all datasets have been registered with the
setData() method, since the graph scaling and this translation may change
with each new dataset.

   Here is a brief example which draws small blue circles around each data
point in the chart.

     use Chart::Plot;
     my $img = Chart::Plot->new;
     my @data = qw( 10 11 11 12 12 13 13 14 14 15);
     $img->setData (\@data);
     
     # draw circles around each data point, diameter 15 pixels
     my $gd = $img->getGDobject;
     my $blue = $gd->colorAllocate(0,0,255); # or use $img's blue
     my ($px,$py);
     for (my $i=0; $i<$#data; $i+=2) {
       ($px,$py) = $img->data2pxl ($data[$i], $data[$i+1]);
       $gd->arc($px,$py,15,15,0,360,$blue);
     }

     # draw the rest of the chart, and print it
     open (OUT,">plot.gif");
     binmode OUT;
     print OUT $img->draw();
     close OUT;


BUGS AND TO DO
==============

   If your data is bunched tightly but far away from the origin, then you
will obtain a better chart if the graph is clipped away from the origin. I
have not yet found a useful way to do this, but I am still thinking. You
may be able to use Custom Tick Labels to improve your chart in the
meantime.

   You will probably be unhappy with axis tick labels running together if
you use scientific notation.  Controlling tick label formatting and length
for scientific notation seems doable but challenging.

   Future versions might incorporate a legend, control of font size, word
wrap and dynamic adjustment of axis labels and title. Better code, a
better pod page.

AUTHOR
======

   Copyright (c) 1998-2000 by Sanford Morton <smorton@pobox.com>  All
rights reserved.  This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.

   This work is dedicated to the memory of Dr. Andrew Morton, who
requested it.  *Requiescat in pace*, my friend.

SEE ALSO
========

   GD::Graph(1) (formerly GIFgraph(1)) and Chart(1) are other front end
modules to GD(1). All can be found on CPAN.


File: pm.info,  Node: Chart/ThreeD/Pie,  Next: Chart/XMGR,  Prev: Chart/Plot,  Up: Module List

3D Piechart
***********

NAME
====

   Pie.pm - 3D Piechart

SYNOPSIS
========

     use Chart::ThreeD::Pie;

     # create a new pie
     my $pie = new Chart::ThreeD::Pie (500, 300, "title");

     # add data
     $pie->add (160, '#FFAA00', 'part 1');
     $pie->add (350, '#00FF66', 'part 2');
     $pie->add (100, '#AA00FF', 'part 3');
     $pie->add (300, '#0000FF', 'part 4');
     $pie->add (300, '#DD00FF', 'part 5');
     $pie->add (300, '#00DDFF', 'part 6');

     # add a percentage after each label part.
     $pie->percents (1);

     # only draw parts greater or equal to 3%. All other parts will be
     # concatenated in to a part called "others" (using red color)
     $pie->limit (2, '#FF0000', 'others');

     # thickness of the pie
     $pie->thickness (30);

     # sort the "parts"
     $pie->want_sort (1);

     # foreground and background colors
     $pie->fgcolor ('#FF0000');
     $pie->bgcolor ('#00FFFF');

     # add a border
     $pie->border (1);

     # make sure we are writing to a binary stream
     binmode STDOUT;

     # Draw the pie, Convert the image to GIF and print it on standard output
     print $pie->plot->gif;

DESCRIPTION
===========

     Chart::ThreeD::Pie allows you to create 3D Piecharts very easily
     and emit the drawings as GIF files. You can customize almost everything
     using a large number of methods.

     This module requires the Lincoln D. Stein's GD module available on CPAN.

Method Calls
============

Creating Pie
------------

new
     `Chart::ThreeD::Pie::new(width, height, title)' *class method*

     To create a new pie, send a new() message to the Chart::ThreeD::Pie
     class.  For example:

          $pie = new Chart::ThreeD::Pie (450, 320, 'my title');

     This will create an image that is 450 x 320 pixels wide.  If you don't
     specify the dimensions, a default of 400 x 300 will be chosen. The
     default title is an empty string (no title). The three parameters can
     be changed using the corresponding methods specified bellow.

Commands
--------

`thickness'
     `Chart::ThreeD::Pie::thickness(val)' *object method*

     This allows you to set the thickness (in pixel) of the pie if val is
     defined. The current value is returned. Default value is 30 pixels.

     Example:

          print "Current thickness is ", $pie->thickness, " pixels\n";
          # set it to 20.
          $pie->thickness(20);

`want_sort'
     `Chart::ThreeD::Pie::thickness(bool)' *object method*

     This will allow you to sort the parts of the pie if bool is non-null.
     The current value is returned. Default is null;

     Example:

          print "Current want_sort value is ", $pie->want_sort, "\n";
          # set it to true
          $pie->want_sort(1);

transparent
     `Chart::ThreeD::Pie::transparent(bool)' *object method*

     This will allow you to make the background of the final picture
     transparent if bool is non-null. The current value is returned.
     Default is null;

     Example:

          # Background will be transparent.
          $pie->transparent(1);

interlaced
     `Chart::ThreeD::Pie::interlaced(bool)' *object method*

     This will allow you to make the background of the final picture
     interlaced if bool is non-null. The current value is returned.
     Default is null;

     Example:

          # Picture will be interlaced
          $pie->interlaced(1);

`percents'
     `Chart::ThreeD::Pie::percents(bool)' *object method*

     This will add percentages after the label of each part of the pie if
     bool is non-null. The current value is returned. Default is null;

     Example:

          # add percents in labels
          $pie->percents(1);

bgcolor
     `Chart::ThreeD::Pie::bgcolor(bgcolor)' *object method*

     Set the background color if bgcolor is defined. The current value is
     returned. Default value is '#000000' (black). Color is a string
     composed of a '#' followed by 3 two-digits hexadecimal values,
     respectively Red, Green and Blue.

     Example:

          # set the background color to yellow
          $pie->bgcolor ('#FFFF00');

`fgcolor'
     `Chart::ThreeD::Pie::fgcolor(fgcolor)' *object method*

     Set the foreground color if fgcolor is defined. The current value is
     returned. Default value is '#000000' (black). Color is a string
     composed of a '#' followed by 3 two-digits hexadecimal values,
     respectively Red, Green and Blue.

     Example:

          # set the foreground color to red
          $pie->fgcolor ('#FF0000');

border
     `Chart::ThreeD::Pie::border(bool)' *object method*

     This will allow you to add a border to the final picture if bool is
     non-null.  The current value is returned. Default is null. The color
     of the boder is specified by fgcolor.

     Example:

          # Want a border
          $pie->border(1);

limit
     `Chart::ThreeD::Pie::limit(val, color, label)' *object method*

     This allows you to set the size (in percent) of the smallest part of
     the pie that will be drawn. All other parts will be merged into a
     single part labeled by 'label' and using the color 'color'. If 'val'
     is null, all parts are drawn. Default values are  7, '#FF0000' and
     'others'. Current values are returned.

`radius'
     `Chart::ThreeD::Pie::radius(rad)' *object method*

     Specify the radius of the pie in pixels if rad is non-null. The
     current value is returned. The default value is a third of the xmax
     value given to the creation of the pie (first parameter of the
     constructor).

     Example:

          # set radius to 100.
          $pie->radius(100);

`xmax'
     `Chart::ThreeD::Pie::xmax(val)' *object method*

     This allows you to set the length (in pixel) of the pie if val is
     defined. The current value is returned.

     Example:

          print "Current length is ", $pie->xmax, " pixels\n";
          # set it to 600.
          $pie->xmax(600);

`ymax'
     `Chart::ThreeD::Pie::ymax(val)' *object method*

     This allows you to set the width (in pixel) of the pie if val is
     defined. The current value is returned.

     Example:

          print "Current width is ", $pie->ymax, " pixels\n";
          # set it to 500.
          $pie->ymax(500);

title
     `Chart::ThreeD::Pie::title(val)' *object method*

     This allows you to change the title of the pie if val is defined.
     The current value is returned.

     Example:

          print "Current title is '", $pie->title, "'\n";
          # set it to 'my own title'.
          $pie->title('my own title');

add
     `Chart::ThreeD::Pie::add(val, color, label)' *object method*

     This method adds a part to a pie. The size of the part is specified
     by val.  Both color and label are optional. The default color is
     '#DDDDDD' and the default label is ".

plot
     `Chart::ThreeD::Pie::plot()' *object method*

     Draw the pie. This method returns a GD object (see *Note GD: GD,).

gif
     `Chart::ThreeD::Pie::gif()' *object method*

     This returns the image data in GIF format.  You can then print it,
     pipe it to a display program, or write it to a file. You MUST call
     the plot() method at least once before calling gif().

     Example:

          $pie->plot;
          open (PIPE, "| xv -") || die "Error: $!";
          binmode PIPE;
          print PIPE $pie->gif;
          close PIPE;

SEE ALSO
========

   *Note Perl: (perl.info)perl,, *Note GD: GD,

AUTHOR
======

   Fabien Tassin (fta@oleane.net)

COPYRIGHT
=========

   Copyright 1998, 1999, Fabien Tassin. All rights reserved.  It may be
used and modified freely, but I do request that this copyright notice
remain attached to the file. You may modify this module as you wish, but
if you redistribute a modified version, please attach a note listing the
modifications you have made.


File: pm.info,  Node: Chart/XMGR,  Next: Chatbot/Eliza,  Prev: Chart/ThreeD/Pie,  Up: Module List

object for displaying data via XMGR
***********************************

NAME
====

   Chart::XMGR - object for displaying data via XMGR

SYNOPSIS
========

     use Chart::XMGR;

     xmgr($a, { SYMBOL => 'plus'};

     use Chart::XMGR ();

     $xmgr = new Chart::XMGR;
     $xmgr->line($pdl);

     $pdl->$xmgr->line;

     xmgr($pdl, { LINESTYLE => 'dotted' });

DESCRIPTION
===========

   Provides a perl/PDL interface to the XMGR plotting package.  Can be
used to plot PDLs or Perl arrays.

   A simple function interface is provided that is based on the more
complete object-oriented interface.

   The interface can be implemented using either anonymous pipes or named
pipes (governed by the module variable Chart::XMGR::NPIPE).  If named
pipes are used ($NPIPE = 1) XMGR can be controlled via the pipe and
buttons are available for use in XMGR. If an anonymous pipe is used XMGR
will not accept button events until the pipe has been closed.

   Currently the named pipe option can not support data sets containing 3
or more columns (I haven't worked out how to do it anyway!).  This means
that only TYPE XY is supported. For anonymouse pipe 3 or more columns can
be supplied along with the graph type.

   The default option is to use the named pipe.

OPTIONS
=======

   The following drawing options are available: The options are
case-insensitive and minimum match.

LINESTYLE
     Controls the linestyle. Allowed values are none(0), solid(1),
     dotted(2), dashed(3), dotdash(4). Default is solid.

LINECOLOUR
     Controls the line colour. LINECOLOR is an allowed synonym.  Allowed
     values are white, black, red, green, blue, yellow, brown, gray,
     violet, cyan, magenta, orange, indigo, maroon, turqse and green4
     (plus numeric equivalents: 0 to 15).  Default is black.

LINEWIDTH
     Width of the line. Default is 1.

FILL
     Governs whether the area inside the line is filled.  Default is none.

SYMBOL
     Governs symbol type. 46 different types are supported (see XMGR
     options for the mapping to symbol type). Basic symbol types are
     available by name: none, dot, circle, square, diamond, triangleup,
     triangleleft, triangledown, triangleright, triangledown,
     triangleright, plus, X, star. Default is circle.

SYMCOLOUR
     Colour of symbol. See LINECOLOUR for description of available values.
     Default is red.

SYMSIZE
     Symbol size. Default is 1.

SYMFILL
     Governs whether symbols are filled (1), opaque (0) or have no fill
     (none(0)). Default is filled.

AUTOSCALE
     Set whether to autoscale as soon as set is drawn. Default is true.

SETTYPE
     Type of data set. Allowed values as for XMGR: XY, XYDX, XYDY, XYDXDX,
     XYDYDY, XYDXDY, XYZ, XYRT.

NON-OO INTERFACE
================

   A simplified non-object oriented interface is provided.  These routines
are exported into the callers namespace by default.

xmgr( args, { options } )
     A simplified interface to plotting on Xmgr.

xmgrset(set)
     Select the current set (integer 0->).

xmgrdetach
     Detach XMGR from the pipe. This returns control of XMGR to the user.

xmgrprint(string)
     Print arbritrary commands to XMGR. The @ symbol is prepended to all
     commands and a newline is appended.

METHODS
=======

   The following methods are available.

new()
     Constructor. Is used to launch the new XMGR process and returns the
     object.

pipe
     Return file handle (of type IO::Pipe) associated with external XMGR
     process.

opt()
     Return options object associated with XMGR object.

npipe()
     Returns name of pipe associated with object.

attached()
     Returns whether an XMGR process is currently attached to the object.
     Can also be used to set the state.

set()
     Returns (or sets) the current set.

graph()
     Returns (or sets) the current graph.

debug()
     Turns the debug flag on or off. If on (1) all commands sent to XMGR
     are also printed to STDOUT.

     Default is false.

prt(text)
     Method to prt Xmgr commands to the attached XMGR process.  Carriage
     returns are appended. '@' symbols are prepended where necessary
     (needed for anonymous pipes, not for named pipes).

prt_data (data)
     Print numbers to the pipe. No @ symbol is prepended.  For named pipes
     we must use the POINT command.  For anonymous pipes the data is just
     sent as is (so multiple column can be supplied).

select_graph
     Selects the current graph in XMGR.

plot($pdl, $pdl2, ..., $hash)
     Method to plot XY data. Multiple arguments are allowed (in addition
     to the options hash). This routine plots the supplied data as the
     currently selected set on the current graph.

     The interpretation of each input argument depends on the set type
     (specified as an option: SETTYPE). For example, 3 columns can be
     translated as XYDY, XYDX or XYZ. No check is made that the number of
     arguments matches the selected type.

     Array references can be substituted for PDLs.

     The options hash is assumed to be the last argument.

          $xmgr->plot(\@x, \@y, { LINECOL => 'red' } );
          $xmgr->plot($pdl);

send_options(hashref)
     Process the options hash and send to XMGR.  This sends the options
     for the current set.

redraw()
     Forces XMGR to redraw.

killset([setnum])
     Kill a set.  If no argument is specified the current set is killed;
     else the specified set (integer greater than or equal to 0) is killed.

autoscale()
     Instruct XMGR to autoscale.

autoscale_on([set])
     Autscale on the specified set (default to current set).

world(xmin, xmax, ymin, ymax)
     Set the world coordinates.

viewport(xmin, xmax, ymin, ymax)
     Set the current graphs viewport (where the current graphi is
     displayed).

graphtype(type)
     Set the graphtype. Allowed values are: 'XY', 'BAR', 'HBAR',
     'STACKEDBAR', 'STACKEDHBAR', 'LOGX', 'LOGY', 'LOGXY', 'POLAR', 'SMITH'

configure(hash)
     Configure the current set.

          $xmgr->configure(SYMBOL=>1, LINECOLOUR=>'red');

detach()
     Close the pipe without asking XMGR to die.  This can be used if you
     want to leave XMGR running after the object is destroyed. Note that
     no more messages can be sent to the XMGR process associated with this
     object.

DESTROY
     Destructor for object. Sends the 'exit' message to the XMGR process.
     This will fail silently if the pipe is no longer open. (eg if the
     detach() method has been called.

EXAMPLE
=======

   An example program may look like this:

     use Chart::XMGR;
     use PDL;

     $a = pdl( 1,4,2,6,5);
     $xmgr = new Chart::XMGR;
     $xmgr->plot($a, { SYMBOL => 3,
                       LINECOL => 'red',
                       LINESTYLE => 2
                       SYMSIZE => 1 }
                 );

     $xmgr->configure(SYMCOL => 'green');
     $xmgr->detach;

   If PDL is not available, then arrays can be used:

     use Chart::XMGR
     
     @a = ( 1,4,2,6,5 );
     $xmgr = new Chart::XMGR;
     $xmgr->plot(\@a, { SYMBOL => 3,
                       LINECOL => 'red',
                       LINESTYLE => 2
                       SYMSIZE => 1 }
                 );

     $xmgr->configure(SYMCOL => 'green');
     $xmgr->detach;

XMGR (Grace)
============

   The XMGR home page is at http://plasma-gate.weizmann.ac.il/Xmgr/ This
modules is designed to be used with XMGR version 4 (tested on v4.1.2).
This module will probably not work with GRACE (XMGR version 5).

REQUIREMENTS
============

   The PDL::Options module is required. This is available as part of the
PDL distribution (http://pdl.perl.org) or separately in the PDL directory
on CPAN.

NOTES
=====

   For versions 0.90 and earlier this module was known by the name
Graphics::XMGR (not on CPAN).

AUTHOR
======

   Copyright (C) Tim Jenness 1998,1999 (t.jenness@jach.hawaii.edu).  All
rights reserved. This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.


File: pm.info,  Node: Chatbot/Eliza,  Next: Chemistry/Elements,  Prev: Chart/XMGR,  Up: Module List

A clone of the classic Eliza program
************************************

NAME
====

   *Chatbot::Eliza* - A clone of the classic Eliza program

SYNOPSIS
========

     use Chatbot::Eliza;
     # see below for details

DESCRIPTION
===========

   This module implements the classic Eliza algorithm.  The original Eliza
program was written by Joseph Weizenbaum and described in the
Communications of the ACM in 1966.  Eliza is a mock Rogerian
psychotherapist.  It prompts for user input, and uses a simple
transformation algorithm to change user input into a follow-up question.
The program is designed to give the appearance of understanding.

   This program is a faithful implementation of the program described by
Weizenbaum.  It uses a simplified script language (devised by Charles
Hayden).  The content of the script is the same as Weizenbaum's.

   This module encapsulates the Eliza algorithm in the form of an object.
This should make the functionality easy to incorporate in larger programs.

   The current version of Chatbot::Eliza.pm is available on CPAN:

     http://www.perl.com/CPAN/modules/by-module/Chatbot/

INSTALLATION
============

   To install this package, just change to the directory which you created
by untarring the package, and type the following:

     perl Makefile.PL
     make test
     make
     make install

   This will copy Eliza.pm to your perl library directory for use by all
perl scripts.  You probably must be root to do this, unless you have
installed a personal copy of perl.

USAGE
=====

   This is all you need to do to launch a simple Eliza session:

     use Chatbot::Eliza;

     $mybot = new Chatbot::Eliza;
     $mybot->command_interface;

   You can also customize certain features of the session:

     $myotherbot = new Chatbot::Eliza;

     $myotherbot->name( "Hortense" );
     $myotherbot->debug( 1 );

     $myotherbot->command_interface;

   These lines set the name of the bot to be "Hortense" and turn on the
debugging output.

   When creating an Eliza object, you can specify a name and an
alternative scriptfile:

     $bot = new Chatbot::Eliza "Brian", "myscript.txt";

   You can also use an anonymous hash to set these parameters.  Any of the
fields can be initialized using this syntax:

     $bot = new Chatbot::Eliza {
     	name       => "Brian",
     	scriptfile => "myscript.txt",
     	debug      => 1,
     	prompts_on => 1,
     	memory_on  => 0,
     	myrand     =>
     		sub { my $N = defined $_[0] ? $_[0] : 1;  rand($N); },
     };

   If you don't specify a script file, then the Eliza module will
initialize the new Eliza object with a default script that the module
contains within itself.

   You can use any of the internal functions in a calling program.  The
code below takes an arbitrary string and retrieves the reply from the
Eliza object:

     my $string = "I have too many problems.";
     my $reply  = $mybot->transform( $string );

   You can easily create two bots, each with a different script, and see
how they interact:

     use Chatbot::Eliza

     my ($harry, $sally, $he_says, $she_says);

     $sally = new Chatbot::Eliza "Sally", "histext.txt";
     $harry = new Chatbot::Eliza "Harry", "hertext.txt";

     $he_says  = "I am sad.";

     # Seed the random number generator.
     srand( time ^ ($$ + ($$ << 15)) );

     while (1) {
     	$she_says = $sally->transform( $he_says );
     	print $sally->name, ": $she_says \n";
     
     	$he_says  = $harry->transform( $she_says );
     	print $harry->name, ": $he_says \n";
     }

   Mechanically, this works well.  However, it critically depends on the
actual script data.  Having two mock Rogerian therapists talk to each
other usually does not produce any sensible conversation, of course.

   After each call to the transform() method, the debugging output for
that transformation is stored in a variable called $debug_text.

     my $reply      = $mybot->transform( "My foot hurts" );
     my $debugging  = $mybot->debug_text;

   This feature always available, even if the instance's $debug variable
is set to 0.

   Calling programs can specify their own random-number generators.  Use
this syntax:

     $chatbot = new Chatbot::Eliza;
     $chatbot->myrand(
             sub {
                     #function goes here!
             }
     );

   The custom random function should have the same prototype as perl's
built-in rand() function.  That is, it should take a single (numeric)
expression as a parameter, and it should return a floating-point value
between 0 and that number.

   What this code actually does is pass a reference to an anonymous
subroutine ("code reference").  Make sure you've read the perlref manpage
for details on how code references actually work.

   If you don't specify any custom rand function, then the Eliza object
will just use the built-in rand() function.

MAIN DATA MEMBERS
=================

   Each Eliza object uses the following data structures to hold the script
data in memory:

%decomplist
-----------

   Hash: the set of keywords;  Values: strings containing the
decomposition rules.

%reasmblist
-----------

   Hash: a set of values which are each the join of a keyword and a
corresponding decomposition rule; Values: the set of possible reassembly
statements for that keyword and decomposition rule.

%reasmblist_for_memory
----------------------

   This structure is identical to %reasmblist, except that these rules are
only invoked when a user comment is being retrieved from memory. These
contain comments such as "Earlier you mentioned that...," which are only
appropriate for remembered comments.  Rules in the script must be
specially marked in order to be included in this list rather than
%reasmblist. The default script only has a few of these rules.

@memory
-------

   A list of user comments which an Eliza instance is remembering for
future use.  Eliza does not remember everything, only some things.  In
this implementation, Eliza will only remember comments which match a
decomposition rule which actually has reassembly rules that are marked
with the keyword "reasm_for_memory" rather than the normal "reasmb".  The
default script only has a few of these.

%keyranks
---------

   Hash: the set of keywords;  Values: the ranks for each keyword

@quit
-----

   "quit" words - that is, words the user might use to try to exit the
program.

@initial
--------

   Possible greetings for the beginning of the program.

@final
------

   Possible farewells for the end of the program.

%pre
----

   Hash: words which are replaced before any transformations; Values: the
respective replacement words.

%post
-----

   Hash: words which are replaced after the transformations and after the
reply is constructed;  Values: the respective replacement words.

%synon
------

   Hash: words which are found in decomposition rules; Values: words which
are treated just like their corresponding synonyms during matching of
decomposition rules.

Other data members
------------------

   There are several other internal data members.  Hopefully these are
sufficiently obvious that you can learn about them just by reading the
source code.

METHODS
=======

new()
-----

     my $chatterbot = new Chatbot::Eliza;

   new() creates a new Eliza object.  This method also calls the internal
_initialize() method, which in turn calls the parse_script_data() method,
which initializes the script data.

     my $chatterbot = new Chatbot::Eliza 'Ahmad', 'myfile.txt';

   The eliza object defaults to the name "Eliza", and it contains default
script data within itself.  However, using the syntax above, you can
specify an alternative name and an alternative script file.

   See the method parse_script_data(). for a description of the format of
the script file.

command_interface()
-------------------

     $chatterbot->command_interface;

   command_interface() opens an interactive session with the Eliza object,
just like the original Eliza program.

   If you want to design your own session format, then you can write your
own while loop and your own functions for prompting for and reading user
input, and use the transform() method to generate Eliza's responses.
(Note: you do not need to invoke preprocess() and postprocess() directly,
because these are invoked from within the transform() method.)

   But if you're lazy and you want to skip all that, then just use
command_interface().  It's all done for you.

   During an interactive session invoked using command_interface(), you
can enter the word "debug" to toggle debug mode on and off.  You can also
enter the keyword "memory" to invoke the _debug_memory() method and print
out the contents of the Eliza instance's memory.

preprocess()
------------

     $string = preprocess($string);

   preprocess() applies simple substitution rules to the input string.
Mostly this is to catch varieties in spelling, misspellings, contractions
and the like.

   preprocess() is called from within the transform() method.  It is
applied to user-input text, BEFORE any processing, and before a reassebly
statement has been selected.

   It uses the array %pre, which is created during the parse of the script.

postprocess()
-------------

     $string = postprocess($string);

   postprocess() applies simple substitution rules to the reassembly rule.
This is where all the "I"'s and "you"'s are exchanged.  postprocess() is
called from within the transform() function.

   It uses the array %post, created during the parse of the script.

_testquit()
-----------

     if ($self->_testquit($user_input) ) { ... }

   _testquit() detects words like "bye" and "quit" and returns true if it
finds one of them as the first word in the sentence.

   These words are listed in the script, under the keyword "quit".

_debug_memory()
---------------

     $self->_debug_memory()

   _debug_memory() is a special function which returns the contents of
Eliza's memory stack.

transform()
-----------

     $reply = $chatterbot->transform( $string, $use_memory );

   transform() applies transformation rules to the user input string.  It
invokes preprocess(), does transformations, then invokes postprocess().
It returns the tranformed output string, called `$reasmb'.

   The algorithm embedded in the transform() method has three main parts:

  1. Search the input string for a keyword.

  2. If we find a keyword, use the list of decomposition rules for that
     keyword, and pattern-match the input string against each rule.

  3. If the input string matches any of the decomposition rules, then
     randomly select one of the reassembly rules for that decomposition
     rule, and use it to construct the reply.

        transform() takes two parameters.  The first is the string we want
to transform.  The second is a flag which indicates where this sting came
from.  If the flag is set, then the string has been pulled from memory,
and we should use reassembly rules appropriate for that.  If the flag is
not set, then the string is the most recent user input, and we can use the
ordinary reassembly rules.

   The memory flag is only set when the transform() function is called
recursively.  The mechanism for setting this parameter is embedded in the
transoform method itself.  If the flag is set inappropriately, it is
ignored.

How memory is used
------------------

   An Eliza object remembers up to `$max_memory_size' (default: 5) user
input strings.  Eliza remembers any comment when it matches a
docomposition rule for which there are any reassembly rules for memory. In
the script, such reassembly rules are marked with the keyword
"reasm_for_memory".

   If the transform() method fails to find any appropriate decomposition
rule for a user's comment, and if there are any comments inside the memory
array, then Eliza may elect to ignore the most recent comment and instead
pull out one of the strings from memory.  In this case, the transform
method is called recursively with the memory flag.

   Honestly, I am not sure exactly how this memory functionality was
implemented in the original Eliza program.  Hopefully this implementation
is not too far from Weizenbaum's.

   If you don't want to use the memory functionality at all, then you can
disable it:

     $mybot->memory_on(0);

   You can also achieve the same effect by making sure that the script
data does not contain any reassembly rules marked with the keyword
"reasm_for_memory".  The default script data only has 4 such items.

parse_script_data()
-------------------

     $self->parse_script_data;
     $self->parse_script_data( $script_file );

   parse_script_data() is invoked from the _initialize() method, which is
called from the new() function.  However, you can also call this method at
any time against an already-instantiated Eliza instance.  In that case,
the new script data is added to the old script data.  The old script data
is not deleted.

   You can pass a parameter to this function, which is the name of the
script file, and it will read in and parse that file.  If you do not pass
any parameter to this method, then it will read the data embedded at the
end of the module as its default script data.

   If you pass the name of a script file to parse_script_data(), and that
file is not available for reading, then the module dies.

Format of the script file
=========================

   This module includes a default script file within itself, so it is not
necessary to explicitly specify a script file when instantiating an Eliza
object.

   Each line in the script file can specify a key, a decomposition rule,
or a reassembly rule.

     key: remember 5
       decomp: * i remember *
         reasmb: Do you often think of (2) ?
         reasmb: Does thinking of (2) bring anything else to mind ?
       decomp: * do you remember *
         reasmb: Did you think I would forget (2) ?
         reasmb: What about (2) ?
         reasmb: goto what
     pre: equivalent alike
     synon: belief feel think believe wish

   The number after the key specifies the rank.  If a user's input
contains the keyword, then the transform() function will try to match one
of the decomposition rules for that keyword.  If one matches, then it will
select one of the reassembly rules at random.  The number (2) here means
"use whatever set of words matched the second asterisk in the decomposition
rule."

   If you specify a list of synonyms for a word, the you should use a "@"
when you use that word in a decomposition rule:

     decomp: * i @belief i *
       reasmb: Do you really think so ?
       reasmb: But you are not sure you (3).

   Otherwise, the script will never check to see if there are any synonyms
for that keyword.

   Reassembly rules should be marked with *reasm_for_memory* rather than
*reasmb* when it is appropriate for use when a user's comment has been
extracted from memory.

     key: my 2
       decomp: * my *
         reasm_for_memory: Let's discuss further why your (2).
         reasm_for_memory: Earlier you said your (2).
         reasm_for_memory: But your (2).
         reasm_for_memory: Does that have anything to do with the fact that your (2) ?

How the script file is parsed
=============================

   Each line in the script file contains an "entrytype" (key, decomp,
synon) and an "entry", separated by a colon.  In turn, each "entry" can
itself be composed of a "key" and a "value", separated by a space.  The
parse_script_data() function parses each line out, and splits the "entry"
and "entrytype" portion of each line into two variables, $entry and
`$entrytype'.

   Next, it uses the string `$entrytype' to determine what sort of stuff
to expect in the $entry variable, if anything, and parses it accordingly.
In some cases, there is no second level of key-value pair, so the function
does not even bother to isolate or create $key and $value.

   $key is always a single word.  $value can be null, or one single word,
or a string composed of several words, or an array of words.

   Based on all these entries and keys and values, the function creates
two giant hashes: %decomplist, which holds the decomposition rules for
each keyword, and %reasmblist, which holds the reassembly phrases for each
decomposition rule.  It also creates %keyranks, which holds the ranks for
each key.

   Six other arrays are created: `%reasm_for_memory, %pre, %post, %synon,
@initial,' and `@final'.

AUTHOR
======

   John Nolan  jpnolan@op.net  April 1999.

   Implements the classic Eliza algorithm by Prof. Joseph Weizenbaum.
Script format devised by Charles Hayden.


