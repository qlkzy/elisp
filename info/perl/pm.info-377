This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Text/template_syntax,  Next: Thesaurus,  Prev: Text/template_extend,  Up: Module List

description of the syntax of a Text::Tmpl template.
***************************************************

NAME
====

   template_syntax - description of the syntax of a Text::Tmpl template.

SYNOPSIS
========

   In general:

   <!-#function "argument1", $argument2, "argu" $ment
"3"-><!-#endfunction->

   Specifically:

   <!-#echo "text"->

   <!-#include "file"->

   <!-#comment->This won't be printed<!-#endcomment->

   <!-#if "value"->This will be printed if "value" is "true"<!-#endif->

   <!-#ifn "value"->This will be printed if "value" is "false"<!-#endifn->

   <!-#loop "loopname"->This may be printed a bunch of times<!-#endloop->

   <!-#debug-><!-#include "debug-include.tmpl"-><!-#enddebug->

   debug-include.tmpl:

   Variables in this context: <!-#loop "variables-" $number->

   <!-#echo $variable_name-> == <!-#echo $variable_value->

   <!-#endloop->

   Named children (loops) in this context: <!-#loop "named_children-"
$number->

   <!-#loop $nc_name-> <!-#echo $nc_name->: <!-#include
"debug-include.tmpl"-> <!-#endloop->

   <!-#endloop->

DESCRIPTION
===========

   The specific tags listed above are merely the default tags in the
template library.  It is possible to add tags of your own.

   The tag format is: open_tag_delimiter (default: "<!-#") + function name
+ some whitespace + comma-separated argument list (described below) +
close_tag_delimiter (default: "->").

   Each argument in the comma-separated argument list consists of variables
and strings - everything else is ignored.  A variable looks like $foo,
where foo is any number of alphanumeric characters.  A string is anything
(including whitespace, newlines, etc...) within double-quotes.  To put
literal double quotes into a string, escape with a backslash.  For
example, the following list:

   "argument1", $argument2, "argu" $ment "3"

   would become:

   argument1, (the value of $argument2), argu(the value of $ment)3

   Tag pair nesting is possible (and infinite, at least if you have an
infinite stack...)  Also, the result of a simple tag evaluation will
actually be parsed again, so you can (for example) include another
template into the current one, and it will be parsed.

echo
     The echo tag is replaced by the concatenated string values of each of
     its arguments.

include
     The include tag is replaced by the contents of the named file.

comment / *endcomment*
     The comment/endcomment tag pair, and everything it contains, is
     replaced by nothing.

if / *endif*
     The if/endif tag pair, and everything it contains, is replaced by
     nothing or by the complete contents of the tag pair, depending on the
     "truth" of the first argument to the tag.  If the argument is true,
     the complete contents of the tag pair are output - otherwise, nothing
     is output.

ifn / *endifn*
     The ifn/endifn tag pair, and everything it contains, is replaced by
     nothing or by the complete contents of the tag pair, depending on the
     "truth" of the first argument to the tag.  If the argument is false,
     the complete contents of the tag pair are output - otherwise, nothing
     is output.

loop / *endloop*
     The loop/endloop tag pair is replaced by everything it contains,
     repeated 0 or more times.  The first argument to the loop tag is the
     name of the loop, and the number of repetitions is equal to the
     number of times that loop_iteration() was called in the current
     context with that loop name as an argument.

debug / *enddebug*
     The debug/enddebug tag pair is replaced by everything it contains.
     This pair also dumps all of the information about the parent context
     into this sub-context, so that you can see the internal state of the
     context as output.  The format for using the debug/enddebug tag pair
     is shown in the SYNOPSIS above.

BUGS
====

   Hopefully none.

AUTHOR
======

   J. David Lowe, dlowe@pootpoot.com

SEE ALSO
========

   libtmpl(1), Text::Tmpl(1), template_extend(1)


File: pm.info,  Node: Thesaurus,  Next: Thesaurus/DBI,  Prev: Text/template_syntax,  Up: Module List

David Rolsky (grimes@waste.org)
*******************************

NAME
====

   Thesaurus - David Rolsky (grimes@waste.org)

SYNOPSIS
========

     use Thesaurus;

     $th = new Thesaurus( -files => ['file1', 'file2'],
     		      -ignore_case => 1 );

     @words = $th->find('vegan');

     %words = $th->find('animal', 'liberation');

     foreach $word ( @{ $words{animal} } )
     {
         #something ...
     }

     $th->add_file('file1', 'file2');

     $th->add('tofu', 'alternative methodologies');

     $th->delete('meat', 'vivisection');

DESCRIPTION
===========

   Thesaurus is a module that allows you to create lists of related
things.  It was created in order to facilitate searches of a database of
Chinese names in Anglicized form.  Because there are various schemes to
create phonetic representations of Chinese words, the following can all
represent the same Chinese character:

     Woo
     Wu
     Ng

   Thesaurus can be used for anything that fits into a scalar by using the
new method with no parameters and then calling the add method to add data.

   Thesaurus also acts as the parent class to several child classes which
implement various forms of persistence for the data structure.  This
module can be used on its own to instantiate an object that lives for the
life of its scope.

METHODS
=======

   * new(%params)
          $th = Thesaurus->new(%params);

     The new method returns a Thesaurus object.

     Parameters:

   * ignore_case (0 or 1) - A boolean parameter.  If true, then the object
     will be case insensitive.  It is _always_ case-preservative for its
     data.

   * find(@items);
          @words = $th->find('Big Hat');
          %words = $th->find('Big Hat', 'Faye Wong');

     The find method returns either a list or a hash, depending on
     context.  Given a single word to find, it returns the list of words
     that it is associated with, including the word that was given.  If no
     matches  are found then it returns an empty list.

     If it is given multiple words, it returns a hash.  The keys of the has
     are the words given, and the keys are list references containing the
     associated words.  If no words were found then the key has a value of
     0.  If none of the words match then an empty list is returned.

   * add(\@list1, \@list2)
          $th->add(\@related1, \@related2);

     The add method takes a list of list references.  Each of these
     references should contain a set of associated scalars.  Like the add
     files method, if an entry in the files matches an entry already in
     the object, then it is appended to the existing list, otherwise a new
     entry is created.

   * delete(@items)
          $th->delete($element);

     The delete method takes a list of items to delete.  All the
     associations for the given items will be removed.

   * dump
          @list_refs = $th->dump;

     Returns a list of list references.  Each one of these list references
     contains one set of associations.  Each association list is returned
     once (not once per item).

AUTHOR
======

   Dave Rolsky, <autarch@urth.org>

SEE ALSO
========

   Thesaurus::File, Thesaurus::DBM, Thesaurus::DBI

COPYRIGHT
=========

   Copyright (c) 1999 David Rolsky. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Thesaurus/DBI,  Next: Thesaurus/DBM,  Prev: Thesaurus,  Up: Module List

Subclass of Thesaurus that creates data structure in a database.
****************************************************************

NAME
====

   Thesaurus::DBI - Subclass of Thesaurus that creates data structure in a
database.

SYNOPSIS
========

     use Thesaurus::DBI;

     my $thesaurus = Thesaurus::DBI( ignore_case => 1,
                                     configuration => 'myconfig',
                                     dbh => $dbh );

DESCRIPTION
===========

   This subclass of Thesaurus creates and maintains its data structure
inside a database.  Use the thesaurus_dbi_config.pl script to create a
configuration for Thesaurus::DBI.  This script creates and/or modifies the
Thesaurus::DBI::Config module, which contains configuration data for your
particular setup.  You can create and maintain multiple

   THIS SUBCLASS HAS NOT YET BEEN IMPLEMENTED!

METHODS
=======

   * new(%params)

     This method returns a new Thesaurus::DBI object using the specified
     configuration.

     This method takes the following parameters:

   * ignore_case (0 or 1) - A boolean parameter.  If true, then the object
     will be case insensitive.  It is _always_ case-preservative for its
     data.

   * configuration ($) - The name that identifies the configuration you
     want to use.  This was specified in the thesaurus_dbi_config.pl
     script.

   * dbh ($) - This is an optional parameter which should be an open
     database handle.  If this is not given then Thesaurus::DBI will
     attempt to open a database handle based on information specified by
     the configuration name.  However, you may not wish to store the
     information necessary to open these handles (such as a password) in
     the Thesaurus::DBI::Config module (which stores it in plaintext).  If
     this parameter is given, then Thesaurus::DBI will not attempt to make
     a database handle.

AUTHOR
======

   Dave Rolsky, <autarch@urth.org>

SEE ALSO
========

   Thesaurus, Thesaurus::File, Thesaurus::DBM


File: pm.info,  Node: Thesaurus/DBM,  Next: Thesaurus/File,  Prev: Thesaurus/DBI,  Up: Module List

Subclass of Thesaurus that ties data structure to DBM file.
***********************************************************

NAME
====

   Thesaurus::DBM - Subclass of Thesaurus that ties data structure to DBM
file.

SYNOPSIS
========

     use Thesaurus qw(DB_File Storable);

     my $book = Thesaurus->new( ignore_case => 1,
                                filename => $filename,
                                flags => $flags,
                                mode => $mode,
                                extra => \@more_params );

DESCRIPTION
===========

   This subclass of Thesaurus implements a tied interface to a DBM file on
disk, allowing persistence.

use Thesaurus::DBM (@params)
============================

   Thesaurus::DBM takes the same parameters as MLDBM.  The most important
are the first two, which are the DBM file module to use and the
serialization module to use.  See the MLDBM documentation for more details.

   Thesaurus::DBM will not work with SDBM_File, NDBM_File, or ODBM_File
because they doe not support exists on tied hashes.  I believe that this
is fixed in Perl 5.6 (at least for SDBM_File).

   Thesaurus::DBM now supports locking.  When locking is enabled all
operations are atomic.

METHODS
=======

   * new( %params );

     This method returns a new Thesaurus::DBM object tied to a DBM file as
     defined by the parameters passed to this method.

     This method takes the following parameters:

   * ignore_case (0 or 1) - A boolean parameter.  If true, then the object
     will be case insensitive.  It is _always_ case-preservative for its
     data.

   * filename ($) - The DBM filename.

   * flags ($) - Flags passed to the appropriate DBM module.

   * mode ($) - Mode passed to the appropriate DBM module.

   * extra (\@) - Anything passed to this parameter will be passed to the
     DBM module as an additional argument.

     For the BerkeleyDB module, and others that don't follow the
     AnyDBM_File module syntax, just put all the parameters in extra and
     Thesaurus::DBM will handle this appropriately.

   * locking ($) - A true or false value indicating whether or not you
     wish the object to attempt to get a lock for reading and writing to
     the DBM file.  Locking is safer but slower.  The default is to enable
     locking.

   * lock_wait ($) - How long, in seconds, to wait for a lock.  The
     default is 2 seconds.

   All other methods are indentical to Thesaurus.

AUTHOR
======

   Dave Rolsky, <autarch@urth.org>

SEE ALSO
========

   Thesaurus, Thesaurus::File, Thesaurus::DBI, MLDBM, DB_File, GDBM_File

COPYRIGHT
=========

   Copyright (c) 1999 David Rolsky. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Thesaurus/File,  Next: Thread/Pool,  Prev: Thesaurus/DBM,  Up: Module List

Subclass of Thesaurus that implements persistence using CSV format text files.
******************************************************************************

NAME
====

   Thesaurus::File - Subclass of Thesaurus that implements persistence
using CSV format text files.

SYNOPSIS
========

     use Thesaurus::File;

     my $book = Thesaurus->new( ignore_case => 1,
                                files => ['file1.csv', 'file2.csv'] );

DESCRIPTION
===========

   This subclass of Thesaurus implements persistence through the use of
CSV format text files.

METHODS
=======

   * add_files
          $th->add_files($filename1, $filenam2, ...);

     This method adds the contents of the given files to the thesaurus
     object.  If an entry in the files matches an entry already in the
     object, then it is appended to the existing list, otherwise a new
     entry is created.

   * save(%params)

     Writes the contents of the object to a CSV format file.  It takes the
     following named parameters:

   * filename ($) - The filename where the data will be written.

   * mode ($) - This determines whether to write or append the data.  This
     should be a string ('write' or 'append').

AUTHOR
======

   Dave Rolsky, <autarch@urth.org>

SEE ALSO
========

   Thesaurus, Thesaurus::DBM, Thesaurus::DBI

COPYRIGHT
=========

   Copyright (c) 1999 David Rolsky. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Thread/Pool,  Next: Tie/Array,  Prev: Thesaurus/File,  Up: Module List

worker thread pools to run Perl code asynchronously
***************************************************

NAME
====

   Thread::Pool - worker thread pools to run Perl code asynchronously

SYNOPSIS
========

     use Thread::Pool;
     my $pool = Thread::Pool->new(Min => 5, Max => 10);
     $pool->enqueue(\&foo, @args);
     $pool->set_min(7);
     $pool->set_max(20);

DESCRIPTION
===========

   The Thread::Pool module implements pools of worker threads. Once a
thread pool is created, jobs (i.e. Perl subs with arguments) may be
enqueued for the pool to execute. When a thread in the pool becomes free,
it takes another job from the pool's work queue and calls it.  If a job is
enqueued while no thread is free and the number of active threads does not
exceed a given maximum, a new thread is added to the pool immediately to
hande the new job. A pool can be configured to have a minimum number of
threads which are always running and waiting for jobs to carry out. A pool
can be configured to have a maximum number of threads - only that number
of threads will ever be created in the pool and new jobs have to wait
until an existing worker thread becomes free.

METHODS
=======

new
     Create a new thread pool. Arguments are optional and are of the form
     of key/value pairs. Passing `Min => $min' invokes `set_min($min)'
     (q.v.) for the pool. The default min value is zero. Passing `Max =>
     $max' invokes `set_max($max)' (q.v.) for the pool. The default max
     value is -1.

enqueue(CODE [, ARG, ...])
     Enqueues a new job for the pool to carry out. CODE can be a reference
     to a subroutine or the name of one. Unqualified subroutine names
     default to the caller's package. The subroutine will be called
     (optionally with any given arguments) in one of the worker threads in
     the pool either immediately (if the number of active threads in the
     pool has not reached its configured maximum) or when a thread becomes
     free (if it has reached its maximum).

set_min(MIN)
     Sets the minimum number of threads in the pool to MIN. If MIN is
     increased then more threads are immediately created in the pool to
     bring the number up to MIN. When the queue of jobs for the pool is
     emptied, MIN worker threads will wait around for more work rather
     than finishing.

set_max(MAX)
     Sets the maximum number of threads in the pool to MAX meaning that no
     more than MAX threads will ever be running concurrently for that pool.
     If MAX is -1 then the limit is infinite. That means that if a new job
     is enqueued while all threads are active, a new thread is always
     created immediately to handle the job.

SEE ALSO
========

   `Thread' in this node

AUTHOR
======

   Malcolm Beattie, mbeattie@sable.ox.ac.uk.


File: pm.info,  Node: Tie/Array,  Next: Tie/CArray,  Prev: Thread/Pool,  Up: Module List

base class for tied arrays
**************************

NAME
====

   Tie::Array - base class for tied arrays

SYNOPSIS
========

     package NewArray;
     use Tie::Array;
     @ISA = ('Tie::Array');

     # mandatory methods
     sub TIEARRAY { ... }
     sub FETCH { ... }
     sub FETCHSIZE { ... }

     sub STORE { ... }        # mandatory if elements writeable
     sub STORESIZE { ... }    # mandatory if elements can be added/deleted
     sub EXISTS { ... }       # mandatory if exists() expected to work
     sub DELETE { ... }       # mandatory if delete() expected to work

     # optional methods - for efficiency
     sub CLEAR { ... }
     sub PUSH { ... }
     sub POP { ... }
     sub SHIFT { ... }
     sub UNSHIFT { ... }
     sub SPLICE { ... }
     sub EXTEND { ... }
     sub DESTROY { ... }

     package NewStdArray;
     use Tie::Array;

     @ISA = ('Tie::StdArray');

     # all methods provided by default

     package main;

     $object = tie @somearray,Tie::NewArray;
     $object = tie @somearray,Tie::StdArray;
     $object = tie @somearray,Tie::NewStdArray;

DESCRIPTION
===========

   This module provides methods for array-tying classes. See *Note
Perltie: (perl.info)perltie, for a list of the functions required in order
to tie an array to a package. The basic Tie::Array package provides stub
DESTROY, and EXTEND methods that do nothing, stub DELETE and EXISTS
methods that croak() if the delete() or exists() builtins are ever called
on the tied array, and implementations of PUSH, POP, SHIFT, UNSHIFT,
SPLICE and CLEAR in terms of basic FETCH, STORE, FETCHSIZE, STORESIZE.

   The *Tie::StdArray* package provides efficient methods required for
tied arrays which are implemented as blessed references to an "inner" perl
array.  It inherits from Tie::Array, and should cause tied arrays to
behave exactly like standard arrays, allowing for selective overloading of
methods.

   For developers wishing to write their own tied arrays, the required
methods are briefly defined below. See the *Note Perltie:
(perl.info)perltie, section for more detailed descriptive, as well as
example code:

TIEARRAY classname, LIST
     The class method is invoked by the command `tie @array, classname'.
     Associates an array instance with the specified class. LIST would
     represent additional arguments (along the lines of *Note AnyDBM_File:
     AnyDBM_File, and compatriots) needed to complete the association. The
     method should return an object of a class which provides the methods
     below.

STORE this, index, value
     Store datum value into index for the tied array associated with
     object *this*. If this makes the array larger then class's mapping of
     undef should be returned for new positions.

FETCH this, index
     Retrieve the datum in index for the tied array associated with object
     *this*.

FETCHSIZE this
     Returns the total number of items in the tied array associated with
     object *this*. (Equivalent to `scalar(@array)').

STORESIZE this, count
     Sets the total number of items in the tied array associated with
     object *this* to be count. If this makes the array larger then
     class's mapping of undef should be returned for new positions.  If
     the array becomes smaller then entries beyond count should be deleted.

EXTEND this, count
     Informative call that array is likely to grow to have count entries.
     Can be used to optimize allocation. This method need do nothing.

EXISTS this, key
     Verify that the element at index key exists in the tied array *this*.

     The Tie::Array implementation is a stub that simply croaks.

DELETE this, key
     Delete the element at index key from the tied array *this*.

     The Tie::Array implementation is a stub that simply croaks.

CLEAR this
     Clear (remove, delete, ...) all values from the tied array associated
     with object *this*.

DESTROY this
     Normal object destructor method.

PUSH this, LIST
     Append elements of LIST to the array.

POP this
     Remove last element of the array and return it.

SHIFT this
     Remove the first element of the array (shifting other elements down)
     and return it.

UNSHIFT this, LIST
     Insert LIST elements at the beginning of the array, moving existing
     elements up to make room.

SPLICE this, offset, length, LIST
     Perform the equivalent of splice on the array.

     offset is optional and defaults to zero, negative values count back
     from the end of the array.

     length is optional and defaults to rest of the array.

     LIST may be empty.

     Returns a list of the original length elements at offset.

CAVEATS
=======

   There is no support at present for tied @ISA. There is a potential
conflict between magic entries needed to notice setting of @ISA, and those
needed to implement 'tie'.

   Very little consideration has been given to the behaviour of tied arrays
when $[ is not default value of zero.

AUTHOR
======

   Nick Ing-Simmons <nik@tiuk.ti.com>


File: pm.info,  Node: Tie/CArray,  Next: Tie/CPHash,  Prev: Tie/Array,  Up: Module List

Space-efficient, typed, external C Arrays (Alpha)
*************************************************

NAME
====

   Tie::CArray - Space-efficient, typed, external C Arrays (Alpha)

SYNOPSIS
========

     use Tie::CArray;
     $dblarr = new Tie::CDoubleArray(10000);

     @values = (0..10000);
     $dblarr = new Tie::CIntArray(10000,\@values);
     ref $dblarr eq 'Tie::CIntArray' and
       $dblarr->set(0,1) and
       $dblarr->get(0) == 1;

     tie @array, 'Tie::CDoubleArray', 10000, \@values;
     print $array[0], join ', ', @dbl[1..20];

DESCRIPTION
===========

   Several XS classes and methods to deal with typed, space-efficient C
arrays are provided. Range checked and tieable.

   There are hand-optimized, fast XS versions for the three basic C-types
array of *INT*, *DOUBLE* and STRING and some sequential aggregate types
int[2][], int[3][], int[4][], double[2][] and double[3][].

   This roughly reflects to:

     CArray
         CIntArray               int[]
             CInt2Array          int[][2]
             CInt3Array          int[][3]
             CInt4Array          int[][4]
         CDoubleArray            double[]
             CDouble2Array       double[][2]
             CDouble3Array       double[][3]
         CStringArray            *char[]

   Typed C arrays need about three times less space then untyped perl
arrays.  Such as various computional geometry modules dealing with 10.000
- 200.000 double[3]. Modification is done in-place and preferably in bulk.

   It might also be easier to write XSUBs by converting the data to
CArray's before, pass this pointer to the C func, and handle the results
in Perl then.

   The Fetch/Store operations with tied arrays copy the scalars to perl
and back, so it shouldn't be abused for BIG data.

   Perl's safemalloc/safefree is used.

EFFICIENT GROW
==============

   CArray's are efficiently growable, which is needed for several
algorithms, such as placing extra sentinels at the end, adding three
points for a super-triangle for Delaunay triangulation, ...

   Extra space is always allocated to fit nicely into the page boundary,
defined by the system granularity.  For now it's 2048, half of the usual
4096, but this can be tweaked (e.g. for many small arrays) in the C
function freesize().

CLASS METHODS
=============

new ( size, [ template, [ values ]] )
     The new method is provided for all classes, the optional arrayref
     initarg applies only to the base Array classes, not the aggregate.

     The constructor creates a new `Tie::CArray' object. For the Array
     classes the second optional argument is used to initialize it with an
     array. The second argument may also be used by a seperate init call.
     If the optionally provided values arrayref is shorter that the
     allocated size, the rest will stay uninitialized.

          $D = new Tie::CDoubleArray( 1000, ,[0..999] );

len ()
     The len method returns the length of the array, 1+ the index of the
     last element. To enlarge the array grow() should be used.

          $D  = new Tie::CDoubleArray(5000);
          for my $j (0 .. $D->len-1) { $D->set($_, 0.0)); }
          $D->len; # => 5000

get ( index )
     get returns the value at the given index, which will be scalar or a
     list.  Croaks with "index out of range" on wrong index.

          $I = new Tie::CIntArray(2,[0,1]);
          print $I->get(1); # => 1
          print $I->get(2);
            => croak "index out of range"

          $I2 = new Tie::CInt2Array(2,[[0,1]]);
          print $I->get(0); # => (0 1)

set ( index, value )
     The set method is provided for all classes.  It changes the value at
     the given index.  The value should be either a scalar or an arrayref.
     Croaks with "index out of range" on wrong index.  Returns nothing.

          $I = new Tie::CIntArray(100);
          map { $I->set($_,$i[$_]) } (0..99);
          $I->set(99,-1);
          $I->set(100);
            => "index out of range"

          $I2 = Tie::CInt2Array->new(2);
          $I2->set(0, [1,0]);
          $I2->set(1, [0,1]);

list ()
     Returns the content of the flat array representation as arrayref.

init ( ARRAYREF )
     Initializes the array with the values from the arrayref.  Returns
     nothing.

     This is the same as the second new argument.  If the provided values
     arrayref is shorter that the allocated size, the rest will stay
     uninitialized.

          $I = Tie::CIntArray::new(100) ;
          $I->init( [0..99] );

grow ( n )
     Adds room for n elements to the array. These elements must be
     initialized extra with set.  To support faster grow() a certain
     number of already pre-allocated items at the end of the array will be
     used. (see free) Returns nothing.

delete ( index )
     Deletes the item at the given index. free is incremented and the
     remaining array items are shifted.  Returns nothing.

get_grouped_by ( size, index )
     Returns a list of subsequent values.  It returns a list of size
     indices starting at size * index.  This is useful to abuse the
     unstructured array as typed array of the same type, such as
     *double[3] or *int[2].

     But this is normally not used since fast get methods are provided for
     the sequential classes, and those methods can be used on flat arrays
     as well.  (Internally all sequential arrays are flat).

          Tie::CInt3Array::get($I,0) == $I->get_grouped_by(3,0)

     $ptr->get_grouped_by(2,4) returns the 4-th pair if the array is seen
     as list of pairs.

          $ptr->get_grouped_by(3,$i) => (ptr[i*3] ptr[i*3+1] ptr[i*3+2] )

slice ( start, size, [ stride=1 ] )
     C++ like slice operator on a flat array. - In contrast to
     get_grouped_by() which semantics are as on a grouped array.

     Returns a list of size items, starting at start, with interim offsets
     of stride which defaults to 1.  This is useful to return columns or
     rows of a flat matrix.

          $I = new Tie::CIntArray (9, [0..8]);
          $I->slice ( 0, 3, 3 ); # 1st column
            => (0 3 6)
          $I->slice ( 0, 3, 1 ); # 1st row
            => (0 1 2)
          $I->get_grouped_by(3, 0);
            => (0 1 2)

isort ( [ cmpfunc ] )
     "Indirect sort" (numerically ascending only for now)

     Returns a fresh sorted index list of integers (0 .. len-1) resp. a
     CIntArray object in scalar context.

     The optional cmpfunc argument is not yet implemented.

nreverse ()
     "Reverse in place". (The name comes from lisp, where `n' denotes the
     destructive version).  Destructively swaps all array items. Returns
     nothing.

     To perform a copying reverse define

     sub reverse { nreverse($_[0]->copy()) }

SOME SEQUENTIAL CLASSES and CONVERSION
======================================

   To mix and change parallel and sequential data structures, some
sequential types (int[2],int[3],int[4],double[2],double[3]) are derived
from their base classes with fast, hand-optimized get and set methods to
return and accept lists instead of scalars.

   The input argument must be an arrayref, the result will be an array in
list context and an arrayref in scalar context.

   Conversion

   The Arrays for Int2, Int3, Int4, Double2 and Double3 can also be
converted from and to parallel base arrays with fast XS methods.  Parallel
arrays are sometimes preferred over structured arrays, but delete/ insert
of structures in parallel arrays is costly.

     # three parallel CIntArray's
     $X = new Tie::CIntArray(1000);
     $Y = new Tie::CIntArray(1000);
     $Z = new Tie::CIntArray(1000);

     # copy to one sequential *int[3], new memory
     $I = $X->ToInt3($Y,$Z);

     # or to an existing array
     $I = new Tie::CIntArray(3000);
     $I = $X->ToInt3($Y,$Z,$I);

     # copies back with allocating new memory
     ($X, $Y, $Z) = $I->ToPar();

     # copies back with reusing some existing memory (not checked!)
     ($X, $Y, $Z) = $I->ToPar($X,$Z);  # Note: I3 will be fresh.

ToPar ( SeqArray, [ Tie::CArray,... ] )
     This returns a list of Tie::CArray objects, copied from the sequential
     object to plain parallel CArray objects. This is a fast slice.

          *int[2] => (*int, *int)

          Tie::CInt2Array::ToPar
          Tie::CInt3Array::ToPar
          Tie::CInt4Array::ToPar
          Tie::CDouble2Array::ToPar
          Tie::CDouble3Array::ToPar

     If the optional CArray args are given the memory for the returned
     objects are not new allocated, the space from the given objects is
     used instead.

To$Type$Num ( CArray, ..., [ CArray ] )
     This returns a sequential CArray object copied from the parallel
     objects given as arguments to one sequential CArray. This is a fast
     map.

          *int, *int => *int[2]

          Tie::CIntArray::ToInt2
          Tie::CIntArray::ToInt3
          Tie::CIntArray::ToInt4
          Tie::CDoubleArray::ToDouble2
          Tie::CDoubleArray::ToDouble3

     If the last optional CArray arg is defined the memory for the returned
     object is not new allocated, the space from the given object is used
     instead.

ARBITRARY STRUCTURED ARRAYS, PACK-STYLE TEMPLATES
=================================================

   Some special sequential arrays are hand-optimized for speed but can
hold only limited data types (int[2] .. double[3]).

   To support arbitrary structured arrays a second template argument may be
provided which must be a arrayref of a hash, where its keys name the
accessor and the values pack-style letters.

     tie @A, 'Tie::CArray', 200,
                  [ x => 'd',
                    y => 'd',
                    z => 'd',
                    attr => [ age   => 'i',
                              dirty => 'i',
                              owner => 's' ],
                    refcount => 'i' ];
       $A->init ...

     for (my $i = 0; $i < @A; $i++) {
       printf("x,y,z: (%d %d %d),\nattr: (age=%d, dirty=%d, owner=%s)\nrefcount=%d",
              $A[$i]->{x}, $A[$i]->{y}, $A[$i]->{z},
              $A[$i]->{attr}->{age}, $A[$i]->{attr}->{dirty}, $A[$i]->{attr}->{owner},
              $A[$i]->{refcount}
             );
     }

     tie @utmp, 'Tie::CArray', 100,
           [ ut_type => 's',
             ut_pid  => 'i',
             ut_line    => 'a12',
             ut_id      => 'a4',
             ut_user    => 'a32',
             ut_host    => 'a256',
             ut_exit    => [ # struct exit_status
                             e_termination => 's',
                             e_exit        => 's' ],
             ut_session => 'l',
             ut_tv      => [ # struct timeval
                             tv_sec  => 'l'
                             tv_usec => 'l' ],
             ut_addr_v6 => 'l4',
             pad        => 'a20' ];

   The following subset of `pack()|perlfunc' in this node template letters
is supported:

i
     signed integer (default)

I
     unsigned integer

c
     signed character (one byte integer)

c
     unsigned character (one byte integer)

s
     signed short integer

S
     unsigned short integer

n
     unsigned short integer in network byte order

l
     signed long integer

L
     unsigned long integer

N
     unsigned long integer in network byte order

q
     signed long long integer (long long/int64)

     (only if the system has quads and perl was compiled for 64 bit)

Q
     unsigned long long integer (unsigned long long/uint64)

     (only if the system has quads and perl was compiled for 64 bit)

L
     unsigned long integer

f
     float

d
     double

aN
     fixed-length, null-padded ASCII string of length N

AN
     fixed-length, space-padded ASCII string of length N

ZN
     fixed-length, null-terminated ASCII string of length N

INTERNAL METHODS
================

DESTROY ()
     This used to crash on certain DEBUGGING perl's, but seems to be okay
     now.  Returns nothing.

Tie::CArray::itemsize ( )
Tie::CStringArray::itemsize ( [index] )
     Returns the size in bytes per item stored in the array. This is only
     used internally to optimize memory allocation and the free list.

     A CStringArray object accepts the optional index argument, which
     returns the string length at the given index. Without argument it
     returns the size in bytes of a char * pointer (which is 4 on 32 bit
     systems).

copy ()
     Returns a freshly allocated copy of the array with the same contents.

_freelen ()
     Internal only.  Returns the number of free elements at the end of the
     array.  If grow() needs less or equal than free elements to be added,
     no new room will be allocated.

     This is primarly for performance measures.

TIEARRAY METHODS
================

   *Not tested yet!*

tie (var, type, size)
     After tying a array variable to an `Tie::CArray' class the variable
     can be used just as any normal perl array.

          tie @array, 'Tie::CDoubleArray', 200;
          print $array[200];
            => croak "index out of range"

SEE ALSO
========

     http://www.perl.com//CPAN/authors/id/RURBAN/         or
     http://xarch.tu-graz.ac.at/home/rurban/software/perl or
     ftp://xarch.tu-graz.ac.at/pub/autocad/urban/perl

   `perlxs(1)' in this node, `tie', *Note Perlfunc: (perl.info)perlfunc,,
`Tie::Array(3)' in this node, `Geometry::Points(3)' in this node,
`C::Dynalib::Poke(3)' in this node, `Tie::MmapArray(3)' in this node

TODO
====

   Not all pack letters are implemented yet.

AUTHOR
======

   Reini Urban <rurban@x-ray.at>

   Andrew Ford wrote the arbitrary structure code.

COPYRIGHT
=========

   Copyright (c) 1999 Reini Urban.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

WARNING
=======

   The author makes NO WARRANTY, implied or otherwise, about the
suitability of this software for safety or security purposes.

   CArrays are now always ranged checked which cannot be turned off, so
it's not that dangerous anymore to read or write to not-owned memory areas.

   The author shall not in any case be liable for special, incidental,
consequential, indirect or other similar damages arising from the use of
this software.

   Your mileage will vary. If in any doubt *DO NOT USE IT*. You've been
warned.

BUGS
====

   There are certainly some. Not fully tested yet.  Tests for copy, grow,
delete, tie are pending.  Also some more conversion tests, esp. with
double and degenerate (grow, cut) cases.

  1. realloc() in string_set() with DEBUGGING perl fails sometimes.

  2. An implicit DESTROY invocation sometimes asserts a DEBUGGING perl,
     regardless if PERL_MALLOC or the WinNT msvcrt.dll malloc is used.
     (5.00502 - 5.00558) Esp. on perl shutdown, when freeing the extra
     objects at the second GC.

     This became much better in 0.08 than in previous versions.

        This is alpha, not fully tested yet!

VERSION
=======

   $Revision 0.12 $ $Date 2000-01-11 $


File: pm.info,  Node: Tie/CPHash,  Next: Tie/Cache,  Prev: Tie/CArray,  Up: Module List

Case preserving but case insensitive hash table
***********************************************

NAME
====

   Tie::CPHash - Case preserving but case insensitive hash table

SYNOPSIS
========

     require Tie::CPHash;
     tie %cphash, 'Tie::CPHash';

     $cphash{'Hello World'} = 'Hi there!';
     printf("The key `%s' was used to store `%s'.\n",
            tied(%cphash)->key('HELLO WORLD'),
            $cphash{'HELLO world'});

DESCRIPTION
===========

   The *Tie::CPHash* provides a hash table that is case preserving but
case insensitive.  This means that

     $cphash{KEY}    $cphash{key}
     $cphash{Key}    $cphash{keY}

   all refer to the same entry.  Also, the hash remembers which form of
the key was last used to store the entry.  The keys and each functions
will return the key that was used to set the value.

   An example should make this clear:

     tie %h, 'Tie::CPHash';
     $h{Hello} = 'World';
     print $h{HELLO};            # Prints 'World'
     print keys(%h);             # Prints 'Hello'
     $h{HELLO} = 'WORLD';
     print $h{hello};            # Prints 'WORLD'
     print keys(%h);             # Prints 'HELLO'

   The additional key method lets you fetch the case of a specific key:

     # When run after the previous example, this prints 'HELLO':
     print tied(%h)->key('Hello');

   (The tied function returns the object that `%h' is tied to.)

   If you need a case insensitive hash, but don't need to preserve case,
just use `$hash{lc $key}' instead of `$hash{$key}'.  This has a lot less
overhead than *Tie::CPHash*.

AUTHOR
======

   Christopher J. Madsen <`chris_madsen@geocities.com'>


File: pm.info,  Node: Tie/Cache,  Next: Tie/Cache/LRU,  Prev: Tie/CPHash,  Up: Module List

LRU Cache in Memory
*******************

NAME
====

   Tie::Cache - LRU Cache in Memory

SYNOPSIS
========

     use Tie::Cache;
     tie %cache, 'Tie::Cache', 100, { Debug => 1 };
     tie %cache2, 'Tie::Cache', { MaxCount => 100, MaxBytes => 1000 };
     tie %cache3, 'Tie::Cache', 100, { Debug => 1 , WriteSync => 0};

     # Options ##################################################################
     #
     # Debug =>	 0 - DEFAULT, no debugging output
     #		 1 - prints cache statistics upon destroying
     #		 2 - prints detailed debugging info
     #
     # MaxCount =>	 Maximum entries in cache.
     # MaxBytes =>   Maximum bytes in cache, sum of keys and values.
     # MaxSize  =>   Maximum size of each cache entry. Larger entries are not cached.
     #                   This helps prevent much of the cache being flushed when
     #                   you set an exceptionally large entry.
     # WriteSync =>  1 - DEFAULT, write() when data is dirtied for
     #                   TRUE CACHE (see below)
     #               0 - write() dirty data as late as possible, when leaving
     #                   cache, or when cache is being DESTROY'd
     #
     ############################################################################

     # cache supports normal tied hash functions
     $cache{1} = 2;       # STORE
     print "$cache{1}\n"; # FETCH

     # FIRSTKEY, NEXTKEY
     while(($k, $v) = each %cache) { print "$k: $v\n"; }
     
     delete $cache{1};    # DELETE
     %cache = ();         # CLEAR

DESCRIPTION
===========

   This module implements a least recently used (LRU) cache in memory
through a tie interface.  Any time data is stored in the tied hash, that
key/value pair has an entry time associated with it, and as the cache
fills up, those members of the cache that are the oldest are removed to
make room for new entries.

   So, the cache only "remembers" the last written entries, up to the size
of the cache.  This can be especially useful if you access great amounts
of data, but only access a minority of the data a majority of the time.

   The implementation is a hash, for quick lookups, overlaying a doubly
linked list for quick insertion and deletion.  On a WinNT PII 300, writes
to the hash were done at a rate 3100 per second, and reads from the hash
at 6300 per second.  Work has been done to optimize refreshing cache
entries that are frequently read from, code like $cache{entry}, which
moves the entry to the end of the linked list internally.

INSTALLATION
============

   Tie::Cache installs easily using the make or nmake commands as shown
below.  Otherwise, just copy Cache.pm to $PERLLIB/site/Tie

     > perl Makefile.PL
     > make
             > make test
     > make install

     * use nmake for win32
     ** you can also just copy Cache.pm to $perllib/Tie

BENCMARKS
=========

   There is another simpler LRU cache implementation in CPAN,
Tie::Cache::LRU, which has the same basic size limiting functionality, and
for this functionality, the exact same interface.  This other cache takes
writes about 20% faster but cache reads are about 50% slower.  Here are
some numbers to illustrate:

     Module			Read/s	Write/s	Delete/s Platform
     ------			------	-------	-------- --------
     Tie::Cache v.08	 6300	3100	4800	 perl 5.00404 WinNT PII300
     Tie::Cache::LRU v.05	 3700	3700	4500	 perl 5.00404 WinNT PII300
     --
     Tie::Cache v.08	10600	5300	8500	 perl 5.00503 Solaris PII300

   The reason for using an cache is that you are probably doing more reads
than writes, so you will likely want to use this module, but may want to
consider Tie::Cache::LRU if your i/o mix is write heavy.

TRUE CACHE
==========

   To use class as a true cache, which acts as the sole interface for some
data set, subclass the real cache off Tie::Cache, with @ISA = qw(
'Tie::Cache' ) notation.  Then override the read() method for behavior
when there is a cache miss, and the write() method for behavior when the
cache's data changes.

   When WriteSync is 1 or TRUE (DEFAULT), write() is called immediately
when data in the cache is modified.  If set to 0, data that has been
modified in the cache gets written out when the entries are deleted or
during the DESTROY phase of the cache object, usually at the end of a
script.

TRUE CACHE EXAMPLE
==================

     use Tie::Cache;

     # personalize the Tie::Cache object, by inheriting from it
     package My::Cache;
     @ISA = qw(Tie::Cache);

     # override the read() and write() member functions
     # these tell the cache what to do with a cache miss or flush
     sub read {
        my($self, $key) = @_;
        print "cache miss for $key, read() data\n";
        rand() * $key;
     }
     sub write {
        my($self, $key, $value) = @_;
        print "flushing [$key, $value] from cache, write() data\n";
     }

     my $cache_size   = $ARGV[0] || 2;
     my $num_to_cache = $ARGV[1] || 4;
     my $Debug = $ARGV[2] || 1;

     tie %cache, 'My::Cache', $cache_size, {Debug => $Debug};

     # load the cache with new data, each through its contents,
     # and then reload in reverse order.
     for(1..$num_to_cache) { print "read data $_: $cache{$_}\n" }
     while(my($k, $v) = each %cache) { print "each data $k: $v\n"; }
     for(my $i=$num_to_cache; $i>0; $i--) { print "read data $i: $cache{$i}\n"; }

     # clear cache in 2 ways, write will flush out to disk
     %cache = ();
     undef %cache;

NOTES
=====

   Many thanks to all those who helped me make this module a reality,
including:

     :) Tom Hukins who provided me insight and motivation for
        finishing this module.
     :) Jamie McCarthy, for trying to make Tie::Cache be all
        that it can be.
     :) Rob Fugina who knows how to "TRULY CACHE".

AUTHOR
======

   Please send any questions or comments to Joshua Chamas at
chamas@alumni.stanford.org

COPYRIGHT
=========

   Copyright (c) 1999 Joshua Chamas.  All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Tie/Cache/LRU,  Next: Tie/CacheHash,  Prev: Tie/Cache,  Up: Module List

A Least-Recently Used cache
***************************

NAME
====

   Tie::Cache::LRU - A Least-Recently Used cache

SYNOPSIS
========

     tie %cache, 'Tie::Cache::LRU', 500;
     tie %cache, 'Tie::Cache::LRU', '400k'; #UNIMPLEMENTED

     # Use like a normal hash.
     
     $cache_obj = tied %cache;
     $current_size = $cache_obj->curr_size;
     
     $max_size = $cache_obj->max_size;
     $cache_obj->max_size($new_size);

DESCRIPTION
===========

   This is an implementation of a least-recently used (LRU) cache keeping
the cache in RAM.

   A LRU cache is similar to the kind of cache used by a web browser.  New
items are placed into the top of the cache.  When the cache grows past its
size limit, it throws away items off the bottom.  The trick is that
whenever an item is -accessed-, it is pulled back to the top.  The end
result of all this is that items which are frequently accessed tend to
stay in the cache.

USAGE
=====

   The cache is extremely simple, is just holds a simple scalar.  If you
want to cache an object, just place it into the cache:

     $cache{$obj->id} = $obj;

   This doesn't make a copy of the object, it just holds a reference to
it.  (Note: This means that your object's destructor will not be called
until it has fallen out of the cache (and all other references to it have
disappeared, of course)!)

   If you want to cache an array, place a reference to it in the cache:

     $cache{$some_id} = \@array;

   Or, if you're worried about the consequences of tossing around
references and want to cache a copy instead, you can do something like
this:

     $cache{$some_id} = [@array];

Tied Interface
--------------

tie
          tie %cache, 'Tie::Cache::LRU';
          tie %cache, 'Tie::Cache::LRU', $cache_size;

     This ties a cache to %cache which will hold a maximum of $cache_size
     keys.  If $cache_size is not given it uses a default value,
     Tie::Cache::LRU::DEFAULT_MAX_SIZE.

     If the size is set to 0, the cache is effectively turned off.  This is
     useful for "removing" the cache from a program without having to make
     deep alterations to the program itself, or for checking performance
     differences with and without a cache.

     All of the expected hash operations (exists, delete, slices, etc...)
     work on the %cache.

Object Interface
----------------

   There's a few things you just can't do through the tied interface.  To
do them, you need to get at the underlying object, which you do with
tied().

     $cache_obj = tied %cache;

   And then you can call a few methods on that object:

max_size
          $cache_obj->max_size($size);
          $size = $cache_obj->max_size;

     An accessor to alter the maximum size of the cache on the fly.

     If max_size() is reset, and it is lower than the current size, the
     cache is immediately truncated.

     The size must be an integer greater than or equal to 0.

curr_size
          $size = $cache_obj->curr_size;

     Returns the current number of items in the cache.

FUTURE
======

   Should eventually allow the cache to be in shared memory.

   Max size by memory use unimplemented.

   For small cache sizes, it might be more efficient to just use an array
instead of a linked list.

AUTHOR
======

   Michael G Schwern <schwern@pobox.com> for Arena Networks

SEE ALSO
========

   `perl(1)' in this node


File: pm.info,  Node: Tie/CacheHash,  Next: Tie/CharArray,  Prev: Tie/Cache/LRU,  Up: Module List

Maintains sorted lists of top entries
*************************************

NAME
====

   Tie::CacheHash - Maintains sorted lists of top entries

SYNOPSIS
========

     use Tie::CacheHash;
     tie %hash1, 'Tie::CacheHash', 10, 100;
     tie %hash2, 'Tie::CacheHash', '5%', '10%';

DESCRIPTION
===========

   Of course you can get the "top 100" entries of any perl hash:

     @top_keys = (sort my_sort_func keys %my_hash)[0..99];

   But if your hash has more than a few thousand entries, that sort
operation may take several seconds.  And if you have tens of thousands of
entries, the sort may take many minutes.

   (If you are reading this documentation past the expiration date on the
bottom of the carton, please adjust the numbers accordingly.  Sorting is
always problematic for sufficiently large n.)

   Many programs will need to keep track of a "top 100" (or "bottom 100")
to perform such operations as expiring the oldest items out of a cache.
Sorting the entire array and skimming off the top items is not always an
acceptable algorithm.  Tie::CacheHash provides a simple and reasonably
efficient solution.  Its primary design goal is reasonable responsiveness
on every operation, i.e. no unpredictable long delays, and it achieves
this goal by avoiding the sorting of huge arrays.

   The two parameters you pass after the classname are the minimum and
maximum allowable size for the cache.  The largest array the module will
ever have to sort will be somewhat above the maximum (how much depends on
the distribution of your data), so picking a good 'max' will help control
the maximum delay you will experience.

   A 'min' of 0 means it is OK for the cache to run dry and never
replenish itself (###I think###), so you probably want a minimum of at
least 1.  A minimum/maximum of a very large integer (try 2**30) means to
keep the whole hash in the cache.

   Duplicate values are allowed;  if you don't specify your own sort
function, they will be secondarily sorted by key.

   If you pass in a subhash, you MUST NOT alter its data directly:  only
through the CacheHash.

BUGS
====

   There should be a way to store or delete large amounts of data at once,
without cache overhead between each entry.  For now, it should work to
munge the {h} array directly and then call cache_rebuild, but that's an
ugly workaround.

   There should be a way to set cache_pos's secondary (key) sort function,
instead of forcing "cmp".  (This would mean a tertiary sort to ensure
predictable sort order in case the user screws up and returns 0 for
nonequal keys.)

   Not sure yet whether the undefined value is handled properly in all
cases.  Should be tested with a subhash of a type known to choke and die
horribly on undef (ideally, Tie::CacheHash would not provoke such
behavior).

   The percent-style min/max arguments don't work yet (but they're an
awfully cool idea aren't they?).

   Because it's not a full 1.0 release yet, "make test" still does a
tremendous amount of randomized stress testing.  This takes longer than it
really should (typically 15-30 seconds, sometimes more).  When it gets
closer to release, this will be backed-off.

   The Monte Carlo algorithm has a number of places where its performance
could be further optimized.  In some cases the impact is significant.
These are marked in the code as "BUG".

   The cmp() method probably has room for performance improvement if we
make the very fair assumption that sort_func and sort_rev will not change
during a sort!

   The different DEBUG levels are neither well-thought-out nor documented.

   Haven't tested setting cache minimum to 0.

   Haven't tested setting cache maximum to 2**30.

AUTHOR
======

   Jamie McCarthy <jamie@mccarthy.org>.


