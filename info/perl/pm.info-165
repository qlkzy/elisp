This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Graph/Reader/XML,  Next: Graph/Traversal,  Prev: Graph/Reader,  Up: Module List

class for reading a Graph instance from XML
*******************************************

NAME
====

   Graph::Reader::XML - class for reading a Graph instance from XML

SYNOPSIS
========

     use Graph::Reader::XML;
     use Graph;
     
     $reader = Graph::Reader::XML->new();
     $graph = $reader->read_graph('mygraph.xml');

DESCRIPTION
===========

   Graph::Reader::XML is a perl class used to read a directed graph stored
as XML, and return an instance of the Graph class.

   The XML format is designed to support the Graph classes: it can be used
to represent a single graph with a collection of nodes, and edges between
those nodes.  The graph, nodes, and edges can all have attributes
specified,

   Graph::Reader::XML is a subclass of Graph::Reader, which defines the
generic interface for Graph reader classes.

METHODS
=======

new()
-----

   Constructor - generate a new reader instance.

     $reader = Graph::Reader::XML->new();

   This doesn't take any arguments.

read_graph()
------------

   Read a graph from a file:

     $graph = $reader->read_graph( $file );

   The $file argument can be either a filename or a filehandle of a
previously opened file.

KNOWN BUGS
==========

   Attribute values must be scalar. If they're not, well, you're on your
own.

SEE ALSO
========

Graph::Reader
     The base class for Graph::Reader::XML.

Graph::Writer::XML
     Used to serialise a Graph instance as XML.

Graph
     Jarkko Hietaniemi's classes for representing directed graphs.

AUTHOR
======

   Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 2001, Canon Research Centre Europe. All rights reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Graph/Traversal,  Next: Graph/Undirected,  Prev: Graph/Reader/XML,  Up: Module List

graph traversal
***************

NAME
====

   Graph::Traversal - graph traversal

SYNOPSIS
========

     use Graph::Traversal;

DESCRIPTION
===========

     $s = Graph::Traversal->new($G, %param)

   Returns a new graph search object for the graph $G and the parameters
%param.

   Usually not used directly but instead via frontends like Graph::DFS for
depth-first searching and Graph::BFS for breadth-first searching:

     $dfs = Graph::DFS->new($G, %param)
     $bfs = Graph::BFS->new($G, %param)

   *%param documentation to be written*

     $S->reset

   Resets a graph search object $S to its initial state.

     $v = $s->next_preorder

   Returns the next vertex in preorder of the graph encapsulated within
the search object $s.

     ($u, $v) = $s->next_edge

   Returns the vertices of the next edge of the graph encapsulated within
the search object $s.

     @V = $S->preorder

   Returns all the vertices in preorder of the graph encapsulated within
the search object $S.

     @V = $S->postorder

   Returns all the vertices in postorder of the graph encapsulated within
the search object $S.

     @V = $S->edges

   Returns all the edges of the graph encapsulated within the search
object $S.

     @R = $S->roots

   Returns all the root vertices of the trees of the graph encapsulated
within the search object $S.  "The root vertices" is ambiguous: what
really happens is that either the roots from the previous search made on
the $s are returned; or a preorder search is done and the roots of this
search are returned.

     %R = $S->vertex_roots

   Returns as a hash of ($vertex, $root) pairs all the vertices and the
root vertices of their search trees of the graph encapsulated within the
search object $S.  "The root vertices" is ambiguous; see the documentation
of the roots() method for more details.

COPYRIGHT
=========

   Copyright 1999, O'Reilly & Associates.

   This code is distributed under the same copyright terms as Perl itself.


File: pm.info,  Node: Graph/Undirected,  Next: Graph/Vertex,  Prev: Graph/Traversal,  Up: Module List

directed graphs
***************

NAME
====

   Graph::Directed - directed graphs

SYNOPSIS
========

     use Graph::Directed;

     $g = new Graph::Directed;

DESCRIPTION
===========

   See Graph::Base for the available methods.

COPYRIGHT
=========

   Copyright 1999, O'Reilly & Associates.

   This code is distributed under the same copyright terms as Perl itself.


File: pm.info,  Node: Graph/Vertex,  Next: Graph/Writer,  Prev: Graph/Undirected,  Up: Module List

a base class for graph vertices
*******************************

NAME
====

   Graph::Vertex - a base class for graph vertices

SYNOPSIS
========

   *Not to be used directly*.

DESCRIPTION
===========

   This class is not to be used directly because a vertex always must
belong to a graph.  The graph classes will do this right.  Some useful
public methods exist, though.

ADDING AND DELETING VERTICES
----------------------------

   See *Note Graph: Graph,.

SEE ALSO
========

   *Note Graph: Graph,, *Note Graph/Element: Graph/Element,.

VERSION
=======

   See *Note Graph: Graph,.

AUTHOR
======

   Jarkko Hietaniemi <`jhi@iki.fi'>

COPYRIGHT
=========

   Copyright 1998, O'Reilly and Associates.

   This code is distributed under the same copyright terms as Perl itself.


File: pm.info,  Node: Graph/Writer,  Next: Graph/Writer/Dot,  Prev: Graph/Vertex,  Up: Module List

base class for Graph file format writers
****************************************

NAME
====

   Graph::Writer - base class for Graph file format writers

SYNOPSIS
========

     package Graph::Writer::MyFormat;
     use Graph::Writer;
     use vars qw(@ISA);
     @ISA = qw(Graph::Writer);
     
     sub _write_graph
     {
         my ($self, $graph, $FILE) = @_;
     
         # write $graph to $FILE
     }

DESCRIPTION
===========

   Graph::Writer is a base class for Graph file format writers.  A
particular subclass of Graph::Writer will handle a specific file format,
and generate a Graph, represented using Jarkko Hietaniemi's Graph class.

   You should never create an instance of this class yourself, it is only
meant for subclassing. If you try to create an instance of Graph::Writer,
the constructor will throw an exception.

METHODS
=======

new()
-----

   Constructor - generate a new writer instance. This is a virtual method,
or whatever the correct lingo is.  You're not meant to call this on the
base class, it is inherited by the subclasses. Ie if you do something like:

     $writer = Graph::Writer->new();

   It will throw an exception.

write_graph()
-------------

   Read a graph from the specified file:

     $graph = $writer->write_graph($file);

   The $file argument can either be a filename, or a filehandle for a
previously opened file.

SUBCLASSING
===========

   To create your own graph format writer, create a module which
subclasses Graph::Writer. For example, suppose DGF is a directed graph
format - create a *Graph::Writer::DGF* module, with the following
structure:

     package Graph::Writer::DGF;
     
     use Graph::Writer;
     use vars qw(@ISA);
     @ISA = qw(Graph::Writer);

     sub _write_graph
     {
         my $self  = shift;
         my $graph = shift;
         my $FILE  = shift;
     
         while (<$FILE>)
         {
     	}
     
         return 1;
     }
     
     1;

   Note the leading underscore on the *_write_graph()* method.  The base
class provides the public method, and invokes the private method which
you're expected to provide, as above.

   If you want to perform additional initialisation at construction time,
you can provide an *_init()* method, which will be invoked by the base
class's constructor.  You should invoke the superclass's initialiser as
well, as follows:

     sub _init
     {
         my $self = shift;
     
         $self->SUPER::_init();
     
         # your initialisation here
     }

   Someone can then use your class as follows:

     use Graph::Writer::DGF;
     
     $writer = Graph::Writer::DGF->new();
     $writer->write_graph($graph, 'foo.dgf');

SEE ALSO
========

Graph
     Jarkko Hietaniemi's modules for representing directed graphs,
     available from CPAN under modules/by-module/Graph/

Algorithms in Perl
     The O'Reilly book has a chapter on directed graphs, which is based
     around Jarkko's modules.

Graph::Writer::Dot
     A simple subclass of this class for writing graphs in the file format
     used by dot, which is part of the graphviz package from AT&T.

Graph::Writer::VCG
     A simple subclass of this class for writing graphs in the file format
     used by VCG, a tool for visualising directed graphs, initially
     developed for visualising compiler graphs.

Graph::Writer::XML
     A simple subclass of this class for writing graphs as XML, using a
     simple graph markup.

Graph::Reader
     A baseclass for Graph file format readers.

AUTHOR
======

   Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 2001, Canon Research Centre Europe. All rights reserved.

   This script is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Graph/Writer/Dot,  Next: Graph/Writer/VCG,  Prev: Graph/Writer,  Up: Module List

write out directed graph in Dot format
**************************************

NAME
====

   Graph::Writer::Dot - write out directed graph in Dot format

SYNOPSIS
========

     use Graph;
     use Graph::Writer::Dot;
     
     $graph = Graph->new();
     # add edges and nodes to the graph
     
     $writer = Graph::Writer::Dot->new();
     $writer->write_graph($graph, 'mygraph.dot');

DESCRIPTION
===========

   Graph::Writer::Dot is a class for writing out a directed graph in the
file format used by the dot tool (part of the AT+T graphviz package).  The
graph must be an instance of the Graph class, which is actually a set of
classes developed by Jarkko Hietaniemi.

METHODS
=======

new()
-----

   Constructor - generate a new writer instance.

     $writer = Graph::Writer::Dot->new();

   This doesn't take any arguments.

write_graph()
-------------

   Write a specific graph to a named file:

     $writer->write_graph($graph, $file);

   The $file argument can either be a filename, or a filehandle for a
previously opened file.

SEE ALSO
========

http://www.graphviz.org/
     The home page for the AT+T graphviz toolkit that includes the dot
     tool.

Graph
     Jarkko Hietaniemi's modules for representing directed graphs,
     available from CPAN under modules/by-module/Graph/

Algorithms in Perl
     The O'Reilly book which has a chapter on directed graphs, which is
     based around Jarkko's modules.

Graph::Writer
     The base-class for Graph::Writer::Dot

AUTHOR
======

   Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 2001, Canon Research Centre Europe. All rights reserved.

   This script is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Graph/Writer/VCG,  Next: Graph/Writer/XML,  Prev: Graph/Writer/Dot,  Up: Module List

write out directed graph in VCG format
**************************************

NAME
====

   Graph::Writer::VCG - write out directed graph in VCG format

SYNOPSIS
========

     use Graph;
     use Graph::Writer::VCG;
     
     $graph = Graph->new();
     # add edges and nodes to the graph
     
     $writer = Graph::Writer::VCG->new();
     $writer->write_graph($graph, 'mygraph.vcg');

DESCRIPTION
===========

   Graph::Writer::VCG is a class for writing out a directed graph in the
file format used by the *VCG* tool, originally developed for Visualising
Compiler Graphs.  The graph must be an instance of the Graph class, which
is actually a set of classes developed by Jarkko Hietaniemi.

METHODS
=======

new()
-----

   Constructor - generate a new writer instance.

     $writer = Graph::Writer::VCG->new();

   This doesn't take any arguments.

write_graph()
-------------

   Write a specific graph to a named file:

     $writer->write_graph($graph, $file);

   The $file argument can either be a filename, or a filehandle for a
previously opened file.

KNOWN BUGS
==========

   Currently doesn't do anything with attributes - only the structure of
the graph is written out.

SEE ALSO
========

http://www.cs.uni-sb.de/RW/users/sander/html/gsvcg1.html
     The home page for VCG.

Graph
     Jarkko Hietaniemi's modules for representing directed graphs,
     available from CPAN under modules/by-module/Graph/

Algorithms in Perl
     The O'Reilly book which has a chapter on directed graphs, which is
     based around Jarkko's modules.

Graph::Writer
     The base-class for Graph::Writer::VCG

AUTHOR
======

   Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 2001, Canon Research Centre Europe. All rights reserved.

   This script is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Graph/Writer/XML,  Next: Graph/_element,  Prev: Graph/Writer/VCG,  Up: Module List

write out directed graph as XML
*******************************

NAME
====

   Graph::Writer::XML - write out directed graph as XML

SYNOPSIS
========

     use Graph;
     use Graph::Writer::XML;
     
     $graph = Graph->new();
     # add edges and nodes to the graph
     
     $writer = Graph::Writer::XML->new();
     $writer->write_graph($graph, 'mygraph.xml');

DESCRIPTION
===========

   Graph::Writer::XML is a class for writing out a directed graph in a
simple XML format.  The graph must be an instance of the Graph class,
which is actually a set of classes developed by Jarkko Hietaniemi.

   The XML format is designed to support the Graph classes: it can be used
to represent a single graph with a collection of nodes, and edges between
those nodes.  The graph, nodes, and edges can all have attributes
specified, where an attribute is a (name,value) pair, with the value being
scalar.

METHODS
=======

new()
-----

   Constructor - generate a new writer instance.

     $writer = Graph::Writer::XML->new();

   This doesn't take any arguments.

write_graph()
-------------

   Write a specific graph to a named file:

     $writer->write_graph($graph, $file);

   The $file argument can either be a filename, or a filehandle for a
previously opened file.

KNOWN BUGS
==========

   No attempt is made to validate the XML in any formal way.

   Attribute values must be scalar. If they're not, well, you're on your
own.

SEE ALSO
========

XML::Writer
     The perl module used to actually write out the XML.  It handles
     entities etc.

Graph
     Jarkko Hietaniemi's modules for representing directed graphs,
     available from CPAN under modules/by-module/Graph/

Algorithms in Perl
     The O'Reilly book which has a chapter on directed graphs, which is
     based around Jarkko's modules.

Graph::Writer
     The base-class for Graph::Writer::XML

AUTHOR
======

   Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 2001, Canon Research Centre Europe. All rights reserved.

   This script is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Graph/_element,  Next: GraphViz,  Prev: Graph/Writer/XML,  Up: Module List

baseclass for all graph elements
********************************

NAME
====

   Graph::_element - baseclass for all graph elements

SYNOPSIS
========

   *Not intended for public use*.

DESCRIPTION
===========

VERSION
=======

   Version 0.01.

AUTHOR
======

   Jarkko Hietaniemi, <`jhi@iki.fi'>

COPYRIGHT
=========

   Copyright 1998, O'Reilly & Associates.

   This code is distributed under the same copyright terms as perl itself.


File: pm.info,  Node: GraphViz,  Next: GraphViz/DBI,  Prev: Graph/_element,  Up: Module List

Interface to the GraphViz graphing tool
***************************************

NAME
====

   GraphViz - Interface to the GraphViz graphing tool

SYNOPSIS
========

     use GraphViz;

     my $g = GraphViz->new();

     $g->add_node('London');
     $g->add_node('Paris', label => 'City of\nlurve');
     $g->add_node('New York');

     $g->add_edge('London' => 'Paris');
     $g->add_edge('London' => 'New York', label => 'Far');
     $g->add_edge('Paris' => 'London');

     print $g->as_png;

DESCRIPTION
===========

   This module provides an interface to layout and image generation of
directed and undirected graphs in a variety of formats (PostScript, PNG,
etc.) using the "dot" and "neato" programs from the GraphViz project
(http://www.graphviz.org/).

What is a graph?
----------------

   A (undirected) graph is a collection of nodes linked together with
edges.

   A directed graph is the same as a graph, but the edges have a direction.

What is GraphViz?
-----------------

   This module is an interface to the GraphViz toolset
(http://www.graphviz.org/). The GraphViz tools provide automatic graph
layout and drawing. This module simplifies the creation of graphs and
hides some of the complexity of the GraphViz module.

   Laying out graphs in an aesthetically-pleasing way is a hard problem -
there may be multiple ways to lay out the same graph, each with their own
quirks. GraphViz luckily takes part of this hard problem and does a pretty
good job in a couple of seconds for most graphs.

Why should I use this module?
-----------------------------

   Observation aids comprehension. That is a fancy way of expressing that
popular faux-Chinese proverb: "a picture is worth a thousand words".

   Text is not always the best way to represent anything and everything to
do with a computer programs. Pictures and images are easier to assimilate
than text. The ability to show a particular thing graphically can aid a
great deal in comprehending what that thing really represents.

   Diagrams are computationally efficient, because information can be
indexed by location; they group related information in the same area. They
also allow relations to be expressed between elements without labeling the
elements.

   A friend of mine used this to his advantage when trying to remember
important dates in computer history. Instead of sitting down and trying to
remember everything, he printed over a hundred posters (each with a date
and event) and plastered these throughout his house. His spatial memory is
still so good that asked last week (more than a year since the experiment)
when Lisp was invented, he replied that it was upstairs, around the corner
from the toilet, so must have been around 1958.

   Spreadsheets are also a wonderfully simple graphical representation of
computational models.

METHODS
=======

new
---

   This is the constructor. It currently takes one attribute, 'directed',
which defaults to 1 (true) - this specifies directed (tree-like) graphs.
Setting this to zero produces undirected graphs, which are layed out
differently.

     my $g = GraphViz->new();
     my $g = GraphViz->new(directed => 0);

add_node
--------

   A graph consists of at least one node. All nodes have a name attached
which uniquely represents that node.

   The add_node method creates a new node and optionally assigns it
attributes.

   The simplest form is used when no attributes are required, in which the
string represents the name of the node:

     $g->add_node('Paris');

   Various attributes are possible: "label" provides a label for the node
(the label defaults to the name if none is specified). The label can
contain embedded newlines with '\n', as well as '\c', '\l', '\r' for
center, left, and right justified lines:

     $g->add_node('Paris', label => 'City of\nlurve');

   Note that multiple attributes can be specified. Other attributes
include:

height, width
     sets the minimum height or width

shape
     sets the node shape. This can be one of: 'record', 'plaintext',
     'ellipse', 'circle', 'egg', 'triangle', 'box', 'diamond', 'trapezium',
     'parallelogram', 'house', 'hexagon', 'octagon'

fontsize
     sets the label size in points

fontname
     sets the label font family name

color
     sets the outline colour, and the default fill colour if the 'style' is
     'filled' and 'fillcolor' is not specified

     A colour value may be "h,s,v" (hue, saturation, brightness) floating
     point numbers between 0 and 1, or an X11 color name such as 'white',
     'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan', or
     'burlywood'

fillcolor
     sets the fill colour when the style is 'filled'. If not specified, the
     'fillcolor' when the 'style' is 'filled' defaults to be the same as
     the outline color

style
     sets the style of the node. Can be one of: 'filled', 'solid',
     'dashed', 'dotted', 'bold', 'invis'

URL
     sets the url for the node in image map and PostScript files. The
     string '\N' value will be replaced by the node name. In PostScript
     files, URL information is embedded in such a way that Acrobat
     Distiller creates PDF files with active hyperlinks

   If you wish to add an anonymous node, that is a node for which you do
not wish to generate a name, you may use the following form, where the
GraphViz module generates a name and returns it for you. You may then use
this name later on to refer to this node:

     my $nodename = $g->add_node('label' => 'Roman city');

   Nodes can be clustered together with the "cluster" attribute, which is
drawn by having a labelled rectangle around all the nodes in a cluster.

     $g->add_node('London', cluster => 'Europe');
     $g->add_node('Amsterdam', cluster => 'Europe');

   Also, nodes can consist of multiple parts (known as ports). This is
implemented by passing an array reference as the label, and the parts are
displayed as a label. GraphViz has a much more complete port system, this
is just a simple interface to it. See the 'from_port' and 'to_port'
attributes of add_edge:

     $g->add_node('London', label => ['Heathrow', 'Gatwick']);

add_edge
--------

   Edges are directed (or undirected) links between nodes. This method
creates a new edge between two nodes and optionally assigns it attributes.

   The simplest form is when now attributes are required, in which case
the nodes from and to which the edge should be are specified. This works
well visually in the program code:

     $g->add_edge('London' => 'Paris');

   Attributes such as 'label' can also be used. This specifies a label for
the edge.  The label can contain embedded newlines with '\n', as well as
'\c', '\l', '\r' for center, left, and right justified lines.

     $g->add_edge('London' => 'New York', label => 'Far');

   Note that multiple attributes can be specified. Other attributes
include:

minlen
     sets an integer factor that applies to the edge length (ranks for
     normal edges, or minimum node separation for flat edges)

weight
     sets the integer cost of the edge. Values greater than 1 tend to
     shorten the edge. Weight 0 flat edges are ignored for ordering nodes

fontsize
     sets the label type size in points

fontname
     sets the label font family name

fontcolor
     sets the label text colour

color
     sets the line colour for the edge

     A colour value may be "h,s,v" (hue, saturation, brightness) floating
     point numbers between 0 and 1, or an X11 color name such as 'white',
     'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan', or
     'burlywood'

style
     sets the style of the node. Can be one of: 'filled', 'solid',
     'dashed', 'dotted', 'bold', 'invis'

dir
     sets the arrow direction. Can be one of: 'forward', 'back', 'both',
     'none'

tailclip, headclip
     when set to false disables endpoint shape clipping

arrowhead, arrowtail
     sets the type for the arrow head or tail. Can be one of: 'none',
     'normal', 'inv', 'dot', 'odot', 'invdot', 'invodot.'

arrowsize
     sets the arrow size: (norm_length=10,norm_width=5,
     inv_length=6,inv_width=7,dot_radius=2)

headlabel, taillabel
     sets the text for port labels. Note that labelfontcolor,
     labelfontname, labelfontsize are also allowed

labeldistance, port_label_distance
     sets the distance from the edge / port to the label. Also labelangle

decorateP
     if set, draws a line from the edge to the label

samehead, sametail
     if set aim edges having the same value to the same port, using the
     average landing point

constraint
     if set to false causes an edge to be ignored for rank assignment

   Additionally, adding edges between ports of a node is done via the
'from_port' and 'to_port' parameters, which currently takes in the offset
of the port (ie 0, 1, 2...).

     $g->add_edge('London' => 'Paris', from_port => 0);

as_canon, as_text, as_gif etc. methods
--------------------------------------

   There are a number of methods which generate input for dot / neato or
output the graph in a variety of formats.

as_canon
     The as_canon method returns the canonical dotneato file which
     corresponds to the graph. It does not layout the graph - every other
     as_* method does.

          print $g->as_canon;

          # prints out something like:
          digraph test {
              node [	label = "\N" ];
              London [label=London];
              Paris [label="City of\nlurve"];
              New_York [label="New York"];
              London -> Paris;
              London -> New_York [label=Far];
              Paris -> London;
          }

as_text
     The as_text method returns text which is a layed-out dot /
     neato-format file.

          print $g->as_text;

          # prints out something like:
          digraph test {
              node [	label = "\N" ];
              graph [bb= "0,0,162,134"];
              London [label=London, pos="33,116", width="0.89", height="0.50"];
              Paris [label="City of\nlurve", pos="33,23", width="0.92", height="0.62"];
              New_York [label="New York", pos="123,23", width="1.08", height="0.50"];
              London -> Paris [pos="e,27,45 28,98 26,86 26,70 27,55"];
              London -> New_York [label=Far, pos="e,107,40 49,100 63,85 84,63 101,46", lp="99,72"];
              Paris -> London [pos="s,38,98 39,92 40,78 40,60 39,45"];
          }

as_ps
     Returns a string which contains a layed-out PostScript-format file.

          print $g->as_ps;

as_hpgl
     Returns a string which contains a layed-out HP pen plotter-format
     file.

          print $g->as_hpgl;

as_pcl
     Returns a string which contains a layed-out Laserjet printer-format
     file.

          print $g->as_pcl;

as_mif
     Returns a string which contains a layed-out FrameMaker
     graphics-format file.

          print $g->as_mif;

as_pic
     Returns a string which contains a layed-out PIC-format file.

          print $g->as_pic;

as_gd
     Returns a string which contains a layed-out GD-format file.

          print $g->as_gd;

as_gd2
     Returns a string which contains a layed-out GD2-format file.

          print $g->as_gd2;

as_gif
     Returns a string which contains a layed-out GIF-format file.

          print $g->as_gif;

as_jpeg
     Returns a string which contains a layed-out JPEG-format file.

          print $g->as_jpeg;

as_png
     Returns a string which contains a layed-out PNG-format file.

          print $g->as_png;

as_wbmp
     Returns a string which contains a layed-out Windows BMP-format file.

          print $g->as_wbmp;

as_ismap
     Returns a string which contains a layed-out HTML client-side image map
     format file.

          print $g->as_ismap;

as_imap
     Returns a string which contains a layed-out HTML server-side image map
     format file.

          print $g->as_imap;

as_vrml
     Returns a string which contains a layed-out VRML-format file.

          print $g->as_vrml;

as_vtx
     Returns a string which contains a layed-out VTX (Visual Thought)
     format file.

          print $g->as_vtx;

as_mp
     Returns a string which contains a layed-out MetaPost-format file.

          print $g->as_mp;

as_fig
     Returns a string which contains a layed-out FIG-format file.

          print $g->as_fig;

as_svg
     Returns a string which contains a layed-out SVG-format file.

          print $g->as_svg;

as_plain
     Returns a string which contains a layed-out simple-format file.

          print $g->as_plain;

NOTES
=====

   Older versions of GraphViz used a slightly different syntax for node
and edge adding (with hash references). The new format is slightly
clearer, although for the moment we support both. Use the new, clear
syntax, please.

AUTHOR
======

   Leon Brocard <`acme@astray.com'>

COPYRIGHT
=========

   Copyright (C) 2000-1, Leon Brocard

   This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.


File: pm.info,  Node: GraphViz/DBI,  Next: GraphViz/Data/Grapher,  Prev: GraphViz,  Up: Module List

graph database tables and relations
***********************************

NAME
====

   GraphViz::DBI - graph database tables and relations

SYNOPSIS
========

     use GraphViz::DBI;
     print GraphViz::DBI->new($dbh)->graph_tables->as_png;

DESCRIPTION
===========

   This module constructs a graph for a database showing tables and
connecting them if they are related. While or after constructing the
object, pass an open database handle, then call `graph_tables' to
determine database metadata and construct a GraphViz graph from the table
and field information.

METHODS
=======

   The following methods are defined by this class; all other method calls
are passed to the underlying GraphViz object:

new( [$dbh] )
     Constructs the object; also creates a GraphViz object. The constructor
     accepts an optional open database handle.

set_dbh($dbh)
     Sets the database handle.

get_dbh()
     Returns the database handle.

is_table($table)
     Checks the database metadata whether the argument is a valid table
     name.

is_foreign_key($table, $field)
     Determines whether the field belonging to the table is a foreign key
     into some other table. If so, it is expected to return the name of
     that table. If not, it is expected to return a false value.

     For example, if there is a table called "product" and another table
     contains a field called "product_id", then to indicate that this
     field is a foreign key into the product table, the method returns
     "product". This is the logic implemented in this class. You can
     override this method in a subclass to suit your needs.

graph_tables()
     This method goes through all tables and fields and calls appropriate
     methods to determine which tables and which dependencies exist, then
     hand the results over to GraphViz. It returns the GraphViz object.

TODO
====

   * Test with various database drivers to see whether they support the
     metadata interface.

   * Make each table a vertical port with dependencies using those ports.

   * Provide the possibility to name edges to specify the type of
     relationship ('has-a', 'is-a', etc.).

BUGS
====

   None known so far. If you find any bugs or oddities, please do inform
the author.

AUTHOR
======

   Marcel GrE<uuml>nauer <marcel@codewerk.com>

COPYRIGHT
=========

   Copyright 2001 Marcel GrE<uuml>nauer. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   perl(1), GraphViz(3pm).


File: pm.info,  Node: GraphViz/Data/Grapher,  Next: GraphViz/ISA,  Prev: GraphViz/DBI,  Up: Module List

Visualise data structures as a graph
************************************

NAME
====

   GraphViz::Data::Grapher - Visualise data structures as a graph

SYNOPSIS
========

     use GraphViz::Data::Grapher;

     my $graph = GraphViz::Data::Grapher->new($structure);
     print $g->as_png;

DESCRIPTION
===========

   This module makes it easy to visualise Perl data structures. Data
structures can grow quite large and it can be hard to understand the quite
how the structure fits together.

   Data::Dumper can help by representing the structure as a text
heirarchy, but GraphViz::Data::Grapher goes a step further and visualises
the structure by drawing a graph which represents the data structure.

   Arrays are represented by records. Scalars are represented by
themselves. Array references are represented by a '@' symbol, which is
linked to the array. Hash references are represented by a '%' symbol,
which is linked to an array of keys, which each link to their value.
Object references are represented by 'Object', which then links to the
type of the object. Undef is represented by 'undef'.

METHODS
=======

new
---

   This is the constructor. It takes a list, which is the data structure
to be visualised. A GraphViz object is returned.

     my $graph = GraphViz::Data::Grapher->new([3, 4, 5], "Hello");

as_*
----

   The data structure can be visualised in a number of different graphical
formats. Methods include as_ps, as_hpgl, as_pcl, as_mif, as_pic, as_gd,
as_gd2, as_gif, as_jpeg, as_png, as_wbmp, as_ismap, as_imap, as_vrml,
as_vtx, as_mp, as_fig, as_svg. See the GraphViz documentation for more
information. The two most common methods are:

     # Print out a PNG-format file
     print $g->as_png;

     # Print out a PostScript-format file
     print $g->as_ps;

AUTHOR
======

   Leon Brocard <`acme@astray.com'>

COPYRIGHT
=========

   Copyright (C) 2000-1, Leon Brocard

   This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.


File: pm.info,  Node: GraphViz/ISA,  Next: GraphViz/No,  Prev: GraphViz/Data/Grapher,  Up: Module List

Graphing @ISA hierarchies at run-time
*************************************

NAME
====

   GraphViz::ISA - Graphing @ISA hierarchies at run-time

SYNOPSIS
========

     use GraphViz::ISA;
     my $p = Some::Class->new;

     my $g1 = GraphViz::ISA->new($p);
     print $g1->as_png;

     my $g2 = GraphViz::ISA->new('Some::Other::Module');
     print $g2->as_png;

DESCRIPTION
===========

   This class constructs a graph showing the `@ISA' hierarchy (note: not
object hierarchies) from a package name or a blessed scalar.

METHODS
=======

   The following methods are defined by this class; all other method calls
are passed to the underlying GraphViz object:

new()
     This constructs the object itself and takes a parameter. The parameter
     can be either a package name or a scalar blessed into a package. It
     then calls isatree() and hands the result to graph(). Then it returns
     the newly constructed object.

isatree()
     Takes a package name as a parameter and traverses the indicated
     package's `@ISA' recursively, constructing a hash of hashes. If a
     package's `@ISA' is empty, it has an empty hashref as the value in
     the tree.

graph()
     Takes a tree previously constructed by isatree() and traverses it,
     creating nodes and edges as it goes along.

TODO
====

test.pl
BUGS
====

   None known so far. If you find any bugs or oddities, please do inform
the author.

AUTHOR
======

   Marcel GrE<uuml>nauer, <marcel@codewerk.com>

COPYRIGHT
=========

   Copyright 2001 Marcel GrE<uuml>nauer. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   perl(1), GraphViz(3pm).


File: pm.info,  Node: GraphViz/No,  Next: GraphViz/Parse/RecDescent,  Prev: GraphViz/ISA,  Up: Module List

subclass of GraphViz with no nodes
**********************************

NAME
====

   GraphViz::No - subclass of GraphViz with no nodes

SYNOPSIS
========

     use GraphViz::No;

     my $g = GraphViz::No->new();
     # methods as for GraphViz

DESCRIPTION
===========

   Graphs produced by GraphViz are occasionally huge, making it hard to
observe the structure. This subclass removes the nodes, so that only the
edges are visible. This allows the structure to stand out.

METHODS
=======

   As for GraphViz.

AUTHOR
======

   Leon Brocard <`acme@astray.com'>

COPYRIGHT
=========

   Copyright (C) 2000-1, Leon Brocard

   This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.


File: pm.info,  Node: GraphViz/Parse/RecDescent,  Next: GraphViz/Remote,  Prev: GraphViz/No,  Up: Module List

Visualise grammars
******************

NAME
====

   GraphViz::Parse::RecDescent - Visualise grammars

SYNOPSIS
========

     use GraphViz::Parse::RecDescent;

     # Either pass in the grammar
     my $graph = GraphViz::Parse::RecDescent->new($grammar);
     print $g->as_png;

     # or a Parse::RecDescent parser object
     my $graph = GraphViz::Parse::RecDescent->new($parser);
     print $g->as_ps;

DESCRIPTION
===========

   This module makes it easy to visualise Parse::RecDescent grammars.
Writing Parse::RecDescent grammars is tricky at the best of times, and
grammars almost always evolve in ways unforseen at the start. This module
aims to visualise a grammar as a graph in order to make the structure
clear and aid in understanding the grammar.

   Rules are represented as nodes, which have their name on the left of
the node and their productions on the right of the node. The subrules
present in the productions are represented by edges to the subrule nodes.

   Thus, every node (rule) should be connected to the graph - otherwise a
rule is not part of the grammar.

   This uses the GraphViz module to draw the graph. Thanks to Damian
Conway for the idea.

   Note that the Parse::RecDescent module should be installed.

METHODS
=======

new
---

   This is the constructor. It takes one mandatory argument, which can
either be the grammar text or a Parse::RecDescent parser object of the
grammar to be visualised. A GraphViz object is returned.

     # Either pass in the grammar
     my $graph = GraphViz::Parse::RecDescent->new($grammar);

     # or a Parse::RecDescent parser object
     my $graph = GraphViz::Parse::RecDescent->new($parser);

as_*
----

   The grammar can be visualised in a number of different graphical
formats. Methods include as_ps, as_hpgl, as_pcl, as_mif, as_pic, as_gd,
as_gd2, as_gif, as_jpeg, as_png, as_wbmp, as_ismap, as_imap, as_vrml,
as_vtx, as_mp, as_fig, as_svg. See the GraphViz documentation for more
information. The two most common methods are:

     # Print out a PNG-format file
     print $g->as_png;

     # Print out a PostScript-format file
     print $g->as_ps;

BUGS
====

   Translating the grammar to a graph is accomplished by peeking inside
the internals of a parser object, which is a tad scary. A new version of
Parse::RecDescent with different internals may break this module.

   At the moment, almost all Parse::RecDescent directives are supported.
If you find one that has been missed - let me know!

   Unfortunately, alternations (such as the following) do not produce very
pretty graphs, due to the fact that they are implicit (unamed) rules and
are implemented by new long-named subrules.

     character: 'the' ( good | bad | ugly ) /dude/

   Hopefully Parse::FastDescent will make this all much easier.

AUTHOR
======

   Leon Brocard <`acme@astray.com'>

COPYRIGHT
=========

   Copyright (C) 2001, Leon Brocard

   This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.


File: pm.info,  Node: GraphViz/Remote,  Next: GraphViz/Small,  Prev: GraphViz/Parse/RecDescent,  Up: Module List

use graphviz without installing it
**********************************

NAME
====

   GraphViz::Remote - use graphviz without installing it

SYNOPSIS
========

     use GraphViz::Remote;

     my $g = GraphViz::Remote->new();
     # methods as for GraphViz

DESCRIPTION
===========

   Installing the graphviz tools dot and neato is occasionally tricky.
This module allows you to send your GraphViz object across the Internet to
a GraphViz server which processes the graph with the graphviz tools. That
way, you do not need to install graphviz locally.

METHODS
=======

   As for GraphViz.

NOTES
=====

   This module functions by running dot and neato on my own personal
webserver, so please do not use this script too often or with large
graphs. If you intend to use GraphViz a lot, please install it locally!
Many thanks.

AUTHOR
======

   Leon Brocard <`acme@astray.com'>

COPYRIGHT
=========

   Copyright (C) 2001, Leon Brocard

   This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.


File: pm.info,  Node: GraphViz/Small,  Next: GraphViz/XML,  Prev: GraphViz/Remote,  Up: Module List

subclass of GraphViz with small nodes
*************************************

NAME
====

   GraphViz::Small - subclass of GraphViz with small nodes

SYNOPSIS
========

     use GraphViz::Small;

     my $g = GraphViz::Small->new();
     # methods as for GraphViz

DESCRIPTION
===========

   Graphs produced by GraphViz are occasionally huge, making it hard to
observe the structure. This subclass simply makes the nodes small and
empty, allowing the structure to stand out.

METHODS
=======

   As for GraphViz.

AUTHOR
======

   Leon Brocard <`acme@astray.com'>

COPYRIGHT
=========

   Copyright (C) 2000-1, Leon Brocard

   This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.


File: pm.info,  Node: GraphViz/XML,  Next: Graphics/ColorNames,  Prev: GraphViz/Small,  Up: Module List

Visualise XML as a tree
***********************

NAME
====

   GraphViz::XML - Visualise XML as a tree

SYNOPSIS
========

     use GraphViz::XML;

     my $graph = GraphViz::XML->new($xml);
     print $g->as_png;

DESCRIPTION
===========

   This module makes it easy to visualise XML as a tree. XML is hard for
humans to grasp, especially if the XML is computer-generated. This modules
aims to visualise the XML as a graph in order to make the structure of the
XML clear and to aid in understanding the XML.

   XML elements are represented as diamond nodes, with links to elements
within them. Character data is represented in round nodes.

   Note that the XML::Twig module should be installed.

METHODS
=======

new
---

   This is the constructor. It takes one mandatory argument, which is the
XML to be visualised. A GraphViz object is returned.

     my $graph = GraphViz::XML->new($xml);

as_*
----

   The XML can be visualised in a number of different graphical formats.
Methods include as_ps, as_hpgl, as_pcl, as_mif, as_pic, as_gd, as_gd2,
as_gif, as_jpeg, as_png, as_wbmp, as_ismap, as_imap, as_vrml, as_vtx,
as_mp, as_fig, as_svg. See the GraphViz documentation for more
information. The two most common methods are:

     # Print out a PNG-format file
     print $g->as_png;

     # Print out a PostScript-format file
     print $g->as_ps;

BUGS
====

   GraphViz tends to reorder the nodes. I hope to find a work around soon
(possibly with ports).

AUTHOR
======

   Leon Brocard <`acme@astray.com'>

COPYRIGHT
=========

   Copyright (C) 2001, Leon Brocard

   This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Graphics/ColorNames,  Next: Graphics/ColorNames/HTML,  Prev: GraphViz/XML,  Up: Module List

defines RGB values for common color names
*****************************************

NAME
====

   Graphics::ColorNames - defines RGB values for common color names

SYNOPSIS
========

     use Graphics::ColorNames qw( hex2tuple );

     tie %NameTable, 'Graphics::ColorNames', 'X';

     my $rgbhex = $NameTable{'green'};  # returns '00ff00'
     my @rgbtup = hex2tuple( $rgbhex ); # returns (0, 255, 0)

DESCRIPTION
===========

   This module defines RGB values for common color names. The intention is
to (1) provide a common module that authors can use with other modules to
specify colors; and (2) free module authors from having to "re-invent the
wheel" whenever they decide to give the users the option of specifying a
color by name rather than RGB value.

Usage
-----

   The interface is through a tied hash:

     tie %NAMETABLE, 'Graphics::ColorNames', SCHEME

   where `%NAMETABLE' is the tied hash and `SCHEME' is the color scheme.
Currently three schemes are available:

X
     550 color names used in X-Windows. *This is the default naming
     scheme*, since it provides the most names.

HTML
     16 common color names defined in the HTML 4.0 specification. These
     names are also used with CSS and SVG.

Windows
     16 commom color names used with Microsoft Windows and related
     products.  These are actually the same colors as HTML, although with
     different names.

   RGB values can be retrieved with a case-insensitive hash key:

     $rgb = $colors{'AliceBlue'};

   The value returned is in the six-digit hexidecimal format used in HTML
and CSS (without the initial '#'). To convert it to separate red, green,
and blue values (between 0 and 255), use the `hex2tuple' function:

     @rgb = hex2tuple( $colors{'AliceBlue'} );

   The `hex2tuple' function is not exported by default. You must specify it
explicitly when you 'use' the module.

CAVEAT
======

   This module is experimental. The interface may change.

AUTHOR
======

   Robert Rothenberg <rrwo@cpan.org>

LICENSE
=======

   Copyright (c) 2001 Robert Rothenberg. All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.


File: pm.info,  Node: Graphics/ColorNames/HTML,  Next: Graphics/ColorNames/Windows,  Prev: Graphics/ColorNames,  Up: Module List

HTML color names and equivalent RGB values
******************************************

NAME
====

   Graphics::ColorNames::HTML - HTML color names and equivalent RGB values

SYNOPSIS
========

     require Graphics::ColorNames::HTML;

     $NameTable = Graphics::ColorNames::HTML->NamesRgbTable();
     $RgbBlack  = $NameTable->{black};

DESCRIPTION
===========

   This module defines color names and their associated RGB values from the
HTML 4.0 Specification.

SEE ALSO
========

   `Graphics::ColorNames',  HTML 4.0 Specificiation <http://www.w3.org>

AUTHOR
======

   Robert Rothenberg <rrwo@cpan.org>


File: pm.info,  Node: Graphics/ColorNames/Windows,  Next: Graphics/ColorNames/X,  Prev: Graphics/ColorNames/HTML,  Up: Module List

Windows color names and equivalent RGB values
*********************************************

NAME
====

   Graphics::ColorNames::Windows - Windows color names and equivalent RGB
values

SYNOPSIS
========

     require Graphics::ColorNames::Windows;

     $NameTable = Graphics::ColorNames::Windows->NamesRgbTable();
     $RgbBlack  = $NameTable->{black};

DESCRIPTION
===========

   This module defines color names and their associated RGB values used in
Microsoft Windows.

SEE ALSO
========

   `Graphics::ColorNames'

AUTHOR
======

   Robert Rothenberg <rrwo@cpan.org>


File: pm.info,  Node: Graphics/ColorNames/X,  Next: Graphics/Libplot,  Prev: Graphics/ColorNames/Windows,  Up: Module List

X-Windows color names and equivalent RGB values
***********************************************

NAME
====

   Graphics::ColorNames::X - X-Windows color names and equivalent RGB
values

SYNOPSIS
========

     require Graphics::ColorNames::X;

     $NameTable = Graphics::ColorNames::X->NamesRgbTable();
     $RgbBlack  = $NameTable->{black};

DESCRIPTION
===========

   This module defines color names and their associated RGB values used in
X-Windows.

SEE ALSO
========

   `Graphics::ColorNames',

AUTHOR
======

   Robert Rothenberg <rrwo@cpan.org>


File: pm.info,  Node: Graphics/Libplot,  Next: Graphics/Plotter,  Prev: Graphics/ColorNames/X,  Up: Module List

Perl extension for libplot plotting library
*******************************************

NAME
====

   Graphics::Libplot - Perl extension for libplot plotting library

SYNOPSIS
========

     use Graphics::Libplot ':All';

DESCRIPTION
===========

   This module lets you create plots by calling the routines in the libplot
library.  The libplot library is included in the  plotutils package.
Wrappers for each published C function are present. So the section of the
plotutils info pages  on programming in C should be your main reference.
There are a few possible confusions, which are noted below.

   Some of the C routines require character constants rather than strings.
When using the equivalent perl function, you must wrap the character with
the 'ord' function. For instance,  alabel(ord 'c', ord 'c', "some text");
, will write some centered text.

EXPORTING FUNCTIONS
===================

   None of the libplot functions is exported by default. If you do not
import any functions you must prepend the module name to each function.
To call the openpl() function you would give,

   Graphics::Libplot::openpl();

   However, if you include the library with

   use Graphics::Libplot ':All'

   then all of the functions will be exported, and you do not need to
prepend the module name.  In this case you need to be careful because
there are many function names which may collide with others in your
program.

   On the other hand you can use one of

     use Graphics::Libplot ':INTEGERLOW'
     use Graphics::Libplot ':FLOATLOW'

   to get just integer or just floating point plotting.

   Be aware that the interface is still under development so more names
will be added, and your scripts may need to be changed.

EXAMPLES
========

   There are additional examples included in the source distribution.
This example draws a spiraling box pattern.

     use Graphics::Libplot ':ALL';
     $SIZE=100;
     parampl ("BITMAPSIZE", "700x700");
     $handle = newpl("X", stdin, stdout, stderr); # open xwindow display
     selectpl($handle);
     openpl();
     fspace(-$SIZE,-$SIZE, $SIZE, $SIZE); # specify user coord system
     pencolorname ("blue");
     fontname("HersheySerif");
     $s = 10;
     $f = 10;
     $sf = 1- .0012;
     for($i=1;$i<3000;$i++){
         fscale($sf,$sf);
         fbox(60+$s*sin($i/$f),
     	  60+$s*sin($i/$f),
     	  75-$s*cos($i/$f),
     	  75-$s*cos($i/$f));
        frotate(1);
     }
     closepl();
     selectpl(0);
     deletepl($handle);

   Substituting "ps" for "X" in the above example produces postscript on
the standard output stream.



AUTHOR
======

   John Lapeyre <lapeyre@physics.arizona.edu> wrote this perl interface.

   The libplot C library is developed by Robert Maier.

COPYRIGHT
=========

   libplot-perl is copyrighted by John Lapeyre and may be distributed only
under the terms of either the Gnu General Public License, or of the perl
Artistic License.

SEE ALSO
========

   perl(1).


