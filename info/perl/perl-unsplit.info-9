This is Info file perl.info, produced by Makeinfo version 1.68 from the
input file bigperl.texi.

   settitle perl


File: perl.info,  Node: perlvms,  Next: perlwin32,  Prev: perlos390,  Up: Top

VMS-specific documentation for Perl
***********************************

NAME
====

   perlvms - VMS-specific documentation for Perl

DESCRIPTION
===========

   Gathered below are notes describing details of Perl 5's behavior on
VMS.  They are a supplement to the regular Perl 5 documentation, so we
have focussed on the ways in which Perl 5 functions differently under VMS
than it does under Unix, and on the interactions between Perl and the rest
of the operating system.  We haven't tried to duplicate complete
descriptions of Perl features from the main Perl documentation, which can
be found in the `[.pod]' subdirectory of the Perl distribution.

   We hope these notes will save you from confusion and lost sleep when
writing Perl scripts on VMS.  If you find we've missed something you think
should appear here, please don't hesitate to drop a line to
vmsperl@newman.upenn.edu.

Installation
============

   Directions for building and installing Perl 5 can be found in the file
`README.vms' in the main source directory of the Perl distribution..

Organization of Perl Images
===========================

Core Images
-----------

   During the installation process, three Perl images are produced.
`Miniperl.Exe' is an executable image which contains all of the basic
functionality of Perl, but cannot take advantage of Perl extensions.  It
is used to generate several files needed to build the complete Perl and
various extensions.  Once you've finished installing Perl, you can delete
this image.

   Most of the complete Perl resides in the shareable image `PerlShr.Exe',
which provides a core to which the Perl executable image and all Perl
extensions are linked.  You should place this image in `Sys$Share', or
define the logical name `PerlShr' to translate to the full file
specification of this image.  It should be world readable.  (Remember that
if a user has execute only access to `PerlShr', VMS will treat it as if it
were a privileged shareable image, and will therefore require all
downstream shareable images to be INSTALLed, etc.)

   Finally, `Perl.Exe' is an executable image containing the main entry
point for Perl, as well as some initialization code.  It should be placed
in a public directory, and made world executable.  In order to run Perl
with command line arguments, you should define a foreign command to invoke
this image.

Perl Extensions
---------------

   Perl extensions are packages which provide both XS and Perl code to add
new functionality to perl.  (XS is a meta-language which simplifies
writing C code which interacts with Perl, see *Note Perlxs: perlxs, for
more details.)  The Perl code for an extension is treated like any other
library module - it's made available in your script through the appropriate
use or require statement, and usually defines a Perl package containing
the extension.

   The portion of the extension provided by the XS code may be connected
to the rest of Perl in either of two ways.  In the static configuration,
the object code for the extension is linked directly into `PerlShr.Exe',
and is initialized whenever Perl is invoked.  In the dynamic
configuration, the extension's machine code is placed into a separate
shareable image, which is mapped by Perl's DynaLoader when the extension
is used or required in your script.  This allows you to maintain the
extension as a separate entity, at the cost of keeping track of the
additional shareable image.  Most extensions can be set up as either
static or dynamic.

   The source code for an extension usually resides in its own directory.
At least three files are generally provided: *Extshortname*`.xs' (where
*Extshortname* is the portion of the extension's name following the last
`::'), containing the XS code, *Extshortname*`.pm', the Perl library module
for the extension, and Makefile.PL, a Perl script which uses the MakeMaker
library modules supplied with Perl to generate a `Descrip.MMS' file for
the extension.

Installing static extensions
----------------------------

   Since static extensions are incorporated directly into `PerlShr.Exe',
you'll have to rebuild Perl to incorporate a new extension.  You should
edit the main `Descrip.MMS' or `Makefile' you use to build Perl, adding
the extension's name to the ext macro, and the extension's object file to
the `extobj' macro.  You'll also need to build the extension's object
file, either by adding dependencies to the main `Descrip.MMS', or using a
separate `Descrip.MMS' for the extension.  Then, rebuild `PerlShr.Exe' to
incorporate the new code.

   Finally, you'll need to copy the extension's Perl library module to the
`[.'*Extname*] subdirectory under one of the directories in `@INC', where
*Extname* is the name of the extension, with all `::' replaced by . (e.g.
the library module for extension Foo::Bar would be copied to a
`[.Foo.Bar]' subdirectory).

Installing dynamic extensions
-----------------------------

   In general, the distributed kit for a Perl extension includes a file
named Makefile.PL, which is a Perl program which is used to create a
`Descrip.MMS' file which can be used to build and install the files
required by the extension.  The kit should be unpacked into a directory
tree not under the main Perl source directory, and the procedure for
building the extension is simply

     $ perl Makefile.PL  ! Create Descrip.MMS
     $ mmk               ! Build necessary files
     $ mmk test          ! Run test code, if supplied
     $ mmk install       ! Install into public Perl tree

   *N.B.* The procedure by which extensions are built and tested creates
several levels (at least 4) under the directory in which the extension's
source files live.  For this reason, you shouldn't nest the source
directory too deeply in your directory structure, lest you eccedd RMS'
maximum of 8 levels of subdirectory in a filespec.  (You can use rooted
logical names to get another 8 levels of nesting, if you can't place the
files near the top of the physical directory structure.)

   VMS support for this process in the current release of Perl is
sufficient to handle most extensions.  However, it does not yet recognize
extra libraries required to build shareable images which are part of an
extension, so these must be added to the linker options file for the
extension by hand.  For instance, if the `PGPLOT' extension to Perl
requires the `PGPLOTSHR.EXE' shareable image in order to properly link the
Perl extension, then the line `PGPLOTSHR/Share' must be added to the
linker options file `PGPLOT.Opt' produced during the build process for the
Perl extension.

   By default, the shareable image for an extension is placed
`[.lib.site_perl.auto'*Arch*.*Extname*] directory of the installed Perl
directory tree (where *Arch* is `VMS_VAX' or `VMS_AXP', and *Extname* is
the name of the extension, with each `::' translated to .).  (See the
MakeMaker documentation for more details on installation options for
extensions.)  However, it can be manually placed in any of several
locations:    - the `[.Lib.Auto.'*Arch**$PVers**Extname*] subdirectory
of one of the directories in `@INC' (where *PVers*      is the version of
Perl you're using, as supplied in $],      with '.' converted to '_'), or
 - one of the directories in `@INC', or    - a directory which the
extensions Perl library module      passes to the DynaLoader when asking
it to map      the shareable image, or    - `Sys$Share' or `Sys$Library'.
If the shareable image isn't in any of these places, you'll need to define
a logical name *Extshortname*, where *Extshortname* is the portion of the
extension's name after the last `::', which translates to the full file
specification of the shareable image.

File specifications
===================

Syntax
------

   We have tried to make Perl aware of both VMS-style and Unix- style file
specifications wherever possible.  You may use either style, or both, on
the command line and in scripts, but you may not combine the two styles
within a single fle specification.  VMS Perl interprets Unix pathnames in
much the same way as the CRTL (*e.g.* the first component of an absolute
path is read as the device name for the VMS file specification).  There
are a set of functions provided in the `VMS::Filespec' package for explicit
interconversion between VMS and Unix syntax; its documentation provides
more details.

   Filenames are, of course, still case-insensitive.  For consistency,
most Perl routines return  filespecs using lower case letters only,
regardless of the case used in the arguments passed to them.  (This is
true  only when running under VMS; Perl respects the case-sensitivity of
OSs like Unix.)

   We've tried to minimize the dependence of Perl library modules on Unix
syntax, but you may find that some of these, as well as some scripts
written for Unix systems, will require that you use Unix syntax, since
they will assume that '/' is the directory separator, etc.  If you find
instances of this in the Perl distribution itself, please let us know, so
we can try to work around them.

Wildcard expansion
------------------

   File specifications containing wildcards are allowed both on the
command line and within Perl globs (e.g. <C<*.c>>).  If the wildcard
filespec uses VMS syntax, the resultant filespecs will follow VMS syntax;
if a Unix-style filespec is passed in, Unix-style filespecs will be
returned.

   In both cases, VMS wildcard expansion is performed. (csh-style wildcard
expansion is available if you use `File::Glob::glob'.)  If the wildcard
filespec contains a device or directory specification, then the resultant
filespecs will also contain a device and directory; otherwise, device and
directory information are removed.  VMS-style resultant filespecs will
contain a full device and directory, while Unix-style resultant filespecs
will contain only as much of a directory path as was present in the input
filespec.  For example, if your default directory is Perl_Root:[000000],
the expansion of `[.t]*.*' will yield filespecs  like
"perl_root:[t]base.dir", while the expansion of `t/*/*' will yield
filespecs like "t/base.dir".  (This is done to match the behavior of glob
expansion performed by Unix shells.)

   Similarly, the resultant filespec will contain the file version only if
one was present in the input filespec.

Pipes
-----

   Input and output pipes to Perl filehandles are supported; the "file
name" is passed to lib$spawn() for asynchronous execution.  You should be
careful to close any pipes you have opened in a Perl script, lest you
leave any "orphaned" subprocesses around when Perl exits.

   You may also use backticks to invoke a DCL subprocess, whose output is
used as the return value of the expression.  The string between the
backticks is handled as if it were the argument to the system operator
(see below).  In this case, Perl will wait for the subprocess to complete
before continuing.

PERL5LIB and PERLLIB
====================

   The PERL5LIB and PERLLIB logical names work as documented *Note Perl:
perl,, except that the element separator is '|' instead of ':'.  The
directory specifications may use either VMS or Unix syntax.

Command line
============

I/O redirection and backgrounding
---------------------------------

   Perl for VMS supports redirection of input and output on the command
line, using a subset of Bourne shell syntax:

     <F<file> reads stdin from F<file>,
     >F<file> writes stdout to F<file>,
     >>F<file> appends stdout to F<file>,
     2>F<file> writes stderr to F<file>, and
     2>>F<file> appends stderr to F<file>.

   In addition, output may be piped to a subprocess, using the character
'|'.  Anything after this character on the command line is passed to a
subprocess for execution; the subprocess takes the output of Perl as its
input.

   Finally, if the command line ends with '&', the entire command is run
in the background as an asynchronous subprocess.

Command line switches
---------------------

   The following command line switches behave differently under VMS than
described in *Note Perlrun: perlrun,.  Note also that in order to pass
uppercase switches to Perl, you need to enclose them in double-quotes on
the command line, since the CRTL downcases all unquoted strings.

-i
     If the -i switch is present but no extension for a backup copy is
     given, then inplace editing creates a new version of a file; the
     existing copy is not deleted.  (Note that if an extension is given,
     an existing file is renamed to the backup file, as is the case under
     other operating systems, so it does not remain as a previous version
     under the original filename.)

-S
     If the -S switch is present and the script name does not contain a
     directory, then Perl translates the logical name DCL$PATH as a
     searchlist, using each translation as a directory in which to look
     for the script.  In addition, if no file type is specified, Perl
     looks in each directory for a file matching the name specified, with
     a blank type, a type of `.pl', and a type of `.com', in that order.

-u
     The -u switch causes the VMS debugger to be invoked after the Perl
     program is compiled, but before it has run.  It does not create a
     core dump file.

Perl functions
==============

   As of the time this document was last revised, the following Perl
functions were implemented in the VMS port of Perl (functions marked with
* are discussed in more detail below):

     file tests*, abs, alarm, atan, backticks*, binmode*, bless,
     caller, chdir, chmod, chown, chomp, chop, chr,
     close, closedir, cos, crypt*, defined, delete,
     die, do, dump*, each, endpwent, eof, eval, exec*,
     exists, exit, exp, fileno, fork*, getc, getlogin,
     getpwent*, getpwnam*, getpwuid*, glob, gmtime*, goto,
     grep, hex, import, index, int, join, keys, kill*,
     last, lc, lcfirst, length, local, localtime, log, m//,
     map, mkdir, my, next, no, oct, open, opendir, ord, pack,
     pipe, pop, pos, print, printf, push, q//, qq//, qw//,
     qx//*, quotemeta, rand, read, readdir, redo, ref, rename,
     require, reset, return, reverse, rewinddir, rindex,
     rmdir, s///, scalar, seek, seekdir, select(internal),
     select (system call)*, setpwent, shift, sin, sleep,
     sort, splice, split, sprintf, sqrt, srand, stat,
     study, substr, sysread, system*, syswrite, tell,
     telldir, tie, time, times*, tr///, uc, ucfirst, umask,
     undef, unlink*, unpack, untie, unshift, use, utime*,
     values, vec, wait, waitpid*, wantarray, warn, write, y///

   The following functions were not implemented in the VMS port, and
calling them produces a fatal error (usually) or undefined behavior
(rarely, we hope):

     chroot, dbmclose, dbmopen, fcntl, flock,
     getpgrp, getppid, getpriority, getgrent, getgrgid,
     getgrnam, setgrent, endgrent, ioctl, link, lstat,
     msgctl, msgget, msgsend, msgrcv, readlink, semctl,
     semget, semop, setpgrp, setpriority, shmctl, shmget,
     shmread, shmwrite, socketpair, symlink, syscall

   The following functions are available on Perls compiled with Dec C 5.2
or greater and running VMS 7.0 or greater

     truncate

   The following functions may or may not be implemented, depending on
what type of socket support you've built into your copy of Perl:

     accept, bind, connect, getpeername,
     gethostbyname, getnetbyname, getprotobyname,
     getservbyname, gethostbyaddr, getnetbyaddr,
     getprotobynumber, getservbyport, gethostent,
     getnetent, getprotoent, getservent, sethostent,
     setnetent, setprotoent, setservent, endhostent,
     endnetent, endprotoent, endservent, getsockname,
     getsockopt, listen, recv, select(system call)*,
     send, setsockopt, shutdown, socket

File tests
     The tests -b, -B, -c, -C, -d, -e, -f, -o, -M, -s, -S, -t, -T, and -z
     work as advertised.  The return values for -r, -w, and -x tell you
     whether you can actually access the file; this may not reflect the
     UIC-based file protections.  Since real and effective UIC don't
     differ under VMS, -O, `-R', -W, and -X are equivalent to -o, -r, -w,
     and -x.  Similarly, several other tests, including -A, -g, -k, -l,
     -p, and -u, aren't particularly meaningful under VMS, and the values
     returned by these tests reflect whatever your CRTL stat() routine
     does to the equivalent bits in the st_mode field.  Finally, -d
     returns true if passed a device specification without an explicit
     directory (e.g. `DUA1:'), as well as if passed a directory.

     Note: Some sites have reported problems when using the file-access
     tests (-r, -w, and -x) on files accessed via DEC's DFS.
     Specifically, since DFS does not currently provide access to the
     extended file header of files on remote volumes, attempts to examine
     the ACL fail, and the file tests will return false, with $!
     indicating that the file does not exist.  You can use stat on these
     files, since that checks UIC-based protection only, and then manually
     check the appropriate bits, as defined by your C compiler's `stat.h',
     in the mode value it returns, if you need an approximation of the
     file's protections.

backticks
     Backticks create a subprocess, and pass the enclosed string to it for
     execution as a DCL command.  Since the subprocess is created directly
     via `lib$spawn()', any valid DCL command string may be specified.

binmode FILEHANDLE
     The binmode operator will attempt to insure that no translation of
     carriage control occurs on input from or output to this filehandle.
     Since this involves reopening the file and then restoring its file
     position indicator, if this function returns FALSE, the underlying
     filehandle may no longer point to an open file, or may point to a
     different position in the file than before binmode was called.

     Note that binmode is generally not necessary when using normal
     filehandles; it is provided so that you can control I/O to existing
     record-structured files when necessary.  You can also use the
     `vmsfopen' function in the VMS::Stdio extension to gain finer control
     of I/O to files and devices with different record structures.

crypt PLAINTEXT, USER
     The crypt operator uses the `sys$hash_password' system service to
     generate the hashed representation of PLAINTEXT.  If USER is a valid
     username, the algorithm and salt values are taken from that user's
     UAF record.  If it is not, then the preferred algorithm and a salt of
     0 are used.  The quadword encrypted value is returned as an
     8-character string.

     The value returned by crypt may be compared against the encrypted
     password from the UAF returned by the `getpw*' functions, in order to
     authenticate users.  If you're going to do this, remember that the
     encrypted password in the UAF was generated using uppercase username
     and password strings; you'll have to upcase the arguments to crypt to
     insure that you'll get the proper value:

          sub validate_passwd {
            my($user,$passwd) = @_;
            my($pwdhash);
            if ( !($pwdhash = (getpwnam($user))[1]) ||
                 $pwdhash ne crypt("\U$passwd","\U$name") ) {
              intruder_alert($name);
            }
            return 1;
          }

dump
     Rather than causing Perl to abort and dump core, the dump operator
     invokes the VMS debugger.  If you continue to execute the Perl
     program under the debugger, control will be transferred to the label
     specified as the argument to dump, or, if no label was specified,
     back to the beginning of the program.  All other state of the program
     (*e.g.* values of variables, open file handles) are not affected by
     calling dump.

exec LIST
     The exec operator behaves in one of two different ways.  If called
     after a call to fork, it will invoke the CRTL `execv()' routine,
     passing its arguments to the subprocess created by fork for
     execution.  In this case, it is subject to all limitations that
     affect `execv()'.  (In particular, this usually means that the
     command executed in the subprocess must be an image compiled from C
     source code, and that your options for passing file descriptors and
     signal handlers to the subprocess are limited.)

     If the call to exec does not follow a call to fork, it will cause
     Perl to exit, and to invoke the command given as an argument to exec
     via `lib$do_command'.  If the argument begins with '@' or '$' (other
     than as part of a filespec), then it is executed as a DCL command.
     Otherwise, the first token on the command line is treated as the
     filespec of an image to run, and an attempt is made to invoke it
     (using `.Exe' and the process defaults to expand the filespec) and
     pass the rest of exec's argument to it as parameters.  If the token
     has no file type, and matches a file with null type, then an attempt
     is made to determine whether the file is an executable image which
     should be invoked using `MCR' or a text file which should be passed
     to DCL as a command procedure.

     You can use exec in both ways within the same script, as long as you
     call fork and exec in pairs.  Perl keeps track of how many times fork
     and exec have been called, and will call the CRTL `execv()' routine
     if there have previously been more calls to fork than to exec.

fork
     The fork operator works in the same way as the CRTL `vfork()'
     routine, which is quite different under VMS than under Unix.
     Specifically, while fork returns 0 after it is called and the
     subprocess PID after exec is called, in both cases the thread of
     execution is within the parent process, so there is no opportunity to
     perform operations in the subprocess before calling exec.

     In general, the use of fork and exec to create subprocess is not
     recommended under VMS; wherever possible, use the system operator or
     piped filehandles instead.

getpwent
getpwnam
getpwuid
     These operators obtain the information described in *Note Perlfunc:
     perlfunc,, if you have the privileges necessary to retrieve the named
     user's UAF information via `sys$getuai'.  If not, then only the $name,
     `$uid', and `$gid' items are returned.  The $dir item contains the
     login directory in VMS syntax, while the $comment item contains the
     login directory in Unix syntax. The `$gcos' item contains the owner
     field from the UAF record.  The `$quota' item is not used.

gmtime
     The gmtime operator will function properly if you have a working CRTL
     `gmtime()' routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL
     is defined as the number of seconds which must be added to UTC to
     yield local time.  (This logical name is defined automatically if you
     are running a version of VMS with built-in UTC support.)  If neither
     of these cases is true, a warning message is printed, and undef is
     returned.

kill
     In most cases, kill kill is implemented via the CRTL's kill()
     function, so it will behave according to that function's
     documentation.  If you send a SIGKILL, however, the $DELPRC system
     service is called directly.  This insures that the target process is
     actually deleted, if at all possible.  (The CRTL's kill() function is
     presently implemented via $FORCEX, which is ignored by
     supervisor-mode images like DCL.)

     Also, negative signal values don't do anything special under VMS;
     they're just converted to the corresponding positive value.

qx//
     See the entry on backticks above.

select (system call)
     If Perl was not built with socket support, the system call version of
     select is not available at all.  If socket support is present, then
     the system call version of select functions only for file descriptors
     attached to sockets.  It will not provide information about regular
     files or pipes, since the CRTL select() routine does not provide this
     functionality.

stat EXPR
     Since VMS keeps track of files according to a different scheme than
     Unix, it's not really possible to represent the file's ID in the
     `st_dev' and `st_ino' fields of a `struct stat'.  Perl tries its
     best, though, and the values it uses are pretty unlikely to be the
     same for two different files.  We can't guarantee this, though, so
     caveat scriptor.

system LIST
     The system operator creates a subprocess, and passes its arguments to
     the subprocess for execution as a DCL command.  Since the subprocess
     is created directly via `lib$spawn()', any valid DCL command string
     may be specified.  If the string begins with '@', it is treated as a
     DCL command unconditionally.  Otherwise, if the first token contains
     a character used as a delimiter in file specification (e.g. : or ]),
     an attempt is made to expand it using  a default type of `.Exe' and
     the process defaults, and if successful, the resulting file is
     invoked via `MCR'. This allows you to invoke an image directly simply
     by passing the file specification to system, a common Unixish idiom.
     If the token has no file type, and matches a file with null type,
     then an attempt is made to determine whether the file is an
     executable image which should be invoked using `MCR' or a text file
     which should be passed to DCL as a command procedure.

     If LIST consists of the empty string, system spawns an interactive
     DCL subprocess, in the same fashion as typiing *SPAWN* at the DCL
     prompt.

     Perl waits for the subprocess to complete before continuing execution
     in the current process.  As described in *Note Perlfunc: perlfunc,,
     the return value of system is a fake "status" which follows POSIX
     semantics; see the description of $? in this document for more
     detail.  The actual VMS exit status of the subprocess is available in
     $^S (as long as you haven't used another Perl function that resets $?
     and $^S in the meantime).

time
     The value returned by time is the offset in seconds from 01-JAN-1970
     00:00:00 (just like the CRTL's times() routine), in order to make
     life easier for code coming in from the POSIX/Unix world.

times
     The array returned by the times operator is divided up according to
     the same rules the CRTL `times()' routine.  Therefore, the "system
     time" elements will always be 0, since there is no difference between
     "user time" and "system" time under VMS, and the time accumulated by
     subprocess may or may not appear separately in the "child time"
     field, depending on whether `times' in this node keeps track of
     subprocesses separately.  Note especially that the VAXCRTL (at least)
     keeps track only of subprocesses spawned using `fork' in this node
     and `exec' in this node; it will not accumulate the times of
     suprocesses spawned via pipes, `system' in this node, or backticks.

unlink LIST
     unlink will delete the highest version of a file only; in order to
     delete all versions, you need to say     1 while (unlink LIST); You
     may need to make this change to scripts written for a Unix system
     which expect that after a call to unlink, no files with the names
     passed to unlink will exist.  (Note: This can be changed at compile
     time; if you `use Config' and `$Config{'d_unlink_all_versions'}' is
     define, then unlink will delete all versions of a file on the first
     call.)

     unlink will delete a file if at all possible, even if it requires
     changing file protection (though it won't try to change the
     protection of the parent directory).  You can tell whether you've got
     explicit delete access to a file by using the
     `VMS::Filespec::candelete' operator.  For instance, in order to
     delete only files to which you have delete access, you could say
     something like

          sub safe_unlink {
              my($file,$num);
              foreach $file (@_) {
                  next unless VMS::Filespec::candelete($file);
                  $num += unlink $file;
              }
              $num;
          }

     (or you could just use `VMS::Stdio::remove', if you've installed the
     VMS::Stdio extension distributed with Perl). If unlink has to change
     the file protection to delete the file, and you interrupt it in
     midstream, the file may be left intact, but with a changed ACL
     allowing you delete access.

utime LIST
     Since ODS-2, the VMS file structure for disk files, does not keep
     track of access times, this operator changes only the modification
     time of the file (VMS revision date).

waitpid PID,FLAGS
     If PID is a subprocess started by a piped *Note Open: (pm.info)open,,
     waitpid will wait for that subprocess, and return its final status
     value.  If PID is a subprocess created in some other way (e.g.
     SPAWNed before Perl was invoked), or is not a subprocess of the
     current process, waitpid will check once per second whether the
     process has completed, and when it has, will return 0.  (If PID
     specifies a process that isn't a subprocess of the current process,
     and you invoked Perl with the -w switch, a warning will be issued.)

     The FLAGS argument is ignored in all cases.

Perl variables
==============

   The following VMS-specific information applies to the indicated
"special" Perl variables, in addition to the general information in *Note
Perlvar: perlvar,.  Where there is a conflict, this infrmation takes
precedence.

%ENV
     The operation of the %ENV array depends on the translation of the
     logical name `PERL_ENV_TABLES'.  If defined, it should be a search
     list, each element of which specifies a location for %ENV elements.
     If you tell Perl to read or set the element `$ENV{'name`}', then Perl
     uses the translations of `PERL_ENV_TABLES' as follows:

    CRTL_ENV
          This string tells Perl to consult the CRTL's internal `environ'
          array of key-value pairs, using name as the key.  In most cases,
          this contains only a few keys, but if Perl was invoked via the C
          `exec[lv]e()' function, as is the case for CGI processing by some
          HTTP servers, then the `environ' array may have been populated by
          the calling program.

    CLISYM_[LOCAL]
          A string beginning with `CLISYM_'tells Perl to consult the CLI's
          symbol tables, using name as the name of the symbol.  When
          reading an element of %ENV, the local symbol table is scanned
          first, followed by the global symbol table..  The characters
          following `CLISYM_' are significant when an element of %ENV is
          set or deleted: if the complete string is `CLISYM_LOCAL', the
          change is made in the local symbol table, otherwise the global
          symbol table is changed.

    Any other string
          If an element of `PERL_ENV_TABLES' translates to any other
          string, that string is used as the name of a logical name table,
          which is consulted using name as the logical name.  The normal
          search order of access modes is used.

     `PERL_ENV_TABLES' is translated once when Perl starts up; any changes
     you make while Perl is running do not affect the behavior of %ENV.
     If `PERL_ENV_TABLES' is not defined, then Perl defaults to consulting
     first the logical name tables specified by `LNM$FILE_DEV', and then
     the CRTL `environ' array.

     In all operations on %ENV, the key string is treated as if it were
     entirely uppercase, regardless of the case actually specified in the
     Perl expression.

     When an element of %ENV is read, the locations to which
     `PERL_ENV_TABLES' points are checked in order, and the value obtained
     from the first successful lookup is returned.  If the name of the
     %ENV element contains a semi-colon, it and any characters after it
     are removed.  These are ignored when the CRTL `environ' array or a
     CLI symbol table is consulted.  However, the name is looked up in a
     logical name table, the suffix after the semi-colon is treated as the
     translation index to be used for the lookup.   This lets you look up
     successive values for search list logical names.  For instance, if
     you say

          $  Define STORY  once,upon,a,time,there,was
          $  perl -e "for ($i = 0; $i <= 6; $i++) " -
          _$ -e "{ print $ENV{'story;'.$i},' '}"

     Perl will print `ONCE UPON A TIME THERE WAS', assuming, of course,
     that `PERL_ENV_TABLES' is set up so that the logical name `story' is
     found, rather than a CLI symbol or CRTL `environ' element with the
     same name.

     When an element of %ENV is set to a defined string, the corresponding
     definition is made in the location to which the first translation of
     `PERL_ENV_TABLES' points.  If this causes a logical name to be
     created, it is defined in supervisor mode.  (The same is done if an
     existing logical name was defined in executive or kernel mode; an
     existing user or supervisor mode logical name is reset to the new
     value.)  If the value is an empty string, the logical name's
     translation is defined as a single NUL (ASCII 00) character, since a
     logical name cannot translate to a zero-length string.  (This
     restriction does not apply to CLI symbols or CRTL `environ' values;
     they are set to the empty string.)  An element of the CRTL `environ'
     array can be set only if your copy of Perl knows about the CRTL's
     `setenv()' function.  (This is present only in some versions of the
     DECCRTL; check `$Config{d_setenv}' to see whether your copy of Perl
     was built with a CRTL that has this function.)

     When an element of %ENV is set to undef, the element is looked up as
     if it were being read, and if it is found, it is deleted.  (An item
     "deleted" from the CRTL `environ' array is set to the empty string;
     this can only be done if your copy of Perl knows about the CRTL
     `setenv()' function.)  Using delete to remove an element from %ENV
     has a similar effect, but after the element is deleted, another
     attempt is made to look up the element, so an inner-mode logical name
     or a name in another location will replace the logical name just
     deleted.  In either case, only the first value found searching
     PERL_ENV_TABLES is altered.  It is not possible at present to define
     a search list logical name via %ENV.

     The element `$ENV{DEFAULT}' is special: when read, it returns Perl's
     current default device and directory, and when set, it resets them,
     regardless of the definition of `PERL_ENV_TABLES'.  It cannot be
     cleared or deleted; attempts to do so are silently ignored.

     Note that if you want to pass on any elements of the C-local environ
     array to a subprocess which isn't started by fork/exec, or isn't
     running a C program, you can "promote" them to logical names in the
     current process, which will then be inherited by all subprocesses, by
     saying

          foreach my $key (qw[C-local keys you want promoted]) {
             my $temp = $ENV{$key}; # read from C-local array
             $ENV{$key} = $temp;    # and define as logical name
          }

     (You can't just say `$ENV{$key} = $ENV{$key}', since the Perl
     optimizer is smart enough to elide the expression.)

     At present, the first time you iterate over %ENV using keys, or
     values,  you will incur a time penalty as all logical names are read,
     in order to fully populate %ENV.  Subsequent iterations will not
     reread logical names, so they won't be as slow, but they also won't
     reflect any changes to logical name tables caused by other programs.

     You do need to be careful with the logicals representing
     process-permanent files, such as `SYS$INPUT' and `SYS$OUTPUT'.  The
     translations for these logicals are prepended with a two-byte binary
     value (0x1B 0x00) that needs to be stripped off if you want to use
     it. (In previous versions of perl it wasn't possible to get the
     values of these logicals, as the null byte acted as an end-of-string
     marker)

$!
     The string value of $! is that returned by the CRTL's strerror()
     function, so it will include the VMS message for VMS-specific errors.
     The numeric value of $! is the value of errno, except if errno is
     EVMSERR, in which case $! contains the value of vaxc$errno.  Setting
     $!  always sets errno to the value specified.  If this value is
     EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the
     string value of $! won't reflect the VMS error message from before $!
     was set.

$^E
     This variable provides direct access to VMS status values in
     vaxc$errno, which are often more specific than the generic Unix-style
     error messages in $!.  Its numeric value is the value of vaxc$errno,
     and its string value is the corresponding VMS message string, as
     retrieved by sys$getmsg().  Setting $^E sets vaxc$errno to the value
     specified.

$?
     The "status value" returned in $? is synthesized from the actual exit
     status of the subprocess in a way that approximates POSIX wait(5)
     semantics, in order to allow Perl programs to portably test for
     successful completion of subprocesses.  The low order 8 bits of $?
     are always 0 under VMS, since the termination status of a process may
     or may not have been generated by an exception.  The next 8 bits are
     derived from severity portion of the subprocess' exit status: if the
     severity was success or informational, these bits are all 0;
     otherwise, they contain the severity value shifted left one bit.  As
     a result, $? will always be zero if the subprocess' exit status
     indicated successful completion, and non-zero if a warning or error
     occurred.  The actual VMS exit status may be found in $^S (q.v.).

$^S
     Under VMS, this is the 32-bit VMS status value returned by the last
     subprocess to complete.  Unlink $?, no manipulation is done to make
     this look like a POSIX wait(5) value, so it may be treated as a
     normal VMS status value.

$|
     Setting $| for an I/O stream causes data to be flushed all the way to
     disk on each write (*i.e.* not just to the underlying RMS buffers for
     a file).  In other words, it's equivalent to calling fflush() and
     fsync() from C.

Standard modules with VMS-specific differences
==============================================

SDBM_File
---------

   SDBM_File works properly on VMS. It has, however, one minor difference.
The database directory file created has a `.sdbm_dir' extension rather
than a `.dir' extension. `.dir' files are VMS filesystem directory files,
and using them for other purposes could cause unacceptable problems.

Revision date
=============

   This document was last updated on 26-Feb-2000, for Perl 5, patchlevel 6.

AUTHOR
======

   Charles Bailey  <bailey@cor.newman.upenn.edu> Dan Sugalski
<dan@sidhe.org>


File: perl.info,  Node: perlwin32,  Next: Tk,  Prev: perlvms,  Up: Top

Perl under Win32
****************

NAME
====

   perlwin32 - Perl under Win32

SYNOPSIS
========

   These are instructions for building Perl under Windows (9x, NT and
2000).

DESCRIPTION
===========

   Before you start, you should glance through the README file found in
the top-level directory where the Perl distribution was extracted.  Make
sure you read and understand the terms under which this software is being
distributed.

   Also make sure you read `BUGS AND CAVEATS' in this node below for the
known limitations of this port.

   The INSTALL file in the perl top-level has much information that is
only relevant to people building Perl on Unix-like systems.  In
particular, you can safely ignore any information that talks about
"Configure".

   You may also want to look at two other options for building a perl that
will work on Windows NT:  the README.cygwin and README.os2 files, which
each give a different set of rules to build a Perl that will work on Win32
platforms.  Those two methods will probably enable you to build a more
Unix-compatible perl, but you will also need to download and use various
other build-time and run-time support software described in those files.

   This set of instructions is meant to describe a so-called "native" port
of Perl to Win32 platforms.  The resulting Perl requires no additional
software to run (other than what came with your operating system).
Currently, this port is capable of using one of the following compilers:

     Borland C++		version 5.02 or later
     Microsoft Visual C++	version 4.2 or later
     Mingw32 with GCC		version 2.95.2 or better

   The last of these is a high quality freeware compiler.  Support for it
is still experimental.  (Older versions of GCC are known not to work.)

   This port currently supports MakeMaker (the set of modules that is used
to build extensions to perl).  Therefore, you should be able to build and
install most extensions found in the CPAN sites.  See `Usage Hints' in
this node below for general hints about this.

Setting Up
----------

Make
     You need a "make" program to build the sources.  If you are using
     Visual C++ under Windows NT or 2000, nmake will work.  All other
     builds need dmake.

     dmake is a freely available make that has very nice macro features
     and parallelability.

     A port of dmake for Windows is available from:

          http://www.cpan.org/authors/id/GSAR/dmake-4.1pl1-win32.zip

     (This is a fixed version of original dmake sources obtained from
     http://www.wticorp.com/dmake/.  As of version 4.1PL1, the original
     sources did not build as shipped, and had various other problems.  A
     patch is included in the above fixed version.)

     Fetch and install dmake somewhere on your path (follow the
     instructions in the README.NOW file).

Command Shell
     Use the default "cmd" shell that comes with NT.  Some versions of the
     popular 4DOS/NT shell have incompatibilities that may cause you
     trouble.  If the build fails under that shell, try building again
     with the cmd shell.

     The nmake Makefile also has known incompatibilites with the
     "command.com" shell that comes with Windows 9x.  You will need to use
     dmake and makefile.mk to build under Windows 9x.

     The surest way to build it is on Windows NT, using the cmd shell.

     Make sure the path to the build directory does not contain spaces.
     The build usually works in this circumstance, but some tests will
     fail.

Borland C++
     If you are using the Borland compiler, you will need dmake.  (The
     make that Borland supplies is seriously crippled, and will not work
     for MakeMaker builds.)

     See L/"Make"> above.

Microsoft Visual C++
     The nmake that comes with Visual C++ will suffice for building.  You
     will need to run the VCVARS32.BAT file usually found somewhere like
     C:\MSDEV4.2\BIN.  This will set your build environment.

     You can also use dmake to build using Visual C++, provided: you set
     OSRELEASE to "microsft" (or whatever the directory name under which
     the Visual C dmake configuration lives) in your environment, and edit
     win32/config.vc to change "make=nmake" into "make=dmake".  The latter
     step is only essential if you want to use dmake as your default make
     for building extensions using MakeMaker.

Mingw32 with GCC
     GCC-2.95.2 binaries can be downloaded from:

          ftp://ftp.xraylith.wisc.edu/pub/khan/gnu-win32/mingw32/

     The GCC-2.95.2 bundle comes with Mingw32 libraries and headers.

     Make sure you install the binaries that work with MSVCRT.DLL as
     indicated in the README for the GCC bundle.  You may need to set up a
     few environment variables (usually run from a batch file).

     You also need dmake.  See `' in this node above on how to get it.

Building
--------

   * Make sure you are in the "win32" subdirectory under the perl toplevel.
     This directory contains a "Makefile" that will work with versions of
     nmake that come with Visual C++, and a dmake "makefile.mk" that will
     work for all supported compilers.  The defaults in the dmake makefile
     are setup to build using the GCC compiler.

   * Edit the makefile.mk (or Makefile, if using nmake) and change the
     values of INST_DRV and INST_TOP.   You can also enable various build
     flags.  These are explained in the makefiles.

     You will have to make sure CCTYPE is set correctly, and CCHOME points
     to wherever you installed your compiler.

     The default value for CCHOME in the makefiles for Visual C++ may not
     be correct for some versions.  Make sure the default exists and is
     valid.

     If you have either the source or a library that contains des_fcrypt(),
     enable the appropriate option in the makefile.  des_fcrypt() is not
     bundled with the distribution due to US Government restrictions on
     the export of cryptographic software.  Nevertheless, this routine is
     part of the "libdes" library (written by Eric Young) which is widely
     available worldwide, usually along with SSLeay (for example:
     "ftp://fractal.mta.ca/pub/crypto/SSLeay/DES/").  Set CRYPT_SRC to the
     name of the file that implements des_fcrypt().  Alternatively, if you
     have built a library that contains des_fcrypt(), you can set
     CRYPT_LIB to point to the library name.  The location above contains
     many versions of the "libdes" library, all with slightly different
     implementations of des_fcrypt().  Older versions have a single,
     self-contained file (fcrypt.c) that implements crypt(), so they may be
     easier to use.  A patch against the fcrypt.c found in libdes-3.06 is
     in des_fcrypt.patch.

     Perl will also build without des_fcrypt(), but the crypt() builtin
     will fail at run time.

     Be sure to read the instructions near the top of the makefiles
     carefully.

   * Type "dmake" (or "nmake" if you are using that make).

     This should build everything.  Specifically, it will create perl.exe,
     perl56.dll at the perl toplevel, and various other extension dll's
     under the lib\auto directory.  If the build fails for any reason, make
     sure you have done the previous steps correctly.

Testing
-------

   Type "dmake test" (or "nmake test").  This will run most of the tests
from the testsuite (many tests will be skipped).

   No tests should typically fail when running Windows NT 4.0.  Under
Windows 2000, test 22 in lib/open3.t is known to fail (cause still
unknown).  Many tests will fail under Windows 9x due to the inferior
command shell.

   Some test failures may occur if you use a command shell other than the
native "cmd.exe", or if you are building from a path that contains spaces.
So don't do that.

   If you are running the tests from a emacs shell window, you may see
failures in op/stat.t.  Run "dmake test-notty" in that case.

   If you're using the Borland compiler, you may see a failure in
op/taint.t arising from the inability to find the Borland Runtime DLLs on
the system default path.  You will need to copy the DLLs reported by the
messages from where Borland chose to install it, into the Windows system
directory (usually somewhere like C:\WINNT\SYSTEM32), and rerun the test.

   Please report any other failures as described under `BUGS AND CAVEATS'
in this node.

Installation
------------

   Type "dmake install" (or "nmake install").  This will put the newly
built perl and the libraries under whatever `INST_TOP' points to in the
Makefile.  It will also install the pod documentation under
`$INST_TOP\$VERSION\lib\pod' and HTML versions of the same under
`$INST_TOP\$VERSION\lib\pod\html'.  To use the Perl you just installed,
you will need to add two components to your PATH environment variable,
`$INST_TOP\$VERSION\bin', and `$INST_TOP\$VERSION\bin\$ARCHNAME'.  For
example:

     set PATH c:\perl\5.6.0\bin;c:\perl\5.6.0\bin\MSWin32-x86;%PATH%

   If you opt to comment out INST_VER and INST_ARCH in the makefiles, the
installation structure is much simpler.  In that case, it will be
sufficient to add a single entry to the path, for instance:

     set PATH c:\perl\bin;%PATH%

Usage Hints
-----------

Environment Variables
     The installation paths that you set during the build get compiled
     into perl, so you don't have to do anything additional to start using
     that perl (except add its location to your PATH variable).

     If you put extensions in unusual places, you can set PERL5LIB to a
     list of paths separated by semicolons where you want perl to look for
     libraries.  Look for descriptions of other environment variables you
     can set in *Note Perlrun: perlrun,.

     You can also control the shell that perl uses to run system() and
     backtick commands via PERL5SHELL.  See *Note Perlrun: perlrun,.

     Perl does not depend on the registry, but it can look up certain
     default values if you choose to put them there.  Perl attempts to
     read entries from `HKEY_CURRENT_USER\Software\Perl' and
     `HKEY_LOCAL_MACHINE\Software\Perl'.  Entries in the former override
     entries in the latter.  One or more of the following entries (of type
     REG_SZ or REG_EXPAND_SZ) may be set:

          lib-$]		version-specific standard library path to add to @INC
          lib			standard library path to add to @INC
          sitelib-$]		version-specific site library path to add to @INC
          sitelib		site library path to add to @INC
          vendorlib-$]	version-specific vendor library path to add to @INC
          vendorlib		vendor library path to add to @INC
          PERL*		fallback for all %ENV lookups that begin with "PERL"

     Note the $] in the above is not literal.  Substitute whatever version
     of perl you want to honor that entry, e.g. `5.6.0'.  Paths must be
     separated with semicolons, as usual on win32.

File Globbing
     By default, perl handles file globbing using the File::Glob extension,
     which provides portable globbing.

     If you want perl to use globbing that emulates the quirks of DOS
     filename conventions, you might want to consider using File::DosGlob
     to override the internal glob() implementation.  See *Note
     File/DosGlob: (pm.info)File/DosGlob, for details.

Using perl from the command line
     If you are accustomed to using perl from various command-line shells
     found in UNIX environments, you will be less than pleased with what
     Windows offers by way of a command shell.

     The crucial thing to understand about the "cmd" shell (which is the
     default on Windows NT) is that it does not do any wildcard expansions
     of command-line arguments (so wildcards need not be quoted).  It also
     provides only rudimentary quoting.  The only (useful) quote character
     is the double quote (").  It can be used to protect spaces in
     arguments and other special characters.  The Windows NT documentation
     has almost no description of how the quoting rules are implemented,
     but here are some general observations based on experiments:  The
     shell breaks arguments at spaces and passes them to programs in
     argc/argv.  Doublequotes can be used to prevent arguments with spaces
     in them from being split up.  You can put a double quote in an
     argument by escaping it with a backslash and enclosing the whole
     argument within double quotes.  The backslash and the pair of double
     quotes surrounding the argument will be stripped by the shell.

     The file redirection characters "<", ">", and "|" cannot be quoted by
     double quotes (there are probably more such).  Single quotes will
     protect those three file redirection characters, but the single
     quotes don't get stripped by the shell (just to make this type of
     quoting completely useless).  The caret "^" has also been observed to
     behave as a quoting character (and doesn't get stripped by the shell
     also).

     Here are some examples of usage of the "cmd" shell:

     This prints two doublequotes:

          perl -e "print '\"\"' "

     This does the same:

          perl -e "print \"\\\"\\\"\" "

     This prints "bar" and writes "foo" to the file "blurch":

          perl -e "print 'foo'; print STDERR 'bar'" > blurch

     This prints "foo" ("bar" disappears into nowhereland):

          perl -e "print 'foo'; print STDERR 'bar'" 2> nul

     This prints "bar" and writes "foo" into the file "blurch":

          perl -e "print 'foo'; print STDERR 'bar'" 1> blurch

     This pipes "foo" to the "less" pager and prints "bar" on the console:

          perl -e "print 'foo'; print STDERR 'bar'" | less

     This pipes "foo\nbar\n" to the less pager:

          perl -le "print 'foo'; print STDERR 'bar'" 2>&1 | less

     This pipes "foo" to the pager and writes "bar" in the file "blurch":

          perl -e "print 'foo'; print STDERR 'bar'" 2> blurch | less

     Discovering the usefulness of the "command.com" shell on Windows 9x
     is left as an exercise to the reader :)

Building Extensions
     The Comprehensive Perl Archive Network (CPAN) offers a wealth of
     extensions, some of which require a C compiler to build.  Look in
     http://www.cpan.org/ for more information on CPAN.

     Note that not all of the extensions available from CPAN may work in
     the Win32 environment; you should check the information at
     http://testers.cpan.org/ before investing too much effort into
     porting modules that don't readily build.

     Most extensions (whether they require a C compiler or not) can be
     built, tested and installed with the standard mantra:

          perl Makefile.PL
          $MAKE
          $MAKE test
          $MAKE install

     where $MAKE is whatever 'make' program you have configured perl to
     use.  Use "perl -V:make" to find out what this is.  Some extensions
     may not provide a testsuite (so "$MAKE test" may not do anything, or
     fail), but most serious ones do.

     It is important that you use a supported 'make' program, and ensure
     Config.pm knows about it.  If you don't have nmake, you can either
     get dmake from the location mentioned earlier, or get an old version
     of nmake reportedly available from:

          ftp://ftp.microsoft.com/Softlib/MSLFILES/nmake15.exe

     Another option is to use the make written in Perl, available from
     CPAN:

          http://www.cpan.org/authors/id/NI-S/Make-0.03.tar.gz

     You may also use dmake.  See `' in this node above on how to get it.

     Note that MakeMaker actually emits makefiles with different syntax
     depending on what 'make' it thinks you are using.  Therefore, it is
     important that one of the following values appears in Config.pm:

          make='nmake'	# MakeMaker emits nmake syntax
          make='dmake'	# MakeMaker emits dmake syntax
          any other value	# MakeMaker emits generic make syntax
          			    (e.g GNU make, or Perl make)

     If the value doesn't match the 'make' program you want to use, edit
     Config.pm to fix it.

     If a module implements XSUBs, you will need one of the supported C
     compilers.  You must make sure you have set up the environment for
     the compiler for command-line compilation.

     If a module does not build for some reason, look carefully for why it
     failed, and report problems to the module author.  If it looks like
     the extension building support is at fault, report that with full
     details of how the build failed using the perlbug utility.

Command-line Wildcard Expansion
     The default command shells on DOS descendant operating systems (such
     as they are) usually do not expand wildcard arguments supplied to
     programs.  They consider it the application's job to handle that.
     This is commonly achieved by linking the application (in our case,
     perl) with startup code that the C runtime libraries usually provide.
     However, doing that results in incompatible perl versions (since the
     behavior of the argv expansion code differs depending on the
     compiler, and it is even buggy on some compilers).  Besides, it may
     be a source of frustration if you use such a perl binary with an
     alternate shell that *does* expand wildcards.

     Instead, the following solution works rather well. The nice things
     about it: 1) you can start using it right away 2) it is more powerful,
     because it will do the right thing with a pattern like */*/*.c 3) you
     can decide whether you do/don't want to use it 4) you can extend the
     method to add any customizations (or even entirely different kinds of
     wildcard expansion).

          C:\> copy con c:\perl\lib\Wild.pm
          # Wild.pm - emulate shell @ARGV expansion on shells that don't
          use File::DosGlob;
          @ARGV = map {
          	      my @g = File::DosGlob::glob($_) if /[*?]/;
          	      @g ? @g : $_;
          	    } @ARGV;
          1;
          ^Z
          C:\> set PERL5OPT=-MWild
          C:\> perl -le "for (@ARGV) { print }" */*/perl*.c
          p4view/perl/perl.c
          p4view/perl/perlio.c
          p4view/perl/perly.c
          perl5.005/win32/perlglob.c
          perl5.005/win32/perllib.c
          perl5.005/win32/perlglob.c
          perl5.005/win32/perllib.c
          perl5.005/win32/perlglob.c
          perl5.005/win32/perllib.c

     Note there are two distinct steps there: 1) You'll have to create
     Wild.pm and put it in your perl lib directory. 2) You'll need to set
     the PERL5OPT environment variable.  If you want argv expansion to be
     the default, just set PERL5OPT in your default startup environment.

     If you are using the Visual C compiler, you can get the C runtime's
     command line wildcard expansion built into perl binary.  The resulting
     binary will always expand unquoted command lines, which may not be
     what you want if you use a shell that does that for you.  The
     expansion done is also somewhat less powerful than the approach
     suggested above.

Win32 Specific Extensions
     A number of extensions specific to the Win32 platform are available
     from CPAN.  You may find that many of these extensions are meant to
     be used under the Activeware port of Perl, which used to be the only
     native port for the Win32 platform.  Since the Activeware port does
     not have adequate support for Perl's extension building tools, these
     extensions typically do not support those tools either, and therefore
     cannot be built using the generic steps shown in the previous section.

     To ensure smooth transitioning of existing code that uses the
     ActiveState port, there is a bundle of Win32 extensions that contains
     all of the ActiveState extensions and most other Win32 extensions from
     CPAN in source form, along with many added bugfixes, and with
     MakeMaker support.  This bundle is available at:

          http://www.cpan.org/authors/id/GSAR/libwin32-0.151.zip

     See the README in that distribution for building and installation
     instructions.  Look for later versions that may be available at the
     same location.

Running Perl Scripts
     Perl scripts on UNIX use the "#!" (a.k.a "shebang") line to indicate
     to the OS that it should execute the file using perl.  Win32 has no
     comparable means to indicate arbitrary files are executables.

     Instead, all available methods to execute plain text files on Win32
     rely on the file "extension".  There are three methods to use this to
     execute perl scripts:

       1. There is a facility called "file extension associations" that
          will work in Windows NT 4.0.  This can be manipulated via the two
          commands "assoc" and "ftype" that come standard with Windows NT
          4.0.  Type "ftype /?" for a complete example of how to set this
          up for perl scripts (Say what?  You thought Windows NT wasn't
          perl-ready? :).

       2. Since file associations don't work everywhere, and there are
          reportedly bugs with file associations where it does work, the
          old method of wrapping the perl script to make it look like a
          regular batch file to the OS, may be used.  The install process
          makes available the "pl2bat.bat" script which can be used to wrap
          perl scripts into batch files.  For example:

               pl2bat foo.pl

          will create the file "FOO.BAT".  Note "pl2bat" strips any .pl
          suffix and adds a .bat suffix to the generated file.

          If you use the 4DOS/NT or similar command shell, note that
          "pl2bat" uses the "%*" variable in the generated batch file to
          refer to all the command line arguments, so you may need to make
          sure that construct works in batch files.  As of this writing,
          4DOS/NT users will need a "ParameterChar = *" statement in their
          4NT.INI file, or will need to execute "setdos /p*" in the 4DOS/NT
          startup file to enable this to work.

       3. Using "pl2bat" has a few problems:  the file name gets changed,
          so scripts that rely on $0 to find what they must do may not run
          properly; running "pl2bat" replicates the contents of the
          original script, and so this process can be maintenance intensive
          if the originals get updated often.  A different approach that
          avoids both problems is possible.

          A script called "runperl.bat" is available that can be copied to
          any filename (along with the .bat suffix).  For example, if you
          call it "foo.bat", it will run the file "foo" when it is
          executed.  Since you can run batch files on Win32 platforms
          simply by typing the name (without the extension), this
          effectively runs the file "foo", when you type either "foo" or
          "foo.bat".  With this method, "foo.bat" can even be in a
          different location than the file "foo", as long as "foo" is
          available somewhere on the PATH.  If your scripts are on a
          filesystem that allows symbolic links, you can even avoid
          copying "runperl.bat".

          Here's a diversion:  copy "runperl.bat" to "runperl", and type
          "runperl".  Explain the observed behavior, or lack thereof. :)
          Hint: .gnidnats llits er'uoy fi ,"lrepnur" eteled :tniH


Miscellaneous Things
     A full set of HTML documentation is installed, so you should be able
     to use it if you have a web browser installed on your system.

     perldoc is also a useful tool for browsing information contained in
     the documentation, especially in conjunction with a pager like less
     (recent versions of which have Win32 support).  You may have to set
     the PAGER environment variable to use a specific pager.  "perldoc -f
     foo" will print information about the perl operator "foo".

     If you find bugs in perl, you can run `perlbug' to create a bug
     report (you may have to send it manually if `perlbug' cannot find a
     mailer on your system).

BUGS AND CAVEATS
================

   Some of the built-in functions do not act exactly as documented in
*Note Perlfunc: perlfunc,, and a few are not implemented at all.  To avoid
surprises, particularly if you have had prior exposure to Perl in other
operating environments or if you intend to write code that will be
portable to other environments, see *Note Perlport: perlport, for a
reasonably definitive list of these differences.

   Not all extensions available from CPAN may build or work properly in
the Win32 environment.  See `' in this node.

   Most `socket()' related calls are supported, but they may not behave as
on Unix platforms.  See *Note Perlport: perlport, for the full list.

   Signal handling may not behave as on Unix platforms (where it doesn't
exactly "behave", either :).  For instance, calling `die()' or exit() from
signal handlers will cause an exception, since most implementations of
`signal()' on Win32 are severely crippled.  Thus, signals may work only
for simple things like setting a flag variable in the handler.  Using
signals under this port should currently be considered unsupported.

   Please send detailed descriptions of any problems and solutions that
you may find to <`perlbug@perl.com'>, along with the output produced by
`perl -V'.

AUTHORS
=======

   Gary Ng <71564.1743@CompuServe.COM>

   Gurusamy Sarathy <gsar@activestate.com>

   Nick Ing-Simmons <nick@ni-s.u-net.com>

   This document is maintained by Gurusamy Sarathy.

SEE ALSO
========

   *Note Perl: perl,

HISTORY
=======

   This port was originally contributed by Gary Ng around 5.003_24, and
borrowed from the Hip Communications port that was available at the time.
Various people have made numerous and sundry hacks since then.

   Borland support was added in 5.004_01 (Gurusamy Sarathy).

   GCC/mingw32 support was added in 5.005 (Nick Ing-Simmons).

   Support for PERL_OBJECT was added in 5.005 (ActiveState Tool Corp).

   Support for fork() emulation was added in 5.6 (ActiveState Tool Corp).

   Win9x support was added in 5.6 (Benjamin Stuhl).

   Last updated: 22 March 2000


File: perl.info,  Node: perlxs,  Next: perlxstut,  Prev: perldebguts,  Up: Top

XS language reference manual
****************************

NAME
====

   perlxs - XS language reference manual

DESCRIPTION
===========

Introduction
------------

   XS is an interface description file format used to create an extension
interface between Perl and C code (or a C library) which one wishes to use
with Perl.  The XS interface is combined with the library to create a new
library which can then be either dynamically loaded or statically linked
into perl.  The XS interface description is written in the XS language and
is the core component of the Perl extension interface.

   An XSUB forms the basic unit of the XS interface.  After compilation by
the xsubpp compiler, each XSUB amounts to a C function definition which
will provide the glue between Perl calling conventions and C calling
conventions.

   The glue code pulls the arguments from the Perl stack, converts these
Perl values to the formats expected by a C function, call this C function,
transfers the return values of the C function back to Perl.  Return values
here may be a conventional C return value or any C function arguments that
may serve as output parameters.  These return values may be passed back to
Perl either by putting them on the Perl stack, or by modifying the
arguments supplied from the Perl side.

   The above is a somewhat simplified view of what really happens.  Since
Perl allows more flexible calling conventions than C, XSUBs may do much
more in practice, such as checking input parameters for validity, throwing
exceptions (or returning undef/empty list) if the return value from the C
function indicates failure, calling different C functions based on numbers
and types of the arguments, providing an object-oriented interface, etc.

   Of course, one could write such glue code directly in C.  However, this
would be a tedious task, especially if one needs to write glue for
multiple C functions, and/or one is not familiar enough with the Perl
stack discipline and other such arcana.  XS comes to the rescue here:
instead of writing this glue C code in long-hand, one can write a more
concise short-hand description of what should be done by the glue, and let
the XS compiler xsubpp handle the rest.

   The XS language allows one to describe the mapping between how the C
routine is used, and how the corresponding Perl routine is used.  It also
allows creation of Perl routines which are directly translated to C code
and which are not related to a pre-existing C function.  In cases when the
C interface coincides with the Perl interface, the XSUB declaration is
almost identical to a declaration of a C function (in K&R style).  In such
circumstances, there is another tool called h2xs that is able to translate
an entire C header file into a corresponding XS file that will provide
glue to the functions/macros described in the header file.

   The XS compiler is called xsubpp.  This compiler creates the constructs
necessary to let an XSUB manipulate Perl values, and creates the glue
necessary to let Perl call the XSUB.  The compiler uses *typemaps* to
determine how to map C function parameters and output values to Perl
values and back.  The default typemap (which comes with Perl) handles many
common C types.  A supplementary typemap may also be needed to handle any
special structures and types for the library being linked.

   A file in XS format starts with a C language section which goes until
the first `MODULE =Z<'> directive.  Other XS directives and XSUB
definitions may follow this line.  The "language" used in this part of the
file is usually referred to as the XS language.

   See *Note Perlxstut: perlxstut, for a tutorial on the whole extension
creation process.

   Note: For some extensions, Dave Beazley's SWIG system may provide a
significantly more convenient mechanism for creating the extension glue
code. See `http:' in this node for more information.

On The Road
-----------

   Many of the examples which follow will concentrate on creating an
interface between Perl and the ONC+ RPC bind library functions.  The
rpcb_gettime() function is used to demonstrate many features of the XS
language.  This function has two parameters; the first is an input
parameter and the second is an output parameter.  The function also
returns a status value.

     bool_t rpcb_gettime(const char *host, time_t *timep);

   From C this function will be called with the following statements.

     #include <rpc/rpc.h>
     bool_t status;
     time_t timep;
     status = rpcb_gettime( "localhost", &timep );

   If an XSUB is created to offer a direct translation between this
function and Perl, then this XSUB will be used from Perl with the
following code.  The $status and $timep variables will contain the output
of the function.

     use RPC;
     $status = rpcb_gettime( "localhost", $timep );

   The following XS file shows an XS subroutine, or XSUB, which
demonstrates one possible interface to the rpcb_gettime() function.  This
XSUB represents a direct translation between C and Perl and so preserves
the interface even from Perl.  This XSUB will be invoked from Perl with
the usage shown above.  Note that the first three #include statements, for
`EXTERN.h', `perl.h', and `XSUB.h', will always be present at the
beginning of an XS file.  This approach and others will be expanded later
in this document.

     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"
     #include <rpc/rpc.h>

     MODULE = RPC  PACKAGE = RPC

     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &timep
        OUTPUT:
          timep

   Any extension to Perl, including those containing XSUBs, should have a
Perl module to serve as the bootstrap which pulls the extension into Perl.
This module will export the extension's functions and variables to the
Perl program and will cause the extension's XSUBs to be linked into Perl.
The following module will be used for most of the examples in this
document and should be used from Perl with the use command as shown
earlier.  Perl modules are explained in more detail later in this document.

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime );

     bootstrap RPC;
     1;

   Throughout this document a variety of interfaces to the rpcb_gettime()
XSUB will be explored.  The XSUBs will take their parameters in different
orders or will take different numbers of parameters.  In each case the
XSUB is an abstraction between Perl and the real C rpcb_gettime()
function, and the XSUB must always ensure that the real rpcb_gettime()
function is called with the correct parameters.  This abstraction will
allow the programmer to create a more Perl-like interface to the C
function.

The Anatomy of an XSUB
----------------------

   The simplest XSUBs consist of 3 parts: a description of the return
value, the name of the XSUB routine and the names of its arguments, and a
description of types or formats of the arguments.

   The following XSUB allows a Perl program to access a C library function
called sin().  The XSUB will imitate the C function which takes a single
argument and returns a single value.

     double
     sin(x)
       double x

   When using parameters with C pointer types, as in

     double string_to_double(char *s);

   there may be two ways to describe this argument to xsubpp:

     char *  s
     char    &s

   Both these XS declarations correspond to the `char*' C type, but they
have different semantics.  It is convenient to think that the indirection
operator * should be considered as a part of the type and the address
operator & should be considered part of the variable.  See `"The Typemap"'
in this node and `"The & Unary Operator"' in this node for more info about
handling qualifiers and unary operators in C types.

   The function name and the return type must be placed on separate lines
and should be flush left-adjusted.

     INCORRECT                        CORRECT

     double sin(x)                    double
       double x                       sin(x)
     				     double x

   The function body may be indented or left-adjusted.  The following
example shows a function with its body left-adjusted.  Most examples in
this document will indent the body for better readability.

     CORRECT

     double
     sin(x)
     double x

   More complicated XSUBs may contain many other sections.  Each section of
an XSUB starts with the corresponding keyword, such as INIT: or CLEANUP:.
However, the first two lines of an XSUB always contain the same data:
descriptions of the return type and the names of the function and its
parameters.  Whatever immediately follows these is considered to be an
INPUT: section unless explicitly marked with another keyword.  (See `The
INPUT: Keyword' in this node.)

   An XSUB section continues until another section-start keyword is found.

The Argument Stack
------------------

   The Perl argument stack is used to store the values which are sent as
parameters to the XSUB and to store the XSUB's return value(s).  In
reality all Perl functions (including non-XSUB ones) keep their values on
this stack all the same time, each limited to its own range of positions
on the stack.  In this document the first position on that stack which
belongs to the active function will be referred to as position 0 for that
function.

   XSUBs refer to their stack arguments with the macro *ST(x)*, where x
refers to a position in this XSUB's part of the stack.  Position 0 for that
function would be known to the XSUB as ST(0).  The XSUB's incoming
parameters and outgoing return values always begin at ST(0).  For many
simple cases the xsubpp compiler will generate the code necessary to
handle the argument stack by embedding code fragments found in the
typemaps.  In more complex cases the programmer must supply the code.

The RETVAL Variable
-------------------

   The RETVAL variable is a special C variable that is declared
automatically for you.  The C type of RETVAL matches the return type of
the C library function.  The xsubpp compiler will declare this variable in
each XSUB with non-void return type.  By default the generated C function
will use RETVAL to hold the return value of the C library function being
called.  In simple cases the value of RETVAL will be placed in ST(0) of
the argument stack where it can be received by Perl as the return value of
the XSUB.

   If the XSUB has a return type of void then the compiler will not
declare a RETVAL variable for that function.  When using a PPCODE: section
no manipulation of the RETVAL variable is required, the section may use
direct stack manipulation to place output values on the stack.

   If PPCODE: directive is not used, void return value should be used only
for subroutines which do not return a value, *even if* CODE: directive is
used which sets ST(0) explicitly.

   Older versions of this document recommended to use void return value in
such cases. It was discovered that this could lead to segfaults in cases
when XSUB was *truly* void. This practice is now deprecated, and may be
not supported at some future version. Use the return value `SV *' in such
cases. (Currently xsubpp contains some heuristic code which tries to
disambiguate between "truly-void" and "old-practice-declared-as-void"
functions. Hence your code is at mercy of this heuristics unless you use
`SV *' as return value.)

The MODULE Keyword
------------------

   The MODULE keyword is used to start the XS code and to specify the
package of the functions which are being defined.  All text preceding the
first MODULE keyword is considered C code and is passed through to the
output untouched.  Every XS module will have a bootstrap function which is
used to hook the XSUBs into Perl.  The package name of this bootstrap
function will match the value of the last MODULE statement in the XS
source files.  The value of MODULE should always remain constant within
the same XS file, though this is not required.

   The following example will start the XS code and will place all
functions in a package named RPC.

     MODULE = RPC

The PACKAGE Keyword
-------------------

   When functions within an XS source file must be separated into packages
the PACKAGE keyword should be used.  This keyword is used with the MODULE
keyword and must follow immediately after it when used.

     MODULE = RPC  PACKAGE = RPC

     [ XS code in package RPC ]

     MODULE = RPC  PACKAGE = RPCB

     [ XS code in package RPCB ]

     MODULE = RPC  PACKAGE = RPC

     [ XS code in package RPC ]

   Although this keyword is optional and in some cases provides redundant
information it should always be used.  This keyword will ensure that the
XSUBs appear in the desired package.

The PREFIX Keyword
------------------

   The PREFIX keyword designates prefixes which should be removed from the
Perl function names.  If the C function is `rpcb_gettime()' and the PREFIX
value is `rpcb_' then Perl will see this function as `gettime()'.

   This keyword should follow the PACKAGE keyword when used.  If PACKAGE
is not used then PREFIX should follow the MODULE keyword.

     MODULE = RPC  PREFIX = rpc_

     MODULE = RPC  PACKAGE = RPCB  PREFIX = rpcb_

The OUTPUT: Keyword
-------------------

   The OUTPUT: keyword indicates that certain function parameters should be
updated (new values made visible to Perl) when the XSUB terminates or that
certain values should be returned to the calling Perl function.  For
simple functions which have no CODE: or PPCODE: section, such as the sin()
function above, the RETVAL variable is automatically designated as an
output value.  For more complex functions the xsubpp compiler will need
help to determine which variables are output variables.

   This keyword will normally be used to complement the CODE:  keyword.
The RETVAL variable is not recognized as an output variable when the CODE:
keyword is present.  The OUTPUT:  keyword is used in this situation to
tell the compiler that RETVAL really is an output variable.

   The OUTPUT: keyword can also be used to indicate that function
parameters are output variables.  This may be necessary when a parameter
has been modified within the function and the programmer would like the
update to be seen by Perl.

     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &timep
        OUTPUT:
          timep

   The OUTPUT: keyword will also allow an output parameter to be mapped to
a matching piece of code rather than to a typemap.

     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &timep
        OUTPUT:
          timep sv_setnv(ST(1), (double)timep);

   xsubpp emits an automatic `SvSETMAGIC()' for all parameters in the
OUTPUT section of the XSUB, except RETVAL.  This is the usually desired
behavior, as it takes care of properly invoking 'set' magic on output
parameters (needed for hash or array element parameters that must be
created if they didn't exist).  If for some reason, this behavior is not
desired, the OUTPUT section may contain a `SETMAGIC: DISABLE' line to
disable it for the remainder of the parameters in the OUTPUT section.
Likewise,  `SETMAGIC: ENABLE' can be used to reenable it for the remainder
of the OUTPUT section.  See *Note Perlguts: perlguts, for more details
about 'set' magic.

The CODE: Keyword
-----------------

   This keyword is used in more complicated XSUBs which require special
handling for the C function.  The RETVAL variable is still declared, but
it will not be returned unless it is specified in the OUTPUT: section.

   The following XSUB is for a C function which requires special handling
of its parameters.  The Perl usage is given first.

     $status = rpcb_gettime( "localhost", $timep );

   The XSUB follows.

     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t timep
        CODE:
               RETVAL = rpcb_gettime( host, &timep );
        OUTPUT:
          timep
          RETVAL

The INIT: Keyword
-----------------

   The INIT: keyword allows initialization to be inserted into the XSUB
before the compiler generates the call to the C function.  Unlike the
CODE: keyword above, this keyword does not affect the way the compiler
handles RETVAL.

     bool_t
     rpcb_gettime(host,timep)
           char *host
           time_t &timep
     	INIT:
     	  printf("# Host is %s\n", host );
         OUTPUT:
           timep

   Another use for the INIT: section is to check for preconditions before
making a call to the C function:

     long long
     lldiv(a,b)
     	long long a
     	long long b
       INIT:
     	if (a == 0 && b == 0)
     	    XSRETURN_UNDEF;
     	if (b == 0)
     	    croak("lldiv: cannot divide by 0");

The NO_INIT Keyword
-------------------

   The NO_INIT keyword is used to indicate that a function parameter is
being used only as an output value.  The xsubpp compiler will normally
generate code to read the values of all function parameters from the
argument stack and assign them to C variables upon entry to the function.
NO_INIT will tell the compiler that some parameters will be used for
output rather than for input and that they will be handled before the
function terminates.

   The following example shows a variation of the rpcb_gettime() function.
This function uses the timep variable only as an output variable and does
not care about its initial contents.

     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &timep = NO_INIT
        OUTPUT:
          timep

Initializing Function Parameters
--------------------------------

   C function parameters are normally initialized with their values from
the argument stack (which in turn contains the parameters that were passed
to the XSUB from Perl).  The typemaps contain the code segments which are
used to translate the Perl values to the C parameters.  The programmer,
however, is allowed to override the typemaps and supply alternate (or
additional) initialization code.  Initialization code starts with the first
=, `;' or + on a line in the INPUT: section.  The only exception happens
if this `;' terminates the line, then this `;' is quietly ignored.

   The following code demonstrates how to supply initialization code for
function parameters.  The initialization code is eval'd within double
quotes by the compiler before it is added to the output so anything which
should be interpreted literally [mainly `$', `@', or \\] must be protected
with backslashes.  The variables $var, $arg, and $type can be used as in
typemaps.

     bool_t
     rpcb_gettime(host,timep)
          char *host = (char *)SvPV($arg,PL_na);
          time_t &timep = 0;
        OUTPUT:
          timep

   This should not be used to supply default values for parameters.  One
would normally use this when a function parameter must be processed by
another library function before it can be used.  Default parameters are
covered in the next section.

   If the initialization begins with =, then it is output in the
declaration for the input variable, replacing the initialization supplied
by the typemap.  If the initialization begins with `;' or +, then it is
performed after all of the input variables have been declared.  In the `;'
case the initialization normally supplied by the typemap is not performed.
For the + case, the declaration for the variable will include the
initialization from the typemap.  A global variable, `%v', is available
for the truly rare case where information from one initialization is
needed in another initialization.

   Here's a truly obscure example:

     bool_t
     rpcb_gettime(host,timep)
          time_t &timep ; /* \$v{timep}=@{[$v{timep}=$arg]} */
          char *host + SvOK($v{timep}) ? SvPV($arg,PL_na) : NULL;
        OUTPUT:
          timep

   The construct `\$v{timep}=@{[$v{timep}=$arg]}' used in the above
example has a two-fold purpose: first, when this line is processed by
xsubpp, the Perl snippet `$v{timep}=$arg' is evaluated.  Second, the text
of the evaluated snippet is output into the generated C file (inside a C
comment)!  During the processing of `char *host' line, $arg will evaluate
to `ST(0)', and `$v{timep}' will evaluate to `ST(1)'.

Default Parameter Values
------------------------

   Default values for XSUB arguments can be specified by placing an
assignment statement in the parameter list.  The default value may be a
number, a string or the special string `NO_INIT'.  Defaults should always
be used on the right-most parameters only.

   To allow the XSUB for rpcb_gettime() to have a default host value the
parameters to the XSUB could be rearranged.  The XSUB will then call the
real rpcb_gettime() function with the parameters in the correct order.
This XSUB can be called from Perl with either of the following statements:

     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );

   The XSUB will look like the code  which  follows.   A  CODE: block  is
used to call the real rpcb_gettime() function with the parameters in the
correct order for that function.

     bool_t
     rpcb_gettime(timep,host="localhost")
          char *host
          time_t timep = NO_INIT
        CODE:
               RETVAL = rpcb_gettime( host, &timep );
        OUTPUT:
          timep
          RETVAL

The PREINIT: Keyword
--------------------

   The PREINIT: keyword allows extra variables to be declared immediately
before or after the declartions of the parameters from the INPUT: section
are emitted.

   If a variable is declared inside a CODE: section it will follow any
typemap code that is emitted for the input parameters.  This may result in
the declaration ending up after C code, which is C syntax error.  Similar
errors may happen with an explicit `;'-type or +-type initialization of
parameters is used (see `"Initializing Function Parameters"' in this
node).  Declaring these variables in an INIT: section will not help.

   In such cases, to force an additional variable to be declared together
with declarations of other variables, place the declaration into a
PREINIT: section.  The PREINIT: keyword may be used one or more times
within an XSUB.

   The following examples are equivalent, but if the code is using complex
typemaps then the first example is safer.

     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
     	PREINIT:
          char *host = "localhost";
        CODE:
     	  RETVAL = rpcb_gettime( host, &timep );
        OUTPUT:
          timep
          RETVAL

   For this particular case an INIT: keyword would generate the same C
code as the PREINIT: keyword.  Another correct, but error-prone example:

     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
     	CODE:
          char *host = "localhost";
     	  RETVAL = rpcb_gettime( host, &timep );
        OUTPUT:
          timep
          RETVAL

   Another way to declare host is to use a C block in the CODE: section:

     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
     	CODE:
     	  {
            char *host = "localhost";
     	    RETVAL = rpcb_gettime( host, &timep );
     	  }
        OUTPUT:
          timep
          RETVAL

   The ability to put additional declarations before the typemap entries
are processed is very handy in the cases when typemap conversions
manipulate some global state:

     MyObject
     mutate(o)
     	PREINIT:
     	    MyState st = global_state;
     	INPUT:
     	    MyObject o;
     	CLEANUP:
     	    reset_to(global_state, st);

   Here we suppose that conversion to `MyObject' in the INPUT: section and
from MyObject when processing RETVAL will modify a global variable
`global_state'.  After these conversions are performed, we restore the old
value of `global_state' (to avoid memory leaks, for example).

   There is another way to trade clarity for compactness: INPUT sections
allow declaration of C variables which do not appear in the parameter list
of a subroutine.  Thus the above code for mutate() can be rewritten as

     MyObject
     mutate(o)
     	  MyState st = global_state;
     	  MyObject o;
     	CLEANUP:
     	  reset_to(global_state, st);

   and the code for rpcb_gettime() can be rewritten as

     bool_t
     rpcb_gettime(timep)
     	  time_t timep = NO_INIT
     	  char *host = "localhost";
     	C_ARGS:
     	  host, &timep
     	OUTPUT:
          timep
          RETVAL

The SCOPE: Keyword
------------------

   The SCOPE: keyword allows scoping to be enabled for a particular XSUB.
If enabled, the XSUB will invoke ENTER and LEAVE automatically.

   To support potentially complex type mappings, if a typemap entry used
by an XSUB contains a comment like `/*scope*/' then scoping will be
automatically enabled for that XSUB.

   To enable scoping:

     SCOPE: ENABLE

   To disable scoping:

     SCOPE: DISABLE

The INPUT: Keyword
------------------

   The XSUB's parameters are usually evaluated immediately after entering
the XSUB.  The INPUT: keyword can be used to force those parameters to be
evaluated a little later.  The INPUT: keyword can be used multiple times
within an XSUB and can be used to list one or more input variables.  This
keyword is used with the PREINIT: keyword.

   The following example shows how the input parameter `timep' can be
evaluated late, after a PREINIT.

     bool_t
     rpcb_gettime(host,timep)
           char *host
     	PREINIT:
     	  time_t tt;
     	INPUT:
           time_t timep
         CODE:
                RETVAL = rpcb_gettime( host, &tt );
     	       timep = tt;
         OUTPUT:
           timep
           RETVAL

   The next example shows each input parameter evaluated late.

     bool_t
     rpcb_gettime(host,timep)
     	PREINIT:
     	  time_t tt;
     	INPUT:
           char *host
     	PREINIT:
     	  char *h;
     	INPUT:
           time_t timep
         CODE:
     	       h = host;
     	       RETVAL = rpcb_gettime( h, &tt );
     	       timep = tt;
         OUTPUT:
           timep
           RETVAL

   Since INPUT sections allow declaration of C variables which do not
appear in the parameter list of a subroutine, this may be shortened to:

     bool_t
     rpcb_gettime(host,timep)
     	  time_t tt;
           char *host;
     	  char *h = host;
           time_t timep;
         CODE:
     	  RETVAL = rpcb_gettime( h, &tt );
     	  timep = tt;
         OUTPUT:
           timep
           RETVAL

   (We used our knowledge that input conversion for `char *' is a "simple"
one, thus host is initialized on the declaration line, and our assignment
`h = host' is not performed too early.  Otherwise one would need to have
the assignment `h = host' in a CODE: or INIT: section.)

Variable-length Parameter Lists
-------------------------------

   XSUBs can have variable-length parameter lists by specifying an ellipsis
`(...)' in the parameter list.  This use of the ellipsis is similar to that
found in ANSI C.  The programmer is able to determine the number of
arguments passed to the XSUB by examining the items variable which the
xsubpp compiler supplies for all XSUBs.  By using this mechanism one can
create an XSUB which accepts a list of parameters of unknown length.

   The host parameter for the rpcb_gettime() XSUB can be optional so the
ellipsis can be used to indicate that the XSUB will take a variable number
of parameters.  Perl should be able to call this XSUB with either of the
following statements.

     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );

   The XS code, with ellipsis, follows.

     bool_t
     rpcb_gettime(timep, ...)
          time_t timep = NO_INIT
     	PREINIT:
          char *host = "localhost";
     	  STRLEN n_a;
        CODE:
     	  if( items > 1 )
     	       host = (char *)SvPV(ST(1), n_a);
     	  RETVAL = rpcb_gettime( host, &timep );
        OUTPUT:
          timep
          RETVAL

The C_ARGS: Keyword
-------------------

   The C_ARGS: keyword allows creating of XSUBS which have different
calling sequence from Perl than from C, without a need to write CODE: or
PPCODE: section.  The contents of the C_ARGS: paragraph is put as the
argument to the called C function without any change.

   For example, suppose that a C function is declared as

     symbolic nth_derivative(int n, symbolic function, int flags);

   and that the default flags are kept in a global C variable
`default_flags'.  Suppose that you want to create an interface which is
called as

     $second_deriv = $function->nth_derivative(2);

   To do this, declare the XSUB as

     symbolic
     nth_derivative(function, n)
     	symbolic	function
     	int		n
       C_ARGS:
     	n, function, default_flags

The PPCODE: Keyword
-------------------

   The PPCODE: keyword is an alternate form of the CODE: keyword and is
used to tell the xsubpp compiler that the programmer is supplying the code
to control the argument stack for the XSUBs return values.  Occasionally
one will want an XSUB to return a list of values rather than a single
value.  In these cases one must use PPCODE: and then explicitly push the
list of values on the stack.  The PPCODE: and CODE:  keywords should not
be used together within the same XSUB.

   The actual difference between PPCODE: and CODE: sections is in the
initialization of SP macro (which stands for the current Perl stack
pointer), and in the handling of data on the stack when returning from an
XSUB.  In CODE: sections SP preserves the value which was on entry to the
XSUB: SP is on the function pointer (which follows the last parameter).
In PPCODE: sections SP is moved backward to the beginning of the parameter
list, which allows `PUSH*()' macros to place output values in the place
Perl expects them to be when the XSUB returns back to Perl.

   The generated trailer for a CODE: section ensures that the number of
return values Perl will see is either 0 or 1 (depending on the voidness of
the return value of the C function, and heuristics mentioned in `"The
RETVAL Variable"' in this node).  The trailer generated for a PPCODE:
section is based on the number of return values and on the number of times
SP was updated by `[X]PUSH*()' macros.

   Note that macros `ST(i)', `XST_m*()' and `XSRETURN*()' work equally
well in CODE: sections and PPCODE: sections.

   The following XSUB will call the C rpcb_gettime() function and will
return its two output values, timep and status, to Perl as a single list.

     void
     rpcb_gettime(host)
          char *host
     	PREINIT:
          time_t  timep;
          bool_t  status;
        PPCODE:
          status = rpcb_gettime( host, &timep );
          EXTEND(SP, 2);
          PUSHs(sv_2mortal(newSViv(status)));
          PUSHs(sv_2mortal(newSViv(timep)));

   Notice that the programmer must supply the C code necessary to have the
real rpcb_gettime() function called and to have the return values properly
placed on the argument stack.

   The void return type for this function tells the xsubpp compiler that
the RETVAL variable is not needed or used and that it should not be
created.  In most scenarios the void return type should be used with the
PPCODE: directive.

   The EXTEND() macro is used to make room on the argument stack for 2
return values.  The PPCODE: directive causes the xsubpp compiler to create
a stack pointer available as SP, and it is this pointer which is being
used in the EXTEND() macro.  The values are then pushed onto the stack
with the PUSHs() macro.

   Now the rpcb_gettime() function can be used from Perl with the
following statement.

     ($status, $timep) = rpcb_gettime("localhost");

   When handling output parameters with a PPCODE section, be sure to handle
'set' magic properly.  See *Note Perlguts: perlguts, for details about
'set' magic.

Returning Undef And Empty Lists
-------------------------------

   Occasionally the programmer will want to return simply undef or an
empty list if a function fails rather than a separate status value.  The
rpcb_gettime() function offers just this situation.  If the function
succeeds we would like to have it return the time and if it fails we would
like to have undef returned.  In the following Perl code the value of
$timep will either be undef or it will be a valid time.

     $timep = rpcb_gettime( "localhost" );

   The following XSUB uses the `SV *' return type as a mnemonic only, and
uses a CODE: block to indicate to the compiler that the programmer has
supplied all the necessary code.  The sv_newmortal() call will initialize
the return value to undef, making that the default return value.

     SV *
     rpcb_gettime(host)
          char *  host
     	PREINIT:
          time_t  timep;
          bool_t x;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) )
               sv_setnv( ST(0), (double)timep);

   The next example demonstrates how one would place an explicit undef in
the return value, should the need arise.

     SV *
     rpcb_gettime(host)
          char *  host
     	PREINIT:
          time_t  timep;
          bool_t x;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) ){
               sv_setnv( ST(0), (double)timep);
          }
          else{
               ST(0) = &PL_sv_undef;
          }

   To return an empty list one must use a PPCODE: block and then not push
return values on the stack.

     void
     rpcb_gettime(host)
          char *host
     	PREINIT:
          time_t  timep;
        PPCODE:
          if( rpcb_gettime( host, &timep ) )
               PUSHs(sv_2mortal(newSViv(timep)));
          else{
     	      /* Nothing pushed on stack, so an empty
     	       * list is implicitly returned. */
          }

   Some people may be inclined to include an explicit return in the above
XSUB, rather than letting control fall through to the end.  In those
situations XSRETURN_EMPTY should be used, instead.  This will ensure that
the XSUB stack is properly adjusted.  Consult `"API LISTING"', *Note
Perlguts: perlguts, for other XSRETURN macros.

   Since `XSRETURN_*' macros can be used with CODE blocks as well, one can
rewrite this example as:

     int
     rpcb_gettime(host)
          char *host
     	PREINIT:
          time_t  timep;
        CODE:
          RETVAL = rpcb_gettime( host, &timep );
     	  if (RETVAL == 0)
     		XSRETURN_UNDEF;
     	OUTPUT:
     	  RETVAL

   In fact, one can put this check into a CLEANUP: section as well.
Together with PREINIT: simplifications, this leads to:

     int
     rpcb_gettime(host)
          char *host
          time_t  timep;
     	CLEANUP:
     	  if (RETVAL == 0)
     		XSRETURN_UNDEF;

The REQUIRE: Keyword
--------------------

   The REQUIRE: keyword is used to indicate the minimum version of the
xsubpp compiler needed to compile the XS module.  An XS module which
contains the following statement will compile with only xsubpp version
1.922 or greater:

     REQUIRE: 1.922

The CLEANUP: Keyword
--------------------

   This keyword can be used when an XSUB requires special cleanup
procedures before it terminates.  When the CLEANUP:  keyword is used it
must follow any CODE:, PPCODE:, or OUTPUT: blocks which are present in the
XSUB.  The code specified for the cleanup block will be added as the last
statements in the XSUB.

The BOOT: Keyword
-----------------

   The BOOT: keyword is used to add code to the extension's bootstrap
function.  The bootstrap function is generated by the xsubpp compiler and
normally holds the statements necessary to register any XSUBs with Perl.
With the BOOT: keyword the programmer can tell the compiler to add extra
statements to the bootstrap function.

   This keyword may be used any time after the first MODULE keyword and
should appear on a line by itself.  The first blank line after the keyword
will terminate the code block.

     BOOT:
     # The following message will be printed when the
     # bootstrap function executes.
     printf("Hello from the bootstrap!\n");

The VERSIONCHECK: Keyword
-------------------------

   The VERSIONCHECK: keyword corresponds to xsubpp's `-versioncheck' and
`-noversioncheck' options.  This keyword overrides the command line
options.  Version checking is enabled by default.  When version checking is
enabled the XS module will attempt to verify that its version matches the
version of the PM module.

   To enable version checking:

     VERSIONCHECK: ENABLE

   To disable version checking:

     VERSIONCHECK: DISABLE

The PROTOTYPES: Keyword
-----------------------

   The PROTOTYPES: keyword corresponds to xsubpp's `-prototypes' and
`-noprototypes' options.  This keyword overrides the command line options.
Prototypes are enabled by default.  When prototypes are enabled XSUBs will
be given Perl prototypes.  This keyword may be used multiple times in an XS
module to enable and disable prototypes for different parts of the module.

   To enable prototypes:

     PROTOTYPES: ENABLE

   To disable prototypes:

     PROTOTYPES: DISABLE

The PROTOTYPE: Keyword
----------------------

   This keyword is similar to the PROTOTYPES: keyword above but can be
used to force xsubpp to use a specific prototype for the XSUB.  This
keyword overrides all other prototype options and keywords but affects
only the current XSUB.  Consult `Prototypes', *Note Perlsub: perlsub, for
information about Perl prototypes.

     bool_t
     rpcb_gettime(timep, ...)
           time_t timep = NO_INIT
     	PROTOTYPE: $;$
     	PREINIT:
           char *host = "localhost";
     	  STRLEN n_a;
         CODE:
     		  if( items > 1 )
     		       host = (char *)SvPV(ST(1), n_a);
     		  RETVAL = rpcb_gettime( host, &timep );
         OUTPUT:
           timep
           RETVAL

The ALIAS: Keyword
------------------

   The ALIAS: keyword allows an XSUB to have two or more unique Perl names
and to know which of those names was used when it was invoked.  The Perl
names may be fully-qualified with package names.  Each alias is given an
index.  The compiler will setup a variable called ix which contain the
index of the alias which was used.  When the XSUB is called with its
declared name ix will be 0.

   The following example will create aliases `FOO::gettime()' and
`BAR::getit()' for this function.

     bool_t
     rpcb_gettime(host,timep)
           char *host
           time_t &timep
     	ALIAS:
     	    FOO::gettime = 1
     	    BAR::getit = 2
     	INIT:
     	  printf("# ix = %d\n", ix );
         OUTPUT:
           timep

The INTERFACE: Keyword
----------------------

   This keyword declares the current XSUB as a keeper of the given calling
signature.  If some text follows this keyword, it is considered as a list
of functions which have this signature, and should be attached to the
current XSUB.

   For example, if you have 4 C functions multiply(), divide(), add(),
subtract() all having the signature:

     symbolic f(symbolic, symbolic);

   you can make them all to use the same XSUB using this:

     symbolic
     interface_s_ss(arg1, arg2)
     	symbolic	arg1
     	symbolic	arg2
     INTERFACE:
     	multiply divide
     	add subtract

   (This is the complete XSUB code for 4 Perl functions!)  Four generated
Perl function share names with corresponding C functions.

   The advantage of this approach comparing to ALIAS: keyword is that there
is no need to code a switch statement, each Perl function (which shares
the same XSUB) knows which C function it should call.  Additionally, one
can attach an extra function remainder() at runtime by using

     CV *mycv = newXSproto("Symbolic::remainder",
     			  XS_Symbolic_interface_s_ss, __FILE__, "$$");
     XSINTERFACE_FUNC_SET(mycv, remainder);

   say, from another XSUB.  (This example supposes that there was no
INTERFACE_MACRO: section, otherwise one needs to use something else
instead of `XSINTERFACE_FUNC_SET', see the next section.)

The INTERFACE_MACRO: Keyword
----------------------------

   This keyword allows one to define an INTERFACE using a different way to
extract a function pointer from an XSUB.  The text which follows this
keyword should give the name of macros which would extract/set a function
pointer.  The extractor macro is given return type, `CV*', and
`XSANY.any_dptr' for this `CV*'.  The setter macro is given cv, and the
function pointer.

   The default value is `XSINTERFACE_FUNC' and `XSINTERFACE_FUNC_SET'.  An
INTERFACE keyword with an empty list of functions can be omitted if
INTERFACE_MACRO keyword is used.

   Suppose that in the previous example functions pointers for multiply(),
divide(), add(), subtract() are kept in a global C array `fp[]' with
offsets being `multiply_off', `divide_off', `add_off', `subtract_off'.
Then one can use

     #define XSINTERFACE_FUNC_BYOFFSET(ret,cv,f) \
     	((XSINTERFACE_CVT(ret,))fp[CvXSUBANY(cv).any_i32])
     #define XSINTERFACE_FUNC_BYOFFSET_set(cv,f) \
     	CvXSUBANY(cv).any_i32 = CAT2( f, _off )

   in C section,

     symbolic
     interface_s_ss(arg1, arg2)
     	symbolic	arg1
     	symbolic	arg2
       INTERFACE_MACRO:
     	XSINTERFACE_FUNC_BYOFFSET
     	XSINTERFACE_FUNC_BYOFFSET_set
       INTERFACE:
     	multiply divide
     	add subtract

   in XSUB section.

The INCLUDE: Keyword
--------------------

   This keyword can be used to pull other files into the XS module.  The
other files may have XS code.  INCLUDE: can also be used to run a command
to generate the XS code to be pulled into the module.

   The file `Rpcb1.xsh' contains our `rpcb_gettime()' function:

     bool_t
     rpcb_gettime(host,timep)
           char *host
           time_t &timep
         OUTPUT:
           timep

   The XS module can use INCLUDE: to pull that file into it.

     INCLUDE: Rpcb1.xsh

   If the parameters to the INCLUDE: keyword are followed by a pipe (|)
then the compiler will interpret the parameters as a command.

     INCLUDE: cat Rpcb1.xsh |

The CASE: Keyword
-----------------

   The CASE: keyword allows an XSUB to have multiple distinct parts with
each part acting as a virtual XSUB.  CASE: is greedy and if it is used
then all other XS keywords must be contained within a CASE:.  This means
nothing may precede the first CASE: in the XSUB and anything following the
last CASE: is included in that case.

   A CASE: might switch via a parameter of the XSUB, via the ix ALIAS:
variable (see `"The ALIAS: Keyword"' in this node), or maybe via the items
variable (see `"Variable-length Parameter Lists"' in this node).  The last
CASE: becomes the default case if it is not associated with a conditional.
The following example shows CASE switched via ix with a function
`rpcb_gettime()' having an alias `x_gettime()'.  When the function is
called as `rpcb_gettime()' its parameters are the usual `(char *host,
time_t *timep)', but when the function is called as `x_gettime()' its
parameters are reversed, `(time_t *timep, char *host)'.

     long
     rpcb_gettime(a,b)
       CASE: ix == 1
     	ALIAS:
     	  x_gettime = 1
     	INPUT:
     	  # 'a' is timep, 'b' is host
           char *b
           time_t a = NO_INIT
         CODE:
                RETVAL = rpcb_gettime( b, &a );
         OUTPUT:
           a
           RETVAL
       CASE:
     	  # 'a' is host, 'b' is timep
           char *a
           time_t &b = NO_INIT
         OUTPUT:
           b
           RETVAL

   That function can be called with either of the following statements.
Note the different argument lists.

     $status = rpcb_gettime( $host, $timep );

     $status = x_gettime( $timep, $host );

The & Unary Operator
--------------------

   The & unary operator in the INPUT: section is used to tell xsubpp that
it should convert a Perl value to/from C using the C type to the left of
&, but provide a pointer to this value when the C function is called.

   This is useful to avoid a CODE: block for a C function which takes a
parameter by reference.  Typically, the parameter should be not a pointer
type (an int or long but not a `int*' or `long*').

   The following XSUB will generate incorrect C code.  The xsubpp compiler
will turn this into code which calls `rpcb_gettime()' with parameters
`(char *host, time_t timep)', but the real `rpcb_gettime()' wants the
`timep' parameter to be of type `time_t*' rather than `time_t'.

     bool_t
     rpcb_gettime(host,timep)
           char *host
           time_t timep
         OUTPUT:
           timep

   That problem is corrected by using the & operator.  The xsubpp compiler
will now turn this into code which calls `rpcb_gettime()' correctly with
parameters `(char *host, time_t *timep)'.  It does this by carrying the &
through, so the function call looks like `rpcb_gettime(host, &timep)'.

     bool_t
     rpcb_gettime(host,timep)
           char *host
           time_t &timep
         OUTPUT:
           timep

Inserting Comments and C Preprocessor Directives
------------------------------------------------

   C preprocessor directives are allowed within BOOT:, PREINIT: INIT:,
CODE:, PPCODE:, and CLEANUP: blocks, as well as outside the functions.
Comments are allowed anywhere after the MODULE keyword.  The compiler will
pass the preprocessor directives through untouched and will remove the
commented lines.

   Comments can be added to XSUBs by placing a `#' as the first
non-whitespace of a line.  Care should be taken to avoid making the
comment look like a C preprocessor directive, lest it be interpreted as
such.  The simplest way to prevent this is to put whitespace in front of
the `#'.

   If you use preprocessor directives to choose one of two versions of a
function, use

     #if ... version1
     #else /* ... version2  */
     #endif

   and not

     #if ... version1
     #endif
     #if ... version2
     #endif

   because otherwise xsubpp will believe that you made a duplicate
definition of the function.  Also, put a blank line before the
#else/#endif so it will not be seen as part of the function body.

Using XS With C++
-----------------

   If an XSUB name contains `::', it is considered to be a C++ method.
The generated Perl function will assume that its first argument is an
object pointer.  The object pointer will be stored in a variable called
THIS.  The object should have been created by C++ with the new() function
and should be blessed by Perl with the sv_setref_pv() macro.  The blessing
of the object by Perl can be handled by a typemap.  An example typemap is
shown at the end of this section.

   If the return type of the XSUB includes static, the method is considered
to be a static method.  It will call the C++ function using the
class::method() syntax.  If the method is not static the function will be
called using the THIS->method() syntax.

   The next examples will use the following C++ class.

     class color {
          public:
          color();
          ~color();
          int blue();
          void set_blue( int );

     private:
     int c_blue;
          };

   The XSUBs for the blue() and set_blue() methods are defined with the
class name but the parameter for the object (THIS, or "self") is implicit
and is not listed.

     int
     color::blue()

     void
     color::set_blue( val )
          int val

   Both Perl functions will expect an object as the first parameter.  In
the generated C++ code the object is called THIS, and the method call will
be performed on this object.  So in the C++ code the blue() and set_blue()
methods will be called as this:

     RETVAL = THIS->blue();

     THIS->set_blue( val );

   You could also write a single get/set method using an optional argument:

     int
     color::blue( val = NO_INIT )
         int val
         PROTOTYPE $;$
         CODE:
             if (items > 1)
                 THIS->set_blue( val );
             RETVAL = THIS->blue();
         OUTPUT:
             RETVAL

   If the function's name is DESTROY then the C++ delete function will be
called and THIS will be given as its parameter.  The generated C++ code for

     void
     color::DESTROY()

   will look like this:

     color *THIS = ...;	// Initialized as in typemap

     delete THIS;

   If the function's name is new then the C++ new function will be called
to create a dynamic C++ object.  The XSUB will expect the class name, which
will be kept in a variable called CLASS, to be given as the first argument.

     color *
     color::new()

   The generated C++ code will call new.

     RETVAL = new color();

   The following is an example of a typemap that could be used for this C++
example.

     TYPEMAP
     color *		O_OBJECT

     OUTPUT
     # The Perl object is blessed into 'CLASS', which should be a
     # char* having the name of the package for the blessing.
     O_OBJECT
     	sv_setref_pv( $arg, CLASS, (void*)$var );

     INPUT
     O_OBJECT
     	if( sv_isobject($arg) && (SvTYPE(SvRV($arg)) == SVt_PVMG) )
     		$var = ($type)SvIV((SV*)SvRV( $arg ));
     	else{
     		warn( \"${Package}::$func_name() -- $var is not a blessed SV reference\" );
     		XSRETURN_UNDEF;
     	}

Interface Strategy
------------------

   When designing an interface between Perl and a C library a straight
translation from C to XS (such as created by `h2xs -x') is often
sufficient.  However, sometimes the interface will look very C-like and
occasionally nonintuitive, especially when the C function modifies one of
its parameters, or returns failure inband (as in "negative return values
mean failure").  In cases where the programmer wishes to create a more
Perl-like interface the following strategy may help to identify the more
critical parts of the interface.

   Identify the C functions with input/output or output parameters.  The
XSUBs for these functions may be able to return lists to Perl.

   Identify the C functions which use some inband info as an indication of
failure.  They may be candidates to return undef or an empty list in case
of failure.  If the failure may be detected without a call to the C
function, you may want to use an INIT: section to report the failure.  For
failures detectable after the C function returns one may want to use a
CLEANUP: section to process the failure.  In more complicated cases use
CODE: or PPCODE: sections.

   If many functions use the same failure indication based on the return
value, you may want to create a special typedef to handle this situation.
Put

     typedef int negative_is_failure;

   near the beginning of XS file, and create an OUTPUT typemap entry for
`negative_is_failure' which converts negative values to undef, or maybe
croak()s.  After this the return value of type `negative_is_failure' will
create more Perl-like interface.

   Identify which values are used by only the C and XSUB functions
themselves, say, when a parameter to a function should be a contents of a
global variable.  If Perl does not need to access the contents of the value
then it may not be necessary to provide a translation for that value from
C to Perl.

   Identify the pointers in the C function parameter lists and return
values.  Some pointers may be used to implement input/output or output
parameters, they can be handled in XS with the & unary operator, and,
possibly, using the NO_INIT keyword.  Some others will require handling of
types like `int *', and one needs to decide what a useful Perl translation
will do in such a case.  When the semantic is clear, it is advisable to
put the translation into a typemap file.

   Identify the structures used by the C functions.  In many cases it may
be helpful to use the T_PTROBJ typemap for these structures so they can be
manipulated by Perl as blessed objects.  (This is handled automatically by
`h2xs -x'.)

   If the same C type is used in several different contexts which require
different translations, `typedef' several new types mapped to this C type,
and create separate `typemap' entries for these new types.  Use these
types in declarations of return type and parameters to XSUBs.

Perl Objects And C Structures
-----------------------------

   When dealing with C structures one should select either *T_PTROBJ* or
*T_PTRREF* for the XS type.  Both types are designed to handle pointers to
complex objects.  The T_PTRREF type will allow the Perl object to be
unblessed while the T_PTROBJ type requires that the object be blessed.  By
using T_PTROBJ one can achieve a form of type-checking because the XSUB
will attempt to verify that the Perl object is of the expected type.

   The following XS code shows the getnetconfigent() function which is used
with ONC+ TIRPC.  The getnetconfigent() function will return a pointer to a
C structure and has the C prototype shown below.  The example will
demonstrate how the C pointer will become a Perl reference.  Perl will
consider this reference to be a pointer to a blessed object and will
attempt to call a destructor for the object.  A destructor will be
provided in the XS source to free the memory used by getnetconfigent().
Destructors in XS can be created by specifying an XSUB function whose name
ends with the word DESTROY.  XS destructors can be used to free memory
which may have been malloc'd by another XSUB.

     struct netconfig *getnetconfigent(const char *netid);

   A `typedef' will be created for `struct netconfig'.  The Perl object
will be blessed in a class matching the name of the C type, with the tag
`Ptr' appended, and the name should not have embedded spaces if it will be
a Perl package name.  The destructor will be placed in a class
corresponding to the class of the object and the PREFIX keyword will be
used to trim the name to the word DESTROY as Perl will expect.

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     Netconfig *
     getnetconfigent(netid)
          char *netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf("Now in NetconfigPtr::DESTROY\n");
          free( netconf );

   This example requires the following typemap entry.  Consult the typemap
section for more information about adding new typemaps for an extension.

     TYPEMAP
     Netconfig *  T_PTROBJ

   This example will be used with the following Perl statements.

     use RPC;
     $netconf = getnetconfigent("udp");

   When Perl destroys the object referenced by $netconf it will send the
object to the supplied XSUB DESTROY function.  Perl cannot determine, and
does not care, that this object is a C struct and not a Perl object.  In
this sense, there is no difference between the object created by the
getnetconfigent() XSUB and an object created by a normal Perl subroutine.

The Typemap
-----------

   The typemap is a collection of code fragments which are used by the
xsubpp compiler to map C function parameters and values to Perl values.
The typemap file may consist of three sections labeled `TYPEMAP', INPUT,
and OUTPUT.  An unlabelled initial section is assumed to be a `TYPEMAP'
section.  The INPUT section tells the compiler how to translate Perl values
into variables of certain C types.  The OUTPUT section tells the compiler
how to translate the values from certain C types into values Perl can
understand.  The TYPEMAP section tells the compiler which of the INPUT and
OUTPUT code fragments should be used to map a given C type to a Perl value.
The section labels `TYPEMAP', INPUT, or OUTPUT must begin in the first
column on a line by themselves, and must be in uppercase.

   The default typemap in the ext directory of the Perl source contains
many useful types which can be used by Perl extensions.  Some extensions
define additional typemaps which they keep in their own directory.  These
additional typemaps may reference INPUT and OUTPUT maps in the main
typemap.  The xsubpp compiler will allow the extension's own typemap to
override any mappings which are in the default typemap.

   Most extensions which require a custom typemap will need only the
TYPEMAP section of the typemap file.  The custom typemap used in the
getnetconfigent() example shown earlier demonstrates what may be the
typical use of extension typemaps.  That typemap is used to equate a C
structure with the T_PTROBJ typemap.  The typemap used by
getnetconfigent() is shown here.  Note that the C type is separated from
the XS type with a tab and that the C unary operator * is considered to be
a part of the C type name.

     TYPEMAP
     Netconfig *<tab>T_PTROBJ

   Here's a more complicated example: suppose that you wanted `struct
netconfig' to be blessed into the class `Net::Config'.  One way to do this
is to use underscores (_) to separate package names, as follows:

     typedef struct netconfig * Net_Config;

   And then provide a typemap entry `T_PTROBJ_SPECIAL' that maps
underscores to double-colons (::), and declare `Net_Config' to be of that
type:

     TYPEMAP
     Net_Config      T_PTROBJ_SPECIAL

     INPUT
     T_PTROBJ_SPECIAL
             if (sv_derived_from($arg, \"${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\")) {
                     IV tmp = SvIV((SV*)SvRV($arg));
             $var = ($type) tmp;
             }
             else
                     croak(\"$var is not of type ${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\")

     OUTPUT
     T_PTROBJ_SPECIAL
             sv_setref_pv($arg, \"${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\",
             (void*)$var);

   The INPUT and OUTPUT sections substitute underscores for double-colons
on the fly, giving the desired effect.  This example demonstrates some of
the power and versatility of the typemap facility.

EXAMPLES
========

   File `RPC.xs': Interface to some ONC+ RPC bind library functions.

     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"

     #include <rpc/rpc.h>

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     SV *
     rpcb_gettime(host="localhost")
          char *host
     	PREINIT:
          time_t  timep;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &timep ) )
               sv_setnv( ST(0), (double)timep );

     Netconfig *
     getnetconfigent(netid="udp")
          char *netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf("NetconfigPtr::DESTROY\n");
          free( netconf );

   File `typemap': Custom typemap for RPC.xs.

     TYPEMAP
     Netconfig *  T_PTROBJ

   File `RPC.pm': Perl module for the RPC extension.

     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw(rpcb_gettime getnetconfigent);

     bootstrap RPC;
     1;

   File `rpctest.pl': Perl test program for the RPC extension.

     use RPC;

     $netconf = getnetconfigent();
     $a = rpcb_gettime();
     print "time = $a\n";
     print "netconf = $netconf\n";

     $netconf = getnetconfigent("tcp");
     $a = rpcb_gettime("poplar");
     print "time = $a\n";
     print "netconf = $netconf\n";

XS VERSION
==========

   This document covers features supported by xsubpp 1.935.

AUTHOR
======

   Originally written by Dean Roehrich <`roehrich@cray.com'>.

   Maintained since 1996 by The Perl Porters <`perlbug@perl.com'>.


File: perl.info,  Node: perlxstut,  Next: perlguts,  Prev: perlxs,  Up: Top

Tutorial for writing XSUBs
**************************

NAME
====

   perlXStut - Tutorial for writing XSUBs

DESCRIPTION
===========

   This tutorial will educate the reader on the steps involved in creating
a Perl extension.  The reader is assumed to have access to *Note Perlguts:
perlguts, and *Note Perlxs: perlxs,.

   This tutorial starts with very simple examples and becomes more complex,
with each new example adding new features.  Certain concepts may not be
completely explained until later in the tutorial in order to slowly ease
the reader into building extensions.

   This tutorial was written from a Unix point of view.  Where I know them
to be otherwise different for other platforms (e.g. Win32), I will list
them.  If you find something that was missed, please let me know.

SPECIAL NOTES
=============

make
----

   This tutorial assumes that the make program that Perl is configured to
use is called make.  Instead of running "make" in the examples that
follow, you may have to substitute whatever make program Perl has been
configured to use.  Running *perl -V:make* should tell you what it is.

Version caveat
--------------

   When writing a Perl extension for general consumption, one should
expect that the extension will be used with versions of Perl different
from the version available on your machine.  Since you are reading this
document, the version of Perl on your machine is probably 5.005 or later,
but the users of your extension may have more ancient versions.

   To understand what kinds of incompatibilities one may expect, and in
the rare case that the version of Perl on your machine is older than this
document, see the section on "Troubleshooting these Examples" for more
information.

   If your extension uses some features of Perl which are not available on
older releases of Perl, your users would appreciate an early meaningful
warning.  You would probably put this information into the README file,
but nowadays installation of extensions may be performed automatically,
guided by `CPAN.pm' module or other tools.

   In MakeMaker-based installations, Makefile.PL provides the earliest
opportunity to perform version checks.  One can put something like this in
Makefile.PL for this purpose:

     eval { require 5.007 }
         or die <<EOD;
     ############
     ### This module uses frobnication framework which is not available before
     ### version 5.007 of Perl.  Upgrade your Perl before installing Kara::Mba.
     ############
     EOD

Dynamic Loading versus Static Loading
-------------------------------------

   It is commonly thought that if a system does not have the capability to
dynamically load a library, you cannot build XSUBs.  This is incorrect.
You can build them, but you must link the XSUBs subroutines with the rest
of Perl, creating a new executable.  This situation is similar to Perl 4.

   This tutorial can still be used on such a system.  The XSUB build
mechanism will check the system and build a dynamically-loadable library
if possible, or else a static library and then, optionally, a new
statically-linked executable with that static library linked in.

   Should you wish to build a statically-linked executable on a system
which can dynamically load libraries, you may, in all the following
examples, where the command "make" with no arguments is executed, run the
command "`make perl'" instead.

   If you have generated such a statically-linked executable by choice,
then instead of saying "make test", you should say "`make test_static'".
On systems that cannot build dynamically-loadable libraries at all, simply
saying "make test" is sufficient.

TUTORIAL
========

   Now let's go on with the show!

EXAMPLE 1
---------

   Our first extension will be very simple.  When we call the routine in
the extension, it will print out a well-known message and return.

   Run "`h2xs -A -n Mytest'".  This creates a directory named Mytest,
possibly under ext/ if that directory exists in the current working
directory.  Several files will be created in the Mytest dir, including
MANIFEST, Makefile.PL, Mytest.pm, Mytest.xs, test.pl, and Changes.

   The MANIFEST file contains the names of all the files just created in
the Mytest directory.

   The file Makefile.PL should look something like this:

     use ExtUtils::MakeMaker;
     # See lib/ExtUtils/MakeMaker.pm for details of how to influence
     # the contents of the Makefile that is written.
     WriteMakefile(
         NAME         => 'Mytest',
         VERSION_FROM => 'Mytest.pm', # finds $VERSION
         LIBS         => [''],   # e.g., '-lm'
         DEFINE       => '',     # e.g., '-DHAVE_SOMETHING'
         INC          => '',     # e.g., '-I/usr/include/other'
     );

   The file Mytest.pm should start with something like this:

     package Mytest;

     use strict;
             use warnings;

     require Exporter;
     require DynaLoader;

     our @ISA = qw(Exporter DynaLoader);
     # Items to export into callers namespace by default. Note: do not export
     # names by default without a very good reason. Use EXPORT_OK instead.
     # Do not simply export all your public functions/methods/constants.
     our @EXPORT = qw(

     );
     our $VERSION = '0.01';

     bootstrap Mytest $VERSION;

     # Preloaded methods go here.

     # Autoload methods go after __END__, and are processed by the autosplit program.

     1;
     __END__
     # Below is the stub of documentation for your module. You better edit it!

   The rest of the .pm file contains sample code for providing
documentation for the extension.

   Finally, the Mytest.xs file should look something like this:

     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"

     MODULE = Mytest		PACKAGE = Mytest

   Let's edit the .xs file by adding this to the end of the file:

     void
     hello()
         CODE:
     	printf("Hello, world!\n");

   It is okay for the lines starting at the "CODE:" line to not be
indented.  However, for readability purposes, it is suggested that you
indent CODE: one level and the lines following one more level.

   Now we'll run "`perl Makefile.PL'".  This will create a real Makefile,
which make needs.  Its output looks something like:

     % perl Makefile.PL
     Checking if your kit is complete...
     Looks good
     Writing Makefile for Mytest
     %

   Now, running make will produce output that looks something like this
(some long lines have been shortened for clarity and some extraneous lines
have been deleted):

     % make
     umask 0 && cp Mytest.pm ./blib/Mytest.pm
     perl xsubpp -typemap typemap Mytest.xs >Mytest.tc && mv Mytest.tc Mytest.c
     Please specify prototyping behavior for Mytest.xs (see perlxs manual)
     cc -c Mytest.c
     Running Mkbootstrap for Mytest ()
     chmod 644 Mytest.bs
     LD_RUN_PATH="" ld -o ./blib/PA-RISC1.1/auto/Mytest/Mytest.sl -b Mytest.o
     chmod 755 ./blib/PA-RISC1.1/auto/Mytest/Mytest.sl
     cp Mytest.bs ./blib/PA-RISC1.1/auto/Mytest/Mytest.bs
     chmod 644 ./blib/PA-RISC1.1/auto/Mytest/Mytest.bs
     Manifying ./blib/man3/Mytest.3
     %

   You can safely ignore the line about "prototyping behavior".

   If you are on a Win32 system, and the build process fails with linker
errors for functions in the C library, check if your Perl is configured to
use PerlCRT (running *perl -V:libc* should show you if this is the case).
If Perl is configured to use PerlCRT, you have to make sure PerlCRT.lib is
copied to the same location that msvcrt.lib lives in, so that the compiler
can find it on its own.  msvcrt.lib is usually found in the Visual C
compiler's lib directory (e.g. C:/DevStudio/VC/lib).

   Perl has its own special way of easily writing test scripts, but for
this example only, we'll create our own test script.  Create a file called
hello that looks like this:

     #! /opt/perl5/bin/perl

     use ExtUtils::testlib;

     use Mytest;

     Mytest::hello();

   Now we make the script executable (`chmod -x hello'), run the script
and we should see the following output:

     % ./hello
     Hello, world!
     %

EXAMPLE 2
---------

   Now let's add to our extension a subroutine that will take a single
numeric argument as input and return 0 if the number is even or 1 if the
number is odd.

   Add the following to the end of Mytest.xs:

     int
     is_even(input)
     	int	input
         CODE:
     	RETVAL = (input % 2 == 0);
         OUTPUT:
     	RETVAL

   There does not need to be white space at the start of the "`int input'"
line, but it is useful for improving readability.  Placing a semi-colon at
the end of that line is also optional.  Any amount and kind of white space
may be placed between the "int" and "input".

   Now re-run make to rebuild our new shared library.

   Now perform the same steps as before, generating a Makefile from the
Makefile.PL file, and running make.

   In order to test that our extension works, we now need to look at the
file test.pl.  This file is set up to imitate the same kind of testing
structure that Perl itself has.  Within the test script, you perform a
number of tests to confirm the behavior of the extension, printing "ok"
when the test is correct, "not ok" when it is not.  Change the print
statement in the BEGIN block to print "1..4", and add the following code
to the end of the file:

     print &Mytest::is_even(0) == 1 ? "ok 2" : "not ok 2", "\n";
     print &Mytest::is_even(1) == 0 ? "ok 3" : "not ok 3", "\n";
     print &Mytest::is_even(2) == 1 ? "ok 4" : "not ok 4", "\n";

   We will be calling the test script through the command "make test".  You
should see output that looks something like this:

     % make test
     PERL_DL_NONLAZY=1 /opt/perl5.004/bin/perl (lots of -I arguments) test.pl
     1..4
     ok 1
     ok 2
     ok 3
     ok 4
     %

What has gone on?
-----------------

   The program h2xs is the starting point for creating extensions.  In
later examples we'll see how we can use h2xs to read header files and
generate templates to connect to C routines.

   h2xs creates a number of files in the extension directory.  The file
Makefile.PL is a perl script which will generate a true Makefile to build
the extension.  We'll take a closer look at it later.

   The .pm and .xs files contain the meat of the extension.  The .xs file
holds the C routines that make up the extension.  The .pm file contains
routines that tell Perl how to load your extension.

   Generating the Makefile and running make created a directory called blib
(which stands for "build library") in the current working directory.  This
directory will contain the shared library that we will build.  Once we have
tested it, we can install it into its final location.

   Invoking the test script via "make test" did something very important.
It invoked perl with all those -I arguments so that it could find the
various files that are part of the extension.  It is *very* important that
while you are still testing extensions that you use "make test".  If you
try to run the test script all by itself, you will get a fatal error.
Another reason it is important to use "make test" to run your test script
is that if you are testing an upgrade to an already-existing version,
using "make test" insures that you will test your new extension, not the
already-existing version.

   When Perl sees a `use extension;', it searches for a file with the same
name as the use'd extension that has a .pm suffix.  If that file cannot be
found, Perl dies with a fatal error.  The default search path is contained
in the `@INC' array.

   In our case, Mytest.pm tells perl that it will need the Exporter and
Dynamic Loader extensions.  It then sets the `@ISA' and `@EXPORT' arrays
and the $VERSION scalar; finally it tells perl to bootstrap the module.
Perl will call its dynamic loader routine (if there is one) and load the
shared library.

   The two arrays `@ISA' and `@EXPORT' are very important.  The `@ISA'
array contains a list of other packages in which to search for methods (or
subroutines) that do not exist in the current package.  This is usually
only important for object-oriented extensions (which we will talk about
much later), and so usually doesn't need to be modified.

   The `@EXPORT' array tells Perl which of the extension's variables and
subroutines should be placed into the calling package's namespace.  Because
you don't know if the user has already used your variable and subroutine
names, it's vitally important to carefully select what to export.  Do not
export method or variable names *by default* without a good reason.

   As a general rule, if the module is trying to be object-oriented then
don't export anything.  If it's just a collection of functions and
variables, then you can export them via another array, called
`@EXPORT_OK'.  This array does not automatically place its subroutine and
variable names into the namespace unless the user specifically requests
that this be done.

   See *Note Perlmod: perlmod, for more information.

   The $VERSION variable is used to ensure that the .pm file and the shared
library are "in sync" with each other.  Any time you make changes to the
.pm or .xs files, you should increment the value of this variable.

Writing good test scripts
-------------------------

   The importance of writing good test scripts cannot be overemphasized.
You should closely follow the "ok/not ok" style that Perl itself uses, so
that it is very easy and unambiguous to determine the outcome of each test
case.  When you find and fix a bug, make sure you add a test case for it.

   By running "make test", you ensure that your test.pl script runs and
uses the correct version of your extension.  If you have many test cases,
you might want to copy Perl's test style.  Create a directory named "t" in
the extension's directory and append the suffix ".t" to the names of your
test files.  When you run "make test", all of these test files will be
executed.

EXAMPLE 3
---------

   Our third extension will take one argument as its input, round off that
value, and set the argument to the rounded value.

   Add the following to the end of Mytest.xs:

     void
     round(arg)
     	double  arg
         CODE:
     	if (arg > 0.0) {
     		arg = floor(arg + 0.5);
     	} else if (arg < 0.0) {
     		arg = ceil(arg - 0.5);
     	} else {
     		arg = 0.0;
     	}
         OUTPUT:
     	arg

   Edit the Makefile.PL file so that the corresponding line looks like
this:

     'LIBS'      => ['-lm'],   # e.g., '-lm'

   Generate the Makefile and run make.  Change the BEGIN block to print
"1..9" and add the following to test.pl:

     $i = -1.5; &Mytest::round($i); print $i == -2.0 ? "ok 5" : "not ok 5", "\n";
     $i = -1.1; &Mytest::round($i); print $i == -1.0 ? "ok 6" : "not ok 6", "\n";
     $i = 0.0; &Mytest::round($i); print $i == 0.0 ? "ok 7" : "not ok 7", "\n";
     $i = 0.5; &Mytest::round($i); print $i == 1.0 ? "ok 8" : "not ok 8", "\n";
     $i = 1.2; &Mytest::round($i); print $i == 1.0 ? "ok 9" : "not ok 9", "\n";

   Running "make test" should now print out that all nine tests are okay.

   Notice that in these new test cases, the argument passed to round was a
scalar variable.  You might be wondering if you can round a constant or
literal.  To see what happens, temporarily add the following line to
test.pl:

     &Mytest::round(3);

   Run "make test" and notice that Perl dies with a fatal error.  Perl
won't let you change the value of constants!

What's new here?
----------------

   * We've made some changes to Makefile.PL.  In this case, we've
     specified an extra library to be linked into the extension's shared
     library, the math library libm in this case.  We'll talk later about
     how to write XSUBs that can call every routine in a library.

   * The value of the function is not being passed back as the function's
     return value, but by changing the value of the variable that was
     passed into the function.  You might have guessed that when you saw
     that the return value of round is of type "void".

Input and Output Parameters
---------------------------

   You specify the parameters that will be passed into the XSUB on the
line(s) after you declare the function's return value and name.  Each
input parameter line starts with optional white space, and may have an
optional terminating semicolon.

   The list of output parameters occurs at the very end of the function,
just before after the OUTPUT: directive.  The use of RETVAL tells Perl
that you wish to send this value back as the return value of the XSUB
function.  In Example 3, we wanted the "return value" placed in the
original variable which we passed in, so we listed it (and not RETVAL) in
the OUTPUT: section.

The XSUBPP Program
------------------

   The xsubpp program takes the XS code in the .xs file and translates it
into C code, placing it in a file whose suffix is .c.  The C code created
makes heavy use of the C functions within Perl.

The TYPEMAP file
----------------

   The xsubpp program uses rules to convert from Perl's data types (scalar,
array, etc.) to C's data types (int, char, etc.).  These rules are stored
in the typemap file ($PERLLIB/ExtUtils/typemap).  This file is split into
three parts.

   The first section maps various C data types to a name, which corresponds
somewhat with the various Perl types.  The second section contains C code
which xsubpp uses to handle input parameters.  The third section contains
C code which xsubpp uses to handle output parameters.

   Let's take a look at a portion of the .c file created for our extension.
The file name is Mytest.c:

     XS(XS_Mytest_round)
     {
         dXSARGS;
         if (items != 1)
     	croak("Usage: Mytest::round(arg)");
         {
     	double  arg = (double)SvNV(ST(0));	/* XXXXX */
     	if (arg > 0.0) {
     		arg = floor(arg + 0.5);
     	} else if (arg < 0.0) {
     		arg = ceil(arg - 0.5);
     	} else {
     		arg = 0.0;
     	}
     	sv_setnv(ST(0), (double)arg);	/* XXXXX */
         }
         XSRETURN(1);
     }

   Notice the two lines commented with "XXXXX".  If you check the first
section of the typemap file, you'll see that doubles are of type T_DOUBLE.
In the INPUT section, an argument that is T_DOUBLE is assigned to the
variable arg by calling the routine SvNV on something, then casting it to
double, then assigned to the variable arg.  Similarly, in the OUTPUT
section, once arg has its final value, it is passed to the sv_setnv
function to be passed back to the calling subroutine.  These two functions
are explained in *Note Perlguts: perlguts,; we'll talk more later about
what that "ST(0)" means in the section on the argument stack.

Warning about Output Arguments
------------------------------

   In general, it's not a good idea to write extensions that modify their
input parameters, as in Example 3.  Instead, you should probably return
multiple values in an array and let the caller handle them (we'll do this
in a later example).  However, in order to better accomodate calling
pre-existing C routines, which often do modify their input parameters,
this behavior is tolerated.

EXAMPLE 4
---------

   In this example, we'll now begin to write XSUBs that will interact with
pre-defined C libraries.  To begin with, we will build a small library of
our own, then let h2xs write our .pm and .xs files for us.

   Create a new directory called Mytest2 at the same level as the directory
Mytest.  In the Mytest2 directory, create another directory called mylib,
and cd into that directory.

   Here we'll create some files that will generate a test library.  These
will include a C source file and a header file.  We'll also create a
Makefile.PL in this directory.  Then we'll make sure that running make at
the Mytest2 level will automatically run this Makefile.PL file and the
resulting Makefile.

   In the mylib directory, create a file mylib.h that looks like this:

     #define TESTVAL	4

     extern double	foo(int, long, const char*);

   Also create a file mylib.c that looks like this:

     #include <stdlib.h>
     #include "./mylib.h"

     double
     foo(int a, long b, const char *c)
     {
     	return (a + b + atof(c) + TESTVAL);
     }

   And finally create a file Makefile.PL that looks like this:

     use ExtUtils::MakeMaker;
     $Verbose = 1;
     WriteMakefile(
         NAME   => 'Mytest2::mylib',
         SKIP   => [qw(all static static_lib dynamic dynamic_lib)],
         clean  => {'FILES' => 'libmylib$(LIBEEXT)'},
     );

     sub MY::top_targets {
     	'
     all :: static

     pure_all :: static

     static ::       libmylib$(LIB_EXT)

     libmylib$(LIB_EXT): $(O_FILES)
     	$(AR) cr libmylib$(LIB_EXT) $(O_FILES)
     	$(RANLIB) libmylib$(LIB_EXT)

     ';
     }

   Make sure you use a tab and not spaces on the lines beginning with
"$(AR)" and "$(RANLIB)".  Make will not function properly if you use
spaces.  It has also been reported that the "cr" argument to $(AR) is
unnecessary on Win32 systems.

   We will now create the main top-level Mytest2 files.  Change to the
directory above Mytest2 and run the following command:

     % h2xs -O -n Mytest2 ./Mytest2/mylib/mylib.h

   This will print out a warning about overwriting Mytest2, but that's
okay.  Our files are stored in Mytest2/mylib, and will be untouched.

   The normal Makefile.PL that h2xs generates doesn't know about the mylib
directory.  We need to tell it that there is a subdirectory and that we
will be generating a library in it.  Let's add the argument MYEXTLIB to
the WriteMakefile call so that it looks like this:

     WriteMakefile(
         'NAME'      => 'Mytest2',
         'VERSION_FROM' => 'Mytest2.pm', # finds $VERSION
         'LIBS'      => [''],   # e.g., '-lm'
         'DEFINE'    => '',     # e.g., '-DHAVE_SOMETHING'
         'INC'       => '',     # e.g., '-I/usr/include/other'
         'MYEXTLIB' => 'mylib/libmylib$(LIB_EXT)',
     );

   and then at the end add a subroutine (which will override the
pre-existing subroutine).  Remember to use a tab character to indent the
line beginning with "cd"!

     sub MY::postamble {
     '
     $(MYEXTLIB): mylib/Makefile
     	cd mylib && $(MAKE) $(PASSTHRU)
     ';
     }

   Let's also fix the MANIFEST file so that it accurately reflects the
contents of our extension.  The single line that says "mylib" should be
replaced by the following three lines:

     mylib/Makefile.PL
     mylib/mylib.c
     mylib/mylib.h

   To keep our namespace nice and unpolluted, edit the .pm file and change
the variable `@EXPORT' to `@EXPORT_OK'.  Finally, in the .xs file, edit
the #include line to read:

     #include "mylib/mylib.h"

   And also add the following function definition to the end of the .xs
file:

     double
     foo(a,b,c)
     	int             a
     	long            b
     	const char *    c
         OUTPUT:
     	RETVAL

   Now we also need to create a typemap file because the default Perl
doesn't currently support the const char * type.  Create a file called
typemap in the Mytest2 directory and place the following in it:

     const char *	T_PV

   Now run perl on the top-level Makefile.PL.  Notice that it also created
a Makefile in the mylib directory.  Run make and watch that it does cd into
the mylib directory and run make in there as well.

   Now edit the test.pl script and change the BEGIN block to print "1..4",
and add the following lines to the end of the script:

     print &Mytest2::foo(1, 2, "Hello, world!") == 7 ? "ok 2\n" : "not ok 2\n";
     print &Mytest2::foo(1, 2, "0.0") == 7 ? "ok 3\n" : "not ok 3\n";
     print abs(&Mytest2::foo(0, 0, "-3.4") - 0.6) <= 0.01 ? "ok 4\n" : "not ok 4\n";

   (When dealing with floating-point comparisons, it is best to not check
for equality, but rather that the difference between the expected and
actual result is below a certain amount (called epsilon) which is 0.01 in
this case)

   Run "make test" and all should be well.

What has happened here?
-----------------------

   Unlike previous examples, we've now run h2xs on a real include file.
This has caused some extra goodies to appear in both the .pm and .xs files.

   * In the .xs file, there's now a #include directive with the absolute
     path to the mylib.h header file.  We changed this to a relative path
     so that we could move the extension directory if we wanted to.

   * There's now some new C code that's been added to the .xs file.  The
     purpose of the constant routine is to make the values that are
     #define'd in the header file accessible by the Perl script (by
     calling either `TESTVAL' or `&Mytest2::TESTVAL').  There's also some
     XS code to allow calls to the constant routine.

   * The .pm file originally exported the name `TESTVAL' in the `@EXPORT'
     array.  This could lead to name clashes.  A good rule of thumb is
     that if the #define is only going to be used by the C routines
     themselves, and not by the user, they should be removed from the
     `@EXPORT' array.  Alternately, if you don't mind using the "fully
     qualified name" of a variable, you could move most or all of the
     items from the `@EXPORT' array into the `@EXPORT_OK' array.

   * If our include file had contained #include directives, these would
     not have been processed by h2xs.  There is no good solution to this
     right now.

   * We've also told Perl about the library that we built in the mylib
     subdirectory.  That required only the addition of the MYEXTLIB
     variable to the WriteMakefile call and the replacement of the
     postamble subroutine to cd into the subdirectory and run make.  The
     Makefile.PL for the library is a bit more complicated, but not
     excessively so.  Again we replaced the postamble subroutine to insert
     our own code.  This code simply specified that the library to be
     created here was a static archive library (as opposed to a
     dynamically loadable library) and provided the commands to build it.

Anatomy of .xs file
-------------------

   The .xs file of `"EXAMPLE 4"' in this node contained some new elements.
To understand the meaning of these elements, pay attention to the line
which reads

     MODULE = Mytest2		PACKAGE = Mytest2

   Anything before this line is plain C code which describes which headers
to include, and defines some convenience functions.  No translations are
performed on this part, it goes into the generated output C file as is.

   Anything after this line is the description of XSUB functions.  These
descriptions are translated by xsubpp into C code which implements these
functions using Perl calling conventions, and which makes these functions
visible from Perl interpreter.

   Pay a special attention to the function constant.  This name appears
twice in the generated .xs file: once in the first part, as a static C
function, the another time in the second part, when an XSUB interface to
this static C function is defined.

   This is quite typical for .xs files: usually the .xs file provides an
interface to an existing C function.  Then this C function is defined
somewhere (either in an external library, or in the first part of .xs
file), and a Perl interface to this function (i.e. "Perl glue") is
described in the second part of .xs file.  The situation in `"EXAMPLE 1"'
in this node, `"EXAMPLE 2"' in this node, and `"EXAMPLE 3"' in this node,
when all the work is done inside the "Perl glue", is somewhat of an
exception rather than the rule.

Getting the fat out of XSUBs
----------------------------

   In `"EXAMPLE 4"' in this node the second part of .xs file contained the
following description of an XSUB:

     double
     foo(a,b,c)
     	int             a
     	long            b
     	const char *    c
         OUTPUT:
     	RETVAL

   Note that in contrast with `"EXAMPLE 1"' in this node, `"EXAMPLE 2"' in
this node and `"EXAMPLE 3"' in this node, this description does not
contain the actual code for what is done is done during a call to Perl
function foo().  To understand what is going on here, one can add a CODE
section to this XSUB:

     double
     foo(a,b,c)
     	int             a
     	long            b
     	const char *    c
         CODE:
     	RETVAL = foo(a,b,c);
         OUTPUT:
     	RETVAL

   However, these two XSUBs provide almost identical generated C code:
xsubpp compiler is smart enough to figure out the `CODE:' section from the
first two lines of the description of XSUB.  What about `OUTPUT:' section?
In fact, that is absolutely the same!  The `OUTPUT:' section can be
removed as well, *as far as `CODE:' section or `PPCODE:' section* is not
specified: xsubpp can see that it needs to generate a function call
section, and will autogenerate the OUTPUT section too.  Thus one can
shortcut the XSUB to become:

     double
     foo(a,b,c)
     	int             a
     	long            b
     	const char *    c

   Can we do the same with an XSUB

     int
     is_even(input)
     	int	input
         CODE:
     	RETVAL = (input % 2 == 0);
         OUTPUT:
     	RETVAL

   of `"EXAMPLE 2"' in this node?  To do this, one needs to define a C
function `int is_even(int input)'.  As we saw in `Anatomy of .xs file' in
this node, a proper place for this definition is in the first part of .xs
file.  In fact a C function

     int
     is_even(int arg)
     {
     	return (arg % 2 == 0);
     }

   is probably overkill for this.  Something as simple as a `#define' will
do too:

     #define is_even(arg)	((arg) % 2 == 0)

   After having this in the first part of .xs file, the "Perl glue" part
becomes as simple as

     int
     is_even(input)
     	int	input

   This technique of separation of the glue part from the workhorse part
has obvious tradeoffs: if you want to change a Perl interface, you need to
change two places in your code.  However, it removes a lot of clutter, and
makes the workhorse part independent from idiosyncrasies of Perl calling
convention.  (In fact, there is nothing Perl-specific in the above
description, a different version of xsubpp might have translated this to
TCL glue or Python glue as well.)

More about XSUB arguments
-------------------------

   With the completion of Example 4, we now have an easy way to simulate
some real-life libraries whose interfaces may not be the cleanest in the
world.  We shall now continue with a discussion of the arguments passed to
the xsubpp compiler.

   When you specify arguments to routines in the .xs file, you are really
passing three pieces of information for each argument listed.  The first
piece is the order of that argument relative to the others (first, second,
etc).  The second is the type of argument, and consists of the type
declaration of the argument (e.g., int, char*, etc).  The third piece is
the calling convention for the argument in the call to the library
function.

   While Perl passes arguments to functions by reference, C passes
arguments by value; to implement a C function which modifies data of one
of the "arguments", the actual argument of this C function would be a
pointer to the data.  Thus two C functions with declarations

     int string_length(char *s);
     int upper_case_char(char *cp);

   may have completely different semantics: the first one may inspect an
array of chars pointed by s, and the second one may immediately
dereference cp and manipulate `*cp' only (using the return value as, say,
a success indicator).  From Perl one would use these functions in a
completely different manner.

   One conveys this info to xsubpp by replacing * before the argument by
&.  & means that the argument should be passed to a library function by
its address.  The above two function may be XSUB-ified as

     int
     string_length(s)
     	char *	s

     int
     upper_case_char(cp)
     	char	&cp

   For example, consider:

     int
     foo(a,b)
     	char	&a
     	char *	b

   The first Perl argument to this function would be treated as a char and
assigned to the variable a, and its address would be passed into the
function foo.  The second Perl argument would be treated as a string
pointer and assigned to the variable b.  The value of b would be passed
into the function foo.  The actual call to the function foo that xsubpp
generates would look like this:

     foo(&a, b);

   xsubpp will parse the following function argument lists identically:

     char	&a
     char&a
     char	& a

   However, to help ease understanding, it is suggested that you place a
"&" next to the variable name and away from the variable type), and place a
"*" near the variable type, but away from the variable name (as in the
call to foo above).  By doing so, it is easy to understand exactly what
will be passed to the C function - it will be whatever is in the "last
column".

   You should take great pains to try to pass the function the type of
variable it wants, when possible.  It will save you a lot of trouble in
the long run.

The Argument Stack
------------------

   If we look at any of the C code generated by any of the examples except
example 1, you will notice a number of references to ST(n), where n is
usually 0.  "ST" is actually a macro that points to the n'th argument on
the argument stack.  ST(0) is thus the first argument on the stack and
therefore the first argument passed to the XSUB, ST(1) is the second
argument, and so on.

   When you list the arguments to the XSUB in the .xs file, that tells
xsubpp which argument corresponds to which of the argument stack (i.e.,
the first one listed is the first argument, and so on).  You invite
disaster if you do not list them in the same order as the function expects
them.

   The actual values on the argument stack are pointers to the values
passed in.  When an argument is listed as being an OUTPUT value, its
corresponding value on the stack (i.e., ST(0) if it was the first
argument) is changed.  You can verify this by looking at the C code
generated for Example 3.  The code for the round() XSUB routine contains
lines that look like this:

     double  arg = (double)SvNV(ST(0));
     /* Round the contents of the variable arg */
     sv_setnv(ST(0), (double)arg);

   The arg variable is initially set by taking the value from ST(0), then
is stored back into ST(0) at the end of the routine.

   XSUBs are also allowed to return lists, not just scalars.  This must be
done by manipulating stack values ST(0), ST(1), etc, in a subtly different
way.  See *Note Perlxs: perlxs, for details.

   XSUBs are also allowed to avoid automatic conversion of Perl function
arguments to C function arguments.  See *Note Perlxs: perlxs, for details.
Some people prefer manual conversion by inspecting `ST(i)' even in the
cases when automatic conversion will do, arguing that this makes the logic
of an XSUB call clearer.  Compare with `"Getting the fat out of XSUBs"' in
this node for a similar tradeoff of a complete separation of "Perl glue"
and "workhorse" parts of an XSUB.

   While experts may argue about these idioms, a novice to Perl guts may
prefer a way which is as little Perl-guts-specific as possible, meaning
automatic conversion and automatic call generation, as in `"Getting the
fat out of XSUBs"' in this node.  This approach has the additional benefit
of protecting the XSUB writer from future changes to the Perl API.

Extending your Extension
------------------------

   Sometimes you might want to provide some extra methods or subroutines
to assist in making the interface between Perl and your extension simpler
or easier to understand.  These routines should live in the .pm file.
Whether they are automatically loaded when the extension itself is loaded
or only loaded when called depends on where in the .pm file the subroutine
definition is placed.  You can also consult *Note AutoLoader:
(pm.info)AutoLoader, for an alternate way to store and load your extra
subroutines.

Documenting your Extension
--------------------------

   There is absolutely no excuse for not documenting your extension.
Documentation belongs in the .pm file.  This file will be fed to pod2man,
and the embedded documentation will be converted to the man page format,
then placed in the blib directory.  It will be copied to Perl's man page
directory when the extension is installed.

   You may intersperse documentation and Perl code within the .pm file.
In fact, if you want to use method autoloading, you must do this, as the
comment inside the .pm file explains.

   See *Note Perlpod: perlpod, for more information about the pod format.

Installing your Extension
-------------------------

   Once your extension is complete and passes all its tests, installing it
is quite simple: you simply run "make install".  You will either need to
have write permission into the directories where Perl is installed, or ask
your system administrator to run the make for you.

   Alternately, you can specify the exact directory to place the
extension's files by placing a "PREFIX=/destination/directory" after the
make install.  (or in between the make and install if you have a
brain-dead version of make).  This can be very useful if you are building
an extension that will eventually be distributed to multiple systems.  You
can then just archive the files in the destination directory and
distribute them to your destination systems.

EXAMPLE 5
---------

   In this example, we'll do some more work with the argument stack.  The
previous examples have all returned only a single value.  We'll now create
an extension that returns an array.

   This extension is very Unix-oriented (struct statfs and the statfs
system call).  If you are not running on a Unix system, you can substitute
for statfs any other function that returns multiple values, you can
hard-code values to be returned to the caller (although this will be a bit
harder to test the error case), or you can simply not do this example.  If
you change the XSUB, be sure to fix the test cases to match the changes.

   Return to the Mytest directory and add the following code to the end of
Mytest.xs:

     void
     statfs(path)
     	char *  path
         INIT:
     	int i;
     	struct statfs buf;

     PPCODE:
     		i = statfs(path, &buf);
     		if (i == 0) {
     			XPUSHs(sv_2mortal(newSVnv(buf.f_bavail)));
     			XPUSHs(sv_2mortal(newSVnv(buf.f_bfree)));
     			XPUSHs(sv_2mortal(newSVnv(buf.f_blocks)));
     			XPUSHs(sv_2mortal(newSVnv(buf.f_bsize)));
     			XPUSHs(sv_2mortal(newSVnv(buf.f_ffree)));
     			XPUSHs(sv_2mortal(newSVnv(buf.f_files)));
     			XPUSHs(sv_2mortal(newSVnv(buf.f_type)));
     			XPUSHs(sv_2mortal(newSVnv(buf.f_fsid[0])));
     			XPUSHs(sv_2mortal(newSVnv(buf.f_fsid[1])));
     		} else {
     			XPUSHs(sv_2mortal(newSVnv(errno)));
     		}

   You'll also need to add the following code to the top of the .xs file,
just after the include of "XSUB.h":

     #include <sys/vfs.h>

   Also add the following code segment to test.pl while incrementing the
"1..9" string in the BEGIN block to "1..11":

     @a = &Mytest::statfs("/blech");
     print ((scalar(@a) == 1 && $a[0] == 2) ? "ok 10\n" : "not ok 10\n");
     @a = &Mytest::statfs("/");
     print scalar(@a) == 9 ? "ok 11\n" : "not ok 11\n";

New Things in this Example
--------------------------

   This example added quite a few new concepts.  We'll take them one at a
time.

   * The INIT: directive contains code that will be placed immediately
     after the argument stack is decoded.  C does not allow variable
     declarations at arbitrary locations inside a function, so this is
     usually the best way to declare local variables needed by the XSUB.
     (Alternatively, one could put the whole `PPCODE:' section into
     braces, and put these declarations on top.)

   * This routine also returns a different number of arguments depending
     on the success or failure of the call to statfs.  If there is an
     error, the error number is returned as a single-element array.  If
     the call is successful, then a 9-element array is returned.  Since
     only one argument is passed into this function, we need room on the
     stack to hold the 9 values which may be returned.

     We do this by using the PPCODE: directive, rather than the CODE:
     directive.  This tells xsubpp that we will be managing the return
     values that will be put on the argument stack by ourselves.

   * When we want to place values to be returned to the caller onto the
     stack, we use the series of macros that begin with "XPUSH".  There
     are five different versions, for placing integers, unsigned integers,
     doubles, strings, and Perl scalars on the stack.  In our example, we
     placed a Perl scalar onto the stack.  (In fact this is the only macro
     which can be used to return multiple values.)

     The XPUSH* macros will automatically extend the return stack to
     prevent it from being overrun.  You push values onto the stack in the
     order you want them seen by the calling program.

   * The values pushed onto the return stack of the XSUB are actually
     mortal SV's.  They are made mortal so that once the values are copied
     by the calling program, the SV's that held the returned values can be
     deallocated.  If they were not mortal, then they would continue to
     exist after the XSUB routine returned, but would not be accessible.
     This is a memory leak.

   * If we were interested in performance, not in code compactness, in the
     success branch we would not use XPUSHs macros, but PUSHs macros, and
     would pre-extend the stack before pushing the return values:

          EXTEND(SP, 9);

     The tradeoff is that one needs to calculate the number of return
     values in advance (though overextending the stack will not typically
     hurt anything but memory consumption).

     Similarly, in the failure branch we could use PUSHs *without*
     extending the stack: the Perl function reference comes to an XSUB on
     the stack, thus the stack is always large enough to take one return
     value.

EXAMPLE 6 (Coming Soon)
-----------------------

   Passing in and returning references to arrays and/or hashes

EXAMPLE 7 (Coming Soon)
-----------------------

   XPUSH args AND set RETVAL AND assign return value to array

EXAMPLE 8 (Coming Soon)
-----------------------

   Setting $!

EXAMPLE 9 (Coming Soon)
-----------------------

   Getting fd's from filehandles

Troubleshooting these Examples
------------------------------

   As mentioned at the top of this document, if you are having problems
with these example extensions, you might see if any of these help you.

   * In versions of 5.002 prior to the gamma version, the test script in
     Example 1 will not function properly.  You need to change the "use
     lib" line to read:

          use lib './blib';

   * In versions of 5.002 prior to version 5.002b1h, the test.pl file was
     not automatically created by h2xs.  This means that you cannot say
     "make test" to run the test script.  You will need to add the
     following line before the "use extension" statement:

          use lib './blib';

   * In versions 5.000 and 5.001, instead of using the above line, you
     will need to use the following line:

          BEGIN { unshift(@INC, "./blib") }

   * This document assumes that the executable named "perl" is Perl
     version 5.  Some systems may have installed Perl version 5 as "perl5".

See also
========

   For more information, consult *Note Perlguts: perlguts,, *Note Perlxs:
perlxs,, *Note Perlmod: perlmod,, and *Note Perlpod: perlpod,.

Author
======

   Jeff Okamoto <`okamoto@corp.hp.com'>

   Reviewed and assisted by Dean Roehrich, Ilya Zakharevich, Andreas
Koenig, and Tim Bunce.

Last Changed
------------

   1999/11/30


File: perl.info,  Node: Function Index,  Next: Predefined Variable Index,  Prev: Module List,  Up: Top

Function Index
**************

* Menu:

* :                                      perlfunc.
* -X FILEHANDLE:                         perlfunc.
* abs VALUE:                             perlfunc.
* accept NEWSOCKET,GENERICSOCKET:        perlfunc.
* alarm SECONDS:                         perlfunc.
* atan2 Y,X:                             perlfunc.
* bind SOCKET,NAME:                      perlfunc.
* binmode FILEHANDLE, DISCIPLINE:        perlfunc.
* bless REF,CLASSNAME:                   perlfunc.
* caller EXPR:                           perlfunc.
* chdir EXPR:                            perlfunc.
* chmod LIST:                            perlfunc.
* chomp VARIABLE:                        perlfunc.
* chop VARIABLE:                         perlfunc.
* chown LIST:                            perlfunc.
* chr NUMBER:                            perlfunc.
* chroot FILENAME:                       perlfunc.
* close FILEHANDLE:                      perlfunc.
* closedir DIRHANDLE:                    perlfunc.
* connect SOCKET,NAME:                   perlfunc.
* continue BLOCK:                        perlfunc.
* cos EXPR:                              perlfunc.
* crypt PLAINTEXT,SALT:                  perlfunc.
* dbmclose HASH:                         perlfunc.
* dbmopen HASH,DBNAME,MASK:              perlfunc.
* defined EXPR:                          perlfunc.
* delete EXPR:                           perlfunc.
* die LIST:                              perlfunc.
* do BLOCK:                              perlfunc.
* do EXPR:                               perlfunc.
* do SUBROUTINE(LIST):                   perlfunc.
* dump LABEL:                            perlfunc.
* each HASH:                             perlfunc.
* eof FILEHANDLE:                        perlfunc.
* eval EXPR:                             perlfunc.
* exec LIST:                             perlfunc.
* exists EXPR:                           perlfunc.
* exit EXPR:                             perlfunc.
* exp EXPR:                              perlfunc.
* fcntl FILEHANDLE,FUNCTION,SCALAR:      perlfunc.
* Fetching network info:                 perlfunc.
* Fetching user and group info:          perlfunc.
* fileno FILEHANDLE:                     perlfunc.
* flock FILEHANDLE,OPERATION:            perlfunc.
* fork:                                  perlfunc.
* format:                                perlfunc.
* formline PICTURE,LIST:                 perlfunc.
* Functions for filehandles, files, or directories: perlfunc.
* Functions for fixed length data or records: perlfunc.
* Functions for list data:               perlfunc.
* Functions for processes and process groups: perlfunc.
* Functions for real %HASHes:            perlfunc.
* Functions for real @ARRAYs:            perlfunc.
* Functions for SCALARs or strings:      perlfunc.
* Functions new in perl5:                perlfunc.
* Functions obsoleted in perl5:          perlfunc.
* getc FILEHANDLE:                       perlfunc.
* getlogin:                              perlfunc.
* getpeername SOCKET:                    perlfunc.
* getpgrp PID:                           perlfunc.
* getppid:                               perlfunc.
* getpriority WHICH,WHO:                 perlfunc.
* getpwnam NAME:                         perlfunc.
* getsockname SOCKET:                    perlfunc.
* getsockopt SOCKET,LEVEL,OPTNAME:       perlfunc.
* glob EXPR:                             perlfunc.
* gmtime EXPR:                           perlfunc.
* goto LABEL:                            perlfunc.
* grep BLOCK LIST:                       perlfunc.
* hex EXPR:                              perlfunc.
* import:                                perlfunc.
* index STR,SUBSTR,POSITION:             perlfunc.
* Input and output functions:            perlfunc.
* int EXPR:                              perlfunc.
* ioctl FILEHANDLE,FUNCTION,SCALAR:      perlfunc.
* join EXPR,LIST:                        perlfunc.
* keys HASH:                             perlfunc.
* Keywords related to classes and object-orientedness: perlfunc.
* Keywords related to perl modules:      perlfunc.
* Keywords related to scoping:           perlfunc.
* Keywords related to the control flow of your perl program: perlfunc.
* kill SIGNAL, LIST:                     perlfunc.
* last LABEL:                            perlfunc.
* lc EXPR:                               perlfunc.
* lcfirst EXPR:                          perlfunc.
* length EXPR:                           perlfunc.
* link OLDFILE,NEWFILE:                  perlfunc.
* listen SOCKET,QUEUESIZE:               perlfunc.
* local EXPR:                            perlfunc.
* localtime EXPR:                        perlfunc.
* lock:                                  perlfunc.
* log EXPR:                              perlfunc.
* Low-level socket functions:            perlfunc.
* lstat FILEHANDLE:                      perlfunc.
* m//:                                   perlfunc.
* map BLOCK LIST:                        perlfunc.
* Miscellaneous functions:               perlfunc.
* mkdir FILENAME,MASK:                   perlfunc.
* msgctl ID,CMD,ARG:                     perlfunc.
* msgget KEY,FLAGS:                      perlfunc.
* msgrcv ID,VAR,SIZE,TYPE,FLAGS:         perlfunc.
* msgsnd ID,MSG,FLAGS:                   perlfunc.
* my EXPR:                               perlfunc.
* next LABEL:                            perlfunc.
* no Module LIST:                        perlfunc.
* Numeric functions:                     perlfunc.
* oct EXPR:                              perlfunc.
* open FILEHANDLE,MODE,LIST:             perlfunc.
* opendir DIRHANDLE,EXPR:                perlfunc.
* ord EXPR:                              perlfunc.
* our EXPR:                              perlfunc.
* pack TEMPLATE,LIST:                    perlfunc.
* package:                               perlfunc.
* pipe READHANDLE,WRITEHANDLE:           perlfunc.
* pop ARRAY:                             perlfunc.
* pos SCALAR:                            perlfunc.
* print FILEHANDLE LIST:                 perlfunc.
* printf FILEHANDLE FORMAT, LIST:        perlfunc.
* prototype FUNCTION:                    perlfunc.
* push ARRAY,LIST:                       perlfunc.
* q/STRING/:                             perlfunc.
* quotemeta EXPR:                        perlfunc.
* rand EXPR:                             perlfunc.
* read FILEHANDLE,SCALAR,LENGTH,OFFSET:  perlfunc.
* readdir DIRHANDLE:                     perlfunc.
* readline EXPR:                         perlfunc.
* readlink EXPR:                         perlfunc.
* readpipe EXPR:                         perlfunc.
* recv SOCKET,SCALAR,LENGTH,FLAGS:       perlfunc.
* redo LABEL:                            perlfunc.
* ref EXPR:                              perlfunc.
* Regular expressions and pattern matching: perlfunc.
* rename OLDNAME,NEWNAME:                perlfunc.
* require VERSION:                       perlfunc.
* reset EXPR:                            perlfunc.
* return EXPR:                           perlfunc.
* reverse LIST:                          perlfunc.
* rewinddir DIRHANDLE:                   perlfunc.
* rindex STR,SUBSTR,POSITION:            perlfunc.
* rmdir FILENAME:                        perlfunc.
* s///:                                  perlfunc.
* scalar EXPR:                           perlfunc.
* seek FILEHANDLE,POSITION,WHENCE:       perlfunc.
* seekdir DIRHANDLE,POS:                 perlfunc.
* select FILEHANDLE:                     perlfunc.
* select RBITS,WBITS,EBITS,TIMEOUT:      perlfunc.
* semctl ID,SEMNUM,CMD,ARG:              perlfunc.
* semget KEY,NSEMS,FLAGS:                perlfunc.
* semop KEY,OPSTRING:                    perlfunc.
* send SOCKET,MSG,FLAGS,TO:              perlfunc.
* setpgrp PID,PGRP:                      perlfunc.
* setpriority WHICH,WHO,PRIORITY:        perlfunc.
* setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL: perlfunc.
* shift ARRAY:                           perlfunc.
* shmctl ID,CMD,ARG:                     perlfunc.
* shmget KEY,SIZE,FLAGS:                 perlfunc.
* shmread ID,VAR,POS,SIZE:               perlfunc.
* shutdown SOCKET,HOW:                   perlfunc.
* sin EXPR:                              perlfunc.
* sleep EXPR:                            perlfunc.
* socket SOCKET,DOMAIN,TYPE,PROTOCOL:    perlfunc.
* socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL: perlfunc.
* sort SUBNAME LIST:                     perlfunc.
* splice ARRAY,OFFSET,LENGTH,LIST:       perlfunc.
* split /PATTERN/,EXPR,LIMIT:            perlfunc.
* sprintf FORMAT, LIST:                  perlfunc.
* sqrt EXPR:                             perlfunc.
* srand EXPR:                            perlfunc.
* stat FILEHANDLE:                       perlfunc.
* study SCALAR:                          perlfunc.
* sub BLOCK:                             perlfunc.
* substr EXPR,OFFSET,LENGTH,REPLACEMENT: perlfunc.
* symlink OLDFILE,NEWFILE:               perlfunc.
* syscall LIST:                          perlfunc.
* sysopen FILEHANDLE,FILENAME,MODE:      perlfunc.
* sysread FILEHANDLE,SCALAR,LENGTH,OFFSET: perlfunc.
* sysseek FILEHANDLE,POSITION,WHENCE:    perlfunc.
* system LIST:                           perlfunc.
* System V interprocess communication functions: perlfunc.
* syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET: perlfunc.
* tell FILEHANDLE:                       perlfunc.
* telldir DIRHANDLE:                     perlfunc.
* tie VARIABLE,CLASSNAME,LIST:           perlfunc.
* tied VARIABLE:                         perlfunc.
* time:                                  perlfunc.
* Time-related functions:                perlfunc.
* times:                                 perlfunc.
* tr///:                                 perlfunc.
* truncate FILEHANDLE,LENGTH:            perlfunc.
* uc EXPR:                               perlfunc.
* ucfirst EXPR:                          perlfunc.
* umask EXPR:                            perlfunc.
* undef EXPR:                            perlfunc.
* unlink LIST:                           perlfunc.
* unpack TEMPLATE,EXPR:                  perlfunc.
* unshift ARRAY,LIST:                    perlfunc.
* untie VARIABLE:                        perlfunc.
* use Module VERSION LIST:               perlfunc.
* utime LIST:                            perlfunc.
* values HASH:                           perlfunc.
* vec EXPR,OFFSET,BITS:                  perlfunc.
* wait:                                  perlfunc.
* waitpid PID,FLAGS:                     perlfunc.
* wantarray:                             perlfunc.
* warn LIST:                             perlfunc.
* write FILEHANDLE:                      perlfunc.
* y///:                                  perlfunc.


File: perl.info,  Node: Predefined Variable Index,  Next: Diagnostics Index,  Prev: Function Index,  Up: Top

Predefined Variable Index
*************************

* Menu:

* :                                      perlvar.
* $0:                                    perlvar.
* $1 is the same as substr($var, $-[1], $+[1] - $-[1]): perlvar.
* $2 is the same as substr($var, $-[2], $+[2] - $-[2]): perlvar.
* $3 is the same as substr $var, $-[3], $+[3] - $-[3]): perlvar.
* $<digits>:                             perlvar.
* $[:                                    perlvar.
* $]:                                    perlvar.
* $^H:                                   perlvar.
* $^M:                                   perlvar.
* $` is the same as substr($var, 0, $-[0]): perlvar.
* $ACCUMULATOR:                          perlvar.
* $ARG:                                  perlvar.
* $ARGV:                                 perlvar.
* $BASETIME:                             perlvar.
* $CHILD_ERROR:                          perlvar.
* $COMPILING:                            perlvar.
* $DEBUGGING:                            perlvar.
* $EFFECTIVE_GROUP_ID:                   perlvar.
* $EFFECTIVE_USER_ID:                    perlvar.
* $EVAL_ERROR:                           perlvar.
* $EXCEPTIONS_BEING_CAUGHT:              perlvar.
* $EXECUTABLE_NAME:                      perlvar.
* $EXTENDED_OS_ERROR:                    perlvar.
* $INPLACE_EDIT:                         perlvar.
* $LAST_PAREN_MATCH:                     perlvar.
* $LAST_REGEXP_CODE_RESULT:              perlvar.
* $LIST_SEPARATOR:                       perlvar.
* $MATCH:                                perlvar.
* $MULTILINE_MATCHING:                   perlvar.
* $OFMT:                                 perlvar.
* $OS_ERROR:                             perlvar.
* $OSNAME:                               perlvar.
* $PERL_VERSION:                         perlvar.
* $PERLDB:                               perlvar.
* $POSTMATCH:                            perlvar.
* $PREMATCH:                             perlvar.
* $PROCESS_ID:                           perlvar.
* $PROGRAM_NAME:                         perlvar.
* $REAL_GROUP_ID:                        perlvar.
* $REAL_USER_ID:                         perlvar.
* $SUBSCRIPT_SEPARATOR:                  perlvar.
* $SYSTEM_FD_MAX:                        perlvar.
* $WARNING:                              perlvar.
* ${^WARNING_BITS}:                      perlvar.
* ${^WIDE_SYSTEM_CALLS}:                 perlvar.
* %^H:                                   perlvar.
* %ENV:                                  perlvar.
* %INC:                                  perlvar.
* %SIG:                                  perlvar.
* @+:                                    perlvar.
* @-:                                    perlvar.
* @_:                                    perlvar.
* @ARGV:                                 perlvar.
* @INC:                                  perlvar.
* autoflush HANDLE EXPR:                 perlvar.
* format_formfeed HANDLE EXPR:           perlvar.
* format_line_break_characters HANDLE EXPR: perlvar.
* format_lines_left HANDLE EXPR:         perlvar.
* format_lines_per_page HANDLE EXPR:     perlvar.
* format_page_number HANDLE EXPR:        perlvar.
* format_top_name HANDLE EXPR:           perlvar.
* input_line_number HANDLE EXPR:         perlvar.
* input_record_separator HANDLE EXPR:    perlvar.
* output_field_separator HANDLE EXPR:    perlvar.
* output_record_separator HANDLE EXPR:   perlvar.


File: perl.info,  Node: Diagnostics Index,  Next: Module List,  Prev: Predefined Variable Index,  Up: Top

Diagnostics Index
*****************

* Menu:

* "%s" variable %s masks earlier declaration in same %s: perldiag.
* "my sub" not yet implemented:          perldiag.
* "my" variable %s can't be in a package: perldiag.
* "no" not allowed in expression:        perldiag.
* "our" variable %s redeclared:          perldiag.
* "use" not allowed in expression:       perldiag.
* % may only be used in unpack:          perldiag.
* %cetsockopt() on closed socket %s:     perldiag.
* %s (...) interpreted as function:      perldiag.
* %s argument is not a HASH or ARRAY element: perldiag.
* %s argument is not a HASH or ARRAY element or slice: perldiag.
* %s argument is not a subroutine name:  perldiag.
* %s did not return a true value:        perldiag.
* %s failed-call queue aborted:          perldiag.
* %s found where operator expected:      perldiag.
* %s had compilation errors:             perldiag.
* %s has too many errors:                perldiag.
* %s matches null string many times:     perldiag.
* %s never introduced:                   perldiag.
* %s package attribute may clash with future reserved word: %s: perldiag.
* %s syntax OK:                          perldiag.
* %s() called too early to check prototype: perldiag.
* %s: Command not found:                 perldiag.
* %s: Eval-group in insecure regular expression: perldiag.
* %s: Eval-group not allowed at run time: perldiag.
* %s: Eval-group not allowed, use re 'eval': perldiag.
* %s: Expression syntax:                 perldiag.
* %s: not found:                         perldiag.
* %s: Undefined variable:                perldiag.
* %sseek() on unopened file:             perldiag.
* '!' allowed only after types %s:       perldiag.
* '|' and '<' may not both be specified on command line: perldiag.
* '|' and '>' may not both be specified on command line: perldiag.
* (Did you mean "local" instead of "our"?): perldiag.
* (Did you mean $ or @ instead of %?):   perldiag.
* (Did you mean &%s instead?):           perldiag.
* (Do you need to predeclare %s?):       perldiag.
* (in cleanup) %s:                       perldiag.
* (Missing operator before %s?):         perldiag.
* (Missing semicolon on previous line?): perldiag.
* -p destination: %s:                    perldiag.
* -P not allowed for setuid/setgid script: perldiag.
* -T and -B not implemented on filehandles: perldiag.
* / cannot take a count:                 perldiag.
* / must be followed by a*, A* or Z*:    perldiag.
* / must be followed by a, A or Z:       perldiag.
* / must follow a numeric type:          perldiag.
* /%s/ should probably be written as "%s": perldiag.
* /%s/: Unrecognized escape \\%c in character class passed through: perldiag.
* /%s/: Unrecognized escape \\%c passed through: perldiag.
* <> should be quotes:                   perldiag.
* @ outside of string:                   perldiag.
* \1 better written as $1:               perldiag.
* accept() on closed socket %s:          perldiag.
* Allocation too large: %lx:             perldiag.
* Ambiguous call resolved as CORE::%s(), qualify as such or use &: perldiag.
* Ambiguous use of %s resolved as %s:    perldiag.
* Applying %s to %s will act on scalar(%s): perldiag.
* Arg too short for msgsnd:              perldiag.
* Args must match #! line:               perldiag.
* Argument "%s" isn't numeric%s:         perldiag.
* Array @%s missing the @ in argument %d of %s(): perldiag.
* assertion botched: %s:                 perldiag.
* Assertion failed: file "%s":           perldiag.
* Assignment to both a list and a scalar: perldiag.
* Attempt to free non-arena SV: 0x%lx:   perldiag.
* Attempt to free nonexistent shared string: perldiag.
* Attempt to free temp prematurely:      perldiag.
* Attempt to free unreferenced glob pointers: perldiag.
* Attempt to free unreferenced scalar:   perldiag.
* Attempt to join self:                  perldiag.
* Attempt to pack pointer to temporary value: perldiag.
* Attempt to use reference as lvalue in substr: perldiag.
* Bad arg length for %s, is %d, should be %d: perldiag.
* Bad evalled substitution pattern:      perldiag.
* Bad filehandle: %s:                    perldiag.
* Bad free() ignored:                    perldiag.
* Bad hash:                              perldiag.
* Bad index while coercing array into hash: perldiag.
* Bad name after %s:::                   perldiag.
* Bad realloc() ignored:                 perldiag.
* Bad symbol for array:                  perldiag.
* Bad symbol for filehandle:             perldiag.
* Bad symbol for hash:                   perldiag.
* Badly placed ()'s:                     perldiag.
* Bareword "%s" not allowed while "strict subs" in use: perldiag.
* Bareword "%s" refers to nonexistent package: perldiag.
* Bareword found in conditional:         perldiag.
* BEGIN failed-compilation aborted:      perldiag.
* BEGIN not safe after errors-compilation aborted: perldiag.
* Binary number > 0b11111111111111111111111111111111 non-portable: perldiag.
* bind() on closed socket %s:            perldiag.
* Bit vector size > 32 non-portable:     perldiag.
* Bizarre copy of %s in %s:              perldiag.
* Buffer overflow in prime_env_iter: %s: perldiag.
* Callback called exit:                  perldiag.
* Can't "goto" into the middle of a foreach loop: perldiag.
* Can't "goto" out of a pseudo block:    perldiag.
* Can't "last" outside a loop block:     perldiag.
* Can't "next" outside a loop block:     perldiag.
* Can't "redo" outside a loop block:     perldiag.
* Can't bless non-reference value:       perldiag.
* Can't break at that line:              perldiag.
* Can't call method "%s" in empty package "%s": perldiag.
* Can't call method "%s" on an undefined value: perldiag.
* Can't call method "%s" on unblessed reference: perldiag.
* Can't call method "%s" without a package or object reference: perldiag.
* Can't chdir to %s:                     perldiag.
* Can't check filesystem of script "%s" for nosuid: perldiag.
* Can't coerce %s to integer in %s:      perldiag.
* Can't coerce %s to number in %s:       perldiag.
* Can't coerce %s to string in %s:       perldiag.
* Can't coerce array into hash:          perldiag.
* Can't create pipe mailbox:             perldiag.
* Can't declare %s in "%s":              perldiag.
* Can't declare class for non-scalar %s in "%s": perldiag.
* Can't do inplace edit on %s: %s:       perldiag.
* Can't do inplace edit without backup:  perldiag.
* Can't do inplace edit: %s is not a regular file: perldiag.
* Can't do inplace edit: %s would not be unique: perldiag.
* Can't do setegid!:                     perldiag.
* Can't do seteuid!:                     perldiag.
* Can't do setuid:                       perldiag.
* Can't do waitpid with flags:           perldiag.
* Can't do {n,m} with n > m:             perldiag.
* Can't emulate -%s on #! line:          perldiag.
* Can't exec "%s": %s:                   perldiag.
* Can't exec %s:                         perldiag.
* Can't execute %s:                      perldiag.
* Can't find %s on PATH:                 perldiag.
* Can't find %s on PATH, '.' not in PATH: perldiag.
* Can't find an opnumber for "%s":       perldiag.
* Can't find label %s:                   perldiag.
* Can't find string terminator %s anywhere before EOF: perldiag.
* Can't fork:                            perldiag.
* Can't get filespec - stale stat buffer?: perldiag.
* Can't get pipe mailbox device name:    perldiag.
* Can't get SYSGEN parameter value for MAXBUF: perldiag.
* Can't goto subroutine from an eval-string: perldiag.
* Can't goto subroutine outside a subroutine: perldiag.
* Can't ignore signal CHLD, forcing to default: perldiag.
* Can't localize lexical variable %s:    perldiag.
* Can't localize pseudo-hash element:    perldiag.
* Can't localize through a reference:    perldiag.
* Can't locate %s:                       perldiag.
* Can't locate auto/%s.al in @INC:       perldiag.
* Can't locate object method "%s" via package "%s": perldiag.
* Can't locate package %s for @%s::ISA:  perldiag.
* Can't make list assignment to \%ENV on this system: perldiag.
* Can't modify %s in %s:                 perldiag.
* Can't modify non-lvalue subroutine call: perldiag.
* Can't modify nonexistent substring:    perldiag.
* Can't msgrcv to read-only var:         perldiag.
* Can't open %s: %s:                     perldiag.
* Can't open bidirectional pipe:         perldiag.
* Can't open error file %s as stderr:    perldiag.
* Can't open input file %s as stdin:     perldiag.
* Can't open output file %s as stdout:   perldiag.
* Can't open output pipe (name: %s):     perldiag.
* Can't open perl script "%s": %s:       perldiag.
* Can't read CRTL environ:               perldiag.
* Can't redefine active sort subroutine %s: perldiag.
* Can't remove %s: %s, skipping file:    perldiag.
* Can't rename %s to %s: %s, skipping file: perldiag.
* Can't reopen input pipe (name: %s) in binary mode: perldiag.
* Can't resolve method `%s' overloading `%s' in package `%s': perldiag.
* Can't reswap uid and euid:             perldiag.
* Can't return %s from lvalue subroutine: perldiag.
* Can't return outside a subroutine:     perldiag.
* Can't stat script "%s":                perldiag.
* Can't swap uid and euid:               perldiag.
* Can't take log of %g:                  perldiag.
* Can't take sqrt of %g:                 perldiag.
* Can't undef active subroutine:         perldiag.
* Can't unshift:                         perldiag.
* Can't upgrade that kind of scalar:     perldiag.
* Can't upgrade to undef:                perldiag.
* Can't use "my %s" in sort comparison:  perldiag.
* Can't use %%! because Errno.pm is not available: perldiag.
* Can't use %s for loop variable:        perldiag.
* Can't use %s ref as %s ref:            perldiag.
* Can't use \%c to mean $%c in expression: perldiag.
* Can't use an undefined value as %s reference: perldiag.
* Can't use bareword ("%s") as %s ref while "strict refs" in use: perldiag.
* Can't use global %s in "my":           perldiag.
* Can't use string ("%s") as %s ref while "strict refs" in use: perldiag.
* Can't use subscript on %s:             perldiag.
* Can't weaken a nonreference:           perldiag.
* Can't x= to read-only value:           perldiag.
* Character class [:%s:] unknown:        perldiag.
* Character class syntax [%s] belongs inside character classes: perldiag.
* Character class syntax [. .] is reserved for future extensions: perldiag.
* Character class syntax [= =] is reserved for future extensions: perldiag.
* chmod() mode argument is missing initial 0: perldiag.
* Close on unopened file <%s>:           perldiag.
* Compilation failed in require:         perldiag.
* Complex regular subexpression recursion limit (%d) exceeded: perldiag.
* connect() on closed socket %s:         perldiag.
* Constant is not %s reference:          perldiag.
* Constant subroutine %s redefined:      perldiag.
* Constant subroutine %s undefined:      perldiag.
* constant(%s): %s:                      perldiag.
* Copy method did not return a reference: perldiag.
* CORE::%s is not a keyword:             perldiag.
* Corrupt malloc ptr 0x%lx at 0x%lx:     perldiag.
* corrupted regexp pointers:             perldiag.
* corrupted regexp program:              perldiag.
* Deep recursion on subroutine "%s":     perldiag.
* defined(%hash) is deprecated:          perldiag.
* defined(@array) is deprecated:         perldiag.
* Delimiter for here document is too long: perldiag.
* Did not produce a valid header:        perldiag.
* Died:                                  perldiag.
* do_study: out of memory:               perldiag.
* Document contains no data:             perldiag.
* Don't know how to handle magic of type '%s': perldiag.
* Duplicate free() ignored:              perldiag.
* elseif should be elsif:                perldiag.
* entering effective %s failed:          perldiag.
* Error converting file specification %s: perldiag.
* Excessively long <> operator:          perldiag.
* Execution of %s aborted due to compilation errors: perldiag.
* Exiting eval via %s:                   perldiag.
* Exiting format via %s:                 perldiag.
* Exiting pseudo-block via %s:           perldiag.
* Exiting subroutine via %s:             perldiag.
* Exiting substitution via %s:           perldiag.
* Explicit blessing to " (assuming package main): perldiag.
* false [] range "%s" in regexp:         perldiag.
* Fatal VMS error at %s, line %d:        perldiag.
* fcntl is not implemented:              perldiag.
* Filehandle %s never opened:            perldiag.
* Filehandle %s opened only for input:   perldiag.
* Filehandle %s opened only for output:  perldiag.
* Final $ should be \$ or $name:         perldiag.
* Final @ should be \@ or @name:         perldiag.
* flock() on closed filehandle %s:       perldiag.
* follows nothing in regexp:             perldiag.
* Format %s redefined:                   perldiag.
* Format not terminated:                 perldiag.
* Found = in conditional, should be ==:  perldiag.
* gdbm store returned %d, errno %d, key "%s": perldiag.
* get%sname() on closed socket %s:       perldiag.
* gethostent not implemented:            perldiag.
* getpwnam returned invalid UIC %#o for user "%s": perldiag.
* glob failed (%s):                      perldiag.
* Glob not terminated:                   perldiag.
* Global symbol "%s" requires explicit package name: perldiag.
* Got an error from DosAllocMem:         perldiag.
* goto must have label:                  perldiag.
* Had to create %s unexpectedly:         perldiag.
* Hash %%s missing the % in argument %d of %s(): perldiag.
* Hexadecimal number > 0xffffffff non-portable: perldiag.
* Identifier too long:                   perldiag.
* Ill-formed CRTL environ value "%s":    perldiag.
* Ill-formed message in prime_env_iter: |%s|: perldiag.
* Illegal binary digit %s:               perldiag.
* Illegal binary digit %s ignored:       perldiag.
* Illegal character %s (carriage return): perldiag.
* Illegal division by zero:              perldiag.
* Illegal hexadecimal digit %s ignored:  perldiag.
* Illegal modulus zero:                  perldiag.
* Illegal number of bits in vec:         perldiag.
* Illegal octal digit %s:                perldiag.
* Illegal octal digit %s ignored:        perldiag.
* Illegal switch in PERL5OPT: %s:        perldiag.
* In string, @%s now must be written as \@%s: perldiag.
* Insecure $ENV{%s} while running %s:    perldiag.
* Insecure dependency in %s:             perldiag.
* Insecure directory in %s:              perldiag.
* Integer overflow in %s number:         perldiag.
* internal disaster in regexp:           perldiag.
* Internal inconsistency in tracking vforks: perldiag.
* internal urp in regexp at /%s/:        perldiag.
* Invalid %s attribute: %s:              perldiag.
* Invalid %s attributes: %s:             perldiag.
* invalid [] range "%s" in regexp:       perldiag.
* Invalid conversion in %s: "%s":        perldiag.
* Invalid separator character %s in attribute list: perldiag.
* Invalid type in pack: '%s':            perldiag.
* Invalid type in unpack: '%s':          perldiag.
* ioctl is not implemented:              perldiag.
* junk on end of regexp:                 perldiag.
* Label not found for "last %s":         perldiag.
* Label not found for "next %s":         perldiag.
* Label not found for "redo %s":         perldiag.
* leaving effective %s failed:           perldiag.
* listen() on closed socket %s:          perldiag.
* Lvalue subs returning %s not implemented yet: perldiag.
* Malformed PERLLIB_PREFIX:              perldiag.
* Method %s not permitted:               perldiag.
* Method for operation %s not found in package %s during blessing: perldiag.
* Might be a runaway multi-line %s string starting on line %d: perldiag.
* Misplaced _ in number:                 perldiag.
* Missing $ on loop variable:            perldiag.
* Missing %sbrace%s on \N{}:             perldiag.
* Missing comma after first argument to %s function: perldiag.
* Missing command in piped open:         perldiag.
* Missing name in "my sub":              perldiag.
* Missing right curly or square bracket: perldiag.
* Modification of a read-only value attempted: perldiag.
* Modification of non-creatable array value attempted, subscript %d: perldiag.
* Modification of non-creatable hash value attempted, subscript "%s": perldiag.
* Module name must be constant:          perldiag.
* msg%s not implemented:                 perldiag.
* Multidimensional syntax %s not supported: perldiag.
* Name "%s::%s" used only once: possible typo: perldiag.
* Negative length:                       perldiag.
* nested *?+ in regexp:                  perldiag.
* No #! line:                            perldiag.
* No %s allowed while running setuid:    perldiag.
* No %s specified for -%c:               perldiag.
* No -e allowed in setuid scripts:       perldiag.
* No comma allowed after %s:             perldiag.
* No command into which to pipe on command line: perldiag.
* No DB::DB routine defined:             perldiag.
* No dbm on this machine:                perldiag.
* No DBsub routine:                      perldiag.
* No error file after 2> or 2>> on command line: perldiag.
* No input file after < on command line: perldiag.
* No output file after > on command line: perldiag.
* No output file after > or >> on command line: perldiag.
* No package name allowed for variable %s in "our": perldiag.
* No Perl script found in input:         perldiag.
* No setregid available:                 perldiag.
* No setreuid available:                 perldiag.
* No space allowed after -%c:            perldiag.
* No such pipe open:                     perldiag.
* No such pseudo-hash field "%s":        perldiag.
* No such pseudo-hash field "%s" in variable %s of type %s: perldiag.
* No such signal: SIG%s:                 perldiag.
* no UTC offset information; assuming local time is UTC: perldiag.
* Not a CODE reference:                  perldiag.
* Not a format reference:                perldiag.
* Not a GLOB reference:                  perldiag.
* Not a HASH reference:                  perldiag.
* Not a perl script:                     perldiag.
* Not a SCALAR reference:                perldiag.
* Not a subroutine reference:            perldiag.
* Not a subroutine reference in overload table: perldiag.
* Not an ARRAY reference:                perldiag.
* Not enough arguments for %s:           perldiag.
* Not enough format arguments:           perldiag.
* Null filename used:                    perldiag.
* NULL OP IN RUN:                        perldiag.
* Null picture in formline:              perldiag.
* Null realloc:                          perldiag.
* NULL regexp argument:                  perldiag.
* NULL regexp parameter:                 perldiag.
* Number too long:                       perldiag.
* Octal number > 037777777777 non-portable: perldiag.
* Octal number in vector unsupported:    perldiag.
* Odd number of elements in hash assignment: perldiag.
* Offset outside string:                 perldiag.
* oops: oopsAV:                          perldiag.
* oops: oopsHV:                          perldiag.
* Operation `%s': no method found, %s:   perldiag.
* Operator or semicolon missing before %s: perldiag.
* Out of memory during "large" request for %s: perldiag.
* Out of memory during request for %s:   perldiag.
* Out of memory during ridiculously large request: perldiag.
* Out of memory for yacc stack:          perldiag.
* Out of memory!:                        perldiag.
* page overflow:                         perldiag.
* panic: %s:                             perldiag.
* panic: ck_grep:                        perldiag.
* panic: ck_split:                       perldiag.
* panic: corrupt saved stack index:      perldiag.
* panic: del_backref:                    perldiag.
* panic: die %s:                         perldiag.
* panic: do_match:                       perldiag.
* panic: do_split:                       perldiag.
* panic: do_subst:                       perldiag.
* panic: do_trans:                       perldiag.
* panic: frexp:                          perldiag.
* panic: goto:                           perldiag.
* panic: INTERPCASEMOD:                  perldiag.
* panic: INTERPCONCAT:                   perldiag.
* panic: kid popen errno read:           perldiag.
* panic: last:                           perldiag.
* panic: leave_scope clearsv:            perldiag.
* panic: leave_scope inconsistency:      perldiag.
* panic: magic_killbackrefs:             perldiag.
* panic: malloc:                         perldiag.
* panic: mapstart:                       perldiag.
* panic: null array:                     perldiag.
* panic: pad_alloc:                      perldiag.
* panic: pad_free curpad:                perldiag.
* panic: pad_free po:                    perldiag.
* panic: pad_reset curpad:               perldiag.
* panic: pad_sv po:                      perldiag.
* panic: pad_swipe curpad:               perldiag.
* panic: pad_swipe po:                   perldiag.
* panic: pp_iter:                        perldiag.
* panic: realloc:                        perldiag.
* panic: restartop:                      perldiag.
* panic: return:                         perldiag.
* panic: scan_num:                       perldiag.
* panic: sv_insert:                      perldiag.
* panic: top_env:                        perldiag.
* panic: yylex:                          perldiag.
* Parentheses missing around "%s" list:  perldiag.
* Perl %3.3f required-this is only version %s, stopped: perldiag.
* perl: warning: Setting locale failed.: perldiag.
* PERL_SH_DIR too long:                  perldiag.
* Permission denied:                     perldiag.
* pid %x not a child:                    perldiag.
* POSIX getpgrp can't take an argument:  perldiag.
* Possible attempt to put comments in qw() list: perldiag.
* Possible attempt to separate words with commas: perldiag.
* Possible memory corruption: %s overflowed 3rd argument: perldiag.
* Possible Y2K bug: %s:                  perldiag.
* pragma "attrs" is deprecated, use "sub NAME : ATTRS" instead: perldiag.
* Precedence problem: open %s should be open(%s): perldiag.
* Premature end of script headers:       perldiag.
* print() on closed filehandle %s:       perldiag.
* printf() on closed filehandle %s:      perldiag.
* Process terminated by SIG%s:           perldiag.
* Prototype mismatch: %s vs %s:          perldiag.
* Range iterator outside integer range:  perldiag.
* readline() on closed filehandle %s:    perldiag.
* realloc() of freed memory ignored:     perldiag.
* Reallocation too large: %lx:           perldiag.
* Recompile perl with -DDEBUGGING to use -D switch: perldiag.
* Recursive inheritance detected in package '%s': perldiag.
* Recursive inheritance detected while looking for method '%s' in package '%s': perldiag.
* Reference found where even-sized list expected: perldiag.
* Reference is already weak:             perldiag.
* Reference miscount in sv_replace():    perldiag.
* regexp *+ operand could be empty:      perldiag.
* regexp memory corruption:              perldiag.
* regexp out of space:                   perldiag.
* Repeat count in pack overflows:        perldiag.
* Repeat count in unpack overflows:      perldiag.
* Reversed %s= operator:                 perldiag.
* Runaway format:                        perldiag.
* Scalar value @%s[%s] better written as $%s[%s]: perldiag.
* Scalar value @%s{%s} better written as $%s{%s}: perldiag.
* Script is not setuid/setgid in suidperl: perldiag.
* Search pattern not terminated:         perldiag.
* select not implemented:                perldiag.
* sem%s not implemented:                 perldiag.
* semi-panic: attempt to dup freed string: perldiag.
* Semicolon seems to be missing:         perldiag.
* send() on closed socket %s:            perldiag.
* Sequence (? incomplete:                perldiag.
* Sequence (?#... not terminated:        perldiag.
* Sequence (?%s...) not implemented:     perldiag.
* Sequence (?%s...) not recognized:      perldiag.
* Server error:                          perldiag.
* setegid() not implemented:             perldiag.
* seteuid() not implemented:             perldiag.
* setpgrp can't take arguments:          perldiag.
* setrgid() not implemented:             perldiag.
* setruid() not implemented:             perldiag.
* Setuid/gid script is writable by world: perldiag.
* shm%s not implemented:                 perldiag.
* shutdown() on closed socket %s:        perldiag.
* SIG%s handler "%s" not defined:        perldiag.
* sort is now a reserved word:           perldiag.
* Sort subroutine didn't return a numeric value: perldiag.
* Sort subroutine didn't return single value: perldiag.
* Split loop:                            perldiag.
* Stat on unopened file <%s>:            perldiag.
* Statement unlikely to be reached:      perldiag.
* Strange *+?{} on zero-length expression: perldiag.
* Stub found while resolving method `%s' overloading `%s' in package `%s': perldiag.
* Subroutine %s redefined:               perldiag.
* Substitution loop:                     perldiag.
* Substitution pattern not terminated:   perldiag.
* Substitution replacement not terminated: perldiag.
* substr outside of string:              perldiag.
* suidperl is no longer needed since %s: perldiag.
* switching effective %s is not implemented: perldiag.
* syntax error:                          perldiag.
* syntax error at line %d: `%s' unexpected: perldiag.
* System V %s is not implemented on this machine: perldiag.
* syswrite() on closed filehandle %s:    perldiag.
* Target of goto is too deeply nested:   perldiag.
* tell() on unopened file:               perldiag.
* Test on unopened file <%s>:            perldiag.
* That use of $[ is unsupported:         perldiag.
* The %s function is unimplemented:      perldiag.
* The crypt() function is unimplemented due to excessive paranoia: perldiag.
* The stat preceding -l _ wasn't an lstat: perldiag.
* This Perl can't reset CRTL environ elements (%s): perldiag.
* times not implemented:                 perldiag.
* Too few args to syscall:               perldiag.
* Too late for "-%s" option:             perldiag.
* Too late for "-T" option:              perldiag.
* Too late to run %s block:              perldiag.
* Too many ('s:                          perldiag.
* Too many args to syscall:              perldiag.
* Too many arguments for %s:             perldiag.
* trailing \ in regexp:                  perldiag.
* Transliteration pattern not terminated: perldiag.
* Transliteration replacement not terminated: perldiag.
* truncate not implemented:              perldiag.
* Type of arg %d to %s must be %s (not %s): perldiag.
* umask not implemented:                 perldiag.
* umask: argument is missing initial 0:  perldiag.
* Unable to create sub named "%s":       perldiag.
* Unbalanced context: %d more PUSHes than POPs: perldiag.
* Unbalanced saves: %d more saves than restores: perldiag.
* Unbalanced scopes: %d more ENTERs than LEAVEs: perldiag.
* Unbalanced tmps: %d more allocs than frees: perldiag.
* Undefined format "%s" called:          perldiag.
* Undefined sort subroutine "%s" called: perldiag.
* Undefined subroutine &%s called:       perldiag.
* Undefined subroutine called:           perldiag.
* Undefined subroutine in sort:          perldiag.
* Undefined top format "%s" called:      perldiag.
* Undefined value assigned to typeglob:  perldiag.
* unexec of %s into %s failed!:          perldiag.
* Unknown BYTEORDER:                     perldiag.
* Unknown open() mode '%s':              perldiag.
* Unknown process %x sent message to prime_env_iter: %s: perldiag.
* unmatched () in regexp:                perldiag.
* unmatched [] in regexp:                perldiag.
* Unmatched right %s bracket:            perldiag.
* Unquoted string "%s" may clash with future reserved word: perldiag.
* Unrecognized character %s:             perldiag.
* Unrecognized escape \\%c passed through: perldiag.
* Unrecognized signal name "%s":         perldiag.
* Unrecognized switch: -%s  (-h will show valid options): perldiag.
* Unsuccessful %s on filename containing newline: perldiag.
* Unsupported directory function "%s" called: perldiag.
* Unsupported function %s:               perldiag.
* Unsupported function fork:             perldiag.
* Unsupported socket function "%s" called: perldiag.
* Unterminated <> operator:              perldiag.
* Unterminated attribute list:           perldiag.
* Unterminated attribute parameter in attribute list: perldiag.
* untie attempted while %d inner references still exist: perldiag.
* Use of $# is deprecated:               perldiag.
* Use of $* is deprecated:               perldiag.
* Use of %s in printf format not supported: perldiag.
* Use of %s is deprecated:               perldiag.
* Use of bare << to mean <<"" is deprecated: perldiag.
* Use of implicit split to @_ is deprecated: perldiag.
* Use of inherited AUTOLOAD for non-method %s() is deprecated: perldiag.
* Use of reserved word "%s" is deprecated: perldiag.
* Use of uninitialized value%s:          perldiag.
* Useless use of "re" pragma:            perldiag.
* Useless use of %s in void context:     perldiag.
* Value of %s can be "0"; test with defined(): perldiag.
* Value of CLI symbol "%s" too long:     perldiag.
* Variable "%s" is not imported%s:       perldiag.
* Variable "%s" may be unavailable:      perldiag.
* Variable "%s" will not stay shared:    perldiag.
* Variable syntax:                       perldiag.
* Version number must be a constant number: perldiag.
* Warning: something's wrong:            perldiag.
* Warning: unable to close filehandle %s properly: perldiag.
* Warning: Use of "%s" without parentheses is ambiguous: perldiag.
* write() on closed filehandle %s:       perldiag.
* X outside of string:                   perldiag.
* x outside of string:                   perldiag.
* Xsub "%s" called in sort:              perldiag.
* Xsub called in sort:                   perldiag.
* You can't use -l on a filehandle:      perldiag.
* YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!: perldiag.
* You need to quote "%s":                perldiag.




