This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Text/Header,  Next: Text/Hyphenate,  Prev: Text/Graphics,  Up: Module List

RFC 822/2068 header and `unheader' functions
********************************************

NAME
====

   Text::Header - RFC 822/2068 header and `unheader' functions

SYNOPSIS
========

     use Text::Header;     # header and unheader exported

     # Construct headers similar to CGI.pm and HTTP::Headers

     @HEADERS = header(content_type => 'text/html',
                       author => 'Nathan Wiger',
                       last_modified => $date,
                       accept => [qw(text/html text/plain)]);

     # The above produces the array:

     @HEADERS = ("Content-Type: text/html\n",
                 "Author: Nathan Wiger\n",
                 "Last-Modified: Wed Sep 27 13:31:06 PDT 2000\n",
                 "Accept: text/html, text/plain\n");

     # Can also construct SMTP headers to format mail

     @mail_headers = header(from => 'Nathan Wiger <nate@sun.com>',
                            to => 'perl5-porters@perl.org');
     
     print $MAIL @mail_headers, "\nKeep up the great work!\n";

     # The above would print this to the $MAIL handle:

     From: Nathan Wiger <nate@sun.com>
     To: perl5-porters@perl.org

     Keep up the great work!

DESCRIPTION
===========

   This module provides two new functions, header and `unheader', which
provide general-purpose RFC 822 header construction and parsing.  They do
not provide any intelligent defaults of HTTP-specific methods.  They are
simply aimed at providing an easy means to address the mechanics of header
parsing.

   The output style is designed to mimic `CGI.pm' and `HTTP::Headers', so
that users familiar with these interfaces will feel at home with these
functions. As shown above, the headers function automatically does the
following:

     1. uc's the first letter of each tag token and lc's the
        rest, also converting _'s to -'s automatically

     2. Adds a colon separating each tag and its value, and
        exactly one newline after each one

     3. Combines list elements into a comma-delimited
        string

   Note that a list is always joined into a comma-delimited string. To
insert multiple separate headers, simply call header with multiple args:

     push @out, header(accept => 'text/html',
                       accept => 'text/plain');

   This would create multiple "Accept:" lines.

   Note that unlike `CGI.pm', the header function provided here does not
provide any intelligent defaults. If called as:

     @out_headers = header;

   It will return an empty list. This allows header to be more general
pupose, so it can provide SMTP and other headers as well. You can also use
it as a generic text formatting tool, hence the reason it's under the
`Text::' hierarchy.

   The `unheader' function works in exactly the opposite direction from
header, pulling apart headers and returning a list. `unheader':

     1. lc's the entire tag name, converting -'s to _'s

     2. Separates each tag based on the colon delimiter,
        chomping newlines.

     3. Returns a list of tag/value pairs for easy assignment
        to a hash

   So, assuming the `@HEADERS' array shown up top:

     %myheaders = unheader(@HEADERS);

   The hash `%myheaders' would have the following values:

     %myheaders = (
         content_type => 'text/html',
         author => 'Nathan Wiger',
         last_modified => 'Wed Sep 27 13:31:06 PDT 2000',
         accept => 'text/html, text/plain'
     );

   Note that all keys are converted to lowercase, and their values have
their newlines stripped. However, note that comma-separated fields are not
split up on input. This cannot be done reliably because some fields, such
as the HTTP `Date:' header, can contain commas even though they are not
lists. Inferring this type of structure would require knowledge of
content, and these functions are specifically designed to be
content-independent.

   The `unheader' function will respect line wrapping, as seen in SMTP
headers. It will simply join the lines and return the value, so that:

     %mail = unheader("To: Nathan Wiger <nate@sun.com>,
                               perl5-porters@perl.org");

   Would return:

     $mail{to} = "Nathan Wiger <nate@sun.com>, perl5-porters@perl.org"

   Notice that multiple spaces between the comma separator have been
condensed to a single space. Since the header and `unheader' functions are
direct inverses, this call:

     @out = header unheader @in;

   Will result in `@out' being exactly equivalent to `@in'.

REFERENCES
==========

   This is designed as both a Perl 5 module and also a Perl 6 prototype.
Please see the Perl 6 proposal at http://dev.perl.org/rfc/333.html

   This module is designed to be fully compliant with the internet
standards RFC 822 (SMTP Headers) and RFC 2068 (HTTP Headers).

AUTHOR
======

   Copyright (c) 2000 Nathan Wiger <nate@sun.com>. All Rights Reserved.

   This module is free software; you may copy this under the terms of the
GNU General Public License, or the Artistic License, copies of which
should have accompanied your Perl kit.


File: pm.info,  Node: Text/Hyphenate,  Next: Text/Iconv,  Prev: Text/Header,  Up: Module List

Perl extension for blah blah blah
*********************************

NAME
====

   Text::Hyphenate - Perl extension for blah blah blah

SYNOPSIS
========

     use Text::Hyphenate qw(hyphenate);

     $hyphenated = hyphenate($width, $text);

     # OR:

     $hyphenater = Text::Hyphenate->new($width);
     $hyphenated = $hyphenater->hyphenate($text);
     
     =head1 DESCRIPTION

   Stub documentation for Text::Hyphenate was created by h2xs. It looks
like the author of the extension was negligent enough to leave the stub
unedited.

   Blah blah blah.

AUTHOR
======

   A. U. Thor, a.u.thor@a.galaxy.far.far.away

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Text/Iconv,  Next: Text/Ispell,  Prev: Text/Hyphenate,  Up: Module List

Perl interface to iconv() codeset conversion function
*****************************************************

NAME
====

   Text::Iconv - Perl interface to iconv() codeset conversion function

SYNOPSIS
========

     use Text::Iconv;
     $converter = Text::Iconv->new("fromcode", "tocode");
     $converted = $converter->convert("Text to convert");

DESCRIPTION
===========

   The *Text::Iconv* module provides a Perl interface to the iconv()
function as defined by the Single UNIX Specification.  The convert()
method converts the encoding of characters in the input string from the
*fromcode* codeset to the *tocode* codeset, and returns the result.

   Settings of *fromcode* and *tocode* and their permitted combinations
are implementation-dependent.  Valid values are specified in the system
documentation

ERRORS
======

   If the conversion can't be initialized an exception is raised (using
croak()).

   As an experimental feature, this version of *Text:Iconv* provides a new
class attribute *raise_error* and a corresponding class method for setting
and getting its value.  The handling of errors during conversion now
depends on the setting of this attribute.  If *raise_error* is set to a
true value, an exception is raised; otherwise, the convert() method only
returns undef.  By default *raise_error* is false.  Warnings are no longer
emitted.  Example usage:

     Text::Iconv->raise_error(1);     # Conversion errors raise exceptions
     Text::Iconv->raise_error(0);     # Conversion errors return undef
     $a = Text::Iconv->raise_error(); # Get current setting

   Consult `iconv(3)' in this node for details on errors that might occur.

NOTES
=====

   The supported codesets, their names, the supported conversions, and the
quality of the conversions are all system-dependent.

AUTHOR
======

   Michael Piotrowski <mxp@dynalabs.de>

SEE ALSO
========

   iconv(1), iconv(3)


File: pm.info,  Node: Text/Ispell,  Next: Text/LineEditor,  Prev: Text/Iconv,  Up: Module List

a module encapsulating access to the Ispell program.
****************************************************

NAME
====

   Text::Ispell.pm - a module encapsulating access to the Ispell program.

SYNOPSIS
========

     # Brief:
     use Text::Ispell;
     Text::Ispell::spellcheck( $string );
     # or
     use Text::Ispell qw( spellcheck ); # import the function
     spellcheck( $string );

     # Useful:
     use Text::Ispell qw( :all );  # import all symbols
     for my $r ( spellcheck( "hello hacking perl shrdlu 42" ) ) {
       print "$r->{'type'}: $r->{'term'}\n";
     }

DESCRIPTION
===========

   Text::Ispell::spellcheck() takes one argument.  It must be a string,
and it should contain only printable characters.  One allowable exception
is a terminal newline, which will be chomped off anyway.  The line is fed
to a coprocess running ispell for analysis.  The line is parsed on
non-wordchars into a sequence of terms.  By default, the set of wordchars
is defined in ispell as letters, digits, and the apostrophe.  In other
words, the line is subjected the equivalent of

     split /[^a-zA-Z0-9']+/

   (ispell has a means to add characters to the default set, but currently
Text::Ispell does not provide access to that feature.)

   The result of ispell's analysis of each term is a categorization of the
term into one of six types: ok, root, miss, none, compound, and guess.
Some of these carry additional information.

   Text::Ispell::spellcheck returns a list of objects, each corresponding
to a term in the spellchecked string.  Each object is a hash (hash-ref)
with at least two entries: 'term' and 'type'.  The former contains the
term ispell is reporting on, and the latter is ispell's determination of
that term's type (see above).  For types 'ok' and 'none', that is all the
information there is.  For the type 'root', an additional hash entry is
present: 'root'.  Its value is the word which ispell identified in the
dictionary as being the likely root of the current term.  For the type
'miss', an additional hash entry is present: 'misses'.  Its value is a
string of words, comma-separated, which ispell identified as being
"near-misses" of the current term, when scanning the dictionary.

   A quickie example:

     use Text::Ispell qw( spellcheck );
     Text::Ispell::allow_compounds(1);
     for my $r ( spellcheck( "hello hacking perl salmoning fruithammer shrdlu 42" ) ) {
       if ( $r->{'type'} eq 'ok' ) {
         # as in the case of 'hello'
         print "'$r->{'term'}' was found in the dictionary.\n";
       }
       elsif ( $r->{'type'} eq 'root' ) {
         # as in the case of 'hacking'
         print "'$r->{'term'}' can be formed from root '$r->{'root'}'\n";
       }
       elsif ( $r->{'type'} eq 'miss' ) {
         # as in the case of 'perl'
         print "'$r->{'term'}' was not found in the dictionary;\n";
         print "Near misses: $r->{'misses'}\n";
       }
       elsif ( $r->{'type'} eq 'guess' ) {
         # as in the case of 'salmoning'
         print "'$r->{'term'}' was not found in the dictionary;\n";
         print "Root/affix Guesses: $r->{'guesses'}\n";
       }
       elsif ( $r->{'type'} eq 'compound' ) {
         # as in the case of 'fruithammer'
         print "'$r->{'term'}' is a valid compound word.\n";
       }
       elsif ( $r->{'type'} eq 'none' ) {
         # as in the case of 'shrdlu'
         print "No match for term '$r->{'term'}'\n";
       }
       # and numbers are skipped entirely, as in the case of 42.
     }

ERRORS
------

   `Text::Ispell::spellcheck()' starts the ispell coprocess if the
coprocess seems not to exist.  Ordinarily this is simply the first time
it's called.

   ispell is spawned via the `Open2::open2()' function, which throws an
exception (i.e. dies) if the spawn fails.  The caller should be prepared
to catch this exception - unless, of course, the default behavior of die
is acceptable.

Nota Bene
---------

   The full location of the ispell executable is stored in the variable
`$Text::Ispell::path'.  The default value is `/usr/local/bin/ispell'.  If
your ispell executable has some name other than this, then you must set
`$Text::Ispell::path' accordingly before you call
`Text::Ispell::spellcheck()' (or any other function in the module) for the
first time!

AUX FUNCTIONS
=============

add_word(word)
--------------

   Adds a word to the personal dictionary.  Be careful of capitalization.
If you want the word to be added "case-insensitively", you should call
`add_word_lc()'

add_word_lc(word)
-----------------

   Adds a word to the personal dictionary, in lower-case form.  This
allows ispell to match it in a case-insensitive manner.

accept_word(word)
-----------------

   Similar to adding a word to the dictionary, in that it causes ispell to
accept the word as valid, but it does not actually add it to the
dictionary.  Presumably the effects of this only last for the current
ispell session, which will mysteriously end if any of the
coprocess-restarting functions are called...

parse_according_to(formatter)
-----------------------------

   Causes ispell to parse subsequent input lines according to the
specified formatter.  As of ispell v. 3.1.20, only 'tex' and 'nroff' are
supported.

set_params_by_language(language)
--------------------------------

   Causes ispell to set its internal operational parameters according to
the given language.  Legal arguments to this function, and its effects,
are currently unknown by the author of Text::Ispell.

save_dictionary()
-----------------

   Causes ispell to save the current state of the dictionary to its disk
file.  Presumably ispell would ordinarily only do this upon exit.

terse_mode(bool:terse)
----------------------

   In terse mode, ispell will not produce reports for "correct" words.
This means that the calling program will not receive results of the types
'ok', 'root', and 'compound'.

   ispell starts up in NON-terse mode, i.e. reports are produced for all
terms, not just "incorrect" ones.

FUNCTIONS THAT RESTART ISPELL
=============================

   The following functions cause the current ispell coprocess, if any, to
terminate.  This means that all the changes to the state of ispell made by
the above functions will be lost, and their respective values reset to
their defaults.  The only function above whose effect is persistent is
save_dictionary().

   Perhaps in the future we will figure out a good way to make this state
information carry over from one instantiation of the coprocess to the next.

allow_compounds(bool)
---------------------

   When this value is set to True, compound words are accepted as legal -
as long as both words are found in the dictionary; more than two words are
always illegal.  When this value is set to False, run-together words are
considered spelling errors.

   The default value of this setting is dictionary-dependent, so the
caller should set it explicitly if it really matters.

make_wild_guesses(bool)
-----------------------

   This setting controls when ispell makes "wild" guesses.

   If False, ispell only makes "sane" guesses, i.e.  possible root/affix
combinations that match the current dictionary; only if it can find none
will it make "wild" guesses, which don't match the dictionary, and might
in fact be illegal words.

   If True, wild guesses are always made, along with any "sane" guesses.
This feature can be useful if the dictionary has a limited word list, or a
word list with few suffixes.

   The default value of this setting is dictionary-dependent, so the
caller should set it explicitly if it really matters.

use_dictionary([dictionary])
----------------------------

   Specifies what dictionary to use instead of the default.  Dictionary
names are actually file names, and are searched for according to the
following rule: if the name does not contain a slash, it is looked for in
the directory containing the default dictionary, typically /usr/local/lib.
Otherwise, it is used as is: if it does not begin with a slash, it is
construed from the current directory.

   If no argument is given, the default dictionary will be used.

use_personal_dictionary([dictionary])
-------------------------------------

   Specifies what personal dictionary to use instead of the default.

   Dictionary names are actually file names, and are searched for
according to the following rule: if the name begins with a slash, it is
used as is (i.e. it is an absolute path name). Otherwise, it is construed
as relative to the user's home directory ($HOME).

   If no argument is given, the default personal dictionary will be used.

FUTURE ENHANCEMENTS
===================

   ispell options:

     -w chars
          Specify additional characters that can be part of a word.

DEPENDENCIES
============

   Text::Ispell uses the external program ispell, which is the
"International Ispell", available at

     http://fmg-www.cs.ucla.edu/geoff/ispell.html

   as well as various archives and mirrors, such as

     ftp://ftp.math.orst.edu/pub/ispell-3.1/

   This is a very popular program, and may already be installed on your
system.

   Text::Ispell also uses the standard perl modules FileHandle,
IPC::Open2, and Carp.

AUTHOR
======

   jdporter@min.net (John Porter)

   This module is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Text/LineEditor,  Next: Text/MacroScript,  Prev: Text/Ispell,  Up: Module List

simple line  editor
*******************

NAME
====

   Text::LineEditor - simple line  editor

SYNOPSIS
========

     use Text::LineEditor;

     $text = &line_editor();

DESCRIPTION
===========

   `Text::LineEditor' implements a -very- simple editor like Berkley mail
used to use.

FUNCTIONS
=========

line_editor ();
     Returns the text entered.  If the text has been abandoned with ~x it
     returns an empty string.

EDITING COMMANDS
================

   To append text, just type.  To end, type '.' by itself on a line.
Tilde commands for editing (by themselves on a line):    ~h     This help
message    ~e, ~v Edit message using visual editor    ~w <filename>
  Write current text to file <filename>    ~p     Print current text
using 'lpr'    ~.     End message as normal    ~x     Quit, abandon text


File: pm.info,  Node: Text/MacroScript,  Next: Text/Macros,  Prev: Text/LineEditor,  Up: Module List

A macro pre-processor with embedded perl capability
***************************************************

NAME
====

   Text::MacroScript - A macro pre-processor with embedded perl capability

SYNOPSIS
========

     use Text::MacroScript ;

     # new() for macro processing

     my $Macro = Text::MacroScript->new ;
     while( <> ) {
         print $Macro->expand( $_ ) if $_ ;
     }

     # Canonical use (the filename improves error messages):
     my $Macro = Text::MacroScript->new ;
     while( <> ) {
         print $Macro->expand( $_, $ARGV ) if $_ ;
     }

     # new() for embedded macro processing

     my $Macro = Text::MacroScript->new( -embedded => 1 ) ;
     # Delimiters default to <: and :>
     # or
     my $Macro = Text::MacroScript->new( -opendelim => '[[', -closedelim => ']]' ) ;
     while( <> ) {
         print $Macro->expand_delimited( $_, $ARGV ) if $_ ;
     }

     # Create a macro object and create initial macros/scripts from the file(s)
     # given:
     my $Macro = Text::MacroScript->new(
                     -file => [ 'local.macro', '~/.macro/global.macro' ]
                     ) ;

     # Create a macro object and create initial macros/scripts from the
     # definition(s) given:
     my $Macro = Text::MacroScript->new(
                     -macro => [
                             [ 'MAX_INT' => '32767' ],
                         ],
                     -script => [
                         [ 'DHM2S' =>
                             [
                                 my $s = (#0*24*60*60)+(#1*60*60)+(#2*60) ;
                                 "#0 days, #1 hrs, #2 mins = $s secs"
                             ],
                         ],
                     -variable => [ '*MARKER*' => 0 ],
                     ) ;

     # We may of course use any combination of the options.

     my $Macro = Text::MacroScript->new( -comment => 1 ) ; # Create the %%[] macro.

     # define()

     $Macro->define( -macro, $macroname, $macrobody ) ;

     $Macro->define( -script, $scriptname, $scriptbody ) ;

     $Macro->define( -variable, $variablename, $variablebody ) ;

     # undefine()

     $Macro->undefine( -macro, $macroname ) ;

     $Macro->undefine( -script, $scriptname ) ;

     $Macro->undefine( -variable, $variablename ) ;

     # undefine_all()

     $Macro->undefine( -macro ) ;

     $Macro->undefine( -script ) ;

     $Macro->undefine( -variable ) ;

     # list()

     @macros    = $Macro->list( -macro ) ;
     @macros    = $Macro->list( -macro, -namesonly ) ;

     @scripts   = $Macro->list( -script ) ;
     @scripts   = $Macro->list( -script, -namesonly ) ;

     @variables = $Macro->list( -variable ) ;
     @variables = $Macro->list( -variable, -namesonly ) ;

     # load_file() - always treats the contents as within delimiters if we are
     # doing embedded processing.

     $Macro->load_file( $filename ) ;

     # expand_file() - calls expand_embedded() if we are doing embedded
     # processing otherwise calls expand().

     $Macro->expand_file( $filename ) ;
     @expanded = $Macro->expand_file( $filename ) ;

     # expand()

     $expanded = $Macro->expand( $unexpanded ) ;
     $expanded = $Macro->expand( $unexpanded, $filename ) ;

     # expand_embedded()

     $expanded = $Macro->expand_embedded( $unexpanded ) ;
     $expanded = $Macro->expand_embedded( $unexpanded, $filename ) ;

   This bundle also includes the macro and `macrodir' scripts which allows
us to expand macros without having to use/understand
`Text::MacroScript.pm', although you will have to learn the handful of
macro commands available and which are documented here and in macro. macro
provides more documentation on the embedded approach.

   The `macroutil.pl' library supplied provides some functions which you
may choose to use in HTML work for example.

DESCRIPTION
===========

   Define macros, scripts and variables in macro files or directly in text
files.

   Commands may appear in separate macro files which are loaded in either
via the text files they process (e.g. via the `%LOAD' command), or may be
embedded directly in text files. Almost every command that can appear in a
file has an equivalent object method so that programmers may achieve the
same things in code as can be achieved by macro commands in texts; there
are also additional methods which have no command equivalents.

   Most the examples given here use the macro approach. However this
module now directly supports an embedded approach and this is now
documented. Although you may specify your own delimiters where shown in
examples we use the default delimiters of `>:' and `:<' throughout.

Public methods
--------------

     new         class   object
     get         class   object
     define              object
     undefine            object
     list                object
     undefine_all        object
     load_file           object
     expand_file         object
     expand              object
     expand_embedded     object

Summary of Commands
-------------------

   These commands may appear in separate `macro' files, and/or in the body
of files. Wherever a macroname or scriptname is encountered it will be
replaced by the body of the macro or the result of the evaluation of the
script using any parameters that are given.

   Note that if we are using an embedded approach commands, macro names and
script names should appear between delimiters. (Except when we `%LOAD'
since this assumes the whole file is `embedded'.)

     %DEFINE macroname [macro body]

     %DEFINE macroname
     multi-line
     macro body
     #0, #1 are the first and second parameters if any used
     %END_DEFINE

     %UNDEFINE macroname

     %UNDEFINE_ALL   # Undefine all macros

     %DEFINE_SCRIPT scriptname [script body]

     %DEFINE_SCRIPT scriptname
     multi-line
     script body
     arbitrary perl
     optional parameters are in @Param, although #0, etc may be used
     any variables are in %Var, although #varname may be used
     %END_DEFINE

     %UNDEFINE scriptname

     %UNDEFINE_ALL_SCRIPT

     %DEFINE_VARIABLE variablename [variable value]

     %UNDEFINE variablename

     %UNDEFINE_ALL_VARIABLE

     %LOAD[path/filename]    # Instantiate macros/scripts/variables in this
                             # file, but discard the text

     %INCLUDE[path/filename] # Instantiate macros/scripts/variables in this
                             # file and output the resultant text

     %REQUIRE[path/filename] # Make Perl require a file e.g. of functions,
                             # modules, etc. which can then be accessed within
                             # scripts.
     
     %CASE [condition]       # Provides #ifdef-type functionality
     %END_CASE

   Thus, in the body of a file we may have, for example:

     %DEFINE &B [Billericky Rickety Builders]
     Some arbitrary text.
     We are writing to complain to the &B about the shoddy work they did.

   If we are taking the embedded approach the example above might become:

     <:%DEFINE BB [Billericky Rickety Builders]:>
     Some arbitrary text.
     We are writing to complain to the <:BB:> about the shoddy work they did.

   When using an embedded approach we don't have to make the macro or
script name unique within the text, (although each must be distinct from
each other), since the delimiters are used to signify them. However since
expansion applies recursively it is still wise to make names distinctive.

Macro systems vs embedded systems
---------------------------------

   Macro systems read all the text, substituting anything which matches a
macro name with the macro's body (or script name with the result of the
execution of the script). This makes macro systems slower (they have to
check for macro/script names everywhere, not just in a delimited section)
and more risky (if we choose a macro/script name that normally occurs in
the text we'll end up with a mess) than embedded systems. On the other
hand because they work on the whole text not just delimited bits, macro
systems can perform processing that embedded systems can't. Macro systems
are used extensively, for example the CPP, C pre-processor, with its
#DEFINE's, etc.

   Essentially, embedded systems print all text until they hit an opening
delimiter. They then execute any code up until the closing delimiter. The
text that results replaces everything between and including the
delimeters. They then carry on printing text until they hit an opening
delimeter and so on until they've finished processing all the text. This
module now provides both approaches.

Creating macro objects with new()
---------------------------------

   For macro processing:

     my $Macro = Text::MacroScript->new ;

   For embedded macro processing:

     my $Macro = Text::MacroScript->new( -embedded => 1 ) ;
     # Delimiters default to <: and :>

   Or specify your own delimiters:

   my $Macro = Text::MacroScript->new( -opendelim => '[[', -closedelim =>
']]' ) ;

   Or specify one delimiter to use for both (probably not wise):

     my $Macro = Text::MacroScript->new( -opendelim => '%%' ) ;
     # -closedelim defaults to -opendelim, e.g. %% in this case

   The full list of options that may be specified at object creation:

   `-comment' optional integer; 1 = create the `%%[]' comment macro;
default 0.

   `-file' optional array reference of strings; read macros and scripts
from the file(s) given - they are `%LOAD'ed so are treated as already
embedded if we are doing embedded processing. Default is a reference to an
empty array.

   `-macro' optional array reference of macros, in the form:

     my $Macro = Text::MacroScript->new(
                     -macro => [
                         ["name1"=>"body1"],
                         ["name2"=>"body2"],
                         ["name3"=>"body3"],
                     ],
                     ) ;

   Default is a reference to an empty array.

   `-script' optional array reference of scripts, in the form:

     my $Macro = Text::MacroScript->new(
                     -script => [
                         ["name1"=>"body1"],
                         ["name2"=>"body2"],
                         ["name3"=>"body3"],
                     ],
                     ) ;

   Default is a reference to an empty array.

   `-variable' optional array reference of variables, in the form:

     my $Macro = Text::MacroScript->new(
                     -variable => [
                         ["name1"=>"value1"],
                         ["name2"=>"value2"],
                         ["name3"=>"value3"],
                     ],
                     ) ;

   Default is a reference to an empty array.

   `-embedded' optional integer, 1 = use embedded processing; 0 = use macro
processing. Default is 0. If set to 1 then the delimiters become <: and :>
unless otherwise specified.

   `-opendelim' optional string, default is undef unless `-embedded' is 1
in which case default is <: if `-opendelim' is undefined or the empty
string.

   `-closedelim' optional string, default is undef unless `-embedded' is 1
in which case default is :> if `-closedelim' is undefined or the empty
string and `-opendelim' is <: or `-opendelim' if `-opendelim' is not <:.

Defining Macros with `%DEFINE' and define()
-------------------------------------------

   In files we would write:

     %DEFINE MAC [The Mackintosh Macro]

   The equivalent method call is:

     $Macro->define( -macro, 'MAC', 'The Mackintosh Macro' ) ;

   We can call our macro anything, excluding white-space characters and [,
although [ is not advised. So a name like `%*&!' is fine - indeed names
which could not normally appear in the text are recommended to avoid
having the wrong thing substituted. We should also avoid calling macros,
scripts or variables names beginning with #. All names are case-sensitive.

   Note that if we define a macro and then a script with the same name the
script will effectively replace the macro.

   We can have parameters (for macros and scripts), e.g.:

     %DEFINE *P [The forename is #0 and the surname is #1]

   Parameters used in the source text can contain square brackets since
macro will grab up to the last square bracket on the line. The only thing
we can't pass are `|'s since these are used to separate parameters.
White-space between the macro name and the [ is optional in definitions
but *not allowed* in the source text.

   Parameters are named #0, #1, etc. There is a limit of 100 parameters,
i.e.  #0..#99, and we must use all those we specify. In the example above
we must use *P[param1|param2], e.g. *P[Jim|Hendrix]; if we don't
`Text::MacroScript.pm' will croak. Note that macro names and their
parameters must all be on the same line (although this is relaxed if you
use paragraph mode).

   Because we use # to signify parameters if you require text that
consists of a # followed by digits then you should escape the #, e.g.

     %DEFINE *GRAY[<font color="\#121212">#0</font>]

   We can use as many more parameters than we need, for example add a
third to document: *P[Jim|Hendrix|Musician] will become `The forename is
Jim and the surname is Hendrix', just as in the previous example; the
third parameter, `Musician', will simply be thrown away.

   If we take an embedded approach we might write this example thus:

     <:%DEFINE P [The forename is #0 and the surname is #1]:>

   and in the text, <:P[Jim|Hendrix]:> will be transformed appropriately.

   If we define a macro, script or variable and later define the same name
the later definition will replace the earlier one. This is useful for
making local macro definitions over-ride global ones, simply by loading
the global ones first.

   Although macros can have plain textual names like this:

     %DEFINE MAX_INT [32767]

   It is generally wise to use a prefix and/or suffix to make sure we don't
expand something unintentionally, e.g.

     %DEFINE $MAX_INT [65535]

   *Macro expansion is no respector of quoted strings or anything else* -
*if the name matches the expansion will take place!*

   Multi-line definitions are permitted (here's an example I use with the
lout typesetting language):

     %DEFINE SCENE
     @Section
         @Title {#0}
     @Begin
     @PP
     @Include {#1}
     @End @Section
     %END_DEFINE

   This allows us to write the following in our lout files:

     SCENE[ The title of the scene | scene1.lt ]

   which is a lot shorter than the definition.

   The body of a macro may not contain a literal null. If you really need
one then use a script and represent the null as `chr(0)'.

   *Converting a macro to a script*

   This can be achieved very simply. For a one line macro simply enclose
the body between qq{ and }, e.g.

     %DEFINE $SURNAME [Baggins]

   becomes

     %DEFINE_SCRIPT $SURNAME [qq{Baggins}]

   For a multi-line macro use a here document, e.g.

     %DEFINE SCENE
     @Section
         @Title {#0}
     @Begin
     @PP
     @Include {#1}
     @End @Section
     %END_DEFINE

   becomes

     %DEFINE_SCRIPT SCENE
     <<__EOT__
     \@Section
         \@Title {#0}
     \@Begin
     \@PP
     \@Include {#1}
     \@End \@Section
     __EOT__
     %END_DEFINE

   Note that the @s had to be escaped because they have a special meaning
in perl.

Defining Scripts with `%DEFINE_SCRIPT' and define()
---------------------------------------------------

   Instead of straight textual substitution, we can have some perl executed
(after any parameters have been replaced in the perl text):

     %DEFINE_SCRIPT *ADD ["#0 + #1 = " . (#0 + #1)]

   or by using the equivalent method call:

     $Macro->define( -script, '*ADD', '"#0 + #1 = " . (#0 + #1)' ) ;

   These would be used as *ADD[5|11] in the text which would be output as:

     These would be used as 5 + 11 = 16 in the text...

   In script definitions we can use an alternative way of passing
parameters instead of or in addition to the #0 syntax.

   This is particularly useful if we want to take a variable number of
parameters since the #0 etc syntax does not provide for this. An array
called `@Param' is available to our perl code that has any parameters.
This allows things like the following to be achieved:

     %DEFINE_SCRIPT ^PEOPLE
     # We don't use the name hash number params but read straight from the
     # array:
     my $a = "friends and relatives are " ;
     $a .= join ", ", @Param ;
     $a ;
     %END_DEFINE

   The above would expand in the following text:

     Her ^PEOPLE[Anna|John|Zebadiah].

   to     Her friends and relatives are Anna, John, Zebadiah.

   In addition to having access to the parameters either using the #0
syntax or the `@Param' array, we can also access any variables that have
been defined using `%DEFINE_VARIABLE' (see later). These are accessible
either using #variablename similarly to the #0 parameter syntax, or via
the `%Var' hash.  Although we can change both `@Param' and `%Var' elements
in our script, the changes to `@Param' only apply within the script
whereas changes to `%Var' apply from that point on globally.

   Note that if you require a literal # followed by digits in a script
body then you must escape the # like this `\#'.

   Macro names can be any length and consist of any characters (including
non-printable which is probably only useful within code), except
white-space and [, although ] is not recommended and a leading # should be
avoided.

   Here's a simple date-stamp style:

     %DEFINE_SCRIPT *DATESTAMP
     {
         my( $d, $m, $y ) = (localtime( time ))[3..5] ;
         $m++ ;
         $m = "0$m" if $m < 10 ;
         $d = "0$d" if $d < 10 ;
         $y += 1900 ;
         "#0 on $y/$m/$d" ;
     }
     %END_DEFINE

   If we wanted to add the above in code we'd have to make sure the
$variables weren't interpolated:

     $Macro->define( -script, '*DATESTAMP', <<'__EOT__' ) ;
     {
         my( $d, $m, $y ) = (localtime( time ))[3..5] ;
         $m++ ;
         $m = "0$m" if $m < 10 ;
         $d = "0$d" if $d < 10 ;
         $y += 1900 ;
         "#0 on $y/$m/$d" ;
     }
     __EOT__
     
     Here's (a somewhat contrived example of) how the above would be used:

     <HTML>
     <HEAD><TITLE>Test Page</TITLE></HEAD>
     <BODY>
     *DATESTAMP[Last Updated]<P>
     This page is up-to-date and will remain valid until *DATESTAMP[midnight]
     </BODY>
     </HTML>

   Thus we could have a file, `test.html.m' containing:

     %DEFINE_SCRIPT *DATESTAMP
     {
         my( $d, $m, $y ) = (localtime( time ))[3..5] ;
         $m++ ;
         $m = "0$m" if $m < 10 ;
         $d = "0$d" if $d < 10 ;
         $y += 1900 ;
         "#0 on $y/$m/$d" ;
     }
     %END_DEFINE
     <HTML>
     <HEAD><TITLE>Test Page</TITLE></HEAD>
     <BODY>
     *DATESTAMP[Last Updated]<P>
     This page is up-to-date and will remain valid until *DATESTAMP[midnight]
     </BODY>
     </HTML>

   which when expanded, either in code using `$Macro->expand()', or using
the simple macro utility supplied with `Text::MacroScript.pm':

     [1]% macro test.html.m > test.html

   `test.html' will contain just this:

     <HTML>
     <HEAD><TITLE>Test Page</TITLE></HEAD>
     <BODY>
     Last Updated on 1999/08/21<P>
     This page is up-to-date and will remain valid until midnight on 1999/08/21
     </BODY>
     </HTML>

   Of course in practice we wouldn't want to define everything in-line
like this.  See `%LOAD' later for an alternative.

   This example written in embedded style might be written thus:

     <:
     %DEFINE_SCRIPT DATESTAMP
     {
         my( $d, $m, $y ) = (localtime( time ))[3..5] ;
         $m++ ;
         $m = "0$m" if $m < 10 ;
         $d = "0$d" if $d < 10 ;
         $y += 1900 ;
         "#0 on $y/$m/$d" ;
     }
     %END_DEFINE
     :>
     <HTML>
     <HEAD><TITLE>Test Page</TITLE></HEAD>
     <BODY>
     <!-- Note how the parameter must be within the delimiters. -->
     <:DATESTAMP[Last Updated]:><P>
     This page is up-to-date and will remain valid until <:DATESTAMP[midnight]:>
     </BODY>
     </HTML>

   For more (and better) HTML examples see the example file `html.macro'.

   The body of a script may not contain a literal null. If you really need
one then represent the null as `chr(0)'.

Defining Variables with `%DEFINE_VARIABLE' and define()
-------------------------------------------------------

   We can also define variables:

     %DEFINE_VARIABLE &*! [89.1232]

   or in code:

     $Macro->define( -variable, '&*!', 89.1232 ) ;

   Note that there is no multi-line version of `%DEFINE_VARIABLE'.

   All current variables are available inside `%DEFINE_SCRIPT' scripts in
the `%Var' hash:

     %DEFINE_SCRIPT *TEST1
     $a = '' ;
     while( my( $key, $val ) each( %Var ) ) {
         $a .= "$key = $val\n" ;
     }
     $a ;
     %END_DEFINE

   Here's another example:

   %DEFINE_VARIABLE XCOORD[256]     %DEFINE_VARIABLE YCOORD[112]         :
   The X coord is *SCALE[X|16] and the Y coord is *SCALE[Y|16]

   %DEFINE_SCRIPT *SCALE     my $coord = shift @Param ;     my $scale =
shift @Param ;     my $val   = $Var{$coord} ;     $val %= scale ; # Scale
it     $val ;     %END_DEFINE

   Variables may be modified within script `%DEFINE's, e.g.

     %DEFINE_VARIABLE VV[Foxtrot]
     # VV eq 'Foxtrot'
     # other text
     # Here we use the #variable synax:
     %DEFINE_SCRIPT VV[#VV='Alpha']
     # VV eq 'Alpha' - note that we *must* refer to the script (as we've done
     # on the line following) for it to execute.
     # other text
     # Here we use perl syntax:
     %DEFINE_SCRIPT VV[$Var{'VV'}='Tango']
     # VV eq 'Tango' - note that we *must* refer to the script (as we've done
     # on the line following) for it to execute.

   As we can see variables support the #variable syntax similarly to
parameters which support #0 etc and ara available in scripts via the
`@Param' array.  Note that changing parameters within a script only apply
within the script; whereas changing variables in the `%Var' hash in a
script changes them from that point on globally.

   Variables are also used with `%CASE' (covered later).

Loading and including files with `%LOAD' and `load_file()', and `%INCLUDE' and `expand_file()'
----------------------------------------------------------------------------------------------

   Although we can define macros directly in the files that require them
it is often more useful to define them separately and include them in all
those that need them.

   One way of achieving this is to load in the macros/scripts first and
then process the file(s). In code this would be achieved like this:

     $Macro->load_file( $macro_file ) ; # Loads definitions only, ignores any
                                        # other text. If working in embedded
                                        # mode the file is treated as if
                                        # wrapped in delimiters.
     $Macro->expand_file( $file ) ;     # Expands definitions (and instantiates
                                        # any definitions that appear in the
                                        # file); output is to the current
                                        # output filehandle.
     my @expanded = $Macro->expand_file( $file ) ; # Output to array.

   From the command line it would be achieved thus:

     [2]% macro -f ~/.macro/html.macros test.html.m > test.html

   One disadvantage of this approach, especially if we have lots of macro
files, is that we can easily forget which macro files are required by
which text files. One solution to this is to go back to `%DEFINE'ing in
the text files themselves, but this would lose reusability. The answer to
both these problems is to use the `%LOAD' command which loads the
definitions from the named file at the point it appears in the text file:

     %LOAD[~/.macro/html.macros]
     <HTML>
     <HEAD><TITLE>Test Page Again</TITLE></HEAD>
     <BODY>
     *DATESTAMP[Last Updated]<P>
     This page will remain valid until *DATESTAMP[midnight]
     </BODY>
     </HTML>

   The above text has the same output but we don't have to remember or
explicitly load the macros. In code we can simply do this:

     my @expanded = $Macro->expand_file( $file ) ;

   or from the command line:

     [3]% macro test.html.m > test.html

     At the beginning of our lout typesetting files we might put this line:

     %LOAD[local.macros]

   The first line of the `local.macros' file is:

     %LOAD[~/.macro/lout.macros]

   So this loads both global macros then local ones (which if they have
the same name will of course over-ride).

   This saves repeating the `%DEFINE' definitions in all the files and
makes maintenance easier.

   `%LOAD' loads perl scripts and macros, but ignores any other text. Thus
we can use `%LOAD', or its method equivalent `load_file()', on any file,
and it will only ever instantiate macros and scripts and produce no
output. When we are using embedded processing any file `%LOAD'ed is
treated as if wrapped in delimiters.

   If we want to include the entire contents of another file, and perform
macro expansion on that file then use `%INCLUDE', e.g.

     %INCLUDE[/path/to/file/with/scripts-and-macros-and-text]

   The `%INCLUDE' command will instantiate any macros and scripts it
encounters and include all other lines of text (with macro/script
expansion) in the output stream.

   Macros and scripts are expanded in the following order: 1. scripts
(longest named first, shortest named last) 2. macros  (longest named
first, shortest named last)

Requiring files using `%REQUIRE'
--------------------------------

   We often want our scripts to have access to a bundle of functions that
we have created or that are in other modules. This can now be achieved by:

     %REQUIRE[/path/to/mylibrary.pl]

   An example library `macroutil.pl' is provided with examples of usage in
`html.macro'.

   There is no equivalent object method because if we're writing code we
can `use' or `require' as needed and if we're writing macros then we use
`%REQUIRE'.

Skipping text using `%CASE' and `%END_CASE'
-------------------------------------------

   It is possible to selectively skip parts of the text.

     %CASE[0]
     All the text here will be discarded.
     No matter how much there is.
     This is effectively a `comment' case.
     %END_CASE

   The above is useful for multi-line comments.

   We can also skip selectively. Here's an if...then:

     %CASE[#OS eq 'Linux']
     Skipped if the condition is FALSE.
     %END_CASE

   The condition can be any perl fragment. We can use previously defined
variables either using the #variable syntax as shown above or using the
exported perl name, thus in this case either `#OS', or `%Var{'OS'}'
whichever we prefer.

   If the condition is true the text is output with macro/script expansion
as normal; if the condition is false the text is skipped.

   The if...then...else structure:

     %DEFINE_VARIABLE OS[Linux]

     %CASE[$Var{'OS'} eq 'Linux']
     Linux specific stuff.
     %CASE[#OS ne 'Linux']
     Non-linux stuff - note that both references to the OS variable are
     identical in the expression (#OS is converted internally to $Var{'0S'} so
     the eval sees the same code in both cases
     %END_CASE

   Although nested `%CASE's are not supported we can get the same
functionality (and indeed more versatility because we can use full perl
expressions), e.g.:

     %DEFINE_VARIABLE TARGET[Linux]

     %CASE[#TARGET eq 'Win32' or #TARGET eq 'DOS']
     Win32/DOS stuff.
     %CASE[#TARGET eq 'Win32']
     Win32 only stuff.
     %CASE[#TARGET eq 'DOS']
     DOS only stuff.
     %CASE[#TARGET eq 'Win32' or #TARGET eq 'DOS']
     More Win32/DOS stuff.
     %END_CASE

   Although macro doesn't support nested `%CASE''s we can still represent
logic like this:

     if cond1 then
         if cond2
             do cond1 + cond2 stuff
         else
             do cond1 stuff
         end if
     else
         do other stuff
     end if

   By `unrolling' the expression and writing something like this:

     %CASE[#cond1 and #cond2]
         do cond1 + cond2 stuff
     %CASE[#cond1 and (not #cond2)]
         do cond1 stuff
     %CASE[(not #cond1) and (not #cond2)]
         do other stuff
     %END_CASE

   In other words we must fully specify the conditions for each case.

   We can use any other macro/script command within `%CASE' commands, e.g.
`%DEFINE's, etc., as well as have any text that will be macro/script
expanded as normal.

Undefining with `%UNDEFINE' and `undefine()'
--------------------------------------------

   Macros and scripts may be undefined in files:

     %UNDEFINE *P
     %UNDEFINE_SCRIPT *DATESTAMP
     %UNDEFINE_VARIABLE &*!

   and in code:

     $Macro->undefine( -macro, '*P' ) ;
     $Macro->undefine( -script, '*DATESTAMP' ) ;
     $Macro->undefine( -variable, '&*!' ) ;

   All macros, scripts and variables can be undefined:

     %UNDEFINE_ALL
     %UNDEFINE_ALL_SCRIPT
     %UNDEFINE_ALL_VARIABLE

     $Macro->undefine_all( -macro ) ;
     $Macro->undefine_all( -script ) ;
     $Macro->undefine_all( -variable ) ;

   One use of undefining everything is to ensure we get a clean start. We
might head up our files thus:

     %UNDEFINE_ALL
     %UNDEFINE_ALL_SCRIPT
     %UNDEFINE_ALL_VARIABLE
     %LOAD[mymacros]
     text goes here

Listing macros, scripts and variables with list()
-------------------------------------------------

   We can list the macros, scripts and variables in code with list:

     $Macro->list( -macro ) ;

   This will print the macros currently defined to the current file handle
- if there is one. If used in an array context will provide the list one
macro per array element:

     @macros = $Macro->list( -macro ) ;

     # Just give us the macro names:
     @macros = $Macro->list( -macro, -nameonly ) ;

   There are equivalents for scripts and variables:

     @scripts   = $Macro->list( -script ) ;
     @variables = $Macro->list( -variable ) ;

Commenting
----------

   Generally the text files that we process are in formats that support
commenting, e.g. HTML:

     <!-- This is an HTML comment -->

   Sometimes however we want to put comments in our macro source files
that won't end up in the output files. One simple way of achieving this is
to define a macro whose body is empty; when its called with any number of
parameters (our comments), their text is thrown away:

     %DEFINE %%[]

   which is used like this in texts:

     The comment comes %%[Here | [anything] put here will disappear]here!

   The output of the above will be:

     The comment comes here!

   We can add the definition in code:

     $Macro->define( -macro, '%%', '' ) ;

   Or the macro can be added automatically for us when we create the Macro
object:

     my $Macro = Text::MacroScript->new( -comment => 1 ) ;
     # All other options may be used too of course.

   However the easiest way to comment is to use `%CASE':

     %CASE[0]
     This unconditionally skips text up until the end marker since the
     condition is always false.
     %END_CASE

IMPORTABLE FUNCTIONS
====================

   In version 1.25 I introduced some useful importable functions. These
have now been removed from the module. Instead I supply a perl library
`macroutil.pl' which has these functions (abspath, relpath, today) since
Text::MacroScript can now `require' in any library file you like using the
`%REQUIRE' directive.

EXAMPLES
========

   I now include a sample `html.macro' file for use with HTML documents.
It uses the `macrodir' program (supplied). The macro examples include
macros which use `relpath' and also two macros which will include `new'
and `updated' images up until a specified expiry date using variables.

   (Also see DESCRIPTION.)

BUGS
====

   Lousy error reporting for embedded perl in most cases.

AUTHOR
======

   Mark Summerfield. I can be contacted as <summer@perlpress.com> - please
include the word 'macroscript' in the subject line.

COPYRIGHT
=========

   Copyright (c) Mark Summerfield 1999-2000. All Rights Reserved.

   This module may be used/distributed/modified under the LGPL.


