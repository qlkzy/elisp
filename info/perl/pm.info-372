This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Text/MetaText/Directive,  Next: Text/MetaText/Factory,  Prev: Text/MetaText,  Up: Module List

MetaText Directive object class.
********************************

NAME
====

   Text::MetaText::Directive - MetaText Directive object class.

SYNOPSIS
========

     use Text::MetaText::Directive;
     my $directive = Text::MetaText::Directive->new(\%params);

DESCRIPTION
===========

   Objects of the Text::MetaText::Directive class are instantiated by the
Text::MetaText::Factory class from within the Text::MetaText module.  The
Factory and Directive classes can be sub-classed to create a more specific
processing system.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

   See also:

     http://www.kfs.org/~abw/

REVISION
========

   $Revision: 0.4 $

COPYRIGHT
=========

   Copyright (c) 1996-1998 Andy Wardley.  All Rights Reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the Perl Artistic License.

SEE ALSO
========

   For more information, see the main Text::MetaText documentation:

     perldoc Text::MetaText
     
     For more information about the author and other Perl development work:

     http://www.kfs.org/~abw/
     http://www.kfs.org/~abw/perl/
     http://www.cre.canon.co.uk/perl/

   For more information about Perl in general:

     http://www.perl.com/


File: pm.info,  Node: Text/MetaText/Factory,  Next: Text/Metaphone,  Prev: Text/MetaText/Directive,  Up: Module List

Factory class for instatiating Directive objects.
*************************************************

NAME
====

   Text::MetaText::Factory - Factory class for instatiating Directive
objects.

SYNOPSIS
========

     use Text::MetaText::Factory;
     my $factory = Text::MetaText::Factory->new(\%cfg);

DESCRIPTION
===========

   The Text::MetaText::Factory module is used by Text::MetaText to
instantiate Text::MetaText::Directive objects.  The Factory and Directive
classes can be sub-classed to create a more specific processing system.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

   See also:

     http://www.kfs.org/~abw/

REVISION
========

   $Revision: 0.2 $

COPYRIGHT
=========

   Copyright (c) 1996-1998 Andy Wardley.  All Rights Reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the Perl Artistic License.

SEE ALSO
========

   For more information, see the main Text::MetaText documentation:

     perldoc Text::MetaText
     
     For more information about the author and other Perl development work:

     http://www.kfs.org/~abw/
     http://www.kfs.org/~abw/perl/
     http://www.cre.canon.co.uk/perl/

   For more information about Perl in general:

     http://www.perl.com/


File: pm.info,  Node: Text/Metaphone,  Next: Text/Munge/Vowels,  Prev: Text/MetaText/Factory,  Up: Module List

A modern soundex.  Phonetic encoding of words.
**********************************************

NAME
====

   Text::Metaphone - A modern soundex.  Phonetic encoding of words.

SYNOPSIS
========

     use Text::Metaphone;
     $phoned_words = Metaphone('Schwern');

DESCRIPTION
===========

   `Metaphone()' is a function whereby a string/word is broken down into a
rough approximation of its english phonetic pronunciation.  Very similar
in concept and purpose to soundex, but much more comprehensive in its
approach.

FUNCTIONS
=========

Metaphone
          $phoned_word = Metaphone($word, $max_phone_len);

     Takes a word and encodes it according to the Metaphone algorithm.
     The algorithm only deals with alphabetical characters, all else is
     ignored.

     If $max_phone_len is provided, Metaphone will only encode up to that
     many characters for each word.

     'sh' is encoded as 'X', 'th' is encoded as '0'.  This can be changed
     in the metaphone.h header file.

CAVEATS
=======

Metaphone algorithm changes
     I have made a few minor changes to the traditional metaphone
     algorithm found in the books.  The most significant one is that it
     will differenciate between SCH and SCHW making the former K (As in
     School) and the latter sh (as in Schwartz and Schwern).

     My changes can be turned off by defining the USE_TRADITIONAL_METAPHONE
     flag in metaphone.h.

     Due to these changes, any users of Metaphone v1.00 or earlier which
     have stored metaphonetic encodings, they should recalculate those
     with the new verison.

AUTHOR
======

   Michael G Schwern <schwern@pobox.com>

SEE ALSO
========

Man pages
---------

   *Note Text/Soundex: Text/Soundex,

Books, Journals and Magazines
-----------------------------

Binstock, Andrew & Rex, John. "Metaphone:  A Modern Soundex." *Practical Algorithms For Programmers.*  Reading, Mass:  Addion-Wesley, 1995  pp160-169
     Contains an explaination of the basic metaphone concept & algorithm
     and C code from which I learned of Metaphone and ported this module.

Parker, Gary. "A Better Phonetic Search." *C Gazette*, Vol. 5, No. 4 (June/July), 1990.
     This is the public-domain C version of metaphone from which Binstock
     & Rex based their own..  I haven't actually read it.

Philips, Lawrence. *Computer Language*, Vol. 7, No. 12 (December), 1990.
     And here's the original Metaphone algorithm as presented in Pick
     BASIC.

COPYRIGHT, et al.
=================

   Copyright (c) 1997-1999 Michael G Schwern.  All Rights Reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.


File: pm.info,  Node: Text/Munge/Vowels,  Next: Text/NWrap,  Prev: Text/Metaphone,  Up: Module List

removes vowels from words phrases
*********************************

NAME
====

   Text::Munge::Vowels - removes vowels from words phrases

SYNOPSIS
========

     use Text::Munge::Vowels;

     $obj = new Text::Munge::Vowels();
     $obj->add_stopwords LIST

     $string = $obj->munge LIST

DESCRIPTION
===========

   Text::Munge::Vowels strips vowels spaces from words and phrases to
shorten the length of simple text messages, as might be used for to send
weather forecasts or short news items to alphanumeric pagers with limited
message or screen sizes.

   Note that there's another module on CPAN called *Lingua-EN-Squeeze*
intended for the same purpose.

EXAMPLE
=======

     use Text::Munge::Vowels();

     $munger = new Text::Munge::Vowels();

     $text = "This sentence will have some of it\'s vowels removed.";

     print $munger->munge($text), "\n";

CAVEATS
=======

   Overuse can make messages unreadable. "Decoding" the output of this
module requires a human (?) brain familiar with the language and the
context of the messages.

   Some would argue the use of this module is suspect.

FUTURE ENHANCEMENTS
===================

   Improve the regular expression in *$DefaultMungeRule* to ignore double
or triple vowels in short words.

   Actually, I am working on a separate module which will load specialized
vocabularies from XML files. If this module evolves at all, it will be as
a wrapper to that module.

AUTHOR
======

   Robert Rothenberg <wlkngowl@unix.asb.com>


File: pm.info,  Node: Text/NWrap,  Next: Text/Number,  Prev: Text/Munge/Vowels,  Up: Module List

a simple text wrapping module
*****************************

NAME
====

   *Text::NWrap* - a simple text wrapping module

SYNOPSIS
========

     use Text::NWrap;

     $NWrap::columns = 132;
     NWrap::wrap('    ','',@text);

DESCRIPTION
===========

   *Text::NWrap* is a simple interface to *Text::Format*.  If you want
more functionality just use *Text::Format*.  *Text::NWrap* is meant to
replace Text::Wrap.  Its interface is basically identical to Text::Wrap's.
However, nothing is exported by default and it does not call die under
any circumstance.

wrap $firstIndent, $bodyIndent, @text
     Wrap @text using $firstIndent for the first line's indent and
     $bodyIndent for the indentation of the body of the paragraph.

$columns
     Lets you set the width of the paragraph.  Default is 72 characters
     wide.

EXAMPLE
=======

     use Text::NWrap;

     print NWrap::wrap('','',"hello world this is some silly example",
             "and some more text that should explain the use");

     use Text::NWrap qw(wrap $columns);

     $columns = 20;
     wrap("\t",'',"some text that should be wrapped");

AUTHOR
======

   Gabor Egressy *gabor@vmunix.com*

   Copyright (c) 1998 Gabor Egressy.  All rights reserved.  All wrongs
reversed.  This program is free software; you can redistribute and/or
modify it under the same terms as Perl itself.


File: pm.info,  Node: Text/Number,  Next: Text/PDF/AFont,  Prev: Text/NWrap,  Up: Module List

Overloaded class for printing numbers
*************************************

NAME
====

   Text::Number - Overloaded class for printing numbers

SYNOPSIS
========

   Provides a facility for transparently configuring numbers to print the
way you want them to.  Calculations are always executed using the full
precision of the number, but printing is rounded to the number of places
of your choosing.

   Extended printing operations are configurable via the format method.

DESCRIPTION
===========

   `use Text::Number;'

   `$allowance = number(value => 5, places => 2)';

   `print STDOUT "My allowance is $allowance dollars."'

   > My allowance is 5.00 dollars.

   `require Text::Number;'

   `$allowance = Text::Number-'new(value => 5, places => 2)>;

   `$allowance += 5000; print "$allowance";'

   > 5005.00

   `$allowance->format(type => 'number'); print "$allowance";'

   > 5,005.00

EXPORTS
=======

   If you import `Text::Number' with the <use> statement, the number
constructor will be imported into your namespace.  If you'd rather not
import this symbol, `require Text::Number' instead and use either `new
Text::Number' or `Text::Number->number' as your constructor.

OPERATORS
=========

   Objects created by this module should function transparently with these
operators:

   `+ - / * "" x ** ++ += -- -= *= /= < > <= >= <=>'

   abs atan2 cos exp log sin sqrt

METHODS
=======

new (synonymous with number)
----------------------------

   `$number = number(6);' (only if you used)

   `$number = new Text::Number(value => 6, places => 0)'

   `$number = Text::Number->number(6)'

places
------

   Returns the display precision of the number.

   `$precision = $number->places'

value
-----

   Returns the real value of the number.

   `$value = $number->value'

format
------

   Use this method to configure the number for more sophisticated printing
option, i.e., anything other than plain old decimal point control.  If you
invoke this method, you need to have Number::Format installed on your
system, as this module is used to generate the formats.  The module is
only loaded at runtime so Text::Number will work without it, except you
won't have access to these formatting options.

   Number::Format is a very useful and feature-rich module.  Please see
the pod for that module for a better description of it capabilities.

   `$success = $number->format(type => number)' inserts commas, or the
local equivalent, into numbers > 1000.  It can also insert the localized
decimal point character.

   `$success = $number->format(type => picture, template => template )'

   Please see the Number::Format docs for more information.

   `$success = $number->format(type => negative,template => template )'

   Please see the Number::Format docs for more information.

   `$success = $number->format(type => price)'

   Prepends the printed output with the local currency symbol.  Please see
the Number::Format docs for more information.

   `$success = $number->format(type => bytes)'

   Prints the number as K or M. Please see the Number::Format docs for
more information.

   `$success = $number->format()'

   Will remove the advanced formatting option.

CAVEATS and NOTES
=================

Performance Issues
------------------

   I wrote this to help me transparently configure number printing formats
for figures that get passed around between objects that print.  In this
capacity it works pretty decently for me.  *However*, using these objects
in place of numeric scalars adds a fair bit of memory and processor
consumption, so I'd recommend only using them when you need to print
numbers, and for the occasional calculation.

   If you have many calculations to do, you can do the calculations first,
and then stuff the value into a Text::Number object.

Exception Handling
------------------

   All calculations that can throw exceptions are wrapped in evals.  If
your calculation threw an exception (say, divided bt zero), the return
value will be an empty string.  I was considering returning an instance of
the object with the value set to zero, but this seemed confusing, since
you wouldn't necessarily know if the value was the result of math or of
the exception.  I also considered undef.

   I'm open to suggestion on this - if anyone is using this object and has
suggestions, please send them to me <fix@fixler.com>

REQUIRES
========

   Perl 5.005

   POSIX

   Number::Format (optional)

AUTHOR
======

   Eric Fixler <fix@fixler.com>

   Copyright 1999.  You are free to use, modify, and redistribute this
module as long as the source remains freely available, and credit is given
to the the original author (i.e., me).

TODO
====

   Fuller and better implementation of Number::Format methods.

   Elimination of POSIX call (there's only one).

   Implement mod arithmetic.

   Is Text::Number really the right name for this package?

ACKNOWLEDGEMENTS
================

   Tom Christansen and Nathan Torkington; their StrNum/overload example in
the [excellent] Perl Cookbook was the beginning of this module.

   William R. Ward <wrw@bayview.com> author of Number::Format.

SEE ALSO
========

   Number::Format


File: pm.info,  Node: Text/PDF/AFont,  Next: Text/PDF/API,  Prev: Text/Number,  Up: Module List

Embedding of Adobe PFB/PFA + AFM format fonts. Inherits from *Note Text/PDF/Dict: Text/PDF/Dict,
************************************************************************************************

NAME
====

   Text::PDF::AFont - Embedding of Adobe PFB/PFA + AFM format fonts.
Inherits from *Note Text/PDF/Dict: Text/PDF/Dict,

METHODS
=======

Text::PDF::AFont->new $parent, $name, $psfile, $afmfile, $pdfname [ , $encoding [ , @glyphs ]]
----------------------------------------------------------------------------------------------

   Creates a new font object with given parent and name from pfb/pfa from
psfile and afm from afmfile.

   The $pdfname is the name that this particular font object will be
referenced by throughout the PDF file. If you want to play silly games
with naming, then you can write the code to do it!

   The $encoding is the name of one of the encoding schemes specified in
the pdf-specification (v1.3 2nd Ed.), 'latin1' or 'custom'. 'latin1' is a
variant of the standard WinAnsiEncoding especially customized for
iso-8859-1 (aka. iso-latin-1).  If you use 'custom' as encoding, you have
to supply the @glyphs array which should specify 256 glyph-names as
defined by the "PostScript(R) Language Reference 3rd. Ed. - Appendix E"

   If you do not give $encoding, than the afms internal encoding is used.

   If you give an unknown $encoding, the encoding defaults to
WinAnsiEncoding.

   Returns the new font object.

Text::PDF::AFont->newNonEmbed $parent, $afmfile, $pdfname [ , $encoding [, @glyphs ]]
-------------------------------------------------------------------------------------

   Creates a new font object with given parent and name from pfb/pfa from
psfile and afm from afmfile.

   All the rules for Text::PDF::AFont->new apply here, but instead of
having a embedded font included in the pdf-file you only have a reference
to the font included in the pdf-file.  This results in far smaller
filesizes, but requires the viewing/printing application to have the
actual font properly installed at their platform.

   Returns the new font object.

Text::PDF::AFont->newCore $parent, $fontname, $pdfname [, $encoding [, @glyphs ]]
---------------------------------------------------------------------------------

   Creates a new font object with given parent and fontname from one of
the 14 Adobe Core Fonts as supported by the Adobe PDF Reader applications
versions 3.0 and up.

   Valid values for fontname are:

     Courier-Bold
     Courier-BoldOblique
     Courier-Oblique
     Courier
     Helvetica-Bold
     Helvetica-BoldOblique
     Helvetica-Oblique
     Helvetica
     Symbol
     Times-Bold
     Times-BoldItalic
     Times-Italic
     Times-Roman
     ZapfDingbats

   All the rules of Text::PDF::AFont->newNonEmbed apply here, but don't
require you to specify an afm-file since the fonts are internally
supported by both the Adobe PDF Reader applications and this module.

   Returns the new font object.

$f->reencode $parentpdf $pdfname $encoding [@glyphs]
----------------------------------------------------

   Reencodes the current font $f with encoding $encoding (optional variant
@glyphs) to be used with name $pdfname.

   Returns the new font object.

$f->width($text)
----------------

   Returns the width of the text in em.

$f->out_text($text)
-------------------

   Acknowledges the text to be output for subsetting purposes, etc.


File: pm.info,  Node: Text/PDF/API,  Next: Text/PDF/Array,  Prev: Text/PDF/AFont,  Up: Module List

a wrapper api for the Text::PDF::* modules of Martin Hosken.
************************************************************

NAME
====

   Text::PDF::API - a wrapper api for the Text::PDF::* modules of Martin
Hosken.

SYNOPSIS
========

     use Text::PDF::API;

     $pdf = Text::PDF::API->new( %defaults );

     $pdf->end;

DESCRIPTION
===========

Base Methods
------------

$pdf = Text::PDF::API->new [%defaults]
     This creates a new pdf-object initializes it with the given defaults
     and returns it.  See the functions getDefault and *setDefault* for a
     list of supported parameters.

$pdf->info $title, $subject, $creator, $author, $keywords
     This creates the pdf-info-object and initializes it with the given
     values.

$pdf->saveas $file
     This saves the pdf-object to a file indicated by $file.

$pdf->end
     This destroys the pdf-object and frees its memory.

$pdf->getDefault $parameter
     This returns the pdf-object default indicated by *$parameter*.

     The current supported defaults are:

     PageSize, valid values:

          'a0'		=>	[ 2380	, 3368	]
          'a1'		=>	[ 1684	, 2380	]
          'a2'		=>	[ 1190	, 1684	]
          'a3'		=>	[ 842	, 1190	]
          'a4'		=>	[ 595	, 842	]
          'a5'		=>	[ 421	, 595	]
          'a6'		=>	[ 297	, 421	]
          'letter'	=>	[ 612	, 792	]
          'broadsheet'	=>	[ 1296	, 1584	]
          'ledger'	=>	[ 1224	, 792	]
          'tabloid'	=>	[ 792	, 1224	]
          'legal'		=>	[ 612	, 1008	]
          'executive'	=>	[ 522	, 756	]
          '36x36'		=>	[ 2592	, 2592	]

     PageWidth, valid values:

          0 .. 32535 points (remember default = 72dpi)
          
          PageHeight, valid values:

          0 .. 32535 points (remember default = 72dpi)

     PageOrientation, valid values:

     	Landscape, Portrait

     Compression

          0, 1 (= off, on)

     PDFVersion

          0 .. 3 (corresponding to the adobe acrobat versions up to 4.0)

$pdf->setDefault $parameter , $value
     This sets the pdf-object defaults (see $pdf->getDefault for details).

$pdf->newpage [ $width, $height ]
$pdf->newpage [ $pagesize ]
     This creates a new page in the pdf-object and assigns it to the
     default page context.  If $width and $height are not given the
     funtion falls back to any given defaults (PageSize then
     PageWidth+PageHeight) and as a last resort to 'A4'.  You can use also
     specify oonly the Pagesize as given under the defaults.

$pdf->endpage
     This closes the current page.

Generic Methods
---------------

$pdf->savePdfState
$pdf->restorePdfState
     Saves and restores the state of the pdf-document BUT NOT of the
     pdf-object.

     BEWARE: Don't cross page boundaries with save/restore, if you really
     don't know the pdf-specification well enough.

$pdf->saveState {currently broken}
$pdf->restoreState {currently broken}
     Saves and restores the state of the pdf-object and the underlying
     document.

     NOTE: All states are automagically restored if you issue a
     $pdf->endpage.

Font State Methods
------------------

$pdf->setFontDir $directory
     Sets the default font search directory.

$directory = $pdf->getFontDir
     Gets the default font search directory.

$pdf->addFontPath $directory
     Adds a directory to the font search path.

$pdf->newFont $fontname, $ttfile
$pdf->newFont $fontname, $psffile, $afmfile
$pdf->newFont $fontname
     Adds a new font to the pdf-object. Based on the fonts name either a
     core, truetype or postscript font is assumed: TrueType have a ','
     between the family and style names whereas the postscript and core
     fonts use a '-'.

     BEWARE: Postscript fonts other than the core fonts are supported, BUT
     the implementation is still somewhere in alpha/beta stage and may not
     result in valid pdf-files under certain conditions.

     NOTE: this function is for BACKWARD COMPATIBLITY ONLY (as of version
     0.5) and will be removed sometime before version 1.0.

     *RECOMMENDATION:* Start using the following three functions below.

$pdf->newFontCore $fontname [, $encoding [, @glyphs ]]
$pdf->newFontTTF $fontname, $ttffile [, $encoding ]
$pdf->newFontPS $fontname, $psffile, $afmfile [, $encoding [, @glyphs ]]
     Although you can add a font thru the $pdf->newFont function, these
     three new functions are much more stable (newFontPS is alpha-quality)
     and reliable.

     The $encoding is the name of one of the encoding schemes supported by
     Unicode::Map8, 'asis' or 'custom'. If you use 'custom' as encoding,
     you have to supply the @glyphs array which should specify 256
     glyph-names as defined by the "PostScript(R) Language Reference 3rd.
     Ed. - Appendix E"

     If you do not give $encoding or 'asis', than the afms internal
     encoding is used.

     If you give an unknown $encoding, the encoding defaults to
     WinAnsiEncoding.

$pdf->addCoreFonts
     This is a shortcut to add all pdf-core-fonts to the pdf-object.

$pdf->useFont $name, $size [, $encoding ]
     This selects the font at the specified size and encoding.  The font
     must have been loaded with the same $name parameter with $pdf->newFont

     If you do not give $encoding, than the encoding from $pdf->newFont???
     is used.

     NOTE: As of version API 0.5 you can specify any encoding supported by
     Unicode::Map8, since the fonts are automagically reencoded to use the
     new encoding if it differs from that encoding specified at
     $pdf->newFont???.

$pdf->setFontTranslate $tx, $ty
     Sets the translation (aka. x,y-offset) in the
     Font-Transformation-Matrices.

$pdf->setFontScale $scalex, $scaley
     Sets the scale in the Font-Transformation-Matrices.

$pdf->setFontSkew $alfa, $beta
     Sets the skew in the Font-Transformation-Matrices specified in
     degrees (0..360).

$pdf->setFontRotation $alfa
     Sets the rotation in the Font-Transformation-Matrices specified in
     degrees (0..360) counter-clock-wise from the right horizontal.

$pdf->clearFontMatrix
     Resets all Font-Transformation-Matrices.

$pdf->calcFontMatrix
     Calculates the final Transformation-Matrix for use with the *Text*
     functions.

$pdf->setFontMatrix $a, $b, $c, $d, $e, $f
     Sets the final Transformation-Matrix directly.

($a, $b, $c, $d, $e, $f)=$pdf->getFontMatrix
     Returns the final Transformation-Matrix. Use $pdf->calcFontMatrix and
     then $pdf->getFontMatrix to retrive the combined effects of
     Translate, Skew, Scale & Rotate.

$pdf->setCharSpacing $spacing
$pdf->setWordSpacing $spacing
$pdf->setTextLeading $leading
$pdf->setTextRise $rise
$pdf->setTextRendering $rendering
Text Block Methods
------------------

$pdf->beginText
     Starts a text block.

$pdf->endText
     Ends a text block

$pdf->charSpacing [ $spacing ]
$pdf->wordSpacing [ $spacing ]
$pdf->textLeading [ $leading ]
$pdf->textRise [ $rise ]
$pdf->textRendering [ $rendering ]
$pdf->textMatrix [ @matrix ]
     Sets the parameter for the text-block only. If parameter is not given
     the default as defined by $pdf->set* is used.

$pdf->textPos $mx, $my
     Sets a new text position, but honoring the current FontMatrix.

$pdf->textFont [ $font, $size [, $encoding ] ]
     Switches the font within the text-block or resets to the last
     $pdf->useFont.  BEWARE: you can only change to a new font before a
     matrix or pos command since changing it after such command gives
     pdf-errors !!!

$pdf->textAdd $text
     Adds text to the text-block.

$pdf->textNewLine [ $leading ]
     Moves the text-pointer to a new line using TextLeading as default.

Text Utility Methods
--------------------

$pdf->calcTextWidth $text
     Calculates the width of the text based on the parameters set by
     useFont.

     BEWARE: Does not consider parameters specified by setFont* and
     *Matrix functions.

$pdf->showText $text
     Displays the $text based on the parameters given by the *Font*
     functions.

$pdf->showTextXY $x, $y, $text
$pdf->showTextXY_R $x, $y, $text
$pdf->showTextXY_C $x, $y, $text
     Like $pdf->showText but overrides the x,y-offsets of the Matrices.
     The *_R and *_C variants perform right and center alignment !

$pdf->printText $x, $y, $font, $size, $encoding, $text
     Like a $pdf->useFont followed by a $pdf->showTextXY.

Graphic State Methods
---------------------

$pdf->setGfxTranslate $tx, $ty
$pdf->setGfxScale $scalex, $scaley
$pdf->setGfxSkew $alfa, $beta
$pdf->setGfxRotation $alfa
$pdf->clearGfxMatrix
$pdf->calcGfxMatrix
$pdf->setGfxMatrix $a, $b, $c, $d, $e, $f
($a, $b, $c, $d, $e, $f)=$pdf->getGfxMatrix
     These functions behave like the the font functions BUT affect the
     whole global graphics state.

     BEWARE: If you use both the Gfx and Font versions of these functions
     the final result for Text would be the combined effects of both the
     Gfx and Font parameters.

$pdf->useGfxState
     Adds the parameters of the functions above to the current graphics
     state.  To revert to the former parameters use $pdf->savePdfState and
     $pdf->restorePdfState.

$pdf->useGfxFlatness $flatness
$pdf->useGfxLineCap $linecap
$pdf->useGfxLineDash @dasharray
$pdf->useGfxLineJoin $linejoin
$pdf->useGfxLineWidth $linewidth
$pdf->useGfxMeterlimit $limit
Color Methods
-------------

$pdf->setColorFill $red, $green, $blue
$pdf->setColorFill $cyan, $magenta, $yellow, $black
$pdf->setColorFill $gray
$pdf->setColorStroke $red, $green, $blue
$pdf->setColorStroke $cyan, $magenta, $yellow, $black
$pdf->setColorStroke $gray
Drawing Methods
---------------

$pdf->moveTo $x, $y
$pdf->lineTo $x, $y
$pdf->curveTo $x1, $y1, $x2, $y2, $x3, $y3
$pdf->rect $x, $y, $w, $h
$pdf->closePath
$pdf->endPath
$pdf->rectXY $x1, $y1, $x2, $y2
$pdf->lineXY $x1, $y1, $x2, $y2
($xs,$ys,$xe,$ye)=$pdf->arcXYabDG $x, $y, $a, $b, $delta, $gamma, $move
($xs,$ys,$xe,$ye)=$pdf->arcXYrDG $x, $y, $r, $delta, $gamma, $move
$pdf->ellipsisXYAB $x, $y, $a, $b
$pdf->circleXYR $x, $y, $r
$pdf->stroke
$pdf->closestroke
$pdf->fill
$pdf->closefill
$pdf->fillNZ
$pdf->fillstroke
$pdf->closefillstroke
$pdf->fillstrokeNZ
$pdf->closefillstrokeNZ
     quot errat demonstrandum

Bitmap Methods
--------------

( $key , $width , $height ) = $pdf->newImage $file
     Current loading support includes NetPBM images of the RAW_BITS
     variation and non-interlaced/non-filtered PNG.  Transperancy/Opacity
     information is currently ignored as well as Alpha-Channel information.

( $key , $width , $height ) = $pdf->rawImage $name, $width $height $type @imagearray
     This function supports loading of point-arrays for embedding image
     information into the pdf. $type must be one of the following:

          '-rgb' ... each element of the array is a color component
          		in the range of 0..255
          '-RGB' ... each element of the array is a hex-encoded color pixel
          		with two hex-digits per color component

     $name must be a unique name for this image (at least 8 characters
     long).

$pdf->placeImage $key, $x, $y, $scalex, $scaley
HISTORY
=======

Version 0.00
     GENESIS

Version 0.01
     inital implementation without documentation

Version 0.01_01
     you can create pages, still no docs

Version 0.01_02 - 0.01_11
     various conceptual design stages

Version 0.01_12
     first public snapshot with some docs and first implementation of font
     caching (released as 0.01_12_snapshot)

Version 0.01_14
     reimplementaion of font-handling with unification of core and
     truetype fonts under the function "newFont"

Version 0.01_15
     implementaion of font-encoding for truetypes

Version 0.01_16
     reimplementaion of font-encoding thru CID because Acrobat seems to
     ignore encoding tables for TTs when using normal embedding

Version 0.01_17
     implementaion of printText, useFont, showText & showTextXY

Version 0.01_18
     implementaion of *FontMatrix functions, changes in showText &
     showTextXY

Version 0.01_19
     addition of setFontTranslate, Skew, Rotate & Scale with cleanup in
     *FontMatrix

Version 0.01_20
     end of text/font implementation, let it stabilize :)

Version 0.02
     genesis of the graphical interface (CTM handling copied from fonts)

Version 0.02_01
     added text and graphic state functions

Version 0.02_02
     cleanup/extension of dokumentation, but still not finished

Version 0.02_03
     proposed implementation of drawing functions (NOT FINISHED)

Version 0.02_04
     finished implemetation of needed drawing functions

Version 0.03
     bugfixes in drawing and font functions first implementation of state
     functions

Version 0.03_01
     first implementation of bitmap functions

Version 0.03_02
     bugfixes in text/font functions

Version 0.03_03
     added support for loading of PNM(netpbm) and PNG bitmaps

Version 0.03_04
     added circle and ellipsis drawing functions

Version 0.03_05
     fixed calcTextWidth to allow the type1 core fonts to be measured too.
     added showTextXY_R and _C functions for alignment procedures :)

Version 0.04-0.43
     rewrite of type1 core-font handling to ease development support for
     other type1 fonts in future releases of Text::PDF and Text::PDF::API.

     small bugfixes in calcTextWidth and showTextXY_[RC].

     small documentation update

Version 0.05 (Oct. 2000)
     major rewrite to use Unicode::Map8 instead of the homegrown functions
     :) , add another dependency but at least a fast one

Versions 0.5_pre??? (Dec. 2000)
     major rewrite of font-handling routines stalls the tutorial/exaples
     collection.  now adobe-type1 fonts (pfb/pfa + afm) and the core-fonts
     can be used the same way as truetype with the Unicode::Map8 encodings.

Version 0.5 (07-01-2001)
     documemtation update and release of the much hacked 0.5_pre??? code :)

Version 0.5001 to 0.5003
     minor bugfixes:

     under certain conditions the 'image' functions stopped working, hope
     that my newly invented "nigma-hash" keygenerator fixes this.

     the symbol and zapfdingbat corefonts did not work ... since they
     missed attributes and had wrong font-flags set ... doesn't anybody
     use them ?

Version 0.6
     removed: "nigma-hash" keygenerator had some disadvantages.

     added: Digest::REHLHA module for key-generation (this comes with the
     API).

     added: $p->arcXYrDG() and $p->arcXYabDG() to relief users of the (in
     my opinion) 'mind boggling' bezier-curve function for arcs.

     added: $p->info() to include copyright/generator information in the
     pdf.

     added: new text-block functions to ease the use of text.

     changed: unicode<->name mapping was broken under perl-5.004xx.

     *PLEASE NOTE:* this is now the minimum required version for the
     upcoming APIx module-chain.

CONTRIBUTORS / BUGHUNTERS / THANKS
==================================

   Martin Hosken [mhosken@sil.org] - for writing Text::PDF in the first
place

   Lester Hightower [hightowe@TheAIMSGroup.com] - fixes/reports:
perl-5.004xx, key-generation, Makefile.PL

BUGS
====

   MANY! If you find some report them to
perl-text-pdf-modules@yahoogroups.com.

TODO ( in no particular order )
===============================

   documentation ?

   drawing functions ?

   more bitmap import functions (jpeg,tiff,xbm,xpm,...?)

   function to populate a Text::PDF::API object from an existing pdf-file ?


File: pm.info,  Node: Text/PDF/Array,  Next: Text/PDF/Bool,  Prev: Text/PDF/API,  Up: Module List

Corresponds to a PDF array. Inherits from `PDF::Objind' in this node
********************************************************************

NAME
====

   Text::PDF::Array - Corresponds to a PDF array. Inherits from
`PDF::Objind' in this node

INSTANCE VARIABLES
==================

   This object is not an array but an associative array containing the
array of elements. Thus, there are special instance variables for an array
object, beginning with a space

var
     Contains the actual array of elements

METHODS
=======

PDF::Array->new($parent, @vals)
-------------------------------

   Creates an array with the given storage parent and an optional list of
values to initialise the array with.

$a->outobjdeep($fh, $pdf)
-------------------------

   Outputs an array as a PDF array to the given filehandle.

$a->removeobj($elem)
--------------------

   Removes all occurrences of an element from an array.

$a->elementsof
--------------

   Returns a list of all the elements in the array. Notice that this is
not the array itself but the elements in the array.

$a->add_elements
----------------

   Appends the given elements to the array. An element is only added if it
is defined.

$a->val
-------

   Returns the value of the array, this is a reference to the actual array
containing the elements.

$a->copy($pdf)
--------------

   Copies the array with deep-copy on elements which are not full PDF
objects with respect to a particular $pdf output context


File: pm.info,  Node: Text/PDF/Bool,  Next: Text/PDF/Dict,  Prev: Text/PDF/Array,  Up: Module List

A special form of `PDF::String' in this node which holds the strings *true* or false
************************************************************************************

NAME
====

   PDF::Bool - A special form of `PDF::String' in this node which holds
the strings *true* or false

METHODS
=======

$b->convert($str)
-----------------

   Converts a string into the string which will be stored.

as_pdf
------

   Converts the value to a PDF output form


File: pm.info,  Node: Text/PDF/Dict,  Next: Text/PDF/File,  Prev: Text/PDF/Bool,  Up: Module List

PDF Dictionaries and Streams. Inherits from `PDF::Objind' in this node
**********************************************************************

NAME
====

   Text::PDF::Dict - PDF Dictionaries and Streams. Inherits from
`PDF::Objind' in this node

INSTANCE VARIABLES
==================

   There are various special instance variables which are used to look
after, particularly, streams. Each begins with a space:

stream
     Holds the stream contents for output

streamfile
     Holds the stream contents in an external file rather than in memory.
     This is not the same as a PDF file stream. The data is stored in its
     unfiltered form.

streamloc
     If both ' stream' and ' streamfile' are empty, this indicates where
     in the source PDF the stream starts.

METHODS
=======

$d->outobjdeep($fh)
-------------------

   Outputs the contents of the dictionary to a PDF file. This is a
recursive call.

   It also outputs a stream if the dictionary has a stream element. If
this occurs then this method will calculate the length of the stream and
insert it into the stream's dictionary.

$d->read_stream($force_memory)
------------------------------

   Reads in a stream from a PDF file. If the stream is greater than
`PDF::Dict::mincache' (defaults to 32768) bytes to be stored, then the
default action is to create a file for it somewhere and to use that file
as a data cache. If $force_memory is set, this caching will not occur and
the data will all be stored in the $self->{' stream'} variable.


File: pm.info,  Node: Text/PDF/File,  Next: Text/PDF/Filter,  Prev: Text/PDF/Dict,  Up: Module List

Holds the trailers and cross-reference tables for a PDF file
************************************************************

NAME
====

   Text::PDF::File - Holds the trailers and cross-reference tables for a
PDF file

SYNOPSIS
========

     $p = Text::PDF::File->open("filename.pdf", 1);
     $p->new_obj($obj_ref);
     $p->free_obj($obj_ref);
     $p->append_file;
     $p->close;

DESCRIPTION
===========

   This class keeps track of the directory aspects of a PDF file. There
are two parts to the directory: the main directory object which is the
parent to all other objects and a chain of cross-reference tables and
corresponding trailer dictionaries starting with the main directory object.

INSTANCE VARIABLES
==================

   Within this class hierarchy, rather than making everything visible via
methods, which would be a lot of work, there are various instance
variables which are accessible via associative array referencing. To
distinguish instance variables from content variables (which may come from
the PDF content itself), each such variable will start with a space.

   Variables which do not start with a space directly reflect elements in
a PDF dictionary. In the case of a Text::PDF::File, the elements reflect
those in the trailer dictionary.

   Since some variables are not designed for class users to access,
variables are marked in the documentation with (R) to indicate that such
an entry should only be used as read-only information. (P) indicates that
the information is private and not designed for user use at all, but is
included in the documentation for completeness and to ensure that nobody
else tries to use it.

newroot
     This variable allows the user to create a new root entry to occur in
     the trailer dictionary which is output when the file is written or
     appended. If you wish to over-ride the root element in the dictionary
     you have, use this entry to indicate that without losing the current
     Root entry. Notice that newroot should point to a PDF level object
     and not just to a dictionary which does not have object status.

INFILE (R)
     Contains the filehandle used to read this information into this PDF
     directory. Is an IO object.

fname (R)
     This is the filename which is reflected by INFILE, or the original IO
     object passed in.

update (R)
     This indicates that the read file has been opened for update and that
     at some point, $p->appendfile() can be called to update the file with
     the changes that have been made to the memory representation.

maxobj (R)
     Contains the first useable object number above any that have already
     appeared in the file so far.

outlist (P)
     This is a list of Objind which are to be output when the next
     appendfile or outfile occurs.

firstfree (P)
     Contains the first free object in the free object list. Free objects
     are removed from the front of the list and added to the end.

lastfree (P)
     Contains the last free object in the free list. It may be the same as
     the firstfree if there is only one free object.

objcache (P)
     All objects are held in the cache to ensure that a system only has
     one occurrence of each object. In effect, the objind class acts as a
     container type class to hold the PDF object structure and it would be
     unfortunate if there were two identical place-holders floating around
     a system.

epos (P)
     The end location of the read-file.

   Each trailer dictionary contains a number of private instance variables
which hold the chain together.

loc (P)
     Contains the location of the start of the cross-reference table
     preceding the trailer.

xref (P)
     Contains an anonymous array of each cross-reference table entry.

prev (P)
     A reference to the previous table. Note this differs from the Prev
     entry which is in PDF which contains the location of the previous
     cross-reference table.

METHODS
=======

Text::PDF::File->new
--------------------

   Creates a new, empty file object which can act as the host to other PDF
objects.  Since there is no file associated with this object, it is
assumed that the object is created in readiness for creating a new PDF
file.

$p = Text::PDF::File->open($filename, $update)
----------------------------------------------

   Opens the file and reads all the trailers and cross reference tables to
build a complete directory of objects.

   $update specifies whether this file is being opened for updating and
editing, or simply to be read.

   $filename may be an IO object

$p->append_file()
-----------------

   Appends the objects for output to the read file and then appends the
appropriate tale.

$p->out_file($fname)
--------------------

   Writes a PDF file to a file of the given filename based on the current
list of objects to be output. It creates the trailer dictionary based on
information in $self.

   $fname may be an IO object;

$p->create_file($fname)
-----------------------

   Creates a new output file (no check is made of an existing open file) of
the given filename or IO object. Note, make sure that $p->{' version'} is
set correctly before calling this function.

$p->close_file
--------------

   Closes up the open file for output by outputting the trailer etc.

($value, $str) = $p->readval($str)
----------------------------------

   Reads a PDF value from the current position in the file. If $str is too
short then read some more from the current location in the file until the
whole object is read. This is a recursive call which may slurp in a whole
big stream (unprocessed).

   Returns the recursive data structure read and also the current $str
that has been read from the file.

$ref = $p->read_obj($objind)
----------------------------

   Given an indirect object reference, locate it and read the object
returning the read in object.

$objind = $p->new_obj($obj)
---------------------------

   Creates a new, free object reference based on free space in the cross
reference chain.  If nothing free then thinks up a new number. If $obj
then turns that object into this new object rather than returning a new
object.

$p->out_obj($objind)
--------------------

   Indicates that the given object reference should appear in the output
xref table whether with data or freed.

$p->free_obj($objind)
---------------------

   Marks an object reference for output as being freed.

$p->remove_obj($objind)
-----------------------

   Removes the object from all places where we might remember it

$p->ship_out(@objects)
----------------------

   Ships the given objects (or all objects for output if @objects is
empty) to the currently open output file (assuming there is one). Freed
objects are not shipped, and once an object is shipped it is switched such
that this file becomes its source and it will not be shipped again unless
out_obj is called again. Notice that a shipped out object can be re-output
or even freed, but that it will not cause the data already output to be
changed.

PRIVATE METHODS & FUNCTIONS
===========================

   The following methods and functions are considered private to this
class. This does not mean you cannot use them if you have a need, just
that they aren't really designed for users of this class.

$offset = $p->locate_obj($num, $gen)
------------------------------------

   Returns a file offset to the object asked for by following the chain of
cross reference tables until it finds the one you want.

update($fh, $str)
-----------------

   Keeps reading $fh for more data to ensure that $str has at least a line
full for `readval' to work on. At this point we also take the opportunity
to ignore comments.

$objind = $p->test_obj($num, $gen)
----------------------------------

   Tests the cache to see whether an object reference (which may or may
not have been getobj()ed) has been cached. Returns it if it has.

$p->add_obj($objind)
--------------------

   Adds the given object to the internal object cache.

$tdict = $p->readxrtr($xpos)
----------------------------

   Recursive function which reads each of the cross-reference and trailer
tables in turn until there are no more.

   Returns a dictionary corresponding to the trailer chain. Each trailer
also includes the corresponding cross-reference table.

   The structure of the xref private element in a trailer dictionary is of
an anonymous hash of cross reference elements by object number. Each
element consists of an array of 3 elements corresponding to the three
elements read in [location, generation number, free or used]. See the PDF
Specification for details.

$p->out_trailer($tdict)
-----------------------

   Outputs the body and trailer for a PDF file by outputting all the
objects in the ' outlist' and then outputting a xref table for those
objects and any freed ones. It then outputs the trailing dictionary and
the trailer code.

Text::PDF::File->_new
---------------------

   Creates a very empty PDF file object (used by new and open)

AUTHOR
======

   Martin Hosken Martin_Hosken@sil.org

   Copyright Martin Hosken 1999 and onwards

   No warranty or expression of effectiveness, least of all regarding
anyone's safety, is implied in this software or documentation.

Licensing
---------

   This Perl Text::PDF module is licensed under the Perl Artistic License.


File: pm.info,  Node: Text/PDF/Filter,  Next: Text/PDF/Name,  Prev: Text/PDF/File,  Up: Module List

Abstract superclass for PDF stream filters
******************************************

NAME
====

   PDF::Filter - Abstract superclass for PDF stream filters

SYNOPSIS
========

     $f = Text::PDF::Filter->new;
     $str = $f->outfilt($str, 1);
     print OUTFILE $str;
     
     while (read(INFILE, $dat, 4096))
     { $store .= $f->infilt($dat, 0); }
     $store .= $f->infilt("", 1);

DESCRIPTION
===========

   A Filter object contains state information for the process of outputting
and inputting data through the filter. The precise state information stored
is up to the particular filter and may range from nothing to whole objects
created and destroyed.

   Each filter stores different state information for input and output and
thus may handle one input filtering process and one output filtering
process at the same time.

METHODS
=======

Text::PDF::Filter->new
----------------------

   Creates a new filter object with empty state information ready for
processing data both input and output.

$dat = $f->infilt($str, $isend)
-------------------------------

   Filters from output to input the data. Notice that $isend == 0 implies
that there is more data to come and so following it $f may contain state
information (usually due to the break-off point of $str not being tidy).
Subsequent calls will incorporate this stored state information.

   $isend == 1 implies that there is no more data to follow. The final
state of $f will be that the state information is empty. Error messages
are most likely to occur here since if there is required state information
to be stored following this data, then that would imply an error in the
data.

$str = $f->outfilt($dat, $isend)
--------------------------------

   Filter stored data ready for output. Parallels `infilt'.

Ascii85 filter for PDF streams. Inherits from *Note Text/PDF/Filter: Text/PDF/Filter,
*************************************************************************************

NAME
====

   Text::PDF::ASCII85Decode - Ascii85 filter for PDF streams. Inherits from
*Note Text/PDF/Filter: Text/PDF/Filter,

Run Length encoding filter for PDF streams. Inherits from *Note Text/PDF/Filter: Text/PDF/Filter,
*************************************************************************************************

NAME
====

   Text::PDF::RunLengthDecode - Run Length encoding filter for PDF
streams. Inherits from *Note Text/PDF/Filter: Text/PDF/Filter,

Ascii Hex encoding (very inefficient) for PDF streams. Inherits from *Note Text/PDF/Filter: Text/PDF/Filter,
************************************************************************************************************

NAME
====

   Text::PDF::ASCIIHexDecode - Ascii Hex encoding (very inefficient) for
PDF streams.  Inherits from *Note Text/PDF/Filter: Text/PDF/Filter,


File: pm.info,  Node: Text/PDF/Name,  Next: Text/PDF/Number,  Prev: Text/PDF/Filter,  Up: Module List

Inherits from *Note Text/PDF/String: Text/PDF/String, and stores PDF names (things beginning with /)
****************************************************************************************************

NAME
====

   Text::PDF::Name - Inherits from *Note Text/PDF/String: Text/PDF/String,
and stores PDF names (things beginning with /)

METHODS
=======

$n->convert
-----------

   Converts a name into a string by removing the / and converting any hex
munging

as_pdf
------

   Returns a name formatted as PDF


File: pm.info,  Node: Text/PDF/Number,  Next: Text/PDF/Objind,  Prev: Text/PDF/Name,  Up: Module List

Numbers in PDF. Inherits from *Note Text/PDF/String: Text/PDF/String,
*********************************************************************

NAME
====

   Text::PDF::Number - Numbers in PDF. Inherits from *Note
Text/PDF/String: Text/PDF/String,

METHODS
=======

$n->convert($str)
-----------------

   Converts a string from PDF to internal, by doing nothing

$n->as_pdf
----------

   Converts a number to PDF format


