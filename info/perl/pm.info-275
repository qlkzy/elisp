This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Netscape/Registry,  Next: Netscape/Server,  Prev: Netscape/HistoryURL,  Up: Module List

emulate perl CGI programming under nsapi_perl
*********************************************

NAME
====

   Netscape::Registry - emulate perl CGI programming under nsapi_perl

SYNOPSIS
========

   In `obj.conf'

     NameTrans fn="pfx2dir"
         from="/perl" dir="/full/path/to/perl" name="perl"

     <Object name="perl">
     ObjectType fn="force-type" type="application/perl"
     Service fn="nsapi_perl_handler" module="Netscape::Registry"
     </Object>

DESCRIPTION
===========

   This module allows CGI programs written in Perl to be run within the
Netscape httpd server process.  This provides a large performance boost by
reducing overhead from the normal fork/exec/compile process for Perl CGI
programs.  Netscape::Registry is loaded into the server by nsapi_perl, the
Perl interface to the Netscape httpd API.

   For the full details of nsapi_perl, see `nsapi_perl' in this node.
Suffice it to say here that nsapi_perl provides a mechanism by which a Perl
interpreter is embedded into a Netscape server.  The NSAPI can then be
programmed to in Perl rather than in C.  This is achieved by placing the
appropriate hooks in the server configuration files; nsapi_perl will then
call whatever Perl subroutines you wish at various stages of processing a
request from a client.

   This module was inspired by and derived from Apache::Registry, which
provides the same functionality for the Apache web server.

USAGE
=====

   Basically you need to tell your Netscape server that all files
underneath a certain directory, or ending with a certain suffix, are to be
handled during the Service stage of the transaction by the Perl module
*Netscape::Registry*.  This generally involves editing the file
`obj.conf'; see `nsapi_perl' in this node and your server's documentation
for full details.  See also `' in this node.

   After this initial setup, it's essentially CGI programming as per
normal.  However, since your scripts are actually run in the server
process, it's prudent to avoid the use of global variables since they may
by left around after your script has finished.

   Netscape::Registry works with Lincoln Stein's CGI.pm module but you
should use version 2.36 or more recent; earlier versions may not clean up
global variables properly.

   Compile and run-time errors from your scripts are written to the
server's error log.

   See `' in this node for a summary of (some) known bugs.

INTERNALS
=========

   The first request for a given file causes the file to be compiled (by
eval()) into a subroutine whose package is is unique to that file.  The
modification time and length of the source file are then stored in a
global hash.

   The subroutine is then executed by a statement like this:

     eval {package->subroutine};

   Each subsequent request for the file causes Netscape::Registry to check
the time stamp and size of the file.  If the file has changed, it is
recompiled and then executed.  If the file has not changed, it is executed
immediately.

   Standard input and output are tie()d to the Netscape::Server::Socket
class.  This enables your script's output to be sent to the client.  It
also lets your script read the content of POST-type requests on the
standard input (but don't do this yourself; let CGI.pm take care of it for
you).

   The perl built-in exit() function is redefined to be a mutation of
die() - and hence trapable by the above eval() - so that it doesn't cause
grief for the server.

ENVIRONMENT
===========

   Netscape::Registry attempts to provide the same environment as for
normal CGI, but at the time of writing there are some differences.

AUTH_TYPE
     This variable is the same as under regular CGI.  It is only defined if
     the program being accessed is under access control.

CONTENT_LENGTH
     This variable is the same as under regular CGI.

CONTENT_TYPE
     This variable is the same as under regular CGI.

GATEWAY_INTERFACE
     This variable is defined as *CGI/1.1; nsapi_perl/x.y* where x and y
     are respectively the major and minor version numbers of nsapi_perl.

HTTPS
     This variable is currently hardcoded to the value OFF.  Let the
     author know if this is a problem.


     These variables, which represent the header lines from the client's
     request header, are defined the same as they would be under regular
     CGI.

PATH
     This variable is currently not defined under nsapi_perl but it is
     under (at least some of) Netscape's implementations of CGI.  I don't
     think it *should* be defined under CGI, so if you've come to rely on
     it, that's your problem :-)

PATH_INFO
     This variable is the same as under regular CGI.

PATH_TRANSLATED
     Under Netscape's implementation of CGI, this variable (if defined) is
     PATH_INFO appended to the server's document root.  Under nsapi_perl,
     this variable (if defined) is PATH_INFO appended to the full path to
     the script.  One of these implementations is probably in error.

QUERY_STRING
     This variable is the same as under regular CGI.

REMOTE_ADDR
     This variable is the same as under regular CGI.

REMOTE_HOST
     This variable is the same as under regular CGI.

REQUEST_METHOD
     This variable is the same as under regular CGI.

REMOTE_USER
     This variable is the same as under regular CGI.  It is only defined if
     the program being accessed is under access control.

SCRIPT_NAME
     This variable is the same as under regular CGI.

SERVER_NAME
     This variable is currently undefined under nsapi_perl.  This is a bug.

SERVER_PORT
     This variable is currently undefined under nsapi_perl.  This is a bug.

SERVER_PROTOCOL
     This variable is the same as under regular CGI.

SERVER_SOFTWARE
     This variable is currently undefined under nsapi_perl.  This is a bug.

SERVER_URL
     This variable is currently undefined under nsapi_perl.  This is a bug.

BUGS
====

   Command-line switches on your CGI scripts are currently ignored by
nsapi_perl.  For example, if you dutifully put

     #!/usr/bin/perl -w

   at the start of your script, it will be ignored.

   See `' in this node for some important differences in environment
variables between nsapi_perl and regular CGI.

   Extension modules that dynamically load a shared object may cause you
grief.  See the section titled *DYNAMIC LOADING OF EXTENSION MODULES* in
`nsapi_perl' in this node if you suffer problems.  The good news is that
such modules are reported to work "out of the box" on Win32.

   use CGI::Carp('fatalsToBrowser') doesn't work as expected.

   CGI programs can't - or at least shouldn't - muck with @INC.

   Expect other bugs and weirdness.  Please don't get mad; just report
them to nsapi_perl mailing list: nsapi_perl@samurai.com.

AUTHOR
======

   Benjamin Sugars <bsugars@canoe.ca>

SEE ALSO
========

   perl(1), nsapi_perl, modperl, Apache::Registry


File: pm.info,  Node: Netscape/Server,  Next: Netscape/Server/Request,  Prev: Netscape/Registry,  Up: Module List

framework for integrating Perl and Netscape servers
***************************************************

NAME
====

   Netscape::Server - framework for integrating Perl and Netscape servers

SYNOPSIS
========

     use Netscape::Server;
     use Netscape::Server qw/:request_codes/;
     use Netscape::Server qw/:protocol_codes/;
     use Netscape::Server qw/:error_codes/;
     use Netscape::Server qw/:all/;

     log_error($degree, $sub, $sn, $rq, $gripe);
     func_exec($fname, $sn, $rq, $args);

DESCRIPTION
===========

   The Netscape::Server module provides a framework for other modules that
implement an interface between Perl and the Netscape Server Application
Programming Interface (NSAPI).  Netscape::Server provides definitions of
the various NSAPI constants and server functions for error logging.

   For an overview of integrating Perl and NSAPI, see `nsapi_perl' in this
node.  Suffice it to say here that nsapi_perl provides a mechanism by
which a Perl interpreter is embedded into a Netscape server.  The NSAPI can
then be programmed to in Perl rather than in C.  This is achieved by
placing the appropriate hooks in the server configuration files;
nsapi_perl will then call whatever Perl subroutines you wish at various
stages of processing a request from a client.

   Perl modules interfacing to the NSAPI will require access to the
structures and constants defined in the NSAPI C header files.  The two
structures defined in these header files that are of most interest are the
Session structure and the Request structure.  These two structures are
represented in Perl by instances of the Netscape::Server::Request and
Netscape::Server::Session classes; see their individual man pages for full
details.

   The rest of this document describes the constants and functions
declared in the NSAPI header files that are accessible through the
Netscape::Server module.

IMPORTABLE CONSTANTS
====================

   Importable from the point of view of whoever is using Netscape::Server,
that is.

   NSAPI constants of interest to Perl fall into the following categories
(for full details, see your Netscape Server documentation or the NSAPI
header files).

Request-Response Codes
----------------------

   Request-Response codes are those constants that NSAPI C functions
return to the server to tell the server what to do next.  Similarly, Perl
subroutines called from nsapi_perl should return one of these constants.

REQ_PROCEED
     Returned by a subroutine when it has performed its task without a
     problem.

REQ_NOACTION
     Returned by a subroutine when conditions indicate it is not
     appropriate for the subroutine to perform its task.

REQ_ABORTED
     Returned by a subroutine when an error has occurred an the client's
     request cannot be completed.

REQ_EXIT
     Returned by a subroutine when a read or write error to or from the
     client has occurred and no further communication with the client is
     possible.

   See `nsapi_perl' in this node for a description of how the server
behaves when a particular constant is returned from a subroutine.

Protocol-Status Codes
---------------------

   Subroutines should use these constants to set the HTTP status of the
server's response to the request.  This should be done (using the
protocol_status() method of either Netscape::Server::Session or
Netscape::server::Request) before any data is sent to the client.  These
constants have exact analogs in the definition of the http protocol itself.

PROTOCOL_OK
     Request can be fulfilled no problem.

PROTOCOL_REDIRECT
     The client making the request should be sent to another URL.

PROTOCOL_NOT_MODIFIED
     The requested object has not been modified since the date indicated by
     the client in its initial request.

PROTOCOL_BAD_REQUEST
     The request was not understandable.

PROTOCOL_UNAUTHORIZED
     The client did not supply proper authorization to access the requested
     object.

PROTOCOL_FORBIDDEN
     The client is explicitly forbidden to access the requested object.

PROTOCOL_NOT_FOUND
     The requested object could not be found.

PROTOCOL_SERVER_ERROR
     An internal server error has occurred.

PROTOCOL_NOT_IMPLEMENTED
     The server has been asked to do something it knows it cannot do.

Error-Logging Codes
-------------------

   Error-logging codes are used by subroutines when an error has occurred.
In particular, when an error occurs, the subroutine should call the
function log_error(); see `' in this node for more details.

LOG_INFORM
     An informational message.

LOG_WARN
     A warning message.

LOG_MISCONFIG
     An internal misconfiguration or permission problem.

LOG_SECURITY
     An authentication failure.

LOG_FAILURE
     A problem internal to your subroutine.

LOG_CATASTROPHE
     A non-recoverable server error.

FUNCTIONS
=========

   The following functions may be imported in to the calling package's
namespace.

log_error
          $success = log_error($degree, $sub, $sn, $rq, $gripe);

     *$degree* is one of the constants defined in `' in this node; it
     specifies the severity of your problem.  *$sub* is a string that
     should contain the name of the subroutine producing the error.  $sn
     is an instance of Netscape::Server::Session.  *$rq* is an instance of
     Netscape::Server::Request.  $gripe is an excuse for the error you have
     begat; make it a good one.

     log_error returns true if the error has been successfully logged;
     undef otherwise (Note: the log_error function for the servers I have
     access to produces different return values than what the
     documentation says I should expect.  I have built the perl log_error()
     function based on the return values I have emprically determined.  If
     Netscape changes their API to agree with the documentation, the perl
     log_error() function might break.)

func_exec
          $proceed = func_exec($fname, $sn, $rq, $args);
          $proceed = func_exec($fname, $sn, $rq);

     Call a function from the NSAPI. Returns REQ_ABORTED if no function was
     executed, or the return code of the called function. *$fname* is the
     function name, as it would appear in a directive line from obj.conf.
     $sn is an instance of Netscape::Server::Session. *$rq* is an instance
     of Netscape::Server::Request. The optional $args is a reference to a
     hash containing argument and value pairs.

     Example:

          $proceed = func_exec('find-index', $sn, $rq,
                       {'index-names' => 'my_index'});

IMPORT TAGS
===========

   A module wishing to import Netscape::Server symbols into its namespace
can use the following tags as arguments to the *use Netscape::Server* call.

:request_codes
     Import the constants request-response codes like REQ_PROCEED,
     REQ_NOACTION, etc.

:protocol_codes
     Import the protocol-status codes like PROTOCOL_OK, PROTOCOL_REDIRECT,
     etc.

:error_codes
     Import the error-logging codes like LOG_INFORM, LOG_WARN, etc.  This
     tag also imports the *log_error()* function.

:all
     Import all constant symbols, the *log_error()* and *func_exec()*
     functions.

AUTHOR
======

   Benjamin Sugars <bsugars@canoe.ca>

   Contributions from Steve Nielsen <spn@enteract.com> and Olivier Dehon
<dehon_olivier@jpmorgan.com>.

SEE ALSO
========

   perl(1), nsapi_perl, Netscape::Server::Session,
Netscape::Server::Request


File: pm.info,  Node: Netscape/Server/Request,  Next: Netscape/Server/Session,  Prev: Netscape/Server,  Up: Module List

Perl interface to Netscape server Request
*****************************************

NAME
====

   Netscape::Server::Request - Perl interface to Netscape server Request

SYNOPSIS
========

     package Netscape::Server::Something;
     use Netscape::Server qw/:all/;

     sub handler {
         my($pb, $sn, $rq) = @_;
         ...
         $auth_type = $rq->auth_type;
         $path_info = $rq->path_info;
         $query_string = $rq->query_string;
         $remote_user = $rq->remote_user;
         $request_method = $rq->request_method;
         $server_protocol = $rq->server_protocol;
         $user_agent = $rq->user_agent;
         $vars = $rq->vars;
         $reqpb = $rq->reqpb;
         $headers = $rq->headers;
         $srvhdrs = $rq->srvhdrs;
         $rq->protocol_status($sn, $status, $reason);
         $proceed = $rq->protocol_start_response($sn, $rq);
         ...
     }

DESCRIPTION
===========

   The Netscape::Server::Request class provides a Perl-object interface to
the Netscape Server API Request structure.  Instances of the
Netscape::Server::Request structure are passed as arguments to all Perl
subroutines that are executed by a Netscape server that has been
integrated with Perl using nsapi_perl.

   For an overview of integrating Perl and NSAPI, see `nsapi_perl' in this
node.  Suffice it to say here that nsapi_perl provides a mechanism by
which a Perl interpreter is embedded into a Netscape server.  The NSAPI can
then be programmed to in Perl rather than in C.  This is acheived by
placing the appropriate hooks in the server configuration files;
nsapi_perl will then call whatever Perl subroutines you wish at various
stages of processing a request from a client.

   When a Perl subroutine is called by nsapi_perl, it is passed three
arguments:

     my($pb, $sn, $rq) = @_;

   *$pb* is a reference to hash to the *key=value* pairs passed to the
argument from the server configuration files; see `nsapi_perl' in this
node for more details.  $sn is an instance of Netscape::Server::Session
which has its own man page. *$rq* is an instance of
Netscape::Server::Request and is the subject of the rest of this document.

OBJECT ABSTRACTION
==================

   A request in the world of the NSAPI is an entity that encapsulates the
header data sent from the client and header data sent back by the server
during an http transaction. In addition, information internal to the
server generated in during a transaction is considered part of a request.
In the NSAPI all this information is maintained in a C structure called a
Request.

   Netscape::Server::Request provides a Perl interface to the Request
structure.  It also provides methods that cause the server to perform an
action based on the current state of the request.

   Some Netscape::Server::Request methods require that an instance of
Netcape::Server::Session be passed as an argument.  You will find that
those methods requiring this will have a synonym method defined in
Netscape::Server::Session.  This is so you don't have to remember whether
such a method is to be written as

     $rq->method($sn);

   or

     $sn->method($rq);

   where $rq is an instance of Netscape::Server::Request and $sn is an
instance of Netscape::Server::Session.  Either method call will do the
same thing.

INSTANCE METHODS
================

   Netscape::Server::Request methods can be divided into those that return
request attributes, those that access server variables, and those that
perform actions.

Request Attributes
------------------

   These methods return or set attributes of the request.

auth_type
          $auth_type = $rq->auth_type($type);

     With no arguments returns the authorization type of the request.  This
     will either be 'basic' if authorization has been provided by the
     client or undef if the client provided no authorization.  The $type
     argument sets the authorization to the value of $type.

path_info
          $path_info = $rq->path_info($path);

     With no arguments returns the extra path information appended to the
     URI of the request.  Note that this may not be defined during the
     initial stages of processing a request; usually it is defined by
     NameTrans directives.  The optional argument allows you to set the
     extra path information.

query_string
          $query_string = $rq->query_string($path);

     With no arguments returns the query string information appended to the
     URI of the request.  Note that this may not be defined during the
     initial stages of processing a request; usually it is defined by
     NameTrans directives.  The optional argument allows you to set the
     query string information.

remote_user
          $remote_user = $rq->remote_user($user);

     With no arguments returns the remote user as determined from http
     authentication.  If no authentication has been provided with the
     request this will be undef.  The optional argument allows you to set
     the remote user.

request_method
          $request_method = $rq->request_method($method);

     With no arguments returns the request method of the request.  This
     will probably be one of GET, POST, or HEAD.  The optional argument
     allows you to set the request method.

server_protocol
          $server_protocol = $rq->server_protocol($protocol);

     With no arguments returns something like "HTTP/1.0", or whatever
     protocol the server is using to process the request.  The optional
     argument allows you to set the server protocol, although I'm not sure
     how this affects server internals.

user_agent
          $user_agent = $rq->user_agent($agent);

     With no arguments returns the value sent by the browser in the
     "User-Agent" field of the http request header.  The optional argument
     allows you to set the user agent.

Server Variable Methods
-----------------------

   These methods allow you to work with the variables the server uses when
constructing a response to a request.  Each such variable is basically a
key=value pair.  The variables are grouped into 4 different categories.
Each category of variable is accessed using a method specific to that
category.

vars
     This method accesses server working variables.

          $vars = $rq->vars;
          $vars = $rq->vars($key);
          $vars = $rq->vars($key, $value);

     With no arguments returns a reference to hash containing the names and
     values of server working variables for this request.  Server working
     variables are internal variables set up by the server during the
     various stages of processing a request.  These variables describe
     things like the document root directory for the server, the full path
     to the requested file, and so on.

     With one argument returns the value of the variable named by $key, or
     undef if the variable doesn't exist.

     With two arguments sets the variable named by $key to $value.  This is
     the "official" way for one nsapi_perl subroutine to pass data to a
     second subroutine that will run later on during the request.

     I do not know of a definitive list of server working variable names,
     but the following seem to be in common usage in NSAPI documentation
     and examples.

     *auth-type*: This variable is defined by subroutines running in the
     AuthTrans stage of processing a request.  It should be to the literal
     *basic* if http authentication is in effect for this request.

     *auth-user*: This variable is defined by subroutines running in the
     AuthTrans stage of processing a request.  It should be set to the
     username as determined from the client's authentication information if
     authentication was successful.

     *ppath*: This variable initially contains the partial path as
     determined from the clients request header.  For instance if a client
     requests *http://server/file.html*, *ppath* would initially contain
     the string */file.html*.

     name: This variable can be created by a NameTrans subroutine to
     indicate that the object named by name is to be added to the set of
     active objects processing this request.  See `nsapi_perl' in this
     node and your Netscape server documentation for what an object is in
     this context.

     path: This variable contains the full path to the requested file
     after all NameTrans subroutines have run.  If don't plan on having the
     built-in NameTrans function run in addition to your subroutines, then
     you are responsible for setting this variable to the correct value.

     You can create any number of your own variables to pass information to
     subroutines that will run later on in processing of the request.

reqpb
     This method accesses client request line variables.

          $reqpb = $rq->reqpb;
          $reqpb = $rq->reqpb($key);
          $reqpb = $rq->reqpb($key, $value);

     With no arguments returns a reference to a hash containing these
     entries:

     method: The method of the request: either GET, HEAD, or POST.

     *uri*: The URI the client asked for in the request.

     protocol: The protocol of the request, as in HTTP/1.0 or something
     like that.

     *clf-request*: The full test of the first line of the client's
     request.

     With one argument this method returns the value of the field named by
     $key.

     With two arguments this method sets the field named by $key to $value.

headers
     This method accesses client request header variables.

          $headers = $rq->headers;
          $headers = $rq->headers($key);
          $headers = $rq->headers($key, $value);

     With no arguments returns a reference to hash containing the client's
     request headers.  The keys of this hash are the names of the various
     header lines conveted to all lower case, such as *user-agent* and
     cookie.  The values are whatever text appeared in that field of the
     header.

     With one argument this method returns the value of the request header
     field named by $key.  Be sure to use the all lower-case form of the
     field name.

     With two arguments sets the value of the request header field named by
     $key (again all lower-case) to $value.  Setting one of these values is
     not an ethical thing.

srvhdrs
     This method accesses server response header variables.

          $srvhdrs = $rq->srvhdrs;
          $srvhdrs = $rq->srvhdrs($key);
          $srvhdrs = $rq->srvhdrs($key, $value);

     With no arguments returns a reference to a hash containing the
     server's response headers.  The keys of this hash are the names of
     the various header lines converted to all lower case, such as
     *content-type* and *set-cookie*.  The values are whatever text
     appears in that field of the header.

     With one argument this method returns the value of the request header
     field name dby $key.  Be sure to user the all lower-case form of the
     field name.

     With two arguments sets the value of the request header field named by
     $key (again all lower-case) to $value.  This is the "official" way to
     set the server's response headers.  Make sure you do this before
     using protocol_start_response() (a method defined below).

Action Methods
--------------

   These methods cause the server to take an action based on the current
state of the request.  They are listed in the approximate sequence in
which they should be used by the nsapi_perl subroutine.  Some of these
methods indicate success or failure by returning one of the constants
defined in the Netscape::Server module.

protocol_status
          $rq->protocol_status($sn, $status, $reason);

     Sets the HTTP status of the session.  $sn is an instance of
     Netscape::Server::Session.  $status is one of the protocol-status
     constants, like PROTOCOL_OK, that can imported from Netscape::Server.
     $reason is an optional string sent to the client in the status line.
     If $reason is omitted the server will pick one based on $status
     defaulting to "unknown reason" in degenerate cases. This method
     returns nothing.

protocol_start_response
          $proceed = $rq->protocol_start_response($sn, $status, $reason);

     Initiates an http response to the client by sending an http header
     based on the current state of $sn and $rq.  $sn is an instance of
     Netscape::Server::Session.  Returns either REQ_PROCEED, REQ_NOACTION
     or REQ_ABORTED.  If REQ_PROCEED is returned the subroutine can
     continue as normal.  If REQ_NOACTION is returned, the method
     succeeded, but the client needs no actual data (perhaps because the
     client has the data in its cache.)  If REQ_ABORTED is returned, the
     method did not succeed.

   To send data to the client see net_write() in *Note
Netscape/Server/Session: Netscape/Server/Session,.

AUTHOR
======

   Benjamin Sugars <bsugars@canoe.ca>

SEE ALSO
========

   perl(1), nsapi_perl, Netscape::Server, Netscape::Server::Session


File: pm.info,  Node: Netscape/Server/Session,  Next: Netscape/Server/Socket,  Prev: Netscape/Server/Request,  Up: Module List

Perl interface to Netscape server Session
*****************************************

NAME
====

   Netscape::Server::Session - Perl interface to Netscape server Session

SYNOPSIS
========

     package Netscape::Server::Something;
     use Netscape::Server qw/:all/;

     sub handler {
         my($pb, $sn, $rq) = @_;
         ...
         $remote_host = $sn->remote_host;
         $remote_addr = $sn->remote_addr;
         ...
         $sn->protocol_status($rq, $status, $reason);
         $proceed = $sn->protocol_start_response($rq);
         $sn->net_write($message);
         $sn->net_read($length, $timeout);
         $sn->sys_net_read($length, $offset);
         ...
     }

DESCRIPTION
===========

   The Netscape::Server::Session class provides a Perl-object interface to
the Netscape Server API Session structure.  Instances of the
Netscape::Server::Session class are passed as arguments to all Perl
subroutines that are executed by a Netscape server that has been
integrated with Perl using nsapi_perl.

   For an overview of integrating Perl and NSAPI, see `nsapi_perl' in this
node.  Suffice it to say here that nsapi_perl provides a mechanism by
which a Perl interpreter is embedded into a Netscape server.  The NSAPI can
then be programmed to in Perl rather than in C.  This is achieved by
placing the appropriate hooks in the server configuration files;
nsapi_perl will then call whatever Perl subroutines you wish at various
stages of processing a request from a client.

   When a Perl subroutine is called by nsapi_perl, it is passed three
arguments:

     my($pb, $sn, $rq) = @_;

   *$pb* is a reference to hash to the key=value pairs passed to the
subroutine from the server configuration files; see `nsapi_perl' in this
node for more details.  *$rq* is an instance of Netscape::Server::Request
which has its own man page. $sn is an instance of
Netscape::Server::Session and is the subject of the rest of this document.

OBJECT ABSTRACTION
==================

   In NSAPI circles, "a session is the time between the opening and the
closing of the connection between the client and the server", quoting the
Netscape server documentation.  The NSAPI stores information about a
session in a C structure called Session. This information includes the
client host's IP address and hostname, socket and buffer information about
the connection to the client, and parameters related to the client's
ability to transmit data encrypted through SSL.

   Netscape::Server::Session exposes these properties to nsapi_perl
subroutines through instance methods.  Since these properties apply
session-wide, these properties are read-only.

   In addition to allowing access to these properties, other
Netscape::Server::Session instance methods cause the server to perform
actions for the Session.  For example, the *net_write()* method sends a
message to the client.

   Some methods require that an instance of Netscape::Server::Request be
passed as an argument.  Those that do will also have synonyms in the
Netscape::Server::Request class so that you don't have to remember whether
the method is to be written as

     $sn->method($rq);

   or

     $rq->method($sn)

   where $sn is an instance of Netscape::Server::Session and $rq is an
instance of Netscape::Server::Request. Either method call will do the same
thing.

INSTANCE METHODS
================

   Netscape::Server::Session instance methods can be divided into those
that return session attributes and those that perform actions.

Session Attributes
------------------

remote_host
          $remote_host = $sn->remote_host;

     Returns the hostname of the client's host.  Returns undef if the
     hostname cannot be resolved.

remote_addr
          $remote_addr = $sn->remote_addr;

     Returns the IP address of the client's host.

Session Actions
---------------

   These methods are listed in the approximate sequence in which they
should be used by the nsapi_perl subroutine. Some of these methods
indicate success or failure by returning one of the constants defined in
the Netscape::Server module.

protocol_status
          $sn->protocol_status($rq, $status, $reason);

     Set the HTTP status of the session.  $rq is an instance of
     Netscape::Server::Request.  $status is one of the protocol-status
     constants, like PROTOCOL_OK, that can imported from Netscape::Server.
     $reason is an optional string sent to the client in the status line.
     If $reason is omitted the server will pick one based on $status
     defaulting to "unknown reason" in degenerate cases. This method
     returns nothing.

protocol_start_response
          $proceed = $sn->protocol_start_response($rq);

     Initiates an http response to the client by sending an http header
     based on the current state of $sn and $rq.  $rq is an instance of
     Netscape::Server::Request.  Returns either REQ_PROCEED, REQ_NOACTION
     or REQ_ABORTED.  If REQ_PROCEED is returned the subroutine can
     continue as normal.  If REQ_NOACTION is returned, the method
     succeeded, but the client needs no actual data (perhaps because the
     client has the data in its cache.)  If REQ_ABORTED is returned, the
     method did not succeed.

net_write
          $sn->net_write($message);

     Sends the contents of $message to the client.  Returns the number of
     bytes actually sent (which may be less than the length of message if
     there are problems).  This seems to be the preferred method to send
     data to the client.

net_read
          $sn->net_read($length);
          $sn->net_read($length, $timeout);

     Reads $length bytes of data from the body of this Session's http
     request. If $timeout is specified, its default value of 10 seconds is
     overridden. In the event of an error, $! is set to reflect errno.

sys_net_read
          $sn->sys_net_read($buffer, $length, $offset);

     Reads $length bytes of data from the body of this Session's http
     request into $buffer.  If $offset is specified, the content read will
     will written to $buffer starting at position $offset in $buffer.
     $buffer will grow or shrink as necessary. It returns the number of
     bytes read. This method can be used to read HTML form data sent to
     the server by a client; see, for instance, the READ method in
     Netscape::Server::Socket.

AUTHOR
======

   Benjamin Sugars <bsugars@canoe.ca>

   Contributions by Olivier Dehon <dehon_olivier@jpmorgan.com>.

SEE ALSO
========

   perl(1), nsapi_perl, Netscape::Server, Netscape::Server::Request


File: pm.info,  Node: Netscape/Server/Socket,  Next: Network/IPv4Addr,  Prev: Netscape/Server/Session,  Up: Module List

Netscape httpd/client socket class
**********************************

NAME
====

   Netscape::Server::Socket - Netscape httpd/client socket class

SYNOPSIS
========

     use Netscape::Server::Socket;
     tie(*FILEHANDLE, 'Netscape::Server::Socket', $sn, $rq);

DESCRIPTION
===========

   Netscape::Server::Socket provides a perl implementation of the socket
connection between the Netscape httpd and clients connecting to the
server.  It is intended to be used by nsapi_perl modules that wish to send
or receive data to a client.

   For the full details of nsapi_perl, see `nsapi_perl' in this node.
Suffice it to say here that nsapi_perl provides a mechanism by which a Perl
interpreter is embedded into a Netscape server.  The NSAPI can then be
programmed to in Perl rather than in C.  This is achieved by placing the
appropriate hooks in the server configuration files; nsapi_perl will then
call whatever Perl subroutines you wish at various stages of processing a
request from a client.

   The remainder of this document describes the usage and internals of
Netscape::Server::Socket.

USAGE
=====

   Users of Netscape::Server::Socket will generally want to tie a
filehandle to the class.  Subsequent transactions on that filehandle will
then read to or from the client.  Indeed, at this time, all of
Netscape::Server::Socket's class and instance methods are for use by tie().

   Generally, it is therefore sufficient to call tie() as follows

     tie(*FILEHANDLE, 'Netscape::Server::Socket', $sn, $rq);

   *FILEHANDLE is the typeglob of the filehandle you wish to tie; $sn is an
instance of Netscape::Server::Session; $rq is an instance of
Netscape::Server::Request.

   The above call will return an instance Netscape::Server::Socket if
successful.  Most likely you will not need to call instance methods on
this object.  Rather, you will let the magic of tie() call the appropriate
instance methods whenever a read or write is attempted on the tied
filehandle.

   Currently the following actions on the tied filehandle are supported:

print FILEHANDLE LIST
printf FILEHANDLE FORMAT, LIST
read FILEHANDLE,SCALAR,LENGTH,OFFSET
sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
   At this time there is no support for reading from the filehandle using
the diamond operator or using getc().  In other words, doing a

     my $line = <FILEHANDLE>
     my $char = getc(FILEHANDLE);

   for a tied FILEHANDLE will not work.

   Most of you can stop reading at this point; if you're interested in the
internals of the module, read on.

METHODS
=======

   The user need not call these methods directly but can rely on the magic
of tie() to do that for them.  The methods are listed here for
completeness.

Constructor
-----------

TIEHANDLE
          my $socket = TIEHANDLE Netscape::Server::Socket, $sn, $rq;

     The TIEHANDLE method returns an instance of Netscape::Server::Socket.
     $sn is an instance of Netscape::Server::Session.  $rq is an instance
     of Netscape::Server::Request.

Instance Methods
----------------

PRINT
          $socket->PRINT(@stuff);

     Causes @stuff to be sent to the client.  Until a completely empty line
     is received, the data is assumed to comprise the http header.
     Subsequent data is assumed to comprise the http message body.  In
     other words, things like

          $socket->PRINT("Content-type: text/plain\n",
                         "\n",
                         "This came from the server\n");

     will work as expected.

PRINTF
          $socket->PRINTF($format, @stuff);

     Works like the perl built-in printf function, but sends the data to
     the client.  This is just a wrapper around PRINT(), so it has the same
     behaviour regarding the http header/body.

READ
          $socket->READ($scalar, $length, $offset);

     Attempts to read $length bytes of data from the body of the client's
     request to the server starting at $offset.  Stores the results in
     $scalar.  Returns the actual number of bytes read.

     Note that this method does not read data from the header of the
     client's request.  To do this, look at the Netscape::Server::Request
     man page.

     Note also that this method does not (yet) return undef in the case of
     an I/O error.  This is an ugly bug that will be fixed in future
     release.

AUTHOR
======

   Benjamin Sugars <bsugars@canoe.ca>

SEE ALSO
========

   perl(1), perltie(3)

   nsapi_perl, Netscape::Server::Session, Netscape::Server::Request


File: pm.info,  Node: Network/IPv4Addr,  Next: News/Article,  Prev: Netscape/Server/Socket,  Up: Module List

Perl extension for manipulating IPv4 addresses.
***********************************************

NAME
====

   Network::IPv4Addr - Perl extension for manipulating IPv4 addresses.

SYNOPSIS
========

     use Network::IPv4Addr qw( :all );

     my ($ip,$cidr) = ipv4_parse( "127.0.0.1/24" );
     my ($ip,$cidr) = ipv4_parse( "192.168.100.10 / 255.255.255.0" );

     my ($net,$msk) = ipv4_network( "192.168.100.30" );

     my $broadcast  = ipv4_broadcast( "192.168.100.30/26" );

     if ( ipv4_in_network( "192.168.100.0", $her_ip ) ) {
       print "Welcome !";
     }

     etc.

DESCRIPTION
===========

   Network::IPv4Addr provides functions for parsing IPv4 addresses both in
traditional address/netmask format and in the new CIDR format.  There are
also methods for calculating the network and broadcast address and also to
see check if a given address is in a specific network.

ADDRESSES
=========

   All of Network::IPv4Addr functions accepts addresses in many format.
The parsing is very liberal.

   All these addresses would be accepted:

     127.0.0.1
     192.168.001.010/24
     192.168.10.10/255.255.255.0
     192.168.30.10 / 21
     10.0.0.0 / 255.0.0.0
     255.255.0.0

   Those wouldn't though:

     272.135.234.0
     192.168/16

   Most functions accepts the address and netmask or masklength in the
same scalar value or as separate values. That is either

     my($ip,$masklength) = ipv4_parse($cidr_str);
     my($ip,$masklength) = ipv4_parse($ip_str,$msk_str);

USING
=====

   No functions are exported by default. Either use the :all tag to import
them all or explicitly import those you need.

FUNCTIONS
=========

ipv4_parse
          my ($ip,$msklen) = ipv4_parse($cidr_str);
          my $cidr = ipv4_parse($ip_str,$msk_str);
          my ($ip) = ipv4_parse($ip_str,$msk_str);

     Parse an IPv4 address and in scalar context the address in CIDR
     format and in an array context the address and the mask length.

     If the parameters doesn't contains a netmask or a mask length, in
     scalar context only the IPv4 address is returned and in an array
     context the mask length is undefined.

     If the function cannot parse its input, it croaks. Trap it using eval
     if don't like that.

ipv4_network
          my $cidr = ipv4_network($ip_str);
          my $cidr = ipv4_network($cidr_str);
          my ($net,$msk) = ipv4_network( $net_str, $msk_str);

     In scalar context, this function returns the network in CIDR format in
     which the address is. In array context, it returns the network
     address and its mask length as a two elements array. If the input is
     an host without a netmask of mask length, the default netmask is
     assumed.

     Again, the function croak if the input is invalid.

ipv4_broadcast
          my ($broadcast) = ipv4_broadcast($ip_str);
          my $broadcast   = ipv4_broadcast($ip_str,$msk_str);

     This function returns the broadcast address. If the input doesn't
     contains a netmask or mask length, the default netmask is assumed.

     This function croaks if the input is invalid.

ipv4_network
          my $cidr = ipv4_network($net_str);
          my $cidr = ipv4_network($cidr_sstr);
          my ($net,$msk) = ipv4_network( $ip_str, $mask_str);

     In scalar context, this function returns the network in CIDR format in
     which the address is. In array context, it returns the network
     address and its mask length as a two elements array. If the input is
     an host without a netmask or mask length, the default netmask is
     assumed.

     Again, the function croak if the input is invalid.

ipv4_in_network
          print "Yes" if ipv4_in_network( $cidr_str1, $cidr_str2);
          print "Yes" if ipv4_in_network( $ip_str1, $mask_str1, $cidr_str2 );
          print "Yes" if ipv4_in_network( $ip1, $mask1, $ip2, $msk2 );

     This function checks if the second network is contained in the first
     one and it implements the following semantics :

          If net1 or net2 is a magic address (0.0.0.0 or 255.255.255.255)
          than this function returns true.

          If net1 is an host, net2 will be in the same net only if
          it is the same host.

          If net2 is an host, it will be contained in net1 only if
          it is part of net1.

          If net2 is only part of net1 if it is entirely contained in
          net1.

     Trap bad input with eval or else.

ipv4_checkip
          if ($ip = ipv4_checkip($str) ) {
          	# Do something
          }

     Return the IPv4 address in the string or undef if the input doesn't
     contains a valid IPv4 address.

ipv4_cidr2msk
          my $netmask = ipv4_cidr2msk( $cidr );

     Returns the netmask corresponding to the mask length given in input.
     As usual, croaks if it doesn't like your input (in this case a number
     between 0 and 32).

ipv4_msk2cidr
          my $masklen = ipv4_msk2cidr( $msk );

     Returns the mask length of the netmask in input. As usual, croaks if
     it doesn't like your input.

AUTHOR
======

   Francis J. Lacoste francis.lacoste@iNsu.COM

COPYRIGHT
=========

   Copyright (c) 1999 Francis J. Lacoste and iNsu Innovations Inc.  All
rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms as perl itself.

SEE ALSO
========

   perl(1) ipv4calc(1).


File: pm.info,  Node: News/Article,  Next: News/AutoReply,  Prev: Network/IPv4Addr,  Up: Module List

Object for handling Usenet articles in mail or news form.
*********************************************************

NAME
====

   News::Article - Object for handling Usenet articles in mail or news
form.

SYNOPSIS
========

     use News::Article;

   See below for functions available.

DESCRIPTION
===========

   An object for representing a Usenet article (or a mail message).
Primarily written for use with mail2news and/or moderation programs.

USAGE
=====

     use News::Article;

   Article exports nothing.

   A new Article object must be created with the new method.

Article Methods
---------------

new ()
new ( SOURCE [,MAXSIZE [,MAXHEADS]] )
     Use this to create a new Article object. Makes an empty article if no
     parameters are specified, otherwise reads in an article from SOURCE
     as for read.

clone ()
     Create a new Article as an exact clone of the current one.  Returns a
     ref to the new object.

envelope ( [SENDER] )
     If SENDER is specified, sets the envelope sender to the specified
     value (which will then subsequently be used if the article is mailed).
     Returns the (new or current) envelope sender in any case.

rawheaders ()
     Returns a list (or a reference to an array if in scalar context) of
     the original header lines of the article, as read from the input
     source. Terminating newlines are not included. (Continued headers are
     returned as single strings with embedded newlines.)

header_names ()
     Returns a list of the names of all headers currently present in the
     article.

headers ([FIRST [,NEXT [,LAST]]])
     Returns a list of all header strings with no terminating newlines.
     Continued headers will have embedded newlines.

     FIRST, NEXT and LAST are optional references to arrays of header
     names. The order of the returned headers is as follows:

          - headers specified by FIRST (one value only per name)
          - headers in the order originally read in (if any)
          - headers specified by NEXT (one value only per name)
          - any remaining headers not named in LAST, sorted by name
          - headers named in LAST (all values)

headers_first (HDR...)
     Set default ordering for headers().

headers_next (HDR...)
     Set default ordering for headers().

headers_last (HDR...)
     Set default ordering for headers().

set_headers ( NAME, VALUE [, NAME, VALUE [...]] )
     For each header name supplied, replace any current occurences of the
     header with the specified value(s). Each value may be a single scalar,
     or a reference to an array of values. Returns undef without completing
     the assignments if any attempt is made to supply multiple values for a
     unique header. Undef or empty values cause the header to be deleted.
     (If an array is supplied, it is not copied.)

add_headers ( NAME, VALUE [, NAME, VALUE [...]] )
     Add new header values without affecting existing ones. Each value is
     either a single scalar, or a reference to an array of values. Returns
     undef without completing if any attempt is made to supply duplicate
     values for a unique header. (If an array reference is supplied, the
     array is copied.)

drop_headers ( NAME [, NAME [...]] )
     Delete all values of the specified header(s).

header ( NAME )
     Returns a list of values for the specified header. Returns a null list
     if the header does not exist. In scalar context, returns the first
     value found or undef.

rename_header ( SRC, DEST [, ACTION] )
     Transform the name of a header without touching the value. Fails if
     the source header does not exist. Returns undef on failure, true on
     success.

     Optional ACTION (may be "drop", "clobber", "add", or "fail"
     (default)), specifies what to do if both source and destination exist:

          ACTION     PREVIOUS DEST
          drop       unchanged      (SRC dropped)
          clobber    dropped        (SRC replaces DEST)
          add        preserved      (SRC added to DEST)
          fail       unchanged      (operation fails)

body ()
     Return the body of the article as a list of lines (no newlines), or a
     reference to an array in scalar context (the array may be modified in
     this case).

lines ()
     Returns the number of lines in the article body.

bytes ()
     Returns the total size of the article body, not counting newlines.

set_body ( BODY )
     Replace the current article body with the specified text.  Expects a
     list, each item of which is either one line, or multiple lines
     separated by newlines (but with no final newline).

add_body ( BODY )
     Append the specified text to the current article body.  Expects a
     list, each item of which is either one line, or multiple lines
     separated by newlines (but with no final newline), or a reference to
     an array of lines.

read_headers ( SOURCE, MAXSIZE )
     Read article headers (terminated by an empty line) from the specified
     source (see read for defintion of allowed sources).

     Gives up (returning undef) if more than MAXSIZE bytes are read.
     Returns the amount read.

read_body ( SOURCE, MAXSIZE )
     Read an article body from the specified source (see read). Stops at
     end of file; fails (returning undef) if MAXSIZE is reached prior to
     that point.  Returns the number of bytes read (may be 0 if the body is
     null).

     Useless trailing blank lines are removed.

read ( SOURCE [,MAXSIZE [,MAXHEADS]] )
     Reads in an article from SOURCE.

     SOURCE may be any of the following:

     - a CODE ref, which is called to return lines or chunks of data

     - an ARRAY ref, assumed to contain a list of lines with optional line
     terminators

     - a SCALAR ref, assumed to contain text with embedded newlines

     - a scalar, assumed to be a filename, which is opened and read

     - anything else is assumed to be a glob, reference to a glob, or
     reference to a filehandle, and is read from accordingly

     When reading in articles, `MAXHEADS' is the maximum header size to
     read (default 8k), and `MAXSIZE' is the maximum article body size
     (default 256k). If `MAXSIZE' is explicitly specified as 0, then no
     attempt at reading the body is made. Returns the total number of bytes
     read, or undef if either limit is reached or no headers were found.

write ( FILE )
     Write the entire article to the specified filehandle reference.

write_original ( FILE )
     Write the original headers followed by the article body to the
     specified filehandle reference.

sendmail ( [COMMAND] )
     Get or set the command and options that will be used to mail the
     article. Defaults to a system dependent value such as
     /usr/sbin/sendmail -oi -oem

mail ( [RECIPIENTS...] )
     Mails the article to the specified list of recipients, or to the
     addressed recipients in the header (To, Cc, Bcc) if none are supplied.
     Attempts to set the envelope sender to the stored envelope sender, if
     set, so unset that before mailing if you do not want this behavior.

post ( [CONN] )
     Post the article. Avoids inews due to undesirable header munging and
     unwarranted complaints to stderr. Takes an optional parameter which is
     a Net::NNTP reference.  If supplied, posts the article to it;
     otherwise opens a new reader connection and posts to that.

     Throws an exception containing the error message on failure.

ihave ( [CONN] )
     Inject the article. Takes an optional parameter which is a Net::NNTP
     reference.  If supplied, posts the article to it; otherwise opens a
     new transport connection and posts to that. All required headers must
     already be present, including Path and Message-ID.

     Throws an exception containing the error message on failure.

add_message_id ( [PREFIX [, DOMAIN] ] )
     If the current article lacks a message-id, then create one.

add_date ()
     If the current article lacks a date, then add one (in local time).

sign_pgpmoose ( GROUP, PASSPHRASE [, KEYID] )
     Signs the article according to the PGPMoose spec.  We require that
     pgp be on the path to do this.  Takes a "group" which can be either a
     newsgroup or an address, a PGP password, and an optional key id and
     returns a null list on success, the PGP error output as a list on
     failure.

     If the key id is omitted, we will assume that if the group is an
     e-mail address, the key id is that address surrounded by <>, and
     otherwise the key id will be the group with a space on either side.
     This is so that one can help PGP distinguish between the keys for
     (say) mod.config and mod.config.status.  The PGP key id should be
     something like:

          Moderator of group.name <request-address@some.host>

     The article to be signed must already have all of the headers needed
     by PGPMoose (Newsgroups, From, Subject) or this will fail. Message-ID
     is added if necessary.

verify_pgpmoose ( GROUP )
     Verifies an article signature according to the PGPMoose spec.  We
     require that pgp be on the path to do this.  Takes a "group" which can
     be either a newsgroup or an address, and an optional key id.

     Looks for a X-Auth header matching the specified group or address, and
     if found, checks the validity of the signature. If successful, returns
     the signer identity (from the PGP output), otherwise returns false.

sign_control ( KEYID, PASSPHRASE [, HEADER [...] ] )
     Signs the article in the manner used for control messages.  This is
     derived from signcontrol, written by David Lawrence, but with fewer
     sanity checks since we assume people know what they're doing.  Caveat
     programmer.

     We take a key id, a PGP password, and an optional list of extra
     headers to add to the signature.  By default, Subject, Control,
     Message-ID, Date, From, and Sender are signed. Any signed header that
     isn't present in the article will be signed with an empty value. Date
     and Message-ID are automatically added if needed.

AUTHOR
======

   Written by Andrew Gierth <andrew@erlenstar.demon.co.uk>

   Thanks to Russ Allbery <rra@stanford.edu> for comments and suggestions.

COPYRIGHT
=========

   Copyright 1997 Andrew Gierth <andrew@erlenstar.demon.co.uk>

   This code may be used and/or distributed under the same terms as Perl
itself.


