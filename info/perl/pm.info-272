This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Net/Z3950/APDU,  Next: Net/Z3950/Connection,  Prev: Net/Z3950,  Up: Module List

Read-only objects representing decoded Z39.50 APDUs
***************************************************

NAME
====

   Net::Z3950::APDU - Read-only objects representing decoded Z39.50 APDUs

SYNOPSIS
========

   *You probably shouldn't be reading this!*

     package Net::Z3950::APDU::SomeSpecificSortOfAPDU;
     use Net::Z3950::APDU;
     @ISA = qw(Net::Z3950::APDU);
     @FIELDS = qw(names of APDU fields);

DESCRIPTION
===========

   This class provides a trivial base for the various read-only APDUs
implemented as a part of the Net::Z3950 module.  Its role is simply to
supply named methods providing read-only access to the same-named fields.
The set of fields is specified by the derived class's package-global
`@FIELDS' array.

   *You don't need to understand or use this class in order to use the
Net::Z3950 module.  It's purely an implementation detail.  In fact, I
probably should never even have written this documentation.  Forget I said
anything.  Go and read the next section.*

SUBCLASSES
==========

   The following classes are all trivial derivations of `Net::Z3950::APDU',
and represent specific types of APDU.  Each such class is characterised by
the set of data-access methods it supplies: these are listed below.

   Each method takes no arguments, and returns the information implied by
its name.  See the relevant sections of the Z39.50 Standard for
information on the interpretation of this information - for example,
section 3.2.1 (Initialization Facility) describes the elements of the
Net::Z3950::APDU::InitResponse class.

   *Actually, you don't need to understand or use any of these classes
either: they're used internally in the implementation, so this
documentation is provided as a service to those who will further develop
this module in the future.*

Net::Z3950::APDU::InitResponse
------------------------------

     referenceId()
     preferredMessageSize()
     maximumRecordSize()
     result()
     implementationId()
     implementationName()
     implementationVersion()

Net::Z3950::APDU::SearchResponse
--------------------------------

     referenceId()
     resultCount()
     numberOfRecordsReturned()
     nextResultSetPosition()
     searchStatus()
     resultSetStatus()
     presentStatus()
     records()

Net::Z3950::APDU::PresentResponse
---------------------------------

     referenceId()
     numberOfRecordsReturned()
     nextResultSetPosition()
     presentStatus()
     records()

Net::Z3950::APDU::NamePlusRecordList
------------------------------------

   No methods - just treat as a reference to an array of
Net::Z3950::APDU::NamePlusRecord

Net::Z3950::APDU::NamePlusRecord
--------------------------------

     databaseName()
     which()
     databaseRecord()
     surrogateDiagnostic()
     startingFragment()
     intermediateFragment()
     finalFragment()

   Only one of the last five methods will return anything - you can find
out which one by inspecting the return value of the `which()' method,
which always takes one of the following values:

   * Net::Z3950::NamePlusRecord::DatabaseRecord

   * Net::Z3950::NamePlusRecord::SurrogateDiagnostic

   * Net::Z3950::NamePlusRecord::StartingFragment

   * Net::Z3950::NamePlusRecord::IntermediateFragment

   * Net::Z3950::NamePlusRecord::FinalFragment

   When `which()' is `Net::Z3950::NamePlusRecord::DatabaseRecord', the
object returned from the `databaseRecord()' method will be a decoded
Z39.50 EXTERNAL.  Its type may be any of the following (and may be tested
using `$rec->isa('Net::Z3950::APDU::Whatever')' if necessary.)

   * Net::Z3950::Record::SUTRS (a subclass of Net::Z3950::APDU::SUTRS)

   * Net::Z3950::Record::GRS1 (a subclass of Net::Z3950::APDU::GRS1)

   * Net::Z3950::Record::USMARC (a subclass of Net::Z3950::APDU::USMARC)
     and similarly, Net::Z3950::Record::UKMARC,
     Net::Z3950::Record::NORMARC, *etc*.

     ### others, not yet supported

Net::Z3950::APDU::SUTRS, Net::Z3950::APDU::USMARC, Net::Z3950::APDU::UKMARC, Net::Z3950::APDU::NORMARC, Net::Z3950::APDU::LIBRISMARC, Net::Z3950::APDU::DANMARC
---------------------------------------------------------------------------------------------------------------------------------------------------------------

   No methods - just treat as a string.

Net::Z3950::APDU::GRS1
----------------------

   No methods - just treat as a reference to an array of
`Net::Z3950::APDU::TaggedElement'

Net::Z3950::APDU::TaggedElement;
--------------------------------

     tagType()
     tagValue()
     tagOccurrence()
     content()

Net::Z3950::APDU::ElementData
-----------------------------

     which()
     numeric()
     string()
     subtree()

   Only one of the last three methods will return anything - you can find
out which one by inspecting the return value of the `which()' method,
which always takes one of the following values:

   * Net::Z3950::ElementData::Numeric

   * Net::Z3950::ElementData::String

   * Net::Z3950::ElementData::subtree

   * ### others, not yet supported

Net::Z3950::APDU::DiagRecs
--------------------------

   No methods - just treat as a reference to an array of object
references.  The objects will typically be of class
`Net::Z3950::APDU::DefaultDiagFormat', but careful callers will check
this, since any kind of EXTERNAL may be provided instead.

Net::Z3950::APDU::DefaultDiagFormat;
------------------------------------

     diagnosticSetId()
     condition()
     addinfo()

Net::Z3950::APDU::OID
---------------------

   No methods - just treat as a reference to an array of integers.

AUTHOR
======

   Mike Taylor <mike@tecc.co.uk>

   First version Saturday 27th May 2000.


File: pm.info,  Node: Net/Z3950/Connection,  Next: Net/Z3950/Manager,  Prev: Net/Z3950/APDU,  Up: Module List

Connection to a Z39.50 server, with request queue
*************************************************

NAME
====

   Net::Z3950::Connection - Connection to a Z39.50 server, with request
queue

SYNOPSIS
========

     $conn = new Net::Z3950::Connection($hostname, $port);
     $rs = $conn->search('au=kernighan and su=unix');
     # or
     $mgr = $conn->manager();
     $conn = $mgr->wait();
     if ($mgr->failed()) {
     	die "error " . $conn->errcode() .
     		"( " . $conn->addinfo() . ")" .
     		" in " . Net::Z3950::opstr($conn->errop());
     }

DESCRIPTION
===========

   A connection object represents an established connection to a
particular server on a particular port, together with options such as the
default database in which to search.  It maintains a queue of outstanding
requests (searches executed against it, fetches executed against result
sets instantiated against it) etc.

METHODS
=======

new()
-----

     $conn = new Net::Z3950::Connection($mgr, $host, $port);

   Creates and returns a new connection, under the control of the manager
*$mgr*, to the server on the specified $host and $port.  If the $port
argument is omitted, the `z3950' service is used; if this is not defined,
port 210 is used.

   The manager argument may be undef, or may be omitted completely; in
either case, the connection is created under the control of a "default
manager", a reference to which may be subsequently retrieved with the
manager() method.  Multiple connections made with no explicitly-specified
manager in this way will all share the same implicit manager.  The default
manager is initially in synchronous mode.

   If the connection is created in synchronous mode, (or, if the
constructor call doesn't specify a mode, if the manager controlling the
new connection is synchronous), then the constructor does not return until
either the connection is forged or an error occurs in trying to do so.
(In the latter case, error information is stored in the manager
structure.)  If the connection is asynchronous, then the new object is
created and returned before the connection is forged; this will happen in
parallel with subsequent actions.

   Any of the standard options (including synchronous or asynchronous
mode) may be specified as additional arguments.  Specifically:

     $conn = new Net::Z3950::Connection($mgr, $host, $port, mode => 'async');

   Works as expected.

option()
--------

     $value = $conn->option($type);
     $value = $conn->option($type, $newval);

   Returns *$conn*'s value of the standard option $type, as registered in
*$conn* itself, in the manager which controls it, or in the global
defaults.

   If *$newval* is specified, then it is set as the new value of that
option in *$conn*, and the option's old value is returned.

manager()
---------

     $mgr = $conn->manager();

   Returns a reference to the manager controlling *$conn*.  If *$conn* was
created with an explicit manager, then this method will always return that
function; otherwise, it returns a reference to the single global "default
manager" shared by all other connections.

startSearch()
-------------

     $conn->startSearch($srch);
     $conn->startSearch(-ccl => 'au=kernighan and su=unix');
     $conn->startSearch(-prefix => '@and @attr 1=1 kernighan @attr 1=21 unix');
     $conn->startSearch('@and @attr 1=1 kernighan @attr 1=21 unix');

   Inititiates a new search against the Z39.50 server to which *$conn* is
connected.  Since this can never fail (:-), it `die()s' if anything goes
wrong.  But that will never happen.  ("Surely the odds of that happening
are million to one, doctor?")

   The query itself can be specified in a variety of ways:

   * A `Net::Z3950::Query' object may be passed in.

   * A query-type option may be passed in, together with the query string
     itself as its argument.  Currently recognised query types are `-ccl'
     (using the standard CCL query syntax, interpreted by the server),
     `-ccl2rpn' (CCL query compiled by the client into a type-1 query) and
     `-prefix' (using Index Data's prefix query notation).

   * A query string alone may be passed in.  In this case, it is
     interpreted according to the query type previously established as a
     default for *$conn* or its manager.

   The various query types are described in more detail in the
documentation of the `Net::Z3950::Query' class.

search()
--------

     $rs = $conn->search($srch);

   This utility method performs a blocking search, returning a reference
to the result set generated by the server.  It takes the same arguments as
startSearch()

op()
----

     op = $conn->op();
     if (op == Net::Z3950::Op::Search) { # ...

   When a connection has been returned from the `Net::Z3950::Manager'
class's wait() method, it's known that *something* has happened to it.
This method may then be called to find out what.  It returns one of the
following values:

`Net::Z3950::Op::Error'
     An error occurred.  The details may be obtained via the `errcode()',
     `addinfo()' and `errop()' methods described below.

`Net::Z3950::Op::Init'
     An init response was received.  The response object may be obtained
     via the initResponse() method described below.

`Net::Z3950::Op::Search'
     A search response was received.  The result set may be obtained via
     the `resultSet()' method described below.

`Net::Z3950::Op::Get'
     One or more result-set records have become available.  They may be
     obtained via the records() method described below.

errcode(), addinfo(), errop()
-----------------------------

     if ($conn->op() == Net::Z3950::Op::Error) {
     	print "error number: ", $conn->errcode(), "\n";
     	print "error message: ", $conn->errmsg(), "\n";
     	print "additional info: ", $conn->errcode(), "\n";
     	print "in function: ", Net::Z3950::opstr($conn->errop()), "\n";
     }

   When an error is known to have occurred on a connection, the error code
(from the BIB-1 diagnosic set) can be retrieved via the `errcode()'
method, any additional information via the `addinfo()' method, and the
operation that was being attempted when the error occurred via the
`errop()' method.  (The error operation returned takes one of the values
that may be returned from the op() method.)

   As a convenience, `$conn-'errmsg()> is equivalent to
`Net::Z3950::diagbib1_str($conn-'errcode())>.

initResponse()
--------------

     if ($op == Net::Z3950::Op::Init) {
     	$rs = $conn->initResponse();

   When a connection is known to have received an init response, the
response may be accessed via the connection's initResponse() method.

searchResponse(), resultSet()
-----------------------------

     if ($op == Net::Z3950::Op::Search) {
     	$sr = $conn->searchResponse();
     	$rs = $conn->resultSet();

   When a connection is known to have received a search response, the
response may be accessed via the connection's `searchResponse()', and the
search result may be accessed via the connection's `resultSet()' method.

resultSets()
------------

     @rs = $conn->resultSets();

   Returns a list of all the result sets that have been created across the
connection *$conn* and have not subsequently been deleted.

records()
---------

     if ($op == Net::Z3950::Op::Get) {
     	@recs = $conn->records();

   When a connection is known to have some result-set records available,
they may be accessed via the connection's records() method, which returns
an array of zero or more `Net::Z3950::Record' references.

   Zero records are only returned if there are no more records on the
server satisfying the get() requests that have been made on the
appropriate result set associated with *$conn*.

   *### What happens if the client issues several sets of get requests on
the same result set, and those requests can only be satisfied by repeated
PRESENT requests?  This is unclear, and suggests that the interface needs
rethinking.  Perhaps we need a method to return a reference to a
particular result set for which records have arrived?  Watch this space
...*

AUTHOR
======

   Mike Taylor <mike@tecc.co.uk>

   First version Tuesday 23rd May 2000.

SEE ALSO
========

   `Net::Z3950::Query'


File: pm.info,  Node: Net/Z3950/Manager,  Next: Net/Z3950/Record,  Prev: Net/Z3950/Connection,  Up: Module List

State manager for multiple Z39.50 connections.
**********************************************

NAME
====

   Net::Z3950::Manager - State manager for multiple Z39.50 connections.

SYNOPSIS
========

     $mgr = new Net::Z3950::Manager(mode => 'async');
     $conn = $mgr->connect($hostname, $port);
     # Set up some more connections, then:
     while ($conn = $mgr->wait()) {
     	# Handle message on $conn
     }

DESCRIPTION
===========

   A manager object encapsulates the Net::Z3950 module's global state -
preferences for search parsing, preferred record syntaxes, compiled
configuration files, etc. - as well as a list of references to all the
open connections.  It main role is to handle multiplexing between the
connections that are opened on it.

   We would normally expect there to be just one manager object in a
program, but I suppose there's no reason why you shouldn't make more if
you want.

   Simple programs - those which therefore have no requirement for
multiplexing, perhaps because they connect only to a single server - do
not need explicitly to create a manager at all: an anonymous manager is
implicitly created along with the connection.

METHODS
=======

new()
-----

     $mgr = new Net::Z3950::Manager();

   Creates and returns a new manager.  Any of the standard options may be
specified as arguments; in addition, the following manager-specific
options are recognised:

mode
     Must be either sync or async; if omitted, defaults to sync.  The mode
     affects various details of subsequent behaviour - for example, see
     the description of the `Net::Z3950::Connection' class's new() method.

option()
--------

     $value = $mgr->option($type);
     $value = $mgr->option($type, $newval);

   Returns *$mgr*'s value of the standard option $type, as registered in
*$mgr* or in the global defaults.

   If *$newval* is specified, then it is set as the new value of that
option in *$mgr*, and the option's old value is returned.

connect()
---------

     $conn = $mgr->connect($hostname, $port);

   Creates a new connection under the control of the manager *$mgr*.  The
connection will be forged to the server on the specified $port of
<$hostname>.

   Additional standard options may be specified after the $port argument.

   (This is simply a sugar function to `Net::Z3950::Connection-'new()>)

wait()
------

     $conn = $mgr->wait();

   Waits for an event to occur on one of the connections under the control
of *$mgr*, yielding control to any other event handlers that may have been
registered with the underlying event loop.

   When a suitable event occurs - typically, a response is received to an
earlier INIT, SEARCH or PRESENT - the handle of the connection on which it
occurred is returned: the handle can be further interrogated with its op()
and related methods.

connections()
-------------

     @conn = $mgr->connections();

   Returns a list of all the connections that have been opened under the
control of the manager *$mgr* and have not subsequently been closed.

resultSets()
------------

     @rs = $mgr->resultSets();

   Returns a list of all the result sets that have been created across the
connections associated with the manager *$mgr* and have not subsequently
been deleted.

AUTHOR
======

   Mike Taylor <mike@tecc.co.uk>

   First version Tuesday 23rd May 2000.

SEE ALSO
========

   List of standard options.

   Discussion of the Net::Z3950 module's use of the Event module.


File: pm.info,  Node: Net/Z3950/Record,  Next: Net/Z3950/ResultSet,  Prev: Net/Z3950/Manager,  Up: Module List

base class for records retrieved from a Z39.50 server
*****************************************************

NAME
====

   Net::Z3950::Record - base class for records retrieved from a Z39.50
server

SYNOPSIS
========

     $rs = $conn->resultSet();
     $rec = $rs->record($n);
     print $rec->render();

DESCRIPTION
===========

   A Record object represents a record retrieved from a Z39.50 server.  In
fact, the `Net::Z3950::Record' class itself is never instantiated:
instead, the Net::Z3950 module creates objects of subclasses such as
Net::Z3950::Record::SUTRS, Net::Z3950::Record::GRS1 and
`Net::Z3950::Record::USMARC'.  This class defines a common interface which
must be supported by all such subclasses.

METHODS
=======

nfields()
---------

     $count = $rec->nfields();

   Returns the number of fields in the record *$rec*.

render()
--------

     print $rec->render();

   Returns a human-readable string representing the content of the record
*$rec* in a form appropriate to its specific type.

rawdata()
---------

     $raw = $rec->rawdata();

   Returns the raw form of the data in the record, which will in general
be different in form for different record syntaxes.

SUBCLASSES
==========

Net::Z3950::Record::SUTRS
-------------------------

   Represents a a record using the Simple Unstructured Text Record Syntax
(SUTRS) - a simple flat string containing the record's data in a form
suitable for presentation to humans (so that the same thing is returned by
the render() and rawdata() methods return the same thing.)

   See Appendix REC.2 (Simple Unstructured Text Record Syntax) of the
Z39.50 Standard for more information.

Net::Z3950::Record::GRS1
------------------------

   Represents a record using Generic Record Syntax 1 (GRS1) - a list of
tagged fields where each tag is made up of a tag type and tag value, and
each field may be of any type, including numeric, string, and recursively
contained sub-record.  Fields may also be annotated with metadata, variant
information etc.

   See Appendix REC.5 (Generic Record Syntax 1) of the Z39.50 Standard for
more information.

Net::Z3950::Record::USMARC, Net::Z3950::Record::UKMARC, Net::Z3950::Record::NORMARC, Net::Z3950::Record::LIBRISMARC, Net::Z3950::Record::DANMARC
------------------------------------------------------------------------------------------------------------------------------------------------

   Represents a record using the appropriate MARC (MAchine Readable
Catalogue) format - binary formats used extensively in libraries.

   For further information on the MARC formats, see the Library of
Congress Network Development and MARC Standards Office web page at
http://lcweb.loc.gov/marc/ and the MARC module in Ed Summers's directory
at CPAN, http://cpan.valueclick.com/authors/id/E/ES/ESUMMERS/

### others, not yet supported
-----------------------------

AUTHOR
======

   Mike Taylor <mike@tecc.co.uk>

   First version Sunday 4th May 2000.


File: pm.info,  Node: Net/Z3950/ResultSet,  Next: Net/Z3950/Tutorial,  Prev: Net/Z3950/Record,  Up: Module List

result set received in response to a Z39.50 search
**************************************************

NAME
====

   Net::Z3950::ResultSet - result set received in response to a Z39.50
search

SYNOPSIS
========

     if ($conn->op() == Net::Z3950::Op::Search) {
     	$rs = $conn->resultSet();
     	$size = $rs->size();

DESCRIPTION
===========

   A ResultSet object represents the set of records found by a Z39.50
server in response to a search.  At any given time, none, some or all of
the records may have been physcially transferred to the client; a cache is
maintained.

   Note that there is no constructor for this class (or at least, none
that I'm going to tell you about :-)  ResultSet objects are always created
by the Net::Z3950 module itself, and are returned to the caller via the
`Net::Z3950::Connection' class's `resultSet()' method.

METHODS
=======

size()
------

     $nrecords = $rs->size();

   Returns the number of records in the result set *$rs*

record()
--------

     $rec = $rs->record($n);

   Returns a reference to $nth record in the result set *$rs*, if the
content of that record is known.  Valid values of $n range from 1 to the
return value of the size() method.

   If the record is not available, an undefined value is returned, and
diagnostic information made available via *$rs*'s `errcode()' and
`addinfo()' methods.

   As a special case, when the connection is anychronous, the `errcode()'
may be zero, indicating simply that the record has not yet been fetched
from the server.  In this case, the calling code should try again later.
(How much later?  As a rule of thumb, after it's done "something else",
such as request another record or issue another search.)  This can never
happen in synchronous mode.

records()
---------

     @records = $rs->records();
     foreach $rec (@records) {
         print $rec->render();
     }

   This utility method returns a list of all the records in the result set
I$<rs>.  Because Perl arrays are indexed from zero, the first record is
`$records[0]', the second is `$records[1]', etc.

   If not all the records associated with *$rs* have yet been transferred
from the server, then they need to be transferred at this point.  This
means that the records() method may block, and so is not recommended for
use in applications that interact with multiple servers simultaneously.
It does also have the side-effect that subsequent invocations of the
record() method will always immediately return either a legitimate record
or a "real error" rather than a "not yet" indicator.

   If an error occurs, an empty list is returned.  Since this is also
what's returned when the search had zero hits, well-behaved applications
will consult `$rs-'size()> in these circumstances to determine which of
these two conditions pertains.  After an error has occurred, details may
be obtained via the result set's `errcode()' and `addinfo()' methods.

   If a non-empty list is returned, then individual elements of that list
may still be undefined, indicating that corresponding record could not be
fetched.  In order to get more information, it's necessary to attempt to
fetch the record using the record() method, then consult the `errcode()'
and `addinfo()' methods.

   *Unwarranted personal opinion*: all in all, this method is a pleasant
short-cut for trivial programs to use, but probably carries too many
caveats to be used extensively in serious applications.

errcode(), addinfo()
--------------------

     if (!defined $rs->record($n)) {
     	print "error number: ", $rs->errcode(), "\n";
     	print "additional info: ", $rs->errcode(), "\n";
     }

   When a result set's record() method returns an undefined value,
indicating an error, it also sets into the result set the BIB-1 error code
and additional information returned by the server.  They can be retrieved
via the `errcode()' and `addinfo()' methods.

option()
--------

     $value = $rs->option($type);
     $value = $rs->option($type, $newval);

   Returns *$rs*'s value of the standard option $type, as registered in
*$rs* itself, in the connection across which it was created, in the
manager which controls that connection, or in the global defaults.

   If *$newval* is specified, then it is set as the new value of that
option in *$rs*, and the option's old value is returned.

AUTHOR
======

   Mike Taylor <mike@tecc.co.uk>

   First version Sunday 28th May 2000.


File: pm.info,  Node: Net/Z3950/Tutorial,  Next: Net/hostent,  Prev: Net/Z3950/ResultSet,  Up: Module List

tutorial for the Net::Z3950 module
**********************************

NAME
====

   Net::Z3950::Tutorial - tutorial for the Net::Z3950 module

SYNOPSIS
========

   Apparently, every POD document has to have a SYNOPSIS.  So here's one.

DESCRIPTION
===========

   `Net::Z3950' is a Perl module for writing Z39.50 clients.  (If you want
to write a Z39.50 server, you want the `Net::Z3950::SimpleServer' module.)

   Its goal is to hide all the messy details of the Z39.50 protocol - at
least by default - while providing access to all of its glorious power.
Sometimes, this involves revealing the messy details after all, but at
least this is the programmer's choice.  The result is that writing Z39.50
clients works the way it should according my favourite of the various Perl
mottos: "Simple things should be simple, and difficult things should be
possible."

   If you don't know what Z39.50 is, then the best place to find out is at
http://lcweb.loc.gov/z3950/agency/ the web site of the Z39.50 Maintenance
Agency.  Among its many other delights, this site contains a complete
downloadable soft-copy of the standard itself.  In briefest summary,
Z39.50 is the international standard for distributed searching and
retrieval.

A VERY SIMPLE CLIENT
====================

   The `Net::Z3950' distribution includes a couple of sample clients in
the `samples' directory.  The simplest of them, `trivial.pl' reads as
follows:

     use Net::Z3950;
     $conn = new Net::Z3950::Connection('indexdata.dk', 210,
     				   databaseName => 'gils');
     $rs = $conn->search('mineral');
     print "found ", $rs->size(), " records:\n";
     my $rec = $rs->record(1);
     print $rec->render();

   This complete program retrieves from the database called "gils" on the
Z39.50 server on port 210 of `indexdata.dk' the first record matching the
search "mineral", and renders it in human-readable form.  Typical output
would look like this:

     6 fields:
     (1,1) 1.2.840.10003.13.2
     (1,14) "2"
     (2,1) {
         (1,19) "UTAH EARTHQUAKE EPICENTERS"
         (3,Acronym) "UUCCSEIS"
     }
     (4,52) "UTAH GEOLOGICAL AND MINERAL SURVEY"
     (4,1) "ESDD0006"
     (1,16) "198903"

HOW IT WORKS
============

   Let's pick the trivial client apart line by line (it won't take long!)

     use Net::Z3950;

   This line simply tells Perl to pull in the `Net::Z3950' module - a
prerequisite for using types like `Net::Z3950::Connection'.

     $conn = new Net::Z3950::Connection('indexdata.dk', 210,
     				   databaseName => 'gils');

   Creates a new connection to the Z39.50 server on port 210 of the host
`indexdata.dk', noting that searches on this connection will default to
the database called "gils".  A reference to the new connection is stored
in `$conn'.

     $rs = $conn->search('mineral');

   Performs a single-word search on the connection referenced by `$conn'
(in the previously established default database, "gils".)  In response,
the server generates an *result set*, notionally containing all the
matching records; a reference to the new connection is stored in `$rs'.

     print "found ", $rs->size(), " records:\n";

   Prints the number of records in the new result set `$rs'.

     my $rec = $rs->record(1);

   Fetches from the server the first record in the result set `$rs',
requesting the default record syntax (GRS-1) and the default element set
(brief, "b"); a reference to the newly retrieved record is stored in
`$rec'.

     print $rec->render();

   Prints a human-readable rendition of the record `$rec'.  The exact
format of the rendition is dependent on issues like the record syntax of
the record that the server sent.

MORE COMPLEX BEHAVIOUR
======================

Searching
---------

   Searches may be specified in one of two different syntaxes, both of
which will be familiar to users of the Yaz toolkit.  The default syntax is
so-called Prefix Query Notation, or PQN, a bespoke format invented by
Index Data to map simply to the Z39.50 type-1 query structure.  The other
is the Common Command Language, or CCL, an international standard query
language often used in libraries.

   CCL queries may be interpreted on the client side and translated into a
type-1 query which is forwarded to the server; or it may be sent "as is"
for the server to interpret as it may.

   The interpretation of the search string may be specified by passing an
argument of `-prefix', `-ccl' or `-ccl2rpn' to the search() method before
the search string itself, as follows:

   *Prefix Queries*

     $rs = $conn->search(-prefix => '@or rock @attr 1=21 mineral');

   Prefix Query Notation is fully described in section 4.1 (*Query Syntax
Parsers*) of the Yaz toolkit documentation, *YAZ User's Guide and
Reference*.

   Briefly, however, keywords begin with an `@'-sign, and all other words
are interpreted as search terms.  Keywords include the binary operators
`@and' and `@or', which join together the two operands that follow them,
and `@attr', which introduces a type=value expression specifying an
attribute to be applied to the following term.

   So:

   * `fruit' searches for the term "fruit",

   * `@and fruit fish' searches for records containing both "fruit" and
     "fish",

   * `@or fish chicken' searches for records containing either "fish" or
     "chicken" (or both),

   * `@and fruit @or fish chicken' searches for records containing both
     "fruit" and at least one of "fish" or "chicken".

   * `@or rock @attr 1=21 mineral' searches for records either containing
     "rock" or "mineral", but with the "mineral" search term carrying an
     attribute of type 1, with value 21 (typically interpreted to mean
     that the search term must occur in the "subject" field of the record.)

   *CCL Queries*

     $rs = $conn->search(-ccl2rpn => 'rock or su=mineral');
     $rs = $conn->search(-ccl => 'rock or su=mineral');

   CCL is formally specified in the international standard ISO 8777
(*Commands for interactive text searching*) and also described in section
4.1 (*Query Syntax Parsers*) of the Yaz toolkit documentation, *YAZ User's
Guide and Reference*.

   Briefly, however, there is a set of well-known keywords including and,
or and not.  Words other than these are interpreted as search terms.
Operating grouping (precedence) is specified by parentheses, and the
semantics of a search term may be modified by prepending one or more
comma-separated qualifiers qualifiers and an equals sign.

   So:

   * `fruit' searches for the term "fruit",

   * `fruit and fish' searches for records containing both "fruit" and
     "fish",

   * `fish or chicken' searches for records containing either "fish" or
     "chicken" (or both),

   * `fruit and (fish or chicken)' searches for records containing both
     "fruit" and at least one of "fish" or "chicken".

   * `rock or su=mineral' searches for records either containing "rock" or
     "mineral", but with the "mineral" search term modified by the
     qualifier "su" (typically interpreted to mean that the search term
     must occur in the "subject" field of the record.)

   For CCL searches sent directly to the server (query type `ccl'), the
exact interpretation of the qualifiers is the server's responsibility.
For searches compiled on the client side (query side `ccl2rpn') the
interpretation of the qualifiers in terms of type-1 attributes is
determined by the contents of a file called *### not yet implemented*.
The format of this file is described in the Yaz documentation.

   *Setting Search Defaults*

   As an alternative to explicitly specifying the query type when invoking
the search() method, you can change the connection's default query type
using its option() method:

     $conn->option(querytype => 'prefix');
     $conn->option(querytype => 'ccl');
     $conn->option(querytype => 'ccl2rpn');

   The connection's current default query type can be retrieved using
option() with no "value" argument:

     $qt = $conn->option('querytype');

   The option() method can be used to set and get numerous other defaults
described in this document and elsewhere; this method exists not only on
connections but also on managers (q.v.) and result sets.

   Another important option is `databaseName', whose value specifies which
database is to be searched.

Retrieval
---------

   *Element Set*

   The default element set is "b" (brief).  To change this, set the result
set's `elementSetName' option:

     $rs->option(elementSetName => "f");

   *Record Syntax*

   The default record syntax preferred by the `Net::Z3950' module is GRS-1
(the One True Record syntax).  If, however, you need to ask the server for
a record using a different record syntax, then the way to do this is to
set the `preferredRecordSyntax' option of the result set from which the
record is to be fetched:

     $rs->option(preferredRecordSyntax =>
                 Net::Z3950::RecordSyntax::SUTRS);

   The record syntaxes which may be requested are listed in the
`Net::Z3950::RecordSyntax' enumeration in the file `Net/Z3950.pm'; they
include `Net::Z3950::RecordSyntax::GRS1', `Net::Z3950::RecordSyntax::SUTRS'
and `Net::Z3950::RecordSyntax::USMARC'.

   (As always, option() may also be invoked with no "value" parameter to
return the current value of the option.)

WHAT TO DO WITH YOUR RECORDS
============================

   Once you've retrieved a record, what can you do with it?

   There are two broad approaches.  One is just to display it to the user:
this can always be done with the render() method, as used in the sample
code above, whatever the record syntax of the record.

   The more sophisticated approach is to perform appropriate analysis and
manipulation of the raw record according to the record syntax.  The raw
data is retrieved using the rawdata() method, and the record syntax can be
determined using the universal isa() method:

     $raw = $rec->rawdata();
     if ($rec->isa('Net::Z3950::Record::GRS1')) {
     	process_grs1_record($raw);
     elsif ($rec->isa('Net::Z3950::Record::USMARC')) {
     	process_marc_record($raw);
     } # etc.

   For further manipulation of MARC records, we recommend the existing
MARC module in Ed Summers's directory at CPAN,
http://cpan.valueclick.com/authors/id/E/ES/ESUMMERS/

   The raw data of GRS-1 records in the `Net::Z3950' module closely
follows the structure of physcial GRS-1 records - see Appendices REC.5
(*Generic Record Syntax 1*), TAG (*TagSet Definitions and Schemas*) and
RET (*Z39.50 Retrieval*) of the standard more details.

   The raw GRS-1 data is intended to be more or less self-describing, but
here is a summary.

   * The raw data is a reference to an array of elements, each representing
     one of the fields of the record.

   * Each element is a `Net::Z3950::APDU::TaggedElement' object.  These
     objects support the accessor methods `tagType()', `tagValue()',
     `tagOccurrence()' and `content()'; the first three of these return
     numeric values, or strings in the less common case of string
     tag-values.

   * The content of an element is an object of one of the subtypes of
     `Net::Z3950::ElementData'.  These include
     `Net::Z3950::ElementData::Numeric' and
     `Net::Z3950::ElementData::String' (both self-explanatory), and
     `Net::Z3950::ElementData::OID' (a reference to an array of integers).
     The fourth, and more interesting content-type is
     `Net::Z3950::ElementData::Subtree' - a reference to another whole
     Net::Z3950::Record::GRS1, enabling arbitrary recursive nesting.

   In the future, we plan to take you away from all this by introducing a
`Net::Z3950::Data' module which provides a DOM-like interface for walking
hierarchically structured records independently of their record syntax.
Keep watchin', kids!

CHANGING SESSION PARAMETERS
===========================

   As with customising searching or retrieval behaviour, whole-session
behaviour is customised by setting options.  However, this needs to be
done before the session is created, because the Z39.50 protocol doesn't
provide a method for changing (for example) the preferred message size of
an existing connection.

   In the `Net::Z3950' module, this is done by creating a manager - a
controller for one or more connections.  Then the manager's options can be
set; then connections which are opened through the manager use the
specified values for those options.

   As a matter of fact, every connection is made through a manager.  If
one is not specified in the connection constructor, then the "default
manager" is used; it's automatically created the first time it's needed,
then re-used for any other connections that need it.

Make or Find a Manager
----------------------

   A new manager is created as follows:

     $mgr = new Net::Z3950::Manager();

   Once the manager exists, a new connection can be made through it by
specifying the manager reference as the first option to the connection
constructor:

     $conn = new Net::Z3950::Connection($mgr, 'indexdata.dk', 210);

   Or equivalently,

     $conn = $mgr->connect('indexdata.dk', 210);

   In order to retrieve the manager through which a connection was made,
whether it was the implicit default manager or not, use the manager()
method:

     $mgr = $conn->manager();

Set the Parameters
------------------

   There are two ways to set parameters.  One we have already seen: the
option() method can be used to get and set option values for managers just
as it can for connections and result sets:

     $pms = $mgr->option('preferredMessageSize');
     $mgr->option(preferredMessageSize => $pms*2);

   Alternatively, options may be passed to the manager constructor when
the manager is first created:

     $mgr = new Net::Z3950::Manager(
     	preferredMessageSize => 100*1024,
     	maximumRecordSize => 10*1024*1024,
     	preferredRecordSyntax => Net::Z3950::RecordSyntax::GRS1);

   This is *exactly* equivalent to creating a "vanilla" manager with `new
Net::Z3950::Manager()', then setting the three options with the option()
method.

   *Message Size Parameters*

   The `preferredMessageSize' and `maximumRecordSize' parameters can be
used to specify values of the corresponding parameters which are proposed
to the server at initialisation time (although the server is not bound to
honour them.)  See sections 3.2.1.1.4 (*Preferred-message-size and
Exceptional-message-size*) and 3.3 (*Message/Record Size and
Segmentation*) of the Z39.50 standard itself for details.

   Both options default to one megabyte.

   *Implementation Identification*

   The `implementationId', `implementationName' and
`implementationVersion' options can be used to control the corresponding
parameters in initialisation request sent to the server to identify the
client.  The default values are listed below in the section OPTION
INHERITANCE.

   Authentication

   The user, password and `groupid' options can be specified for a manager
so that they are passed as identification tokens at initialisation time to
any connections opened through that manager.  The three options are
interpreted as follows:

   * If user is not specified, then authentication is omitted (which is
     more or less the same as "anonymous" authentication).

   * If user is specified but not password, then the value of the user
     option is passed as an "open" authentication token.

   * If both user and password are specified, then their values are passed
     in an "idPass" authentication structure, together with the value of
     group if is it specified.

   By default, all three options are undefined, so no authentication is
used.

OPTION INHERITANCE
==================

   The values of options are inherited from managers to connections,
result sets and finally to records.

   This means that when a record is asked for an option value (whether by
an application invoking its option() method, or by code inside the module
that needs to know how to behave), that value is looked for first in the
record's own table of options; then, if it's not specified there, in the
options of the result set from which the record was retrieved; then if
it's not specified there, in those of the connection across which the
result set was found; and finally, if not specified there either, in the
options for the manager through which the connection was created.

   Similarly, option values requested from a result set are looked up (if
not specified in the result set itself) in the connection, then the
manager; and values requested from a connection fall back to its manager.

   This is why it made sense in an earlier example (see the section *Set
the Parameters*) to specify a value for the `preferredRecordSyntax' option
when creating a manager: the result of this is that, unless overridden, it
will be the preferred record syntax when any record is retrieved from any
result set retrieved from any connection created through that manager.  In
effect, it establishes a global default.  Alternatively, one might specify
different defaults on two different connections.

   In all cases, if the manager doesn't have a value for the requested
option, then a hard-wired default is used.  The defaults are as follows.
(Please excuse the execrable formatting - that's what pod2html does, and
there's no sensible way around it.)

mode
     `'sync'' (Determines whether a given connection is in synchronous or
     asynchronous mode.)

`preferredMessageSize'
     `1024*1024'

`maximumRecordSize'
     `1024*1024'

user
     undef

password
     undef

`groupid'
     undef

`implementationId'
     `'Mike Taylor (id=169)''

`implementationName'
     `'Net::Z3950.pm (Perl)''

`implementationVersion'
     `$Net::Z3950::VERSION'

`querytype'
     `'prefix''

`databaseName'
     `'Default''

`smallSetUpperBound'
     0 (This and the next four options provide flexible control for
     run-time details such as what record syntax to use when returning
     records.  See sections 3.2.2.1.4 (*Small-set-element-set-names and
     Medium-set-element-set-names*) and 3.2.2.1.6 (*Small-set-upper-bound,
     Large-set-lower-bound, and Medium-set-present-number*) of the Z39.50
     standard itself for details.)

`largeSetLowerBound'
     1

`mediumSetPresentNumber'
     0

`smallSetElementSetName'
     'f'

`mediumSetElementSetName'
     'b'

`preferredRecordSyntax'
     `Net::Z3950::RecordSyntax::GRS1'

`elementSetName'
     'b'

   Any other option's value is undefined.

ASYNCHRONOUS MODE
=================

   I don't propose to discuss this at the moment, since I think it's more
important to get the Tutorial out there with the synchronous stuff in
place than to write the asynchronous stuff.  I'll do it soon, honest.

   *### Note to self - write this section!*

NOW WHAT?
=========

   This tutorial is only an overview of what can be done with the
`Net::Z3950' module.  If you need more information that it provides, then
you need to read the more technical documentation on the individual
classes that make up the module - `Net::Z3950' itself,
`Net::Z3950::Manager', `Net::Z3950::Connection', `Net::Z3950::ResultSet'
and `Net::Z3950::Record'.

AUTHOR
======

   Mike Taylor <mike@tecc.co.uk>

   First version Sunday 28th January 2001.


File: pm.info,  Node: Net/hostent,  Next: Net/libnetFAQ,  Prev: Net/Z3950/Tutorial,  Up: Module List

by-name interface to Perl's built-in gethost*() functions
*********************************************************

NAME
====

   Net::hostent - by-name interface to Perl's built-in gethost*() functions

SYNOPSIS
========

     use Net::hostnet;

DESCRIPTION
===========

   This module's default exports override the core gethostbyname() and
gethostbyaddr() functions, replacing them with versions that return
"Net::hostent" objects.  This object has methods that return the similarly
named structure field name from the C's hostent structure from `netdb.h';
namely name, aliases, addrtype, length, and addr_list.  The aliases and
addr_list methods return array reference, the rest scalars.  The addr
method is equivalent to the zeroth element in the addr_list array
reference.

   You may also import all the structure fields directly into your
namespace as regular variables using the :FIELDS import tag.  (Note that
this still overrides your core functions.)  Access these fields as
variables named with a preceding `h_'.  Thus, `$host_obj->name()'
corresponds to $h_name if you import the fields.  Array references are
available as regular array variables, so for example `@{
$host_obj->aliases() }' would be simply @h_aliases.

   The gethost() function is a simple front-end that forwards a numeric
argument to gethostbyaddr() by way of Socket::inet_aton, and the rest to
gethostbyname().

   To access this functionality without the core overrides, pass the use
an empty import list, and then access function functions with their full
qualified names.  On the other hand, the built-ins are still available via
the `CORE::' pseudo-package.

EXAMPLES
========

     use Net::hostent;
     use Socket;

     @ARGV = ('netscape.com') unless @ARGV;

     for $host ( @ARGV ) {

     unless ($h = gethost($host)) {
     	warn "$0: no such host: $host\n";
     	next;
     }

     printf "\n%s is %s%s\n",
     	    $host,
     	    lc($h->name) eq lc($host) ? "" : "*really* ",
     	    $h->name;

     print "\taliases are ", join(", ", @{$h->aliases}), "\n"
     		if @{$h->aliases};

     if ( @{$h->addr_list} > 1 ) {
     	my $i;
     	for $addr ( @{$h->addr_list} ) {
     	    printf "\taddr #%d is [%s]\n", $i++, inet_ntoa($addr);
     	}
     } else {
     	printf "\taddress is [%s]\n", inet_ntoa($h->addr);
     }

     if ($h = gethostbyaddr($h->addr)) {
     	if (lc($h->name) ne lc($host)) {
     	    printf "\tThat addr reverses to host %s!\n", $h->name;
     	    $host = $h->name;
     	    redo;
     	}
     }
      }

NOTE
====

   While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

AUTHOR
======

   Tom Christiansen


File: pm.info,  Node: Net/libnetFAQ,  Next: Net/netent,  Prev: Net/hostent,  Up: Module List

libnet Frequently Asked Questions
*********************************

NAME
====

   libnetFAQ - libnet Frequently Asked Questions

DESCRIPTION
===========

Where to get this document
--------------------------

   This document is distributed with the libnet disribution, and is also
avaliable on the libnet web page at

     http://www.pobox.com/~gbarr/libnet/

How to contribute to this document
----------------------------------

   You may mail corrections, additions, and suggestions to me
gbarr@pobox.com.

Author and Copyright Information
================================

   Copyright (c) 1997-1998 Graham Barr. All rights reserved.  This
document is free; you can redistribute it and/or modify it under the terms
of the Artistic Licence.

Disclaimer
----------

   This information is offered in good faith and in the hope that it may
be of use, but is not guaranteed to be correct, up to date, or suitable
for any particular purpose whatsoever.  The authors accept no liability in
respect of this information or its use.

Obtaining and installing libnet
===============================

What is libnet ?
----------------

   libnet is a collection of perl5 modules which all related to network
programming. The majority of the modules avaliable provided the client
side of popular server-client protocols that are used in the internet
community.

Which version of perl do I need ?
---------------------------------

   libnet has been know to work with versions of perl from 5.002 onwards.
However if your release of perl is prior to perl5.004 then you will need to
obtain and install the IO distribution from CPAN. If you have perl5.004 or
later then you will have the IO modules in your installation already, but
CPAN may contain updates.

What other modules do I need ?
------------------------------

   The only modules you will need installed are the modules from the IO
distribution. If you have perl5.004 or later you will already have these
modules.

What machines support libnet ?
------------------------------

   libnet itself is an entirly perl-code distribution so it should work on
any machine that perl runs on. However IO may not work with some machines
and earlier releases of perl. But this should not be the case with perl
version 5.004 or later.

Where can I get the latest libnet release
-----------------------------------------

   The latest libnet release is always on CPAN, you will find it in

     http://www.perl.com/CPAN/modules/by-module/Net/
     
     The latest release and information is also avaliable on the libnet web page
     at

     http://www.pobox.com/~gbarr/libnet/

Using Net::FTP
==============

How do I download files from a FTP server ?
-------------------------------------------

   An example taken from an article posted to comp.lang.perl.misc

     #!/your/path/to/perl

     # a module making life easier

     use Net::FTP;

     # for debuging: $ftp = Net::FTP->new('site','Debug',10);
     # open a connection and log in!

     $ftp = Net::FTP->new('target_site.somewhere.xxx');
     $ftp->login('username','password');

     # set transfer mode to binary

     $ftp->binary();

     # change the directory on the ftp site

     $ftp->cwd('/some/path/to/somewhere/');

     foreach $name ('file1', 'file2', 'file3') {

     # get's arguments are in the following order:
     # ftp server's filename
     # filename to save the transfer to on the local machine
     # can be simply used as get($name) if you want the same name

     $ftp->get($name,$name);
         }

     # ftp done!

     $ftp->quit;

How do I transfer files in binary mode ?
----------------------------------------

   To transfer files without <LF><CR> translation Net::FTP provides the
binary method

     $ftp->binary;

How can I get the size of a file on a remote FTP server ?
---------------------------------------------------------

How can I get the modification time of a file on a remote FTP server ?
----------------------------------------------------------------------

How can I change the permissions of a file on a remote server ?
---------------------------------------------------------------

   The FTP protocol does not have a command for changing the permissions
of a file on the remote server. But some ftp servers may allow a chmod
command to be issued via a SITE command, eg

     $ftp->quot('site chmod 0777',$filename);

   But this is not guaranteed to work.

Can I do a reget operation like the ftp command ?
-------------------------------------------------

How do I get a directory listing from a FTP server ?
----------------------------------------------------

Changeing directory to "" does not fail ?
-----------------------------------------

   Passing an argument of "" to ->cwd() has the same affect of calling
->cwd() without any arguments. Turn on Debug (*See below*) and you will
see what is happening

     $ftp = Net::FTP->new($host, Debug => 1);
     $ftp->login;
     $ftp->cwd("");

   gives

     Net::FTP=GLOB(0x82196d8)>>> CWD /
     Net::FTP=GLOB(0x82196d8)<<< 250 CWD command successful.

I am behind a SOCKS firewall, but the Firewall option does not work ?
---------------------------------------------------------------------

   The Firewall option is only for support of one type of firewall. The
type supported is a ftp proxy.

   To use Net::FTP, or any other module in the libnet distribution,
through a SOCKS firewall you must create a socks-ified perl executable by
compiling perl with the socks library.

I am behind a FTP proxy firewall, but cannot access machines outside ?
----------------------------------------------------------------------

   Net::FTP implements the most popular ftp proxy firewall approach. The
sceme implemented is that where you loginin to the firewall with
`user@hostname'

   I have heard of one other type of firewall which requires a login to the
firewall with an accont, then a second login with `user@hostname'. You can
still use Net::FTP to traverse these firewalls, but a more manual approach
must be taken, eg

     $ftp = Net::FTP->new($firewall) or die $@;
     $ftp->login($firewall_user, $firewall_passwd) or die $ftp->message;
     $ftp->login($ext_user . '@' . $ext_host, $ext_passwd) or die $ftp->message.

My ftp proxy firewall does not listen on port 21
------------------------------------------------

   FTP servers usually listen on the same port number, port 21, as any
other FTP server. But there is no reason why thi has to be the case.

   If you pass a port number to Net::FTP then it assumes this is the port
number of the final destination. By default Net::FTP will always try to
connect to the firewall on port 21.

   Net::FTP uses IO::Socket to open the connection and IO::Socket allows
the port number to be specified as part of the hostname. So this problem
can be resolved by either passing a Firewall option like `"hostname:1234"'
or by setting the ftp_firewall option in Net::Config to be a string in in
the same form.

Is it possible to change the file permissions of a file on an FTP server ?
--------------------------------------------------------------------------

   The answer to this is "maybe". The FTP protocol does not specify a
command to change file permissions on a remote host. However many servers
do allow you to run the chmod command via the SITE command. This can be
done with

     $ftp->site('chmod','0775',$file);

I have seen scripts call a method message, but cannot find it documented ?
--------------------------------------------------------------------------

   Net::FTP, like several other packages in libnet, inherits from
Net::Cmd, so all the methods described in Net::Cmd are also avaliable on
Net::FTP objects.

Why does Net::FTP not implement mput and mget methods
-----------------------------------------------------

   The quick answer is because they are easy to implement yourself. The
long answer is that to write these in such a way that multiple platforms
are supported correctly would just require too much code. Below are some
examples how you can implement these yourself.

   sub mput {   my($ftp,$pattern) = @_;   foreach my $file (<$pattern>) {
  $ftp->put($file) or warn $ftp->message;   } }

   sub mget {   my($ftp,$pattern) = @_;   foreach my $file
($ftp->ls($pattern)) {     $ftp->get($file) or warn $ftp->message;   } }

Using Net::SMTP
===============

Why can't the part of an Email address after the @ be used as the hostname ?
----------------------------------------------------------------------------

   The part of an Email address which follows the @ is not necessarily a
hostname, it is a mail domain. To find the name of a host to connect for a
mail domain you need to do a DNS MX lookup

Why does Net::SMTP not do DNS MX lookups ?
------------------------------------------

   Net::SMTP implements the SMTP protocol. The DNS MX lookup is not part
of this protocol.

The verify method always returns true ?
---------------------------------------

   Well it may seem thay way, but it does not. The verify method returns
true if the command suceeded. If you pass verify an address which the
server would normally have to forward to another machine the the command
will suceed with something like

     252 Couldn't verify <someone@there> but will attempt delivery anyway

   This command will only fail if you pass it an address in a domain the
the server directly delivers for, and that address does not exist.

Debugging scripts
=================

How can I debug my scripts that use Net::* modules ?
----------------------------------------------------

   Most of the libnet client classes allow options to be passed to the
constructor, in most cases one option is called Debug. Passing this option
with a non-zero value will turn on a protocol trace, which will be sent to
STDERR. This trace can be useful to see what commands are being sent to
the remote server and what responces are being received back.

     #!/your/path/to/perl
     
     use Net::FTP;
     
     my $ftp = new Net::FTP($host, Debug => 1);
     $ftp->login('gbarr','password');
     $ftp->quit;

   this script would output something like

     Net::FTP: Net::FTP(2.22)
     Net::FTP:   Exporter
     Net::FTP:   Net::Cmd(2.0801)
     Net::FTP:   IO::Socket::INET
     Net::FTP:     IO::Socket(1.1603)
     Net::FTP:       IO::Handle(1.1504)

     Net::FTP=GLOB(0x8152974)<<< 220 imagine FTP server (Version wu-2.4(5) Tue Jul 29 11:17:18 CDT 1997) ready.
     Net::FTP=GLOB(0x8152974)>>> user gbarr
     Net::FTP=GLOB(0x8152974)<<< 331 Password required for gbarr.
     Net::FTP=GLOB(0x8152974)>>> PASS ....
     Net::FTP=GLOB(0x8152974)<<< 230 User gbarr logged in.  Access restrictions apply.
     Net::FTP=GLOB(0x8152974)>>> QUIT
     Net::FTP=GLOB(0x8152974)<<< 221 Goodbye.

   The first few lines tell you the modules that Net::FTP uses and thier
versions, this is usefule data to me when a user reports a bug. The last
seven lines show the communication with the server. Each line has three
parts. The first part is the object itself, this is useful for separating
the output if you are using mutiple objects. The second part is either
`<<<<' to show data coming from the server or `&gt&gt&gt&gt' to show data
going to the server. The remainder of the line is the command being sent
or responce being received.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997 Graham Barr.  All rights reserved.


