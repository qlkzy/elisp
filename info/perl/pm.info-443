This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: XTM/variantName,  Next: Xbase,  Prev: XTM/variant,  Up: Module List

trivial class definition
************************

NAME
====

   XTM::variantName - trivial class definition

SYNOPSIS
========

     # see XTM::generic

DESCRIPTION
===========

   Generic container for accessor functions.

SEE ALSO
========

   *Note XTM: XTM,

AUTHOR INFORMATION
==================

   Copyright 2001, Robert Barta <rho@telecoma.net>, All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Xbase,  Next: Xmms,  Prev: XTM/variantName,  Up: Module List

Perl Module to Read Xbase DBF Files and Foxpro IDX indexes
**********************************************************

NAME
====

   Xbase - Perl Module to Read Xbase DBF Files and Foxpro IDX indexes

ABSTRACT
========

   This is a perl module to access xbase files with simple IDX indexes.
At the moment only read access to the files are provided by this package
Writing is tougher with IDX updates etc and is being worked on. Since the
read functionality is useful in itself this version is being released.

INSTALLATION
============

   To install this package, change to the directory where this file is
present and type

     perl Makefile.PL
     make
     make install

   This will copy Xbase.pm to the perl library directory provided you have
the permissions to do so. To use the module in your programs you will use
the line:

     use Xbase;

   If you cannot install it in the system directory, put it whereever you
like and tell perl where to find it by using the following in the
beginning of your script:

     BEGIN {
     	unshift(@INC,'/usr/underprivileged/me/lib');
     }
     use Xbase;

DESCRIPTION
===========

   The various methods that are supported by this module are given below.
There is a very distinct xbase like flavour to most of the commands.

CREATING A NEW XBASE OBJECT:
----------------------------

     $database = new Xbase;

   This will create an object $database that will be used to interact with
the various methods the module provides.

OPENING A DATABASE
------------------

     $database->open_dbf($dbf_name, $idx_name);

   Associates the DBF file and optionally the IDX file with the object. It
opens the files and if a associated MEMO file is present automatically
opens it. Only Foxpro Memo files are currently supported and assumes the
same filename as the DBF with a FPT extension.

DATABASE TYPE
-------------

     print $database->dbf_type;

   Returns a string telling you if the xbase file opened is DBF3, DBF4 or
FOX

LAST UPDATE DATE
----------------

     print $database->last_update;

   Returns a date string telling you when the database was last updated.

LAST RECORD NUMBER
------------------

     $end=$database->lastrec;

   Returns the record number of the last record in the database file.

DATABASE STATUS INFORMATION
---------------------------

     $database->dbf_stat;

   This prints out on to STDOUT a display of the status/structure of the
database. It is similar to the xbase command DISPLAY STATUS. Since it
prints field names and structure it is commonly used to see if the module
is reading the database as intended and finding out the field names.

INDEX FILE STATUS INFORMATION
-----------------------------

     $database->idx_stat;

   Prints on to STDOUT the status information of an open IDX file.

GO TOP
------

     $database->go_top;

   Moves the record pointer to the top of the database. Physical top of
database if no index is present else first record according to index order.

GO BOTTOM
---------

     $database->go_bottom;

   Moves the record pointer to the bottom of the database. Physical bottom
of database if no index is present else last record according to index
order.

GO NEXT
-------

     $database->go_next;

   Equivalent to the xbase command SKIP 1 which moves the record pointer to
the next record.

GO PREVIOUS
-----------

     $database->go_prev;

   Equivalent to the xbase command SKIP -1 which moves the record pointer
to the previous record.

SEEK
----

     $stat=$database->seek($keyvalue);

   This command positions the record pointer on the first matching record
that has the key value specified. The database should be opened with an
associated index. Seek without an available index will print an error
message and abort. The return value indicates whether the key value was
found or not.

RECORD NUMBER
-------------

     $current_rec=$database->recno;

   Returns the record number that the record pointer is currently at.

BEGINNING OF FILE
-----------------

     if ($database->bof) {
     	print "At the very top of the file \n";
     }

   Tells you whether you are at the beginning of the file. Like in xbase
it is not true when you are at record number one but rather it is set when
you try to $database->go_prev when you are at the top of the file.

END OF FILE   	if ($database->eof) { 		print "At the very end of the file \n"; 	}
---------------------------------------------------------------------------------

   Tells you whether you are at the end of the file. Like in xbase it is
not true when you are at the last record but rather it is set when you try
to $database->go_next from the last record.

READ INDIVIDUAL FIELD VALUES
----------------------------

     print $database->get_field("NAME");

   Returns as a string the contents of a field name specified from the
current record. Using the pseudo field name _DELETED will tell you if the
current record is marked for deletion.

READ FIELD VALUES INTO ARRAY
----------------------------

     @fields = $database->get_record;

   Returns as an array all the fields from the current record. The fields
are in the same order as in the database.

CLOSE DATABASE
--------------

     $database->close_dbf;

   This closes the database files, index files and memo files that are
associated with the $database object with $database->open_dbf

COPYRIGHT
=========

   Copyright (c) 1995 Pratap Pereira. All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

   I request that if you use this module at a web site to make a link to

   	http://eewww.eng.ohio-state.edu/~pereira/software/xbase/

   This is just so that others might find it. This is however not required
of you.

AUTHOR INFORMATION
==================

   Please send your comments, suggestions, gripes, bug-reports to

     Pratap Pereira
     pereira@ee.eng.ohio-state.edu

UPDATE HISTORY
==============

Original perl 4 script done in March 1994
Perl 5 module done in February 1995
RELEASE 2 was first public release now called xbase12.pm
RELEASE 3 was done 6/22/95 called xbase13.pm
          Fixed problem with GO_PREV & GO_NEXT after SEEK.
          Fixed problem with parsing headers of dbfs with
                  record length > 255.
          Added Memo file support.

RELEASE 4 was done 9/29/95
          Fixed problem with certain IDX failing completely,
                  was a stupid
          indexing mistake.

RELEASE 5 was done 11/14/95 (called xbase.pm 1.05)
          Fixed field length inconsistency errors by changing
                  way header is decoded. Should work with more xbase
                  variants. (Dick Sutton & Andrew Vasquez)

Version 1.06  was done 11/17/95
          Added binmode command to file handles to support
          Windows NT

Version 1.07 was done 01/23/96
          Made documentation in pod format, installation
                  automated. Fixed problem with deleted status being
                  improperly read (Chung Huynh). Renamed to Xbase
                  (previously xbase) to be consistent with other perl
                  modules. Released in CPAN.
          Prettied up dbf_stat output (Gilbert Ramirez).

CREDITS
=======

   Thanks are due to Chung Huynh (chuynh@nero.finearts.uvic.ca), Jim
Esposito (jgespo@exis.net), Dick Sutton (suttond@federal.unisys.com),
Andrew Vasquez (praka@ophelia.fullcoll.edu), Leonard Samuelson
(lcs@synergy.smartpages.com) and Gilbert Ramirez Jr
(gram@merece.uthscsa.edu)


File: pm.info,  Node: Xmms,  Next: Xmms/Config,  Prev: Xbase,  Up: Module List

Interactive remote control shell for xmms
*****************************************

NAME
====

   Xmms - Interactive remote control shell for xmms

SYNOPSIS
========

     perl -MXmms -e shell

DESCRIPTION
===========

   Xmms::shell provides an alternative or companion interface to the xmms
gui.

   Feature summary:

Standard Play Controls
     play, pause, stop, next, prev, eject

Standard Options
     toggle repeat, toggle shuffle

Playlist Controls
     clear, select, add file(s), add url(s), playlist load/save, sort
     (more options than the gui)

File Info
     search, view and edit mp3 tags

Misc Controls
     time change (and slider), volume change (and slider), balance change,
     window toggle

Shell Features

    command history
    command/file completion
    file matching
    title matching
    emacs key bindings
Shell Command Summary
=====================

   The complete list of shell commands is also available via the help
command.

add
     Add files to the current playlist, without clearing the current
     playlist.  See also: play description of the special `-' character.

alias
     Alias a long command to one of your own definition, e.g.:

          xmms> alias cd play /cdrom
          xmms> cd

balance
     View or change the balance.

clear
     Clear the current playlist.

current
     Display the current playlist track number, title, time, rate,
     frequency and mode.

delete
     Delete tracks from the playlist.  (NOTE: at the time of this writing,
     the *patches/xmms-playlist-delete.pat* patch must be applied to
     xmms-0.9.1.)  Example:

          xmms> delete 3

     This command can also handle ranges, e.g. to play just your favorite
     tracks from and audio cd:

          xmms> play /cdrom
          xmms> delete 5, 7..10

dig
     Search for mp3 files by mp3 tag or file name.  Root directory defaults
     to the last play command or greedy dig command.

     Example:

          #"greedy" match against *.mp3 filename and all tag info
          xmms> dig ~/mp3 gabba|break

          xmms> track
          1 - Prodigy - Break'n'Enter [0:11/5:59 (3%)]
          2 - gabba (6:12)
          3 - gabba (4:47)
          4 - break_and_enter_95_live (5:58)
          5 - Prodigy - Diesel Power (Snake break - Mi (7:08)
          6 - The Prodigy - Acid Break (4:42)

          #match against mp3 `artist' tag only
          xmms> dig artist maxim|liam
          1 - Biohazard feat. Maxim Reality - Breathe [0:03/3:33 (1%)]
          2 - Liam Howlett (DJ mix) - Heavyweight Selection XL Mix (19:37)
          3 - Maxim - Dog Day (4:41)
          4 - Maxim - Factory Girl (2:33)

     See also: play description of the special `-' character.

eject
     Just like pressing the eject button on the gui, pops up the *load
     file* window.  However, if an audio cd is/was playing (and Audio::CD
     is installed), the cd tray will pop open.  If an audio cd is not
     playing, but you want to open the tray, provided the cd argument:

          xmms> eject cd

export
     Make environment variables available to the shell, e.g.:

          xmms> export PWD
          xmms> play $PWD/fav.mp3

          xmms> export MP3_HOME=/usr/local/mp3
          xmms> play $MP3_HOME/fav.mp3

          xmms> export CD="play /cdrom"
          xmms> $CD

files
     The current playlist with be reduced to files matching the given
     pattern.  If no files match, the playlist is not changed.  Example:

          xmms> files ro(ck|ll) #reduces playlist to files containing `rock' and `roll'

     To negate, use the ! prefix:

          xmms> files !fire    #removes files containing `fire' from the playlist

help
     Print command summary.

history
     This function adds a bit of functionality over the readline history.
     Mainly, ability to save and run history to and from files on disk.
     Example:

          xmms> play ~/mp3/favorites
          xmms> volume 40
          xmms> jtime 1 2:00
          xmms> jtime 2 0:45
          xmms> history >~/mp3/fav.hist #save current history
          xmms> history <~/mp3/fav.hist #read/run history from fav.hist

     TAB completion on the special character `-' will recall the last
     directory from which a history script was read.  See also:
     *Xmms::SongChange*.

     If the file *~/.xmms/.perlrc* exists, it will be automatically run as
     a history script when the shell is invoked, before the prompt loop.
     For example, my *~/.xmms/.perlrc* file looks like so:

          volume 30
          resume

     The clear subcommand can be used to clear the current history:

          xmms> history clear

info
     This command will display information about the given track, where
     track is a number in the current playlist file.  The sub-commands can
     be used to edit the mp3 tag of the track file.  Example:

          xmms> info 2
          File........./usr/local/mp3/prodigy/rare/we_eat_rhythm.mp3
          Size......... 4.9M
          Modified.....Thu May 20 16:29:43 1999
          Album........deleted from Jilted Generation
          Artist.......The Prodigy
          Comment......?
          Genre........Electronic
          Title........We Eat Rhythm (Original Version)
          Tracknum.....?
          Year.........1994
          Time.........5:18
          ...

          xmms> info 2 comment Great Tune
          comment set to `Great Tune'

          xmms> info 2 comment
          Comment......Great Tune

jtime
     This command jumps to the last time set by the time command and
     defaults to *0:00*.  For example:

          xmms> dig file speedway #load files with the name `speedway'
          xmms> time 1:10         #jump 1:10 into the song
          ... time passes ...
          xmms> jtime             #jump back to 1:10

     A two argument form of jtime can be used to set jump times for tracks
     without actually jumping to that time, until jtime is called in the
     no argument form.   I like this for playing my favorite parts of
     songs, example:

          #set jump times for these three tracks
          xmms> jtime 3 0:30
          xmms> jtime 4 1:00
          xmms> jtime 6 2:11

     See also, key bindings: M-\

list
     This command is used to load a playlist file or to save the current
     playlist file to disk.

     Example:

          xmms> list save ~/mp3/fav-tracks #save list
          playlist saved

          xmms> list ~/mp3/fav-tracks      #load list

     To measure the size of a list:

          xmms> list size ~/mp3/slipknot.m3u
          slipknot_742617000027.mp3  560k
          slipknot_sic.mp3  3.1M
          ...
          Total: 40.2M

mtime
     Mark the current output time for jtime.

next
     Skip forward to next track in the playlist.

pause
     Pause the current track in the playlist.

play
     With no arguments, this command is just the same as hitting the gui
     play button.  When given an argument of a directory, file or file
     glob, the playlist will be set to these files.  Example:

          xmms> play ~/mp3/prodigy/remixes/

          xmms> play ~/mp3/prodigy/live/*skylined*

     TAB completion on the special character `-' will recall the last
     directory used with the add, play or dig command, this value is also
     saved to your ~/.xmms/config file, so it is always available.
     Example:

          xmms> play -<TAB>

     completes to:

          xmms> play /home/dougm/mp3/prodigy/remixes/

prev
     Skip backward to previous track in the playlist.

quit
     Quit the xmms shell.

repeat
     Toggle the repeat button.

resume
     This command will restore the xmms state to where it was just before
     the last quit command was run.  That is, it will load the saved
     playlist and jump to the list position and output time where xmms was
     just before quitting.  The playlist, position and output time are
     saved in *~/.xmms/config*.

shuffle
     Toggle the shuffle button.

sort
     Sort the playlist various ways:

    access
          Sort by last file access time.

    album
          Sort by album mp3 tag.

    artist
          Sort by artist mp3 tag.

    comment
          Sort by artist mp3 tag.

    file
          Sort by file basename.

    genre
          Sort by genre mp3 tag.

    large
          Sort by file size, from large to small.

    new
          Sort by file modification time, from new to old.

    old
          Sort by file modification time, from old to new.

    order
          Sort the list by order of your choice, e.g.:

               xmms> play /cdrom
               xmms> sort order 3, 10, 6..9, 1

          Tracks not specified in the new order are left out of the new
          playlist.

    path
          Sort by filename, including the path name.

    random
          Sort in random order.

    reverse
          Reverse the playlist order.

    small
          Sort by file size, from small to large.

    title
          Sort by title name.

    tracknum
          Sort by tracknum mp3 tag.

    year
          Sort by year mp3 tag.

time
     With no argument, this command will display the elapsed, total and
     remaining percentage time of the current track.  When given a *+N*
     argument, it will jump the song forward N seconds.  When given a -N
     argument, it will jump the song backward N seconds.  *+<TAB*> and
     *-<TAB*> can be used a slider for moving forward and backward.
     Finally, a *mm:ss* argument will jump to that time in the song.  Oh,
     and *time <TAB*> will complete to the form *0:00..mm:ss*, which will
     jump to a random time in the song.

titles
     This function works just the same as the files function, but matches
     against playlist titles.

track
     This function is used for interacting with the current playlist.
     With no arguments, it will print the entire list.  When given a range
     argument, it will print the info for those tracks, for example:

          xmms> track 100..230

     Given a number or title name, it will jump to that track in the
     playlist.

url
     Add a url to the playlist for streaming.  TAB completion on the
     special character `-' will recall the last url used with this command.

     If *Xmms::shell* finds the *$ENV{HOME}/.xmms/.perlurldb* file when
     starting up, the urls in this file will be used for url tab
     completion.

volume
     View or change the volume.  With no argument, this command displays
     the current volume percentage.  With an argument, changes the volume
     to the given percentage.  *+<TAB*> and *-<TAB*> can be used a slider
     for moving raising and lowering the volume.  The up/down arrow keys
     are also bound to this slider.

window
     This command is used to show or hide the xmms windows.  If the shell
     is started and xmms is not already running, all windows will be
     hidden by default.

Key Bindings
============

   Here is a list of some of the more useful key bindings.  `C' is
shorthand for the control key, `M' is shorthand for the *meta* key, which
is normally the escape key.

C-a : move to beginning of the line
C-b : move backward one character
C-c : interrupt
C-d : delete next character
C-e : move to end of the line
C-f : more forward one character
C-h : delete previous character
TAB : complete
C-k : kill line
C-l : clear screen
C-n : next command in history list
C-p : previous command in history list
C-r : reverse search in history list
C-s : forward search in history list
C-t : transpose characters
C-u : discard line
C-y : yank line
M-< : beginning of history
M-> : end of history
M-b : move backward one word
   The following key bindings are shortcuts specific to xmms:

up arrow : volume slide up
down arrow : volume slide down
M-= : next
M- : prev
M-. : stop
M-/ : play
M-\ : jtime
M-m : mtime
M-, : pause
M-~ : shuffle
M-@ : repeat
M-` : run previous command in history list

M-1 : play track 1 in the playlist

M-2 : play track 2 in the playlist (and so on to #9)
   The nice part about these key bindings is the single-keystoke-ness and
that they are not added to the command history, leaving just the more
complex commands in your history buffer.

   Effective use of these bounds keys can actually make up a half-assed
sampler too.

   The following key bindings will toggle the xmms windows:

M-a : all windows
M-w : main window
M-l : playlist window
M-q : equalizer window
Command Aliases
===============

   A command abbreviation table is built at startup to provide the
following command aliases:

     a     => add
     b     => balance
     ch    => change
     cl    => clear
     cr    => crop
     cu    => current
     de    => delete
     di    => dig
     e     => eject
     f     => files
     he    => help
     hi    => history
     i     => info
     j     => jtime
     l     => list
     m     => mtime
     n     => next
     pa    => pause
     pl    => play
     pr    => prev
     q     => quit
     rep   => repeat
     res   => resume
     sh    => shuffle
     so    => sort
     st    => stop
     tim   => time
     tit   => titles
     tr    => track
     u     => url
     v     => volume
     w     => window

SEE ALSO
========

   xmms(1), Xmms::SongChange(3), Xmms::Remote(3), Xmms::Config(3),
MPEG::MP3Info(3)

AUTHOR
======

   Doug MacEachern


File: pm.info,  Node: Xmms/Config,  Next: Xmms/Remote,  Prev: Xmms,  Up: Module List

Perl Interface to xmms_cfg API
******************************

NAME
====

   Xmms::Config - Perl Interface to xmms_cfg API

SYNOPSIS
========

     my $file = Xmms::Config->file; #$ENV{HOME}/.xmms/config
     my $cfg = Xmms::Config->new($file);

DESCRIPTION
===========

AUTHOR
======

   Doug MacEachern

SEE ALSO
========

   xmms(1), Xmms::Remote(3)


File: pm.info,  Node: Xmms/Remote,  Next: Xmms/SongChange,  Prev: Xmms/Config,  Up: Module List

Perl Interface to xmms_remote API
*********************************

NAME
====

   Xmms::Remote - Perl Interface to xmms_remote API

SYNOPSIS
========

     use Xmms::Remote ();
     my $remote = Xmms::Remote->new;
     $remote->play;

DESCRIPTION
===========

   This module provides a Perl interface to the xmms remote control
interface.  No docs yet, sorry, see test.pl and Xmms.pm for now

SEE ALSO
========

   xmms(1), Xmms(3), MPEG::MP3Info(3)

AUTHOR
======

   Doug MacEachern


File: pm.info,  Node: Xmms/SongChange,  Next: YAPE/HTML,  Prev: Xmms/Remote,  Up: Module List

Take actions based on song track/time change
********************************************

NAME
====

   Xmms::SongChange - Take actions based on song track/time change

SYNOPSIS
========

     xmms> change on

DESCRIPTION
===========

   This module creates a thread to poll *xmms* for song track and time
changes.  The thread is started via the *Xmms::shell* command *change on*
and stopped via *change off*.

CAVEATS
=======

   This module is considered very *EXPERIMENTAL*.  During testing, it
caused *xmms* to freeze sometimes.  However, this freezing occured with
*xmms* version *0.9*, I have seen no freezing with version *0.9.1*.

   The module decides if a song has changed based on track number or track
length.  So, when only one track is in the playlist, this logic is broken.

   Since the thread is constantly polling *xmms* via the remote protocol,
xmms is consuming more cpu time than normal.

FEATURES
========

   Current features include:

jtime
     When *Xmms::SongChange* is running, it will auto jump to the current
     track's jtime, if any.

repeat
     The *Xmms::shell* repeat command can be used with 2 additional
     arguments, to repeat a track in the playlist n number of times before
     advancing.  Example:

          xmms> repeat 1 3

     This command will cause track 1 to be repeated 3 times before
     advancing.

crop
     *Xmms::SongChange* adds a new crop command, which is similar in
     concept to jtime, but advances to the next track in the playlist when
     the current track crop time is reached.  Example:

          xmms> crop 2 4:30

     This command will cause playlist advance when track 2 reaches the
     output time of *4:30*.

     With no arguments, the current output time is set as the crop time
     for the current track.  The *M-c* key binding has the same effect.

clear
     When the *SongChange* thread is running, the *Xmms::shell* clear
     command will also clear all *SongChange* watch points.

TIPS
====

   The *Xmms::shell* history command can be used to run a "script".  For
example, consider a file such as:

     change on
     clear
     add /usr/local/mp3/prodigy/live/speedway.mp3
     add /usr/local/mp3/prodigy/live/rock_n_roll_98.mp3
     jtime 1 1:19
     crop 1 2:17
     repeat 1 3
     jtime 2 1:00
     crop 2 4:20
     play

   Which can be run in the shell like so:

     xmms> history < ~/mp3/example.sc

FUTURE
======

   I plan to implement the following features in the future:

fade
     start to fade the volume at a given time.

splice
     similar to using jtime and crop, but in the middle of a song.  of
     course, this can already be done by adding the same file to the
     playlist multiple times and setting different jtime and crop times
     for each.

???
AUTHOR
======

   Doug MacEachern


File: pm.info,  Node: YAPE/HTML,  Next: YAPE/HTML/Element,  Prev: Xmms/SongChange,  Up: Module List

Yet Another Parser/Extractor for HTML
*************************************

NAME
====

   YAPE::HTML - Yet Another Parser/Extractor for HTML

SYNOPSIS
========

     use YAPE::HTML;
     use strict;
     
     my $content = "<html>...</html>";
     my $parser = YAPE::HTML->new($content);
     my ($extor,@fonts,@urls,@headings,@comments);
     
     # here is the tokenizing part
     while (my $chunk = $parser->next) {
       if ($chunk->type eq 'tag' and $chunk->tag eq 'font') {
         if (my $face = $chunk->get_attr('face')) {
           push @fonts, $face;
         }
       }
     }
     
     # here we catch any errors
     unless ($parser->done) {
       die sprintf "bad HTML: %s (%s)",
         $parser->error, $parser->chunk;
     }
     
     # here is the extracting part
     
     # <A> tags with HREF attributes
     # <IMG> tags with SRC attributes
     $extor = $parser->extract(a => ['href'], img => ['src']);
     while (my $chunk = $extor->()) {
       push @urls, $chunk->get_attr(
         $chunk->tag eq 'a' ? 'href' : 'src'
       );
     }
     
     # <H1>, <H2>, ..., <H6> tags
     $extor = $parser->extract(qr/^h[1-6]$/ => []);
     while (my $chunk = $extor->()) {
       push @headings, $chunk;
     }
     
     # all comments
     $extor = $parser->extract(-COMMENT => []);
     while (my $chunk = $extor->()) {
       push @comments, $chunk;
     }

`YAPE' MODULES
==============

   The `YAPE' hierarchy of modules is an attempt at a unified means of
parsing and extracting content.  It attempts to maintain a generic
interface, to promote simplicity and reusability.  The API is powerful,
yet simple.  The modules do tokenization (which can be intercepted) and
build trees, so that extraction of specific nodes is doable.

DESCRIPTION
===========

   This module is yet another parser and tree-builder for HTML documents.
It is designed to make extraction and modification of HTML documents
simplistic.  The API allows for easy custom additions to the document
being parsed, and allows very specific tag, text, and comment extraction.

USAGE
=====

   In addition to the base class, `YAPE::HTML', there is the auxiliary
class `YAPE::HTML::Element' (common to all `YAPE' base classes) that holds
the individual nodes' classes.  There is documentation for the node
classes in that module's documentation.

   HTML elements and their attributes are stored internally as lowercase
strings.  For clarification, that means that the tag `<A
HREF="FooBar.html">' is stored as

     {
       TAG => 'a',
       ATTR => {
         href => 'FooBar.html',
       }
     }

   This means that tags will be output in lowercase.  There will be a
feature in a future version to switch output case to capital letters.

Functions
---------

   * `YAPE::HTML::EMPTY(@tags)'

     Adds to the internal hash of tags which never contain any out-of-tag
     content.  This hash is `%YAPE::HTML::EMPTY', and contains the
     following tag names: area, base, `br', `hr', `img', input, link,
     `meta', and param.  Deletion from this hashmust be done manually.
     Adding to this hash automatically adds to the `%OPEN' hash, described
     next.

   * `YAPE::HTML::OPEN(@tags)'

     Adds to the internal hash of tags which do not require a closing tag.
     This hash is `%YAPE::HTML::OPEN', and contains the following tag
     names:  area, base, `br', dd, `dt', `hr', `img', input, `li', link,
     `meta', p, and param.  Deletion from this hash must be done manually.

     There is a subtle difference between "empty" and "open" tags.  For
     example, the `<AREA>' tag contains a few attributes, but there is no
     text associated with it (nor any other tags), and therefore, is
     "empty"; the `<LI>', on the other hand,

     *It is strongly suggested* that for ease in parsing, any tags that
     you do not explicitly close have a / at the end of the tag:

          Here's my cat: <img src="cat.jpg" />

Methods for `YAPE::HTML'
------------------------

   * `use YAPE::HTML;'

   * `use YAPE::HTML qw( MyExt::Mod );'

     If supplied no arguments, the module is loaded normally, and the node
     classes are given the proper inheritence (from
     `YAPE::HTML::Element').  If you supply a module (or list of modules),
     import will automatically include them (if needed) and set up *their*
     node classes with the proper inheritence - that is, it will append
     `YAPE::HTML' to `@MyExt::Mod::ISA', and `YAPE::HTML::xxx' to each
     node class's `@ISA' (where `xxx' is the name of the specific node
     class).

     It also copies the `%OPEN' and `%EMPTY' hashes, as well as the
     `OPEN()' and `EMPTY()' functions, into the `MyExt::Mod' namespace.
     This process is designed to save you from having to place `@ISA'
     assignments all over the place.

     It also copies the `%SSI' hash.  This hash is not suggested to be
     altered, and therefore it does not have any public interface (you
     have to fiddle with it yourself).  It exists to ensure an SSI is
     valid.

          package MyExt::Mod;
          use YAPE::HTML 'MyExt::Mod';
          
          # @MyExt::Mod::ISA = 'YAPE::HTML'
          # @MyExt::Mod::text::ISA = 'YAPE::HTML::text'
          # ...
          
          # being rather strict with the tags
          %OPEN = ();
          %EMPTY = ();

   * `my $p = YAPE::HTML->new($HTML, $strict);'

     Creates a `YAPE::HTML' object, using the contents of the `$HTML'
     string as its HTML to parse.  The optional second argument determines
     whether this parser instance will demand strict comment parsing and
     require all tags to be closed with a closing tag or a / at the end of
     the tag (`<HR />').  Any true value (except for the special string
     `-NO_STRICT') will turn strict parsing on.  This is off by default.
     (This could be considered a bug.)

   * `my $text = $p->chunk($len);'

     Returns the next `$len' characters in the input string; `$len'
     defaults to 30 characters.  This is useful for figuring out why a
     parsing error occurs.

   * `my $done = $p->done;'

     Returns true if the parser is done with the input string, and false
     otherwise.

   * `my $errstr = $p->error;'

     Returns the parser error message.

   * `my $coderef = $p->extract(...);'

     Returns a code reference that returns the next object that matches
     the criteria given in the arguments.  This is a fundamental feature
     of the module, and you can extract that from `Extracting Sections' in
     this node.

   * `my $node = $p->display(...);'

     Returns a string representation of the entire content.  It calls the
     parse method in case there is more data that has not yet been parsed.
     This calls the `fullstring' method on the root nodes.  Check the
     `YAPE::HTML::Element' docs on the arguments to `fullstring'.

   * `my $node = $p->next;'

     Returns the next token, or undef if there is no valid token.  There
     will be an error message (accessible with the error method) if there
     was a problem in the parsing.

   * `my $node = $p->parse;'

     Calls next until all the data has been parsed.

   * `my $attr = $p->quote($string);'

     Returns a quoted string, suitable for using as an attribute.  It
     turns any embedded `"' characters into `&quot;'.  This can also be
     called as a raw function:

          my $quoted = YAPE::HTML::quote($string);

   * `my $root = $p->root;'

     Returns an array reference holding the root of the tree structure -
     for documents that contain multiple top-level tags, this will have
     more than one element.

   * `my $state = $p->state;'

     Returns the current state of the parser.  It is one of the following
     values: `close(TAG)', comment, done, dtd, error, `open(TAG)', pi,
     `ssi', text, `text(script)', or `text(xmp)'.  The open and close
     states contain the name of the element in parentheses (ex.
     `open(img)').  Tag names, as well as the names of attributes, are
     converted to lowercase.  The state of `text(script)' refers to text
     found inside an `<SCRIPT>' element, and likewise for `text(xmp)'.

   * `my $HTMLnode = $p->top;'

     Returns the first `<HTML>' node it finds in the tree structure.

Extracting Sections
-------------------

   `YAPE::HTML' allows comprehensive extraction of tags, text, comments,
DTDs, PIs, and SSIs, using a simple, yet rich, syntax:

     my $extor = $parser->extract(
       TYPE => [ REQS ],
       ...
     );

   TYPE can be either the name of a tag (`"table"'), a regular expression
that matches tags (`qr/^t[drh]$/'), or a special string to match all tags
(`-TAG'), all text (`-TEXT'), all comments (`-COMMENT'), all DTDs
(`-DTD'), all PIs (`-PI'), and all SSIs (`-SSI').

   *REQS* varies from element to element:

   * `-TAG', `-DTD', `-PI', `-SSI'

     A list of attributes that the tag/DTD/PI/SSI must have.

   * `-TEXT', `-COMMENT'

     A list of strings and regexes that the content of the text/comment
     must have or match.

   Here are some example uses:

   * all tags starting with "h"
          my $extor = $parser->extract(qr/^h/ => []);

   * all tags with an "align" attribute
          my $extor = $parser->extract(-TAG => ['align']);

   * all text containing the word "japhy"
          my $extor = $parser->extract(-TEXT => [qr/\bjaphy\b/i]);

   * tags involving links
          my $extor = $parser->extract(
            a => ['href'],
            area => ['href'],
            base => ['href'],
            body => ['background'],
            img => ['src'],
            # ...
          );

FEATURES
========

   This is a list of special features of `YAPE::HTML'.

   * On-the-fly cleaning of HTML

     If you aren't enforcing strict HTML syntax, then in the act of
     parsing HTML, if a tag that should be closed is not closed, it will
     be flagged for closing.  That means that input like:

          <b>Foo<i>bar</b>

     will appear as:

          <b>Foo<i>bar</i></b>

     upon request for output.  In addition, tags that are left dangling
     open at the end of an HTML document get closed.  That means:

          <b>Foo<i>bar

     will appear as:

          <b>Foo<i>bar</i></b>

   * Syntax-checking

     If strict checking is off, the only error you'll receive from
     mismatched HTML tags is a closing tag out-of-place.

     On the other hand, if you do enforce strict HTML syntax, you'll be
     informed of tags that do not get closed as well (that should be
     closed).

TO DO
=====

   This is a listing of things to add to future versions of this module.

API
---

   * HTML entity translation (via `HTML::Entities' no doubt)

     Add a flag to the `fullstring' method of objects, `-EXPAND', which
     will display `&...;' HTML escapes as the character representing them.

   * Toggle case of output (lower/upper case)

     Add a flag to the `fullstring' method of objects, `-UPPER', which
     will display tag and attribute names in uppercase.

   * Super-strict syntax checking

     DTD-like strictness in regards to nesting of elements - `<LI>' is not
     allowed to be outside an `<OL>' or `<UL>' element.

Internals
---------

   * Make it faster, of course

     There's probably some inherent slowness to this method, but it works.
     And it supports the robust extract method.

   * Combine `CLOSED' and `IMPLICIT'

     Make three constants, `CLOSED_NO', `CLOSED_YES', and `CLOSED_IMPL'.

BUGS
====

   Following is a list of known or reported bugs.

Fixed
-----

   * Inheritence fixed again (fixed in `1.11')

   * Inheritence was fouled up (fixed in 1.10)

Pending
-------

   * The above features aren't in here yet.  `;)'

   * Strict syntax-checking is not on by default.

   * This documentation might be incomplete.

   * DTD, PI, and SSI support is incomplete.

   * Probably need some more test cases.

   * SSI conditional tags don't contain content.

SUPPORT
=======

   Visit `YAPE''s web site at `http://www.pobox.com/~japhy/YAPE/'.

SEE ALSO
========

   The `YAPE::HTML::Element' documentation, for information on the node
classes.

AUTHOR
======

     Jeff "japhy" Pinyan
     CPAN ID: PINYAN
     japhy@pobox.com
     http://www.pobox.com/~japhy/


File: pm.info,  Node: YAPE/HTML/Element,  Next: YAPE/Regex,  Prev: YAPE/HTML,  Up: Module List

sub-classes for YAPE::HTML elements
***********************************

NAME
====

   YAPE::HTML::Element - sub-classes for YAPE::HTML elements

SYNOPSIS
========

     use YAPE::HTML 'MyExt::Mod';
     # this sets up inheritence in MyExt::Mod
     # see YAPE::HTML documentation

`YAPE' MODULES
==============

   The `YAPE' hierarchy of modules is an attempt at a unified means of
parsing and extracting content.  It attempts to maintain a generic
interface, to promote simplicity and reusability.  The API is powerful,
yet simple.  The modules do tokenization (which can be intercepted) and
build trees, so that extraction of specific nodes is doable.

DESCRIPTION
===========

   This module provides the classes for the `YAPE::HTML' objects.  The
base class for these objects is `YAPE::HTML::Element'; the four object
classes are `YAPE::HTML::opentag', `YAPE::HTML::closetag',
`YAPE::HTML::text', and `YAPE::HTML::comment'.

Methods for `YAPE::HTML::Element'
---------------------------------

   This class contains fallback methods for the other classes.

   * `my $content = $obj->text;'

     Returns an array reference of objects between an open and close tag,
     or a string of plain text for a block of text or a comment.  This
     method merely returns the TEXT value in the object hash.  This
     returns undef for dtd, pi, and `ssi' objects.

   * `my $string = $obj->string;'

     Returns a string representing the single object (for tags, this does
     not include the elements found in between the open and close tag).
     This method merely calls the object's text method.

   * `my $complete = $obj->fullstring;'

     Returns a string representing the object (and all objects found
     within it, in the case of a tag).  This method merely calls the
     object's string method.

   * `my $type = $obj->type;'

     Returns the type of the object:  tag, `closetag', text, or comment.

Methods for `YAPE::HTML::opentag'
---------------------------------

   This class represents tags.  Object has the following methods:

   *



     `my $tag = YAPE::HTML::opentag->new($name, $attr, $text, $closed, $impl);'

     Creates a `YAPE::HTML::opentag' object.  Takes five arguments: the
     name of the HTML element, a hash reference of attribute-value pairs,
     an array reference of objects to be included in between the open and
     closing tags, whether the tag is explicitly closed or not, and
     whether the tag is implicitly closed or not.  The attribute hash
     reference must have the keys in lowercase text.

          my $attr = { src => 'foo.png', alt => 'foo' };
          my $img = YAPE::HTML::opentag->new('img', $attr, [], 0, 1);
          
          my $text = [ YAPE::HTML::text->new("Bar!"), $img ];
          my $name = YAPE::HTML::opentag->new('a', { name => 'foo' }, $text);

   * `my $str = $tag->string;'

     Creates a string representation of the *tag only*.  This means the
     tag, and any attributes of the tag *only*.  No closing tag (if any)
     is returned.

          print $img->string;
          # <img src="foo.png" alt="foo" />
          
          print $name->string;
          # <a name="foo">

   * `my $str = $tag->fullstring($exclude, $depth);'

     Creates a string representation of the tag, the content enclosed
     between the open and closing tags, and the closing tag (if
     applicable).  The method can take two arguments: an array reference
     of tag names not to render, and the depth with which to render tags.
     The `$exclude' defaults to none, and `$depth' defaults to `-1', which
     means there is no depth limit.

          print $img->fullstring;
          # <img src="foo.png" width=20 height=43 />
          
          print $name->fullstring;
          # <a name="foo">Bar!<img src="foo.png" alt="foo" /></a>
          
          print $name->fullstring(0);
          # Bar!
          
          print $name->fullstring(['img']);
          # <a name="foo">Bar!</a>
          
          print $name->fullstring(1);
          # <a name="foo">Bar!</a>

   * `my $attr = $tag->get_attr($name);'

   * `my @attrs = $tag->get_attr(@names);'

   * `my %attrs = $tag->get_attr;'

     Fetches any number of attribute values from a tag.  Note: tags which
     contain attributes with no value have a value of undef returned for
     that attribute - this is indistinguishable from the undef returned
     for a tag that does not have an attribute.  This is on the list of
     things to be fixed.  In the meantime, use the `has_attr' method
     beforehand.

          print $name->get_attr('name');
          # 'foo'
          
          my %list = $img->get_attr;
          # alt => 'foo', src => 'foo.png'

   * `my $attr = $tag->has_attr($name);'

   * `my @attrs = $tag->has_attr(@names);'

     Returns 1 or "" depending on the existence of the attribute in the
     tag.

          my @on = $name->has_attr(qw( name href ));  # (1,0)

   * `$tag->set_attr(%pairs);'

     Sets a list of attributes to the associated values for the tag.

          $img->set_attr( width => 40, height => 16 );

   * `$tag->rem_attr(@names);'

     Removes (and returns) the specified attributes from a tag.  See the
     caveat above for the get_attr method about undef values.

          my $src = $img->rem_attr('src');

   * `my $closed = $tag->closed;'

     Returns 1 or 0, depending on whether or not the tag is closed.  This
     means it has a closing tag - tags like `<hr />' are not closed.

   * `my $impl = $tag->implied_closed;'

     Returns 1 or 0, depending on whether or not the tag is implicitly
     closed with a / at the end of the tag (like `<hr />').

   * `my $tagname = $tag->tag;'

     Returns the name of the HTML element.

          print $name->tag;  # 'a'

Methods for `YAPE::HTML::closetag'
----------------------------------

   This class represents closing tags.  Object has the following methods:

   * `my $tag = YAPE::HTML::closetag->new($name);'

     Creates a `YAPE::HTML::closetag' object.  Takes one argument: the
     name of the HTML element.  These objects are never included in the
     HTML tree structure, since the parser uses the `CLOSED' attribute of
     an `opentag' object to figure out if there needs to be a closing tag.
     However, they are returned in the parsing stage so that you know
     when they've been reached.

          my $close = YAPE::HTML::closetag->new('a');

   * `my $str = $tag->string;'

     Creates a string representation of the closing tag.

          print $close->string;  # '</a>'

   * `my $tagname = $tag->tag;'

     Returns the name of the HTML element.

          print $close->tag;  # 'a'

Methods for `YAPE::HTML::text'
------------------------------

   This class represents blocks of plain text.  Objects have the following
methods:

   * `my $text = YAPE::HTML::text->new($content);'

     Creates a `YAPE::HTML::text' object.  Takes one argument: the text of
     the block.

          my $para = YAPE::HTML::text->new(<< "END");
          Perl is not an acronym -- rather "Practical Extraction
          and Report Language" was developed after the fact.
          END

Methods for `YAPE::HTML::comment'
---------------------------------

   This class represents comments.  Objects have the following methods:

   * `my $comment = YAPE::HTML::comment->new($content);'

     Creates a `YAPE::HTML::comment' object.  Takes one argument: the text
     of the comment.

          my $todo = YAPE::HTML::comment->new(<< "END");
          This table should be formatted differently.
          END

   * `my $str = $comment->string;'

     Creates a string representation of the comment, with `<!--' before
     it, and `-->' after it.

          print $todo->string;
          # <!--This table should be formatted differently-->

Methods for `YAPE::HTML::dtd'
-----------------------------

   This class represents `<!DOCTYPE>' tags.  Objects have the following
methods:

   * `my $dtd = YAPE::HTML::dtd->new(\@fields);'

     Creates a `YAPE::HTML::dtd' object.  Takes one argument: an array
     reference of the four fields (should be two unquoted strings, and two
     quoted strings (?)).

          my $dtd = YAPE::HTML::dtd->new([
            'HTML',
            'PUBLIC',
            '"-//W3C//DTD HTML 4.01//EN"',
            '"http://www.w3.org/TR/html4/strict.dtd"'
          ]);

   * `my $str = $dtd->string;'

     Creates a string representation of the DTD.

          print $dtd->string;
          # (line breaks added for readability)
          # <!DOCTYPE HTML PUBLIC
          #   "-//W3C//DTD HTML 4.01//EN"
          #   "http://www.w3.org/TR/html4/strict.dtd">

   * `my @attrs = $dtd->get_attrs;'

     Returns the four attributes of the DTD.

   * `$dtd->set_attrs(@attrs);'

     Sets the four attributes of the DTD (can't be done piecemeal).

Methods for `YAPE::HTML::pi'
----------------------------

   This class represents process instruction tags.  Objects have the
following methods:

   * `my $pi = YAPE::HTML::pi->new($name, $attr);'

     Creates a `YAPE::HTML::pi' object.  Takes two arguments: the name of
     the processing instruction, and a hash reference of attribute-value
     pairs.  The attribute hash reference must have the keys in lowercase
     text.

          my $attr = { order => 'alphabetical', need => 'examples' };
          my $pi = YAPE::HTML::pi->new(sample => $attr);

   * `my $str = $pi->string;'

     Creates a string representation of the processing instruction.

          print $pi->string;
          # <?sample need="examples" order="alphabetical"?>

   * `my $attr = $pi->get_attr($name);'

   * `my @attrs = $pi->get_attr(@names);'

   * `my %attrs = $pi->get_attr;'

   * `my $attr = $pi->has_attr($name);'

   * `my @attrs = $pi->has_attr(@names);'

   * `$pi->set_attr(%pairs);'

   * `$pi->rem_attr(@names);'

     See the identical methods for `opentag' objects above.

   * `my $name = $pi->name;'

     Returns the name of the processing instruction.

          print $pi->name;  # 'first'

Methods for `YAPE::HTML::ssi'
-----------------------------

   This class represents server-side includes.  Objects have the following
methods:

   * `my $ssi = YAPE::HTML::ssi->new($name, $attr);'

     Creates a `YAPE::HTML::ssi' object.  Takes two arguments: the SSI
     command, and a hash reference of attribute-value pairs.  The
     attribute hash reference must have the keys in lowercase text.

          my $attr = { var => 'REMOTE_HOST' };
          my $ssi = YAPE::HTML::ssi->new(echo => $attr);

   * `my $str = $ssi->string;'

     Creates a string representation of the processing instruction.

          print $ssi->string;
          # <!--#echo var="REMOTE_HOST"-->

   * `my $attr = $ssi->get_attr($name);'

   * `my @attrs = $ssi->get_attr(@names);'

   * `my %attrs = $ssi->get_attr;'

   * `my $attr = $ssi->has_attr($name);'

   * `my @attrs = $ssi->has_attr(@names);'

   * `$ssi->set_attr(%pairs);'

   * `$ssi->rem_attr(@names);'

     See the identical methods for `opentag' objects above.

   * `my $command = $ssi->command;'

     Returns the SSI command's name.

          print $ssi->command;  # 'echo'

CAVEATS
=======

   The `<script>' and `<xmp>' tags are given special treatment.  When they
are encountered, all text up to the first occurrence of the appropriate
closing tag is taken as plain text.

   Tag attributes are displayed in the default `sort()' order.

TO DO
=====

   This is a listing of things to add to future versions of this module.

   * SSI commands if, `elif', and else

     These need to contain content, since the text between them is
     associated with a given condition.

BUGS
====

   Following is a list of known or reported bugs.

   * This documentation might be incomplete.

SUPPORT
=======

   Visit `YAPE''s web site at `http://www.pobox.com/~japhy/YAPE/'.

SEE ALSO
========

   The `YAPE::HTML::Element' documentation, for information on the node
classes.

AUTHOR
======

     Jeff "japhy" Pinyan
     CPAN ID: PINYAN
     japhy@pobox.com
     http://www.pobox.com/~japhy/


