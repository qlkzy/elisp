This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Bio/Tools/HMMER/Set,  Next: Bio/Tools/IUPAC,  Prev: Bio/Tools/HMMER/Results,  Up: Module List

Set of identical domains from HMMER matches
*******************************************

NAME
====

   Bio::Tools::HMMER::Set - Set of identical domains from HMMER matches

SYNOPSIS
========

     # get a Set object probably from the results object
     print "Bits score over set ",$set->bits," evalue ",$set->evalue,"\n";

     foreach $domain ( $set->each_Domain ) {
     	print "Domain start ",$domain->start," end ",$domain->end,"\n";
     }

DESCRIPTION
===========

   Represents a set of HMMER domains hitting one sequence. HMMER reports
two different scores, a per sequence total score (and evalue) and a per
domain score and evalue. This object represents a collection of the same
domain with the sequence bits score and evalue. (these attributes are also
on the per domain scores, which you can get there).

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                - General discussion
     http://www.bioperl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.

   Bug reports can be submitted via email or the web:

     bioperl-bugs@bioperl.org
     http://www.bioperl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email birney@sanger.ac.uk

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

add_Domain
----------

     Title   : add_Domain
     Usage   : $set->add_Domain($domain)
     Function: adds the domain to the list
     Returns : nothing
     Args    : A Bio::Tools::HMMER::Domain object

each_Domain
-----------

     Title   : each_Domain
     Usage   : foreach $domain ( $set->each_Domain() )
     Function: returns an array of domain objects in this set
     Returns : array
     Args    : none

name
----

     Title   : name
     Usage   : $obj->name($newval)
     Function:
     Example :
     Returns : value of name
     Args    : newvalue (optional)

evalue
------

     Title   : evalue
     Usage   : $obj->evalue($newval)
     Function:
     Example :
     Returns : value of evalue
     Args    : newvalue (optional)


File: pm.info,  Node: Bio/Tools/IUPAC,  Next: Bio/Tools/MZEF,  Prev: Bio/Tools/HMMER/Set,  Up: Module List

Generates unique Seq objects from an ambiguous Seq object
*********************************************************

NAME
====

   IUPAC - Generates unique Seq objects from an ambiguous Seq object

SYNOPSIS
========

     use Bio::Seq;
     use Bio::Tools::IUPAC;

     my $ambiseq = new Bio::Seq (-seq => 'ARTCGUTGR', -type => 'Dna');
     my $stream  = new Bio::Tools::IUPAC(-seq => $ambiseq);

     while ($uniqueseq = $stream->next_seq()) {
         # process the unique Seq object.
     }

DESCRIPTION
===========

   IUPAC is a tool that produces a stream of unique, "strict"-satisfying
Seq objects from an ambiquous Seq object (containing non-standard
characters given the meaning shown below)

     Extended Dna / Rna alphabet :
     (includes symbols for nucleotide ambiguity)
     ------------------------------------------
     Symbol       Meaning      Nucleic Acid
     ------------------------------------------
      A            A           Adenine
      C            C           Cytosine
      G            G           Guanine
      T            T           Thymine
      U            U           Uracil
      M          A or C
      R          A or G
      W          A or T
      S          C or G
      Y          C or T
      K          G or T
      V        A or C or G
      H        A or C or T
      D        A or G or T
      B        C or G or T
      X      G or A or T or C
      N      G or A or T or C

     IUPAC-IUB SYMBOLS FOR NUCLEOTIDE NOMENCLATURE:
       Cornish-Bowden (1985) Nucl. Acids Res. 13: 3021-3030.

   ----------------------------------

     Amino Acid alphabet:
      ------------------------------------------
      Symbol           Meaning
      ------------------------------------------
      A        Alanine
      B        Aspartic Acid, Asparagine
      C        Cystine
      D        Aspartic Acid
      E        Glutamic Acid
      F        Phenylalanine
      G        Glycine
      H        Histidine
      I        Isoleucine
      K        Lysine
      L        Leucine
      M        Methionine
      N        Asparagine
      P        Proline
      Q        Glutamine
      R        Arginine
      S        Serine
      T        Threonine
      V        Valine
      W        Tryptophan
      X        Unknown
      Y        Tyrosine
      Z        Glutamic Acid, Glutamine
      *        Terminator

     IUPAC-IUP AMINO ACID SYMBOLS:
       Biochem J. 1984 Apr 15; 219(2): 345-373
       Eur J Biochem. 1993 Apr 1; 213(1): 2

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://www.bioperl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bioperl.org
     http://www.bioperl.org/bioperl-bugs/

AUTHOR - Aaron Mackey
=====================

   Email amackey@virginia.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
---

     Title   : new
     Usage   : new Bio::Tools::IUPAC $seq;
     Function: returns a new seq stream (akin to SeqIO)
     Returns : a Bio::Tools::IUPAC stream object that will produce unique
               Seq objects on demand.
     Args    : an ambiguously coded Seq.pm object that has a specified 'type'

next_seq
--------

     Title   : next_seq
     Usage   : $iupac->next_seq()
     Function: returns the next unique Seq object
     Returns : a Seq.pm object
     Args    : none.


File: pm.info,  Node: Bio/Tools/MZEF,  Next: Bio/Tools/OddCodes,  Prev: Bio/Tools/IUPAC,  Up: Module List

Results of one MZEF run
***********************

NAME
====

   Bio::Tools::MZEF - Results of one MZEF run

SYNOPSIS
========

     $mzef = Bio::Tools::MZEF->new(-file => 'result.mzef');
     # filehandle:
     $mzef = Bio::Tools::MZEF->new( -fh  => \*INPUT );
     # to indicate that the sequence was reversed prior to feeding it to MZEF
     # and that you want to have this reflected in the strand() attribute of
     # the exons, as well have the coordinates translated to the non-reversed
     # sequence
     $mzef = Bio::Tools::MZEF->new( -file   => 'result.mzef',
                                    -strand => -1 );

     # parse the results
     # note: this class is-a Bio::Tools::AnalysisResult which implements
     # Bio::SeqAnalysisParserI, i.e., $genscan->next_feature() is the same
     while($gene = $mzef->next_prediction()) {
         # $gene is an instance of Bio::Tools::Prediction::Gene

     # $gene->exons() returns an array of
     # Bio::Tools::Prediction::Exon objects
     # all exons:
     @exon_arr = $gene->exons();

     # internal exons only
     @intrl_exons = $gene->exons('Internal');
     # note that presently MZEF predicts only internal exons!
        }

     # essential if you gave a filename at initialization (otherwise the file
     # will stay open)
     $mzef->close();

DESCRIPTION
===========

   The MZEF module provides a parser for MZEF gene structure prediction
output.

   This module inherits off *Note Bio/Tools/AnalysisResult:
Bio/Tools/AnalysisResult, and therefore implements *Note
Bio/SeqAnalysisParserI: Bio/SeqAnalysisParserI,.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp
====================

   Email hlapp@gmx.net (or hilmar.lapp@pharma.novartis.com)

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

analysis_method
---------------

     Usage     : $mzef->analysis_method();
     Purpose   : Inherited method. Overridden to ensure that the name matches
                 /mzef/i.
     Returns   : String
     Argument  : n/a

next_feature
------------

     Title   : next_feature
     Usage   : while($gene = $mzef->next_feature()) {
                      # do something
               }
     Function: Returns the next gene structure prediction of the MZEF result
               file. Call this method repeatedly until FALSE is returned.

     The returned object is actually a SeqFeatureI implementing object.
     This method is required for classes implementing the
     SeqAnalysisParserI interface, and is merely an alias for
     next_prediction() at present.

     Note that with the present version of MZEF there will only be one
     object returned, because MZEF does not predict individual genes
     but just potential internal exons.
      Example :
      Returns : A Bio::Tools::Prediction::Gene object.
      Args    :

next_prediction
---------------

     Title   : next_prediction
     Usage   : while($gene = $mzef->next_prediction()) {
                      # do something
               }
     Function: Returns the next gene structure prediction of the MZEF result
               file. Call this method repeatedly until FALSE is returned.

     Note that with the present version of MZEF there will only be one
     object returned, because MZEF does not predict individual genes
     but just potential internal exons.
      Example :
      Returns : A Bio::Tools::Prediction::Gene object.
      Args    :

_parse_predictions
------------------

     Title   : _parse_predictions()
     Usage   : $obj->_parse_predictions()
     Function: Parses the prediction section. Automatically called by
               next_prediction() if not yet done.
     Example :
     Returns :

_prediction
-----------

     Title   : _prediction()
     Usage   : $gene = $obj->_prediction()
     Function: internal
     Example :
     Returns :

_add_prediction
---------------

     Title   : _add_prediction()
     Usage   : $obj->_add_prediction($gene)
     Function: internal
     Example :
     Returns :

_predictions_parsed
-------------------

     Title   : _predictions_parsed
     Usage   : $obj->_predictions_parsed
     Function: internal
     Example :
     Returns : TRUE or FALSE


File: pm.info,  Node: Bio/Tools/OddCodes,  Next: Bio/Tools/Prediction/Exon,  Prev: Bio/Tools/MZEF,  Up: Module List

Object holding alternative alphabet coding for  one protein sequence
********************************************************************

NAME
====

   Bio::Tools::OddCodes - Object holding alternative alphabet coding for
one protein sequence

SYNOPSIS
========

   Take a sequence object from eg, an inputstream, and creates an object
for the purposes of rewriting that sequence in another alphabet.  These
are abbreviated amino acid sequence alphabets, designed to simplify the
statistical aspects of analysing protein sequences, by reducing the
combinatorial explosion of the 20-letter alphabet.  These abbreviated
alphabets range in size from 2 to 8.

   Creating the OddCodes object, eg:

     my $inputstream = Bio::SeqIO->new( '-file' => "seqfile",
                                                '-format' => 'Fasta');
     my $seqobj = $inputstream->next_seq();
     my $oddcode_obj = Bio::Tools::Oddcodes->new(-seq => $seqobj);

   or:

     my $seqobj = Bio::PrimarySeq->new
                   (-seq=>'[cut and paste a sequence here]',
                    -moltype = 'protein',
                    -id = 'test');
     my $oddcode_obj  =  Bio::Tools::OddCodes->new(-seq => $seqobj);

   do the alternative coding, returning the answer as a reference to a
string

     my $output = $oddcode_obj->structural();
     my $output = $oddcode_obj->chemical();
     my $output = $oddcode_obj->functional();
     my $output = $oddcode_obj->charge();
     my $output = $oddcode_obj->hydrophobic();
     my $output = $oddcode_obj->Dayhoff();
     my $output = $oddcode_obj->Sneath();
     my $output = $oddcode_obj->Stanfel();

   display sequence in new form, eg:

     my $new_coding = $$output;
     print "\n$new_coding";

DESCRIPTION
===========

   Bio::Tools::Oddcodes is a welterweight object for rewriting a protein
sequence in an alternative alphabet.  8 of these are provided, ranging
from the the 2-letter hydrophobic alphabet, to the 8-letter chemical
alphabet.  These are useful for the statistical analysis of protein
sequences since they can partially avoid the combinatorial explosion
produced by the full 20-letter alphabet (eg. 400 dimers, 8000 trimers etc.)

   See Synopsis above for object creation code.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                - General discussion
     http://www.bioperl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bioperl.org
     http://www.bioperl.org/bioperl-bugs/

AUTHOR
======

   Derek Gatherer

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

structural
----------

     Title   : structural
     Usage   : $output = $oddcode_obj->structural();
     Function: turns amino acid sequence into 3-letter structural alphabet
     	 : A (ambivalent), E (external), I (internal)
     Example : a sequence ACDEFGH will become AAEEIAE
     Returns : Reference to the new sequence string
     Args    : none

functional
----------

     Title   : functional
     Usage   : $output = $oddcode_obj->functional();
     Function: turns amino acid sequence into 4-letter functional alphabet
     	 : A (acidic), C (basic), H (hydrophobic), P (polar)
     Example : a sequence ACDEFGH will become HPAAHHC
     Returns : Reference to the new sequence string
     Args    : none

hydrophobic
-----------

     Title   : hydrophobic
     Usage   : $output = $oddcode_obj->hydrophobic();
     Function: turns amino acid sequence into 2-letter hydrophobicity alphabet
     	 : O (hydrophobic), I (hydrophilic)
     Example : a sequence ACDEFGH will become OIIIOII
     Returns : Reference to the new sequence string
     Args    : none

Dayhoff
-------

     Title   : Dayhoff
     Usage   : $output = $oddcode_obj->Dayhoff();
     Function: turns amino acid sequence into 6-letter Dayhoff alphabet
     Example : a sequence ACDEFGH will become CADDGCE
     Returns : Reference to the new sequence string
     Args    : none

Sneath
------

     Title   : Sneath
     Usage   : $output = $oddcode_obj->Sneath();
     Function: turns amino acid sequence into 7-letter Sneath alphabet
     Example : a sequence ACDEFGH will become CEFFHCF
     Returns : Reference to the new sequence string
     Args    : none

Stanfel
-------

     Title   : Stanfel
     Usage   : $output = $oddcode_obj->Stanfel();
     Function: turns amino acid sequence into 4-letter Stanfel alphabet
     Example : a sequence ACDEFGH will become AACCDAE
     Returns : Reference to the new sequence string
     Args    : none

chemical()
----------

     Title   : chemical
     Usage   : $output = $oddcode_obj->chemical();
     Function: turns amino acid sequence into 8-letter chemical alphabet
     	 : A (acidic), L (aliphatic), M (amide), R (aromatic)
     	 : C (basic), H (hydroxyl), I (imino), S (sulphur)
     Example : a sequence ACDEFGH will become LSAARAC
     Returns : Reference to the new sequence string
     Args    : none

charge
------

     Title   : charge
     Usage   : $output = $oddcode_obj->charge();
     Function: turns amino acid sequence into 3-letter charge alphabet
     Example : a sequence ACDEFGH will become NNAANNC
     Returns : Reference to the new sequence string
     Args    : none


File: pm.info,  Node: Bio/Tools/Prediction/Exon,  Next: Bio/Tools/Prediction/Gene,  Prev: Bio/Tools/OddCodes,  Up: Module List

A predicted exon feature
************************

NAME
====

   Bio::Tools::Prediction::Exon - A predicted exon feature

SYNOPSIS
========

   See documentation of methods.

DESCRIPTION
===========

   A feature representing a predicted exon. This class actually inherits
off Bio::SeqFeature::Gene::Exon and therefore has all that functionality
(also implements Bio::SeqFeatureI), plus a few methods supporting
predicted features, like various scores and a significance. Even though
these were inspired by GenScan results, at least a subset should be
generally useable for exon prediction results.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp
====================

   Email hlapp@gmx.net

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

predicted_cds
-------------

     Title   : predicted_cds
     Usage   : $predicted_cds_dna = $exon->predicted_cds();
               $exon->predicted_cds($predicted_cds_dna);
     Function: Get/Set the CDS (coding sequence) as predicted by a program.

     This method is independent of an attached_seq. There is no
     guarantee whatsoever that the returned CDS has anything to do
     (e.g., matches) with the sequence covered by the exons as annotated
     through this object.

     Example :
     Returns : A Bio::PrimarySeqI implementing object holding the DNA sequence
               defined as coding by a prediction of a program.
     Args    : On set, a Bio::PrimarySeqI implementing object holding the DNA
               sequence defined as coding by a prediction of a program.

predicted_protein
-----------------

     Title   : predicted_protein
     Usage   : $predicted_protein_seq = $exon->predicted_protein();
               $exon->predicted_protein($predicted_protein_seq);
     Function: Get/Set the protein translation as predicted by a program.

     This method is independent of an attached_seq. There is no
     guarantee whatsoever that the returned translation has anything to
     do with the sequence covered by the exons as annotated
     through this object, or the sequence returned by predicted_cds(),
     although it should usually be just the standard translation.

     Example :
     Returns : A Bio::PrimarySeqI implementing object holding the protein
               translation as predicted by a program.
     Args    : On set, a Bio::PrimarySeqI implementing object holding the protein
               translation as predicted by a program.

significance
------------

     Title   : significance
     Usage   : $evalue = $obj->significance();
               $obj->significance($evalue);
     Function:
     Returns :
     Args    :

start_signal_score
------------------

     Title   : start_signal_score
     Usage   : $sc = $obj->start_signal_score();
               $obj->start_signal_score($evalue);
     Function: Get/Set a score for the exon start signal (acceptor splice site
               or initiation signal).
     Returns :
     Args    :

end_signal_score
----------------

     Title   : end_signal_score
     Usage   : $sc = $obj->end_signal_score();
               $obj->end_signal_score($evalue);
     Function: Get/Set a score for the exon end signal (donor splice site
               or termination signal).
     Returns :
     Args    :

coding_signal_score
-------------------

     Title   : coding_signal_score
     Usage   : $sc = $obj->coding_signal_score();
               $obj->coding_signal_score($evalue);
     Function: Get/Set a score for the exon coding signal (e.g., coding potential).
     Returns :
     Args    :


File: pm.info,  Node: Bio/Tools/Prediction/Gene,  Next: Bio/Tools/RestrictionEnzyme,  Prev: Bio/Tools/Prediction/Exon,  Up: Module List

a predicted gene structure feature
**********************************

NAME
====

   Bio::Tools::Prediction::Gene - a predicted gene structure feature

SYNOPSIS
========

   See documentation of methods.

DESCRIPTION
===========

   A feature representing a predicted gene structure. This class actually
inherits off Bio::SeqFeature::Gene::Transcript and therefore has all that
functionality, plus a few methods supporting predicted sequence features,
like a predicted CDS and a predicted translation.

   Exons held by an instance of this class will usually be instances of
Bio::Tools::Prediction::Exon, although they do not have to be. Refer to the
documentation of the class that produced the instance.

   Normally, you will not want to create an instance of this class
yourself.  Instead, classes representing the results of gene structure
prediction programs will do that.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp
====================

   Email hlapp@gmx.net or hilmar.lapp@pharma.novartis.com

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

predicted_cds
-------------

     Title   : predicted_cds
     Usage   : $predicted_cds_dna = $gene->predicted_cds();
               $gene->predicted_cds($predicted_cds_dna);
     Function: Get/Set the CDS (coding sequence) as predicted by a program.

     This method is independent of an attached_seq. There is no
     guarantee whatsoever that the returned CDS has anything to do
     (e.g., matches) with the sequence covered by the exons as annotated
     through this object.

     Example :
     Returns : A Bio::PrimarySeqI implementing object holding the DNA sequence
               defined as coding by a prediction of a program.
     Args    : On set, a Bio::PrimarySeqI implementing object holding the DNA
               sequence defined as coding by a prediction of a program.

predicted_protein
-----------------

     Title   : predicted_protein
     Usage   : $predicted_protein_seq = $gene->predicted_protein();
               $gene->predicted_protein($predicted_protein_seq);
     Function: Get/Set the protein translation as predicted by a program.

     This method is independent of an attached_seq. There is no
     guarantee whatsoever that the returned translation has anything to
     do with the sequence covered by the exons as annotated
     through this object, or the sequence returned by predicted_cds(),
     although it should usually be just the standard translation.

     Example :
     Returns : A Bio::PrimarySeqI implementing object holding the protein
               translation as predicted by a program.
     Args    : On set, a Bio::PrimarySeqI implementing object holding the protein
               translation as predicted by a program.


File: pm.info,  Node: Bio/Tools/RestrictionEnzyme,  Next: Bio/Tools/Run/Alignment/Clustalw,  Prev: Bio/Tools/Prediction/Gene,  Up: Module List

Bioperl object for a restriction endonuclease object.
*****************************************************

NAME
====

   Bio::Tools::RestrictionEnzyme.pm - Bioperl object for a restriction
endonuclease object.

SYNOPSIS
========

Object Creation
---------------

     require Bio::Tools::RestrictionEnzyme;

     ## Create a new object by name.

     $re1 = new Bio::Tools::RestrictionEnzyme(-NAME =>'EcoRI');

     ## Create a new object using special syntax
     ## which specifies the enzyme name, recognition site, and cut position.
     ## Used for enzymes not known to this module.

     $re2 = new Bio::Tools::RestrictionEnzyme(-NAME =>'EcoRV--GAT^ATC',
     				  	     -MAKE =>'custom');

INSTALLATION
============

   This module is included with the central Bioperl distribution:

     http://bio.perl.org/Core/Latest
     ftp://bio.perl.org/pub/DIST

   Follow the installation instructions included in the README file.

DESCRIPTION
===========

   The Bio::Tools::RestrictionEnzyme.pm module encapsulates generic data
and methods for using restriction endonucleases for in silico restriction
analysis of DNA sequences.

Considerations
--------------

   This module is a precursor for a more full featured version that may do
such things as download data from online databases such as REBase
http://www.neb.com/rebase/.  Thus, there is currently no functionality for
obtaining data about commercial availability for a restriction enzyme.

   At some point in the future, it may be best to derive
RestrictionEnzymes from a class such as Bio::Enzyme.pm or
Bio::Prot::Protein.pm so that more data about the enzyme and related
information can be easily obtained.

   This module is currently in use at

     http://genome-www.stanford.edu/Sacch3D/analysis/

   *This module is at an early stage of development and is not yet ready
for general use. API documentation is presently incomplete.*

DEPENDENCIES
============

   Bio::Tools::RestrictionEnzyme.pm is a concrete class that inherits from
*Bio::Root::Object.pm* and uses by delegation *Bio::Seq.pm*.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules.  Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR
======

   Steve A. Chervitz, sac@genome.stanford.edu

VERSION
=======

   Bio::Tools::RestrictionEnzyme.pm, 0.04

COPYRIGHT
=========

   Copyright (c) 1997-8 Steve A. Chervitz. All Rights Reserved.  This
module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

SEE ALSO
========

     Bio::Root::Object.pm    - Base class.
     Bio::Seq.pm             - Lightweight sequence object.

     http://bio.perl.org/Projects/modules.html  - Online module documentation
     http://bio.perl.org/Projects/Blast/        - Bioperl Blast Project
     http://bio.perl.org/                       - Bioperl Project Homepage

APPENDIX
========

   Methods beginning with a leading underscore are considered private and
are intended for internal use by this module. They are not considered part
of the public interface and are described here for documentation purposes
only.

new
===

     Title     : new
     Purpose   : Initializes the RestrictionEnzyme object and calls
               : superclass constructor last (Bio:Seq.pm).
     Returns   : n/a
     Argument  : Parameters passed to new()
     Comments  : The process of creating a new SeqPattern.pm object
               : ensures that the pattern string is untained.

   See Also   : `_make_custom' in this node(), `_make_standard' in this
node(), *Bio::Seq.pm::_initialize()*

_make_standard
==============

     Title     : _make_standard
     Usage     : n/a; automatically called by _initialize()
     Purpose   : Permits custom RE object construction from name.
               : 'EcoRI'.
     Returns   : Hash containing named parameters for Bio::Seq.pm constructor.
     Argument  : String containing string with special syntax.
     Throws    : Exception if the requested enzyme name is unavailable.
               : NOTE: Case sensitive.

   See Also   : `_initialize' in this node(), `_make_custom' in this node()

_make_custom
============

     Title     : _make_custom
     Usage     : n/a; automatically called by _initialize()
     Purpose   : Permits custom RE object construction from strings
               : such as 'EcoRI--G^AATTC' as the name of the enzyme.
     Returns   : Hash containing named parameters for Bio::Seq.pm constructor.
     Argument  : String containing string with special syntax.
     Throws    : Exception if the string has bad syntax.
               : Warning if the string did not specify cut position.
               :         Places cut site after 5'-most position.

   See Also   : `_initialize' in this node()

cuts_after
==========

     Title     : cuts_after
     Usage     : $re->cuts_after();
     Purpose   : Sets/Gets the position of cleavage relative to the 5' end.
     Example   : $num = $re->cuts_after()
     Returns   : Integer
     Argument  : Integer (optional)
     Throws    : Exception if argument is non-numeric.
     Access    : Public
     Comments  : This method is only needed to change the cuts at
               : position. This data is automatically set during
               : construction.

   See Also   : `_make_standard' in this node(), `_make_custom' in this
node()

site
====

     Title     : site
     Usage     : $re->site();
     Purpose   : Gets the recognition sequence for the enzyme.
     Example   : $seq_string = $re->site();
     Returns   : String containing recognition sequence indicating
               : cleavage site as in  'G^AATTC'.
     Argument  : n/a
     Throws    : n/a

seq
===

     Title     : seq
     Usage     : $re->seq();
     Purpose   : Get the Bio::Seq.pm-derived object representing
               : the recognition sequence
     Returns   : String
     Argument  : n/a
     Throws    : n/a

   See Also   : `string' in this node(), `revcom' in this node()

string
======

     Title     : string
     Usage     : $re->string();
     Purpose   : Get a string representing the recognition sequence.
     Returns   : String
     Argument  : n/a
     Throws    : n/a
     Comments  : Delegates to the Bio::Seq.pm-derived object.

   See Also   : `seq' in this node(), `revcom' in this node()

revcom
======

     Title     : revcom
     Usage     : $re->revcom();
     Purpose   : Get a string representing the reverse complement of
               : the recognition sequence.
     Returns   : String
     Argument  : n/a
     Throws    : n/a
     Comments  : Delegates to the Bio::Seq.pm-derived object, but needs to get
                 out the string from it, as now Bio::Seq->revcom makes a Bio::Seq
                 object

   See Also   : `seq' in this node(), `string' in this node()

cut_seq
=======

     Title     : cut_seq
     Usage     : $re->cut_seq(<sequence object>);
     Purpose   : Conceptually cut or "digest" a DNA sequence with the given enzyme.
     Example   : $string = $re->cut_seq(<sequence object>);
     Returns   : List of strings containing the resulting fragments.
     Argument  : Reference to a Bio::Seq.pm-derived object.
     Throws    : Exception if argument is not an object.
               : (Does not yet verify that it is derived from Bio::Seq.pm.)
     Comments  : Strategy relies on Perl's built-in split() function.
               : Since split removes the recognition pattern, the resulting
               : fragments must be repaired after split()-ing.
               : There is currently no support for partial digestions.

cut_locations
=============

     Title     : cut_locations
     Usage     : my $locations = $re->cut_locations(<sequence_object>);
     Purpose   : Report the location of the recognition site(s) within
               : an input sequence.
     Example   : my $locations = $re->annotate_seq($seqObj);
     Returns   : Arrayref of starting locations where enzyme would cut
     Argument  : Reference to a Bio::SeqI-derived sequence object.
     Throws    : n/a
     Comments  :

annotate_seq
============

     Title     : annotate_seq
     Usage     : $re->annotate_seq(<sequence_object>);
     Purpose   : Identify the location of the recognition site(s) within
               : an input sequence. Uses HTML.
     Example   : $annot_seq = $re->annotate_seq($seqObj);
     Returns   : String containing the annotated sequence.
     Argument  : Reference to a Bio::Seq.pm-derived sequence object.
     Throws    : n/a
     Comments  : The annotated sequence must be viewed with a web
               : browser to see the location(s) of the recognition site(s).

palindromic
===========

     Title     : palindromic
     Usage     : $re->palindromic();
     Purpose   : Determines if the recognition sequence is palindromic
               : for the current restriction enzyme.
     Returns   : Boolean
     Argument  : n/a
     Throws    : n/a
     Access    : Public
     Comments  : A palindromic site (EcoRI): 5-GAATTC-3
               :                             3-CTTAAG-5

is_available
============

     Title     : is_available
     Usage     : $re->is_available(<string containing name of enzyme>);
     Purpose   : Determine if an enzyme is available (to this module).
               : (see the package lexical %RE).
     Example   : $re->is_available('EcoRI');
               : &Bio::Tools::RestrictionEnzyme::is_available($object,'EcoRI');
     Returns   : Boolean
     Argument  : String
     Throws    : n/a
     Comments  : This method does NOT give information about
               : commercial availability (yet).
               : Enzyme names are CASE SENSITIVE.

   See Also   : `available_list' in this node()

name
----

     Title   : name
     Usage   : $obj->name($newval)
     Function:
     Example :
     Returns : value of name
     Args    : newvalue (optional)

available_list
==============

     Title     : available_list
     Usage     : $re->available_list([<integer>]);
     Purpose   : Retrieve a list of currently available enzymes.
     Example   : @all = $re->available_list();  ## All enzymes
               : @six_cutters = $re->available_list(6);  ## All 6-cutters
     Returns   : List of strings
     Argument  : Integer (optional)
     Throws    : n/a
     Comments  : This method may be more appropriate for a REData.pm class.

   See Also   : `is_available' in this node()

FOR DEVELOPERS ONLY
===================

Data Members
------------

   Information about the various data members of this module is provided
for those wishing to modify or understand the code. Two things to bear in
mind:

  1. Do NOT rely on these in any code outside of this module.  All data
     members are prefixed with an underscore to signify that they are
     private.  Always use accessor methods. If the accessor doesn't exist
     or is inadequate, create or modify an accessor (and let me know,
     too!).

  2. This documentation may be incomplete and out of date.  It is easy for
     this documentation to become obsolete as this module is still
     evolving.  Always double check this info and search for members not
     described here.

        An instance of Bio::Tools::RestrictionEnzyme.pm is a blessed
reference to a hash containing all or some of the following fields:

     FIELD          VALUE
     ------------------------------------------------------------------------
     _seq         : A Bio::Seq.pm-derived object.
                  :
     _site        : String containing the recognition sequence.
                  :
     _cuts_after  : Integer indicating the cleavage position relative to the
                  : 5' end of the recognition sequence.
     
     INHERITED DATA MEMBERS:

     _name      : (From Bio::Bio::Root::Object.pm) String containing name of the enzyme.


File: pm.info,  Node: Bio/Tools/Run/Alignment/Clustalw,  Next: Bio/Tools/Run/Alignment/TCoffee,  Prev: Bio/Tools/RestrictionEnzyme,  Up: Module List

Object for the calculation of a multiple sequence alignment from a set of unaligned sequences or alignments using the Clustalw program
**************************************************************************************************************************************

NAME
====

   Bio::Tools::Run::Alignment::Clustalw - Object for the calculation of a
multiple sequence alignment from a set of unaligned sequences or
alignments using the Clustalw program

SYNOPSIS
========

     #  Build a clustalw alignment factory
     @params = ('ktuple' => 2, 'matrix' => 'BLOSUM');
     $factory = Bio::Tools::Run::Alignment::Clustalw->new(@params);

     #  Pass the factory a list of sequences to be aligned.
     $inputfilename = 't/cysprot.fa';
     $aln = $factory->align($inputfilename); # $aln is a SimpleAlign object.
     # or
     $seq_array_ref = \@seq_array;
     # where @seq_array is an array of Bio::Seq objects
     $aln = $factory->align($seq_array_ref);

     # Or one can pass the factory a pair of (sub)alignments
     #to be aligned against each other, e.g.:
     $aln = $factory->profile_align($aln1,$aln2);
     # where $aln1 and $aln2 are Bio::SimpleAlign objects.

     # Or one can pass the factory an alignment and one or more unaligned
     # sequences to be added to the alignment. For example:
     $aln = $factory->profile_align($aln1,$seq); # $seq is a Bio::Seq object.

   There are various additional options and input formats available.  See
the DESCRIPTION section that follows for additional details.

DESCRIPTION
===========

   Note: this DESCRIPTION only documents the (Bio)perl interface to
Clustalw.  Clustalw, itself, is a large & complex program - for more
information regarding clustalw, please see the clustalw documentation
which accompanies the clustalw distribution. Clustalw is available from
(among others) ftp://ftp.ebi.ac.uk/pub/software/. Clustalw.pm has been
tested so far only under Linux. I expect that it should also work under
other Unix systems.  However, since the module is currently implemented
using (unix) system calls, extensive modification may be necessary before
Clustalw.pm would work under non-Unix operating systems (eg Windows,
MacOS).  Clustalw.pm has only been tested using version 1.8 of clustalw.
Compatibility with earlier versions of the clustalw program is currently
unknown. Before running Clustalw.pm successfully it will be necessary: to
install clustalw on your system, to edit the variable $clustdir in
Clustalw.pm to point to the clustalw program, and to ensure that users
have execute privilieges for the clustalw program.

   Bio::Tools::Run::Alignment::Clustalw.pm: is an object for performing a
multiple sequence alignment from a set of unaligned sequences and/or
sub-alignments by means of the clustalw program.

   Initially, a clustalw "factory object" is created. Optionally, the
factory may be passed most of the parameters or switches of the clustalw
program, e.g.:

     @params = ('ktuple' => 2, 'matrix' => 'BLOSUM');
     $factory = Bio::Tools::Run::Alignment::Clustalw->new(@params);

   Any parameters not explicitly set will remain as the defaults of the
clustalw program.  Additional parameters and switches (not available in
clustalw) may also be set.  Currently, the only such parameter is "quiet",
which when set to a non-zero value, suppresses clustalw terminal output.
Not all clustalw parameters are supported at this stage.

   By default, Clustalw.pm output is returned solely in a the form of a
BioPerl Bio::SimpleAlign object which can then be printed and/or saved in
multiple formats using the AlignIO.pm module. Optionally the raw clustalw
output file can be saved if the calling script specifies an output file
(with the clustalw parameter OUTFILE).  Currently only the GCG-MSF output
file formats is supported.

   Other parameters and features (such as those corresponding to tree
production) have not been implemented yet in Perl format.

   Alignment parameters can be changed and/or examined at any time after
the factory has been created.  The program checks that any
parameter/switch being set/read is valid.  However, currently no
additional checks are included to check that parameters are of the proper
type (eg string or numeric) or that their values are within the proper
range.  As an example, to change the value of the clustalw parameter
ktuple to 3 and subsequently to check its value one would write:

     $ktuple = 3;
     $factory->ktuple($ktuple);
      	$get_ktuple = $factory->ktuple();

   Once the factory has been created and the appropriate parameters set,
one can call the method align() to align a set of unaligned sequences, or
call profile_align() to add one or more sequences or a second alignment to
an initial alignment.

   Input to align() may consist of a set of unaligned sequences in the
form of the name of file containing the sequences. For example,
$inputfilename = 't/cysprot.fa'; $aln = $factory->align($inputfilename);

   Alternately one can create an array of Bio::Seq objects somehow

     $str = Bio::SeqIO->new(-file=> 't/cysprot.fa', '-format' => 'Fasta');
     @seq_array =();
     while ( my $seq = $str->next_seq() ) {push (@seq_array, $seq) ;}

   and pass the factory a reference to that array

     $seq_array_ref = \@seq_array;
     $aln = $factory->align($seq_array_ref);

   In either case, align() returns a reference to a SimpleAlign object
which can then be displayed, stored, or converted to a UnivAlign object
for further manipulation.

   Once an initial alignment exists, one can pass the factory additional
sequence(s) to be added (ie aligned) to the original alignment.  The
alignment can be passed as either an alignment file or a Bio:SimpleAlign
object.  The unaligned sequence(s) can be passed as a filename or as an
array of BioPerl sequence objects or as a single BioPerl Seq object.  For
example (to add a single sequence to an alignment),

     $str = Bio::AlignIO->new(-file=> 't/cysprot1a.msf');
     $aln = $str->next_aln();
     $str1 = Bio::SeqIO->new(-file=> 't/cysprot1b.fa');
     $seq = $str1->next_seq();
     $aln = $factory->profile_align($aln,$seq);

   In either case, profile_align() returns a reference to a SimpleAlign
object containing a new SimpleAlign object of the alignment with the
additional sequence(s) added in.

   Finally one can pass the factory a pair of (sub)alignments to be
aligned against each other.  The alignments can be passed in the form of
either a pair of alignment files or a pair of Bio:SimpleAlign objects. For
example,

     $profile1 = 't/cysprot1a.msf';
     $profile2 = 't/cysprot1b.msf';
     $aln = $factory->profile_align($profile1,$profile2);
     or
     $str1 = Bio::AlignIO->new(-file=> 't/cysprot1a.msf');
     $aln1 = $str1->next_aln();
     $str2 = Bio::AlignIO->new(-file=> 't/cysprot1b.msf');
     $aln2 = $str2->next_aln();
     $aln = $factory->profile_align($aln1,$aln2);

   In either case, profile_align() returns a reference to a SimpleAlign
object containing an (super)alignment of the two input alignments.

   For more examples of syntax and use of Clustalw.pm, the user is
encouraged to run the script Clustalw.t is the bioperl/t directory.

   Note: Clustalw.pm is still under development. Various features of the
clustalw program have not yet been implemented.  If you would like that a
specific clustalw feature be added to this perl interface, let me know.

   These can be specified as paramters when instantiating a new TCoffee
object, or through get/set methods of the same name (lowercase).

PARAMETER FOR ALIGNMENT COMPUTATION
===================================

KTUPLE
------

     Title       : KTUPLE
     Description : (optional) set the word size to be used in the alignment
                   This is the size of exactly matching fragment that is used.
                   INCREASE for speed (max= 2 for proteins; 4 for DNA),
                   DECREASE for sensitivity.
                   For longer sequences (e.g. >1000 residues) you may
                   need to increase the default

TOPDIAGS
--------

     Title       : TOPDIAGS
     Description : (optional) number of best diagonals to use
                   The number of k-tuple matches on each diagonal
                   (in an imaginary dot-matrix plot) is calculated.
                   Only the best ones (with most matches) are used in
                   the alignment.  This parameter specifies how many.
                   Decrease for speed; increase for sensitivity.

WINDOW
------

     Title       : WINDOW
     Description : (optional) window size
                   This is the number of diagonals around each of the 'best'
                   diagonals that will be used.  Decrease for speed;
                   increase for sensitivity.

PAIRGAP
-------

     Title       : PAIRGAP
     Description : (optional) gap penalty for pairwise alignments
                   This is a penalty for each gap in the fast alignments.
                   It has little affect on the speed or sensitivity except
                   for extreme values.

FIXEDGAP
--------

     Title       : FIXEDGAP
     Description : (optional) fixed length gap penalty

FLOATGAP
--------

     Title       : FLOATGAP
     Description : (optional) variable length gap penalty

MATRIX
------

     Title       : MATRIX
     Default     : PAM100 for DNA - PAM250 for protein alignment
     Description : (optional) substitution matrix used in the multiple
                   alignments. Depends on the version of clustalw as to
                   what default matrix will be used

     PROTEIN WEIGHT MATRIX leads to a new menu where you are
     offered a choice of weight matrices. The default for
     proteins in version 1.8 is the PAM series derived by
     Gonnet and colleagues. Note, a series is used! The
     actual matrix that is used depends on how similar the
     sequences to be aligned at this alignment step
     are. Different matrices work differently at each
     evolutionary distance.

     DNA WEIGHT MATRIX leads to a new menu where a single
     matrix (not a series) can be selected. The default is
     the matrix used by BESTFIT for comparison of nucleic
     acid sequences.

TYPE
----

     Title       : TYPE
     Description : (optional) sequence type: protein or DNA. This allows
     	       you to explicitly overide the programs attempt at
     	       guessing the type of the sequence.  It is only useful
     	       if you are using sequences with a VERY strange
     	       composition.

OUTPUT
------

     Title       : OUTPUT
     Description : (optional) clustalw supports GCG or PHYLIP or PIR or
                    Clustal format.  See the Bio::AlignIO modules for
                    which formats are supported by bioperl.

OUTFILE
-------

     Title       : OUTFILE
     Description : (optional) Name of clustalw output file. If not set
     	       module will erase output file.  In any case alignment will
     	       be returned in the form of SimpleAlign objects

TRANSMIT
--------

     Title       : TRANSMIT
     Description : (optional) transitions not weighted.  The default is to
     	       weight transitions as more favourable than other
     	       mismatches in DNA alignments.  This switch makes all
     	       nucleotide mismatches equally weighted.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via  email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR -  Peter Schattner
=========================

   Email schattner@alum.mit.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

exists_clustal()
----------------

     Title   : exists_clustal
     Usage   : $clustalfound = Bio::Tools::Run::Alignment::Clustalw->exists_clustal()
     Function: Determine whether clustalw program can be found on current host
     Example :
     Returns : 1 if clustalw program found at expected location, 0 otherwise.
     Args    :  none

align
-----

     Title   : align
     Usage   :
     	$inputfilename = 't/cysprot.fa';
     	$aln = $factory->align($inputfilename);
     or
     	$seq_array_ref = \@seq_array; @seq_array is array of Seq objs
     	$aln = $factory->align($seq_array_ref);
     Function: Perform a multiple sequence alignment
     Example :
     Returns : Reference to a SimpleAlign object containing the
               sequence alignment.
     Args    : Name of a file containing a set of unaligned fasta sequences
               or else an array of references to Bio::Seq objects.

     Throws an exception if argument is not either a string (eg a
     filename) or a reference to an array of Bio::Seq objects.  If
     argument is string, throws exception if file corresponding to string
     name can not be found. If argument is Bio::Seq array, throws
     exception if less than two sequence objects are in array.

profile_align
-------------

     Title   : profile_align
     Usage   :
     Function: Perform an alignment of 2 (sub)alignments
     Example :
     Returns : Reference to a SimpleAlign object containing the (super)alignment.
     Args    : Names of 2 files containing the subalignments
             or references to 2 Bio::SimpleAlign objects.

   Throws an exception if arguments are not either strings (eg filenames)
or references to SimpleAlign objects.

_run
----

     Title   :  _run
     Usage   :  Internal function, not to be called directly
     Function:   makes actual system call to clustalw program
     Example :
     Returns : nothing; clustalw output is written to a
               temporary file $TMPOUTFILE
     Args    : Name of a file containing a set of unaligned fasta sequences
               and hash of parameters to be passed to clustalw

_setinput()
-----------

     Title   :  _setinput
     Usage   :  Internal function, not to be called directly
     Function:   Create input file for clustalw program
     Example :
     Returns : name of file containing clustalw data input
     Args    : Seq or Align object reference or input file name

_setparams()
------------

     Title   :  _setparams
     Usage   :  Internal function, not to be called directly
     Function:   Create parameter inputs for clustalw program
     Example :
     Returns : parameter string to be passed to clustalw
               during align or profile_align
     Args    : name of calling object


