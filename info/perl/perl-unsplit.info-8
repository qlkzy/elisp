This is Info file perl.info, produced by Makeinfo version 1.68 from the
input file bigperl.texi.

   settitle perl


File: perl.info,  Node: perltie,  Next: perlbot,  Prev: perlobj,  Up: Top

how to hide an object class in a simple variable
************************************************

NAME
====

   perltie - how to hide an object class in a simple variable

SYNOPSIS
========

     tie VARIABLE, CLASSNAME, LIST

     $object = tied VARIABLE

     untie VARIABLE

DESCRIPTION
===========

   Prior to release 5.0 of Perl, a programmer could use dbmopen() to
connect an on-disk database in the standard Unix dbm(3x) format magically
to a %HASH in their program.  However, their Perl was either built with
one particular dbm library or another, but not both, and you couldn't
extend this mechanism to other packages or types of variables.

   Now you can.

   The tie() function binds a variable to a class (package) that will
provide the implementation for access methods for that variable.  Once
this magic has been performed, accessing a tied variable automatically
triggers method calls in the proper class.  The complexity of the class is
hidden behind magic methods calls.  The method names are in ALL CAPS,
which is a convention that Perl uses to indicate that they're called
implicitly rather than explicitly-just like the BEGIN() and END()
functions.

   In the tie() call, VARIABLE is the name of the variable to be
enchanted.  `CLASSNAME' is the name of a class implementing objects of the
correct type.  Any additional arguments in the LIST are passed to the
appropriate constructor method for that class-meaning TIESCALAR(),
TIEARRAY(), TIEHASH(), or TIEHANDLE().  (Typically these are arguments
such as might be passed to the dbminit() function of C.) The object
returned by the "new" method is also returned by the tie() function, which
would be useful if you wanted to access other methods in `CLASSNAME'. (You
don't actually have to return a reference to a right "type" (e.g., HASH or
`CLASSNAME') so long as it's a properly blessed object.)  You can also
retrieve a reference to the underlying object using the tied() function.

   Unlike dbmopen(), the tie() function will not use or require a module
for you-you need to do that explicitly yourself.

Tying Scalars
-------------

   A class implementing a tied scalar should define the following methods:
TIESCALAR, FETCH, STORE, and possibly DESTROY.

   Let's look at each in turn, using as an example a tie class for scalars
that allows the user to do something like:

     tie $his_speed, 'Nice', getppid();
     tie $my_speed,  'Nice', $$;

   And now whenever either of those variables is accessed, its current
system priority is retrieved and returned.  If those variables are set,
then the process's priority is changed!

   We'll use Jarkko Hietaniemi <`jhi@iki.fi'>'s BSD::Resource class (not
included) to access the PRIO_PROCESS, PRIO_MIN, and PRIO_MAX constants
from your system, as well as the getpriority() and setpriority() system
calls.  Here's the preamble of the class.

     package Nice;
     use Carp;
     use BSD::Resource;
     use strict;
     $Nice::DEBUG = 0 unless defined $Nice::DEBUG;

TIESCALAR classname, LIST
     This is the constructor for the class.  That means it is expected to
     return a blessed reference to a new scalar (probably anonymous) that
     it's creating.  For example:

          sub TIESCALAR {
              my $class = shift;
              my $pid = shift || $$; # 0 means me

          if ($pid !~ /^\d+$/) {
              carp "Nice::Tie::Scalar got non-numeric pid $pid" if $^W;
              return undef;
          }

          unless (kill 0, $pid) { # EPERM or ERSCH, no doubt
              carp "Nice::Tie::Scalar got bad pid $pid: $!" if $^W;
              return undef;
          }

          return bless \$pid, $class;
              }

     This tie class has chosen to return an error rather than raising an
     exception if its constructor should fail.  While this is how
     dbmopen() works, other classes may well not wish to be so forgiving.
     It checks the global variable $^W to see whether to emit a bit of
     noise anyway.

FETCH this
     This method will be triggered every time the tied variable is accessed
     (read).  It takes no arguments beyond its self reference, which is the
     object representing the scalar we're dealing with.  Because in this
     case we're using just a SCALAR ref for the tied scalar object, a
     simple $$self allows the method to get at the real value stored
     there.  In our example below, that real value is the process ID to
     which we've tied our variable.

          sub FETCH {
              my $self = shift;
              confess "wrong type" unless ref $self;
              croak "usage error" if @_;
              my $nicety;
              local($!) = 0;
              $nicety = getpriority(PRIO_PROCESS, $$self);
              if ($!) { croak "getpriority failed: $!" }
              return $nicety;
          }

     This time we've decided to blow up (raise an exception) if the renice
     fails-there's no place for us to return an error otherwise, and it's
     probably the right thing to do.

STORE this, value
     This method will be triggered every time the tied variable is set
     (assigned).  Beyond its self reference, it also expects one (and only
     one) argument-the new value the user is trying to assign.

          sub STORE {
              my $self = shift;
              confess "wrong type" unless ref $self;
              my $new_nicety = shift;
              croak "usage error" if @_;

          if ($new_nicety < PRIO_MIN) {
              carp sprintf
                "WARNING: priority %d less than minimum system priority %d",
                    $new_nicety, PRIO_MIN if $^W;
              $new_nicety = PRIO_MIN;
          }

          if ($new_nicety > PRIO_MAX) {
              carp sprintf
                "WARNING: priority %d greater than maximum system priority %d",
                    $new_nicety, PRIO_MAX if $^W;
              $new_nicety = PRIO_MAX;
          }

          unless (defined setpriority(PRIO_PROCESS, $$self, $new_nicety)) {
              confess "setpriority failed: $!";
          }
          return $new_nicety;
              }

DESTROY this
     This method will be triggered when the tied variable needs to be
     destructed.  As with other object classes, such a method is seldom
     necessary, because Perl deallocates its moribund object's memory for
     you automatically-this isn't C++, you know.  We'll use a DESTROY
     method here for debugging purposes only.

          sub DESTROY {
              my $self = shift;
              confess "wrong type" unless ref $self;
              carp "[ Nice::DESTROY pid $$self ]" if $Nice::DEBUG;
          }

   That's about all there is to it.  Actually, it's more than all there is
to it, because we've done a few nice things here for the sake of
completeness, robustness, and general aesthetics.  Simpler TIESCALAR
classes are certainly possible.

Tying Arrays
------------

   A class implementing a tied ordinary array should define the following
methods: TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE and perhaps DESTROY.

   FETCHSIZE and STORESIZE are used to provide `$#array' and equivalent
`scalar(@array)' access.

   The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are
required if the perl operator with the corresponding (but lowercase) name
is to operate on the tied array. The Tie::Array class can be used as a
base class to implement the first five of these in terms of the basic
methods above.  The default implementations of DELETE and EXISTS in
Tie::Array simply croak.

   In addition EXTEND will be called when perl would have pre-extended
allocation in a real array.

   This means that tied arrays are now complete. The example below needs
upgrading to illustrate this. (The documentation in Tie::Array is more
complete.)

   For this discussion, we'll implement an array whose indices are fixed at
its creation.  If you try to access anything beyond those bounds, you'll
take an exception.  For example:

     require Bounded_Array;
     tie @ary, 'Bounded_Array', 2;
     $| = 1;
     for $i (0 .. 10) {
         print "setting index $i: ";
         $ary[$i] = 10 * $i;
         $ary[$i] = 10 * $i;
         print "value of elt $i now $ary[$i]\n";
     }

   The preamble code for the class is as follows:

     package Bounded_Array;
     use Carp;
     use strict;

TIEARRAY classname, LIST
     This is the constructor for the class.  That means it is expected to
     return a blessed reference through which the new array (probably an
     anonymous ARRAY ref) will be accessed.

     In our example, just to show you that you don't *really* have to
     return an ARRAY reference, we'll choose a HASH reference to represent
     our object.  A HASH works out well as a generic record type: the
     `{BOUND}' field will store the maximum bound allowed, and the
     `{ARRAY}' field will hold the true ARRAY ref.  If someone outside the
     class tries to dereference the object returned (doubtless thinking it
     an ARRAY ref), they'll blow up.  This just goes to show you that you
     should respect an object's privacy.

          sub TIEARRAY {
          	my $class = shift;
          	my $bound = shift;
          	confess "usage: tie(\@ary, 'Bounded_Array', max_subscript)"
          	    if @_ || $bound =~ /\D/;
          	return bless {
          	    BOUND => $bound,
          	    ARRAY => [],
          	}, $class;
          }

FETCH this, index
     This method will be triggered every time an individual element the
     tied array is accessed (read).  It takes one argument beyond its self
     reference: the index whose value we're trying to fetch.

          sub FETCH {
            my($self,$idx) = @_;
            if ($idx > $self->{BOUND}) {
          	confess "Array OOB: $idx > $self->{BOUND}";
            }
            return $self->{ARRAY}[$idx];
          }

     As you may have noticed, the name of the FETCH method (et al.) is the
     same for all accesses, even though the constructors differ in names
     (TIESCALAR vs TIEARRAY).  While in theory you could have the same
     class servicing several tied types, in practice this becomes
     cumbersome, and it's easiest to keep them at simply one tie type per
     class.

STORE this, index, value
     This method will be triggered every time an element in the tied array
     is set (written).  It takes two arguments beyond its self reference:
     the index at which we're trying to store something and the value
     we're trying to put there.  For example:

          sub STORE {
            my($self, $idx, $value) = @_;
            print "[STORE $value at $idx]\n" if _debug;
            if ($idx > $self->{BOUND} ) {
              confess "Array OOB: $idx > $self->{BOUND}";
            }
            return $self->{ARRAY}[$idx] = $value;
          }

DESTROY this
     This method will be triggered when the tied variable needs to be
     destructed.  As with the scalar tie class, this is almost never
     needed in a language that does its own garbage collection, so this
     time we'll just leave it out.

   The code we presented at the top of the tied array class accesses many
elements of the array, far more than we've set the bounds to.  Therefore,
it will blow up once they try to access beyond the 2nd element of @ary, as
the following output demonstrates:

     setting index 0: value of elt 0 now 0
     setting index 1: value of elt 1 now 10
     setting index 2: value of elt 2 now 20
     setting index 3: Array OOB: 3 > 2 at Bounded_Array.pm line 39
             Bounded_Array::FETCH called at testba line 12

Tying Hashes
------------

   As the first Perl data type to be tied (see dbmopen()), hashes have the
most complete and useful tie() implementation.  A class implementing a
tied hash should define the following methods: TIEHASH is the constructor.
FETCH and STORE access the key and value pairs.  EXISTS reports whether a
key is present in the hash, and DELETE deletes one.  CLEAR empties the
hash by deleting all the key and value pairs.  FIRSTKEY and NEXTKEY
implement the keys() and each() functions to iterate over all the keys.
And DESTROY is called when the tied variable is garbage collected.

   If this seems like a lot, then feel free to inherit from merely the
standard Tie::Hash module for most of your methods, redefining only the
interesting ones.  See *Note Tie/Hash: (pm.info)Tie/Hash, for details.

   Remember that Perl distinguishes between a key not existing in the hash,
and the key existing in the hash but having a corresponding value of
undef.  The two possibilities can be tested with the exists() and
`defined()' functions.

   Here's an example of a somewhat interesting tied hash class:  it gives
you a hash representing a particular user's dot files.  You index into the
hash with the name of the file (minus the dot) and you get back that dot
file's contents.  For example:

     use DotFiles;
     tie %dot, 'DotFiles';
     if ( $dot{profile} =~ /MANPATH/ ||
          $dot{login}   =~ /MANPATH/ ||
          $dot{cshrc}   =~ /MANPATH/    )
     {
     	print "you seem to set your MANPATH\n";
     }

   Or here's another sample of using our tied class:

     tie %him, 'DotFiles', 'daemon';
     foreach $f ( keys %him ) {
     	printf "daemon dot file %s is size %d\n",
     	    $f, length $him{$f};
     }

   In our tied hash DotFiles example, we use a regular hash for the object
containing several important fields, of which only the `{LIST}' field will
be what the user thinks of as the real hash.

USER
     whose dot files this object represents

HOME
     where those dot files live

CLOBBER
     whether we should try to change or remove those dot files

LIST
     the hash of dot file names and content mappings

   Here's the start of `Dotfiles.pm':

     package DotFiles;
     use Carp;
     sub whowasi { (caller(1))[3] . '()' }
     my $DEBUG = 0;
     sub debug { $DEBUG = @_ ? shift : 1 }

   For our example, we want to be able to emit debugging info to help in
tracing during development.  We keep also one convenience function around
internally to help print out warnings; whowasi() returns the function name
that calls it.

   Here are the methods for the DotFiles tied hash.

TIEHASH classname, LIST
     This is the constructor for the class.  That means it is expected to
     return a blessed reference through which the new object (probably but
     not necessarily an anonymous hash) will be accessed.

     Here's the constructor:

          sub TIEHASH {
          	my $self = shift;
          	my $user = shift || $>;
          	my $dotdir = shift || '';
          	croak "usage: @{[&whowasi]} [USER [DOTDIR]]" if @_;
          	$user = getpwuid($user) if $user =~ /^\d+$/;
          	my $dir = (getpwnam($user))[7]
          		|| croak "@{[&whowasi]}: no user $user";
          	$dir .= "/$dotdir" if $dotdir;

          my $node = {
              USER    => $user,
              HOME    => $dir,
              LIST    => {},
              CLOBBER => 0,
          };

          opendir(DIR, $dir)
          	|| croak "@{[&whowasi]}: can't opendir $dir: $!";
          foreach $dot ( grep /^\./ && -f "$dir/$_", readdir(DIR)) {
              $dot =~ s/^\.//;
              $node->{LIST}{$dot} = undef;
          }
          closedir DIR;
          return bless $node, $self;
              }

     It's probably worth mentioning that if you're going to filetest the
     return values out of a readdir, you'd better prepend the directory in
     question.  Otherwise, because we didn't chdir() there, it would have
     been testing the wrong file.

FETCH this, key
     This method will be triggered every time an element in the tied hash
     is accessed (read).  It takes one argument beyond its self reference:
     the key whose value we're trying to fetch.

     Here's the fetch for our DotFiles example.

          sub FETCH {
          	carp &whowasi if $DEBUG;
          	my $self = shift;
          	my $dot = shift;
          	my $dir = $self->{HOME};
          	my $file = "$dir/.$dot";

          unless (exists $self->{LIST}->{$dot} || -f $file) {
              carp "@{[&whowasi]}: no $dot file" if $DEBUG;
              return undef;
          }

          if (defined $self->{LIST}->{$dot}) {
              return $self->{LIST}->{$dot};
          } else {
              return $self->{LIST}->{$dot} = `cat $dir/.$dot`;
          }
              }

     It was easy to write by having it call the Unix cat(1) command, but it
     would probably be more portable to open the file manually (and
     somewhat more efficient).  Of course, because dot files are a Unixy
     concept, we're not that concerned.

STORE this, key, value
     This method will be triggered every time an element in the tied hash
     is set (written).  It takes two arguments beyond its self reference:
     the index at which we're trying to store something, and the value
     we're trying to put there.

     Here in our DotFiles example, we'll be careful not to let them try to
     overwrite the file unless they've called the clobber() method on the
     original object reference returned by tie().

          sub STORE {
          	carp &whowasi if $DEBUG;
          	my $self = shift;
          	my $dot = shift;
          	my $value = shift;
          	my $file = $self->{HOME} . "/.$dot";
          	my $user = $self->{USER};

          croak "@{[&whowasi]}: $file not clobberable"
              unless $self->{CLOBBER};

          open(F, "> $file") || croak "can't open $file: $!";
          print F $value;
          close(F);
              }

     If they wanted to clobber something, they might say:

          $ob = tie %daemon_dots, 'daemon';
          $ob->clobber(1);
          $daemon_dots{signature} = "A true daemon\n";

     Another way to lay hands on a reference to the underlying object is to
     use the tied() function, so they might alternately have set clobber
     using:

          tie %daemon_dots, 'daemon';
          tied(%daemon_dots)->clobber(1);

     The clobber method is simply:

          sub clobber {
          	my $self = shift;
          	$self->{CLOBBER} = @_ ? shift : 1;
          }

DELETE this, key
     This method is triggered when we remove an element from the hash,
     typically by using the delete() function.  Again, we'll be careful to
     check whether they really want to clobber files.

          sub DELETE   {
          	carp &whowasi if $DEBUG;

          my $self = shift;
          my $dot = shift;
          my $file = $self->{HOME} . "/.$dot";
          croak "@{[&whowasi]}: won't remove file $file"
              unless $self->{CLOBBER};
          delete $self->{LIST}->{$dot};
          my $success = unlink($file);
          carp "@{[&whowasi]}: can't unlink $file: $!" unless $success;
          $success;
              }

     The value returned by DELETE becomes the return value of the call to
     delete().  If you want to emulate the normal behavior of delete(),
     you should return whatever FETCH would have returned for this key.
     In this example, we have chosen instead to return a value which tells
     the caller whether the file was successfully deleted.

CLEAR this
     This method is triggered when the whole hash is to be cleared,
     usually by assigning the empty list to it.

     In our example, that would remove all the user's dot files!  It's
     such a dangerous thing that they'll have to set CLOBBER to something
     higher than 1 to make it happen.

          sub CLEAR    {
          	carp &whowasi if $DEBUG;
          	my $self = shift;
          	croak "@{[&whowasi]}: won't remove all dot files for $self->{USER}"
          	    unless $self->{CLOBBER} > 1;
          	my $dot;
          	foreach $dot ( keys %{$self->{LIST}}) {
          	    $self->DELETE($dot);
          	}
          }

EXISTS this, key
     This method is triggered when the user uses the exists() function on
     a particular hash.  In our example, we'll look at the `{LIST}' hash
     element for this:

          sub EXISTS   {
          	carp &whowasi if $DEBUG;
          	my $self = shift;
          	my $dot = shift;
          	return exists $self->{LIST}->{$dot};
          }

FIRSTKEY this
     This method will be triggered when the user is going to iterate
     through the hash, such as via a keys() or each() call.

          sub FIRSTKEY {
          	carp &whowasi if $DEBUG;
          	my $self = shift;
          	my $a = keys %{$self->{LIST}};		# reset each() iterator
          	each %{$self->{LIST}}
          }

NEXTKEY this, lastkey
     This method gets triggered during a keys() or each() iteration.  It
     has a second argument which is the last key that had been accessed.
     This is useful if you're carrying about ordering or calling the
     iterator from more than one sequence, or not really storing things in
     a hash anywhere.

     For our example, we're using a real hash so we'll do just the simple
     thing, but we'll have to go through the LIST field indirectly.

          sub NEXTKEY  {
          	carp &whowasi if $DEBUG;
          	my $self = shift;
          	return each %{ $self->{LIST} }
          }

DESTROY this
     This method is triggered when a tied hash is about to go out of
     scope.  You don't really need it unless you're trying to add debugging
     or have auxiliary state to clean up.  Here's a very simple function:

          sub DESTROY  {
          	carp &whowasi if $DEBUG;
          }

   Note that functions such as keys() and values() may return huge lists
when used on large objects, like DBM files.  You may prefer to use the
each() function to iterate over such.  Example:

     # print out history file offsets
     use NDBM_File;
     tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);
     while (($key,$val) = each %HIST) {
         print $key, ' = ', unpack('L',$val), "\n";
     }
     untie(%HIST);

Tying FileHandles
-----------------

   This is partially implemented now.

   A class implementing a tied filehandle should define the following
methods: TIEHANDLE, at least one of PRINT, PRINTF, WRITE, READLINE, GETC,
READ, and possibly CLOSE and DESTROY.  The class can also provide: BINMODE,
OPEN, EOF, FILENO, SEEK, TELL - if the corresponding perl operators are
used on the handle.

   It is especially useful when perl is embedded in some other program,
where output to STDOUT and STDERR may have to be redirected in some
special way. See nvi and the Apache module for examples.

   In our example we're going to create a shouting handle.

     package Shout;

TIEHANDLE classname, LIST
     This is the constructor for the class.  That means it is expected to
     return a blessed reference of some sort. The reference can be used to
     hold some internal information.

          sub TIEHANDLE { print "<shout>\n"; my $i; bless \$i, shift }

WRITE this, LIST
     This method will be called when the handle is written to via the
     syswrite function.

          sub WRITE {
          	$r = shift;
          	my($buf,$len,$offset) = @_;
          	print "WRITE called, \$buf=$buf, \$len=$len, \$offset=$offset";
          }

PRINT this, LIST
     This method will be triggered every time the tied handle is printed to
     with the print() function.  Beyond its self reference it also expects
     the list that was passed to the print function.

          sub PRINT { $r = shift; $$r++; print join($,,map(uc($_),@_)),$\ }

PRINTF this, LIST
     This method will be triggered every time the tied handle is printed to
     with the printf() function.  Beyond its self reference it also
     expects the format and list that was passed to the printf function.

          sub PRINTF {
              shift;
              my $fmt = shift;
              print sprintf($fmt, @_)."\n";
          }

READ this, LIST
     This method will be called when the handle is read from via the read
     or sysread functions.

          sub READ {
          	my $self = shift;
          	my $$bufref = \$_[0];
          	my(undef,$len,$offset) = @_;
          	print "READ called, \$buf=$bufref, \$len=$len, \$offset=$offset";
          	# add to $$bufref, set $len to number of characters read
          	$len;
          }

READLINE this
     This method will be called when the handle is read from via <HANDLE>.
     The method should return undef when there is no more data.

          sub READLINE { $r = shift; "READLINE called $$r times\n"; }

GETC this
     This method will be called when the getc function is called.

          sub GETC { print "Don't GETC, Get Perl"; return "a"; }

CLOSE this
     This method will be called when the handle is closed via the close
     function.

          sub CLOSE { print "CLOSE called.\n" }

DESTROY this
     As with the other types of ties, this method will be called when the
     tied handle is about to be destroyed. This is useful for debugging and
     possibly cleaning up.

          sub DESTROY { print "</shout>\n" }

   Here's how to use our little example:

     tie(*FOO,'Shout');
     print FOO "hello\n";
     $a = 4; $b = 6;
     print FOO $a, " plus ", $b, " equals ", $a + $b, "\n";
     print <FOO>;

The untie Gotcha
----------------

   If you intend making use of the object returned from either tie() or
tied(), and if the tie's target class defines a destructor, there is a
subtle gotcha you must guard against.

   As setup, consider this (admittedly rather contrived) example of a tie;
all it does is use a file to keep a log of the values assigned to a scalar.

     package Remember;

     use strict;
     use warnings;
     use IO::File;

     sub TIESCALAR {
         my $class = shift;
         my $filename = shift;
         my $handle = new IO::File "> $filename"
                          or die "Cannot open $filename: $!\n";

     print $handle "The Start\n";
     bless {FH => $handle, Value => 0}, $class;
         }

     sub FETCH {
         my $self = shift;
         return $self->{Value};
     }

     sub STORE {
         my $self = shift;
         my $value = shift;
         my $handle = $self->{FH};
         print $handle "$value\n";
         $self->{Value} = $value;
     }

     sub DESTROY {
         my $self = shift;
         my $handle = $self->{FH};
         print $handle "The End\n";
         close $handle;
     }

     1;

   Here is an example that makes use of this tie:

     use strict;
     use Remember;

     my $fred;
     tie $fred, 'Remember', 'myfile.txt';
     $fred = 1;
     $fred = 4;
     $fred = 5;
     untie $fred;
     system "cat myfile.txt";

   This is the output when it is executed:

     The Start
     1
     4
     5
     The End

   So far so good.  Those of you who have been paying attention will have
spotted that the tied object hasn't been used so far.  So lets add an
extra method to the Remember class to allow comments to be included in the
file - say, something like this:

     sub comment {
         my $self = shift;
         my $text = shift;
         my $handle = $self->{FH};
         print $handle $text, "\n";
     }

   And here is the previous example modified to use the comment method
(which requires the tied object):

     use strict;
     use Remember;

     my ($fred, $x);
     $x = tie $fred, 'Remember', 'myfile.txt';
     $fred = 1;
     $fred = 4;
     comment $x "changing...";
     $fred = 5;
     untie $fred;
     system "cat myfile.txt";

   When this code is executed there is no output.  Here's why:

   When a variable is tied, it is associated with the object which is the
return value of the TIESCALAR, TIEARRAY, or TIEHASH function.  This object
normally has only one reference, namely, the implicit reference from the
tied variable.  When untie() is called, that reference is destroyed.
Then, as in the first example above, the object's destructor (DESTROY) is
called, which is normal for objects that have no more valid references;
and thus the file is closed.

   In the second example, however, we have stored another reference to the
tied object in $x.  That means that when untie() gets called there will
still be a valid reference to the object in existence, so the destructor
is not called at that time, and thus the file is not closed.  The reason
there is no output is because the file buffers have not been flushed to
disk.

   Now that you know what the problem is, what can you do to avoid it?
Well, the good old -w flag will spot any instances where you call untie()
and there are still valid references to the tied object.  If the second
script above this near the top `use warnings 'untie'' or was run with the
-w flag, Perl prints this warning message:

     untie attempted while 1 inner references still exist

   To get the script to work properly and silence the warning make sure
there are no valid references to the tied object before untie() is called:

     undef $x;
     untie $fred;

SEE ALSO
========

   See *Note DB_File: (pm.info)DB_File, or *Note Config: (pm.info)Config,
for some interesting tie() implementations.

BUGS
====

   Tied arrays are *incomplete*.  They are also distinctly lacking
something for the `$#ARRAY' access (which is hard, as it's an lvalue), as
well as the other obvious array functions, like push(), pop(), shift(),
unshift(), and splice().

   You cannot easily tie a multilevel data structure (such as a hash of
hashes) to a dbm file.  The first problem is that all but GDBM and
Berkeley DB have size limitations, but beyond that, you also have problems
with how references are to be represented on disk.  One experimental
module that does attempt to address this need partially is the MLDBM
module.  Check your nearest CPAN site as described in *Note Perlmodlib:
perlmodlib, for source code to MLDBM.

AUTHOR
======

   Tom Christiansen

   TIEHANDLE by Sven Verdoolaege <`skimo@dns.ufsia.ac.be'> and Doug
MacEachern <`dougm@osf.org'>


File: perl.info,  Node: perltodo,  Next: perlhack,  Prev: perlintern,  Up: Top

Perl TO-DO List
***************

NAME
====

   perltodo - Perl TO-DO List

DESCRIPTION
===========

   This is a list of wishes for Perl.  It is maintained by Nathan
Torkington for the Perl porters.  Send updates to
*perl5-porters@perl.org*.  If you want to work on any of these projects,
be sure to check the perl5-porters archives for past ideas, flames, and
propaganda.  This will save you time and also prevent you from
implementing something that Larry has already vetoed.  One set of archives
may be found at:

     http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/

Infrastructure
==============

Mailing list archives
---------------------

   Chaim suggests contacting egroup and asking them to archive the other
perl.org mailing lists.  Probably not advocacy, but definitely
perl6-porters, etc.

Bug tracking system
-------------------

   Richard Foley *richard@perl.org* is writing one.  We looked at several,
like gnats and the Debian system, but at the time we investigated them,
none met our needs.  Since then, Jitterbug has matured, and may be worth
reinvestigation.

   The system we've developed is the recipient of perlbug mail, and any
followups it generates from perl5-porters.  New bugs are entered into a
mysql database, and sent on to perl5-porters with the subject line
rewritten to include a "ticket number" (unique ID for the new bug).  If
the incoming message already had a ticket number in the subject line, then
the message is logged against that bug.  There is a separate email
interface (not forwarding to p5p) that permits porters to claim,
categorize, and close tickets.

   There is also a web interface to the system at http://bugs.perl.org.

   The current delay in implementation is caused by perl.org lockups.  One
suspect is the mail handling system, possibly going into loops.

   We still desperately need a bugmaster, someone who will look at every
new "bug" and kill those that we already know about, those that are not
bugs at all, etc.

Regression Tests
----------------

   The test suite for Perl serves two needs: ensuring features work, and
ensuring old bugs have not been reintroduced.  Both need work.

   Brent LaVelle (lavelle@metronet.com) has stepped forward to work on
performance tests and improving the size of the test suite.

Coverage
     Do the tests that come with Perl exercise every line (or every block,
     or ...)  of the Perl interpreter, and if not then how can we make them
     do so?

Regression
     No bug fixes should be made without a corresponding testsuite
     addition.  This needs a dedicated enforcer, as the current pumpking
     is either too lazy or too stupid or both and lets enforcement wander
     all over the map.  :-)

__DIE__
     Tests that fail need to be of a form that can be readily mailed to
     perlbug and diagnosed with minimal back-and-forth's to determine
     which test failed, due to what cause, etc.

suidperl
     We need regression/sanity tests for suidperl

The 25% slowdown from perl4 to perl5
     This value may or may not be accurate, but it certainly is
     eye-catching.  For some things perl5 is faster than perl4, but often
     the reliability and extensability have come at a cost of speed.  The
     benchmark suite that Gisle released earlier has been hailed as both a
     fantastic solution and as a source of entirely meaningless figures.
     Do we need to test "real applications"?  Can you do so?  Anyone have
     machines to dedicate to the task?  Identify the things that have grown
     slower, and see if there's a way to make them faster.

Configure
=========

   Andy Dougherty maintain(ed|s) a list of "todo" items for the configure
that comes with Perl.  See Porting/pumpkin.pod in the latest source
release.

Install HTML
------------

   Have "make install" give you the option to install HTML as well.  This
would be part of Configure.  Andy Wardley (certified Perl studmuffin) will
look into the current problems of HTML installation-is 'installhtml'
preventing this from happening cleanly, or is pod2html the problem?  If
the latter, Brad Appleton's pod work may fix the problem for free.

Perl Language
=============

our ($var)
----------

   Declare global variables (lexically or otherwise).

64-bit Perl
-----------

   Verify complete 64 bit support so that the value of sysseek, or -s, or
stat(), or tell can fit into a perl number without losing precision.  Work
with the perl-64bit mailing list on perl.org.

Prototypes
----------

Named prototypes
     Add proper named prototypes that actually work usefully.

Indirect objects
     Fix prototype bug that forgets indirect objects.

Method calls
     Prototypes for method calls.

Context
     Return context prototype declarations.

Scoped subs
     lexically-scoped subs, e.g. my sub

Perl Internals
==============

magic_setisa
------------

   magic_setisa should be made to update %FIELDS [???]

Garbage Collection
------------------

   There was talk of a mark-and-sweep garbage collector at TPC2, but the
(to users) unpredictable nature of its behaviour put some off.  Sarathy, I
believe, did the work.  Here's what he has to say:

   Yeah, I hope to implement it someday too.  The points that were raised
in TPC2 were all to do with calling DESTROY() methods, but I think we can
accomodate that by extending bless() to stash extra information for
objects so we track their lifetime accurately for those that want their
DESTROY() to be predictable (this will be a speed hit, naturally, and will
therefore be optional, naturally. :)

   [N.B. Don't even ask me about this now!  When I have the time to write
a cogent summary, I'll post it.]

Reliable signals
----------------

   Sarathy and Dan Sugalski are working on this.  Chip posted a patch
earlier, but it was not accepted into 5.005.  The issue is tricky, because
it has the potential to greatly slow down the core.

   There are at least three things to consider:

Alternate runops() for signal despatch
     Sarathy and Dan are discussed this on perl5-porters.

Figure out how to die() in delayed sighandler
Add tests for Thread::Signal
Automatic tests against CPAN
     Is there some way to automatically build all/most of CPAN with the
     new Perl and check that the modules there pass all the tests?

Interpolated regex performance bugs
-----------------------------------

     while (<>) {
       $found = 0;
       foreach $pat (@patterns) {
         $found++ if /$pat/o;
       }
       print if $found;
     }

   The qr// syntax added in 5.005 has solved this problem, but it needs
more thorough documentation.

Memory leaks from failed eval/regcomp
-------------------------------------

   The only known memory leaks in Perl are in failed code or regexp
compilation.  Fix this.  Hugo Van Der Sanden will attempt this but won't
have tuits until January 1999.

Make XS easier to use
---------------------

   There was interest in SWIG from porters, but nothing has happened
lately.

Make embedded Perl easier to use
--------------------------------

   This is probably difficult for the same reasons that "XS For Dummies"
will be difficult.

Namespace cleanup
-----------------

     CPP-space:    restrict CPP symbols exported from headers
     header-space: move into CORE/perl/
     API-space:    begin list of things that constitute public api
     env-space:    Configure should use PERL_CONFIG instead of CONFIG etc.

MULTIPLICITY
------------

   Complete work on safe recursive interpreters `Perl->new()'.  Sarathy
says that a reference implementation exists.

MacPerl
-------

   Chris Nandor and Matthias Neeracher are working on better integrating
MacPerl into the Perl distribution.

Documentation
=============

   There's a lot of documentation that comes with Perl.  The quantity of
documentation makes it difficult for users to know which section of which
manpage to read in order to solve their problem.  Tom Christiansen has
done much of the documentation work in the past.

A clear division into tutorial and reference
--------------------------------------------

   Some manpages (e.g., perltoot and perlreftut) clearly set out to
educate the reader about a subject.  Other manpages (e.g., perlsub) are
references for which there is no tutorial, or are references with a slight
tutorial bent.  If things are either tutorial or reference, then the
reader knows which manpage to read to learn about a subject, and which
manpage to read to learn all about an aspect of that subject.  Part of the
solution to this is:

Remove the artificial distinction between operators and functions
-----------------------------------------------------------------

   History shows us that users, and often porters, aren't clear on the
operator-function distinction.  The present split in reference material
between perlfunc and perlop hinders user navigation.  Given that perlfunc
is by far the larger of the two, move operator reference into perlfunc.

More tutorials
--------------

   More documents of a tutorial nature could help.  Here are some
candidates:

Regular expressions
     Robin Berjon (r.berjon@ltconsulting.net) has volunteered.

I/O
     Mark-Jason Dominus (mjd@plover.com) has an outline for perliotut.

pack/unpack
     This is badly needed.  There has been some discussion on the subject
     on perl5-porters.

Debugging
     Ronald Kimball (rjk@linguist.dartmouth.edu) has volunteered.

Include a search tool
---------------------

   perldoc should be able to 'grep' fulltext indices of installed POD
files.  This would let people say:

     perldoc -find printing numbers with commas

   and get back the perlfaq entry on 'commify'.

   This solution, however, requires documentation to contain the keywords
the user is searching for.  Even when the users know what they're looking
for, often they can't spell it.

Include a locate tool
---------------------

   perldoc should be able to help people find the manpages on a particular
high-level subject:

     perldoc -find web

   would tell them manpages, web pages, and books with material on web
programming.  Similarly `perldoc -find databases', `perldoc -find
references' and so on.

   We need something in the vicinity of:

     % perl -help random stuff
     No documentation for perl function `random stuff' found
     The following entry in perlfunc.pod matches /random/a:
       =item rand EXPR

     =item rand

     Returns a random fractional number greater than or equal to C<0> and less
     than the value of EXPR.  (EXPR should be positive.)  If EXPR is
     omitted, the value C<1> is used.  Automatically calls C<srand()> unless
     C<srand()> has already been called.  See also C<srand()>.

     (Note: If your rand function consistently returns numbers that are too
     large or too small, then your version of Perl was probably compiled
     with the wrong number of RANDBITS.)
       The following pod pages seem to have /stuff/a:
     perlfunc.pod	(7 hits)
     perlfaq7.pod	(6 hits)
     perlmod.pod		(4 hits)
     perlsyn.pod		(3 hits)
     perlfaq8.pod	(2 hits)
     perlipc.pod		(2 hits)
     perl5004delta.pod	(1 hit)
     perl5005delta.pod	(1 hit)
     perlcall.pod	(1 hit)
     perldelta.pod	(1 hit)
     perlfaq3.pod	(1 hit)
     perlfaq5.pod	(1 hit)
     perlhist.pod	(1 hit)
     perlref.pod		(1 hit)
     perltoc.pod		(1 hit)
     perltrap.pod	(1 hit)
       Proceed to open perlfunc.pod? [y] n
       Do you want to speak perl interactively? [y] n
       Should I dial 911? [y] n
       Do you need psychiatric help? [y] y
       <PELIZA> Hi, what bothers you today?
            A Python programmer in the next cubby is driving me nuts!
       <PELIZA> Hmm, thats fixable.  Just [rest censored]

Separate function manpages by default
-------------------------------------

   Perl should install 'manpages' for every function/operator into the 3pl
or 3p manual section.  By default.  The splitman program in the Perl
source distribution does the work of turning big perlfunc into little 3p
pages.

Users can't find the manpages
-----------------------------

   Make perldoc tell users what they need to add to their .login or .cshrc
to set their MANPATH correctly.

Install ALL Documentation
-------------------------

   Make the standard documentation kit include the VMS, OS/2, Win32,
Threads, etc information.  installperl and pod/Makefile should know enough
to copy README.foo to perlfoo.pod before building everything, when
appropriate.

Outstanding issues to be documented
-----------------------------------

   Tom has a list of 5.005_5* features or changes that require
documentation.

   Create one document that coherently explains the delta between the last
camel release and the current release.  perldelta was supposed to be that,
but no longer.  The things in perldelta never seemed to get placed in the
right places in the real manpages, either.  This needs work.

Adapt www.linuxhq.com for Perl
------------------------------

   This should help glorify documentation and get more people involved in
perl development.

Replace man with a perl program
-------------------------------

   Can we reimplement man in Perl?  Tom has a start.  I believe some of
the Linux systems distribute a manalike.  Alternatively, build on perldoc
to remove the unfeatures like "is slow" and "has no apropos".

Unicode tutorial
----------------

   We could use more work on helping people understand Perl's new Unicode
support that Larry has created.

Modules
=======

Update the POSIX extension to conform with the POSIX 1003.1 Edition 2
---------------------------------------------------------------------

   The current state of the POSIX extension is as of Edition 1, 1991,
whereas the Edition 2 came out in 1996.  ISO/IEC 9945:1-1996(E), ANSI/IEEE
Std 1003.1, 1996 Edition. ISBN 1-55937-573-6.  The updates were legion:
threads, IPC, and real time extensions.

Module versions
---------------

   Automate the checking of versions in the standard distribution so it's
easy for a pumpking to check whether CPAN has a newer version that we
should be including?

New modules
-----------

   Which modules should be added to the standard distribution?  This ties
in with the SDK discussed on the perl-sdk list at perl.org.

Profiler
--------

   Make the profiler (Devel::DProf) part of the standard release, and
document it well.

Tie Modules
-----------

VecArray
     Implement array using vec().  Nathan Torkington has working code to
     do this.

SubstrArray
     Implement array using substr()

VirtualArray
     Implement array using a file

ShiftSplice
     Defines shift et al in terms of splice method

Procedural options
------------------

   Support procedural interfaces for the common cases of Perl's
gratuitously OOO modules.  Tom objects to "use IO::File" reading many
thousands of lines of code.

RPC
---

   Write a module for transparent, portable remote procedure calls.  (Not
core).  This touches on the CORBA and ILU work.

y2k localtime/gmtime
--------------------

   Write a module, Y2k::Catch, which overloads localtime and gmtime's
returned year value and catches "bad" attempts to use it.

Export File::Find variables
---------------------------

   Make File::Find export $name etc manually, at least if asked to.

Ioctl
-----

   Finish a proper Ioctl module.

Debugger attach/detach
----------------------

   Permit a user to debug an already-running program.

Regular Expression debugger
---------------------------

   Create a visual profiler/debugger tool that stepped you through the
execution of a regular expression point by point.  Ilya has a module to
color-code and display regular expression parses and executions.  There's
something at http://tkworld.org/ that might be a good start, it's a Tk/Tcl
RE wizard, that builds regexen of many flavours.

Alternative RE Syntax
---------------------

   Make an alternative regular expression syntax that is accessed through
a module.  For instance,

     use RE;
     $re = start_of_line()
         ->literal("1998/10/08")
         ->optional( whitespace() )
         ->literal("[")
         ->remember( many( or( "-", digit() ) ) );

     if (/$re/) {
       print "time is $1\n";
     }

   Newbies to regular expressions typically only use a subset of the full
language.  Perhaps you wouldn't have to implement the full feature set.

Bundled modules
---------------

   Nicholas Clark (nick@flirble.org) had a patch for storing modules in
zipped format.  This needs exploring and concluding.

Expect
------

   Adopt IO::Tty, make it as portable as Don Libes' "expect" (can we link
against expect code?), and perfect a Perl version of expect.  IO::Tty and
expect could then be distributed as part of the core distribution,
replacing Comm.pl and other hacks.

GUI::Native
-----------

   A simple-to-use interface to native graphical abilities would be
welcomed.  Oh, Perl's access Tk is nice enough, and reasonably portable,
but it's not particularly as fast as one would like.  Simple access to the
mouse's cut buffer or mouse-presses shouldn't required loading a few
terabytes of Tk code.

Update semibroken auxiliary tools; h2ph, a2p, etc.
--------------------------------------------------

   Kurt Starsinic is working on h2ph.  mjd has fixed bugs in a2p in the
past.  a2p apparently doesn't work on nawk and gawk extensions.  Graham
Barr has an Include module that does h2ph work at runtime.

POD Converters
--------------

   Brad's PodParser code needs to become part of the core, and the Pod::*
and pod2* programs rewritten to use this standard parser.  Currently the
converters take different options, some behave in different fashions, and
some are more picky than others in terms of the POD files they accept.

pod2html
--------

   A short-term fix: pod2html generates absolute HTML links.  Make it
generate relative links.

Podchecker
----------

   Something like lint for Pod would be good.  Something that catches
common errors as well as gross ones.  Brad Appleton is putting together
something as part of his PodParser work.

Tom's Wishes
============

Webperl
-------

   Design a webperl environment that's as tightly integrated and as
easy-to-use as Perl's current command-line environment.

Mobile agents
-------------

   More work on a safe and secure execution environment for mobile agents
would be neat; the Safe.pm module is a start, but there's a still a lot to
be done in that area.  Adopt Penguin?

POSIX on non-POSIX
------------------

   Standard programming constructs for non-POSIX systems would help a lot
of programmers stuck on primitive, legacy systems.  For example, Microsoft
still hasn't made a usable POSIX interface on their clunky systems, which
means that standard operations such as alarm() and fork(), both critical
for sophisticated client-server programming, must both be kludged around.

   I'm unsure whether Tom means to emulate alarm( )and fork(), or merely
to provide a document like perlport.pod to say which features are portable
and which are not.

Portable installations
----------------------

   Figure out a portable semi-gelled installation, that is, one without
full paths.  Larry has said that he's thinking about this.  Ilya pointed
out that perllib_mangle() is good for this.

Win32 Stuff
===========

Rename new headers to be consistent with the rest
-------------------------------------------------

Sort out the spawnvp() mess
---------------------------

Work out DLL versioning
-----------------------

Style-check
-----------

Would be nice to have
=====================

`pack "(stuff)*"'
Contiguous bitfields in pack/unpack
lexperl
Bundled perl preprocessor
Use posix calls internally where possible
format BOTTOM
-i rename file only when successfully changed
All ARGV input should act like <>
report HANDLE [formats].
support in perlmain to rerun debugger
lvalue functions
     Tuomas Lukka, on behalf of the PDL project, greatly desires this and
     Ilya has a patch for it (probably against an older version of Perl).
     Tuomas points out that what PDL really wants is lvalue methods, not
     just subs.

Possible pragmas
================

'less'
------

   (use less memory, CPU)

Optimizations
=============

constant function cache
-----------------------

foreach(reverse...)
-------------------

Cache eval tree
---------------

   Unless lexical outer scope used (mark in &compiling?).

rcatmaybe
---------

Shrink opcode tables
--------------------

   Via multiple implementations selected in peep.

Cache hash value
----------------

   Not a win, according to Guido.

Optimize away @_ where possible
-------------------------------

Optimize sort by { $a <=> $b }
------------------------------

   Greg Bacon added several more sort optimizations.  These have made it
into 5.005_55, thanks to Hans Mulder.

Rewrite regexp parser for better integrated optimization
--------------------------------------------------------

   The regexp parser was rewritten for 5.005.  Ilya's the regexp guru.

Vague possibilities
===================

ref function in list context
     This seems impossible to do without substantially breaking code.

make tr/// return histogram in list context?
Loop control on do{} et al
Explicit switch statements
     Nobody has yet managed to come up with a switch syntax that would
     allow for mixed hash, constant, regexp checks.  Submit implementation
     with syntax, please.

compile to real threaded code
structured types
Modifiable $1 et al
     The intent is for this to be a means of editing the matched portions
     of the target string.

To Do Or Not To Do
==================

   These are things that have been discussed in the past and roundly
criticized for being of questionable value.

Making my() work on "package" variables
---------------------------------------

   Being able to say my($Foo::Bar), something that sounds ludicrous and
the 5.6 pumpking has mocked.

"or" testing defined not truth
------------------------------

   We tell people that `||' can be used to give a default value to a
variable:

     $children = shift || 5;		# default is 5 children

   which is almost (but not):

     $children = shift;
     $children = 5 unless $children;

   but if the first argument was given and is "0", then it will be
considered false by `||' and 5 used instead.  Really we want an `||'-like
operator that behaves like:

     $children = shift;
     $children = 5 unless defined $children;

   Namely, a `||' that tests defined-ness rather than truth.  One was
discussed, and a patch submitted, but the objections were many.  While
there were objections, many still feel the need.  At least it was decided
that `??' is the best name for the operator.

"dynamic" lexicals
------------------

     my $x;
     sub foo {
       local $x;
     }

   Localizing, as Tim Bunce points out, is a separate concept from whether
the variable is global or lexical.  Chip Salzenberg had an implementation
once, but Larry thought it had potential to confuse.

"class"-based, rather than package-based "lexicals"
---------------------------------------------------

   This is like what the Alias module provides, but the variables would be
lexicals reserved by perl at compile-time, which really are indices
pointing into the pseudo-hash object visible inside every method so
declared.

Threading
=========

Modules
-------

   Which of the standard modules are thread-safe?  Which CPAN modules?
How easy is it to fix those non-safe modules?

Testing
-------

   Threading is still experimental.  Every reproducible bug identifies
something else for us to fix.  Find and submit more of these problems.

$AUTOLOAD
---------

exit/die
--------

   Consistent semantics for exit/die in threads.

External threads
----------------

   Better support for externally created threads.

Thread::Pool
------------

thread-safety
-------------

   Spot-check globals like statcache and global GVs for thread-safety.
"*Part done*", says Sarathy.

Per-thread GVs
--------------

   According to Sarathy, this would make @_ be the same in threaded and
non-threaded, as well as helping solve problems like filehandles (the same
filehandle currently cannot be used in two threads).

Compiler
========

Optimization
------------

   The compiler's back-end code-generators for creating bytecode or
compilable C code could use optimization work.

Byteperl
--------

   Figure out how and where byteperl will be built for the various
platforms.

Precompiled modules
-------------------

   Save byte-compiled modules on disk.

Executables
-----------

   Auto-produce executable.

Typed lexicals
--------------

   Typed lexicals should affect B::CC::load_pad.

Win32
-----

   Workarounds to help Win32 dynamic loading.

END blocks
----------

   END blocks need saving in compiled output, now that CHECK blocks are
available.

_AUTOLOAD
---------

   _AUTOLOAD prodding.

comppadlist
-----------

   Fix comppadlist (names in comppad_name can have fake SvCUR from where
newASSIGNOP steals the field).

Cached compilation
------------------

   Can we install modules as bytecode?

Recently Finished Tasks
=======================

Figure a way out of $^(capital letter)
--------------------------------------

   Figure out a clean way to extend $^(capital letter) beyond the 26
alphabets.  (${^WORD} maybe?)

   Mark-Jason Dominus sent a patch which went into 5.005_56.

Filenames
---------

   Keep filenames in the distribution and in the standard module set be
8.3 friendly where feasible.  Good luck changing the standard modules,
though.

Foreign lines
-------------

   Perl should be more generous in accepting foreign line terminations.
Mostly done in 5.005.

Namespace cleanup
-----------------

     symbol-space: "pl_" prefix for all global vars
                   "Perl_" prefix for all functions

     CPP-space:	  stop malloc()/free() pollution unless asked

ISA.pm
------

   Rename and alter ISA.pm.  *Done*.  It is now base.pm.

gettimeofday
------------

   See Time::HiRes.

autocroak?
----------

   This is the Fatal.pm module, so any builtin that that does not return
success automatically die()s.  If you're feeling brave, tie this in with
the unified exceptions scheme.


File: perl.info,  Node: perltoot,  Next: perltootc,  Prev: perlboot,  Up: Top

Tom's object-oriented tutorial for perl
***************************************

NAME
====

   perltoot - Tom's object-oriented tutorial for perl

DESCRIPTION
===========

   Object-oriented programming is a big seller these days.  Some managers
would rather have objects than sliced bread.  Why is that?  What's so
special about an object?  Just what *is* an object anyway?

   An object is nothing but a way of tucking away complex behaviours into
a neat little easy-to-use bundle.  (This is what professors call
abstraction.) Smart people who have nothing to do but sit around for weeks
on end figuring out really hard problems make these nifty objects that
even regular people can use. (This is what professors call software
reuse.)  Users (well, programmers) can play with this little bundle all
they want, but they aren't to open it up and mess with the insides.  Just
like an expensive piece of hardware, the contract says that you void the
warranty if you muck with the cover.  So don't do that.

   The heart of objects is the class, a protected little private namespace
full of data and functions.  A class is a set of related routines that
addresses some problem area.  You can think of it as a user-defined type.
The Perl package mechanism, also used for more traditional modules, is
used for class modules as well.  Objects "live" in a class, meaning that
they belong to some package.

   More often than not, the class provides the user with little bundles.
These bundles are objects.  They know whose class they belong to, and how
to behave.  Users ask the class to do something, like "give me an object."
Or they can ask one of these objects to do something.  Asking a class to
do something for you is calling a *class method*.  Asking an object to do
something for you is calling an *object method*.  Asking either a class
(usually) or an object (sometimes) to give you back an object is calling a
*constructor*, which is just a kind of method.

   That's all well and good, but how is an object different from any other
Perl data type?  Just what is an object *really*; that is, what's its
fundamental type?  The answer to the first question is easy.  An object is
different from any other data type in Perl in one and only one way: you
may dereference it using not merely string or numeric subscripts as with
simple arrays and hashes, but with named subroutine calls.  In a word,
with methods.

   The answer to the second question is that it's a reference, and not just
any reference, mind you, but one whose referent has been bless()ed into a
particular class (read: package).  What kind of reference?  Well, the
answer to that one is a bit less concrete.  That's because in Perl the
designer of the class can employ any sort of reference they'd like as the
underlying intrinsic data type.  It could be a scalar, an array, or a hash
reference.  It could even be a code reference.  But because of its
inherent flexibility, an object is usually a hash reference.

Creating a Class
================

   Before you create a class, you need to decide what to name it.  That's
because the class (package) name governs the name of the file used to
house it, just as with regular modules.  Then, that class (package) should
provide one or more ways to generate objects.  Finally, it should provide
mechanisms to allow users of its objects to indirectly manipulate these
objects from a distance.

   For example, let's make a simple Person class module.  It gets stored in
the file Person.pm.  If it were called a Happy::Person class, it would be
stored in the file Happy/Person.pm, and its package would become
Happy::Person instead of just Person.  (On a personal computer not running
Unix or Plan 9, but something like MacOS or VMS, the directory separator
may be different, but the principle is the same.)  Do not assume any
formal relationship between modules based on their directory names.  This
is merely a grouping convenience, and has no effect on inheritance,
variable accessibility, or anything else.

   For this module we aren't going to use Exporter, because we're a
well-behaved class module that doesn't export anything at all.  In order
to manufacture objects, a class needs to have a *constructor method*.  A
constructor gives you back not just a regular data type, but a brand-new
object in that class.  This magic is taken care of by the bless()
function, whose sole purpose is to enable its referent to be used as an
object.  Remember: being an object really means nothing more than that
methods may now be called against it.

   While a constructor may be named anything you'd like, most Perl
programmers seem to like to call theirs new().  However, new() is not a
reserved word, and a class is under no obligation to supply such.  Some
programmers have also been known to use a function with the same name as
the class as the constructor.

Object Representation
---------------------

   By far the most common mechanism used in Perl to represent a Pascal
record, a C struct, or a C++ class is an anonymous hash.  That's because a
hash has an arbitrary number of data fields, each conveniently accessed by
an arbitrary name of your own devising.

   If you were just doing a simple struct-like emulation, you would likely
go about it something like this:

     $rec = {
         name  => "Jason",
         age   => 23,
         peers => [ "Norbert", "Rhys", "Phineas"],
     };

   If you felt like it, you could add a bit of visual distinction by
up-casing the hash keys:

     $rec = {
         NAME  => "Jason",
         AGE   => 23,
         PEERS => [ "Norbert", "Rhys", "Phineas"],
     };

   And so you could get at `< $rec-'{NAME} >> to find "Jason", or `< @{
$rec-'{PEERS} } >> to get at "Norbert", "Rhys", and "Phineas".  (Have you
ever noticed how many 23-year-old programmers seem to be named "Jason"
these days? :-)

   This same model is often used for classes, although it is not considered
the pinnacle of programming propriety for folks from outside the class to
come waltzing into an object, brazenly accessing its data members
directly.  Generally speaking, an object should be considered an opaque
cookie that you use *object methods* to access.  Visually, methods look
like you're dereffing a reference using a function name instead of
brackets or braces.

Class Interface
---------------

   Some languages provide a formal syntactic interface to a class's
methods, but Perl does not.  It relies on you to read the documentation of
each class.  If you try to call an undefined method on an object, Perl
won't complain, but the program will trigger an exception while it's
running.  Likewise, if you call a method expecting a prime number as its
argument with a non-prime one instead, you can't expect the compiler to
catch this.  (Well, you can expect it all you like, but it's not going to
happen.)

   Let's suppose you have a well-educated user of your Person class,
someone who has read the docs that explain the prescribed interface.
Here's how they might use the Person class:

     use Person;

     $him = Person->new();
     $him->name("Jason");
     $him->age(23);
     $him->peers( "Norbert", "Rhys", "Phineas" );

     push @All_Recs, $him;  # save object in array for later

     printf "%s is %d years old.\n", $him->name, $him->age;
     print "His peers are: ", join(", ", $him->peers), "\n";

     printf "Last rec's name is %s\n", $All_Recs[-1]->name;

   As you can see, the user of the class doesn't know (or at least, has no
business paying attention to the fact) that the object has one particular
implementation or another.  The interface to the class and its objects is
exclusively via methods, and that's all the user of the class should ever
play with.

Constructors and Instance Methods
---------------------------------

   Still, *someone* has to know what's in the object.  And that someone is
the class.  It implements methods that the programmer uses to access the
object.  Here's how to implement the Person class using the standard
hash-ref-as-an-object idiom.  We'll make a class method called new() to
act as the constructor, and three object methods called name(), age(), and
peers() to get at per-object data hidden away in our anonymous hash.

     package Person;
     use strict;

     ##################################################
     ## the object constructor (simplistic version)  ##
     ##################################################
     sub new {
         my $self  = {};
         $self->{NAME}   = undef;
         $self->{AGE}    = undef;
         $self->{PEERS}  = [];
         bless($self);           # but see below
         return $self;
     }

     ##############################################
     ## methods to access per-object data        ##
     ##                                          ##
     ## With args, they set the value.  Without  ##
     ## any, they only retrieve it/them.         ##
     ##############################################

     sub name {
         my $self = shift;
         if (@_) { $self->{NAME} = shift }
         return $self->{NAME};
     }

     sub age {
         my $self = shift;
         if (@_) { $self->{AGE} = shift }
         return $self->{AGE};
     }

     sub peers {
         my $self = shift;
         if (@_) { @{ $self->{PEERS} } = @_ }
         return @{ $self->{PEERS} };
     }

     1;  # so the require or use succeeds

   We've created three methods to access an object's data, name(), age(),
and peers().  These are all substantially similar.  If called with an
argument, they set the appropriate field; otherwise they return the value
held by that field, meaning the value of that hash key.

Planning for the Future: Better Constructors
--------------------------------------------

   Even though at this point you may not even know what it means, someday
you're going to worry about inheritance.  (You can safely ignore this for
now and worry about it later if you'd like.)  To ensure that this all
works out smoothly, you must use the double-argument form of bless().  The
second argument is the class into which the referent will be blessed.  By
not assuming our own class as the default second argument and instead
using the class passed into us, we make our constructor inheritable.

   While we're at it, let's make our constructor a bit more flexible.
Rather than being uniquely a class method, we'll set it up so that it can
be called as either a class method or an object method.  That way you can
say:

     $me  = Person->new();
     $him = $me->new();

   To do this, all we have to do is check whether what was passed in was a
reference or not.  If so, we were invoked as an object method, and we need
to extract the package (class) using the ref() function.  If not, we just
use the string passed in as the package name for blessing our referent.

     sub new {
         my $proto = shift;
         my $class = ref($proto) || $proto;
         my $self  = {};
         $self->{NAME}   = undef;
         $self->{AGE}    = undef;
         $self->{PEERS}  = [];
         bless ($self, $class);
         return $self;
     }

   That's about all there is for constructors.  These methods bring objects
to life, returning neat little opaque bundles to the user to be used in
subsequent method calls.

Destructors
-----------

   Every story has a beginning and an end.  The beginning of the object's
story is its constructor, explicitly called when the object comes into
existence.  But the ending of its story is the *destructor*, a method
implicitly called when an object leaves this life.  Any per-object
clean-up code is placed in the destructor, which must (in Perl) be called
DESTROY.

   If constructors can have arbitrary names, then why not destructors?
Because while a constructor is explicitly called, a destructor is not.
Destruction happens automatically via Perl's garbage collection (GC)
system, which is a quick but somewhat lazy reference-based GC system.  To
know what to call, Perl insists that the destructor be named DESTROY.
Perl's notion of the right time to call a destructor is not well-defined
currently, which is why your destructors should not rely on when they are
called.

   Why is DESTROY in all caps?  Perl on occasion uses purely uppercase
function names as a convention to indicate that the function will be
automatically called by Perl in some way.  Others that are called
implicitly include BEGIN, END, AUTOLOAD, plus all methods used by tied
objects, described in *Note Perltie: perltie,.

   In really good object-oriented programming languages, the user doesn't
care when the destructor is called.  It just happens when it's supposed
to.  In low-level languages without any GC at all, there's no way to
depend on this happening at the right time, so the programmer must
explicitly call the destructor to clean up memory and state, crossing
their fingers that it's the right time to do so.   Unlike C++, an object
destructor is nearly never needed in Perl, and even when it is, explicit
invocation is uncalled for.  In the case of our Person class, we don't
need a destructor because Perl takes care of simple matters like memory
deallocation.

   The only situation where Perl's reference-based GC won't work is when
there's a circularity in the data structure, such as:

     $this->{WHATEVER} = $this;

   In that case, you must delete the self-reference manually if you expect
your program not to leak memory.  While admittedly error-prone, this is
the best we can do right now.  Nonetheless, rest assured that when your
program is finished, its objects' destructors are all duly called.  So you
are guaranteed that an object *eventually* gets properly destroyed, except
in the unique case of a program that never exits.  (If you're running Perl
embedded in another application, this full GC pass happens a bit more
frequently-whenever a thread shuts down.)

Other Object Methods
--------------------

   The methods we've talked about so far have either been constructors or
else simple "data methods", interfaces to data stored in the object.
These are a bit like an object's data members in the C++ world, except
that strangers don't access them as data.  Instead, they should only
access the object's data indirectly via its methods.  This is an important
rule: in Perl, access to an object's data should *only* be made through
methods.

   Perl doesn't impose restrictions on who gets to use which methods.  The
public-versus-private distinction is by convention, not syntax.  (Well,
unless you use the Alias module described below in `Data Members as
Variables' in this node.)  Occasionally you'll see method names beginning
or ending with an underscore or two.  This marking is a convention
indicating that the methods are private to that class alone and sometimes
to its closest acquaintances, its immediate subclasses.  But this
distinction is not enforced by Perl itself.  It's up to the programmer to
behave.

   There's no reason to limit methods to those that simply access data.
Methods can do anything at all.  The key point is that they're invoked
against an object or a class.  Let's say we'd like object methods that do
more than fetch or set one particular field.

     sub exclaim {
         my $self = shift;
         return sprintf "Hi, I'm %s, age %d, working with %s",
             $self->{NAME}, $self->{AGE}, join(", ", @{$self->{PEERS}});
     }

   Or maybe even one like this:

     sub happy_birthday {
         my $self = shift;
         return ++$self->{AGE};
     }

   Some might argue that one should go at these this way:

     sub exclaim {
         my $self = shift;
         return sprintf "Hi, I'm %s, age %d, working with %s",
             $self->name, $self->age, join(", ", $self->peers);
     }

     sub happy_birthday {
         my $self = shift;
         return $self->age( $self->age() + 1 );
     }

   But since these methods are all executing in the class itself, this may
not be critical.  There are tradeoffs to be made.  Using direct hash
access is faster (about an order of magnitude faster, in fact), and it's
more convenient when you want to interpolate in strings.  But using
methods (the external interface) internally shields not just the users of
your class but even you yourself from changes in your data representation.

Class Data
==========

   What about "class data", data items common to each object in a class?
What would you want that for?  Well, in your Person class, you might like
to keep track of the total people alive.  How do you implement that?

   You *could* make it a global variable called $Person::Census.  But about
only reason you'd do that would be if you *wanted* people to be able to
get at your class data directly.  They could just say $Person::Census and
play around with it.  Maybe this is ok in your design scheme.  You might
even conceivably want to make it an exported variable.  To be exportable,
a variable must be a (package) global.  If this were a traditional module
rather than an object-oriented one, you might do that.

   While this approach is expected in most traditional modules, it's
generally considered rather poor form in most object modules.  In an
object module, you should set up a protective veil to separate interface
from implementation.  So provide a class method to access class data just
as you provide object methods to access object data.

   So, you *could* still keep $Census as a package global and rely upon
others to honor the contract of the module and therefore not play around
with its implementation.  You could even be supertricky and make $Census a
tied object as described in *Note Perltie: perltie,, thereby intercepting
all accesses.

   But more often than not, you just want to make your class data a
file-scoped lexical.  To do so, simply put this at the top of the file:

     my $Census = 0;

   Even though the scope of a my() normally expires when the block in which
it was declared is done (in this case the whole file being required or
used), Perl's deep binding of lexical variables guarantees that the
variable will not be deallocated, remaining accessible to functions
declared within that scope.  This doesn't work with global variables given
temporary values via local(), though.

   Irrespective of whether you leave $Census a package global or make it
instead a file-scoped lexical, you should make these changes to your
Person::new() constructor:

     sub new {
         my $proto = shift;
         my $class = ref($proto) || $proto;
         my $self  = {};
         $Census++;
         $self->{NAME}   = undef;
         $self->{AGE}    = undef;
         $self->{PEERS}  = [];
         bless ($self, $class);
         return $self;
     }

     sub population {
         return $Census;
     }

   Now that we've done this, we certainly do need a destructor so that
when Person is destroyed, the $Census goes down.  Here's how this could be
done:

     sub DESTROY { --$Census }

   Notice how there's no memory to deallocate in the destructor?  That's
something that Perl takes care of for you all by itself.

Accessing Class Data
--------------------

   It turns out that this is not really a good way to go about handling
class data.  A good scalable rule is that *you must never reference class
data directly from an object method*.  Otherwise you aren't building a
scalable, inheritable class.  The object must be the rendezvous point for
all operations, especially from an object method.  The globals (class
data) would in some sense be in the "wrong" package in your derived
classes.  In Perl, methods execute in the context of the class they were
defined in, not that of the object that triggered them.  Therefore,
namespace visibility of package globals in methods is unrelated to
inheritance.

   Got that?  Maybe not.  Ok, let's say that some other class "borrowed"
(well, inherited) the DESTROY method as it was defined above.  When those
objects are destroyed, the original $Census variable will be altered, not
the one in the new class's package namespace.  Perhaps this is what you
want, but probably it isn't.

   Here's how to fix this.  We'll store a reference to the data in the
value accessed by the hash key "_CENSUS".  Why the underscore?  Well,
mostly because an initial underscore already conveys strong feelings of
magicalness to a C programmer.  It's really just a mnemonic device to
remind ourselves that this field is special and not to be used as a public
data member in the same way that NAME, AGE, and PEERS are.  (Because we've
been developing this code under the strict pragma, prior to perl version
5.004 we'll have to quote the field name.)

     sub new {
         my $proto = shift;
         my $class = ref($proto) || $proto;
         my $self  = {};
         $self->{NAME}     = undef;
         $self->{AGE}      = undef;
         $self->{PEERS}    = [];
         # "private" data
         $self->{"_CENSUS"} = \$Census;
         bless ($self, $class);
         ++ ${ $self->{"_CENSUS"} };
         return $self;
     }

     sub population {
         my $self = shift;
         if (ref $self) {
             return ${ $self->{"_CENSUS"} };
         } else {
             return $Census;
         }
     }

     sub DESTROY {
         my $self = shift;
         -- ${ $self->{"_CENSUS"} };
     }

Debugging Methods
-----------------

   It's common for a class to have a debugging mechanism.  For example,
you might want to see when objects are created or destroyed.  To do that,
add a debugging variable as a file-scoped lexical.  For this, we'll pull
in the standard Carp module to emit our warnings and fatal messages.  That
way messages will come out with the caller's filename and line number
instead of our own; if we wanted them to be from our own perspective, we'd
just use die() and warn() directly instead of croak() and carp()
respectively.

     use Carp;
     my $Debugging = 0;

   Now add a new class method to access the variable.

     sub debug {
         my $class = shift;
         if (ref $class)  { confess "Class method called as object method" }
         unless (@_ == 1) { confess "usage: CLASSNAME->debug(level)" }
         $Debugging = shift;
     }

   Now fix up DESTROY to murmur a bit as the moribund object expires:

     sub DESTROY {
         my $self = shift;
         if ($Debugging) { carp "Destroying $self " . $self->name }
         -- ${ $self->{"_CENSUS"} };
     }

   One could conceivably make a per-object debug state.  That way you
could call both of these:

     Person->debug(1);   # entire class
     $him->debug(1);     # just this object

   To do so, we need our debugging method to be a "bimodal" one, one that
works on both classes and objects.  Therefore, adjust the debug() and
DESTROY methods as follows:

     sub debug {
         my $self = shift;
         confess "usage: thing->debug(level)"    unless @_ == 1;
         my $level = shift;
         if (ref($self))  {
             $self->{"_DEBUG"} = $level;		# just myself
         } else {
             $Debugging        = $level;         # whole class
         }
     }

     sub DESTROY {
         my $self = shift;
         if ($Debugging || $self->{"_DEBUG"}) {
             carp "Destroying $self " . $self->name;
         }
         -- ${ $self->{"_CENSUS"} };
     }

   What happens if a derived class (which we'll call Employee) inherits
methods from this Person base class?  Then `< Employee-'debug() >>, when
called as a class method, manipulates $Person::Debugging not
$Employee::Debugging.

Class Destructors
-----------------

   The object destructor handles the death of each distinct object.  But
sometimes you want a bit of cleanup when the entire class is shut down,
which currently only happens when the program exits.  To make such a
*class destructor*, create a function in that class's package named END.
This works just like the END function in traditional modules, meaning that
it gets called whenever your program exits unless it execs or dies of an
uncaught signal.  For example,

     sub END {
         if ($Debugging) {
             print "All persons are going away now.\n";
         }
     }

   When the program exits, all the class destructors (END functions) are
be called in the opposite order that they were loaded in (LIFO order).

Documenting the Interface
-------------------------

   And there you have it: we've just shown you the implementation of this
Person class.  Its interface would be its documentation.  Usually this
means putting it in pod ("plain old documentation") format right there in
the same file.  In our Person example, we would place the following docs
anywhere in the Person.pm file.  Even though it looks mostly like code,
it's not.  It's embedded documentation such as would be used by the
pod2man, pod2html, or pod2text programs.  The Perl compiler ignores pods
entirely, just as the translators ignore code.  Here's an example of some
pods describing the informal interface:

     =head1 NAME

     Person - class to implement people

     =head1 SYNOPSIS

     use Person;

     #################
     # class methods #
     #################
     $ob    = Person->new;
     $count = Person->population;

     #######################
     # object data methods #
     #######################

     ### get versions ###
         $who   = $ob->name;
         $years = $ob->age;
         @pals  = $ob->peers;

     ### set versions ###
         $ob->name("Jason");
         $ob->age(23);
         $ob->peers( "Norbert", "Rhys", "Phineas" );

     ########################
     # other object methods #
     ########################

     $phrase = $ob->exclaim;
     $ob->happy_birthday;

     =head1 DESCRIPTION

     The Person class implements dah dee dah dee dah....

   That's all there is to the matter of interface versus implementation.
A programmer who opens up the module and plays around with all the private
little shiny bits that were safely locked up behind the interface contract
has voided the warranty, and you shouldn't worry about their fate.

Aggregation
===========

   Suppose you later want to change the class to implement better names.
Perhaps you'd like to support both given names (called Christian names,
irrespective of one's religion) and family names (called surnames), plus
nicknames and titles.  If users of your Person class have been properly
accessing it through its documented interface, then you can easily change
the underlying implementation.  If they haven't, then they lose and it's
their fault for breaking the contract and voiding their warranty.

   To do this, we'll make another class, this one called Fullname.  What's
the Fullname class look like?  To answer that question, you have to first
figure out how you want to use it.  How about we use it this way:

     $him = Person->new();
     $him->fullname->title("St");
     $him->fullname->christian("Thomas");
     $him->fullname->surname("Aquinas");
     $him->fullname->nickname("Tommy");
     printf "His normal name is %s\n", $him->name;
     printf "But his real name is %s\n", $him->fullname->as_string;

   Ok.  To do this, we'll change Person::new() so that it supports a full
name field this way:

     sub new {
         my $proto = shift;
         my $class = ref($proto) || $proto;
         my $self  = {};
         $self->{FULLNAME} = Fullname->new();
         $self->{AGE}      = undef;
         $self->{PEERS}    = [];
         $self->{"_CENSUS"} = \$Census;
         bless ($self, $class);
         ++ ${ $self->{"_CENSUS"} };
         return $self;
     }

     sub fullname {
         my $self = shift;
         return $self->{FULLNAME};
     }

   Then to support old code, define Person::name() this way:

     sub name {
         my $self = shift;
         return $self->{FULLNAME}->nickname(@_)
           ||   $self->{FULLNAME}->christian(@_);
     }

   Here's the Fullname class.  We'll use the same technique of using a
hash reference to hold data fields, and methods by the appropriate name to
access them:

     package Fullname;
     use strict;

     sub new {
         my $proto = shift;
         my $class = ref($proto) || $proto;
         my $self  = {
             TITLE       => undef,
             CHRISTIAN   => undef,
             SURNAME     => undef,
             NICK        => undef,
         };
         bless ($self, $class);
         return $self;
     }

     sub christian {
         my $self = shift;
         if (@_) { $self->{CHRISTIAN} = shift }
         return $self->{CHRISTIAN};
     }

     sub surname {
         my $self = shift;
         if (@_) { $self->{SURNAME} = shift }
         return $self->{SURNAME};
     }

     sub nickname {
         my $self = shift;
         if (@_) { $self->{NICK} = shift }
         return $self->{NICK};
     }

     sub title {
         my $self = shift;
         if (@_) { $self->{TITLE} = shift }
         return $self->{TITLE};
     }

     sub as_string {
         my $self = shift;
         my $name = join(" ", @$self{'CHRISTIAN', 'SURNAME'});
         if ($self->{TITLE}) {
             $name = $self->{TITLE} . " " . $name;
         }
         return $name;
     }

     1;

   Finally, here's the test program:

     #!/usr/bin/perl -w
     use strict;
     use Person;
     sub END { show_census() }

     sub show_census ()  {
         printf "Current population: %d\n", Person->population;
     }

     Person->debug(1);

     show_census();

     my $him = Person->new();

     $him->fullname->christian("Thomas");
     $him->fullname->surname("Aquinas");
     $him->fullname->nickname("Tommy");
     $him->fullname->title("St");
     $him->age(1);

     printf "%s is really %s.\n", $him->name, $him->fullname;
     printf "%s's age: %d.\n", $him->name, $him->age;
     $him->happy_birthday;
     printf "%s's age: %d.\n", $him->name, $him->age;

     show_census();

Inheritance
===========

   Object-oriented programming systems all support some notion of
inheritance.  Inheritance means allowing one class to piggy-back on top of
another one so you don't have to write the same code again and again.
It's about software reuse, and therefore related to Laziness, the
principal virtue of a programmer.  (The import/export mechanisms in
traditional modules are also a form of code reuse, but a simpler one than
the true inheritance that you find in object modules.)

   Sometimes the syntax of inheritance is built into the core of the
language, and sometimes it's not.  Perl has no special syntax for
specifying the class (or classes) to inherit from.  Instead, it's all
strictly in the semantics.  Each package can have a variable called @ISA,
which governs (method) inheritance.  If you try to call a method on an
object or class, and that method is not found in that object's package,
Perl then looks to @ISA for other packages to go looking through in search
of the missing method.

   Like the special per-package variables recognized by Exporter (such as
@EXPORT, @EXPORT_OK, @EXPORT_FAIL, %EXPORT_TAGS, and $VERSION), the @ISA
array must be a package-scoped global and not a file-scoped lexical
created via my().  Most classes have just one item in their @ISA array.
In this case, we have what's called "single inheritance", or SI for short.

   Consider this class:

     package Employee;
     use Person;
     @ISA = ("Person");
     1;

   Not a lot to it, eh?  All it's doing so far is loading in another class
and stating that this one will inherit methods from that other class if
need be.  We have given it none of its own methods.  We rely upon an
Employee to behave just like a Person.

   Setting up an empty class like this is called the "empty subclass test";
that is, making a derived class that does nothing but inherit from a base
class.  If the original base class has been designed properly, then the
new derived class can be used as a drop-in replacement for the old one.
This means you should be able to write a program like this:

     use Employee;
     my $empl = Employee->new();
     $empl->name("Jason");
     $empl->age(23);
     printf "%s is age %d.\n", $empl->name, $empl->age;

   By proper design, we mean always using the two-argument form of bless(),
avoiding direct access of global data, and not exporting anything.  If you
look back at the Person::new() function we defined above, we were careful
to do that.  There's a bit of package data used in the constructor, but
the reference to this is stored on the object itself and all other methods
access package data via that reference, so we should be ok.

   What do we mean by the Person::new() function - isn't that actually a
method?  Well, in principle, yes.  A method is just a function that
expects as its first argument a class name (package) or object (blessed
reference).   Person::new() is the function that both the `< Person-'new()
>> method and the `< Employee-'new() >> method end up calling.  Understand
that while a method call looks a lot like a function call, they aren't
really quite the same, and if you treat them as the same, you'll very soon
be left with nothing but broken programs.  First, the actual underlying
calling conventions are different: method calls get an extra argument.
Second, function calls don't do inheritance, but methods do.

     Method Call             Resulting Function Call
     -----------             ------------------------
     Person->new()           Person::new("Person")
     Employee->new()         Person::new("Employee")

   So don't use function calls when you mean to call a method.

   If an employee is just a Person, that's not all too very interesting.
So let's add some other methods.  We'll give our employee data fields to
access their salary, their employee ID, and their start date.

   If you're getting a little tired of creating all these nearly identical
methods just to get at the object's data, do not despair.  Later, we'll
describe several different convenience mechanisms for shortening this up.
Meanwhile, here's the straight-forward way:

     sub salary {
         my $self = shift;
         if (@_) { $self->{SALARY} = shift }
         return $self->{SALARY};
     }

     sub id_number {
         my $self = shift;
         if (@_) { $self->{ID} = shift }
         return $self->{ID};
     }

     sub start_date {
         my $self = shift;
         if (@_) { $self->{START_DATE} = shift }
         return $self->{START_DATE};
     }

Overridden Methods
------------------

   What happens when both a derived class and its base class have the same
method defined?  Well, then you get the derived class's version of that
method.  For example, let's say that we want the peers() method called on
an employee to act a bit differently.  Instead of just returning the list
of peer names, let's return slightly different strings.  So doing this:

     $empl->peers("Peter", "Paul", "Mary");
     printf "His peers are: %s\n", join(", ", $empl->peers);

   will produce:

     His peers are: PEON=PETER, PEON=PAUL, PEON=MARY

   To do this, merely add this definition into the Employee.pm file:

     sub peers {
         my $self = shift;
         if (@_) { @{ $self->{PEERS} } = @_ }
         return map { "PEON=\U$_" } @{ $self->{PEERS} };
     }

   There, we've just demonstrated the high-falutin' concept known in
certain circles as *polymorphism*.  We've taken on the form and behaviour
of an existing object, and then we've altered it to suit our own purposes.
This is a form of Laziness.  (Getting polymorphed is also what happens
when the wizard decides you'd look better as a frog.)

   Every now and then you'll want to have a method call trigger both its
derived class (also known as "subclass") version as well as its base class
(also known as "superclass") version.  In practice, constructors and
destructors are likely to want to do this, and it probably also makes
sense in the debug() method we showed previously.

   To do this, add this to Employee.pm:

     use Carp;
     my $Debugging = 0;

     sub debug {
         my $self = shift;
         confess "usage: thing->debug(level)"    unless @_ == 1;
         my $level = shift;
         if (ref($self))  {
             $self->{"_DEBUG"} = $level;
         } else {
             $Debugging = $level;            # whole class
         }
         Person::debug($self, $Debugging);   # don't really do this
     }

   As you see, we turn around and call the Person package's debug()
function.  But this is far too fragile for good design.  What if Person
doesn't have a debug() function, but is inheriting *its* debug() method
from elsewhere?  It would have been slightly better to say

     Person->debug($Debugging);

   But even that's got too much hard-coded.  It's somewhat better to say

     $self->Person::debug($Debugging);

   Which is a funny way to say to start looking for a debug() method up in
Person.  This strategy is more often seen on overridden object methods
than on overridden class methods.

   There is still something a bit off here.  We've hard-coded our
superclass's name.  This in particular is bad if you change which classes
you inherit from, or add others.  Fortunately, the pseudoclass SUPER comes
to the rescue here.

     $self->SUPER::debug($Debugging);

   This way it starts looking in my class's @ISA.  This only makes sense
from *within* a method call, though.  Don't try to access anything in
SUPER:: from anywhere else, because it doesn't exist outside an overridden
method call.

   Things are getting a bit complicated here.  Have we done anything we
shouldn't?  As before, one way to test whether we're designing a decent
class is via the empty subclass test.  Since we already have an Employee
class that we're trying to check, we'd better get a new empty subclass
that can derive from Employee.  Here's one:

     package Boss;
     use Employee;        # :-)
     @ISA = qw(Employee);

   And here's the test program:

     #!/usr/bin/perl -w
     use strict;
     use Boss;
     Boss->debug(1);

     my $boss = Boss->new();

     $boss->fullname->title("Don");
     $boss->fullname->surname("Pichon Alvarez");
     $boss->fullname->christian("Federico Jesus");
     $boss->fullname->nickname("Fred");

     $boss->age(47);
     $boss->peers("Frank", "Felipe", "Faust");

     printf "%s is age %d.\n", $boss->fullname, $boss->age;
     printf "His peers are: %s\n", join(", ", $boss->peers);

   Running it, we see that we're still ok.  If you'd like to dump out your
object in a nice format, somewhat like the way the 'x' command works in
the debugger, you could use the Data::Dumper module from CPAN this way:

     use Data::Dumper;
     print "Here's the boss:\n";
     print Dumper($boss);

   Which shows us something like this:

     Here's the boss:
     $VAR1 = bless( {
     	 _CENSUS => \1,
     	 FULLNAME => bless( {
     			      TITLE => 'Don',
     			      SURNAME => 'Pichon Alvarez',
     			      NICK => 'Fred',
     			      CHRISTIAN => 'Federico Jesus'
     			    }, 'Fullname' ),
     	 AGE => 47,
     	 PEERS => [
     		    'Frank',
     		    'Felipe',
     		    'Faust'
     		  ]
        }, 'Boss' );

   Hm.... something's missing there.  What about the salary, start date,
and ID fields?  Well, we never set them to anything, even undef, so they
don't show up in the hash's keys.  The Employee class has no new() method
of its own, and the new() method in Person doesn't know about Employees.
(Nor should it: proper OO design dictates that a subclass be allowed to
know about its immediate superclass, but never vice-versa.)  So let's fix
up Employee::new() this way:

     sub new {
         my $proto = shift;
         my $class = ref($proto) || $proto;
         my $self  = $class->SUPER::new();
         $self->{SALARY}        = undef;
         $self->{ID}            = undef;
         $self->{START_DATE}    = undef;
         bless ($self, $class);          # reconsecrate
         return $self;
     }

   Now if you dump out an Employee or Boss object, you'll find that new
fields show up there now.

Multiple Inheritance
--------------------

   Ok, at the risk of confusing beginners and annoying OO gurus, it's time
to confess that Perl's object system includes that controversial notion
known as multiple inheritance, or MI for short.  All this means is that
rather than having just one parent class who in turn might itself have a
parent class, etc., that you can directly inherit from two or more
parents.  It's true that some uses of MI can get you into trouble,
although hopefully not quite so much trouble with Perl as with
dubiously-OO languages like C++.

   The way it works is actually pretty simple: just put more than one
package name in your @ISA array.  When it comes time for Perl to go finding
methods for your object, it looks at each of these packages in order.
Well, kinda.  It's actually a fully recursive, depth-first order.
Consider a bunch of @ISA arrays like this:

     @First::ISA    = qw( Alpha );
     @Second::ISA   = qw( Beta );
     @Third::ISA    = qw( First Second );

   If you have an object of class Third:

     my $ob = Third->new();
     $ob->spin();

   How do we find a spin() method (or a new() method for that matter)?
Because the search is depth-first, classes will be looked up in the
following order: Third, First, Alpha, Second, and Beta.

   In practice, few class modules have been seen that actually make use of
MI.  One nearly always chooses simple containership of one class within
another over MI.  That's why our Person object *contained* a Fullname
object.  That doesn't mean it *was* one.

   However, there is one particular area where MI in Perl is rampant:
borrowing another class's class methods.  This is rather common,
especially with some bundled "objectless" classes, like Exporter,
DynaLoader, AutoLoader, and SelfLoader.  These classes do not provide
constructors; they exist only so you may inherit their class methods.
(It's not entirely clear why inheritance was done here rather than
traditional module importation.)

   For example, here is the POSIX module's @ISA:

     package POSIX;
     @ISA = qw(Exporter DynaLoader);

   The POSIX module isn't really an object module, but then, neither are
Exporter or DynaLoader.  They're just lending their classes' behaviours to
POSIX.

   Why don't people use MI for object methods much?  One reason is that it
can have complicated side-effects.  For one thing, your inheritance graph
(no longer a tree) might converge back to the same base class.  Although
Perl guards against recursive inheritance, merely having parents who are
related to each other via a common ancestor, incestuous though it sounds,
is not forbidden.  What if in our Third class shown above we wanted its
new() method to also call both overridden constructors in its two parent
classes?  The SUPER notation would only find the first one.  Also, what
about if the Alpha and Beta classes both had a common ancestor, like
Nought?  If you kept climbing up the inheritance tree calling overridden
methods, you'd end up calling Nought::new() twice, which might well be a
bad idea.

UNIVERSAL: The Root of All Objects
----------------------------------

   Wouldn't it be convenient if all objects were rooted at some ultimate
base class?  That way you could give every object common methods without
having to go and add it to each and every @ISA.  Well, it turns out that
you can.  You don't see it, but Perl tacitly and irrevocably assumes that
there's an extra element at the end of @ISA: the class UNIVERSAL.  In
version 5.003, there were no predefined methods there, but you could put
whatever you felt like into it.

   However, as of version 5.004 (or some subversive releases, like
5.003_08), UNIVERSAL has some methods in it already.  These are builtin to
your Perl binary, so they don't take any extra time to load.  Predefined
methods include isa(), can(), and VERSION().  isa() tells you whether an
object or class "is" another one without having to traverse the hierarchy
yourself:

     $has_io = $fd->isa("IO::Handle");
     $itza_handle = IO::Socket->isa("IO::Handle");

   The can() method, called against that object or class, reports back
whether its string argument is a callable method name in that class.  In
fact, it gives you back a function reference to that method:

     $his_print_method = $obj->can('as_string');

   Finally, the VERSION method checks whether the class (or the object's
class) has a package global called $VERSION that's high enough, as in:

     Some_Module->VERSION(3.0);
     $his_vers = $ob->VERSION();

   However, we don't usually call VERSION ourselves.  (Remember that an all
uppercase function name is a Perl convention that indicates that the
function will be automatically used by Perl in some way.)  In this case,
it happens when you say

     use Some_Module 3.0;

   If you wanted to add version checking to your Person class explained
above, just add this to Person.pm:

     our $VERSION = '1.1';

   and then in Employee.pm could you can say

     use Employee 1.1;

   And it would make sure that you have at least that version number or
higher available.   This is not the same as loading in that exact version
number.  No mechanism currently exists for concurrent installation of
multiple versions of a module.  Lamentably.

Alternate Object Representations
================================

   Nothing requires objects to be implemented as hash references.  An
object can be any sort of reference so long as its referent has been
suitably blessed.  That means scalar, array, and code references are also
fair game.

   A scalar would work if the object has only one datum to hold.  An array
would work for most cases, but makes inheritance a bit dodgy because you
have to invent new indices for the derived classes.

Arrays as Objects
-----------------

   If the user of your class honors the contract and sticks to the
advertised interface, then you can change its underlying interface if you
feel like it.  Here's another implementation that conforms to the same
interface specification.  This time we'll use an array reference instead
of a hash reference to represent the object.

     package Person;
     use strict;

     my($NAME, $AGE, $PEERS) = ( 0 .. 2 );

     ############################################
     ## the object constructor (array version) ##
     ############################################
     sub new {
         my $self = [];
         $self->[$NAME]   = undef;  # this is unnecessary
         $self->[$AGE]    = undef;  # as is this
         $self->[$PEERS]  = [];     # but this isn't, really
         bless($self);
         return $self;
     }

     sub name {
         my $self = shift;
         if (@_) { $self->[$NAME] = shift }
         return $self->[$NAME];
     }

     sub age {
         my $self = shift;
         if (@_) { $self->[$AGE] = shift }
         return $self->[$AGE];
     }

     sub peers {
         my $self = shift;
         if (@_) { @{ $self->[$PEERS] } = @_ }
         return @{ $self->[$PEERS] };
     }

     1;  # so the require or use succeeds

   You might guess that the array access would be a lot faster than the
hash access, but they're actually comparable.  The array is a *little* bit
faster, but not more than ten or fifteen percent, even when you replace
the variables above like $AGE with literal numbers, like 1.  A bigger
difference between the two approaches can be found in memory use.  A hash
representation takes up more memory than an array representation because
you have to allocate memory for the keys as well as for the values.
However, it really isn't that bad, especially since as of version 5.004,
memory is only allocated once for a given hash key, no matter how many
hashes have that key.  It's expected that sometime in the future, even
these differences will fade into obscurity as more efficient underlying
representations are devised.

   Still, the tiny edge in speed (and somewhat larger one in memory) is
enough to make some programmers choose an array representation for simple
classes.  There's still a little problem with scalability, though, because
later in life when you feel like creating subclasses, you'll find that
hashes just work out better.

Closures as Objects
-------------------

   Using a code reference to represent an object offers some fascinating
possibilities.  We can create a new anonymous function (closure) who alone
in all the world can see the object's data.  This is because we put the
data into an anonymous hash that's lexically visible only to the closure
we create, bless, and return as the object.  This object's methods turn
around and call the closure as a regular subroutine call, passing it the
field we want to affect.  (Yes, the double-function call is slow, but if
you wanted fast, you wouldn't be using objects at all, eh? :-)

   Use would be similar to before:

     use Person;
     $him = Person->new();
     $him->name("Jason");
     $him->age(23);
     $him->peers( [ "Norbert", "Rhys", "Phineas" ] );
     printf "%s is %d years old.\n", $him->name, $him->age;
     print "His peers are: ", join(", ", @{$him->peers}), "\n";

   but the implementation would be radically, perhaps even sublimely
different:

     package Person;

     sub new {
     	 my $that  = shift;
     	 my $class = ref($that) || $that;
     	 my $self = {
     	    NAME  => undef,
     	    AGE   => undef,
     	    PEERS => [],
     	 };
     	 my $closure = sub {
     	    my $field = shift;
     	    if (@_) { $self->{$field} = shift }
     	    return    $self->{$field};
     	};
     	bless($closure, $class);
     	return $closure;
     }

     sub name   { &{ $_[0] }("NAME",  @_[ 1 .. $#_ ] ) }
     sub age    { &{ $_[0] }("AGE",   @_[ 1 .. $#_ ] ) }
     sub peers  { &{ $_[0] }("PEERS", @_[ 1 .. $#_ ] ) }

     1;

   Because this object is hidden behind a code reference, it's probably a
bit mysterious to those whose background is more firmly rooted in standard
procedural or object-based programming languages than in functional
programming languages whence closures derive.  The object created and
returned by the new() method is itself not a data reference as we've seen
before.  It's an anonymous code reference that has within it access to a
specific version (lexical binding and instantiation) of the object's data,
which are stored in the private variable $self.  Although this is the same
function each time, it contains a different version of $self.

   When a method like `$him->name("Jason")' is called, its implicit zeroth
argument is the invoking object-just as it is with all method calls.  But
in this case, it's our code reference (something like a function pointer
in C++, but with deep binding of lexical variables).  There's not a lot to
be done with a code reference beyond calling it, so that's just what we do
when we say `&{$_[0]}'.  This is just a regular function call, not a
method call.  The initial argument is the string "NAME", and any remaining
arguments are whatever had been passed to the method itself.

   Once we're executing inside the closure that had been created in new(),
the $self hash reference suddenly becomes visible.  The closure grabs its
first argument ("NAME" in this case because that's what the name() method
passed it), and uses that string to subscript into the private hash hidden
in its unique version of $self.

   Nothing under the sun will allow anyone outside the executing method to
be able to get at this hidden data.  Well, nearly nothing.  You *could*
single step through the program using the debugger and find out the pieces
while you're in the method, but everyone else is out of luck.

   There, if that doesn't excite the Scheme folks, then I just don't know
what will.  Translation of this technique into C++, Java, or any other
braindead-static language is left as a futile exercise for aficionados of
those camps.

   You could even add a bit of nosiness via the caller() function and make
the closure refuse to operate unless called via its own package.  This
would no doubt satisfy certain fastidious concerns of programming police
and related puritans.

   If you were wondering when Hubris, the third principle virtue of a
programmer, would come into play, here you have it. (More seriously,
Hubris is just the pride in craftsmanship that comes from having written a
sound bit of well-designed code.)

AUTOLOAD: Proxy Methods
=======================

   Autoloading is a way to intercept calls to undefined methods.  An
autoload routine may choose to create a new function on the fly, either
loaded from disk or perhaps just eval()ed right there.  This
define-on-the-fly strategy is why it's called autoloading.

   But that's only one possible approach.  Another one is to just have the
autoloaded method itself directly provide the requested service.  When
used in this way, you may think of autoloaded methods as "proxy" methods.

   When Perl tries to call an undefined function in a particular package
and that function is not defined, it looks for a function in that same
package called AUTOLOAD.  If one exists, it's called with the same
arguments as the original function would have had.  The fully-qualified
name of the function is stored in that package's global variable
$AUTOLOAD.  Once called, the function can do anything it would like,
including defining a new function by the right name, and then doing a
really fancy kind of goto right to it, erasing itself from the call stack.

   What does this have to do with objects?  After all, we keep talking
about functions, not methods.  Well, since a method is just a function with
an extra argument and some fancier semantics about where it's found, we
can use autoloading for methods, too.  Perl doesn't start looking for an
AUTOLOAD method until it has exhausted the recursive hunt up through @ISA,
though.  Some programmers have even been known to define a
UNIVERSAL::AUTOLOAD method to trap unresolved method calls to any kind of
object.

Autoloaded Data Methods
-----------------------

   You probably began to get a little suspicious about the duplicated code
way back earlier when we first showed you the Person class, and then later
the Employee class.  Each method used to access the hash fields looked
virtually identical.  This should have tickled that great programming
virtue, Impatience, but for the time, we let Laziness win out, and so did
nothing.  Proxy methods can cure this.

   Instead of writing a new function every time we want a new data field,
we'll use the autoload mechanism to generate (actually, mimic) methods on
the fly.  To verify that we're accessing a valid member, we will check
against an `_permitted' (pronounced "under-permitted") field, which is a
reference to a file-scoped lexical (like a C file static) hash of
permitted fields in this record called %fields.  Why the underscore?  For
the same reason as the _CENSUS field we once used: as a marker that means
"for internal use only".

   Here's what the module initialization code and class constructor will
look like when taking this approach:

     package Person;
     use Carp;
     our $AUTOLOAD;  # it's a package global

     my %fields = (
     	name        => undef,
     	age         => undef,
     	peers       => undef,
     );

     sub new {
     	my $that  = shift;
     	my $class = ref($that) || $that;
     	my $self  = {
     	    _permitted => \%fields,
     	    %fields,
     	};
     	bless $self, $class;
     	return $self;
     }

   If we wanted our record to have default values, we could fill those in
where current we have undef in the %fields hash.

   Notice how we saved a reference to our class data on the object itself?
Remember that it's important to access class data through the object
itself instead of having any method reference %fields directly, or else
you won't have a decent inheritance.

   The real magic, though, is going to reside in our proxy method, which
will handle all calls to undefined methods for objects of class Person (or
subclasses of Person).  It has to be called AUTOLOAD.  Again, it's all
caps because it's called for us implicitly by Perl itself, not by a user
directly.

     sub AUTOLOAD {
     	my $self = shift;
     	my $type = ref($self)
     		    or croak "$self is not an object";

     my $name = $AUTOLOAD;
     $name =~ s/.*://;   # strip fully-qualified portion

     unless (exists $self->{_permitted}->{$name} ) {
         croak "Can't access `$name' field in class $type";
     }

     if (@_) {
         return $self->{$name} = shift;
     } else {
         return $self->{$name};
     }
         }

   Pretty nifty, eh?  All we have to do to add new data fields is modify
%fields.  No new functions need be written.

   I could have avoided the `_permitted' field entirely, but I wanted to
demonstrate how to store a reference to class data on the object so you
wouldn't have to access that class data directly from an object method.

Inherited Autoloaded Data Methods
---------------------------------

   But what about inheritance?  Can we define our Employee class
similarly?  Yes, so long as we're careful enough.

   Here's how to be careful:

     package Employee;
     use Person;
     use strict;
     our @ISA = qw(Person);

     my %fields = (
     	id          => undef,
     	salary      => undef,
     );

     sub new {
     	my $that  = shift;
     	my $class = ref($that) || $that;
     	my $self = bless $that->SUPER::new(), $class;
     	my($element);
     	foreach $element (keys %fields) {
     	    $self->{_permitted}->{$element} = $fields{$element};
     	}
     	@{$self}{keys %fields} = values %fields;
     	return $self;
     }

   Once we've done this, we don't even need to have an AUTOLOAD function
in the Employee package, because we'll grab Person's version of that via
inheritance, and it will all work out just fine.

Metaclassical Tools
===================

   Even though proxy methods can provide a more convenient approach to
making more struct-like classes than tediously coding up data methods as
functions, it still leaves a bit to be desired.  For one thing, it means
you have to handle bogus calls that you don't mean to trap via your proxy.
It also means you have to be quite careful when dealing with inheritance,
as detailed above.

   Perl programmers have responded to this by creating several different
class construction classes.  These metaclasses are classes that create
other classes.  A couple worth looking at are Class::Struct and Alias.
These and other related metaclasses can be found in the modules directory
on CPAN.

Class::Struct
-------------

   One of the older ones is Class::Struct.  In fact, its syntax and
interface were sketched out long before perl5 even solidified into a real
thing.  What it does is provide you a way to "declare" a class as having
objects whose fields are of a specific type.  The function that does this
is called, not surprisingly enough, struct().  Because structures or
records are not base types in Perl, each time you want to create a class
to provide a record-like data object, you yourself have to define a new()
method, plus separate data-access methods for each of that record's
fields.  You'll quickly become bored with this process.  The
Class::Struct::struct() function alleviates this tedium.

   Here's a simple example of using it:

     use Class::Struct qw(struct);
     use Jobbie;  # user-defined; see below

     struct 'Fred' => {
         one        => '$',
         many       => '@',
         profession => Jobbie,  # calls Jobbie->new()
     };

     $ob = Fred->new;
     $ob->one("hmmmm");

     $ob->many(0, "here");
     $ob->many(1, "you");
     $ob->many(2, "go");
     print "Just set: ", $ob->many(2), "\n";

     $ob->profession->salary(10_000);

   You can declare types in the struct to be basic Perl types, or
user-defined types (classes).  User types will be initialized by calling
that class's new() method.

   Here's a real-world example of using struct generation.  Let's say you
wanted to override Perl's idea of gethostbyname() and gethostbyaddr() so
that they would return objects that acted like C structures.  We don't
care about high-falutin' OO gunk.  All we want is for these objects to act
like structs in the C sense.

     use Socket;
     use Net::hostent;
     $h = gethostbyname("perl.com");  # object return
     printf "perl.com's real name is %s, address %s\n",
     	$h->name, inet_ntoa($h->addr);

   Here's how to do this using the Class::Struct module.  The crux is
going to be this call:

     struct 'Net::hostent' => [  	# note bracket
     	name       => '$',
     	aliases    => '@',
     	addrtype   => '$',
     	'length'   => '$',
     	addr_list  => '@',
      ];

   Which creates object methods of those names and types.  It even creates
a new() method for us.

   We could also have implemented our object this way:

     struct 'Net::hostent' => {  	# note brace
     	name       => '$',
     	aliases    => '@',
     	addrtype   => '$',
     	'length'   => '$',
     	addr_list  => '@',
      };

   and then Class::Struct would have used an anonymous hash as the object
type, instead of an anonymous array.  The array is faster and smaller, but
the hash works out better if you eventually want to do inheritance.  Since
for this struct-like object we aren't planning on inheritance, this time
we'll opt for better speed and size over better flexibility.

   Here's the whole implementation:

     package Net::hostent;
     use strict;

     BEGIN {
     	use Exporter   ();
     	our @EXPORT      = qw(gethostbyname gethostbyaddr gethost);
     	our @EXPORT_OK   = qw(
     			       $h_name         @h_aliases
     			       $h_addrtype     $h_length
     			       @h_addr_list    $h_addr
     			   );
     	our %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
     }
     our @EXPORT_OK;

     # Class::Struct forbids use of @ISA
     sub import { goto &Exporter::import }

     use Class::Struct qw(struct);
     struct 'Net::hostent' => [
        name        => '$',
        aliases     => '@',
        addrtype    => '$',
        'length'    => '$',
        addr_list   => '@',
     ];

     sub addr { shift->addr_list->[0] }

     sub populate (@) {
     	return unless @_;
     	my $hob = new();  # Class::Struct made this!
     	$h_name     =    $hob->[0]              = $_[0];
     	@h_aliases  = @{ $hob->[1] } = split ' ', $_[1];
     	$h_addrtype =    $hob->[2]              = $_[2];
     	$h_length   =    $hob->[3]              = $_[3];
     	$h_addr     =                             $_[4];
     	@h_addr_list = @{ $hob->[4] } =         @_[ (4 .. $#_) ];
     	return $hob;
     }

     sub gethostbyname ($)  { populate(CORE::gethostbyname(shift)) }

     sub gethostbyaddr ($;$) {
     	my ($addr, $addrtype);
     	$addr = shift;
     	require Socket unless @_;
     	$addrtype = @_ ? shift : Socket::AF_INET();
     	populate(CORE::gethostbyaddr($addr, $addrtype))
     }

     sub gethost($) {
     	if ($_[0] =~ /^\d+(?:\.\d+(?:\.\d+(?:\.\d+)?)?)?$/) {
     	   require Socket;
     	   &gethostbyaddr(Socket::inet_aton(shift));
     	} else {
     	   &gethostbyname;
     	}
     }

     1;

   We've snuck in quite a fair bit of other concepts besides just dynamic
class creation, like overriding core functions, import/export bits,
function prototyping, short-cut function call via `&whatever', and
function replacement with `goto &whatever'.  These all mostly make sense
from the perspective of a traditional module, but as you can see, we can
also use them in an object module.

   You can look at other object-based, struct-like overrides of core
functions in the 5.004 release of Perl in File::stat, Net::hostent,
Net::netent, Net::protoent, Net::servent, Time::gmtime, Time::localtime,
User::grent, and User::pwent.  These modules have a final component that's
all lowercase, by convention reserved for compiler pragmas, because they
affect the compilation and change a builtin function.  They also have the
type names that a C programmer would most expect.

Data Members as Variables
-------------------------

   If you're used to C++ objects, then you're accustomed to being able to
get at an object's data members as simple variables from within a method.
The Alias module provides for this, as well as a good bit more, such as
the possibility of private methods that the object can call but folks
outside the class cannot.

   Here's an example of creating a Person using the Alias module.  When
you update these magical instance variables, you automatically update
value fields in the hash.  Convenient, eh?

     package Person;

     # this is the same as before...
     sub new {
     	 my $that  = shift;
     	 my $class = ref($that) || $that;
     	 my $self = {
     	    NAME  => undef,
     	    AGE   => undef,
     	    PEERS => [],
     	};
     	bless($self, $class);
     	return $self;
     }

     use Alias qw(attr);
     our ($NAME, $AGE, $PEERS);

     sub name {
     	my $self = attr shift;
     	if (@_) { $NAME = shift; }
     	return    $NAME;
     }

     sub age {
     	my $self = attr shift;
     	if (@_) { $AGE = shift; }
     	return    $AGE;
     }

     sub peers {
     	my $self = attr shift;
     	if (@_) { @PEERS = @_; }
     	return    @PEERS;
     }

     sub exclaim {
         my $self = attr shift;
         return sprintf "Hi, I'm %s, age %d, working with %s",
             $NAME, $AGE, join(", ", @PEERS);
     }

     sub happy_birthday {
         my $self = attr shift;
         return ++$AGE;
     }

   The need for the our declaration is because what Alias does is play
with package globals with the same name as the fields.  To use globals
while `use strict' is in effect, you have to predeclare them.  These
package variables are localized to the block enclosing the attr() call
just as if you'd used a local() on them.  However, that means that they're
still considered global variables with temporary values, just as with any
other local().

   It would be nice to combine Alias with something like Class::Struct or
Class::MethodMaker.

NOTES
-----

Object Terminology
------------------

   In the various OO literature, it seems that a lot of different words
are used to describe only a few different concepts.  If you're not already
an object programmer, then you don't need to worry about all these fancy
words.  But if you are, then you might like to know how to get at the same
concepts in Perl.

   For example, it's common to call an object an instance of a class and
to call those objects' methods *instance methods*.  Data fields peculiar
to each object are often called *instance data* or *object attributes*,
and data fields common to all members of that class are *class data*,
class attributes, or *static data members*.

   Also, *base class*, *generic class*, and superclass all describe the
same notion, whereas *derived class*, *specific class*, and *subclass*
describe the other related one.

   C++ programmers have *static methods* and *virtual methods*, but Perl
only has *class methods* and *object methods*.  Actually, Perl only has
methods.  Whether a method gets used as a class or object method is by
usage only.  You could accidentally call a class method (one expecting a
string argument) on an object (one expecting a reference), or vice versa.

   From the C++ perspective, all methods in Perl are virtual.  This, by
the way, is why they are never checked for function prototypes in the
argument list as regular builtin and user-defined functions can be.

   Because a class is itself something of an object, Perl's classes can be
taken as describing both a "class as meta-object" (also called *object
factory*) philosophy and the "class as type definition" (*declaring*
behaviour, not *defining* mechanism) idea.  C++ supports the latter
notion, but not the former.

SEE ALSO
========

   The following manpages will doubtless provide more background for this
one: *Note Perlmod: perlmod,, *Note Perlref: perlref,, *Note Perlobj:
perlobj,, *Note Perlbot: perlbot,, *Note Perltie: perltie,, and *Note
Overload: (pm.info)overload,.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997, 1998 Tom Christiansen All rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.

COPYRIGHT
=========

Acknowledgments
---------------

   Thanks to Larry Wall, Roderick Schertler, Gurusamy Sarathy, Dean
Roehrich, Raphael Manfredi, Brent Halsey, Greg Bacon, Brad Appleton, and
many others for their helpful comments.


File: perl.info,  Node: perltootc,  Next: perlobj,  Prev: perltoot,  Up: Top

Tom's OO Tutorial for Class Data in Perl
****************************************

NAME
====

   perltootc - Tom's OO Tutorial for Class Data in Perl

DESCRIPTION
===========

   When designing an object class, you are sometimes faced with the
situation of wanting common state shared by all objects of that class.
Such class attributes act somewhat like global variables for the entire
class, but unlike program-wide globals, class attributes have meaning only
to the class itself.

   Here are a few examples where class attributes might come in handy:

   * to keep a count of the objects you've created, or how many are still
     extant.

   * to extract the name or file descriptor for a logfile used by a
     debugging method.

   * to access collective data, like the total amount of cash dispensed by
     all ATMs in a network in a given day.

   * to access the last object created by a class, or the most accessed
     object, or to retrieve a list of all objects.

   Unlike a true global, class attributes should not be accessed directly.
Instead, their state should be inspected, and perhaps altered, only
through the mediated access of *class methods*.  These class attributes
accessor methods are similar in spirit and function to accessors used to
manipulate the state of instance attributes on an object.  They provide a
clear firewall between interface and implementation.

   You should allow access to class attributes through either the class
name or any object of that class.  If we assume that $an_object is of type
Some_Class, and the &Some_Class::population_count method accesses class
attributes, then these two invocations should both be possible, and almost
certainly equivalent.

     Some_Class->population_count()
     $an_object->population_count()

   The question is, where do you store the state which that method
accesses?  Unlike more restrictive languages like C++, where these are
called static data members, Perl provides no syntactic mechanism to declare
class attributes, any more than it provides a syntactic mechanism to
declare instance attributes.  Perl provides the developer with a broad set
of powerful but flexible features that can be uniquely crafted to the
particular demands of the situation.

   A class in Perl is typically implemented in a module.  A module consists
of two complementary feature sets: a package for interfacing with the
outside world, and a lexical file scope for privacy.  Either of these two
mechanisms can be used to implement class attributes.  That means you get
to decide whether to put your class attributes in package variables or to
put them in lexical variables.

   And those aren't the only decisions to make.  If you choose to use
package variables, you can make your class attribute accessor methods
either ignorant of inheritance or sensitive to it.  If you choose lexical
variables, you can elect to permit access to them from anywhere in the
entire file scope, or you can limit direct data access exclusively to the
methods implementing those attributes.

Class Data as Package Variables
===============================

   Because a class in Perl is really just a package, using package
variables to hold class attributes is the most natural choice.  This makes
it simple for each class to have its own class attributes.  Let's say you
have a class called Some_Class that needs a couple of different attributes
that you'd like to be global to the entire class.  The simplest thing to
do is to use package variables like $Some_Class::CData1 and
$Some_Class::CData2 to hold these attributes.  But we certainly don't want
to encourage outsiders to touch those data directly, so we provide methods
to mediate access.

   In the accessor methods below, we'll for now just ignore the first
argument-that part to the left of the arrow on method invocation, which is
either a class name or an object reference.

     package Some_Class;
     sub CData1 {
     	shift;	# XXX: ignore calling class/object
     	$Some_Class::CData1 = shift if @_;
     	return $Some_Class::CData1;
     }
     sub CData2 {
     	shift;	# XXX: ignore calling class/object
     	$Some_Class::CData2 = shift if @_;
     	return $Some_Class::CData2;
     }

   This technique is highly legible and should be completely
straightforward to even the novice Perl programmer.  By fully qualifying
the package variables, they stand out clearly when reading the code.
Unfortunately, if you misspell one of these, you've introduced an error
that's hard to catch.  It's also somewhat disconcerting to see the class
name itself hard-coded in so many places.

   Both these problems can be easily fixed.  Just add the `use strict'
pragma, then pre-declare your package variables.  (The our operator will
be new in 5.6, and will work for package globals just like my works for
scoped lexicals.)

     package Some_Class;
     use strict;
     our($CData1, $CData2);   	# our() is new to perl5.6
     sub CData1 {
     	shift;	# XXX: ignore calling class/object
     	$CData1 = shift if @_;
     	return $CData1;
     }
     sub CData2 {
     	shift;	# XXX: ignore calling class/object
     	$CData2 = shift if @_;
     	return $CData2;
     }

   As with any other global variable, some programmers prefer to start
their package variables with capital letters.  This helps clarity
somewhat, but by no longer fully qualifying the package variables, their
significance can be lost when reading the code.  You can fix this easily
enough by choosing better names than were used here.

Putting All Your Eggs in One Basket
-----------------------------------

   Just as the mindless enumeration of accessor methods for instance
attributes grows tedious after the first few (see *Note Perltoot:
perltoot,), so too does the repetition begin to grate when listing out
accessor methods for class data.  Repetition runs counter to the primary
virtue of a programmer: Laziness, here manifesting as that innate urge
every programmer feels to factor out duplicate code whenever possible.

   Here's what to do.  First, make just one hash to hold all class
attributes.

     package Some_Class;
     use strict;
     our %ClassData = (   	# our() is new to perl5.6
     	CData1 => "",
     	CData2 => "",
     );

   Using closures (see *Note Perlref: perlref,) and direct access to the
package symbol table (see *Note Perlmod: perlmod,), now clone an accessor
method for each key in the %ClassData hash.  Each of these methods is used
to fetch or store values to the specific, named class attribute.

     for my $datum (keys %ClassData) {
     	no strict "refs";	# to register new methods in package
     	*$datum = sub {
     	    shift;	# XXX: ignore calling class/object
     	    $ClassData{$datum} = shift if @_;
     	    return $ClassData{$datum};
     	}
     }

   It's true that you could work out a solution employing an &AUTOLOAD
method, but this approach is unlikely to prove satisfactory.  Your
function would have to distinguish between class attributes and object
attributes; it could interfere with inheritance; and it would have to
careful about DESTROY.  Such complexity is uncalled for in most cases, and
certainly in this one.

   You may wonder why we're rescinding strict refs for the loop.  We're
manipulating the package's symbol table to introduce new function names
using symbolic references (indirect naming), which the strict pragma would
otherwise forbid.  Normally, symbolic references are a dodgy notion at
best.  This isn't just because they can be used accidentally when you
aren't meaning to.  It's also because for most uses to which beginning
Perl programmers attempt to put symbolic references, we have much better
approaches, like nested hashes or hashes of arrays.  But there's nothing
wrong with using symbolic references to manipulate something that is
meaningful only from the perspective of the package symbol symbol table,
like method names or package variables.  In other words, when you want to
refer to the symbol table, use symbol references.

   Clustering all the class attributes in one place has several advantages.
They're easy to spot, initialize, and change.  The aggregation also makes
them convenient to access externally, such as from a debugger or a
persistence package.  The only possible problem is that we don't
automatically know the name of each class's class object, should it have
one.  This issue is addressed below in `"The Eponymous Meta-Object"' in
this node.

Inheritance Concerns
--------------------

   Suppose you have an instance of a derived class, and you access class
data using an inherited method call.  Should that end up referring to the
base class's attributes, or to those in the derived class?  How would it
work in the earlier examples?  The derived class inherits all the base
class's methods, including those that access class attributes.  But what
package are the class attributes stored in?

   The answer is that, as written, class attributes are stored in the
package into which those methods were compiled.  When you invoke the
&CData1 method on the name of the derived class or on one of that class's
objects, the version shown above is still run, so you'll access
$Some_Class::CData1-or in the method cloning version,
`$Some_Class::ClassData{CData1}'.

   Think of these class methods as executing in the context of their base
class, not in that of their derived class.  Sometimes this is exactly what
you want.  If Feline subclasses Carnivore, then the population of
Carnivores in the world should go up when a new Feline is born.  But what
if you wanted to figure out how many Felines you have apart from
Carnivores?  The current approach doesn't support that.

   You'll have to decide on a case-by-case basis whether it makes any sense
for class attributes to be package-relative.  If you want it to be so,
then stop ignoring the first argument to the function.  Either it will be
a package name if the method was invoked directly on a class name, or else
it will be an object reference if the method was invoked on an object
reference.  In the latter case, the ref() function provides the class of
that object.

     package Some_Class;
     sub CData1 {
     	my $obclass = shift;
     	my $class   = ref($obclass) || $obclass;
     	my $varname = $class . "::CData1";
     	no strict "refs"; 	# to access package data symbolically
     	$$varname = shift if @_;
     	return $$varname;
     }

   And then do likewise for all other class attributes (such as CData2,
etc.) that you wish to access as package variables in the invoking package
instead of the compiling package as we had previously.

   Once again we temporarily disable the strict references ban, because
otherwise we couldn't use the fully-qualified symbolic name for the
package global.  This is perfectly reasonable: since all package variables
by definition live in a package, there's nothing wrong with accessing them
via that package's symbol table.  That's what it's there for (well,
somewhat).

   What about just using a single hash for everything and then cloning
methods?  What would that look like?  The only difference would be the
closure used to produce new method entries for the class's symbol table.

     no strict "refs";
     *$datum = sub {
     	my $obclass = shift;
     	my $class   = ref($obclass) || $obclass;
     	my $varname = $class . "::ClassData";
     	$varname->{$datum} = shift if @_;
     	return $varname->{$datum};
     }

The Eponymous Meta-Object
-------------------------

   It could be argued that the %ClassData hash in the previous example is
neither the most imaginative nor the most intuitive of names.  Is there
something else that might make more sense, be more useful, or both?

   As it happens, yes, there is.  For the "class meta-object", we'll use a
package variable of the same name as the package itself.  Within the scope
of a package Some_Class declaration, we'll use the eponymously named hash
%Some_Class as that class's meta-object.  (Using an eponymously named hash
is somewhat reminiscent of classes that name their constructors
eponymously in the Python or C++ fashion.  That is, class Some_Class would
use &Some_Class::Some_Class as a constructor, probably even exporting that
name as well.  The StrNum class in Recipe 13.14 in *The Perl Cookbook*
does this, if you're looking for an example.)

   This predictable approach has many benefits, including having a
well-known identifier to aid in debugging, transparent persistence, or
checkpointing.  It's also the obvious name for monadic classes and
translucent attributes, discussed later.

   Here's an example of such a class.  Notice how the name of the hash
storing the meta-object is the same as the name of the package used to
implement the class.

     package Some_Class;
     use strict;

     # create class meta-object using that most perfect of names
     our %Some_Class = (   	# our() is new to perl5.6
     	CData1 => "",
     	CData2 => "",
     );

     # this accessor is calling-package-relative
     sub CData1 {
     	my $obclass = shift;
     	my $class   = ref($obclass) || $obclass;
     	no strict "refs"; 	# to access eponymous meta-object
     	$class->{CData1} = shift if @_;
     	return $class->{CData1};
     }

     # but this accessor is not
     sub CData2 {
     	shift;			# XXX: ignore calling class/object
     	no strict "refs"; 	# to access eponymous meta-object
     	__PACKAGE__ -> {CData2} = shift if @_;
     	return __PACKAGE__ -> {CData2};
     }

   In the second accessor method, the __PACKAGE__ notation was used for
two reasons.  First, to avoid hardcoding the literal package name in the
code in case we later want to change that name.  Second, to clarify to the
reader that what matters here is the package currently being compiled
into, not the package of the invoking object or class.  If the long
sequence of non-alphabetic characters bothers you, you can always put the
__PACKAGE__ in a variable first.

     sub CData2 {
     	shift;			# XXX: ignore calling class/object
     	no strict "refs"; 	# to access eponymous meta-object
     	my $class = __PACKAGE__;
     	$class->{CData2} = shift if @_;
     	return $class->{CData2};
     }

   Even though we're using symbolic references for good not evil, some
folks tend to become unnerved when they see so many places with strict ref
checking disabled.  Given a symbolic reference, you can always produce a
real reference (the reverse is not true, though).  So we'll create a
subroutine that does this conversion for us.  If invoked as a function of
no arguments, it returns a reference to the compiling class's eponymous
hash.  Invoked as a class method, it returns a reference to the eponymous
hash of its caller.  And when invoked as an object method, this function
returns a reference to the eponymous hash for whatever class the object
belongs to.

     package Some_Class;
     use strict;

     our %Some_Class = (   	# our() is new to perl5.6
     	CData1 => "",
     	CData2 => "",
     );

     # tri-natured: function, class method, or object method
     sub _classobj {
     	my $obclass = shift || __PACKAGE__;
     	my $class   = ref($obclass) || $obclass;
     	no strict "refs";   # to convert sym ref to real one
     	return \%$class;
     }

     for my $datum (keys %{ _classobj() } ) {
     	# turn off strict refs so that we can
     	# register a method in the symbol table
     	no strict "refs";
     	*$datum = sub {
     	    use strict "refs";
     	    my $self = shift->_classobj();
     	    $self->{$datum} = shift if @_;
     	    return $self->{$datum};
     	}
     }

Indirect References to Class Data
---------------------------------

   A reasonably common strategy for handling class attributes is to store
a reference to each package variable on the object itself.  This is a
strategy you've probably seen before, such as in *Note Perltoot: perltoot,
and *Note Perlbot: perlbot,, but there may be variations in the example
below that you haven't thought of before.

     package Some_Class;
     our($CData1, $CData2);      	# our() is new to perl5.6

     sub new {
     	my $obclass = shift;
     	return bless my $self = {
     	    ObData1 => "",
     	    ObData2 => "",
     	    CData1  => \$CData1,
     	    CData2  => \$CData2,
     	} => (ref $obclass || $obclass);
     }

     sub ObData1 {
     	my $self = shift;
     	$self->{ObData1} = shift if @_;
     	return $self->{ObData1};
     }

     sub ObData2 {
     	my $self = shift;
     	$self->{ObData2} = shift if @_;
     	return $self->{ObData2};
     }

     sub CData1 {
     	my $self = shift;
     	my $dataref = ref $self
     			? $self->{CData1}
     			: \$CData1;
     	$$dataref = shift if @_;
     	return $$dataref;
     }

     sub CData2 {
     	my $self = shift;
     	my $dataref = ref $self
     			? $self->{CData2}
     			: \$CData2;
     	$$dataref = shift if @_;
     	return $$dataref;
     }

   As written above, a derived class will inherit these methods, which
will consequently access package variables in the base class's package.
This is not necessarily expected behavior in all circumstances.  Here's an
example that uses a variable meta-object, taking care to access the proper
package's data.

     package Some_Class;
     use strict;

     our %Some_Class = (   	# our() is new to perl5.6
         CData1 => "",
         CData2 => "",
     );

     sub _classobj {
         my $self  = shift;
         my $class = ref($self) || $self;
         no strict "refs";
         # get (hard) ref to eponymous meta-object
         return \%$class;
     }

     sub new {
         my $obclass  = shift;
         my $classobj = $obclass->_classobj();
         bless my $self = {
     	ObData1 => "",
     	ObData2 => "",
     	CData1  => \$classobj->{CData1},
     	CData2  => \$classobj->{CData2},
         } => (ref $obclass || $obclass);
         return $self;
     }

     sub ObData1 {
         my $self = shift;
         $self->{ObData1} = shift if @_;
         return $self->{ObData1};
     }

     sub ObData2 {
         my $self = shift;
         $self->{ObData2} = shift if @_;
         return $self->{ObData2};
     }

     sub CData1 {
         my $self = shift;
         $self = $self->_classobj() unless ref $self;
         my $dataref = $self->{CData1};
         $$dataref = shift if @_;
         return $$dataref;
     }

     sub CData2 {
         my $self = shift;
         $self = $self->_classobj() unless ref $self;
         my $dataref = $self->{CData2};
         $$dataref = shift if @_;
         return $$dataref;
     }

   Not only are we now strict refs clean, using an eponymous meta-object
seems to make the code cleaner.  Unlike the previous version, this one
does something interesting in the face of inheritance: it accesses the
class meta-object in the invoking class instead of the one into which the
method was initially compiled.

   You can easily access data in the class meta-object, making it easy to
dump the complete class state using an external mechanism such as when
debugging or implementing a persistent class.  This works because the
class meta-object is a package variable, has a well-known name, and
clusters all its data together.  (Transparent persistence is not always
feasible, but it's certainly an appealing idea.)

   There's still no check that object accessor methods have not been
invoked on a class name.  If strict ref checking is enabled, you'd blow
up.  If not, then you get the eponymous meta-object.  What you do with-or
about-this is up to you.  The next two sections demonstrate innovative
uses for this powerful feature.

Monadic Classes
---------------

   Some of the standard modules shipped with Perl provide class interfaces
without any attribute methods whatsoever.  The most commonly used module
not numbered amongst the pragmata, the Exporter module, is a class with
neither constructors nor attributes.  Its job is simply to provide a
standard interface for modules wishing to export part of their namespace
into that of their caller.  Modules use the Exporter's &import method by
setting their inheritance list in their package's @ISA array to mention
"Exporter".  But class Exporter provides no constructor, so you can't have
several instances of the class.  In fact, you can't have any-it just
doesn't make any sense.  All you get is its methods.  Its interface
contains no statefulness, so state data is wholly superfluous.

   Another sort of class that pops up from time to time is one that
supports a unique instance.  Such classes are called *monadic classes*, or
less formally, *singletons* or *highlander classes*.

   If a class is monadic, where do you store its state, that is, its
attributes?  How do you make sure that there's never more than one
instance?  While you could merely use a slew of package variables, it's a
lot cleaner to use the eponymously named hash.  Here's a complete example
of a monadic class:

     package Cosmos;
     %Cosmos = ();

     # accessor method for "name" attribute
     sub name {
     	my $self = shift;
     	$self->{name} = shift if @_;
     	return $self->{name};
     }

     # read-only accessor method for "birthday" attribute
     sub birthday {
     	my $self = shift;
     	die "can't reset birthday" if @_;  # XXX: croak() is better
     	return $self->{birthday};
     }

     # accessor method for "stars" attribute
     sub stars {
     	my $self = shift;
     	$self->{stars} = shift if @_;
     	return $self->{stars};
     }

     # oh my - one of our stars just went out!
     sub supernova {
     	my $self = shift;
     	my $count = $self->stars();
     	$self->stars($count - 1) if $count > 0;
     }

     # constructor/initializer method - fix by reboot
     sub bigbang {
     	my $self = shift;
     	%$self = (
     	    name  	 => "the world according to tchrist",
     	    birthday 	 => time(),
     	    stars 	 => 0,
     	);
     	return $self;	    # yes, it's probably a class.  SURPRISE!
     }

     # After the class is compiled, but before any use or require
     # returns, we start off the universe with a bang.
     __PACKAGE__ -> bigbang();

   Hold on, that doesn't look like anything special.  Those attribute
accessors look no different than they would if this were a regular class
instead of a monadic one.  The crux of the matter is there's nothing that
says that $self must hold a reference to a blessed object.  It merely has
to be something you can invoke methods on.  Here the package name itself,
Cosmos, works as an object.  Look at the &supernova method.  Is that a
class method or an object method?  The answer is that static analysis
cannot reveal the answer.  Perl doesn't care, and neither should you.  In
the three attribute methods, `%$self' is really accessing the %Cosmos
package variable.

   If like Stephen Hawking, you posit the existence of multiple,
sequential, and unrelated universes, then you can invoke the &bigbang
method yourself at any time to start everything all over again.  You might
think of &bigbang as more of an initializer than a constructor, since the
function doesn't allocate new memory; it only initializes what's already
there.  But like any other constructor, it does return a scalar value to
use for later method invocations.

   Imagine that some day in the future, you decide that one universe just
isn't enough.  You could write a new class from scratch, but you already
have an existing class that does what you want-except that it's monadic,
and you want more than just one cosmos.

   That's what code reuse via subclassing is all about.  Look how short
the new code is:

     package Multiverse;
     use Cosmos;
     @ISA = qw(Cosmos);

     sub new {
     	my $protoverse = shift;
     	my $class      = ref($protoverse) || $protoverse;
     	my $self       = {};
     	return bless($self, $class)->bigbang();
     }
     1;

   Because we were careful to be good little creators when we designed our
Cosmos class, we can now reuse it without touching a single line of code
when it comes time to write our Multiverse class.  The same code that
worked when invoked as a class method continues to work perfectly well
when invoked against separate instances of a derived class.

   The astonishing thing about the Cosmos class above is that the value
returned by the &bigbang "constructor" is not a reference to a blessed
object at all.  It's just the class's own name.  A class name is, for
virtually all intents and purposes, a perfectly acceptable object.  It has
state, behavior, and identify, the three crucial components of an object
system.  It even manifests inheritance, polymorphism, and encapsulation.
And what more can you ask of an object?

   To understand object orientation in Perl, it's important to recognize
the unification of what other programming languages might think of as class
methods and object methods into just plain methods.  "Class methods" and
"object methods" are distinct only in the compartmentalizing mind of the
Perl programmer, not in the Perl language itself.

   Along those same lines, a constructor is nothing special either, which
is one reason why Perl has no pre-ordained name for them.  "Constructor"
is just an informal term loosely used to describe a method that returns a
scalar value that you can make further method calls against.  So long as
it's either a class name or an object reference, that's good enough.  It
doesn't even have to be a reference to a brand new object.

   You can have as many-or as few-constructors as you want, and you can
name them whatever you care to.  Blindly and obediently using new() for
each and every constructor you ever write is to speak Perl with such a
severe C++ accent that you do a disservice to both languages.  There's no
reason to insist that each class have but one constructor, or that that
constructor be named new(), or that that constructor be used solely as a
class method and not an object method.

   The next section shows how useful it can be to further distance
ourselves from any formal distinction between class method calls and
object method calls, both in constructors and in accessor methods.

Translucent Attributes
----------------------

   A package's eponymous hash can be used for more than just containing
per-class, global state data.  It can also serve as a sort of template
containing default settings for object attributes.  These default settings
can then be used in constructors for initialization of a particular
object.  The class's eponymous hash can also be used to implement
*translucent attributes*.  A translucent attribute is one that has a
class-wide default.  Each object can set its own value for the attribute,
in which case `< $object-'attribute() >> returns that value.  But if no
value has been set, then `< $object-'attribute() >> returns the class-wide
default.

   We'll apply something of a copy-on-write approach to these translucent
attributes.  If you're just fetching values from them, you get
translucency.  But if you store a new value to them, that new value is set
on the current object.  On the other hand, if you use the class as an
object and store the attribute value directly on the class, then the
meta-object's value changes, and later fetch operations on objects with
uninitialized values for those attributes will retrieve the meta-object's
new values.  Objects with their own initialized values, however, won't see
any change.

   Let's look at some concrete examples of using these properties before we
show how to implement them.  Suppose that a class named Some_Class had a
translucent data attribute called "color".  First you set the color in the
meta-object, then you create three objects using a constructor that
happens to be named &spawn.

     use Vermin;
     Vermin->color("vermilion");

     $ob1 = Vermin->spawn();   	# so that's where Jedi come from
     $ob2 = Vermin->spawn();
     $ob3 = Vermin->spawn();

     print $obj3->color();  	# prints "vermilion"

   Each of these objects' colors is now "vermilion", because that's the
meta-object's value that attribute, and these objects do not have
individual color values set.

   Changing the attribute on one object has no effect on other objects
previously created.

     $ob3->color("chartreuse");
     print $ob3->color();  	# prints "chartreuse"
     print $ob1->color();  	# prints "vermilion", translucently

   If you now use $ob3 to spawn off another object, the new object will
take the color its parent held, which now happens to be "chartreuse".
That's because the constructor uses the invoking object as its template
for initializing attributes.  When that invoking object is the class name,
the object used as a template is the eponymous meta-object.  When the
invoking object is a reference to an instantiated object, the &spawn
constructor uses that existing object as a template.

     $ob4 = $ob3->spawn();	# $ob3 now template, not %Vermin
     print $ob4->color();  	# prints "chartreuse"

   Any actual values set on the template object will be copied to the new
object.  But attributes undefined in the template object, being
translucent, will remain undefined and consequently translucent in the new
one as well.

   Now let's change the color attribute on the entire class:

     Vermin->color("azure");
     print $ob1->color();  	# prints "azure"
     print $ob2->color();  	# prints "azure"
     print $ob3->color();  	# prints "chartreuse"
     print $ob4->color();  	# prints "chartreuse"

   That color change took effect only in the first pair of objects, which
were still translucently accessing the meta-object's values.  The second
pair had per-object initialized colors, and so didn't change.

   One important question remains.  Changes to the meta-object are
reflected in translucent attributes in the entire class, but what about
changes to discrete objects?  If you change the color of $ob3, does the
value of $ob4 see that change?  Or vice-versa.  If you change the color of
$ob4, does then the value of $ob3 shift?

     $ob3->color("amethyst");
     print $ob3->color();  	# prints "amethyst"
     print $ob4->color();  	# hmm: "chartreuse" or "amethyst"?

   While one could argue that in certain rare cases it should, let's not
do that.  Good taste aside, we want the answer to the question posed in
the comment above to be "chartreuse", not "amethyst".  So we'll treat
these attributes similar to the way process attributes like environment
variables, user and group IDs, or the current working directory are
treated across a fork().  You can change only yourself, but you will see
those changes reflected in your unspawned children.  Changes to one object
will propagate neither up to the parent nor down to any existing child
objects.  Those objects made later, however, will see the changes.

   If you have an object with an actual attribute value, and you want to
make that object's attribute value translucent again, what do you do?
Let's design the class so that when you invoke an accessor method with
undef as its argument, that attribute returns to translucency.

     $ob4->color(undef);		# back to "azure"

   Here's a complete implementation of Vermin as described above.

     package Vermin;

     # here's the class meta-object, eponymously named.
     # it holds all class attributes, and also all instance attributes
     # so the latter can be used for both initialization
     # and translucency.

     our %Vermin = (   		# our() is new to perl5.6
     	PopCount => 0,		# capital for class attributes
     	color    => "beige",    # small for instance attributes
     );

     # constructor method
     # invoked as class method or object method
     sub spawn {
     	my $obclass = shift;
     	my $class   = ref($obclass) || $obclass;
     	my $self = {};
     	bless($self, $class);
     	$class->{PopCount}++;
     	# init fields from invoking object, or omit if
     	# invoking object is the class to provide translucency
     	%$self = %$obclass if ref $obclass;
     	return $self;
     }

     # translucent accessor for "color" attribute
     # invoked as class method or object method
     sub color {
     	my $self  = shift;
     	my $class = ref($self) || $self;

     # handle class invocation
     unless (ref $self) {
         $class->{color} = shift if @_;
         return $class->{color}
     }

     # handle object invocation
     $self->{color} = shift if @_;
     if (defined $self->{color}) {  # not exists!
         return $self->{color};
     } else {
         return $class->{color};
     }
         }

     # accessor for "PopCount" class attribute
     # invoked as class method or object method
     # but uses object solely to locate meta-object
     sub population {
     	my $obclass = shift;
     	my $class   = ref($obclass) || $obclass;
     	return $class->{PopCount};
     }

     # instance destructor
     # invoked only as object method
     sub DESTROY {
     	my $self  = shift;
     	my $class = ref $self;
     	$class->{PopCount}--;
     }

   Here are a couple of helper methods that might be convenient.  They
aren't accessor methods at all.  They're used to detect accessibility of
data attributes.  The &is_translucent method determines whether a
particular object attribute is coming from the meta-object.  The
&has_attribute method detects whether a class implements a particular
property at all.  It could also be used to distinguish undefined
properties from non-existent ones.

     # detect whether an object attribute is translucent
     # (typically?) invoked only as object method
     sub is_translucent {
     	my($self, $attr)  = @_;
     	return !defined $self->{$attr};
     }

     # test for presence of attribute in class
     # invoked as class method or object method
     sub has_attribute {
     	my($self, $attr)  = @_;
     	my $class = ref $self if $self;
     	return exists $class->{$attr};
     }

   If you prefer to install your accessors more generically, you can make
use of the upper-case versus lower-case convention to register into the
package appropriate methods cloned from generic closures.

     for my $datum (keys %{ +__PACKAGE__ }) {
     	*$datum = ($datum =~ /^[A-Z]/)
     	    ? sub {  # install class accessor
     		    my $obclass = shift;
     		    my $class   = ref($obclass) || $obclass;
     		    return $class->{$datum};
     		  }
     	    : sub { # install translucent accessor
     		    my $self  = shift;
     		    my $class = ref($self) || $self;
     		    unless (ref $self) {
     			$class->{$datum} = shift if @_;
     			return $class->{$datum}
     		    }
     		    $self->{$datum} = shift if @_;
     		    return defined $self->{$datum}
     			? $self  -> {$datum}
     			: $class -> {$datum}
     		  }
     }

   Translations of this closure-based approach into C++, Java, and Python
have been left as exercises for the reader.  Be sure to send us mail as
soon as you're done.

Class Data as Lexical Variables
===============================

Privacy and Responsibility
--------------------------

   Unlike conventions used by some Perl programmers, in the previous
examples, we didn't prefix the package variables used for class attributes
with an underscore, nor did we do so for the names of the hash keys used
for instance attributes.  You don't need little markers on data names to
suggest nominal privacy on attribute variables or hash keys, because these
are *already* notionally private!  Outsiders have no business whatsoever
playing with anything within a class save through the mediated access of
its documented interface; in other words, through method invocations.  And
not even through just any method, either.  Methods that begin with an
underscore are traditionally considered off-limits outside the class.  If
outsiders skip the documented method interface to poke around the
internals of your class and end up breaking something, that's not your
fault-it's theirs.

   Perl believes in individual responsibility rather than mandated control.
Perl respects you enough to let you choose your own preferred level of
pain, or of pleasure.  Perl believes that you are creative, intelligent,
and capable of making your own decisions-and fully expects you to take
complete responsibility for your own actions.  In a perfect world, these
admonitions alone would suffice, and everyone would be intelligent,
responsible, happy, and creative.  And careful.  One probably shouldn't
forget careful, and that's a good bit harder to expect.  Even Einstein
would take wrong turns by accident and end up lost in the wrong part of
town.

   Some folks get the heebie-jeebies when they see package variables
hanging out there for anyone to reach over and alter them.  Some folks
live in constant fear that someone somewhere might do something wicked.
The solution to that problem is simply to fire the wicked, of course.  But
unfortunately, it's not as simple as all that.  These cautious types are
also afraid that they or others will do something not so much wicked as
careless, whether by accident or out of desperation.  If we fire everyone
who ever gets careless, pretty soon there won't be anybody left to get any
work done.

   Whether it's needless paranoia or sensible caution, this uneasiness can
be a problem for some people.  We can take the edge off their discomfort
by providing the option of storing class attributes as lexical variables
instead of as package variables.  The my() operator is the source of all
privacy in Perl, and it is a powerful form of privacy indeed.

   It is widely perceived, and indeed has often been written, that Perl
provides no data hiding, that it affords the class designer no privacy nor
isolation, merely a rag-tag assortment of weak and unenforcible social
conventions instead.  This perception is demonstrably false and easily
disproven.  In the next section, we show how to implement forms of privacy
that are far stronger than those provided in nearly any other
object-oriented language.

File-Scoped Lexicals
--------------------

   A lexical variable is visible only through the end of its static scope.
That means that the only code able to access that variable is code
residing textually below the my() operator through the end of its block if
it has one, or through the end of the current file if it doesn't.

   Starting again with our simplest example given at the start of this
document, we replace our() variables with my() versions.

     package Some_Class;
     my($CData1, $CData2);   # file scope, not in any package
     sub CData1 {
     	shift;	# XXX: ignore calling class/object
     	$CData1 = shift if @_;
     	return $CData1;
     }
     sub CData2 {
     	shift;	# XXX: ignore calling class/object
     	$CData2 = shift if @_;
     	return $CData2;
     }

   So much for that old $Some_Class::CData1 package variable and its
brethren!  Those are gone now, replaced with lexicals.  No one outside the
scope can reach in and alter the class state without resorting to the
documented interface.  Not even subclasses or superclasses of this one
have unmediated access to $CData1.  They have to invoke the &CData1 method
against Some_Class or an instance thereof, just like anybody else.

   To be scrupulously honest, that last statement assumes you haven't
packed several classes together into the same file scope, nor strewn your
class implementation across several different files.  Accessibility of
those variables is based uniquely on the static file scope.  It has
nothing to do with the package.  That means that code in a different file
but the same package (class) could not access those variables, yet code in
the same file but a different package (class) could.  There are sound
reasons why we usually suggest a one-to-one mapping between files and
packages and modules and classes.  You don't have to stick to this
suggestion if you really know what you're doing, but you're apt to confuse
yourself otherwise, especially at first.

   If you'd like to aggregate your class attributes into one lexically
scoped, composite structure, you're perfectly free to do so.

     package Some_Class;
     my %ClassData = (
     	CData1 => "",
     	CData2 => "",
     );
     sub CData1 {
     	shift;	# XXX: ignore calling class/object
     	$ClassData{CData1} = shift if @_;
     	return $ClassData{CData1};
     }
     sub CData2 {
     	shift;	# XXX: ignore calling class/object
     	$ClassData{CData2} = shift if @_;
     	return $ClassData{CData2};
     }

   To make this more scalable as other class attributes are added, we can
again register closures into the package symbol table to create accessor
methods for them.

     package Some_Class;
     my %ClassData = (
     	CData1 => "",
     	CData2 => "",
     );
     for my $datum (keys %ClassData) {
     	no strict "refs";
     	*$datum = sub {
     	    shift;	# XXX: ignore calling class/object
     	    $ClassData{$datum} = shift if @_;
     	    return $ClassData{$datum};
     	};
     }

   Requiring even your own class to use accessor methods like anybody else
is probably a good thing.  But demanding and expecting that everyone else,
be they subclass or superclass, friend or foe, will all come to your
object through mediation is more than just a good idea.  It's absolutely
critical to the model.  Let there be in your mind no such thing as
"public" data, nor even "protected" data, which is a seductive but
ultimately destructive notion.  Both will come back to bite at you.
That's because as soon as you take that first step out of the solid
position in which all state is considered completely private, save from the
perspective of its own accessor methods, you have violated the envelope.
And, having pierced that encapsulating envelope, you shall doubtless
someday pay the price when future changes in the implementation break
unrelated code.  Considering that avoiding this infelicitous outcome was
precisely why you consented to suffer the slings and arrows of obsequious
abstraction by turning to object orientation in the first place, such
breakage seems unfortunate in the extreme.

More Inheritance Concerns
-------------------------

   Suppose that Some_Class were used as a base class from which to derive
Another_Class.  If you invoke a &CData method on the derived class or on
an object of that class, what do you get?  Would the derived class have
its own state, or would it piggyback on its base class's versions of the
class attributes?

   The answer is that under the scheme outlined above, the derived class
would not have its own state data.  As before, whether you consider this a
good thing or a bad one depends on the semantics of the classes involved.

   The cleanest, sanest, simplest way to address per-class state in a
lexical is for the derived class to override its base class's version of
the method that accesses the class attributes.  Since the actual method
called is the one in the object's derived class if this exists, you
automatically get per-class state this way.  Any urge to provide an
unadvertised method to sneak out a reference to the %ClassData hash should
be strenuously resisted.

   As with any other overridden method, the implementation in the derived
class always has the option of invoking its base class's version of the
method in addition to its own.  Here's an example:

     package Another_Class;
     @ISA = qw(Some_Class);

     my %ClassData = (
     	CData1 => "",
     );

     sub CData1 {
     	my($self, $newvalue) = @_;
     	if (@_ > 1) {
     	    # set locally first
     	    $ClassData{CData1} = $newvalue;

     # then pass the buck up to the first
     # overridden version, if there is one
     if ($self->can("SUPER::CData1")) {
     		$self->SUPER::CData1($newvalue);
     }
     	}
     	return $ClassData{CData1};
         }

   Those dabbling in multiple inheritance might be concerned about there
being more than one override.

     for my $parent (@ISA) {
     	my $methname = $parent . "::CData1";
     	if ($self->can($methname)) {
     	    $self->$methname($newvalue);
     	}
     }

   Because the &UNIVERSAL::can method returns a reference to the function
directly, you can use this directly for a significant performance
improvement:

     for my $parent (@ISA) {
     	if (my $coderef = $self->can($parent . "::CData1")) {
     	    $self->$coderef($newvalue);
     	}
     }

Locking the Door and Throwing Away the Key
------------------------------------------

   As currently implemented, any code within the same scope as the
file-scoped lexical %ClassData can alter that hash directly.  Is that ok?
Is it acceptable or even desirable to allow other parts of the
implementation of this class to access class attributes directly?

   That depends on how careful you want to be.  Think back to the Cosmos
class.  If the &supernova method had directly altered $Cosmos::Stars or
`$Cosmos::Cosmos{stars}', then we wouldn't have been able to reuse the
class when it came to inventing a Multiverse.  So letting even the class
itself access its own class attributes without the mediating intervention
of properly designed accessor methods is probably not a good idea after
all.

   Restricting access to class attributes from the class itself is usually
not enforcible even in strongly object-oriented languages.  But in Perl,
you can.

   Here's one way:

     package Some_Class;

     {  # scope for hiding $CData1
     	my $CData1;
     	sub CData1 {
     	    shift;	# XXX: unused
     	    $CData1 = shift if @_;
     	    return $CData1;
     	}
     }

     {  # scope for hiding $CData2
     	my $CData2;
     	sub CData2 {
     	    shift;	# XXX: unused
     	    $CData2 = shift if @_;
     	    return $CData2;
     	}
     }

   No one-absolutely no one-is allowed to read or write the class
attributes without the mediation of the managing accessor method, since
only that method has access to the lexical variable it's managing.  This
use of mediated access to class attributes is a form of privacy far
stronger than most OO languages provide.

   The repetition of code used to create per-datum accessor methods chafes
at our Laziness, so we'll again use closures to create similar methods.

     package Some_Class;

     {  # scope for ultra-private meta-object for class attributes
     	my %ClassData = (
     	    CData1 => "",
     	    CData2 => "",
     	);

     for my $datum (keys %ClassData ) {
         no strict "refs";
         *$datum = sub {
     	use strict "refs";
     	my ($self, $newvalue) = @_;
     	$ClassData{$datum} = $newvalue if @_ > 1;
     	return $ClassData{$datum};
         }
     }

     }

   The closure above can be modified to take inheritance into account using
the &UNIVERSAL::can method and SUPER as shown previously.

Translucency Revisited
----------------------

   The Vermin class demonstrates translucency using a package variable,
eponymously named %Vermin, as its meta-object.  If you prefer to use
absolutely no package variables beyond those necessary to appease
inheritance or possibly the Exporter, this strategy is closed to you.
That's too bad, because translucent attributes are an appealing technique,
so it would be valuable to devise an implementation using only lexicals.

   There's a second reason why you might wish to avoid the eponymous
package hash.  If you use class names with double-colons in them, you
would end up poking around somewhere you might not have meant to poke.

     package Vermin;
     $class = "Vermin";
     $class->{PopCount}++;
     # accesses $Vermin::Vermin{PopCount}

     package Vermin::Noxious;
     $class = "Vermin::Noxious";
     $class->{PopCount}++;
     # accesses $Vermin::Noxious{PopCount}

   In the first case, because the class name had no double-colons, we got
the hash in the current package.  But in the second case, instead of
getting some hash in the current package, we got the hash %Noxious in the
Vermin package.  (The noxious vermin just invaded another package and
sprayed their data around it. :-) Perl doesn't support relative packages
in its naming conventions, so any double-colons trigger a fully-qualified
lookup instead of just looking in the current package.

   In practice, it is unlikely that the Vermin class had an existing
package variable named %Noxious that you just blew away.  If you're still
mistrustful, you could always stake out your own territory where you know
the rules, such as using Eponymous::Vermin::Noxious or
Hieronymus::Vermin::Boschious or Leave_Me_Alone::Vermin::Noxious as class
names instead.  Sure, it's in theory possible that someone else has a
class named Eponymous::Vermin with its own %Noxious hash, but this kind of
thing is always true.  There's no arbiter of package names.  It's always
the case that globals like @Cwd::ISA would collide if more than one class
uses the same Cwd package.

   If this still leaves you with an uncomfortable twinge of paranoia, we
have another solution for you.  There's nothing that says that you have to
have a package variable to hold a class meta-object, either for monadic
classes or for translucent attributes.  Just code up the methods so that
they access a lexical instead.

   Here's another implementation of the Vermin class with semantics
identical to those given previously, but this time using no package
variables.

     package Vermin;

     # Here's the class meta-object, eponymously named.
     # It holds all class data, and also all instance data
     # so the latter can be used for both initialization
     # and translucency.  it's a template.
     my %ClassData = (
     	PopCount => 0,		# capital for class attributes
     	color    => "beige",    # small for instance attributes
     );

     # constructor method
     # invoked as class method or object method
     sub spawn {
     	my $obclass = shift;
     	my $class   = ref($obclass) || $obclass;
     	my $self = {};
     	bless($self, $class);
     	$ClassData{PopCount}++;
     	# init fields from invoking object, or omit if
     	# invoking object is the class to provide translucency
     	%$self = %$obclass if ref $obclass;
     	return $self;
     }

     # translucent accessor for "color" attribute
     # invoked as class method or object method
     sub color {
     	my $self  = shift;

     # handle class invocation
     unless (ref $self) {
         $ClassData{color} = shift if @_;
         return $ClassData{color}
     }

     # handle object invocation
     $self->{color} = shift if @_;
     if (defined $self->{color}) {  # not exists!
         return $self->{color};
     } else {
         return $ClassData{color};
     }
         }

     # class attribute accessor for "PopCount" attribute
     # invoked as class method or object method
     sub population {
     	return $ClassData{PopCount};
     }

     # instance destructor; invoked only as object method
     sub DESTROY {
     	$ClassData{PopCount}--;
     }

     # detect whether an object attribute is translucent
     # (typically?) invoked only as object method
     sub is_translucent {
     	my($self, $attr)  = @_;
     	$self = \%ClassData if !ref $self;
     	return !defined $self->{$attr};
     }

     # test for presence of attribute in class
     # invoked as class method or object method
     sub has_attribute {
     	my($self, $attr)  = @_;
     	return exists $ClassData{$attr};
     }

NOTES
=====

   Inheritance is a powerful but subtle device, best used only after
careful forethought and design.  Aggregation instead of inheritance is
often a better approach.

   We use the hypothetical our() syntax for package variables.  It works
like `use vars', but looks like my().  It should be in this summer's major
release (5.6) of perl-we hope.

   You can't use file-scoped lexicals in conjunction with the SelfLoader
or the AutoLoader, because they alter the lexical scope in which the
module's methods wind up getting compiled.

   The usual mealy-mouthed package-mungeing doubtless applies to setting
up names of object attributes.  For example, `< $self-'{ObData1} >> should
probably be `< $self-'{ __PACKAGE__ . "_ObData1" } >>, but that would just
confuse the examples.

SEE ALSO
========

   *Note Perltoot: perltoot,, *Note Perlobj: perlobj,, *Note Perlmod:
perlmod,, and *Note Perlbot: perlbot,.

   The Tie::SecureHash module from CPAN is worth checking out.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1999 Tom Christiansen.  All rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.

ACKNOWLEDGEMENTS
================

   Russ Albery, Jon Orwant, Randy Ray, Larry Rosler, Nat Torkington, and
Stephen Warren all contributed suggestions and corrections to this piece.
Thanks especially to Damian Conway for his ideas and feedback, and without
whose indirect prodding I might never have taken the time to show others
how much Perl has to offer in the way of objects once you start thinking
outside the tiny little box that today's "popular" object-oriented
languages enforce.

HISTORY
=======

   Last edit: Fri May 21 15:47:56 MDT 1999


File: perl.info,  Node: perltrap,  Next: perlport,  Prev: perlsec,  Up: Top

Perl traps for the unwary
*************************

NAME
====

   perltrap - Perl traps for the unwary

DESCRIPTION
===========

   The biggest trap of all is forgetting to use the -w switch; see *Note
Perlrun: perlrun,.  The second biggest trap is not making your entire
program runnable under `use strict'.  The third biggest trap is not reading
the list of changes in this version of Perl; see *Note Perldelta:
perldelta,.

Awk Traps
---------

   Accustomed *awk* users should take special note of the following:

   * The English module, loaded via

          use English;

     allows you to refer to special variables (like $/) with names (like
     $RS), as though they were in *awk*; see *Note Perlvar: perlvar, for
     details.

   * Semicolons are required after all simple statements in Perl (except
     at the end of a block).  Newline is not a statement delimiter.

   * Curly brackets are required on ifs and whiles.

   * Variables begin with "$", "@" or "%" in Perl.

   * Arrays index from 0.  Likewise string positions in substr() and
     index().

   * You have to decide whether your array has numeric or string indices.

   * Hash values do not spring into existence upon mere reference.

   * You have to decide whether you want to use string or numeric
     comparisons.

   * Reading an input line does not split it for you.  You get to split it
     to an array yourself.  And the split() operator has different
     arguments than *awk*'s.

   * The current input line is normally in $_, not $0.  It generally does
     not have the newline stripped.  ($0 is the name of the program
     executed.)  See *Note Perlvar: perlvar,.

   * $<digit> does not refer to fields-it refers to substrings matched by
     the last match pattern.

   * The print() statement does not add field and record separators unless
     you set $, and $\.  You can set $OFS and $ORS if you're using the
     English module.

   * You must open your files before you print to them.

   * The range operator is "..", not comma.  The comma operator works as in
     C.

   * The match operator is "=~", not "~".  ("~" is the one's complement
     operator, as in C.)

   * The exponentiation operator is "**", not "^".  "^" is the XOR
     operator, as in C.  (You know, one could get the feeling that *awk* is
     basically incompatible with C.)

   * The concatenation operator is ".", not the null string.  (Using the
     null string would render `/pat/ /pat/' unparsable, because the third
     slash would be interpreted as a division operator-the tokenizer is in
     fact slightly context sensitive for operators like "/", "?", and ">".
     And in fact, "." itself can be the beginning of a number.)

   * The next, exit, and continue keywords work differently.

   * The following variables work differently:

          Awk	Perl
          ARGC	$#ARGV or scalar @ARGV
          ARGV[0]	$0
          FILENAME	$ARGV
          FNR	$. - something
          FS	(whatever you like)
          NF	$#Fld, or some such
          NR	$.
          OFMT	$#
          OFS	$,
          ORS	$\
          RLENGTH	length($&)
          RS	$/
          RSTART	length($`)
          SUBSEP	$;

   * You cannot set $RS to a pattern, only a string.

   * When in doubt, run the *awk* construct through a2p and see what it
     gives you.

C Traps
-------

   Cerebral C programmers should take note of the following:

   * Curly brackets are required on if's and while's.

   * You must use `elsif' rather than `else if'.

   * The break and continue keywords from C become in Perl last and next,
     respectively.  Unlike in C, these do not work within a `do { } while'
     construct.

   * There's no switch statement.  (But it's easy to build one on the fly.)

   * Variables begin with "$", "@" or "%" in Perl.

   * printf() does not implement the "*" format for interpolating field
     widths, but it's trivial to use interpolation of double-quoted
     strings to achieve the same effect.

   * Comments begin with "#", not "/*".

   * You can't take the address of anything, although a similar operator
     in Perl is the backslash, which creates a reference.

   * `ARGV' must be capitalized.  `$ARGV[0]' is C's `argv[1]', and
     `argv[0]' ends up in $0.

   * System calls such as link(), unlink(), rename(), etc. return nonzero
     for success, not 0.

   * Signal handlers deal with signal names, not numbers.  Use `kill -l'
     to find their names on your system.

Sed Traps
---------

   Seasoned *sed* programmers should take note of the following:

   * Backreferences in substitutions use "$" rather than "\".

   * The pattern matching metacharacters "(", ")", and "|" do not have
     backslashes in front.

   * The range operator is ..., rather than comma.

Shell Traps
-----------

   Sharp shell programmers should take note of the following:

   * The backtick operator does variable interpolation without regard to
     the presence of single quotes in the command.

   * The backtick operator does no translation of the return value, unlike
     *csh*.

   * Shells (especially *csh*) do several levels of substitution on each
     command line.  Perl does substitution in only certain constructs such
     as double quotes, backticks, angle brackets, and search patterns.

   * Shells interpret scripts a little bit at a time.  Perl compiles the
     entire program before executing it (except for BEGIN blocks, which
     execute at compile time).

   * The arguments are available via @ARGV, not $1, $2, etc.

   * The environment is not automatically made available as separate scalar
     variables.

Perl Traps
----------

   Practicing Perl Programmers should take note of the following:

   * Remember that many operations behave differently in a list context
     than they do in a scalar one.  See *Note Perldata: perldata, for
     details.

   * Avoid barewords if you can, especially all lowercase ones.  You can't
     tell by just looking at it whether a bareword is a function or a
     string.  By using quotes on strings and parentheses on function
     calls, you won't ever get them confused.

   * You cannot discern from mere inspection which builtins are unary
     operators (like chop() and chdir()) and which are list operators
     (like print() and unlink()).  (User-defined subroutines can be *only*
     list operators, never unary ones.)  See *Note Perlop: perlop,.

   * People have a hard time remembering that some functions default to
     $_, or @ARGV, or whatever, but that others which you might expect to
     do not.

   * The <FH> construct is not the name of the filehandle, it is a readline
     operation on that handle.  The data read is assigned to $_ only if the
     file read is the sole condition in a while loop:

          while (<FH>)      { }
          while (defined($_ = <FH>)) { }..
          <FH>;  # data discarded!

   * Remember not to use = when you need `=~'; these two constructs are
     quite different:

          $x =  /foo/;
          $x =~ /foo/;

   * The `do {}' construct isn't a real loop that you can use loop control
     on.

   * Use my() for local variables whenever you can get away with it (but
     see *Note Perlform: perlform, for where you can't).  Using `local()'
     actually gives a local value to a global variable, which leaves you
     open to unforeseen side-effects of dynamic scoping.

   * If you localize an exported variable in a module, its exported value
     will not change.  The local name becomes an alias to a new value but
     the external name is still an alias for the original.

Perl4 to Perl5 Traps
--------------------

   Practicing Perl4 Programmers should take note of the following
Perl4-to-Perl5 specific traps.

   They're crudely ordered according to the following list:

Discontinuance, Deprecation, and BugFix traps
     Anything that's been fixed as a perl4 bug, removed as a perl4 feature
     or deprecated as a perl4 feature with the intent to encourage usage of
     some other perl5 feature.

Parsing Traps
     Traps that appear to stem from the new parser.

Numerical Traps
     Traps having to do with numerical or mathematical operators.

General data type traps
     Traps involving perl standard data types.

Context Traps - scalar, list contexts
     Traps related to context within lists, scalar statements/declarations.

Precedence Traps
     Traps related to the precedence of parsing, evaluation, and execution
     of code.

General Regular Expression Traps using s///, etc.
     Traps related to the use of pattern matching.

Subroutine, Signal, Sorting Traps
     Traps related to the use of signals and signal handlers, general
     subroutines, and sorting, along with sorting subroutines.

OS Traps
     OS-specific traps.

DBM Traps
     Traps specific to the use of `dbmopen()', and specific dbm
     implementations.

Unclassified Traps
     Everything else.

   If you find an example of a conversion trap that is not listed here,
please submit it to Bill Middleton <`wjm@best.com'> for inclusion.  Also
note that at least some of these can be caught with the `use warnings'
pragma or the -w switch.

Discontinuance, Deprecation, and BugFix traps
---------------------------------------------

   Anything that has been discontinued, deprecated, or fixed as a bug from
perl4.

   * Discontinuance

     Symbols starting with "_" are no longer forced into package main,
     except for $_ itself (and `@_', etc.).

          package test;
          $_legacy = 1;

          package main;
          print "\$_legacy is ",$_legacy,"\n";

          # perl4 prints: $_legacy is 1
          # perl5 prints: $_legacy is

   * Deprecation

     Double-colon is now a valid package separator in a variable name.
     Thus these behave differently in perl4 vs. perl5, because the
     packages don't exist.

          $a=1;$b=2;$c=3;$var=4;
          print "$a::$b::$c ";
          print "$var::abc::xyz\n";

          # perl4 prints: 1::2::3 4::abc::xyz
          # perl5 prints: 3

     Given that `::' is now the preferred package delimiter, it is
     debatable whether this should be classed as a bug or not.  (The older
     package delimiter, ' ,is used here)

          $x = 10 ;
          print "x=${'x}\n" ;

          # perl4 prints: x=10
          # perl5 prints: Can't find string terminator "'" anywhere before EOF

     You can avoid this problem, and remain compatible with perl4, if you
     always explicitly include the package name:

          $x = 10 ;
          print "x=${main'x}\n" ;

     Also see precedence traps, for parsing $:.

   * BugFix

     The second and third arguments of `splice()' are now evaluated in
     scalar context (as the Camel says) rather than list context.

          sub sub1{return(0,2) }          # return a 2-element list
          sub sub2{ return(1,2,3)}        # return a 3-element list
          @a1 = ("a","b","c","d","e");
          @a2 = splice(@a1,&sub1,&sub2);
          print join(' ',@a2),"\n";

          # perl4 prints: a b
          # perl5 prints: c d e

   * Discontinuance

     You can't do a goto into a block that is optimized away.  Darn.

          goto marker1;

          for(1){
          marker1:
              print "Here I is!\n";
          }

          # perl4 prints: Here I is!
          # perl5 dumps core (SEGV)

   * Discontinuance

     It is no longer syntactically legal to use whitespace as the name of
     a variable, or as a delimiter for any kind of quote construct.
     Double darn.

          $a = ("foo bar");
          $b = q baz ;
          print "a is $a, b is $b\n";

          # perl4 prints: a is foo bar, b is baz
          # perl5 errors: Bareword found where operator expected

   * Discontinuance

     The archaic while/if BLOCK BLOCK syntax is no longer supported.

          if { 1 } {
              print "True!";
          }
          else {
              print "False!";
          }

          # perl4 prints: True!
          # perl5 errors: syntax error at test.pl line 1, near "if {"

   * BugFix

     The `**' operator now binds more tightly than unary minus.  It was
     documented to work this way before, but didn't.

          print -4**2,"\n";

          # perl4 prints: 16
          # perl5 prints: -16

   * Discontinuance

     The meaning of `foreach{}' has changed slightly when it is iterating
     over a list which is not an array.  This used to assign the list to a
     temporary array, but no longer does so (for efficiency).  This means
     that you'll now be iterating over the actual values, not over copies
     of the values.  Modifications to the loop variable can change the
     original values.

          @list = ('ab','abc','bcd','def');
          foreach $var (grep(/ab/,@list)){
              $var = 1;
          }
          print (join(':',@list));

          # perl4 prints: ab:abc:bcd:def
          # perl5 prints: 1:1:bcd:def

     To retain Perl4 semantics you need to assign your list explicitly to
     a temporary array and then iterate over that.  For example, you might
     need to change

          foreach $var (grep(/ab/,@list)){

     to

          foreach $var (@tmp = grep(/ab/,@list)){

     Otherwise changing $var will clobber the values of @list.  (This most
     often happens when you use $_ for the loop variable, and call
     subroutines in the loop that don't properly localize $_.)

   * Discontinuance

     split with no arguments now behaves like `split ' '' (which doesn't
     return an initial null field if $_ starts with whitespace), it used to
     behave like `split /\s+/' (which does).

          $_ = ' hi mom';
          print join(':', split);

          # perl4 prints: :hi:mom
          # perl5 prints: hi:mom

   * BugFix

     Perl 4 would ignore any text which was attached to an -e switch,
     always taking the code snippet from the following arg.  Additionally,
     it would silently accept an -e switch without a following arg.  Both
     of these behaviors have been fixed.

          perl -e'print "attached to -e"' 'print "separate arg"'

          # perl4 prints: separate arg
          # perl5 prints: attached to -e

          perl -e

          # perl4 prints:
          # perl5 dies: No code specified for -e.

   * Discontinuance

     In Perl 4 the return value of push was undocumented, but it was
     actually the last value being pushed onto the target list.  In Perl 5
     the return value of push is documented, but has changed, it is the
     number of elements in the resulting list.

          @x = ('existing');
          print push(@x, 'first new', 'second new');

          # perl4 prints: second new
          # perl5 prints: 3

   * Deprecation

     Some error messages will be different.

   * Discontinuance

     Some bugs may have been inadvertently removed.  :-)

Parsing Traps
-------------

   Perl4-to-Perl5 traps from having to do with parsing.

   * Parsing

     Note the space between . and =

          $string . = "more string";
          print $string;

          # perl4 prints: more string
          # perl5 prints: syntax error at - line 1, near ". ="

   * Parsing

     Better parsing in perl 5

          sub foo {}
          &foo
          print("hello, world\n");

          # perl4 prints: hello, world
          # perl5 prints: syntax error

   * Parsing

     "if it looks like a function, it is a function" rule.

          print
            ($foo == 1) ? "is one\n" : "is zero\n";

          # perl4 prints: is zero
          # perl5 warns: "Useless use of a constant in void context" if using -w

   * Parsing

     String interpolation of the `$#array' construct differs when braces
     are to used around the name.

          @ = (1..3);
          print "${#a}";

          # perl4 prints: 2
          # perl5 fails with syntax error

          @ = (1..3);
          print "$#{a}";

          # perl4 prints: {a}
          # perl5 prints: 2

Numerical Traps
---------------

   Perl4-to-Perl5 traps having to do with numerical operators, operands,
or output from same.

   * Numerical

     Formatted output and significant digits

          print 7.373504 - 0, "\n";
          printf "%20.18f\n", 7.373504 - 0;

          # Perl4 prints:
          7.375039999999996141
          7.37503999999999614

          # Perl5 prints:
          7.373504
          7.37503999999999614

   * Numerical

     This specific item has been deleted.  It demonstrated how the
     auto-increment operator would not catch when a number went over the
     signed int limit.  Fixed in version 5.003_04.  But always be wary
     when using large integers.  If in doubt:

          use Math::BigInt;

   * Numerical

     Assignment of return values from numeric equality tests does not work
     in perl5 when the test evaluates to false (0).  Logical tests now
     return an null, instead of 0

          $p = ($test == 1);
          print $p,"\n";

          # perl4 prints: 0
          # perl5 prints:

     Also see `"General Regular Expression Traps using s' in this node for
     another example of this new feature...

   * Bitwise string ops

     When bitwise operators which can operate upon either numbers or
     strings (`& | ^ ~') are given only strings as arguments, perl4 would
     treat the operands as bitstrings so long as the program contained a
     call to the vec() function. perl5 treats the string operands as
     bitstrings.  (See `Bitwise String Operators', *Note Perlop: perlop,
     for more details.)

          $fred = "10";
          $barney = "12";
          $betty = $fred & $barney;
          print "$betty\n";
          # Uncomment the next line to change perl4's behavior
          # ($dummy) = vec("dummy", 0, 0);

          # Perl4 prints:
          8

          # Perl5 prints:
          10

          # If vec() is used anywhere in the program, both print:
          10

General data type traps
-----------------------

   Perl4-to-Perl5 traps involving most data-types, and their usage within
certain expressions and/or context.

   * (Arrays)

     Negative array subscripts now count from the end of the array.

          @a = (1, 2, 3, 4, 5);
          print "The third element of the array is $a[3] also expressed as $a[-2] \n";

          # perl4 prints: The third element of the array is 4 also expressed as
          # perl5 prints: The third element of the array is 4 also expressed as 4

   * (Arrays)

     Setting `$#array' lower now discards array elements, and makes them
     impossible to recover.

          @a = (a,b,c,d,e);
          print "Before: ",join('',@a);
          $#a =1;
          print ", After: ",join('',@a);
          $#a =3;
          print ", Recovered: ",join('',@a),"\n";

          # perl4 prints: Before: abcde, After: ab, Recovered: abcd
          # perl5 prints: Before: abcde, After: ab, Recovered: ab

   * (Hashes)

     Hashes get defined before use

          local($s,@a,%h);
          die "scalar \$s defined" if defined($s);
          die "array \@a defined" if defined(@a);
          die "hash \%h defined" if defined(%h);

          # perl4 prints:
          # perl5 dies: hash %h defined

     Perl will now generate a warning when it sees defined(@a) and
     defined(%h).

   * (Globs)

     glob assignment from variable to variable will fail if the assigned
     variable is localized subsequent to the assignment

          @a = ("This is Perl 4");
          *b = *a;
          local(@a);
          print @b,"\n";

          # perl4 prints: This is Perl 4
          # perl5 prints:

   * (Globs)

     Assigning undef to a glob has no effect in Perl 5.   In Perl 4 it
     undefines the associated scalar (but may have other side effects
     including SEGVs).

   * (Scalar String)

     Changes in unary negation (of strings) This change effects both the
     return value and what it does to auto(magic)increment.

          $x = "aaa";
          print ++$x," : ";
          print -$x," : ";
          print ++$x,"\n";

          # perl4 prints: aab : -0 : 1
          # perl5 prints: aab : -aab : aac

   * (Constants)

     perl 4 lets you modify constants:

          $foo = "x";
          &mod($foo);
          for ($x = 0; $x < 3; $x++) {
              &mod("a");
          }
          sub mod {
              print "before: $_[0]";
              $_[0] = "m";
              print "  after: $_[0]\n";
          }

          # perl4:
          # before: x  after: m
          # before: a  after: m
          # before: m  after: m
          # before: m  after: m

          # Perl5:
          # before: x  after: m
          # Modification of a read-only value attempted at foo.pl line 12.
          # before: a

   * (Scalars)

     The behavior is slightly different for:

          print "$x", defined $x

          # perl 4: 1
          # perl 5: <no output, $x is not called into existence>

   * (Variable Suicide)

     Variable suicide behavior is more consistent under Perl 5.  Perl5
     exhibits the same behavior for hashes and scalars, that perl4
     exhibits for only scalars.

          $aGlobal{ "aKey" } = "global value";
          print "MAIN:", $aGlobal{"aKey"}, "\n";
          $GlobalLevel = 0;
          &test( *aGlobal );

          sub test {
              local( *theArgument ) = @_;
              local( %aNewLocal ); # perl 4 != 5.001l,m
              $aNewLocal{"aKey"} = "this should never appear";
              print "SUB: ", $theArgument{"aKey"}, "\n";
              $aNewLocal{"aKey"} = "level $GlobalLevel";   # what should print
              $GlobalLevel++;
              if( $GlobalLevel<4 ) {
                  &test( *aNewLocal );
              }
          }

          # Perl4:
          # MAIN:global value
          # SUB: global value
          # SUB: level 0
          # SUB: level 1
          # SUB: level 2

          # Perl5:
          # MAIN:global value
          # SUB: global value
          # SUB: this should never appear
          # SUB: this should never appear
          # SUB: this should never appear

Context Traps - scalar, list contexts
-------------------------------------

   * (list context)

     The elements of argument lists for formats are now evaluated in list
     context.  This means you can interpolate list values now.

          @fmt = ("foo","bar","baz");
          format STDOUT=
          @<<<<< @||||| @>>>>>
          @fmt;
          .
          write;

          # perl4 errors:  Please use commas to separate fields in file
          # perl5 prints: foo     bar      baz

   * (scalar context)

     The `caller()' function now returns a false value in a scalar context
     if there is no caller.  This lets library files determine if they're
     being required.

          caller() ? (print "You rang?\n") : (print "Got a 0\n");

          # perl4 errors: There is no caller
          # perl5 prints: Got a 0

   * (scalar context)

     The comma operator in a scalar context is now guaranteed to give a
     scalar context to its arguments.

          @y= ('a','b','c');
          $x = (1, 2, @y);
          print "x = $x\n";

          # Perl4 prints:  x = c   # Thinks list context interpolates list
          # Perl5 prints:  x = 3   # Knows scalar uses length of list

   * (list, builtin)

     `sprintf()' funkiness (array argument converted to scalar array count)
     This test could be added to t/op/sprintf.t

          @z = ('%s%s', 'foo', 'bar');
          $x = sprintf(@z);
          if ($x eq 'foobar') {print "ok 2\n";} else {print "not ok 2 '$x'\n";}

          # perl4 prints: ok 2
          # perl5 prints: not ok 2

     printf() works fine, though:

          printf STDOUT (@z);
          print "\n";

          # perl4 prints: foobar
          # perl5 prints: foobar

     Probably a bug.

Precedence Traps
----------------

   Perl4-to-Perl5 traps involving precedence order.

   Perl 4 has almost the same precedence rules as Perl 5 for the operators
that they both have.  Perl 4 however, seems to have had some
inconsistencies that made the behavior differ from what was documented.

   * Precedence

     LHS vs. RHS of any assignment operator.  LHS is evaluated first in
     perl4, second in perl5; this can affect the relationship between
     side-effects in sub-expressions.

          @arr = ( 'left', 'right' );
          $a{shift @arr} = shift @arr;
          print join( ' ', keys %a );

          # perl4 prints: left
          # perl5 prints: right

   * Precedence

     These are now semantic errors because of precedence:

          @list = (1,2,3,4,5);
          %map = ("a",1,"b",2,"c",3,"d",4);
          $n = shift @list + 2;   # first item in list plus 2
          print "n is $n, ";
          $m = keys %map + 2;     # number of items in hash plus 2
          print "m is $m\n";

          # perl4 prints: n is 3, m is 6
          # perl5 errors and fails to compile

   * Precedence

     The precedence of assignment operators is now the same as the
     precedence of assignment.  Perl 4 mistakenly gave them the precedence
     of the associated operator.  So you now must parenthesize them in
     expressions like

          /foo/ ? ($a += 2) : ($a -= 2);

     Otherwise

          /foo/ ? $a += 2 : $a -= 2

     would be erroneously parsed as

          (/foo/ ? $a += 2 : $a) -= 2;

     On the other hand,

          $a += /foo/ ? 1 : 2;

     now works as a C programmer would expect.

   * Precedence
          open FOO || die;

     is now incorrect.  You need parentheses around the filehandle.
     Otherwise, perl5 leaves the statement as its default precedence:

          open(FOO || die);

          # perl4 opens or dies
          # perl5 errors: Precedence problem: open FOO should be open(FOO)

   * Precedence

     perl4 gives the special variable, $: precedence, where perl5 treats
     `$::' as main package

          $a = "x"; print "$::a";

          # perl 4 prints: -:a
          # perl 5 prints: x

   * Precedence

     perl4 had buggy precedence for the file test operators vis-a-vis the
     assignment operators.  Thus, although the precedence table for perl4
     leads one to believe `-e $foo .= "q"' should parse as `((-e $foo) .=
     "q")', it actually parses as `(-e ($foo .= "q"))'.  In perl5, the
     precedence is as documented.

          -e $foo .= "q"

          # perl4 prints: no output
          # perl5 prints: Can't modify -e in concatenation

   * Precedence

     In perl4, keys(), each() and values() were special high-precedence
     operators that operated on a single hash, but in perl5, they are
     regular named unary operators.  As documented, named unary operators
     have lower precedence than the arithmetic and concatenation operators
     `+ - .', but the perl4 variants of these operators actually bind
     tighter than `+ - .'.  Thus, for:

          %foo = 1..10;
          print keys %foo - 1

          # perl4 prints: 4
          # perl5 prints: Type of arg 1 to keys must be hash (not subtraction)

     The perl4 behavior was probably more useful, if less consistent.

General Regular Expression Traps using s///, etc.
-------------------------------------------------

   All types of RE traps.

   * Regular Expression

     `s'$lhs'$rhs'' now does no interpolation on either side.  It used to
     interpolate $lhs but not $rhs.  (And still does not match a literal
     '$' in string)

          $a=1;$b=2;
          $string = '1 2 $a $b';
          $string =~ s'$a'$b';
          print $string,"\n";

          # perl4 prints: $b 2 $a $b
          # perl5 prints: 1 2 $a $b

   * Regular Expression

     `m//g' now attaches its state to the searched string rather than the
     regular expression.  (Once the scope of a block is left for the sub,
     the state of the searched string is lost)

          $_ = "ababab";
          while(m/ab/g){
              &doit("blah");
          }
          sub doit{local($_) = shift; print "Got $_ "}

          # perl4 prints: blah blah blah
          # perl5 prints: infinite loop blah...

   * Regular Expression

     Currently, if you use the `m//o' qualifier on a regular expression
     within an anonymous sub, all closures generated from that anonymous
     sub will use the regular expression as it was compiled when it was
     used the very first time in any such closure.  For instance, if you
     say

          sub build_match {
              my($left,$right) = @_;
              return sub { $_[0] =~ /$left stuff $right/o; };
          }

     build_match() will always return a sub which matches the contents of
     $left and $right as they were the first time that build_match() was
     called, not as they are in the current call.

     This is probably a bug, and may change in future versions of Perl.

   * Regular Expression

     If no parentheses are used in a match, Perl4 sets $+ to the whole
     match, just like $&. Perl5 does not.

          "abcdef" =~ /b.*e/;
          print "\$+ = $+\n";

          # perl4 prints: bcde
          # perl5 prints:

   * Regular Expression

     substitution now returns the null string if it fails

          $string = "test";
          $value = ($string =~ s/foo//);
          print $value, "\n";

          # perl4 prints: 0
          # perl5 prints:

     Also see `Numerical Traps' in this node for another example of this
     new feature.

   * Regular Expression

     `s`lhs`rhs`' (using backticks) is now a normal substitution, with no
     backtick expansion

          $string = "";
          $string =~ s`^`hostname`;
          print $string, "\n";

          # perl4 prints: <the local hostname>
          # perl5 prints: hostname

   * Regular Expression

     Stricter parsing of variables used in regular expressions

          s/^([^$grpc]*$grpc[$opt$plus$rep]?)//o;

          # perl4: compiles w/o error
          # perl5: with Scalar found where operator expected ..., near "$opt$plus"

     an added component of this example, apparently from the same script,
     is the actual value of the s'd string after the substitution.
     `[$opt]' is a character class in perl4 and an array subscript in perl5

          $grpc = 'a';
          $opt  = 'r';
          $_ = 'bar';
          s/^([^$grpc]*$grpc[$opt]?)/foo/;
          print ;

          # perl4 prints: foo
          # perl5 prints: foobar

   * Regular Expression

     Under perl5, `m?x?' matches only once, like `?x?'. Under perl4, it
     matched repeatedly, like `/x/' or `m!x!'.

          $test = "once";
          sub match { $test =~ m?once?; }
          &match();
          if( &match() ) {
              # m?x? matches more then once
              print "perl4\n";
          } else {
              # m?x? matches only once
              print "perl5\n";
          }

          # perl4 prints: perl4
          # perl5 prints: perl5

Subroutine, Signal, Sorting Traps
---------------------------------

   The general group of Perl4-to-Perl5 traps having to do with Signals,
Sorting, and their related subroutines, as well as general subroutine
traps.  Includes some OS-Specific traps.

   * (Signals)

     Barewords that used to look like strings to Perl will now look like
     subroutine calls if a subroutine by that name is defined before the
     compiler sees them.

          sub SeeYa { warn"Hasta la vista, baby!" }
          $SIG{'TERM'} = SeeYa;
          print "SIGTERM is now $SIG{'TERM'}\n";

          # perl4 prints: SIGTERM is main'SeeYa
          # perl5 prints: SIGTERM is now main::1

     Use -w to catch this one

   * (Sort Subroutine)

     reverse is no longer allowed as the name of a sort subroutine.

          sub reverse{ print "yup "; $a <=> $b }
          print sort reverse a,b,c;

          # perl4 prints: yup yup yup yup abc
          # perl5 prints: abc

   * warn() won't let you specify a filehandle.

     Although it _always_ printed to STDERR, warn() would let you specify a
     filehandle in perl4.  With perl5 it does not.

          warn STDERR "Foo!";

          # perl4 prints: Foo!
          # perl5 prints: String found where operator expected

OS Traps
--------

   * (SysV)

     Under HPUX, and some other SysV OSes, one had to reset any signal
     handler, within  the signal handler function, each time a signal was
     handled with perl4.  With perl5, the reset is now done correctly.
     Any code relying on the handler _not_ being reset will have to be
     reworked.

     Since version 5.002, Perl uses sigaction() under SysV.

          sub gotit {
              print "Got @_... ";
          }
          $SIG{'INT'} = 'gotit';

          $| = 1;
          $pid = fork;
          if ($pid) {
              kill('INT', $pid);
              sleep(1);
              kill('INT', $pid);
          } else {
              while (1) {sleep(10);}
          }

          # perl4 (HPUX) prints: Got INT...
          # perl5 (HPUX) prints: Got INT... Got INT...

   * (SysV)

     Under SysV OSes, `seek()' on a file opened to append `<< '> >>> now
     does the right thing w.r.t. the fopen() manpage. e.g., - When a file
     is opened for append,  it  is  impossible to overwrite information
     already in the file.

          open(TEST,">>seek.test");
          $start = tell TEST ;
          foreach(1 .. 9){
              print TEST "$_ ";
          }
          $end = tell TEST ;
          seek(TEST,$start,0);
          print TEST "18 characters here";

          # perl4 (solaris) seek.test has: 18 characters here
          # perl5 (solaris) seek.test has: 1 2 3 4 5 6 7 8 9 18 characters here

Interpolation Traps
-------------------

   Perl4-to-Perl5 traps having to do with how things get interpolated
within certain expressions, statements, contexts, or whatever.

   * Interpolation

     @ now always interpolates an array in double-quotish strings.

          print "To: someone@somewhere.com\n";

          # perl4 prints: To:someone@somewhere.com
          # perl5 errors : In string, @somewhere now must be written as \@somewhere

   * Interpolation

     Double-quoted strings may no longer end with an unescaped $ or @.

          $foo = "foo$";
          $bar = "bar@";
          print "foo is $foo, bar is $bar\n";

          # perl4 prints: foo is foo$, bar is bar@
          # perl5 errors: Final $ should be \$ or $name

     Note: perl5 DOES NOT error on the terminating @ in $bar

   * Interpolation

     Perl now sometimes evaluates arbitrary expressions inside braces that
     occur within double quotes (usually when the opening brace is
     preceded by `$' or `@').

          @www = "buz";
          $foo = "foo";
          $bar = "bar";
          sub foo { return "bar" };
          print "|@{w.w.w}|${main'foo}|";

          # perl4 prints: |@{w.w.w}|foo|
          # perl5 prints: |buz|bar|

     Note that you can `use strict;' to ward off such trappiness under
     perl5.

   * Interpolation

     The construct "this is $$x" used to interpolate the pid at that
     point, but now apparently tries to dereference $x.  $$ by itself still
     works fine, however.

          print "this is $$x\n";

          # perl4 prints: this is XXXx   (XXX is the current pid)
          # perl5 prints: this is

   * Interpolation

     Creation of hashes on the fly with `eval "EXPR"' now requires either
     both `$''s to be protected in the specification of the hash name, or
     both curlies to be protected.  If both curlies are protected, the
     result will be compatible with perl4 and perl5.  This is a very
     common practice, and should be changed to use the block form of
     `eval{}'  if possible.

          $hashname = "foobar";
          $key = "baz";
          $value = 1234;
          eval "\$$hashname{'$key'} = q|$value|";
          (defined($foobar{'baz'})) ?  (print "Yup") : (print "Nope");

          # perl4 prints: Yup
          # perl5 prints: Nope

     Changing

          eval "\$$hashname{'$key'} = q|$value|";

     to

          eval "\$\$hashname{'$key'} = q|$value|";

     causes the following result:

          # perl4 prints: Nope
          # perl5 prints: Yup

     or, changing to

          eval "\$$hashname\{'$key'\} = q|$value|";

     causes the following result:

          # perl4 prints: Yup
          # perl5 prints: Yup
          # and is compatible for both versions

   * Interpolation

     perl4 programs which unconsciously rely on the bugs in earlier perl
     versions.

          perl -e '$bar=q/not/; print "This is $foo{$bar} perl5"'

          # perl4 prints: This is not perl5
          # perl5 prints: This is perl5

   * Interpolation

     You also have to be careful about array references.

          print "$foo{"

          perl 4 prints: {
          perl 5 prints: syntax error

   * Interpolation

     Similarly, watch out for:

          $foo = "array";
          print "\$$foo{bar}\n";

          # perl4 prints: $array{bar}
          # perl5 prints: $

     Perl 5 is looking for `$array{bar}' which doesn't exist, but perl 4 is
     happy just to expand $foo to "array" by itself.  Watch out for this
     especially in eval's.

   * Interpolation

     `qq()' string passed to eval

          eval qq(
              foreach \$y (keys %\$x\) {
                  \$count++;
              }
          );

          # perl4 runs this ok
          # perl5 prints: Can't find string terminator ")"

DBM Traps
---------

   General DBM traps.

   * DBM

     Existing dbm databases created under perl4 (or any other dbm/ndbm
     tool) may cause the same script, run under perl5, to fail.  The build
     of perl5 must have been linked with the same dbm/ndbm as the default
     for `dbmopen()' to function properly without tie'ing to an extension
     dbm implementation.

          dbmopen (%dbm, "file", undef);
          print "ok\n";

          # perl4 prints: ok
          # perl5 prints: ok (IFF linked with -ldbm or -lndbm)

   * DBM

     Existing dbm databases created under perl4 (or any other dbm/ndbm
     tool) may cause the same script, run under perl5, to fail.  The error
     generated when exceeding the limit on the key/value size will cause
     perl5 to exit immediately.

          dbmopen(DB, "testdb",0600) || die "couldn't open db! $!";
          $DB{'trap'} = "x" x 1024;  # value too large for most dbm/ndbm
          print "YUP\n";

          # perl4 prints:
          dbm store returned -1, errno 28, key "trap" at - line 3.
          YUP

          # perl5 prints:
          dbm store returned -1, errno 28, key "trap" at - line 3.

Unclassified Traps
------------------

   Everything else.

   * require/do trap using returned value

     If the file doit.pl has:

          sub foo {
              $rc = do "./do.pl";
              return 8;
          }
          print &foo, "\n";

     And the do.pl file has the following single line:

          return 3;

     Running doit.pl gives the following:

          # perl 4 prints: 3 (aborts the subroutine early)
          # perl 5 prints: 8

     Same behavior if you replace do with require.

   * split on empty string with LIMIT specified
          $string = '';
              @list = split(/foo/, $string, 2)

     Perl4 returns a one element list containing the empty string but Perl5
     returns an empty list.

   As always, if any of these are ever officially declared as bugs,
they'll be fixed and removed.


File: perl.info,  Node: perlunicode,  Next: perllocale,  Prev: perlform,  Up: Top

Unicode support in Perl
***********************

NAME
====

   perlunicode - Unicode support in Perl

DESCRIPTION
===========

Important Caveat
----------------

   WARNING: The implementation of Unicode support in Perl is incomplete.

   The following areas need further work.

Input and Output Disciplines
     There is currently no easy way to mark data read from a file or other
     external source as being utf8.  This will be one of the major areas of
     focus in the near future.

Regular Expressions
     The existing regular expression compiler does not produce polymorphic
     opcodes.  This means that the determination on whether to match
     Unicode characters is made when the pattern is compiled, based on
     whether the pattern contains Unicode characters, and not when the
     matching happens at run time.  This needs to be changed to adaptively
     match Unicode if the string to be matched is Unicode.

`use utf8' still needed to enable a few features
     The utf8 pragma implements the tables used for Unicode support.  These
     tables are automatically loaded on demand, so the utf8 pragma need not
     normally be used.

     However, as a compatibility measure, this pragma must be explicitly
     used to enable recognition of UTF-8 encoded literals and identifiers
     in the source text.

Byte and Character semantics
----------------------------

   Beginning with version 5.6, Perl uses logically wide characters to
represent strings internally.  This internal representation of strings
uses the UTF-8 encoding.

   In future, Perl-level operations can be expected to work with characters
rather than bytes, in general.

   However, as strictly an interim compatibility measure, Perl v5.6 aims to
provide a safe migration path from byte semantics to character semantics
for programs.  For operations where Perl can unambiguously decide that the
input data is characters, Perl now switches to character semantics.  For
operations where this determination cannot be made without additional
information from the user, Perl decides in favor of compatibility, and
chooses to use byte semantics.

   This behavior preserves compatibility with earlier versions of Perl,
which allowed byte semantics in Perl operations, but only as long as none
of the program's inputs are marked as being as source of Unicode character
data.  Such data may come from filehandles, from calls to external
programs, from information provided by the system (such as %ENV), or from
literals and constants in the source text.

   If the -C command line switch is used, (or the ${^WIDE_SYSTEM_CALLS}
global flag is set to 1), all system calls will use the corresponding wide
character APIs.  This is currently only implemented on Windows.

   Regardless of the above, the bytes pragma can always be used to force
byte semantics in a particular lexical scope.  See *Note Bytes:
(pm.info)bytes,.

   The utf8 pragma is primarily a compatibility device that enables
recognition of UTF-8 in literals encountered by the parser.  It may also
be used for enabling some of the more experimental Unicode support
features.  Note that this pragma is only required until a future version
of Perl in which character semantics will become the default.  This pragma
may then become a no-op.  See *Note Utf8: (pm.info)utf8,.

   Unless mentioned otherwise, Perl operators will use character semantics
when they are dealing with Unicode data, and byte semantics otherwise.
Thus, character semantics for these operations apply transparently; if the
input data came from a Unicode source (for example, by adding a character
encoding discipline to the filehandle whence it came, or a literal UTF-8
string constant in the program), character semantics apply; otherwise,
byte semantics are in effect.  To force byte semantics on Unicode data,
the bytes pragma should be used.

   Under character semantics, many operations that formerly operated on
bytes change to operating on characters.  For ASCII data this makes no
difference, because UTF-8 stores ASCII in single bytes, but for any
character greater than `chr(127)', the character may be stored in a
sequence of two or more bytes, all of which have the high bit set.  But by
and large, the user need not worry about this, because Perl hides it from
the user.  A character in Perl is logically just a number ranging from 0
to 2**32 or so.  Larger characters encode to longer sequences of bytes
internally, but again, this is just an internal detail which is hidden at
the Perl level.

Effects of character semantics
------------------------------

   Character semantics have the following effects:

   * Strings and patterns may contain characters that have an ordinal value
     larger than 255.

     Presuming you use a Unicode editor to edit your program, such
     characters will typically occur directly within the literal strings
     as UTF-8 characters, but you can also specify a particular character
     with an extension of the `\x' notation.  UTF-8 characters are
     specified by putting the hexadecimal code within curlies after the
     `\x'.  For instance, a Unicode smiley face is `\x{263A}'.  A
     character in the Latin-1 range (128..255) should be written `\x{ab}'
     rather than `\xab', since the former will turn into a two-byte UTF-8
     code, while the latter will continue to be interpreted as generating
     a 8-bit byte rather than a character.  In fact, if the `use warnings'
     pragma of the -w switch is turned on, it will produce a warning that
     you might be generating invalid UTF-8.

   * Identifiers within the Perl script may contain Unicode alphanumeric
     characters, including ideographs.  (You are currently on your own when
     it comes to using the canonical forms of characters-Perl doesn't (yet)
     attempt to canonicalize variable names for you.)

   * Regular expressions match characters instead of bytes.  For instance,
     "." matches a character instead of a byte.  (However, the `\C' pattern
     is provided to force a match a single byte ("`char'" in C, hence
     `\C').)

   * Character classes in regular expressions match characters instead of
     bytes, and match against the character properties specified in the
     Unicode properties database.  So `\w' can be used to match an
     ideograph, for instance.

   * Named Unicode properties and block ranges make be used as character
     classes via the new `\p{}' (matches property) and `\P{}' (doesn't
     match property) constructs.  For instance, `\p{Lu}' matches any
     character with the Unicode uppercase property, while `\p{M}' matches
     any mark character.  Single letter properties may omit the brackets,
     so that can be written `\pM' also.  Many predefined character classes
     are available, such as `\p{IsMirrored}' and  `\p{InTibetan}'.

   * The special pattern `\X' match matches any extended Unicode sequence
     (a "combining character sequence" in Standardese), where the first
     character is a base character and subsequent characters are mark
     characters that apply to the base character.  It is equivalent to
     `(?:\PM\pM*)'.

   * The tr/// operator translates characters instead of bytes.  It can
     also be forced to translate between 8-bit codes and UTF-8.  For
     instance, if you know your input in Latin-1, you can say:

          while (<>) {
          	tr/\0-\xff//CU;		# latin1 char to utf8
          	...
          }

     Similarly you could translate your output with

          tr/\0-\x{ff}//UC;		# utf8 to latin1 char

     No, s/// doesn't take /U or /C (yet?).

   * Case translation operators use the Unicode case translation tables
     when provided character input.  Note that `uc()' translates to
     uppercase, while ucfirst translates to titlecase (for languages that
     make the distinction).  Naturally the corresponding backslash
     sequences have the same semantics.

   * Most operators that deal with positions or lengths in the string will
     automatically switch to using character positions, including `chop()',
     `substr()', `pos()', `index()', `rindex()', `sprintf()', write(), and
     length().  Operators that specifically don't switch include vec(),
     pack(), and `unpack()'.  Operators that really don't care include
     `chomp()', as well as any other operator that treats a string as a
     bucket of bits, such as `sort()', and the operators dealing with
     filenames.

   * The pack()/`unpack()' letters "c" and "C" do not change, since
     they're often used for byte-oriented formats.  (Again, think "`char'"
     in the C language.)  However, there is a new "U" specifier that will
     convert between UTF-8 characters and integers.  (It works outside of
     the utf8 pragma too.)

   * The `chr()' and `ord()' functions work on characters.  This is like
     `pack("U")' and `unpack("U")', not like `pack("C")' and
     `unpack("C")'.  In fact, the latter are how you now emulate
     byte-oriented `chr()' and `ord()' under utf8.

   * And finally, `scalar reverse()' reverses by character rather than by
     byte.

Character encodings for input and output
----------------------------------------

   [XXX: This feature is not yet implemented.]

CAVEATS
=======

   As of yet, there is no method for automatically coercing input and
output to some encoding other than UTF-8.  This is planned in the near
future, however.

   Whether an arbitrary piece of data will be treated as "characters" or
"bytes" by internal operations cannot be divined at the current time.

   Use of locales with utf8 may lead to odd results.  Currently there is
some attempt to apply 8-bit locale info to characters in the range 0..255,
but this is demonstrably incorrect for locales that use characters above
that range (when mapped into Unicode).  It will also tend to run slower.
Avoidance of locales is strongly encouraged.

SEE ALSO
========

   *Note Bytes: (pm.info)bytes,, *Note Utf8: (pm.info)utf8,,
`"${^WIDE_SYSTEM_CALLS}"', *Note Perlvar: perlvar,


File: perl.info,  Node: perlvar,  Next: perlsub,  Prev: perlopentut,  Up: Top

Perl predefined variables
*************************

NAME
====

   perlvar - Perl predefined variables

DESCRIPTION
===========

Predefined Names
----------------

   The following names have special meaning to Perl.  Most punctuation
names have reasonable mnemonics, or analogs in the shells.  Nevertheless,
if you wish to use long variable names, you need only say

     use English;

   at the top of your program.  This will alias all the short names to the
long names in the current package.  Some even have medium names, generally
borrowed from *awk*.

   If you don't mind the performance hit, variables that depend on the
currently selected filehandle may instead be set by calling an appropriate
object method on the IO::Handle object.  (Summary lines below for this
contain the word HANDLE.)  First you must say

     use IO::Handle;

   after which you may use either

     method HANDLE EXPR

   or more safely,

     HANDLE->method(EXPR)

   Each method returns the old value of the IO::Handle attribute.  The
methods each take an optional EXPR, which if supplied specifies the new
value for the IO::Handle attribute in question.  If not supplied, most
methods do nothing to the current value-except for autoflush(), which will
assume a 1 for you, just to be different.  Because loading in the
IO::Handle class is an expensive operation, you should learn how to use
the regular built-in variables.

   A few of these variables are considered "read-only".  This means that if
you try to assign to this variable, either directly or indirectly through
a reference, you'll raise a run-time exception.

   The following list is ordered by scalar variables first, then the
arrays, then the hashes.

$ARG
$_
     The default input and pattern-searching space.  The following pairs
     are equivalent:

          while (<>) {...}	# equivalent only in while!
          while (defined($_ = <>)) {...}

          /^Subject:/
          $_ =~ /^Subject:/

          tr/a-z/A-Z/
          $_ =~ tr/a-z/A-Z/

          chomp
          chomp($_)

     Here are the places where Perl will assume $_ even if you don't use
     it:

        * Various unary functions, including functions like ord() and
          int(), as well as the all file tests (-f, -d) except for -t,
          which defaults to STDIN.

        * Various list functions like print() and unlink().

        * The pattern matching operations m//, s///, and tr/// when used
          without an `=~' operator.

        * The default iterator variable in a foreach loop if no other
          variable is supplied.

        * The implicit iterator variable in the grep() and map() functions.

        * The default place to put an input record when a `< <FH' >>
          operation's result is tested by itself as the sole criterion of
          a while test.  Outside a while test, this will not happen.

     (Mnemonic: underline is understood in certain operations.)

$<digits>
     Contains the subpattern from the corresponding set of capturing
     parentheses from the last pattern match, not counting patterns
     matched in nested blocks that have been exited already.  (Mnemonic:
     like \digits.)  These variables are all read-only and dynamically
     scoped to the current BLOCK.

$MATCH
$&
     The string matched by the last successful pattern match (not counting
     any matches hidden within a BLOCK or eval() enclosed by the current
     BLOCK).  (Mnemonic: like & in some editors.)  This variable is
     read-only and dynamically scoped to the current BLOCK.

     The use of this variable anywhere in a program imposes a considerable
     performance penalty on all regular expression matches.  See `BUGS' in
     this node.

$PREMATCH
$`
     The string preceding whatever was matched by the last successful
     pattern match (not counting any matches hidden within a BLOCK or eval
     enclosed by the current BLOCK).  (Mnemonic: ``' often precedes a
     quoted string.)  This variable is read-only.

     The use of this variable anywhere in a program imposes a considerable
     performance penalty on all regular expression matches.  See `BUGS' in
     this node.

$POSTMATCH
$'
     The string following whatever was matched by the last successful
     pattern match (not counting any matches hidden within a BLOCK or
     eval() enclosed by the current BLOCK).  (Mnemonic: `'' often follows
     a quoted string.)  Example:

          $_ = 'abcdefghi';
          /def/;
          print "$`:$&:$'\n";  	# prints abc:def:ghi

     This variable is read-only and dynamically scoped to the current
     BLOCK.

     The use of this variable anywhere in a program imposes a considerable
     performance penalty on all regular expression matches.  See `BUGS' in
     this node.

$LAST_PAREN_MATCH
$+
     The last bracket matched by the last search pattern.  This is useful
     if you don't know which one of a set of alternative patterns matched.
     For example:

          /Version: (.*)|Revision: (.*)/ && ($rev = $+);

     (Mnemonic: be positive and forward looking.)  This variable is
     read-only and dynamically scoped to the current BLOCK.

@+
     This array holds the offsets of the ends of the last successful
     submatches in the currently active dynamic scope.  `$+[0]' is the
     offset into the string of the end of the entire match.  This is the
     same value as what the pos function returns when called on the
     variable that was matched against.  The nth element of this array
     holds the offset of the nth submatch, so `$+[1]' is the offset past
     where $1 ends, `$+[2]' the offset past where $2 ends, and so on.  You
     can use `$#+' to determine how many subgroups were in the last
     successful match.  See the examples given for the `@-' variable.

$MULTILINE_MATCHING

     Set to 1 to do multi-line matching within a string, 0 to tell Perl
     that it can assume that strings contain a single line, for the purpose
     of optimizing pattern matches.  Pattern matches on strings containing
     multiple newlines can produce confusing results when $* is 0.  Default
     is 0.  (Mnemonic: * matches multiple things.)  This variable
     influences the interpretation of only ^ and `$'.  A literal newline
     can be searched for even when `$* == 0'.

     Use of $* is deprecated in modern Perl, supplanted by the `/s' and
     `/m' modifiers on pattern matching.

input_line_number HANDLE EXPR
$INPUT_LINE_NUMBER
$NR
$.
     The current input record number for the last file handle from which
     you just read() (or called a seek or tell on).  The value may be
     different from the actual physical line number in the file, depending
     on what notion of "line" is in effect-see $/ on how to change that.
     An explicit close on a filehandle resets the line number.  Because `<
     <' >> never does an explicit close, line numbers increase across ARGV
     files (but see examples in `eof', *Note Perlfunc: perlfunc,).
     Consider this variable read-only: setting it does not reposition the
     seek pointer; you'll have to do that on your own.  Localizing $.  has
     the effect of also localizing Perl's notion of "the last read
     filehandle".  (Mnemonic: many programs use "." to mean the current
     line number.)

input_record_separator HANDLE EXPR
$INPUT_RECORD_SEPARATOR
$RS
$/
     The input record separator, newline by default.  This influences
     Perl's idea of what a "line" is.  Works like *awk*'s RS variable,
     including treating empty lines as a terminator if set to the null
     string.  (An empty line cannot contain any spaces or tabs.)  You may
     set it to a multi-character string to match a multi-character
     terminator, or to undef to read through the end of file.  Setting it
     to `"\n\n"' means something slightly different than setting to "", if
     the file contains consecutive empty lines.  Setting to "" will treat
     two or more consecutive empty lines as a single empty line.  Setting
     to `"\n\n"' will blindly assume that the next input character belongs
     to the next paragraph, even if it's a newline.  (Mnemonic: / delimits
     line boundaries when quoting poetry.)

          undef $/;		# enable "slurp" mode
          $_ = <FH>;		# whole file now here
          s/\n[ \t]+/ /g;

     Remember: the value of $/ is a string, not a regex.  *awk* has to be
     better for something. :-)

     Setting $/ to a reference to an integer, scalar containing an
     integer, or scalar that's convertible to an integer will attempt to
     read records instead of lines, with the maximum record size being the
     referenced integer.  So this:

          $/ = \32768; # or \"32768", or \$var_containing_32768
          open(FILE, $myfile);
          $_ = <FILE>;

     will read a record of no more than 32768 bytes from FILE.  If you're
     not reading from a record-oriented file (or your OS doesn't have
     record-oriented files), then you'll likely get a full chunk of data
     with every read.  If a record is larger than the record size you've
     set, you'll get the record back in pieces.

     On VMS, record reads are done with the equivalent of sysread, so it's
     best not to mix record and non-record reads on the same file.  (This
     is unlikely to be a problem, because any file you'd want to read in
     record mode is probably unusable in line mode.)  Non-VMS systems do
     normal I/O, so it's safe to mix record and non-record reads of a file.

     See also `"Newlines"', *Note Perlport: perlport,.  Also see $..

autoflush HANDLE EXPR
$OUTPUT_AUTOFLUSH
$|
     If set to nonzero, forces a flush right away and after every write or
     print on the currently selected output channel.  Default is 0
     (regardless of whether the channel is really buffered by the system
     or not; $| tells you only whether you've asked Perl explicitly to
     flush after each write).  STDOUT will typically be line buffered if
     output is to the terminal and block buffered otherwise.  Setting this
     variable is useful primarily when you are outputting to a pipe or
     socket, such as when you are running a Perl program under rsh and
     want to see the output as it's happening.  This has no effect on
     input buffering.  See `getc', *Note Perlfunc: perlfunc, for that.
     (Mnemonic: when you want your pipes to be piping hot.)

output_field_separator HANDLE EXPR
$OUTPUT_FIELD_SEPARATOR
$OFS
$,
     The output field separator for the print operator.  Ordinarily the
     print operator simply prints out its arguments without further
     adornment.  To get behavior more like *awk*, set this variable as you
     would set *awk*'s OFS variable to specify what is printed between
     fields.  (Mnemonic: what is printed when there is a "," in your print
     statement.)

output_record_separator HANDLE EXPR
$OUTPUT_RECORD_SEPARATOR
$ORS
$\
     The output record separator for the print operator.  Ordinarily the
     print operator simply prints out its arguments as is, with no
     trailing newline or other end-of-record string added.  To get
     behavior more like *awk*, set this variable as you would set *awk*'s
     ORS variable to specify what is printed at the end of the print.
     (Mnemonic: you set $\ instead of adding "\n" at the end of the print.
     Also, it's just like $/, but it's what you get "back" from Perl.)

$LIST_SEPARATOR
$"
     This is like $, except that it applies to array and slice values
     interpolated into a double-quoted string (or similar interpreted
     string).  Default is a space.  (Mnemonic: obvious, I think.)

$SUBSCRIPT_SEPARATOR
$SUBSEP
$;
     The subscript separator for multidimensional array emulation.  If you
     refer to a hash element as

          $foo{$a,$b,$c}

     it really means

          $foo{join($;, $a, $b, $c)}

     But don't put

          @foo{$a,$b,$c}	# a slice--note the @

     which means

          ($foo{$a},$foo{$b},$foo{$c})

     Default is "\034", the same as SUBSEP in *awk*.  If your keys contain
     binary data there might not be any safe value for $;.  (Mnemonic:
     comma (the syntactic subscript separator) is a semi-semicolon.  Yeah,
     I know, it's pretty lame, but $, is already taken for something more
     important.)

     Consider using "real" multidimensional arrays as described in *Note
     Perllol: perllol,.

$OFMT
$#
     The output format for printed numbers.  This variable is a
     half-hearted attempt to emulate *awk*'s OFMT variable.  There are
     times, however, when *awk* and Perl have differing notions of what
     counts as numeric.  The initial value is "%.ng", where n is the value
     of the macro DBL_DIG from your system's `float.h'.  This is different
     from *awk*'s default OFMT setting of "%.6g", so you need to set $#
     explicitly to get *awk*'s value.  (Mnemonic: # is the number sign.)

     Use of $# is deprecated.

format_page_number HANDLE EXPR
$FORMAT_PAGE_NUMBER
$%
     The current page number of the currently selected output channel.
     Used with formats.  (Mnemonic: % is page number in *nroff*.)

format_lines_per_page HANDLE EXPR
$FORMAT_LINES_PER_PAGE
$=
     The current page length (printable lines) of the currently selected
     output channel.  Default is 60.  Used with formats.  (Mnemonic: = has
     horizontal lines.)

format_lines_left HANDLE EXPR
$FORMAT_LINES_LEFT
$-
     The number of lines left on the page of the currently selected output
     channel.  Used with formats.  (Mnemonic: lines_on_page -
     lines_printed.)

@-
     $-[0] is the offset of the start of the last successful match.
     `$-['n] is the offset of the start of the substring matched by n-th
     subpattern, or undef if the subpattern did not match.

     Thus after a match against $_, $& coincides with `substr $_, $-[0],
     $+[0] - $-[0]'.  Similarly, `$'n coincides with `substr $_, $-['n`],
     $+['n`] - $-['n] if `$-['n] is defined, and $+ coincides with `substr
     $_, $-[$#-], $+[$#-]'.  One can use `$#-' to find the last matched
     subgroup in the last successful match.  Contrast with `$#+', the
     number of subgroups in the regular expression.  Compare with `@+'.

     This array holds the offsets of the beginnings of the last successful
     submatches in the currently active dynamic scope.  `$-[0]' is the
     offset into the string of the beginning of the entire match.  The nth
     element of this array holds the offset of the nth submatch, so
     `$+[1]' is the offset where $1 begins, `$+[2]' the offset where $2
     begins, and so on.  You can use `$#-' to determine how many subgroups
     were in the last successful match.  Compare with the `@+' variable.

     After a match against some variable $var:

    $` is the same as `substr($var, 0, $-[0]')
    $& is the same as `substr($var, $-[0], $+[0] - $-[0]')
    $' is the same as `substr($var, $+[0]')

    $1 is the same as `substr($var, $-[1], $+[1] - $-[1])'

    $2 is the same as `substr($var, $-[2], $+[2] - $-[2])'

    $3 is the same as `substr $var, $-[3], $+[3] - $-[3]')
format_name HANDLE EXPR
$FORMAT_NAME
$~
     The name of the current report format for the currently selected
     output channel.  Default is the name of the filehandle.  (Mnemonic:
     brother to $^.)

format_top_name HANDLE EXPR
$FORMAT_TOP_NAME
$^
     The name of the current top-of-page format for the currently selected
     output channel.  Default is the name of the filehandle with _TOP
     appended.  (Mnemonic: points to top of page.)

format_line_break_characters HANDLE EXPR
$FORMAT_LINE_BREAK_CHARACTERS
$:
     The current set of characters after which a string may be broken to
     fill continuation fields (starting with ^) in a format.  Default is
     " \n-", to break on whitespace or hyphens.  (Mnemonic: a "colon" in
     poetry is a part of a line.)

format_formfeed HANDLE EXPR
$FORMAT_FORMFEED
$^L
     What formats output as a form feed.  Default is \f.

$ACCUMULATOR
$^A
     The current value of the write() accumulator for format() lines.  A
     format contains formline() calls that put their result into $^A.
     After calling its format, write() prints out the contents of $^A and
     empties.  So you never really see the contents of $^A unless you call
     formline() yourself and then look at it.  See *Note Perlform:
     perlform, and `formline()', *Note Perlfunc: perlfunc,.

$CHILD_ERROR
$?
     The status returned by the last pipe close, backtick (```') command,
     successful call to wait() or waitpid(), or from the system()
     operator.  This is just the 16-bit status word returned by the wait()
     system call (or else is made up to look like it).  Thus, the exit
     value of the subprocess is really (`<< $? '> 8 >>>), and `$? & 127'
     gives which signal, if any, the process died from, and `$? & 128'
     reports whether there was a core dump.  (Mnemonic: similar to *sh*
     and *ksh*.)

     Additionally, if the `h_errno' variable is supported in C, its value
     is returned via $? if any `gethost*()' function fails.

     If you have installed a signal handler for `SIGCHLD', the value of $?
     will usually be wrong outside that handler.

     Inside an END subroutine $? contains the value that is going to be
     given to exit().  You can modify $? in an END subroutine to change
     the exit status of your program.  For example:

          END {
          	$? = 1 if $? == 255;  # die would make it 255
          }

     Under VMS, the pragma `use vmsish 'status'' makes $? reflect the
     actual VMS exit status, instead of the default emulation of POSIX
     status.

     Also see `Error Indicators' in this node.

$OS_ERROR
$ERRNO
$!
     If used numerically, yields the current value of the C errno
     variable, with all the usual caveats.  (This means that you shouldn't
     depend on the value of $! to be anything in particular unless you've
     gotten a specific error return indicating a system error.)  If used
     an a string, yields the corresponding system error string.  You can
     assign a number to $! to set errno if, for instance, you want `"$!"'
     to return the string for error n, or you want to set the exit value
     for the die() operator.  (Mnemonic: What just went bang?)

     Also see `Error Indicators' in this node.

$EXTENDED_OS_ERROR
$^E
     Error information specific to the current operating system.  At the
     moment, this differs from $! under only VMS, OS/2, and Win32 (and for
     MacPerl).  On all other platforms, $^E is always just the same as $!.

     Under VMS, $^E provides the VMS status value from the last system
     error.  This is more specific information about the last system error
     than that provided by $!.  This is particularly important when $! is
     set to *EVMSERR*.

     Under OS/2, $^E is set to the error code of the last call to OS/2 API
     either via CRT, or directly from perl.

     Under Win32, $^E always returns the last error information reported
     by the Win32 call `GetLastError()' which describes the last error
     from within the Win32 API.  Most Win32-specific code will report
     errors via $^E.  ANSI C and Unix-like calls set errno and so most
     portable Perl code will report errors via $!.

     Caveats mentioned in the description of $! generally apply to $^E,
     also.  (Mnemonic: Extra error explanation.)

     Also see `Error Indicators' in this node.

$EVAL_ERROR
$@
     The Perl syntax error message from the last eval() operator.  If
     null, the last eval() parsed and executed correctly (although the
     operations you invoked may have failed in the normal fashion).
     (Mnemonic: Where was the syntax error "at"?)

     Warning messages are not collected in this variable.  You can,
     however, set up a routine to process warnings by setting
     `$SIG{__WARN__}' as described below.

     Also see `Error Indicators' in this node.

$PROCESS_ID
$PID
$$
     The process number of the Perl running this script.  You should
     consider this variable read-only, although it will be altered across
     fork() calls.  (Mnemonic: same as shells.)

$REAL_USER_ID
$UID
$<
     The real uid of this process.  (Mnemonic: it's the uid you came from,
     if you're running setuid.)

$EFFECTIVE_USER_ID
$EUID
$>
     The effective uid of this process.  Example:

          $< = $>;		# set real to effective uid
          ($<,$>) = ($>,$<);	# swap real and effective uid

     (Mnemonic: it's the uid you went to, if you're running setuid.)  `<
     $< '> and `< $' >> can be swapped only on machines supporting
     setreuid().

$REAL_GROUP_ID
$GID
$(
     The real gid of this process.  If you are on a machine that supports
     membership in multiple groups simultaneously, gives a space separated
     list of groups you are in.  The first number is the one returned by
     getgid(), and the subsequent ones by getgroups(), one of which may be
     the same as the first number.

     However, a value assigned to $( must be a single number used to set
     the real gid.  So the value given by $( should not be assigned back
     to $( without being forced numeric, such as by adding zero.

     (Mnemonic: parentheses are used to group things.  The real gid is the
     group you left, if you're running setgid.)

$EFFECTIVE_GROUP_ID
$EGID
$)
     The effective gid of this process.  If you are on a machine that
     supports membership in multiple groups simultaneously, gives a space
     separated list of groups you are in.  The first number is the one
     returned by getegid(), and the subsequent ones by getgroups(), one of
     which may be the same as the first number.

     Similarly, a value assigned to $) must also be a space-separated list
     of numbers.  The first number sets the effective gid, and the rest
     (if any) are passed to setgroups().  To get the effect of an empty
     list for setgroups(), just repeat the new effective gid; that is, to
     force an effective gid of 5 and an effectively empty setgroups()
     list, say ` $) = "5 5" '.

     (Mnemonic: parentheses are used to group things.  The effective gid
     is the group that's right for you, if you're running setgid.)

     `< $< '>, `< $' >>, $( and $) can be set only on machines that
     support the corresponding *set[re][ug]id()* routine.  $( and $) can
     be swapped only on machines supporting setregid().

$PROGRAM_NAME

$0
     Contains the name of the program being executed.  On some operating
     systems assigning to $0 modifies the argument area that the *ps*
     program sees.  This is more useful as a way of indicating the current
     program state than it is for hiding the program you're running.
     (Mnemonic: same as *sh* and *ksh*.)

$[
     The index of the first element in an array, and of the first character
     in a substring.  Default is 0, but you could theoretically set it to
     1 to make Perl behave more like *awk* (or Fortran) when subscripting
     and when evaluating the index() and substr() functions.  (Mnemonic: [
     begins subscripts.)

     As of release 5 of Perl, assignment to $[ is treated as a compiler
     directive, and cannot influence the behavior of any other file.  Its
     use is highly discouraged.

$]
     The version + patchlevel / 1000 of the Perl interpreter.  This
     variable can be used to determine whether the Perl interpreter
     executing a script is in the right range of versions.  (Mnemonic: Is
     this version of perl in the right bracket?)  Example:

          warn "No checksumming!\n" if $] < 3.019;

     See also the documentation of `use VERSION' and `require VERSION' for
     a convenient way to fail if the running Perl interpreter is too old.

     The use of this variable is deprecated.  The floating point
     representation can sometimes lead to inaccurate numeric comparisons.
     See $^V for a more modern representation of the Perl version that
     allows accurate string comparisons.

$COMPILING
$^C
     The current value of the flag associated with the -c switch.  Mainly
     of use with *-MO=...* to allow code to alter its behavior when being
     compiled, such as for example to AUTOLOAD at compile time rather than
     normal, deferred loading.  See `perlcc' in this node.  Setting `$^C =
     1' is similar to calling `B::minus_c'.

$DEBUGGING
$^D
     The current value of the debugging flags.  (Mnemonic: value of -D
     switch.)

$SYSTEM_FD_MAX
$^F
     The maximum system file descriptor, ordinarily 2.  System file
     descriptors are passed to exec()ed processes, while higher file
     descriptors are not.  Also, during an open(), system file descriptors
     are preserved even if the open() fails.  (Ordinary file descriptors
     are closed before the open() is attempted.)  The close-on-exec status
     of a file descriptor will be decided according to the value of $^F
     when the corresponding file, pipe, or socket was opened, not the time
     of the exec().

$^H
     WARNING: This variable is strictly for internal use only.  Its
     availability, behavior, and contents are subject to change without
     notice.

     This variable contains compile-time hints for the Perl interpreter.
     At the end of compilation of a BLOCK the value of this variable is
     restored to the value when the interpreter started to compile the
     BLOCK.

     When perl begins to parse any block construct that provides a lexical
     scope (e.g., eval body, required file, subroutine body, loop body, or
     conditional block), the existing value of $^H is saved, but its value
     is left unchanged.  When the compilation of the block is completed,
     it regains the saved value.  Between the points where its value is
     saved and restored, code that executes within BEGIN blocks is free to
     change the value of $^H.

     This behavior provides the semantic of lexical scoping, and is used
     in, for instance, the `use strict' pragma.

     The contents should be an integer; different bits of it are used for
     different pragmatic flags.  Here's an example:

          sub add_100 { $^H |= 0x100 }

          sub foo {
          	BEGIN { add_100() }
          	bar->baz($boon);
          }

     Consider what happens during execution of the BEGIN block.  At this
     point the BEGIN block has already been compiled, but the body of
     foo() is still being compiled.  The new value of $^H will therefore
     be visible only while the body of foo() is being compiled.

     Substitution of the above BEGIN block with:

          BEGIN { require strict; strict->import('vars') }

     demonstrates how `use strict 'vars'' is implemented.  Here's a
     conditional version of the same lexical pragma:

          BEGIN { require strict; strict->import('vars') if $condition }

%^H
     WARNING: This variable is strictly for internal use only.  Its
     availability, behavior, and contents are subject to change without
     notice.

     The %^H hash provides the same scoping semantic as $^H.  This makes it
     useful for implementation of lexically scoped pragmas.

$INPLACE_EDIT
$^I
     The current value of the inplace-edit extension.  Use undef to disable
     inplace editing.  (Mnemonic: value of -i switch.)

$^M
     By default, running out of memory is an untrappable, fatal error.
     However, if suitably built, Perl can use the contents of $^M as an
     emergency memory pool after die()ing.  Suppose that your Perl were
     compiled with -DPERL_EMERGENCY_SBRK and used Perl's malloc.  Then

          $^M = 'a' x (1 << 16);

     would allocate a 64K buffer for use when in emergency.  See the
     INSTALL file in the Perl distribution for information on how to
     enable this option.  To discourage casual use of this advanced
     feature, there is no *Note English: (pm.info)English, long name for
     this variable.

$OSNAME
$^O
     The name of the operating system under which this copy of Perl was
     built, as determined during the configuration process.  The value is
     identical to `$Config{'osname'}'.  See also *Note Config:
     (pm.info)Config, and the -V command-line switch documented in *Note
     Perlrun: perlrun,.

$PERLDB
$^P
     The internal variable for debugging support.  The meanings of the
     various bits are subject to change, but currently indicate:

       1. Debug subroutine enter/exit.

       2. Line-by-line debugging.

       3. Switch off optimizations.

       4. Preserve more data for future interactive inspections.

       5. Keep info about source lines on which a subroutine is defined.

       6. Start with single-step on.

       7. Use subroutine address instead of name when reporting.

       8. Report `goto &subroutine' as well.

       9. Provide informative "file" names for evals based on the place
          they were compiled.

      10. Provide informative names to anonymous subroutines based on the
          place they were compiled.

          Some bits may be relevant at compile-time only, some at run-time
     only.  This is a new mechanism and the details may change.

$LAST_REGEXP_CODE_RESULT
$^R
     The result of evaluation of the last successful `(?{ code })' regular
     expression assertion (see *Note Perlre: perlre,).  May be written to.

$EXCEPTIONS_BEING_CAUGHT
$^S
     Current state of the interpreter.  Undefined if parsing of the current
     module/eval is not finished (may happen in $SIG{__DIE__} and
     $SIG{__WARN__} handlers).  True if inside an eval(), otherwise false.

$BASETIME
$^T
     The time at which the program began running, in seconds since the
     epoch (beginning of 1970).  The values returned by the -M, -A, and -C
     filetests are based on this value.

$PERL_VERSION
$^V
     The revision, version, and subversion of the Perl interpreter,
     represented as a string composed of characters with those ordinals.
     Thus in Perl v5.6.0 it equals `chr(5) . chr(6) . chr(0)' and will
     return true for `$^V eq v5.6.0'.  Note that the characters in this
     string value can potentially be in Unicode range.

     This can be used to determine whether the Perl interpreter executing a
     script is in the right range of versions.  (Mnemonic: use ^V for
     Version Control.)  Example:

          warn "No "our" declarations!\n" if $^V and $^V lt v5.6.0;

     See the documentation of `use VERSION' and `require VERSION' for a
     convenient way to fail if the running Perl interpreter is too old.

     See also $] for an older representation of the Perl version.

$WARNING
$^W
     The current value of the warning switch, initially true if -w was
     used, false otherwise, but directly modifiable.  (Mnemonic: related
     to the -w switch.)  See also *Note Warnings: (pm.info)warnings,.

${^WARNING_BITS}
     The current set of warning checks enabled by the `use warnings'
     pragma.  See the documentation of warnings for more details.

${^WIDE_SYSTEM_CALLS}
     Global flag that enables system calls made by Perl to use wide
     character APIs native to the system, if available.  This is currently
     only implemented on the Windows platform.

     This can also be enabled from the command line using the -C switch.

     The initial value is typically 0 for compatibility with Perl versions
     earlier than 5.6, but may be automatically set to 1 by Perl if the
     system provides a user-settable default (e.g., `$ENV{LC_CTYPE}').

     The bytes pragma always overrides the effect of this flag in the
     current lexical scope.  See *Note Bytes: (pm.info)bytes,.

$EXECUTABLE_NAME
$^X
     The name that the Perl binary itself was executed as, from C's
     `argv[0]'.  This may not be a full pathname, nor even necessarily in
     your path.

$ARGV
     contains the name of the current file when reading from <>.

@ARGV
     The array @ARGV contains the command-line arguments intended for the
     script.  `$#ARGV' is generally the number of arguments minus one,
     because `$ARGV[0]' is the first argument, not the program's command
     name itself.  See $0 for the command name.

@INC
     The array @INC contains the list of places that the `do EXPR',
     require, or use constructs look for their library files.  It
     initially consists of the arguments to any -I command-line switches,
     followed by the default Perl library, probably `/usr/local/lib/perl',
     followed by ".", to represent the current directory.  If you need to
     modify this at runtime, you should use the `use lib' pragma to get
     the machine-dependent library properly loaded also:

          use lib '/mypath/libdir/';
          use SomeMod;

@_
     Within a subroutine the array @_ contains the parameters passed to
     that subroutine.  See *Note Perlsub: perlsub,.

%INC
     The hash %INC contains entries for each filename included via the do,
     require, or use operators.  The key is the filename you specified
     (with module names converted to pathnames), and the value is the
     location of the file found.  The require operator uses this hash to
     determine whether a particular file has already been included.

%ENV
$ENV{expr}
     The hash %ENV contains your current environment.  Setting a value in
     ENV changes the environment for any child processes you subsequently
     fork() off.

%SIG
$SIG{expr}
     The hash %SIG contains signal handlers for signals.  For example:

          sub handler {	# 1st argument is signal name
          	my($sig) = @_;
          	print "Caught a SIG$sig--shutting down\n";
          	close(LOG);
          	exit(0);
          }

          $SIG{'INT'}  = \&handler;
          $SIG{'QUIT'} = \&handler;
          ...
          $SIG{'INT'}  = 'DEFAULT';	# restore default action
          $SIG{'QUIT'} = 'IGNORE';	# ignore SIGQUIT

     Using a value of `'IGNORE'' usually has the effect of ignoring the
     signal, except for the `CHLD' signal.  See *Note Perlipc: perlipc,
     for more about this special case.

     Here are some other examples:

          $SIG{"PIPE"} = "Plumber";   # assumes main::Plumber (not recommended)
          $SIG{"PIPE"} = \&Plumber;   # just fine; assume current Plumber
          $SIG{"PIPE"} = *Plumber;    # somewhat esoteric
          $SIG{"PIPE"} = Plumber();   # oops, what did Plumber() return??

     Be sure not to use a bareword as the name of a signal handler, lest
     you inadvertently call it.

     If your system has the sigaction() function then signal handlers are
     installed using it.  This means you get reliable signal handling.  If
     your system has the SA_RESTART flag it is used when signals handlers
     are installed.  This means that system calls for which restarting is
     supported continue rather than returning when a signal arrives.  If
     you want your system calls to be interrupted by signal delivery then
     do something like this:

          use POSIX ':signal_h';

          my $alarm = 0;
          sigaction SIGALRM, new POSIX::SigAction sub { $alarm = 1 }
          	or die "Error setting SIGALRM handler: $!\n";

     See *Note POSIX: (pm.info)POSIX,.

     Certain internal hooks can be also set using the %SIG hash.  The
     routine indicated by `$SIG{__WARN__}' is called when a warning
     message is about to be printed.  The warning message is passed as the
     first argument.  The presence of a __WARN__ hook causes the ordinary
     printing of warnings to STDERR to be suppressed.  You can use this to
     save warnings in a variable, or turn warnings into fatal errors, like
     this:

          local $SIG{__WARN__} = sub { die $_[0] };
          eval $proggie;

     The routine indicated by `$SIG{__DIE__}' is called when a fatal
     exception is about to be thrown.  The error message is passed as the
     first argument.  When a __DIE__ hook routine returns, the exception
     processing continues as it would have in the absence of the hook,
     unless the hook routine itself exits via a goto, a loop exit, or a
     die().  The __DIE__ handler is explicitly disabled during the call,
     so that you can die from a __DIE__ handler.  Similarly for `__WARN__'.

     Due to an implementation glitch, the `$SIG{__DIE__}' hook is called
     even inside an eval().  Do not use this to rewrite a pending exception
     in `$@', or as a bizarre substitute for overriding
     CORE::GLOBAL::die().  This strange action at a distance may be fixed
     in a future release so that `$SIG{__DIE__}' is only called if your
     program is about to exit, as was the original intent.  Any other use
     is deprecated.

     __DIE__/`__WARN__' handlers are very special in one respect: they may
     be called to report (probable) errors found by the parser.  In such a
     case the parser may be in inconsistent state, so any attempt to
     evaluate Perl code from such a handler will probably result in a
     segfault.  This means that warnings or errors that result from
     parsing Perl should be used with extreme caution, like this:

          require Carp if defined $^S;
          Carp::confess("Something wrong") if defined &Carp::confess;
          die "Something wrong, but could not load Carp to give backtrace...
               To see backtrace try starting Perl with -MCarp switch";

     Here the first line will load Carp *unless* it is the parser who
     called the handler.  The second line will print backtrace and die if
     Carp was available.  The third line will be executed only if Carp was
     not available.

     See `die', *Note Perlfunc: perlfunc,, `warn', *Note Perlfunc:
     perlfunc,, `eval', *Note Perlfunc: perlfunc,, and `eval', *Note
     Warnings: (pm.info)warnings, for additional information.

Error Indicators
----------------

   The variables `$@', $!, $^E, and $? contain information about different
types of error conditions that may appear during execution of a Perl
program.  The variables are shown ordered by the "distance" between the
subsystem which reported the error and the Perl process.  They correspond
to errors detected by the Perl interpreter, C library, operating system,
or an external program, respectively.

   To illustrate the differences between these variables, consider the
following Perl expression, which uses a single-quoted string:

     eval q{
     	open PIPE, "/cdrom/install |";
     	@res = <PIPE>;
     	close PIPE or die "bad pipe: $?, $!";
     };

   After execution of this statement all 4 variables may have been set.

   `$@' is set if the string to be eval-ed did not compile (this may
happen if open or close were imported with bad prototypes), or if Perl
code executed during evaluation die()d .  In these cases the value of $@
is the compile error, or the argument to die (which will interpolate $!
and $?!).  (See also *Note Fatal: (pm.info)Fatal,, though.)

   When the eval() expression above is executed, open(), `< <PIPE' >>, and
close are translated to calls in the C run-time library and thence to the
operating system kernel.  $! is set to the C library's errno if one of
these calls fails.

   Under a few operating systems, $^E may contain a more verbose error
indicator, such as in this case, "CDROM tray not closed."  Systems that do
not support extended error messages leave $^E the same as $!.

   Finally, $? may be set to non-0 value if the external program
`/cdrom/install' fails.  The upper eight bits reflect specific error
conditions encountered by the program (the program's exit() value).   The
lower eight bits reflect mode of failure, like signal death and core dump
information  See wait(2) for details.  In contrast to $! and $^E, which
are set only if error condition is detected, the variable $? is set on
each wait or pipe close, overwriting the old value.  This is more like
`$@', which on every eval() is always set on failure and cleared on
success.

   For more details, see the individual descriptions at `$@', $!, $^E, and
$?.

Technical Note on the Syntax of Variable Names
----------------------------------------------

   Variable names in Perl can have several formats.  Usually, they must
begin with a letter or underscore, in which case they can be arbitrarily
long (up to an internal limit of 251 characters) and may contain letters,
digits, underscores, or the special sequence `::' or `''.  In this case,
the part before the last `::' or `'' is taken to be a *package qualifier*;
see *Note Perlmod: perlmod,.

   Perl variable names may also be a sequence of digits or a single
punctuation or control character.  These names are all reserved for
special uses by Perl; for example, the all-digits names are used to hold
data captured by backreferences after a regular expression match.  Perl
has a special syntax for the single-control-character names: It
understands `^X' (caret X) to mean the control-X character.  For example,
the notation $^W (dollar-sign caret W) is the scalar variable whose name
is the single character control-W.  This is better than typing a literal
control-W into your program.

   Finally, new in Perl 5.6, Perl variable names may be alphanumeric
strings that begin with control characters (or better yet, a caret).
These variables must be written in the form `${^Foo}'; the braces are not
optional.  `${^Foo}' denotes the scalar variable whose name is a control-F
followed by two o's.  These variables are reserved for future special uses
by Perl, except for the ones that begin with `^_' (control-underscore or
caret-underscore).  No control-character name that begins with `^_' will
acquire a special meaning in any future version of Perl; such names may
therefore be used safely in programs.  `$^_' itself, however, *is*
reserved.

   Perl identifiers that begin with digits, control characters, or
punctuation characters are exempt from the effects of the package
declaration and are always forced to be in package main.  A few other
names are also exempt:

     ENV		STDIN
     INC		STDOUT
     ARGV		STDERR
     ARGVOUT
     SIG

   In particular, the new special `${^_XYZ}' variables are always taken to
be in package main, regardless of any package declarations presently in
scope.

BUGS
====

   Due to an unfortunate accident of Perl's implementation, `use English'
imposes a considerable performance penalty on all regular expression
matches in a program, regardless of whether they occur in the scope of
`use English'.  For that reason, saying `use English' in libraries is
strongly discouraged.  See the Devel::SawAmpersand module documentation
from CPAN (http://www.perl.com/CPAN/modules/by-module/Devel/) for more
information.

   Having to even think about the $^S variable in your exception handlers
is simply wrong.  `$SIG{__DIE__}' as currently implemented invites
grievous and difficult to track down errors.  Avoid it and use an `END{}'
or CORE::GLOBAL::die override instead.


