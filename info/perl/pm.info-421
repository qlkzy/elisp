This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Win32/ASP/Profile,  Next: Win32/ChangeNotify,  Prev: Win32/ASP/Field,  Up: Module List

provides quick and dirty profiling for web performance testing
**************************************************************

NAME
====

   Win32::ASP::Profile - provides quick and dirty profiling for web
performance testing

SYNOPSIS
========

     use Win32::ASP::Profile;

DESCRIPTION
===========

   `Win32::ASP::Profile' outputs rudimentary profiling information at the
end of each web page through the use of BEGIN and END.  The BEGIN
subroutine initializes some information when the web page is first created
and the END subroutine computes the time it took for the web page to be
create and appends that to the end of the web page.

   To use, simply include the line

     use Win32::ASP::Profile;

   on any web page you want to profile.  If you are using a default
`*.INC' file, you can stick that line in the include file and thus garner
profiling information on all your ASP pages.


File: pm.info,  Node: Win32/ChangeNotify,  Next: Win32/Console,  Prev: Win32/ASP/Profile,  Up: Module List

Monitor events related to files and directories
***********************************************

NAME
====

   Win32::ChangeNotify - Monitor events related to files and directories

SYNOPSIS
========

     require Win32::ChangeNotify;

     $notify = Win32::ChangeNotify->new($Path,$WatchSubTree,$Events);
     $notify->wait or warn "Something failed: $!\n";
     # There has been a change.

DESCRIPTION
===========

   This module allows the user to use a Win32 change notification event
object from Perl.  This allows the Perl program to monitor events relating
to files and directory trees.

   The wait method and `wait_all' & `wait_any' functions are inherited
from the `"Win32::IPC"' in this node module.

Methods
-------

$notify = Win32::ChangeNotify->new($path, $subtree, $filter)
     Constructor for a new ChangeNotification object.  $path is the
     directory to monitor.  If `$subtree' is true, then all directories
     under $path will be monitored.  `$filter' indicates what events
     should trigger a notification.  It should be a string containing any
     of the following flags (separated by whitespace and/or |).

          ATTRIBUTES	Any attribute change
          DIR_NAME     Any directory name change
          FILE_NAME    Any file name change (creating/deleting/renaming)
          LAST_WRITE   Any change to a file's last write time
          SECURITY     Any security descriptor change
          SIZE         Any change in a file's size

     (`$filter' can also be an integer composed from the
     `FILE_NOTIFY_CHANGE_*' constants.)

$notify->close
     Shut down monitoring.  You could just `undef $notify' instead (but
     close works even if there are other copies of the object).  This
     happens automatically when your program exits.

$notify->reset
     Resets the ChangeNotification object after a change has been detected.
     The object will become signalled again after the next change.  (It is
     OK to call this immediately after new, but it is not required.)

$notify->wait
     See `"Win32::IPC"' in this node.  Remember to call reset afterwards
     if you want to continue monitoring.

Deprecated Functions and Methods
--------------------------------

   *Win32::ChangeNotify* still supports the ActiveWare syntax, but its use
is deprecated.

FindFirst($Obj,$PathName,$WatchSubTree,$Filter)
     Use

          $Obj = Win32::ChangeNotify->new($PathName,$WatchSubTree,$Filter)

     instead.

$obj->FindNext()
     Use `$obj->reset' instead.

$obj->Close()
     Use `$obj->close' instead.

AUTHOR
======

   Christopher J. Madsen <`chris_madsen@geocities.com'>

   Loosely based on the original module by ActiveWare Internet Corp.,
`http://www.ActiveWare.com'


File: pm.info,  Node: Win32/Console,  Next: Win32/DriveInfo,  Prev: Win32/ChangeNotify,  Up: Module List

Win32 Console and Character Mode Functions
******************************************

NAME
====

   Win32::Console - Win32 Console and Character Mode Functions

DESCRIPTION
===========

   This module implements the Win32 console and character mode functions.
They give you full control on the console input and output, including:
support of off-screen console buffers (eg. multiple screen pages)

   * reading and writing of characters, attributes and whole portions of
     the screen

   * complete processing of keyboard and mouse events

   * some very funny additional features :)

   Those functions should also make possible a port of the Unix's curses
library; if there is anyone interested (and/or willing to contribute) to
this project, e-mail me.  Thank you.

REFERENCE
=========

Methods
-------

Alloc
     Allocates a new console for the process.  Returns undef on errors, a
     nonzero value on success.  A process cannot be associated with more
     than one console, so this method will fail if there is already an
     allocated console.  Use Free to detach the process from the console,
     and then call Alloc to create a new console.  See also: Free

     Example:

          $CONSOLE->Alloc();

Attr [attr]
     Gets or sets the current console attribute.  This attribute is used by
     the Write method.

     Example:

          $attr = $CONSOLE->Attr();
          $CONSOLE->Attr($FG_YELLOW | $BG_BLUE);

Close
     Closes a shortcut object.  Note that it is not "strictly" required to
     close the objects you created, since the Win32::Shortcut objects are
     automatically closed when the program ends (or when you elsehow
     destroy such an object).

     Example:

          $LINK->Close();

Cls [attr]
     Clear the console, with the specified attr if given, or using
     ATTR_NORMAL otherwise.

     Example:

          $CONSOLE->Cls();
          $CONSOLE->Cls($FG_WHITE | $BG_GREEN);

Cursor [x, y, size, visible]
     Gets or sets cursor position and appearance.  Returns undef on
     errors, or a 4-element list containing: x, y, size, *visible*.  x and
     y are the current cursor position; ...

     Example:

          ($x, $y, $size, $visible) = $CONSOLE->Cursor();

          # Get position only
          ($x, $y) = $CONSOLE->Cursor();

          $CONSOLE->Cursor(40, 13, 50, 1);

          # Set position only
          $CONSOLE->Cursor(40, 13);

          # Set size and visibility without affecting position
          $CONSOLE->Cursor(-1, -1, 50, 1);

Display
     Displays the specified console on the screen.  Returns undef on
     errors, a nonzero value on success.

     Example:

          $CONSOLE->Display();

FillAttr [attribute, number, col, row]
     Fills the specified number of consecutive attributes, beginning at
     *col*, row, with the value specified in *attribute*.  Returns the
     number of attributes filled, or undef on errors.  See also: FillChar.

     Example:

          $CONSOLE->FillAttr($FG_BLACK | $BG_BLACK, 80*25, 0, 0);

FillChar char, number, col, row
     Fills the specified number of consecutive characters, beginning at
     *col*, row, with the character specified in *char*.  Returns the
     number of characters filled, or undef on errors.  See also: FillAttr.

     Example:

          $CONSOLE->FillChar("X", 80*25, 0, 0);

Flush
     Flushes the console input buffer.  All the events in the buffer are
     discarded.  Returns undef on errors, a nonzero value on success.

     Example:

          $CONSOLE->Flush();

Free
     Detaches the process from the console.  Returns undef on errors, a
     nonzero value on success.  See also: Alloc.

     Example:

          $CONSOLE->Free();

GenerateCtrlEvent [type, processgroup]
     Sends a break signal of the specified type to the specified
     *processgroup*.  type can be one of the following constants:

          CTRL_BREAK_EVENT
          CTRL_C_EVENT

     they signal, respectively, the pressing of Control + Break and of
     Control + C; if not specified, it defaults to CTRL_C_EVENT.
     *processgroup* is the pid of a process sharing the same console.  If
     omitted, it defaults to 0 (the current process), which is also the
     only meaningful value that you can pass to this function.  Returns
     undef on errors, a nonzero value on success.

     Example:

          # break this script now
          $CONSOLE->GenerateCtrlEvent();

GetEvents
     Returns the number of unread input events in the console's input
     buffer, or undef on errors.  See also: Input, InputChar, PeekInput,
     WriteInput.

     Example:

          $events = $CONSOLE->GetEvents();

Info
     Returns an array of informations about the console (or undef on
     errors), which contains:

        * columns (X size) of the console buffer.

        * rows (Y size) of the console buffer.

        * current column (X position) of the cursor.

        * current row (Y position) of the cursor.

        * current attribute used for Write.

        * left column (X of the starting point) of the current console
          window.

        * top row (Y of the starting point) of the current console window.

        * right column (X of the final point) of the current console
          window.

        * bottom row (Y of the final point) of the current console window.

        * maximum number of columns for the console window, given the
          current buffer size, font and the screen size.

        * maximum number of rows for the console window, given the current
          buffer size, font and the screen size.

     See also: Attr, Cursor, Size, Window, MaxWindow.

     Example:

          @info = $CONSOLE->Info();
          print "Cursor at $info[3], $info[4].\n";

Input
     Reads an event from the input buffer.  Returns a list of values, which
     depending on the event's nature are:

    keyboard event
          The list will contain:

             * event type: 1 for keyboard

             * key down: TRUE if the key is being pressed, FALSE if the
               key is being released

             * repeat count: the number of times the key is being held down

             * virtual keycode: the virtual key code of the key

             * virtual scancode: the virtual scan code of the key

             * char: the ASCII code of the character (if the key is a
               character key, 0 otherwise)

             * control key state: the state of the control keys (SHIFTs,
               CTRLs, ALTs, etc.)

    mouse event
          The list will contain:

             * event type: 2 for mouse

             * mouse pos. X: X coordinate (column) of the mouse location

             * mouse pos. Y: Y coordinate (row) of the mouse location

             * button state: the mouse button(s) which are pressed

             * control key state: the state of the control keys (SHIFTs,
               CTRLs, ALTs, etc.)

             * event flags: the type of the mouse event

     This method will return undef on errors.  Note that the events
     returned are depending on the input Mode of the console; for example,
     mouse events are not intercepted unless ENABLE_MOUSE_INPUT is
     specified.  See also: GetEvents, InputChar, Mode, PeekInput,
     WriteInput.

     Example:

          @event = $CONSOLE->Input();

InputChar number
     Reads and returns number characters from the console input buffer, or
     undef on errors.  See also: Input, Mode.

     Example:

          $key = $CONSOLE->InputChar(1);

InputCP [codepage]
     Gets or sets the input code page used by the console.  Note that this
     doesn't apply to a console object, but to the standard input console.
     This attribute is used by the Write method.  See also: OutputCP.

     Example:

          $codepage = $CONSOLE->InputCP();
          $CONSOLE->InputCP(437);

          # you may want to use the non-instanciated form to avoid confuzion :)
          $codepage = Win32::Console::InputCP();
          Win32::Console::InputCP(437);

MaxWindow
     Returns the size of the largest possible console window, based on the
     current font and the size of the display.  The result is undef on
     errors, otherwise a 2-element list containing col, row.

     Example:

          ($maxCol, $maxRow) = $CONSOLE->MaxWindow();

Mode [flags]
     Gets or sets the input or output mode of a console.  flags can be a
     combination of the following constants:

          ENABLE_LINE_INPUT
          ENABLE_ECHO_INPUT
          ENABLE_PROCESSED_INPUT
          ENABLE_WINDOW_INPUT
          ENABLE_MOUSE_INPUT
          ENABLE_PROCESSED_OUTPUT
          ENABLE_WRAP_AT_EOL_OUTPUT

     For more informations on the meaning of those flags, please refer to
     the `"Microsoft's Documentation"' in this node.

     Example:

          $mode = $CONSOLE->Mode();
          $CONSOLE->Mode(ENABLE_MOUSE_INPUT | ENABLE_PROCESSED_INPUT);

MouseButtons
     Returns the number of the buttons on your mouse, or undef on errors.

     Example:

          print "Your mouse has ", $CONSOLE->MouseButtons(), " buttons.\n";

new Win32::Console standard_handle
new Win32::Console [accessmode, sharemode]
     Creates a new console object.  The first form creates a handle to a
     standard channel, *standard_handle* can be one of the following:

          STD_OUTPUT_HANDLE
          STD_ERROR_HANDLE
          STD_INPUT_HANDLE

     The second form, instead, creates a console screen buffer in memory,
     which you can access for reading and writing as a normal console, and
     then redirect on the standard output (the screen) with Display.  In
     this case, you can specify one or both of the following values for
     *accessmode*:

          GENERIC_READ
          GENERIC_WRITE

     which are the permissions you will have on the created buffer, and one
     or both of the following values for *sharemode*:

          FILE_SHARE_READ
          FILE_SHARE_WRITE

     which affect the way the console can be shared.  If you don't specify
     any of those parameters, all 4 flags will be used.

     Example:

          $STDOUT = new Win32::Console(STD_OUTPUT_HANDLE);
          $STDERR = new Win32::Console(STD_ERROR_HANDLE);
          $STDIN  = new Win32::Console(STD_INPUT_HANDLE);

          $BUFFER = new Win32::Console();
          $BUFFER = new Win32::Console(GENERIC_READ | GENERIC_WRITE);

OutputCP [codepage]
     Gets or sets the output code page used by the console.  Note that this
     doesn't apply to a console object, but to the standard output console.
     See also: InputCP.

     Example:

          $codepage = $CONSOLE->OutputCP();
          $CONSOLE->OutputCP(437);

          # you may want to use the non-instanciated form to avoid confuzion :)
          $codepage = Win32::Console::OutputCP();
          Win32::Console::OutputCP(437);

PeekInput
     Does exactly the same as Input, except that the event read is not
     removed from the input buffer.  See also: GetEvents, Input,
     InputChar, Mode, WriteInput.

     Example:

          @event = $CONSOLE->PeekInput();

ReadAttr [number, col, row]
     Reads the specified number of consecutive attributes, beginning at
     *col*, row, from the console.  Returns the attributes read (a
     variable containing one character for each attribute), or undef on
     errors.  You can then pass the returned variable to WriteAttr to
     restore the saved attributes on screen.  See also: ReadChar, ReadRect.

     Example:

          $colors = $CONSOLE->ReadAttr(80*25, 0, 0);

ReadChar [number, col, row]
     Reads the specified number of consecutive characters, beginning at
     *col*, row, from the console.  Returns a string containing the
     characters read, or undef on errors.  You can then pass the returned
     variable to WriteChar to restore the saved characters on screen.  See
     also: ReadAttr, ReadRect.

     Example:

          $chars = $CONSOLE->ReadChar(80*25, 0, 0);

ReadRect left, top, right, bottom
     Reads the content (characters and attributes) of the rectangle
     specified by left, top, right, *bottom* from the console.  Returns a
     string containing the rectangle read, or undef on errors.  You can
     then pass the returned variable to WriteRect to restore the saved
     rectangle on screen (or on another console).  See also: ReadAttr,
     ReadChar.

     Example:

          $rect = $CONSOLE->ReadRect(0, 0, 80, 25);

Scroll left, top, right, bottom, col, row, char, attr,              [cleft, ctop, cright, cbottom]
     Moves a block of data in a console buffer; the block is identified by
     left, top, right, *bottom*, while row, *col* identify the new
     location of the block.  The cells left empty as a result of the move
     are filled with the character *char* and attribute attr.  Optionally
     you can specify a clipping region with *cleft*, *ctop*, *cright*,
     *cbottom*, so that the content of the console outside this rectangle
     are unchanged.  Returns undef on errors, a nonzero value on success.

     Example:

          # scrolls the screen 10 lines down, filling with black spaces
          $CONSOLE->Scroll(0, 0, 80, 25, 0, 10, " ", $FG_BLACK | $BG_BLACK);

Select standard_handle
     Redirects a standard handle to the specified console.
     *standard_handle* can have one of the following values:

          STD_INPUT_HANDLE
          STD_OUTPUT_HANDLE
          STD_ERROR_HANDLE

     Returns undef on errors, a nonzero value on success.

     Example:

          $CONSOLE->Select(STD_OUTPUT_HANDLE);

Size [col, row]
     Gets or sets the console buffer size.

     Example:

          ($x, $y) = $CONSOLE->Size();
          $CONSOLE->Size(80, 25);

Title [title]
     Gets or sets the title bar the string of the current console window.

     Example:

          $title = $CONSOLE->Title();
          $CONSOLE->Title("This is a title");

Window [flag, left, top, right, bottom]
     Gets or sets the current console window size.  If called without
     arguments, returns a 4-element list containing the current window
     coordinates in the form of left, top, right, *bottom*.  To set the
     window size, you have to specify an additional flag parameter: if it
     is 0 (zero), coordinates are considered relative to the current
     coordinates; if it is non-zero, coordinates are absolute.

     Example:

          ($left, $top, $right, $bottom) = $CONSOLE->Window();
          $CONSOLE->Window(1, 0, 0, 80, 50);

Write string
     Writes string on the console, using the current attribute, that you
     can set with Attr, and advancing the cursor as needed.  This isn't so
     different from Perl's "print" statement.  Returns the number of
     characters written or undef on errors.  See also: WriteAttr,
     WriteChar, WriteRect.

     Example:

          $CONSOLE->Write("Hello, world!");

WriteAttr attrs, col, row
     Writes the attributes in the string attrs, beginning at *col*, row,
     without affecting the characters that are on screen.  The string
     attrs can be the result of a ReadAttr function, or you can build your
     own attribute string; in this case, keep in mind that every attribute
     is treated as a character, not a number (see example).  Returns the
     number of attributes written or undef on errors.  See also: Write,
     WriteChar, WriteRect.

     Example:

          $CONSOLE->WriteAttr($attrs, 0, 0);

          # note the use of chr()...
          $attrs = chr($FG_BLACK | $BG_WHITE) x 80;
          $CONSOLE->WriteAttr($attrs, 0, 0);

WriteChar chars, col, row
     Writes the characters in the string attr, beginning at *col*, row,
     without affecting the attributes that are on screen.  The string chars
     can be the result of a ReadChar function, or a normal string.  Returns
     the number of characters written or undef on errors.  See also:
     Write, WriteAttr, WriteRect.

     Example:

          $CONSOLE->WriteChar("Hello, worlds!", 0, 0);

WriteInput (event)
     Pushes data in the console input buffer.  *(event)* is a list of
     values, for more information see Input.  The string chars can be the
     result of a ReadChar function, or a normal string.  Returns the
     number of characters written or undef on errors.  See also: Write,
     WriteAttr, WriteRect.

     Example:

          $CONSOLE->WriteInput(@event);

WriteRect rect, left, top, right, bottom
     Writes a rectangle of characters and attributes (contained in *rect*)
     on the console at the coordinates specified by left, top, right,
     *bottom*.  *rect* can be the result of a ReadRect function.  Returns
     undef on errors, otherwise a 4-element list containing the
     coordinates of the affected rectangle, in the format left, top,
     right, *bottom*.  See also: Write, WriteAttr, WriteChar.

     Example:

          $CONSOLE->WriteRect($rect, 0, 0, 80, 25);

Constants
---------

   The following constants are exported in the main namespace of your
script using Win32::Console:

     BACKGROUND_BLUE
     BACKGROUND_GREEN
     BACKGROUND_INTENSITY
     BACKGROUND_RED
     CAPSLOCK_ON
     CONSOLE_TEXTMODE_BUFFER
     ENABLE_ECHO_INPUT
     ENABLE_LINE_INPUT
     ENABLE_MOUSE_INPUT
     ENABLE_PROCESSED_INPUT
     ENABLE_PROCESSED_OUTPUT
     ENABLE_WINDOW_INPUT
     ENABLE_WRAP_AT_EOL_OUTPUT
     ENHANCED_KEY
     FILE_SHARE_READ
     FILE_SHARE_WRITE
     FOREGROUND_BLUE
     FOREGROUND_GREEN
     FOREGROUND_INTENSITY
     FOREGROUND_RED
     LEFT_ALT_PRESSED
     LEFT_CTRL_PRESSED
     NUMLOCK_ON
     GENERIC_READ
     GENERIC_WRITE
     RIGHT_ALT_PRESSED
     RIGHT_CTRL_PRESSED
     SCROLLLOCK_ON
     SHIFT_PRESSED
     STD_INPUT_HANDLE
     STD_OUTPUT_HANDLE
     STD_ERROR_HANDLE

   Additionally, the following variables can be used:

     $FG_BLACK
     $FG_BLUE
     $FG_LIGHTBLUE
     $FG_RED
     $FG_LIGHTRED
     $FG_GREEN
     $FG_LIGHTGREEN
     $FG_MAGENTA
     $FG_LIGHTMAGENTA
     $FG_CYAN
     $FG_LIGHTCYAN
     $FG_BROWN
     $FG_YELLOW
     $FG_GRAY
     $FG_WHITE

     $BG_BLACK
     $BG_BLUE
     $BG_LIGHTBLUE
     $BG_RED
     $BG_LIGHTRED
     $BG_GREEN
     $BG_LIGHTGREEN
     $BG_MAGENTA
     $BG_LIGHTMAGENTA
     $BG_CYAN
     $BG_LIGHTCYAN
     $BG_BROWN
     $BG_YELLOW
     $BG_GRAY
     $BG_WHITE

     $ATTR_NORMAL
     $ATTR_INVERSE

   ATTR_NORMAL is set to gray foreground on black background (DOS's
standard colors).

Microsoft's Documentation
-------------------------

   Documentation for the Win32 Console and Character mode Functions can be
found on Microsoft's site at this URL:


http://www.microsoft.com/msdn/sdk/platforms/doc/sdk/win32/sys/src/conchar.htm

   A reference of the available functions is at:


http://www.microsoft.com/msdn/sdk/platforms/doc/sdk/win32/sys/src/conchar_34.htm

VERSION HISTORY
===============

   * 0.031 (24 Sep 1999)
        *  Fixed typo in GenerateCtrlEvent().

        * Converted and added pod documentation (from Jan Dubois
          <jand@activestate.com>).

   * 0.03 (07 Apr 1997)
        *  Added "GenerateCtrlEvent" method.

        * The PLL file now comes in 2 versions, one for Perl version 5.001
          (build 110) and one for Perl version 5.003 (build 300 and higher,
          EXCEPT 304).

        * added an installation program that will automatically copy the
          right version in the right place.

   * 0.01 (09 Feb 1997)
        *  First public release.

AUTHOR
======

   Aldo Calpini <a.calpini@romagiubileo.it>

CREDITS
=======

   Thanks to: Jesse Dougherty, Dave Roth, ActiveWare, and the
Perl-Win32-Users community.

DISCLAIMER
==========

   This program is FREE; you can redistribute, modify, disassemble, or
even reverse engineer this software at your will.  Keep in mind, however,
that NOTHING IS GUARANTEED to work and everything you do is AT YOUR OWN
RISK - I will not take responsibility for any damage, loss of money and/or
health that may arise from the use of this program!

   This is distributed under the terms of Larry Wall's Artistic License.


File: pm.info,  Node: Win32/DriveInfo,  Next: Win32/Event,  Prev: Win32/Console,  Up: Module List

drives on Win32 systems
***********************

NAME
====

   Win32::DriveInfo - drives on Win32 systems

SYNOPSIS
========

     use Win32::DriveInfo;

     ($SectorsPerCluster,
      $BytesPerSector,
      $NumberOfFreeClusters,
      $TotalNumberOfClusters,
      $FreeBytesAvailableToCaller,
      $TotalNumberOfBytes,
      $TotalNumberOfFreeBytes) = Win32::DriveInfo::DriveSpace('f');

     $TotalNumberOfFreeBytes = (Win32::DriveInfo::DriveSpace('c:'))[6];

     $TotalNumberOfBytes = (Win32::DriveInfo::DriveSpace("\\\\serv\\share"))[5];

     @drives = Win32::DriveInfo::DrivesInUse();

     @freelet = Win32::DriveInfo::FreeDriveLetters();

     $type = Win32::DriveInfo::DriveType('a');

     ($VolumeName,
      $VolumeSerialNumber,
      $MaximumComponentLength,
      $FileSystemName, @attr) = Win32::DriveInfo::VolumeInfo('g');

     ($MajorVersion, $MinorVersion, $BuildNumber,
      $PlatformId, $BuildStr) = Win32::DriveInfo::GetVersionEx();

     # check is your CD-ROM loaded
     $CDROM = ( grep { Win32::DriveInfo::DriveType($_) == 5 }
     	Win32::DriveInfo::DrivesInUse() )[0];
     $CD_inside = Win32::DriveInfo::IsReady($CDROM);

ABSTRACT
========

   With this module you can get total/free space on Win32 drives, volume
names, architecture, filesystem type, drive attributes, list of all
available drives and free drive-letters. Additional function to determine
Windows version info.

   The intention was to have a part of Dave Roth's Win32::AdminMisc
functionality on Win95/98.

   The current version of Win32::DriveInfo is available at:

     http://base.dux.ru/guest/fno/perl/

DESCRIPTION
===========

   Module provides few functions:

DriveSpace ( drive )
     `($SectorsPerCluster, $BytesPerSector, $NumberOfFreeClusters,'
     `$TotalNumberOfClusters, $FreeBytesAvailableToCaller,'
     `$TotalNumberOfBytes, $TotalNumberOfFreeBytes) ='
     *Win32::DriveInfo::DriveSpace*( drive );

          drive - drive-letter in either 'c' or 'c:' or 'c:\\' form or UNC path
                  in either "\\\\server\\share" or "\\\\server\\share\\" form.
          $SectorsPerCluster          - number of sectors per cluster.
          $BytesPerSector             - number of bytes per sector.
          $NumberOfFreeClusters       - total number of free clusters on the disk.
          $TotalNumberOfClusters      - total number of clusters on the disk.
          $FreeBytesAvailableToCaller - total number of free bytes on the disk that
                                        are available to the user associated with the
                                        calling thread, b.
          $TotalNumberOfBytes         - total number of bytes on the disk, b.
          $TotalNumberOfFreeBytes     - total number of free bytes on the disk, b.

     Note: in case that UNC path was given first 4 values are undef.

     *Win 95 note:* Win32 API `GetDiskFreeSpaceEx()' function that is
     realized by internal (not intended for users) `GetDiskFreeSpaceEx()'
     subroutine is available on Windows 95 OSR2 (OEM Service Release 2)
     only. This means build numbers (`$BuildNumber' in `GetVersionEx ( )'
     function, described here later) greater then 1000.

     On lower Win95 builds `$FreeBytesAvailableToCaller,
     $TotalNumberOfBytes, $TotalNumberOfFreeBytes' are realized through
     the internal `GetDiskFreeSpace()' function that is claimed less
     trustworthy in Win32 SDK documentation.

     That's why on lower Win 95 builds this function will return 7 undef's
     for UNC drives.

     To say in short: *don't use `DriveSpace ( )' for UNC paths on early
     Win 95!* Where possible use

          net use * \\server\share

     and then usual '\w:' syntax.

DrivesInUse ( )
     Returns sorted array of all drive-letters in use.

FreeDriveLetters ( )
     Returns sorted array of all drive-letters that are available for
     allocation.

DriveType ( drive )
     Returns integer value:

          0     - the drive type cannot be determined.
          1     - the root directory does not exist.
          2     - the drive can be removed from the drive (removable).
          3     - the disk cannot be removed from the drive (fixed).
          4     - the drive is a remote (network) drive.
          5     - the drive is a CD-ROM drive.
          6     - the drive is a RAM disk.

          drive - drive-letter in either 'c' or 'c:' or 'c:\\' form or UNC path
                  in either "\\\\server\\share" or "\\\\server\\share\\" form.

     In case of UNC path 4 will be returned that means that networked
     drive is available (1 - if not available).

IsReady ( drive )
     Returns TRUE if root of the `drive' is accessible, otherwise FALSE.
     This one isn't really something cool - the function just tries to
     chdir to the `drive''s root. This takes time and produces unpleasant
     sound in case the removable drive is not loaded. If somebody knows
     some better way to determine is there something inside your CD-ROM or
     FDD - please let me know (in fact CD-ROMs, RAM drives and network
     drives return their status fast, may be some other devices make
     problem, dunno).

          drive - drive-letter in either 'c' or 'c:' or 'c:\\' form or UNC path
                  in either "\\\\server\\share" or "\\\\server\\share\\" form.

VolumeInfo ( drive )
     `($VolumeName, $VolumeSerialNumber, $MaximumComponentLength,'
     `$FileSystemName, @attr) =' *Win32::DriveInfo::VolumeInfo* ( drive );

          drive - drive-letter in either 'c' or 'c:' or 'c:\\' form.

          $VolumeName             - name of the specified volume.
          $VolumeSerialNumber     - volume serial number.
          $MaximumComponentLength -
               filename component supported by the specified file system.
               A filename component is that portion of a filename between backslashes.
               Indicate that long names are supported by the specified file system.
               For a FAT file system supporting long names, the function stores
               the value 255, rather than the previous 8.3 indicator. Long names can
               also be supported on systems that use the New Technology file system
               (NTFS).
          $FileSystemName         - name of the file system (such as FAT, FAT32, CDFS or NTFS).
          @attr                   - array of integers 1-6
            1 - file system preserves the case of filenames
            2 - file system supports case-sensitive filenames
            3 - file system supports Unicode in filenames as they appear on disk
            4 - file system preserves and enforces ACLs (access-control lists).
                For example, NTFS preserves and enforces ACLs, and FAT does not.
            5 - file system supports file-based compression
            6 - specified volume is a compressed volume; for ex., a DoubleSpace volume

GetVersionEx ( )
     This function provides version of the OS in use.

     `($MajorVersion, $MinorVersion, $BuildNumber, $PlatformId, $BuildStr)
     =' *Win32::DriveInfo::GetVersionEx* ( );

          $MajorVersion - major version number of the operating system. For Windows NT
                          version 3.51, it's 3; for Windows NT version 4.0, it's 4.

          $MinorVersion - minor version number of the operating system. For Windows NT
                          version 3.51, it's 51; for Windows NT version 4.0, it's 0.
          $BuildNumber  - build number of the operating system.
          $PlatformId   - 0 for Win32s, 1 for Win95/98, 2 for Win NT
          $BuildStr     - Windows NT: Contains string, such as "Service Pack 3".
                          Indicates the latest Service Pack installed on the system.
                          If no Service Pack has been installed, the string is empty.
                          Windows 95: Contains a null-terminated string that provides
                          arbitrary additional information about the operating system.

   Nothing is exported by default. All functions return undef on errors.

INSTALLATION
============

   As this is just a plain module no special installation is needed. Just
put it into /Win32 subdir somewhere in your @INC.  The standard

     Makefile.PL
     make
     make test
     make install

   installation procedure is provided. In addition

     make html

   will produce the HTML-docs.

   This module requires

   Win32::API module by Aldo Calpini

CAVEATS
=======

   This module has been created and tested in a Win95 environment on GS
port of Perl 5.004_02. As it uses Win32::API module I expect it would work
fine with other ports like ActiveState if Win32::API (API.dll) is compiled
for this port.

CHANGES
=======

     0.02 - Austin Durbin <adurbin@earthlink.net> tested module on Win NT
            and discovered small bug in UNC paths handling. Fixed.
            Thanks Austin!

     0.03 - fixed bug that returned incorrect values for volumes that are
            larger than 0x7fffffff bytes (2 GB). Approved on Win98 with FAT32.

     0.04 - added IsReady() function and MakeMaker compartible distribution.
            Empty SerialNumber fixed. Now it's empty string, previously it
     	was evaluated to 0000:0000.
     	Minor enhancements.

     0.05 - test.pl fixed, other minor fixes.
     	The last 0.0x version before the major update (soon!)

     0.06 - test.pl fixed more ;-)

BUGS
====

   `DriveSpace ( )' returns incorrect $NumberOfFreeClusters,
$TotalNumberOfClusters values on the large ( >2M ) drives.  Dunno whether
somebody use these values or not but I'll try to fix this in the next
release.

   Please report if any bugs.

VERSION
=======

   This man page documents Win32::DriveInfo version 0.06

   February 19, 2001

AUTHOR
======

   Mike Blazer <blazer@mail.nevalink.ru>

COPYRIGHT
=========

   Copyright (C) 1998-2001 by Mike Blazer. All rights reserved.

LICENSE
=======

   This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Win32/Event,  Next: Win32/EventLog,  Prev: Win32/DriveInfo,  Up: Module List

Use Win32 event objects from Perl
*********************************

NAME
====

   Win32::Event - Use Win32 event objects from Perl

SYNOPSIS
========

     use Win32::Event;

     $event = Win32::Event->new($manual,$initial,$name);
     $event->wait();

DESCRIPTION
===========

   This module allows access to the Win32 event objects.  The wait method
and `wait_all' & `wait_any' functions are inherited from the
`"Win32::IPC"' in this node module.

Methods
-------

$event = Win32::Event->new([$manual, [$initial, [$name]]])
     Constructor for a new event object.  If `$manual' is true, you must
     manually reset the event after it is signalled (the default is false).
     If `$initial' is true, the initial state of the object is signalled
     (default false).  If $name is omitted, creates an unnamed event
     object.

     If $name signifies an existing event object, then `$manual' and
     `$initial' are ignored and the object is opened.

$event = Win32::Event->open($name)
     Constructor for opening an existing event object.

$event->pulse
     Signal the $event and then immediately reset it.  If $event is a
     manual-reset event, releases all threads currently blocking on it.  If
     it's an auto-reset event, releases just one thread.

     If no threads are waiting, just resets the event.

$event->reset
     Reset the $event to nonsignalled.

$event->set
     Set the $event to signalled.

$event->wait([$timeout])
     Wait for $event to be signalled.  See `"Win32::IPC"' in this node.

AUTHOR
======

   Christopher J. Madsen <`chris_madsen@geocities.com'>


File: pm.info,  Node: Win32/EventLog,  Next: Win32/EventLog/Carp,  Prev: Win32/Event,  Up: Module List

Process Win32 Event Logs from Perl
**********************************

NAME
====

   Win32::EventLog - Process Win32 Event Logs from Perl

SYNOPSIS
========

     use Win32::EventLog
     $handle=Win32::EventLog->new("Application");

DESCRIPTION
===========

   This module implements most of the functionality available from the
Win32 API for accessing and manipulating Win32 Event Logs. The access to
the EventLog routines is divided into those that relate to an EventLog
object and its associated methods and those that relate other EventLog
tasks (like adding an EventLog record).

The EventLog Object and its Methods
===================================

   The following methods are available to open, read, close and backup
EventLogs.

Win32::EventLog->new(SOURCENAME [,SERVERNAME]);
     The new() method creates a new EventLog object and returns a handle
     to it. This hande is then used to call the methods below.

     The method is overloaded in that if the supplied SOURCENAME argument
     contains one or more literal '\' characters (an illegal character in
     a SOURCENAME), it assumes that you are trying to open a backup
     eventlog and uses SOURCENAME as the backup eventlog to open. Note
     that when opening a backup eventlog, the SERVERNAME argument is
     ignored (as it is in the underlying Win32 API). For EventLogs on
     remote machines, the SOURCENAME parameter must therefore be specified
     as a UNC path.

$handle->Backup(FILENAME);
     The Backup() method backs up the EventLog represented by $handle. It
     takes a single arguemt, FILENAME. When $handle represents an EventLog
     on a remote machine, FILENAME is filename on the remote machine and
     cannot be a UNC path (i.e you must use `C:\TEMP\App.EVT').  The
     method will fail if the log file already exists.

$handle->Read(FLAGS, OFFSET, HASHREF);
     The Read() method read an EventLog entry from the EventLog represented
     by $handle.

$handle->Close();
     The Close() method closes the EventLog represented by $handle. After
     Close() has been called, any further attempt to use the EventLog
     represented by $handle will fail.

$handle->GetOldest(SCALARREF);
     The GetOldest() method number of the the oldest EventLog record in
     the EventLog represented by $handle. This is required to correctly
     compute the OFFSET required by the Read() method.

$handle->GetNumber(SCALARREF);
     The GetNumber() method returns the number of EventLog records in the
     EventLog represented by $handle. The number of the most recent record
     in the EventLog is therefore computed by

          $handle->GetOldest($oldest);
          $handle->GetNumber($lastRec);
          $lastRecOffset=$oldest+$lastRec;

$handle->Clear(FILENAME);
     The Clear() method clears the EventLog represented by $handle.  If
     you provide a non-null FILENAME, the EventLog will be backed up into
     FILENAME before the EventLog is cleared. The method will fail if
     FILENAME is specified and the file refered to exists. Note also that
     FILENAME specifies a file local to the machine on which the EventLog
     resides and cannot be specified as a UNC name.

$handle->Report(HASHREF);
     The Report() method generates an EventLog entry. The HASHREF should
     contain the following keys:

    `Computer'
          The `Computer' field specfies which computer you want the
          EventLog entry recorded.  If this key doesn't exist, the server
          name used to create the $handle is used.

    Source
          The Source field specifies the source that generated the EventLog
          entry.  If this key doesn't exist, the source name used to
          create the $handle is used.

    `EventType'
          The `EventType' field should be one of the constants

         `EVENTLOG_ERROR_TYPE'
               An Error event is being logged.

         `EVENTLOG_WARNING_TYPE'
               A Warning event is being logged.

         `EVENTLOG_INFORMATION_TYPE'
               An Information event is being logged.

         `EVENTLOG_AUDIT_SUCCESS'
               A Success Audit event is being logged (typically in the
               Security EventLog).

         `EVENTLOG_AUDIT_FAILURE'
               A Failure Audit event is being logged (typically in the
               Security EventLog).

          These constants are exported into the main namespace by default.

    Category
          The Category field can have any value you want. It is specific to
          the particular Source.

    `EventID'
          The `EventID' field should contain the ID of the message that
          this event pertains too. This assumes that you have an
          associated message file (indirectly referenced by the field
          Source).

    Data
          The Data field contains raw data associated with this event.

    Strings
          The Strings field contains the single string that itself contains
          NUL terminated sub-strings. This are used with the EventID to
          generate the message as seen from (for example) the Event Viewer
          application.

Other Win32::EventLog functions.
================================

   The following functions are part of the Win32::EventLog package but are
not callable from an EventLog object.

GetMessageText(HASHREF);
     The GetMessageText() function assumes that HASHREF was obtained by a
     call to `$handle->Read()'. It returns the formatted string that
     represents the fully resolved text of the EventLog message (such as
     would be seen in the Windows NT Event Viewer). For convenience, the
     key 'Message' in the supplied HASHREF is also set to the return value
     of this function.

     If you set the variable $Win32::EventLog::GetMessageText to 1 then
     each call to `$handle->Read()' will call this function automatically.

Example 1
=========

   The following example illustrates the way in which the EventLog module
can be used. It opens the System EventLog and reads through it from oldest
to newest records. For each record from the Source EventLog it extracts
the full text of the Entry and prints the EventLog message text out.

     use Win32::EventLog;

     $handle=Win32::EventLog->new("System", $ENV{ComputerName})
     	or die "Can't open Application EventLog\n";
     $handle->GetNumber($recs)
     	or die "Can't get number of EventLog records\n";
     $handle->GetOldest($base)
     	or die "Can't get number of oldest EventLog record\n";

     while ($x < $recs) {
     	$handle->Read(EVENTLOG_FORWARDS_READ|EVENTLOG_SEEK_READ,
     				  $base+$x,
     				  $hashRef)
     		or die "Can't read EventLog entry #$x\n";
     	if ($hashRef->{Source} eq "EventLog") {
     		Win32::EventLog::GetMessageText($hashRef);
     		print "Entry $x: $hashRef->{Message}\n";
     	}
     	$x++;
     }

Example 2
=========

   To backup and clear the EventLogs on a remote machine, do the following
:-

     use Win32::EventLog;

     $myServer="\\\\my-server";	# your servername here.
     my($date)=join("-", ((split(/\s+/, scalar(localtime)))[0,1,2,4]));
     my($dest);

     for my $eventLog ("Application", "System", "Security") {
     	$handle=Win32::EventLog->new($eventLog, $myServer)
     		or die "Can't open Application EventLog on $myServer\n";

     $dest="C:\\BackupEventLogs\\$eventLog\\$date.evt";
     	$handle->Backup($dest)
     		or warn "Could not backup and clear the $eventLog EventLog on $myServer ($^E)\n";

     $handle->Close;
      }

   Note that only the Clear method is required. Note also that if the file
$dest exists, the function will fail.

BUGS
====

   None currently known.

   The test script for 'make test' should be re-written to use the
EventLog object.

AUTHOR
======

   Original code by Jesse Dougherty for HiP Communications. Additional
fixes and updates attributed to Martin Pauley
<martin.pauley@ulsterbank.ltd.uk>) and Bret Giddings (bret@essex.ac.uk).


File: pm.info,  Node: Win32/EventLog/Carp,  Next: Win32/File,  Prev: Win32/EventLog,  Up: Module List

for carping in the Windows NT Event Log
***************************************

NAME
====

   Win32::EventLog::Carp - for carping in the Windows NT Event Log

REQUIREMENTS
============

     Carp
     Win32::EventLog

SYNOPSIS
========

     use Win32::EventLog::Carp;
     croak "We're outta here!";

     use Win32::EventLog::Carp qw(cluck);
     cluck "This is how we got here!";

DESCRIPTION
===========

   `Win32::EventLog::Carp' traps warnings and fatal errors in Perl and
reports these errors in the Windows NT Event Log. This is useful for
scripts which run as services or through the scheduler, and for CGI/ISAPI
scripts.

   The interface is similar to Carp: the carp, croak and `confess'
functions are exported (with `cluck' being optional).  You need only change
references of "Carp" to "Win32::EventLog::Carp" to begin using this module.

   One notable exception is the addition of the `click' function:

     Win32::EventLog::Carp::click "Hello!\n";

   This outouts a message to STDERR with a short stack trace and allows
scripts to post a simple "I have started" or "I am doing XYZ now" message
to the log.  To avoid the stack trace, end the message with a newline
(which is what happens with the Carp module).

   All messages are posted the the Application Log we well as to STDERR.

Using Win32::EventLog::Carp with CGI::Carp
------------------------------------------

   Some modules which trap the `__WARN__' and __DIE__ signals are not very
friendly, and will cancel out existing traps. The solution is to use this
module after using other modules:

     use CGI::Carp;
     use Win32::EventLog::Carp

   or

     BEGIN
       {
         $SIG{__WARN__} = \&my_handler;
       }

     use Win32::EventLog::Carp

   It is assumed that the previous handler will properly warn or die as
appropriate. This module will instead report these events to the NT event
log.

eval and die
------------

   This module *will* log errors in the event log when something dies in an
eval.  This is a feature, not a bug.

BUGS
====

   Bugs in `Win32::EventLog' and Carp may lead to bugs with this module.

SEE ALSO
========

     Carp
     CGI::Carp
     Win32::EventLog

AUTHOR
======

   Robert Rothenberg <rrwo@cpan.org>

LICENSE
=======

   Copyright (c) 2000-2001 Robert Rothenberg. All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.


File: pm.info,  Node: Win32/File,  Next: Win32/FileOp,  Prev: Win32/EventLog/Carp,  Up: Module List

manage file attributes in perl
******************************

NAME
====

   Win32::File - manage file attributes in perl

SYNOPSIS
========

     use Win32::File;

DESCRIPTION
===========

   This module offers the retrieval and setting of file attributes.

Functions
=========

NOTE
----

   All of the functions return FALSE (0) if they fail, unless otherwise
noted.  The function names are exported into the caller's namespace by
request.

GetAttributes(filename, returnedAttributes)
     Gets the attributes of a file or directory. returnedAttributes will
     be set to the OR-ed combination of the filename attributes.

SetAttributes(filename, newAttributes)
     Sets the attributes of a file or directory. newAttributes must be an
     OR-ed combination of the attributes.

Constants
=========

   The following constants are exported by default.

ARCHIVE
COMPRESSED
DIRECTORY
HIDDEN
NORMAL
OFFLINE
READONLY
SYSTEM
TEMPORARY

File: pm.info,  Node: Win32/FileOp,  Next: Win32/FileSecurity,  Prev: Win32/File,  Up: Module List

0.10.3
******

NAME
====

     Win32::FileOp - 0.10.3

DESCRIPTION
===========

   Module for file operations with fancy dialog boxes, for moving files to
recycle bin, reading and updating INI files and file operations in general.

   Unless mentioned otherwise all functions work both under WinNT and
Win95.

   Version 0.10.3

Functions
---------

   GetDesktopHandle GetWindowHandle

   Copy CopyConfirm CopyConfirmEach CopyEx

   Move MoveConfirm MoveConfirmEach MoveEx

   MoveFile MoveFileEx CopyFile MoveAtReboot

   Recycle RecycleConfirm RecycleConfirmEach RecycleEx

   Delete DeleteConfirm DeleteConfirmEach DeleteEx DeleteAtReboot

   UpdateDir FillInDir

   Compress Uncompress Compressed SetCompression GetCompression
CompressDir UncompressDir

   AddToRecentDocs EmptyRecentDocs

   WriteToINI WriteToWININI ReadINI ReadWININI

   DeleteFromINI DeleteFromWININI

   OpenDialog SaveAsDialog BrowseForFolder

   Map Unmap Disconnect Mapped

GetDesktopHandle
          use Win32::FileOp
          $handle = GetDesktopHandle()

     Same as: $handle = $Win32::FileOp::DesktopHandle

     Used to get desktop window handle when confirmation is used.  The
     value of the handle can be gotten from $Win32::FileOp::DesktopHandle.

     Returns the Desktop Window handle.

GetWindowHandle
          use Win32::FileOp
          $handle = GetWindowHandle()

     Same as: $handle = $Win32::FileOp::WindowHandle

     Used to get the console window handle when confirmation is used.  The
     value of the handle can be gotten from $Win32::FileOp::WindowHandle.

     Returns the Console Window handle.

Copy
          Copy ($FileName => $FileOrDirectoryName [, ...])
          Copy (\@FileNames => $DirectoryName [, ...] )
          Copy (\@FileNames => \@FileOrDirectoryNames [, ...])

     Copies the specified files. Doesn't show any confirmation nor
     progress dialogs.

     It may show an error message dialog, because I had to omit
     FOF_NOERRORUI from its call to allow for autocreating directories.

     You should end the directory names by backslash so that they are not
     mistaken for filenames. It is not necessary if the directory already
     exists or if you use Copy \@filenames => $dirname.

     Returns true if successful.

     Rem: Together with Delete, Move, DeleteConfirm, CopyConfirm,
     MoveConfirm, CopyEx, MoveEx, DeleteEx and Recycle based on Win32 API
     function SHFileOperation().

CopyConfirm
          CopyConfirm ($FileName => $FileOrDirectoryName [, ...])
          CopyConfirm (\@FileNames => $DirectoryName [, ...] )
          CopyConfirm (\@FileNames => \@FileOrDirectoryNames [, ...])

     Copies the specified files. In case of a collision, shows a
     confirmation dialog.  Shows progress dialogs.

     Returns true if successful.

CopyConfirmEach
     The same as CopyConfirm.

CopyEx
          CopyEx ($FileName => $FileOrDirectoryName, [...], $options)
          CopyEx (\@FileNames => $DirectoryName, [...], $options)
          CopyEx (\@FileNames => \@FileOrDirectoryNames, [...], $options)

     Copies the specified files. See below for the available options (FOF_
     constants).

     Returns true if successful.

Move
     Moves the specified files. Parameters as Copy

     It may show an error message dialog, because I had to omit
     FOF_NOERRORUI from its call to allow for autocreating directories.

MoveConfirm
     Moves the specified files. Parameters as CopyConfirm

MoveConfirmEach
     The same as MoveConfirm

MoveEx
     Moves the specified files. Parameters as CopyEx

MoveAtReboot
          MoveAtReboot ($FileName => $DestFileName, [...])

     This function moves the file during the next start of the system.

MoveFile
          MoveFile ($FileName => $DestFileName [, ...])

     Move files. This function uses API function MoveFileEx as well as
     MoveAtReboot. It may be a little quicker than Move, but it doesn't
     understand wildcards and the $DestFileName may not be a directory.

     REM: Based on Win32 API function MoveFileEx().

MoveFileEx
          MoveFileEx ($FileName => $DestFileName [, ...], $options)

     This is a simple wrapper around the API function MoveFileEx, it calls
     the function for every pair of files with the $options you specify.
     See below for the available options (FOF_... constants).

     REM: Based on Win32 API function MoveFileEx().

CopyFile
          CopyFile ($FileName => $DestFileName [, $FileName2 => $DestFileName2 [, ...]])

     Copy a file somewhere. This function is not able to copy directories!

     REM: Based on Win32 API function CopyFile().

Recycle
          Recycle @filenames

     Send the files into the recycle bin. You will not get any
     confirmation dialogs.

     Returns true if successful.

RecycleConfirm
          RecycleConfirm @filenames

     Send the files into the recycle bin. You will get a confirmation
     dialog if you have "Display delete confirmation dialog" turned on in
     your recycle bin. You will confirm the deletion of all the files at
     once.

     Returns true if successful. Please remember that this function is
     successful even if the user chose [No] on the confirmation dialog!

RecycleConfirmEach
          RecycleConfirmEach @filenames

     Send the files into the recycle bin. You will get a separate
     confirmation dialog for each file if you have "Display delete
     confirmation dialog" turned on in your recycle bin. You will confirm
     the deletion of all the files at once.

     Returns the number of files that were successfully deleted.

RecycleEx
          RecycleEx @filenames, $options

     Send the files into the recycle bin. You may specify the options for
     deleting, see below.  You may get a confirmation dialog if you have
     "Display delete confirmation dialog" turned on in your recycle bin,
     if so, you will confirm the deletion of all the files at once.

     Returns true if successful. Please remember that this function is
     successful even if the user chose [No] on the confirmation dialog!

     The $options may be constructed from FOF_... constants.

Delete
          Delete @filenames

     Deletes the files. You will not get any confirmation dialogs.

     Returns true if successful.

DeleteConfirm
          DeleteConfirm @filenames

     Deletes the the files. You will get a confirmation dialog to confirm
     the deletion of all the files at once.

     Returns true if successful. Please remember that this function is
     successful even if the user selected [No] on the confirmation dialog!

DeleteConfirmEach
          DeleteConfirmEach @filenames

     Deletes the files. You will get a separate confirmation dialog for
     each file.

     Returns the number of files that were successfully deleted.

DeleteEx
          DeleteEx @filenames, $options

     Deletes the files. You may specify the options for deleting, see
     below.  You may get a confirmation dialog if you have "Display delete
     confirmation dialog" turned on in your recycle bin.

     Returns true if successful. Please remember that this function is
     successful even if the user selected [No] on the confirmation dialog!

DeleteAtReboot
          DeleteAtReboot @files

     This function moves the file during the next start of the system.

UpdateDir
          UpdateDir $SourceDirectory, $DestDirectory [, \&callback]

     Copy the newer or updated files from $SourceDir to $DestDir.
     Processes subdirectories!  The &callback function is called for each
     file to be copied.  The parameters it gets are exactly the same as
     the callback function in File::Find. That is $_, $File::Find::dir and
     $File::Find::name.

     If this function returns a false value, the file is skipped.

          Ex.

          UpdateDir 'c:\dir' => 'e:\dir', sub {print '.'};
          UpdateDir 'c:\dir' => 'e:\dir', sub {if (/^s/i) {print '.'}};

FillInDir
          FillInDir $SourceDirectory, $DestDirectory [, \&callback]

     Copy the files from $SourceDir not present in $DestDir. Processes
     subdirectories!  The &callback works the same as in UpdateDir.

Compress
          Compress $filename [, ...]

     Compresses the file(s) or directories using the transparent WinNT
     compression (The same as checking the "Compressed" checkbox in
     Explorer properties fo the file).

     It doesn't compress all files and subdirectories in a directory you
     specify. Use ComressDir for that. Compress($directory) only sets the
     compression flag for the directory so that the new files are
     compressed by default.

     WinNT only!

     REM: Together with other compression related functions based on
     DeviceIoControl() Win32 API function.

Uncompress
          Uncompress $filename [, ...]

     Uncompresses the file(s) using the transparent WinNT compression (The
     same as unchecking the "Compressed" checkbox in Explorer properties
     fo the file).

     WinNT only!

Compressed
          Compressed $filename

     Checks the compression status for a file.

SetCompression
          SetCompression $filename [, $filename], $value

     Sets the compression status for file(s). The $value should be either
     1 or 0.

GetCompression
          GetCompression $filename

     Checks the compression status for a file.

CompressDir
          CompressDir $directory, ... [, \&callback]

     Recursively descends the directory(ies) specified and compresses all
     files and directories within. If you specify the \&callback, the
     specified function gets executed for each of the files and
     directories. If the callback returns false, no compression is done on
     the file/directory.

     The parameters the callback gets are exactly the same as the callback
     function in File::Find. That is $_, $File::Find::dir and
     $File::Find::name.

UncompressDir
          UncompressDir $directory, ... [, \&callback]

     The counterpart of CompressDir.

AddToRecentDocs
          AddToRecentDocs $filename [, ...]

     Add a shortcut(s) to the file(s) into the Recent Documents folder.
     The shortcuts will appear in the Documents submenu of Start Menu.

     The paths may be relative.

     REM: Based on Win32 API function SHAddToRecentDocs().

EmptyRecentDocs
          EmptyRecentDocs;

     Deletes all shortcuts from the Recent Documents folder.

     REM: Based on Win32 API function SHAddToRecentDocs(). Strange huh?

WriteToINI
          WriteToINI $INIfile, $section, $name1 => $value [, $name2 => $value2 [, ...]]

     Copies a string into the specified section of the specified
     initialization file.  You may pass several name/value pairs at once.

     Returns 1 if successful, undef otherwise. See Win32::GetLastError &
     Win32::FormatMessage(Win32::GetLastError) if failed for the error
     code and message.

     REM: Based on Win32 API function WritePrivateProfileString().

WriteToWININI
          WriteToWININI $section, $name1 => $value1 [, $name2 => $value2 [, ...]]

     Copies a string into the specified section of WIN.INI.  You may pass
     several name/value pairs at once.

     Please note that some values or sections of WIN.INI and some other INI
     files are mapped to registry so they do not show up in the INI file
     even if they were successfully written!

     REM: Based on Win32 API function WriteProfileString().

ReadINI
          $value = ReadINI $INIfile, $section, $name [, $defaultvalue]

     Reads a value from an INI file. If you do not specify the default and
     the value is not found you'll get undef.

     REM: Based on Win32 API function GetPrivateProfileString().

ReadWININI
          $value = ReadWININI $section, $name [, $defaultvalue]

     Reads a value from WIN.INI file. If you do not specify the default
     and the value is not found you'll get undef.

     Please note that some values or sections of WIN.INI and some other INI
     files are mapped to registry so even that they do not show up in the
     INI file this function will find and read them!

     REM: Based on Win32 API function GetProfileString().

DeleteFromINI
          DeleteFromINI $INIfile, $section, @names_to_delete

     Delete a value from an INI file.

     REM: Based on Win32 API function WritePrivateProfileString().

DeleteFromWININI
          DeleteFromWININI $section, @names_to_delete

     Delete a value from WIN.INI.

     REM: Based on Win32 API function WriteProfileString().

ReadINISections
          @sections = ReadINISections($inifile);
          \@sections = ReadINISections($inifile);
          ReadINISections($inifile,\@sections);

     Enumerate the sections in a INI file. If you do not specify the INI
     file, it enumerates the contents of win.ini.

     REM: Based on Win32 API function GetPrivateProfileString().

ReadINISectionKeys
          @sections = ReadINISectionKeys($inifile, $section);
          \@sections = ReadINISectionKeys($inifile, $section);
          ReadINISectionKeys($inifile, $section, \@sections);

     Enumerate the keys in a section of a INI file. If you do not specify
     the INI file, it enumerates the contents of win.ini.

     REM: Based on Win32 API function GetPrivateProfileString().

OpenDialog
          $filename = OpenDialog \%parameters [, $defaultfilename]
          @filenames = OpenDialog \%parameters [, $defaultfilename]

          $filename = OpenDialog %parameters [, $defaultfilename]
          @filenames = OpenDialog %parameters [, $defaultfilename]

     Creates the standard Open dialog allowing you to select some files.

     Returns a list of selected files or undef if the user pressed
     [Escape].  It also sets two global variables :

          $Win32::FileOp::ReadOnly = the user requested a readonly access.
          $Win32::FileOp::SelectedFilter = the id of filter selected in the dialogbox

          %parameters
           title => the title for the dialog, default is 'Open'
                 'Open file'
           filters => definition of file filters
                 { 'Filter 1' => '*.txt;*.doc', 'Filter 2' => '*.pl;*.pm'}
                 [ 'Filter 1' => '*.txt;*.doc', 'Filter 2' => '*.pl;*.pm']
                 [ 'Filter 1' => '*.txt;*.doc', 'Filter 2' => '*.pl;*.pm' , $default]
                 "Filter 1\0*.txt;*.doc\0Filter 2\0*.pl;*.pm"
           defaultfilter => the number of the default filter counting from 1.
                            Please keep in mind that hashes do not preserve
                            ordering!
           dir => the initial directory for the dialog, default is the current directory
           filename => the default filename to be showed in the dialog
           extension => the default extension, this function appends this extension to
                        the filename if the user fails to type an extension. This
                        string can be any length, but only the first three characters
                        are appended. The string should not contain a period (.).
           handle => the handle to the window which will own this dialog
                     Default is the console of the perl script.
                     If you do not want to tie the dialog to any window use
                     handle => 0
           options => options for the dialog, see bellow OFN_... constants

     There is a little problem with the underlying function. You have to
     preallocate a buffer for the selected filenames and if the buffer is
     too smallyou will not get any results. I've consulted this with the
     guys on Perl-Win32-Users and there is not any nice solution. The
     defalut size of buffer is 256B if the options do not include
     OFN_ALLOWMULTISELECT and 64KB if they do. You may change the later
     via variable $Win32::FileOp::BufferSize.

     REM: Based on Win32 API function GetOpenFileName().

SaveAsDialog
     Creates the Save As dialog box, parameters are the same as for
     OpenDialog.

BrowseForFolder
          BrowseForFolder [$title [, $rootFolder [, $options]]]

     Creates the standard "Browse For Folder" dialog.  The $title
     specifies the text to be displayed below the title of the dialog.
     The $rootFolder may be one of the CSIDL_... constants.  For $options
     you should use the BIF_... constants. Description of the constants is
     bellow.

     REM: Based on Win32 API function GetSaveFileName().

Map
          Map $drive => $share;
          $drive = Map $share;
          Map $drive => $share, \%options;
          $drive = Map $share, \%options;

     Map a drive letter or LTPx to a network resource. If successfull
     returns the drive letter/LPTx.

     If you do not specify the drive letter, the function uses the last
     free letter. Since the function doesn't require the ':' in the drive
     name you may use the function like this:

          Map H => '\\\\server\share';
          as well as
          Map 'H:' => '\\\\server\share';

          Options:
           persistent = 0/1, should the connection be restored on next logon?
           user       = username to be used to connect the device
           passwd     = password to be used to connect the device
           overwrite  = 0/1, should the drive be remapped if it was already connected?

          Example:
           Map I => '\\\\servername\share', {persistent=>1,overwrite=>1};

     REM: Based on Win32 API function WNetAddConnection3().

Disconnect
          Disconnect $drive_or_share;
          Disconnect $drive_or_share, \%options;

     Breaks an existing network connection. It can also be used to remove
     remembered network connections that are not currently connected.

     $drive_or_share specifies the name of either the redirected local
     device or the remote network resource to disconnect from. If this
     parameter specifies a redirected local resource, only the specified
     redirection is broken; otherwise, all connections to the remote
     network resource are broken.

          Options:
           persistent = 0/1, if you do not use persistent=>1, the connection will be closed, but
                        the drive letter will still be mapped to the device
           force      = 0/1, disconnect even if there are some open files

          See also: Unmap

     REM: Based on Win32 API function WNetCancelConnection2().

Unmap
          Unmap $drive_or_share;
          Unmap $drive_or_share, \%options;

     The only difference from Disconnect is that persistent=>1 is the
     default.

     REM: Based on Win32 API function WNetCancelConnection2().

Mapped
          %drives = Mapped;
          $share = Mapped $drive;
          $drive = Mapped $share; # currently not implemented !!!

     This function retrieves the name of the network resource associated
     with a local device.  Or vice versa.

     If you do not specify any parameter, you get a hash of drives and
     shares.

     To get the error message from most of these functions, you should not
     use $!, but Win32::FormatMessage(Win32::GetLastError())!

     REM: Based on Win32 API function WNetGetConnection().

Options
-------

FOF_
          FOF_SILENT = do not show the progress dialog
          FOF_RENAMEONCOLLISION = rename the file in case of collision
                     ('file.txt' -> 'Copy of file.txt')
          FOF_NOCONFIRMATION = do not show the confirmation dialog
          FOF_ALLOWUNDO = send file(s) to RecycleBin instead of deleting
          FOF_FILESONLY = skip directories
          FOF_SIMPLEPROGRESS = do not show the filenames in the process dialog
          FOF_NOCONFIRMMKDIR = do not confirm creating directories
          FOF_NOERRORUI = do not report errors
          FOF_NOCOPYSECURITYATTRIBS = do not copy security attributes

OFN_
          OFN_ALLOWMULTISELECT

     Specifies that the File Name list box allows multiple selections. If
     you also set the OFN_EXPLORER flag, the dialog box uses the
     Explorer-style user interface; otherwise, it uses the old-style user
     interface.

          OFN_CREATEPROMPT

     If the user specifies a file that does not exist, this flag causes the
     dialog box to prompt the user for permission to create the file. If
     the user chooses to create the file, the dialog box closes and the
     function returns the specified name; otherwise, the dialog box
     remains open.

          OFN_EXPLORER

     Since I cannot implement hook procedures through Win32::API (AFAIK),
     this option in not necessary.

          OFN_FILEMUSTEXIST

     Specifies that the user can type only names of existing files in the
     File Name entry field. If this flag is specified and the user enters
     an invalid name, the dialog box procedure displays a warning in a
     message box. If this flag is specified, the OFN_PATHMUSTEXIST flag is
     also used.

          OFN_HIDEREADONLY

     Hides the Read Only check box.

          OFN_LONGNAMES

     For old-style dialog boxes, this flag causes the dialog box to use
     long filenames. If this flag is not specified, or if the
     OFN_ALLOWMULTISELECT flag is also set, old-style dialog boxes use
     short filenames (8.3 format) for filenames with spaces.
     Explorer-style dialog boxes ignore this flag and always display long
     filenames.

          OFN_NOCHANGEDIR

     Restores the current directory to its original value if the user
     changed the directory while searching for files.

          OFN_NODEREFERENCELINKS

     Directs the dialog box to return the path and filename of the selected
     shortcut (.LNK) file. If this value is not given, the dialog box
     returns the path and filename of the file referenced by the shortcut

          OFN_NOLONGNAMES

     For old-style dialog boxes, this flag causes the dialog box to use
     short filenames (8.3 format). Explorer-style dialog boxes ignore this
     flag and always display long filenames.

          OFN_NONETWORKBUTTON

     Hides and disables the Network button.

          OFN_NOREADONLYRETURN

     Specifies that the returned file does not have the Read Only check box
     checked and is not in a write-protected directory.

          OFN_NOTESTFILECREATE

     Specifies that the file is not created before the dialog box is
     closed.  This flag should be specified if the application saves the
     file on a create-nonmodify network sharepoint. When an application
     specifies this flag, the library does not check for write protection,
     a full disk, an open drive door, or network protection. Applications
     using this flag must perform file operations carefully, because a
     file cannot be reopened once it is closed.

          OFN_NOVALIDATE

     Specifies that the dialog boxes allow invalid characters in the
     returned filename.

          OFN_OVERWRITEPROMPT

     Causes the Save As dialog box to generate a message box if the
     selected file already exists. The user must confirm whether to
     overwrite the file.

          OFN_PATHMUSTEXIST

     Specifies that the user can type only valid paths and filenames. If
     this flag is used and the user types an invalid path and filename in
     the File Name entry field, the dialog box function displays a warning
     in a message box.

          OFN_READONLY

     Causes the Read Only check box to be checked initially when the dialog
     box is created. If the check box is checked when the dialog box is
     closed $Win32::FileOp::ReadOnly is set to true.

          OFN_SHAREAWARE

     Specifies that if a call to the OpenFile function fails because of a
     network sharing violation, the error is ignored and the dialog box
     returns the selected filename.

          OFN_SHOWHELP

     Causes the dialog box to display the Help button. The hwndOwner member
     must specify the window to receive the HELPMSGSTRING registered
     messages that the dialog box sends when the user clicks the Help
     button.

BIF_
          BIF_DONTGOBELOWDOMAIN

     Does not include network folders below the domain level in the tree
     view control.

          BIF_RETURNONLYFSDIRS

     Only returns file system directories. If the user selects folders that
     are not part of the file system, the OK button is grayed.

          BIF_RETURNFSANCESTORS

     Only returns file system ancestors. If the user selects anything other
     than a file system ancestor, the OK button is grayed.

     This option is strange, cause it seems to allow you to select only
     computers.  I don't know the definition of a filesystem ancestor, but
     I didn't think it would be a computer. ?-|

          BIF_BROWSEFORCOMPUTER

     Only returns computers. If the user selects anything other than a
     computer, the OK button is grayed.

          BIF_BROWSEFORPRINTER

     Only returns printers. If the user selects anything other than a
     printer, the OK button is grayed.

          BIF_STATUSTEXT

     Since it is currently impossible to define callbacks, this options is
     useless.

CSIDL_
     This is a list of available options for BrowseForFolder().

     CSIDL_BITBUCKET

     Recycle bin -- file system directory containing file objects in the
     user's recycle bin. The location of this directory is not in the
     registry; it is marked with the hidden and system attributes to
     prevent the user from moving or deleting it.

     CSIDL_CONTROLS

     Control Panel -- virtual folder containing icons for the control panel
     applications.

     CSIDL_DESKTOP

     Windows desktop -- virtual folder at the root of the name space.

     CSIDL_DESKTOPDIRECTORY

     File system directory used to physically store file objects on the
     desktop (not to be confused with the desktop folder itself).

     CSIDL_DRIVES

     My Computer -- virtual folder containing everything on the local
     computer: storage devices, printers, and Control Panel. The folder may
     also contain mapped network drives.

     CSIDL_FONTS

     Virtual folder containing fonts.

     CSIDL_NETHOOD

     File system directory containing objects that appear in the network
     neighborhood.

     CSIDL_NETWORK

     Network Neighborhood -- virtual folder representing the top level of
     the network hierarchy.

     CSIDL_PERSONAL

     File system directory that serves as a common repository for
     documents.

     CSIDL_PRINTERS

     Printers folder -- virtual folder containing installed printers.

     CSIDL_PROGRAMS

     File system directory that contains the user's program groups (which
     are also file system directories).

     CSIDL_RECENT

     File system directory that contains the user's most recently used
     documents.

     CSIDL_SENDTO

     File system directory that contains Send To menu items.

     CSIDL_STARTMENU

     File system directory containing Start menu items.

     CSIDL_STARTUP

     File system directory that corresponds to the user's Startup program
     group.

     CSIDL_TEMPLATES

     File system directory that serves as a common repository for document
     templates.

     Not all options make sense in all functions!

Variables
---------

     $Win32::FileOp::ProgressTitle

   This variable (if defined) contains the text to be displayed on the
progress dialog if using FOF_SIMPLEPROGRESS. This allows you to present
the user with your own message about what is happening to his computer.

   If the options for the call do not contain FOF_SIMPLEPROGRESS, this
variable is ignored.

Examples
--------

     use Win32::FileOp;

     CopyConfirm ('c:\temp\kinter.pl' => 'c:\temp\copy\\',
                  ['\temp\kinter1.pl', 'temp\kinter2.pl']
                  => ['c:\temp\copy1.pl', 'c:\temp\copy2.pl']);

     $Win32::FileOp::ProgressTitle = "Moving the temporary files ...";
     MoveEx 'c:\temp\file.txt' => 'd:\temp\\',
            ['c:\temp\file1.txt','c:\temp\file2.txt'] => 'd:\temp',
            FOF_RENAMEONCOLLISION | FOF_SIMPLEPROGRESS;
     undef $Win32::FileOp::ProgressTitle;

     Recycle 'c:\temp\kinter.pl';

Handles
-------

   All the functions keep Win32::API handles between calls. If you want to
free the handles you may undefine them, but NEVER EVER set them to
anything else than undef !!!  Even  "$handlename = $handlename;" would
destroy the handle without repair!  See docs for Lazy.pm for explanation.

   List of handles and functions that use them:

     $Win32::FileOp::fileop : Copy, CopyEx, CopyConfirm, Move, MoveEx, MoveConfirm
      Delete, DeleteEx, DeleteConfirm, Recycle, RecycleEx, RecycleConfirm
     $Win32::FileOp::movefileex : MoveFileEx MoveFile MoveAtReboot
     $Win32::FileOp::movefileexDel : DeleteAtReboot
     $Win32::FileOp::copyfile : CopyFile
     $Win32::FileOp::writeINI : WriteToINI MoveAtReboot DeleteAtReboot
     $Win32::FileOp::writeWININI : WriteToWININI
     $Win32::FileOp::deleteINI : DeleteFromINI
     $Win32::FileOp::deleteWININI : DeleteFromWININI
     $Win32::FileOp::readINI : ReadINI
     $Win32::FileOp::readWININI : ReadWININI
     $Win32::FileOp::GetOpenFileName : OpenDialog
     $Win32::FileOp::GetSaveFileName : SaveAsDialog
     $Win32::FileOp::SHAddToRecentDocs : AddToRecentDocs EmptyRecentDocs
     $Win32::FileOp::DesktopHandle
     $Win32::FileOp::WindowHandle : OpenDialog SaveDialog
     $Win32::FileOp::WNetAddConnection3 : Map
     $Win32::FileOp::WNetGetConnection : Mapped
     $Win32::FileOp::WNetCancelConnection2 : Unmap Disconnect Map
     $Win32::FileOp::GetLogicalDrives : FreeDriveLetters Map

Notes
-----

   By default all functions are exported! If you do not want to polute your
namespace too much import only the functions you need.  You may import
either single functions or whole groups.

   The available groups are :

     BASIC = Move..., Copy..., Recycle... and Delete... functions plus constants
     _BASIC = FOF_... constants only
     HANDLES = DesktopHandle GetDesktopHandle WindowHandle GetWindowHandle
     INI = WriteToINI WriteToWININI ReadINI ReadWININI ReadINISectionKeys DeleteFromINI DeleteFromWININI
     DIALOGS = OpenDialog SaveAsDialog plus OFN_... constants
     _DIALOGS = only OFN_... constants
     RECENT = AddToRecentDocs, EmptyRecentDocs
     DIRECTORY = UpdateDir, FillInDir
     COMPRESS => Compress Uncompress Compressed SetCompression GetCompression
     MAP => Map Unmap Disconnect Mapped

   Examples:

     use Win32::FileOp qw(:BASIC GetDesktopHandle);
     use Win32::FileOp qw(:_BASIC MoveEx CopyEx);
     use Win32::FileOp qw(:INI :_DIALOGS SaveAsDialog);

   This module contains all methods from Win32::RecycleBin. The only change
you have to do is to use this module instead of the old Win32::RecycleBin.
Win32:RecycleBin is not supported anymore!

TO-DO
-----

   WNetConnectionDialog, WNetDisconnectDialog

AUTHORS
-------

     Module built by :
      Jan Krynicky <Jenda@Krynicky.cz>
      $Bill Luebkert <dbe@wgn.net>
      Mike Blazer <blazer@mail.nevalink.ru>
      Aldo Calpini <a.calpini@romagiubileo.it>
      Michael Yamada <myamada@gj.com>


