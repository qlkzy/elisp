This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Geo/TigerLine/Record/Z,  Next: Geo/Walkabout/Chain,  Prev: Geo/TigerLine/Record/S,  Up: Module List

TIGER/Line 1998 ZIP+4 Codes
***************************

NAME
====

   Geo::TigerLine::Record::Z - TIGER/Line 1998 ZIP+4 Codes

SYNOPSIS
========

     use Geo::TigerLine::Record::Z;

     @records = Geo::TigerLine::Record::Z->parse_file($fh);
     @records = Geo::TigerLine::Record::Z->parse_file($fh, \&callback);

     $record = Geo::TigerLine::Record::Z->new(\%fields);

     $record->rt();
     $record->version();
     $record->tlid();
     $record->rtsq();
     $record->zip4l();
     $record->zip4r();

DESCRIPTION
===========

   This is a class representing record type Z of the TIGER/Line 1998
census geographic database.  Each object is one record.  It also contains
methods to parse TIGER/Line record type Z files and turn them into objects.

   This is intended as an intermediate format between pulling the raw data
out of the simplistic TIGER/Line data files into something more
sophisticated (a process you should only have to do once).  As such, its
not very fast, but its careful, easy to use and performs some
verifications on the data being read.

   As this class is autogenerated by mk_parsers, think before you modify
this file.  Its OO, so consider sub-classing instead.

Accessors
---------

   These are simple get/set accessors for each field of a record generated
from the TIGER/Line 1998 data dictionary.  They perform some data
validation.

rt
          $data = $record->rt();
          $record->rt($data);

     Record Type.

     Expects alphanumeric data of no more than 1 characters.  $data cannot
     be blank and should be left justified.

version
          $data = $record->version();
          $record->version($data);

     Version Number.

     Expects numeric data of no more than 4 characters.  $data cannot be
     blank and should be left justified.

tlid
          $data = $record->tlid();
          $record->tlid($data);

     TIGER/Line ID, Permanent Record Number.

     Expects numeric data of no more than 10 characters.  $data cannot be
     blank and should be right justified.

rtsq
          $data = $record->rtsq();
          $record->rtsq($data);

     Record Sequence Number.

     Expects numeric data of no more than 3 characters.  $data cannot be
     blank and should be right justified.

zip4l
          $data = $record->zip4l();
          $record->zip4l($data);

     +4 Postal Add-On Code, Left.

     Expects numeric data of no more than 4 characters.  $data can be blank
     and should be left justified.

zip4r
          $data = $record->zip4r();
          $record->zip4r($data);

     +4 Postal Add-On Code, Right.

     Expects numeric data of no more than 4 characters.  $data can be blank
     and should be left justified.

Data dictionary
---------------

   This is the original TIGER/Line 1998 data dictionary from which this
class was generated.

     Record Type Z - ZIP+4 Codes
     
          Field   BV  Fmt  Type  Beg  End  Len  Description
             RT   No    L     A    1    1    1  Record Type
        VERSION   No    L     N    2    5    4  Version Number
           TLID   No    R     N    6   15   10  TIGER/Line ID, Permanent Record Number
           RTSQ   No    R     N   16   18    3  Record Sequence Number
          ZIP4L  Yes    L     N   19   22    4  +4 Postal Add-On Code, Left
          ZIP4R  Yes    L     N   23   26    4  +4 Postal Add-On Code, Right

AUTHOR
======

   Michael G Schwern <schwern@pobox.com>

SEE ALSO
========

   *Note Geo/TigerLine: Geo/TigerLine,, `mk_parsers' in this node


File: pm.info,  Node: Geo/Walkabout/Chain,  Next: Geo/Walkabout/Line,  Prev: Geo/TigerLine/Record/Z,  Up: Module List

An open path representing the shape of a line feature.
******************************************************

NAME
====

   Geo::Walkabout::Chain - An open path representing the shape of a line
feature.

SYNOPSIS
========

     require Geo::Walkabout::Chain;

     my $chain = Geo::Walkabout::Chain->new([1,1],[5,10.2],[12,13]);
     my $chain = Geo::Walkabout::Chain->new_from_pgpath('[(1,1),(5,10.2),(12,13)]');

     my $begin = $chain->begin;
     my $end   = $chain->end;
     my @shape = $chain->shape;
     my @raw_chain = $chain->chain;
     my $pg_path = $chain->as_pgpath;

     $chain->append_shape(@points);

DESCRIPTION
===========

   This is a representation of a complete chain.  Typically, it should not
be used directly, instead Geo::Walkabout::Line encapsulates a single
Geo::Walkabout::Chain.

   A single point in a chain is represented as a two element array
representing a single point of latitude and longitutde.  (OO dogma says
these should be objects, too, but if I wanted to be that silly I'd be
using Java.)

Public Methods
==============

Constructors
------------

new
          my $chain = Geo::Walkabout::Chain->new([$lat1, $long1],
                                                 [$lat2, $long2],
                                                 ...
                                                );

     Creates a new Geo::Walkabout::Chain object from a list of points (two
     element array references).  The first point is the start of the chain,
     the last is the end (or vice-versa depending on which way you look.)
     The rest are "shape" coordinates.

new_from_pgpath
          my $chain = Geo::Walkabout::Chain->new_from_pgpath($postgres_path);

     An alternative constructor, it takes a PostgreSQL style open PATH of
     the form:

          [ ( lat1, long1 ), ... , (latn, longn) ]

     So something like '[(1,1), (-1,2.2), (-2,3)]'.  This is very helpful
     when reading in chains from a PostgreSQL database.

Accessors
---------

begin
          my $beginning_point = $chain->begin;

     Returns the beginning point of this chain as a two element array
     reference.

end
          my $end_point = $chain->end;

     Returns the end point of this chain as a two element array reference.

shape
          my @shape = $chain->shape;

     Returns the shaping points of this chain, ie. those points between the
     start and the end which determine the shape of the chain (without
     them, its just a line segment).

chain
          my @raw_chain = $chain->chain;

     Dumps the chain this object represents as a series of points.  This is
     equivalent to:

          my @raw_chain = ($chain->begin, $chain->shape, $chain->end);

as_pgpath
          my $pg_path = $chain->as_pgpath;

     Returns a representation of the chain as a PostgreSQL open path
     suitable for insertion into the database.

to_pgpoint
          my $pg_point = $chain->to_pgpoint(\@point);

     Translates a two element array reference into a PostgreSQL point.

Modifiers
---------

append_shape
          $chain->append_shape(@points);

     Adds new shaping points to the chain.  They are appended to the end of
     the shape.

Private Methods
---------------

   *PRIVATE!* I document them here because I'm forgetful.  Use of these
may result in *DIRE CONSEQUENCES!* (consequences may contain one or more
of the following: pain, death, dismemberment, yellow dye #5)

_split_pg_path
          my @path = Geo::Walkabout::Chain->_split_pg_path($pg_path);

     Converts a PostgreSQL open PATH into an array of points.

AUTHOR
======

   Michael G Schwern <schwern@pobox.com>

SEE ALSO
========

   *Geo::Walkabout*, *Geo::Walkabout::Line*, *Geo::TigerLine*


File: pm.info,  Node: Geo/Walkabout/Line,  Next: Geo/Walkabout/Utils,  Prev: Geo/Walkabout/Chain,  Up: Module List

A "line feature"
****************

NAME
====

   Geo::Walkabout::Line - A "line feature"

SYNOPSIS
========

     require Geo::Walkabout::Line;

     my $line = Geo::Walkabout::Line->retrieve($tlid);
     my $line = Geo::Walkabout::Line->new(\%data);

     $line->delete;

     my $id   = $line->id;
     my $name = $line->name;

     my($zip_left, $zip_right) = $line->zip;

     my @address_ranges = $line->addresses_left;
     my @address_ranges = $line->addresses_right;
     $line->add_addresses($side, @address_ranges);

     my $chain = $line->chain;

     $line->TLID;

     $line->FeDirP;
     $line->FeName;
     $line->FeType;
     $line->FeDirS;

     $line->ZipL;
     $line->Zip4L;
     $line->ZipR;
     $line->Zip4R;

     $line->commit;
     $line->rollback;

DESCRIPTION
===========

   This represents a complete "line feature".  Roads, waterways, fences,
power lines, railroads, boundries...  See chapter 3 of the TIGER/Line
documentation for details.

Public Methods
==============

Constructors and Destructors
----------------------------

   Geo::Walkabout::Line is a subclass of Class::DBI and expects to be
stored in a database.

retrieve
          my $line = Geo::Walkabout::Line->retrieve($id);

     Retrieve an existing line feature from the database by its ID.

new
          my $line = Geo::Walkabout::Line->new(\%data);

     Create a new line feature.  %data must contain the following fields...

          TLID        Unique TIGER/Line ID
          Chain       A Geo::Walkabout::Chain object representing the line

     And optionally contain these...

          FeDirP      See accessor descriptions below
          FeName      for what these are
          FeType
          FeDirS

          ZipL
          Zip4L
          ZipR
          Zip4R

delete
          $line->delete;

     Deletes this line feature from the database *permanently*.

Accessors
---------

id
          my $id = $line->id

     Returns a unique ID for this object, not necessarily the same as TLID.

     NOTE Do *NOT*, I repeat, do *NOT* use attempt to use the TLID as a
     unique identifer for a Geo::Walkabout::Line object.  While the TLID is
     unique, it is not guaranteed that all Geo::Walkabout::Line objects
     will have one.  Geo::Walkabout::Line objects will come from many
     sources.

TLID
          my $tlid = $line->TLID;

     Returns the TIGER/Line ID for this object.

name
          my $name = $line->name;

     The complete name of this feature.  Its roughly equivalent to:

          my $name = join ' ', $line->FeDirP, $line->FeName, $line->FeType,
                               $line->FeDirS;

     For example:  "Elford PL"

zip
          my($zip_left, $zip_right) = $line->zip;

     The zip code for the left and right side of this line.  Zip may be the
     5 digit zip code or the 9 digit zip +4.

addresses_left
addresses_right
          my @address_ranges = $line->addresses_left;
          my @address_ranges = $line->addresses_right;

     The possible addresses on the left side of this line.  @address_ranges
     is a list of range pairs (two element array refs).  A range with the
     same start and end number (such as [146,146]) represents a single
     anomalous address.

     The order is meaningless.

     For example:

          # Represents that the addresses descend from 290 to 200 from the
          # start of the line to the end.  There is also a single outstanding
          # address #146 and an additional range of addresses from 20 to 10.
          # So 10-20, 146 and 200-290.
          ([290,200],[146,146],[20,10])

add_addresses
          $line->add_addresses($side, @address_ranges);

     Addes a new address range to this line on the given $side.  $side is
     either 'R' or 'L'.  @address_range is a list of two element array
     references representing possible addresses on that side of the street.
     The ordering is from the start of the chain to the end.

chain
          my $chain = $line->chain;
          $line->chain($chain);

     The Geo::Walkabout::Chain object representing the shape of this line
     feature.  This is the important bit, the line's actual location in the
     world.  *Note Geo/Walkabout/Chain: Geo/Walkabout/Chain, for details.

FeDirP
          my $fedirp = $line->FeDirP;
          $line->FeDirP($fedirp);

     Feature Direction Prefix.  For example, if you had "North Southington
     Road", "N" would be the FeDirP.

     Possible values are "N", "NE", "NW", "S", "SE", "SW", "E", "W", "EX".
     "EX" means "Extended" or "Extension".

FeName
          my $fename = $line->FeName;
          $line->FeName($fename);

     Feature Name.  Continuing the example, "Southington" is the FeName.

FeType
          my $fetype = $line->FeType;
          $line->FeType($fetype);

     Feature Type.  "Rd" would be the feature type from above.  Standard
     abbreviations can be found in Appendix D of the TIGER/Line
     documentation.

FeDirS
          my $fedirs = $line->FeDirS;
          $line->FeDirS($fedirs);

     Feature Type Suffix.  Same as FeDirP, except it follows the feature
     name.  So for "Red Rock West", the FeDirS would be "W".

ZipL
ZipR
          my $zipl = $line->ZipL;
          $line->ZipL($zipl);
          my $zipr = $line->ZipR;
          $line->ZipR($zipr);

     5 digit zip codes for the left and right side of this line.

Zip4L

Zip4R
          my $zip4l = $line->Zip4L;
          $line->Zip4L($zip4l);
          my $zip4r = $line->Zip4R;
          $line->Zip4R($zip4r);

     4 digit +4 zip code extension for the left and right side of this
     line.

Other Methods
-------------

commit
          $line->commit;

     Commit changes made to this line to the database.

rollback
          $line->rollback;

     Throw away changes made to this line and refresh it from the database.
     If an object is changed and destroyed without committing or rolling
     back a warning will be thrown.

AUTHOR
======

   Michael G Schwern <schwern@pobox.com>

SEE ALSO
========

   `Geo::Walkabout' in this node, *Note Geo/TigerLine: Geo/TigerLine,,
*Note Geo/Walkabout/Chain: Geo/Walkabout/Chain,


File: pm.info,  Node: Geo/Walkabout/Utils,  Next: Geo/Weather,  Prev: Geo/Walkabout/Line,  Up: Module List

Utility functions for Geo::Walkabout.
*************************************

NAME
====

   Geo::Walkabout::Utils - Utility functions for Geo::Walkabout.

DESCRIPTION
===========

   These are functions I'm playing around with.  Most likely they will be
broken up into other libraries and reworked, so don't be surprised if all
this changes.

Functions
---------

find_address
          my $line = find_address({fedirp       => $dirp,
                                   fename       => $name,
                                   fetype       => $type,
                                   fedirs       => $dirs,

          addr_num     => $num,
          zip          => $zip,
                                    });

     Finds a line feature from its name and zip.  (Eventually city and
     state instead of zip).

     NOTE fedirs and fedirp are currently ignored.

in_range
          my @lines = in_range([$long, $lat], $range);

     Returns all line features in a circular $range of the given point
     ($long, $lat).

get_line_feature
          my @feature = get_line_feature({
                                          fedirp => $fedirp,
                                          fename => $fename,
                                          fetype => $fetype,
                                          fedirs => $fedirs,

          zip    => $zip,
                                           });

     Returns all connected line features of the feature which passes
     through the given zip code.

     NOTE I don't think this quite gets the entire road.

     NOTE zip, fedirp and fedirs are currently ignored.

get_zip
          my @lines = get_zip($zip);

     Get all lines in a given zip code.

bounding_box
          my $box = bounding_box_zip($zip);

     Returns the two point box bounding this zip code.  $box->[0]
     upper-right, $box->[1] is lower-left.

find_intersection
          @lines = find_intersection({fename => $fe_name,
                                      fetype => $fe_type,
                                     },
                                     {fename => $fe_name,
                                      fetype => $fe_type,
                                     },
                                     $zip
                                    );

     Finds the given cross-street, returning all lines which share in this
     intersection.

AUTHOR
======

   Michael G Schwern <schwern@pobox.com>


File: pm.info,  Node: Geo/Weather,  Next: Geo/WeatherNOAA,  Prev: Geo/Walkabout/Utils,  Up: Module List

Weather retrieval module
************************

NAME
====

   Geo::Weather - Weather retrieval module

SYNOPSIS
========

     use Geo::Weather;

     my $weather = new Geo::Weather;

     $weather->get_weather('Folsom','CA');

     print $weather->report();

     -or-

     use Geo::Weather;

     my $weather = new Geo::Weather;
     
     my $current = $weather->get_weather('95630');

     print "The current temperature is $current->{temp} degrees\n";

DESCRIPTION
===========

   The *Geo::Weather* module retrieves the current weather from
weather.com when given city and state or a US zip code

FUNCTIONS
=========

   * new

     Create and return a new object.

   * *get_weather*

     Gets the current weather from weather.com

     Arguments

          city - US city or zip code
          state - US state, not needed if using zip code

     *Sample Code*

          my $current = $weather->get_weather('Folsom','CA');
          if (!ref $current) {
          	die "Unable to get weather information\n";
          }

     *Returns*

          On sucess, get_weather returns a hashref  containing the following keys

          city		- City
          state		- State
          pic		- weather.com URL to the current weather image
          cond		- Current condition
          temp		- Current temperature (degees F)
          wind		- Current wind speed
          dewp		- Current dew point (degrees F)
          humi		- Current rel. humidity
          visb		- Current visibility
          baro		- Current barometric pressure
          heat		- Current heat index

          On error, it returns the following exported error variables

     Errors

          $ERROR_QUERY		- Invalid data supplied
          $ERROR_PAGE_INVALID	- No URL, or incorrectly formatted URL for retrieving the information
          $ERROR_CONNECT		- Error connecting to weather.com
          $ERROR_NOT_FOUND	- Weather for the specified city/state or zip could not be found

   * report

     Returns an HTML table containing the current weather. Must call
     get_weather first.

     *Sample Code*

          print $weather->report();

   * lookup

     Gets current weather given a full weather.com URL

     *Sample Code*

          my $current = $weather->lookup('http://www.weather.com/weather/cities/us_ca_folsom.html');

     *Returns*

          On sucess, lookup returns a hashref with the same keys as the get_weather function

          On error, lookup returns the same errors defined for get_weather

AUTHOR
======

     Geo::Weather was wrtten by Mike Machado I<Less_Than_Special_Sequencemike@innercite.comGreater_Than_Special_Sequence> with the main weather.com retrieval code from I<Less_Than_Special_Sequencehawk@redtailedhawk.netGreater_Than_Special_Sequence>


File: pm.info,  Node: Geo/WeatherNOAA,  Next: Geography/Countries,  Prev: Geo/Weather,  Up: Module List

Perl extension for interpreting the NOAA weather data
*****************************************************

NAME
====

   Geo::WeatherNOAA - Perl extension for interpreting the NOAA weather data

SYNOPSIS
========

     use Geo::WeatherNOAA;
     ($date,$warnings,$forecast,$coverage) =
        process_city_zone('newport','ri','','get');

     foreach $key (keys %$forecast) {
     	print "$key: $forecast->{$key}\n";
     }
     
     print process_city_hourly('newport news', 'va', '', 'get');

   or

     use Geo::WeatherNOAA;
     print print_forecast('newport news','va');

DESCRIPTION
===========

   This module is intended to interpret the NOAA zone forecasts and current
city hourly data files.  It should give a programmer an easy time to use
the data instead of having to mine it.

   Be aware that if the variable $main::opt_v is set to anything (other
than zero or ") then Geo::WeatherNOAA will be verbose  on what it's doing
with messages sent to STDERR.  Useful for debugging.

REQUIRES
========

   * Tie::IxHash

   * LWP::Simple

   * LWP::UserAgent

   * Text::Wrap

FUNCTIONS
=========

   * print_forecast(CITY,STATE,FILENAME,FILEOPT,LWP_UserAgent)

     Returns text of the forecast

   * print_current(CITY,STATE,FILENAME,FILEOPT,LWP_UserAgent)

     Returns text of current weather

   * make_noaa_table(CITY,STATE,FILENAME,FILEOPT,LWP_UserAgent, MaxItems)

     This call gives the basic html table with current data and forecast
     for the next four periods ("tonight", "tomorrow","tomorrow
     night","day after") and warnings in an (I think) attractive, easy to
     read way.

     Max Items is a way to limit the number of items in the table
     returned...  I think it looks best with no more than 4...5 gets
     crowded looking.

   * process_city_hourly(CITY,STATE,FILENAME,FILEOPT,LWP_UserAgent)

     FILENAME is the file read from with FILEOPT "usefile" and written to
     if FILEOPT is "save"

     FILEOPT can be one of the following

          - save
          	will get and save the data to FILENAME
          - get
          	will retrieve new data (not store it)
          - usefile
          	will not retrieve data from URL,
          	use FILENAME for data

     The fifth argument is for a user created LWP::UserAgent(3) which can
     be configured to work with firewalls. See the LWP::UserAgent(3)
     manpage for specific instructions. A basic example is like this:

          my $ua = new LWP::UserAgent;
          $ua->proxy(['http', 'ftp'], 'http://proxy.my.net:8080/');

     If you merely wish to set your proxy data from environment variables
     (as in $ua-env_proxy>), simply set

          $Geo::WeatherNOAA::proxy_from_env = 1;

   * process_city_zone(CITY,STATE,FILENAME,FILEOPT,LWP_UserAgent)

     Call CITY, STATE, FILENAME (explained above), FILEOPT(explained
     above), and UserAgent (Explained above).

     The return is a three element list containing a) a string of the
     date/time of the forecast, b) a reference to the list of warnings (if
     any), and c) a reference to the hash of forecast.  I recommend
     calling it like this:

          ($date, $warnings, $forecast, $coverage) =
              process_city_zone('newport news','va',
          	'/tmp/va_zone.html', 'save');

     Explanation of this call, it returns:

          $date
          - Scalar of the date of the forecast

          $warnings
          - Reference to the warnings list
          - EXAMPLE:
            foreach (@$warnings) { print; }
          
          $forecast
          - Reference to the forecast KEY, VALUE pairs
          - EXAMPLE:
            foreach $key (keys %$forecast) {
            	print "$key: $forecast->{$key}\n";
            }

          $coverage
          - Scalar of the coverage area of the forecast

   * get_city_zone(CITY,STATE,FILENAME,FILEOPT,LWP_UserAgent)

     This sub is to get the block of data from the data source, which is
     chosen with the FILEOPTswitch.

   * get_city_hourly(CITY,STATE,FILENAME,FILEOPT,LWP_UserAgent)

     This function gets the current weather from the data source, which is
     decided from FILEOPT(explained above).  Input is CITY, STATE,
     FILENAME (filename to read/write from if FILEOPTis "get" or
     "usefile"), and UserAgent.

     This function returns a reference to a hash containing the data. It

     Same FILEOPTand LWP_UserAgent from above, and process the current
     weather data into an english sentence.

AUTHOR
======

   Mark Solomon

   msolomon@seva.net

   http://www.seva.net/~msolomon/

SEE ALSO
========

   perl(1), Tie::IxHash(3), LWP::Simple(3), LWP::UserAgent(3).


File: pm.info,  Node: Geography/Countries,  Next: Geography/States,  Prev: Geo/WeatherNOAA,  Up: Module List

2-letter, 3-letter, and numerical codes for countries.
******************************************************

NAME
====

   Geography::Countries - 2-letter, 3-letter, and numerical codes for
countries.

SYNOPSIS
========

     use Geography::Countries;

     $country = country 'DE';  # 'Germany'
     @list    = country  666;  # ('PM', 'SPM', 666,
                               #  'Saint Pierre and Miquelon', 1)

DESCRIPTION
===========

   This module maps country names, and their 2-letter, 3-letter and
numerical codes, as defined by the ISO-3166 maintenance agency [1], and
defined by the UNSD.

The country subroutine.
-----------------------

   This subroutine is exported by default. It takes a 2-letter, 3-letter or
numerical code, or a country name as argument. In scalar context, it will
return the country name, in list context, it will return a list consisting
of the 2-letter code, the 3-letter code, the numerical code, the country
name, and a flag, which is explained below. Note that not all countries
have all 3 codes; if a code is unknown, the undefined value is returned.

   There are 3 categories of countries. The largest category are the
current countries. Then there is a small set of countries that no longer
exist. The final set consists of areas consisting of multiple countries,
like Africa. No 2-letter or 3-letter codes are available for the second
two sets. (ISO 3166-3 [3] defines 4 letter codes for the set of countries
that no longer exist, but the author of this module was unable to get her
hands on that standard.) By default, country only returns countries from
the first set, but this can be changed by giving country an optional
second argument.

   The module optionally exports the constants `CNT_F_REGULAR',
`CNT_F_OLD', `CNT_F_REGION' and `CNT_F_ANY'. These constants can also be
important all at once by using the tag `:FLAGS'. `CNT_F_ANY' is just the
binary or of the three other flags. The second argument of country should
be the binary or of a subset of the flags `CNT_F_REGULAR', `CNT_F_OLD',
and `CNT_F_REGION' - if no, or a false, second argument is given,
`CNT_F_REGULAR' is assumed. If `CNT_F_REGULAR' is set, regular (current)
countries will be returned; if `CNT_F_OLD' is set, old, no longer
existing, countries will be returned, while `CNT_F_REGION' is used in case
a region (not necessarely) a country might be returned.  If country is
used in list context, the fifth returned element is one of
`CNT_F_REGULAR', `CNT_F_OLD' and `CNT_F_REGION', indicating whether the
result is a regular country, an old country, or a region.

   In list context, country returns a 5 element list. To avoid having to
remember which element is in which index, the constants `CNT_I_CODE2',
`CNT_I_CODE3', `CNT_I_NUMCODE', `CNT_I_COUNTRY' and `CNT_I_FLAG' can be
imported. Those constants contain the indices of the 2-letter code, the
3-letter code, the numerical code, the country, and the flag explained
above, respectively. All index constants can be imported by using the
`:INDICES' tag.

The `code2', `code3', `numcode' and `countries' routines.
---------------------------------------------------------

   All known 2-letter codes, 3-letter codes, numerical codes and country
names can be returned by the routines `code2', `code3', `numcode' and
`countries'. None of these methods is exported by default; all need to be
imported if one wants to use them. The tag `:LISTS' imports them all. In
scalar context, the number of known codes or countries is returned.

REFERENCES
==========

   The 2-letter codes come from the ISO 3166-1:1997 standard [2]. ISO 3166
bases its list of country names on the list of names published by the
United Nations. This list is published by the Statistical Division of the
United Nations [4]. The UNSD uses 3-letter codes, and numerical codes [5].
The information about old countries [6] and regions [7] also comes from
the United Nations.

   In a few cases, there was a conflict between the way how the United
Nations spelled a name, and how ISO 3166 spells it. In most cases, is was
word order (for instance whether *The republic of* should preceed the
name, or come after the name. A few cases had minor spelling variations.
In all such cases, the method in which the UN spelled the name was
choosen; ISO 3166 claims to take the names from the UN, so we consider the
UN authoritative.

[1]
     ISO Maintenance Agency (ISO 3166/MA)
     *http://www.din.de/gremien/nas/nabd/iso3166ma/index.html*.

[2]
     *Country codes*,
     *http://www.din.de/gremien/nas/nabd/iso3166ma/codlstp1.html*, 7
     September 1999.

[3]
     ISO 3166-3, *Code for formerly used country names*.
     *http://www.din.de/gremien/nas/nabd/iso3166ma/info_pt3.html*.

[4]
     United Nations, Statistics Division.
     *http://www.un.org/Depts/unsd/statdiv.htm*.

[5]
     *Country or area codes in alphabetical order*.
     *http://www.un.org/Depts/unsd/methods/m49alpha.htm*, 26 August 1999.

[6]
     *Codes added or changed*.
     *http://www.un.org/Depts/unsd/methods/m49chang.htm*, 26 August 1999.

[7]
     *Geographical regions*.
     *http://www.un.org/Depts/unsd/methods/m49regin.htm*, 26 August 1999.

BUGS
====

   Looking up information using country names is far from perfect.  Except
for case and the amount of white space, the exact name as it appears on
the list has to be given. USA will not return anything, but *United
States* will.

HISTORY
=======

     $Log: Countries.pm,v $
     Revision 1.2  2000/09/05 18:22:01  abigail
     Changed typo in "Federal Republic of Germany" (Dan Allen)
     Changed layout of test.pl

     Revision 1.1  1999/09/15 07:27:22  abigail
     Initial revision

AUTHOR
======

   This package was written by Abigail, *abigail@delanet.com*.

COPYRIGHT AND LICENSE
=====================

   This package is copyright 1999 by Abigail.

   This program is free and open software. You may use, copy, modify,
distribute and sell this program (and any modified variants) in any way
you wish, provided you do not restrict others to do the same.


File: pm.info,  Node: Geography/States,  Next: Geography/USStates,  Prev: Geography/Countries,  Up: Module List

Map states and provinces to their codes, and vica versa.
********************************************************

NAME
====

   Geography::States  -  Map states and provinces to their codes, and vica
versa.

SYNOPSIS
========

     use Geography::States;

     my $obj = Geography::States -> new (COUNTRY [, STRICT]);

EXAMPLES
========

     my $canada = Geography::States -> new ('Canada');

     my  $name          =  $canada -> state 'NF';      # Newfoundland.
     my  $code          =  $canada -> state 'Ontario'; # ON.
     my ($code, $name)  =  $canada -> state 'BC';      # BC, British Columbia.
     my  @all_states    =  $canada -> state;           # List of code/name pairs.

DESCRIPTION
===========

   This module lets you map states and provinces to their codes, and codes
to names of provinces and states.

   The `Geography::States -' new ()> call takes 1 or 2 arguments. The
first, required, argument is the country we are interested in. Current
supported countries are USA, *Brazil*, *Canada*, and *The Netherlands*. If
a second non-false argument is given, we use *strict mode*. In non-strict
mode, we will map territories and alternative codes as well, while we do
not do that in strict mode. For example, if the country is USA, in
non-strict mode, we will map *GU* to *Guam*, while in strict mode, neither
*GU* and *Guam* will be found.

The state() method
------------------

   All queries are done by calling the state method in the object. This
method takes an optional argument. If an argument is given, then in scalar
context, it will return the name of the state if a code of a state is
given, and the code of a state, if the argument of the method is a name of
a state. In list context, both the code and the state will be returned.

   If no argument is given, then the state method in list context will
return a list of all code/name pairs for that country. In scalar context,
it will return the number of code/name pairs. Each code/name pair is a 2
element anonymous array.

   Arguments can be given in a case insensitive way; if a name consists of
multiple parts, the number of spaces does not matter, as long as there is
some whitespace. (That is "NewYork" is wrong, but "new    YORK" is fine.)

ODDITIES AND OPEN QUESTIONS
===========================

   I found conflicting abbreviations for the US *Northern Mariana Islands*,
listed as *NI* and *MP*. I picked *MP* from the USPS site.

   One site listed *Midway Islands* as having code *MD*. It is not listed
by the USPS site, and because it conflicts with *Maryland*, it is not put
in this listing.

   The USPS also has so-called *Military "States"*, with non-unique codes.
Those are not listed here.

   Canada's *Quebec* has two codes, the older *PQ* and the modern *QC*.
Both *PQ* and *QC* will map to *Quebec*, but *Quebec* will only map to
*QC*.  With strict mode, *PQ* will not be listed.

REVISION HISTORY
================

     $Log: States.pm,v $
     Revision 1.3  2000/07/23 09:28:31  abigail
     Fixed dependency on hash ordering when mapping "Quebec" (it worked
        in perl5.005, but failed in perl5.6).
     Fixed typos in state names (Ross Baker).
     Changed email address.
     Changed license to from free prose to X-style license.

     Revision 1.2  1999/09/10 17:12:05  abigail
     Added a 'require 5.005' due to the use of INIT.

     Revision 1.1  1999/09/09 07:33:54  abigail
     Initial revision

AUTHOR
======

   This package was written by Abigail, abigail@foad.org.

COPYRIGHT and LICENSE
=====================

   This package is copyright 1999, 2000 by Abigail.

   Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: pm.info,  Node: Geography/USStates,  Next: Getargs/Long,  Prev: Geography/States,  Up: Module List

USA State Data
**************

NAME
====

   Geography::USStates - USA State Data

SYNOPSIS
========

   use Geography::USStates; # - just getState* functions use
Geography::USStates qw(:areas); # - just getArea* functions use
Geography::USStates qw(:both);  # - just getState*Area* functions use
Geography::USStates qw(:both);  # - all functions

   # ----- US STATES BASED $state = getState('mn');        # - get the
statename 'Minnesota'

   $state = getState('wisconsin'); # - get the abbreviation 'wi'

   @states = getStateNames();      # - return all state names

   @states = getStateAbbrevs();    # - return all state abbrevations (AL,
AK, ..)

   %s = getStates();               # - return hash $states{'MN'} =
'Minnesota'

   %s = getStates(case=>'upper');  # - return hash $states{'MN'} =
'MINNESOTA'

   %s = getStates(case=>'lower');  # - return hash $states{'MN'} =
'minnesota'

   %s = getStates(hashkey=>'name');# - return hash $states{'Minnesota'} =
'MN'

   # ----- US AREAS $area = getArea('gu');          # - get the area name
'Guam'

   $area = getArea('guam');        # - get the abbreviation 'gu'

   @areas = getAreaNames();        # - return all area names

   @areas = getAreaAbbrevs();      # - return all area abbrevations (DC,
GU, ..)

   %a = getAreas();                # - return hash $states{'GU'} = 'Guam'

   %a = getAreas(case=>'upper');   # - return hash $states{'GU'} = 'GUAM'

   %a = getAreas(case=>'lower');   # - return hash $states{'GU'} = 'guam'

   %a = getAreas(hashkey=>'name'); # - return hash $states{'Guam'} = 'GU'

   # ----- Lookup both US States and Dependant areas # - get the statename
'Minnesota' or 'Guam' respectivily $state = getStateOrArea('mn' || 'gu');

   # - get the abbreviation 'wi' or 'gu' respectivily $state =
getStateOrArea('wisconsin' || 'guam');

   # - return all states and areas names together  @states =
getStatesAndAreasNames();

   # - return all states and areas abbreviations together  @states =
getStatesAndAreasAbbrevs();

   # - same as getStates() but it returns the areas in the hash too %s =
getStatesAndAreas(); %s = getStatesAndAreas(case=>'upper'); %s =
getStatesAndAreas(case=>'lower'); %s = getStatesAndAreas(hashkey=>'name');

DESCRIPTION
===========

   This module allows you to get information on US State names, their
abbreviations, and couple the two together (in hashes). As well as states,
the US has "Dependant Area's" like Guam, and the Virgin Islands. Sometimes
you want to offer these areas in your application so you can get access to
those via the getArea*() functions and the getState*Area*() functions.

FUNCTIONS
=========

   o *getState*($statename || $stateabbrev)

     Given an abbreviation a statename is returned.
     Given a name an abbreviatin is returned

     e.g. print getState('MN');
          would print 'Minnesota'

     print getState('wisconsin');
     would print 'WI'

     o B<getStateNames>()

     Return all of the states in an array

     e.g. map { print "$_\n" } getStateNames();
          would print "Alabama\nAlaska\n...";
     
       o B<getStateAbbrevs>()
     
     Return all of the abbrevs in an array
     
     e.g. map { print "$_\n" } getStateAbbrevs();
          would print "AL\nAK\n...";
     
       o B<getStates>(%hash | $hashref) [keys: case => upper||lower, hashkey=>name]
     
     A hash is returned with both abbrev and statename. By default it returns
     the state abbrev as the key and the state name as the value
     
     e.g. $hash{MN} = 'Minnesota';
     
     You can also pass params in a hash or hashref. To force the state names
     to be lower case, or upper case you do:
     
     getStates(case => 'upper'); # -- for upper case... lower for lower case
     
     If you want to return a hash where the name is the key you do:
     
     my %s = getStates(hashkey => 'name');
     and then
     $s{'Minnesota'} = 'MN';
     
       =head1 AUTHOR
     
       Dion Almaer (dion@almaer.com)
     
     =cut


File: pm.info,  Node: Getargs/Long,  Next: Getopt/ArgvFile,  Prev: Geography/USStates,  Up: Module List

parse routine arguments
***********************

NAME
====

   Getargs::Long - parse routine arguments

SYNOPSIS
========

     use Getargs::Long;                     # case sensitive
     use Getargs::Long qw(ignorecase);      # case insensitive

     # Simple, args mandatory
     my ($val, $other) = getargs(\@_, qw(val other));

     # Simple, args optional (in [] means optional)
     my ($val, $other) = getargs(\@_, [qw(val other)]);

     # Simple with typechecking, args mandatory
     my ($val, $other) = getargs(\@_, qw(val=Class::X other=ARRAY));

     # Simple with typechecking, args optional
     my ($val, $other) = getargs(\@_, [qw(val=Class::X other=ARRAY)]);

     # Faster version, building dedicated argument parsing routine
     my ($val, $other) = cgetargs(\@_, qw(val other));

     # Other cases, use full specs:
     my ($x, $y, $z, $a, $b, $c) = xgetargs(\@_,

     # Non-mandatory, defaults to undef unless specified otherwise
     'x'     => ['i'],                   # integer, no default
     'y'     => ['ARRAY', ['a', 'b']],   # Has a default
     'z'     => [],                      # No typecheck, can be anything

     # Mandatory arguments
     'a'     => 'i',                     # integer (scalar)
     'b'     => 'TYPE',                  # TYPE or any heir of TYPE
     'c'     => undef,                   # unspecified type but mandatory
      );

     # Extract remaining unparsed args in @extra
     my ($val, $other, @extra) = getargs(\@_, { -strict => 0 }, qw(val other));

     # Alter behaviour of the getargs() routines via switches in hashref
     my ($val, $other) = getargs(\@_,
        {
            -strict         => 1,       # unknown switches are fatal
            -ignorecase     => 1,       # override package's global
            -inplace        => 1,       # edit @_ inplace: remove parsed args
            -extra          => 0,       # suppress return of extra arguments
        },
        qw(val other)
     );

DESCRIPTION
===========

   The `Getargs::Long' module allows usage of named parameters in function
calls, along with optional argument type-checking.  It provides an easy
way to get at the parameters within the routine, and yields concise
descriptions for the common cases of all-mandatory and all-optional
parameter lists.

   The validation of arguments can be done by a structure-driven routine
getargs() which is fine for infrequently called routines (but should be
slower), or via a dedicated routine created and compiled on the fly the
fist time it is needed, by using the cgetargs() family (expected to be
faster).

   The `Log::Agent' module is used to report errors, which leaves to the
application the choice of the final logging method: to a file, to STDERR,
or to syslog.

EXAMPLE
=======

   Before going through the interface specification, a little example will
help illustrate both caller and callee sides.  Let's write a routine that
can be called as either:

     f(-x => 1, -y => 2, -z => 3);  # -switch form
     f(x => 1, y => 2, z => 3);     # concise form (- are optional)
     f(y => 1, x => 2);             # order changed, z may be omitted

   Since we have an optional parameter z but mandatory x and y, we can't
use the short form of getargs() and must therefore use xgetargs():

     sub f {
         my ($x, $y ,$z) = xgetargs(\@_,
             -x => 'i',             # mandatory, integer
             -y => 'i',             # mandatory, integer
             -z => ['i', 0],        # optional integer, defaults to 0
         );
         # code use $x, $y, $z
     }

   That's quite simple and direct if you think of [] as "optional".  Note
that we pass xgetargs() a reference to @_.

   If we had all arguments mandatory and wished to nonethless benefit from
the named specification at call time to avoid having the caller remember
the exact parameter ordering, we could write:

     sub f {
         my ($x, $y ,$z) = getargs(\@_, qw(x=i y=i z=i));
         # code of f
     }

   Without parameter type checking, that would be even more concise.
Besides, if f() is frequently called, it might be more efficient to build
a routine dynamically to parse the arguments rather than letting getargs()
parse the same data structures again and again:

     sub f {
         my ($x, $y ,$z) = cgetargs(\@_, qw(x y z));    # 'c' for cached/compiled
         # code of f
     }

   If you call f() with an improper argument, logcroak() will be called to
issue an exception from the persepective of the caller, i.e. pointing to
the place f() is called instead of within f() at the getargs() call, which
would be rather useless.

INTERFACE
=========

   All the routines take a mandatory first argument, called *arglist_ref*,
which is a reference to an array containing the named arguments for the
routine (i.e. a succession of name => value tuples).  It will usually be
given as `\@_'.

   All the routines take an optional options argument which comes in the
second place.  It is an hash reference containing named options that alter
the behaviour of the routine.  More details given in the `Options' in this
node section.

   All the routines return a list of the arguments in the order they are
specified, each slot in the list being either the argument value, if
present, or undef if missing (and not mandatory).

Simple Cases
------------

   Simple cases are handled by getargs(): named arguments should either be
*all mandatory* or *all optional*, and there is no provision for specifying
a default value for optional parameters.

   The getargs() routine and its cousin cgetargs() have two different
interfaces, depending on whether the arguments are all mandatory or all
optional.  We'll only specify for getargs(), but the signature of
cgetargs() is identical.

getargs *arglist_ref*, options, *arg_spec1*, *arg_spec2*, ...
     We'll be ignoring the options argument from our discussion.  See the
     `Options' in this node section for details.

     All the routine formal arguments specified by *arg_spec1*,
     *arg_spec2*, etc... are mandatory.  If *arg_spec1* is only a name,
     then it specifies a mandatory formal argument of that name, which can
     be of any type, even undef.  If the name is followed by `=type' then
     type specifies the argument type: usually a reference type, unless
     'i', 'n' or 's' is used for integer, natural and string scalars.

     Currently, types 'i', 'n' and 's' all mean the same thing: that the
     argument must be a scalar.  A future implementation will probably
     ensure 'i' and 'n' hold integers and natural numbers respectively,
     's' being the placeholder for anything else that is defined.

     For instance:

          foo               expects mandatory "foo" of "-foo" argument (undef ok)
          foo=s             idem, and argument cannot be undef or reference
          foo=i             value of argument -foo must be an integer
          foo=My::Package   foo is a blessed object, inheriting from My::Package
          foo=ARRAY         foo is an ARRAY reference

     The rule for determing whether `foo=X' means foo is a reference X or
     foo is an object whose class is an heir of X depends on the argument
     value at runtime: if it is an unblessed ref, strict reference
     equality is expected.  If it is a blessed ref, type conformance is
     based on inheritance, as you would expect.

     Example:

          sub f {
              my ($port, $server) = getargs(\@_,
                  qw(port=i server=HTTP::Server));
          }

     Some calls:

          f(-server => $server, port => 80);  # or -port, since - is optional
          f(port => 80, server => $server);
          f(server => $server);               # WRONG: missing mandatory -port
          f(server => 80, port => 80);        # WRONG: -server not an HTTP::Server
          f(server => undef, port => 80);     # WRONG: -server cannot be undef

     By default, named argument processing is case-sensitive but there is
     an option to ignore case.

getargs *arglist_ref*, options, *array_ref*
     This form specifies that all the formal arguments specified in the
     *array_ref* are optional.  Think of the '[' and ']' (which you'll
     probably use to supply the reference as a manifest constant) as
     syntactic markers for optional things.  In the traditional Unix
     command line description, something like:

          cmd [-a] [-o file]

     typically denotes that options -a and -o are optional, and that -o
     takes one argument, a file name.  To specify the same things for
     routine arguments using getargs():

          sub cmd {
              my ($a, $o) = getargs(\@_, [qw(a o=s)]);
          }

     Here however, the -a argument can be anything: we're not specifying
     switches, we're specifying *named* arguments.  Big difference.

     Some calls:

          cmd();                      # OK
          cmd(-a => undef);           # OK -a accepts anything, even undef
          cmd(-a => 1, -o => "..");   # OK
          cmd(-a => 1, -o => undef);  # WRONG: -o does not accept undef
          cmd(-x => 1);               # WRONG: -x is not a known argument name

     It is important to note that there can only be tuples when using named
     arguments, which means that the routine is called with an *even*
     number of arguments.  If you forget a `,' separator between
     arguments, getargs() will complain about an *odd* number of arguments
     (provided the resulting code still parses as valid Perl, naturally,
     or you'll never get a chance to reach the execution of getargs()
     anyway).

cgetargs *same args as getargs*
     The cgetargs() routine behaves exactly as the getargs() routine: it
     takes the same arguments, returns the same list.  The only difference
     is that the first time it is called, it builds a routine to process
     the arguments, and then calls it.

     On subsequent calls to cgetargs() for the same routine, the cached
     argument parsing routine is re-used to analyze the arguments.  For
     frequently called routines, this might be a win, even though Perl
     still needs to construct the argument list to cgetargs() and call it.

Complex Cases
-------------

   The xgetargs() routine and its cousin cxgetargs() (for the caching
version) allow for a more verbose description of named parameters which
allows specifying arguments that are mandatory or optional, and also give
default values to optional arguments.

xgetargs *arglist_ref*, options, name => type, ...
     We'll be ignoring the options argument from our discussion.  See
     `Options' in this node for details.

     There can be as many name => type tuples as necessary to describe all
     the formal arguments of the routine.  The name refers to the argument
     name, and type specifies both the mandatory nature and the expected
     type.  You may use name or *-name* to specify an argument called
     name, and the caller will also be able to spell it as he wishes.  The
     type is encoded as follows:

          "i"      mandatory integer (scalar)
          "s"      mandatory string (scalar)
          "TYPE"   mandatory ref of type TYPE, or heir of type TYPE
          undef    unspecified type, but mandatory argument
          ["i"]    optional integer
          ["s"]    optional string
          ["TYPE"] optional ref of type TYPE, or heir of type TYPE

     For optional parameter, an optional second value may be inserted in
     the list to specify a default value.  For instance, the tupple:

          'y' => ['HASH', { a => 1, b => 2 }]

     specifies an optional named argument y, which is expected to be a HASH
     reference, and whose default value is the hash given.

     You may specify an expression as default value instead of giving a
     manifest constant, but *BEWARE*: the cxgetargs() routine will take a
     snapshot of your expression when building its analyzing routine.
     It's of no consequence when using a manifest constant, but when using
     an expression, it will be evaluated *once* and the result of that
     evaluation will be taken as the manifest constant to use subsequently
     (and this does not mean the *same* reference will be returned, only
     the same topological structure as the one we evaluated during
     caching).

     Example:

          sub f {
              my ($x, $z) = cxgetargs(\@_,
                  -x  => 'i',                 # -x mandatory integer
                  -z  => ['n', -20.4],        # -z optional, defaults to -20.4
              );
          }

          f(x => 1, z => {});     # WRONG: z is not a numerical value
          f(z => 1, x => -2);     # OK
          f(-z => 1);             # WRONG: mandatory x is missing
          f(-z => undef);         # WRONG: z cannot be undef

     Remember that we are dealing with named parameters for a routine call,
     not with option parsing.  Therefore, we are always expecting an *even*
     number of arguments, and those arguments are tuples name => value.

Options
-------

   All the getargs() and xgetargs() routines take an optional hash
reference as second argument.  Keys in this hash define options that apply
locally to the call.  In the case of caching routines, e.g. cxgetargs(),
the options are only considered the first time, when the analyzing routine
is built, and are ignored on subsequent calls.  Therefore, it is wise to
use manifest constants when specifying options, or use the non-caching
function family instead if your options need to be dynamically computed
(please, don't do that).

   Options given there must be spelled out with the leading - and are case
sensitive.  To enable an option, give a true value.  For instance:

     sub f {
         my ($x, $z) = cxgetargs(\@_,
             { -strict => 0, -ignorecase => 1 },
             -x  => 'i',                 # -x mandatory integer
             -z  => ['n', -20.4],        # -z optional, defaults to -20.4
         );
     }

   supplies two options, turning `-ignorecase' on and `-strict' off.

   The available options are, in alphabetical order:

-extra
     Whether to report extra unknown arguments at the end of the argument
     list.  Example:

          my ($x, $y, @extra) = getargs(\@_,
              { -extra => 1, -strict => 0 }, qw(x y));

     Your setting is forced to false when `-strict' is true.  The default
     value is the negation of the boolean `-strict' setting, which means
     the above can be rewritten as:

          my ($x, $y, @extra) = getargs(\@_, { -strict => 0 }, qw(x y));

     which will implicitely set -extra to be true.  This is usually what
     you want when not strict, i.e. get at the other parameters.  Assuming
     we were writing the above for a function f(), calling:

          f(-x => 1, -y => 2, -other => 5);

     would set:

          @extra = (-other => 5);

     An alternative when you are not strict is to make use of the
     `-inplace' option to edit @_ inplace.

-ignorecase
     Turn case-insensitive named parameters.  False by default.  Actually,
     if not explicitely specified, the default setting depends on the way
     `Getargs::Long' was imported within the package scope.  If you said:

          use Getargs::Long;

     then the default is indeed to be case-sensitive.  However, if you
     said:

          use Getargs::Long qw(ignorecase);

     then the default for the package scope is to be case-insensitive.
     You may still specify the `-ignorecase' option to force case
     sensitivity on a per-routine basis, although I would never do such a
     thing and stick to a uniform case sensitivity on a package basis.

-inplace
     Whether to edit the routine's argument list inplace, removing
     processed arguments as they are found and leaving unprocessed ones.
     False by default.

     Your setting is forced to false when `-strict' is true, naturally,
     since an unknown argument is an error.

-strict
     Whether unknown named parameters are fatal.  True by default.  When
     `-strict' is true, the `-inplace' and `-extra' options you may
     specify are ignored and forced to false.

BUGS
====

   Currently, types 'i', 'n' and 's' all mean the same thing, but that will
change.  Don't take the current implementation's deficiency as an excuse
for lamely specifying your scalar types.

   You must be careful in this implementation to list options and variables
in the very same order.  Some day, I will probably add another routine to
take arguments the way Getopt::Long does to cope with this ordering
problem (but it forces to spell out variables twice - once for declaration,
and once for specifying a pointer to it).

AUTHOR
======

   Raphael Manfredi `<Raphael_Manfredi@pobox.com>'

SEE ALSO
========

   Log::Agent(3).


