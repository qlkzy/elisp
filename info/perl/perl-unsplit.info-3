This is Info file perl.info, produced by Makeinfo version 1.68 from the
input file bigperl.texi.

   settitle perl


File: perl.info,  Node: perldos,  Next: perlhpux,  Prev: perlcygwin,  Up: Top

Perl under DOS, W31, W95.
*************************

NAME
====

   perldos - Perl under DOS, W31, W95.

SYNOPSIS
========

   These are instructions for building Perl under DOS (or w??), using
DJGPP v2.01 or later. Under w95 long filenames are supported.

DESCRIPTION
===========

   Before you start, you should glance through the README file found in
the top-level directory where the Perl distribution was extracted.  Make
sure you read and understand the terms under which this software is being
distributed.

   This port currently supports MakeMaker (the set of modules that is used
to build extensions to perl).  Therefore, you should be able to build and
install most extensions found in the CPAN sites.

Prerequisites
-------------

DJGPP
     DJGPP is a port of GNU C/C++ compiler and development tools to 32-bit,
     protected-mode environment on Intel 32-bit CPUs running MS-DOS and
     compatible operating systems, by DJ Delorie <dj@delorie.com> and
     friends.

     For more details (FAQ), check out the home of DJGPP at:

          http://www.delorie.com/djgpp/

     If you have questions about DJGPP, try posting to the DJGPP newsgroup:
     comp.os.msdos.djgpp, or use the email gateway djgpp@delorie.com.

     You can find the full DJGPP distribution on any SimTel.Net mirror all
     over the world. Like:

          ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2*

     You need the following files to build perl (or add new modules):

          v2/djdev202.zip
          v2/bnu27b.zip
          v2gnu/gcc2721b.zip
          v2gnu/bsh1147b.zip
          v2gnu/mak3761b.zip
          v2gnu/fil316b.zip
          v2gnu/sed118b.zip
          v2gnu/txt122b.zip
          v2gnu/dif271b.zip
          v2gnu/grep21b.zip
          v2gnu/shl112b.zip
          v2gnu/gawk303b.zip
          v2misc/csdpmi4b.zip

     or possibly any newer version.

Pthreads
     Thread support is not tested in this version of the djgpp perl.

Shortcomings of Perl under DOS
------------------------------

   Perl under DOS lacks some features of perl under UNIX because of
deficiencies in the UNIX-emulation, most notably:

   * fork() and pipe()

   * some features of the UNIX filesystem regarding link count and file
     dates

   * in-place operation is a little bit broken with short filenames

   * sockets

Building
--------

   * Unpack the source package `perl5.6*.tar.gz' with djtarx. If you want
     to use long file names under w95, don't forget to use

          set LFN=y

     before unpacking the archive.

   * Create a "symlink" or copy your bash.exe to sh.exe in your
     `($DJDIR)/bin' directory.

          ln -s bash.exe sh.exe

     And make the `SHELL' environment variable point to this `sh.exe':

          set SHELL=c:/djgpp/bin/sh.exe (use full path name!)

     You can do this in `djgpp.env' too. Add this line BEFORE any section
     definition:

          +SHELL=%DJDIR%/bin/sh.exe

   * If you have `split.exe' and `gsplit.exe' in your path, then rename
     `split.exe' to `djsplit.exe', and `gsplit.exe' to `split.exe'.  Copy
     or link `gecho.exe' to `echo.exe' if you don't have `echo.exe'.  Copy
     or link `gawk.exe' to `awk.exe' if you don't have `awk.exe'.

   * Chdir to the djgpp subdirectory of perl toplevel and type the
     following command:

          configure.bat

     This will do some preprocessing then run the Configure script for you.
     The Configure script is interactive, but in most cases you just need
     to press ENTER.

     If the script says that your package is incomplete, and asks whether
     to continue, just answer with Y (this can only happen if you don't use
     long filenames).

     When Configure asks about the extensions, I suggest IO and Fcntl, and
     if you want database handling then SDBM_File or GDBM_File (you need
     to install gdbm for this one). If you want to use the POSIX extension
     (this is the default), make sure that the stack size of your
     `cc1.exe' is at least 512kbyte (you can check this with: `stubedit
     cc1.exe').

     You can use the Configure script in non-interactive mode too.  When I
     built my `perl.exe', I used something like this:

          configure.bat -des

     You can find more info about Configure's command line switches in the
     INSTALL file.

     When the script ends, and you want to change some values in the
     generated `config.sh' file, then run

          sh Configure -S

     after you made your modifications.

     IMPORTANT: if you use this -S switch, be sure to delete the CONFIG
     environment variable before running the script:

          set CONFIG=

   * Now you can compile Perl. Type:

          make

Testing
-------

   Type:

     make test

   If you're lucky you should see "All tests successful". But there can be
a few failed subtests (less than 5 hopefully) depending on some external
conditions (e.g. some subtests fail under linux/dosemu or plain dos with
short filenames only).

Installation
------------

   Type:

     make install

   This will copy the newly compiled perl and libraries into your DJGPP
directory structure. Perl.exe and the utilities go into `($DJDIR)/bin',
and the library goes under `($DJDIR)/lib/perl5'. The pod documentation
goes under `($DJDIR)/lib/perl5/pod'.

AUTHOR
======

   Laszlo Molnar, `laszlo.molnar@eth.ericsson.se'

SEE ALSO
========

   perl(1).


File: perl.info,  Node: perldsc,  Next: perllol,  Prev: perlref,  Up: Top

Perl Data Structures Cookbook
*****************************

NAME
====

   perldsc - Perl Data Structures Cookbook

DESCRIPTION
===========

   The single feature most sorely lacking in the Perl programming language
prior to its 5.0 release was complex data structures.  Even without direct
language support, some valiant programmers did manage to emulate them, but
it was hard work and not for the faint of heart.  You could occasionally
get away with the `$m{$AoA,$b}' notation borrowed from *awk* in which the
keys are actually more like a single concatenated string `"$AoA$b"', but
traversal and sorting were difficult.  More desperate programmers even
hacked Perl's internal symbol table directly, a strategy that proved hard
to develop and maintain-to put it mildly.

   The 5.0 release of Perl let us have complex data structures.  You may
now write something like this and all of a sudden, you'd have a array with
three dimensions!

     for $x (1 .. 10) {
     	for $y (1 .. 10) {
     	    for $z (1 .. 10) {
     		$AoA[$x][$y][$z] =
     		    $x ** $y + $z;
     	    }
     	}
     }

   Alas, however simple this may appear, underneath it's a much more
elaborate construct than meets the eye!

   How do you print it out?  Why can't you say just `print @AoA'?  How do
you sort it?  How can you pass it to a function or get one of these back
from a function?  Is is an object?  Can you save it to disk to read back
later?  How do you access whole rows or columns of that matrix?  Do all
the values have to be numeric?

   As you see, it's quite easy to become confused.  While some small
portion of the blame for this can be attributed to the reference-based
implementation, it's really more due to a lack of existing documentation
with examples designed for the beginner.

   This document is meant to be a detailed but understandable treatment of
the many different sorts of data structures you might want to develop.  It
should also serve as a cookbook of examples.  That way, when you need to
create one of these complex data structures, you can just pinch, pilfer, or
purloin a drop-in example from here.

   Let's look at each of these possible constructs in detail.  There are
separate sections on each of the following:

   * arrays of arrays

   * hashes of arrays

   * arrays of hashes

   * hashes of hashes

   * more elaborate constructs

   But for now, let's look at general issues common to all these types of
data structures.

REFERENCES
==========

   The most important thing to understand about all data structures in Perl
- including multidimensional arrays-is that even though they might appear
otherwise, Perl `@ARRAY's and `%HASH'es are all internally
one-dimensional.  They can hold only scalar values (meaning a string,
number, or a reference).  They cannot directly contain other arrays or
hashes, but instead contain references to other arrays or hashes.

   You can't use a reference to a array or hash in quite the same way that
you would a real array or hash.  For C or C++ programmers unused to
distinguishing between arrays and pointers to the same, this can be
confusing.  If so, just think of it as the difference between a structure
and a pointer to a structure.

   You can (and should) read more about references in the perlref(1) man
page.  Briefly, references are rather like pointers that know what they
point to.  (Objects are also a kind of reference, but we won't be needing
them right away-if ever.)  This means that when you have something which
looks to you like an access to a two-or-more-dimensional array and/or hash,
what's really going on is that the base type is merely a one-dimensional
entity that contains references to the next level.  It's just that you can
use it as though it were a two-dimensional one.  This is actually the way
almost all C multidimensional arrays work as well.

     $array[7][12]			# array of arrays
     $array[7]{string}			# array of hashes
     $hash{string}[7]			# hash of arrays
     $hash{string}{'another string'}	# hash of hashes

   Now, because the top level contains only references, if you try to print
out your array in with a simple print() function, you'll get something
that doesn't look very nice, like this:

     @AoA = ( [2, 3], [4, 5, 7], [0] );
     print $AoA[1][2];
       7
     print @AoA;
       ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)

   That's because Perl doesn't (ever) implicitly dereference your
variables.  If you want to get at the thing a reference is referring to,
then you have to do this yourself using either prefix typing indicators,
like `${$blah}', `@{$blah}', `@{$blah[$i]}', or else postfix pointer
arrows, like `$a->[3]', `$h->{fred}', or even `$ob->method()->[3]'.

COMMON MISTAKES
===============

   The two most common mistakes made in constructing something like an
array of arrays is either accidentally counting the number of elements or
else taking a reference to the same memory location repeatedly.  Here's
the case where you just get the count instead of a nested array:

     for $i (1..10) {
     	@array = somefunc($i);
     	$AoA[$i] = @array;	# WRONG!
     }

   That's just the simple case of assigning an array to a scalar and
getting its element count.  If that's what you really and truly want, then
you might do well to consider being a tad more explicit about it, like
this:

     for $i (1..10) {
     	@array = somefunc($i);
     	$counts[$i] = scalar @array;
     }

   Here's the case of taking a reference to the same memory location again
and again:

     for $i (1..10) {
     	@array = somefunc($i);
     	$AoA[$i] = \@array;	# WRONG!
     }

   So, what's the big problem with that?  It looks right, doesn't it?
After all, I just told you that you need an array of references, so by
golly, you've made me one!

   Unfortunately, while this is true, it's still broken.  All the
references in @AoA refer to the *very same place*, and they will therefore
all hold whatever was last in @array!  It's similar to the problem
demonstrated in the following C program:

     #include <pwd.h>
     main() {
     	struct passwd *getpwnam(), *rp, *dp;
     	rp = getpwnam("root");
     	dp = getpwnam("daemon");

     printf("daemon name is %s\nroot name is %s\n",
     	dp->pw_name, rp->pw_name);
         }

   Which will print

     daemon name is daemon
     root name is daemon

   The problem is that both rp and `dp' are pointers to the same location
in memory!  In C, you'd have to remember to malloc() yourself some new
memory.  In Perl, you'll want to use the array constructor [] or the hash
constructor `{}' instead.   Here's the right way to do the preceding
broken code fragments:

     for $i (1..10) {
     	@array = somefunc($i);
     	$AoA[$i] = [ @array ];
     }

   The square brackets make a reference to a new array with a copy of
what's in @array at the time of the assignment.  This is what you want.

   Note that this will produce something similar, but it's much harder to
read:

     for $i (1..10) {
     	@array = 0 .. $i;
     	@{$AoA[$i]} = @array;
     }

   Is it the same?  Well, maybe so-and maybe not.  The subtle difference
is that when you assign something in square brackets, you know for sure
it's always a brand new reference with a new copy of the data.  Something
else could be going on in this new case with the `@{$AoA[$i]}}'
dereference on the left-hand-side of the assignment.  It all depends on
whether `$AoA[$i]' had been undefined to start with, or whether it already
contained a reference.  If you had already populated @AoA with references,
as in

     $AoA[3] = \@another_array;

   Then the assignment with the indirection on the left-hand-side would
use the existing reference that was already there:

     @{$AoA[3]} = @array;

   Of course, this *would* have the "interesting" effect of clobbering
@another_array.  (Have you ever noticed how when a programmer says
something is "interesting", that rather than meaning "intriguing", they're
disturbingly more apt to mean that it's "annoying", "difficult", or both?
:-)

   So just remember always to use the array or hash constructors with []
or `{}', and you'll be fine, although it's not always optimally efficient.

   Surprisingly, the following dangerous-looking construct will actually
work out fine:

     for $i (1..10) {
         my @array = somefunc($i);
         $AoA[$i] = \@array;
     }

   That's because my() is more of a run-time statement than it is a
compile-time declaration *per se*.  This means that the my() variable is
remade afresh each time through the loop.  So even though it *looks* as
though you stored the same variable reference each time, you actually did
not!  This is a subtle distinction that can produce more efficient code at
the risk of misleading all but the most experienced of programmers.  So I
usually advise against teaching it to beginners.  In fact, except for
passing arguments to functions, I seldom like to see the gimme-a-reference
operator (backslash) used much at all in code.  Instead, I advise
beginners that they (and most of the rest of us) should try to use the
much more easily understood constructors [] and `{}' instead of relying
upon lexical (or dynamic) scoping and hidden reference-counting to do the
right thing behind the scenes.

   In summary:

     $AoA[$i] = [ @array ];	# usually best
     $AoA[$i] = \@array;		# perilous; just how my() was that array?
     @{ $AoA[$i] } = @array;	# way too tricky for most programmers

CAVEAT ON PRECEDENCE
====================

   Speaking of things like `@{$AoA[$i]}', the following are actually the
same thing:

     $aref->[2][2]	# clear
     $$aref[2][2]	# confusing

   That's because Perl's precedence rules on its five prefix dereferencers
(which look like someone swearing: `$ @ * % &') make them bind more
tightly than the postfix subscripting brackets or braces!  This will no
doubt come as a great shock to the C or C++ programmer, who is quite
accustomed to using `*a[i]' to mean what's pointed to by the *i'th*
element of a.  That is, they first take the subscript, and only then
dereference the thing at that subscript.  That's fine in C, but this isn't
C.

   The seemingly equivalent construct in Perl, `$$aref[$i]' first does the
deref of $aref, making it take $aref as a reference to an array, and then
dereference that, and finally tell you the *i'th* value of the array
pointed to by $AoA. If you wanted the C notion, you'd have to write
`${$AoA[$i]}' to force the `$AoA[$i]' to get evaluated first before the
leading `$' dereferencer.

WHY YOU SHOULD ALWAYS `use strict'
==================================

   If this is starting to sound scarier than it's worth, relax.  Perl has
some features to help you avoid its most common pitfalls.  The best way to
avoid getting confused is to start every program like this:

     #!/usr/bin/perl -w
     use strict;

   This way, you'll be forced to declare all your variables with my() and
also disallow accidental "symbolic dereferencing".  Therefore if you'd done
this:

     my $aref = [
     	[ "fred", "barney", "pebbles", "bambam", "dino", ],
     	[ "homer", "bart", "marge", "maggie", ],
     	[ "george", "jane", "elroy", "judy", ],
     ];

     print $aref[2][2];

   The compiler would immediately flag that as an error *at compile time*,
because you were accidentally accessing `@aref', an undeclared variable,
and it would thereby remind you to write instead:

     print $aref->[2][2]

DEBUGGING
=========

   Before version 5.002, the standard Perl debugger didn't do a very nice
job of printing out complex data structures.  With 5.002 or above, the
debugger includes several new features, including command line editing as
well as the x command to dump out complex data structures.  For example,
given the assignment to $AoA above, here's the debugger output:

     DB<1> x $AoA
     $AoA = ARRAY(0x13b5a0)
        0  ARRAY(0x1f0a24)
     	  0  'fred'
     	  1  'barney'
     	  2  'pebbles'
     	  3  'bambam'
     	  4  'dino'
        1  ARRAY(0x13b558)
     	  0  'homer'
     	  1  'bart'
     	  2  'marge'
     	  3  'maggie'
        2  ARRAY(0x13b540)
     	  0  'george'
     	  1  'jane'
     	  2  'elroy'
     	  3  'judy'

CODE EXAMPLES
=============

   Presented with little comment (these will get their own manpages
someday) here are short code examples illustrating access of various types
of data structures.

ARRAYS OF ARRAYS
================

Declaration of a ARRAY OF ARRAYS
--------------------------------

     @AoA = (
            [ "fred", "barney" ],
            [ "george", "jane", "elroy" ],
            [ "homer", "marge", "bart" ],
          );

Generation of a ARRAY OF ARRAYS
-------------------------------

     # reading from file
     while ( <> ) {
         push @AoA, [ split ];
     }

     # calling a function
     for $i ( 1 .. 10 ) {
         $AoA[$i] = [ somefunc($i) ];
     }

     # using temp vars
     for $i ( 1 .. 10 ) {
         @tmp = somefunc($i);
         $AoA[$i] = [ @tmp ];
     }

     # add to an existing row
     push @{ $AoA[0] }, "wilma", "betty";

Access and Printing of a ARRAY OF ARRAYS
----------------------------------------

     # one element
     $AoA[0][0] = "Fred";

     # another element
     $AoA[1][1] =~ s/(\w)/\u$1/;

     # print the whole thing with refs
     for $aref ( @AoA ) {
         print "\t [ @$aref ],\n";
     }

     # print the whole thing with indices
     for $i ( 0 .. $#AoA ) {
         print "\t [ @{$AoA[$i]} ],\n";
     }

     # print the whole thing one at a time
     for $i ( 0 .. $#AoA ) {
         for $j ( 0 .. $#{ $AoA[$i] } ) {
             print "elt $i $j is $AoA[$i][$j]\n";
         }
     }

HASHES OF ARRAYS
================

Declaration of a HASH OF ARRAYS
-------------------------------

     %HoA = (
            flintstones        => [ "fred", "barney" ],
            jetsons            => [ "george", "jane", "elroy" ],
            simpsons           => [ "homer", "marge", "bart" ],
          );

Generation of a HASH OF ARRAYS
------------------------------

     # reading from file
     # flintstones: fred barney wilma dino
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $HoA{$1} = [ split ];
     }

     # reading from file; more temps
     # flintstones: fred barney wilma dino
     while ( $line = <> ) {
         ($who, $rest) = split /:\s*/, $line, 2;
         @fields = split ' ', $rest;
         $HoA{$who} = [ @fields ];
     }

     # calling a function that returns a list
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         $HoA{$group} = [ get_family($group) ];
     }

     # likewise, but using temps
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         @members = get_family($group);
         $HoA{$group} = [ @members ];
     }

     # append new members to an existing family
     push @{ $HoA{"flintstones"} }, "wilma", "betty";

Access and Printing of a HASH OF ARRAYS
---------------------------------------

     # one element
     $HoA{flintstones}[0] = "Fred";

     # another element
     $HoA{simpsons}[1] =~ s/(\w)/\u$1/;

     # print the whole thing
     foreach $family ( keys %HoA ) {
         print "$family: @{ $HoA{$family} }\n"
     }

     # print the whole thing with indices
     foreach $family ( keys %HoA ) {
         print "family: ";
         foreach $i ( 0 .. $#{ $HoA{$family} } ) {
             print " $i = $HoA{$family}[$i]";
         }
         print "\n";
     }

     # print the whole thing sorted by number of members
     foreach $family ( sort { @{$HoA{$b}} <=> @{$HoA{$a}} } keys %HoA ) {
         print "$family: @{ $HoA{$family} }\n"
     }

     # print the whole thing sorted by number of members and name
     foreach $family ( sort {
     			    @{$HoA{$b}} <=> @{$HoA{$a}}
     					||
     				    $a cmp $b
     	    } keys %HoA )
     {
         print "$family: ", join(", ", sort @{ $HoA{$family} }), "\n";
     }

ARRAYS OF HASHES
================

Declaration of a ARRAY OF HASHES
--------------------------------

     @AoH = (
            {
                Lead     => "fred",
                Friend   => "barney",
            },
            {
                Lead     => "george",
                Wife     => "jane",
                Son      => "elroy",
            },
            {
                Lead     => "homer",
                Wife     => "marge",
                Son      => "bart",
            }
      );

Generation of a ARRAY OF HASHES
-------------------------------

     # reading from file
     # format: LEAD=fred FRIEND=barney
     while ( <> ) {
         $rec = {};
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $rec->{$key} = $value;
         }
         push @AoH, $rec;
     }

     # reading from file
     # format: LEAD=fred FRIEND=barney
     # no temp
     while ( <> ) {
         push @AoH, { split /[\s+=]/ };
     }

     # calling a function  that returns a key/value pair list, like
     # "lead","fred","daughter","pebbles"
     while ( %fields = getnextpairset() ) {
         push @AoH, { %fields };
     }

     # likewise, but using no temp vars
     while (<>) {
         push @AoH, { parsepairs($_) };
     }

     # add key/value to an element
     $AoH[0]{pet} = "dino";
     $AoH[2]{pet} = "santa's little helper";

Access and Printing of a ARRAY OF HASHES
----------------------------------------

     # one element
     $AoH[0]{lead} = "fred";

     # another element
     $AoH[1]{lead} =~ s/(\w)/\u$1/;

     # print the whole thing with refs
     for $href ( @AoH ) {
         print "{ ";
         for $role ( keys %$href ) {
             print "$role=$href->{$role} ";
         }
         print "}\n";
     }

     # print the whole thing with indices
     for $i ( 0 .. $#AoH ) {
         print "$i is { ";
         for $role ( keys %{ $AoH[$i] } ) {
             print "$role=$AoH[$i]{$role} ";
         }
         print "}\n";
     }

     # print the whole thing one at a time
     for $i ( 0 .. $#AoH ) {
         for $role ( keys %{ $AoH[$i] } ) {
             print "elt $i $role is $AoH[$i]{$role}\n";
         }
     }

HASHES OF HASHES
================

Declaration of a HASH OF HASHES
-------------------------------

     %HoH = (
            flintstones => {
     		lead      => "fred",
     		pal       => "barney",
            },
            jetsons     => {
     		lead      => "george",
     		wife      => "jane",
     		"his boy" => "elroy",
            },
            simpsons    => {
     		lead      => "homer",
     		wife      => "marge",
     		kid       => "bart",
     	},
     );

Generation of a HASH OF HASHES
------------------------------

     # reading from file
     # flintstones: lead=fred pal=barney wife=wilma pet=dino
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $who = $1;
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $HoH{$who}{$key} = $value;
         }

     # reading from file; more temps
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $who = $1;
         $rec = {};
         $HoH{$who} = $rec;
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $rec->{$key} = $value;
         }
     }

     # calling a function  that returns a key,value hash
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         $HoH{$group} = { get_family($group) };
     }

     # likewise, but using temps
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         %members = get_family($group);
         $HoH{$group} = { %members };
     }

     # append new members to an existing family
     %new_folks = (
         wife => "wilma",
         pet  => "dino",
     );

     for $what (keys %new_folks) {
         $HoH{flintstones}{$what} = $new_folks{$what};
     }

Access and Printing of a HASH OF HASHES
---------------------------------------

     # one element
     $HoH{flintstones}{wife} = "wilma";

     # another element
     $HoH{simpsons}{lead} =~ s/(\w)/\u$1/;

     # print the whole thing
     foreach $family ( keys %HoH ) {
         print "$family: { ";
         for $role ( keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }

     # print the whole thing  somewhat sorted
     foreach $family ( sort keys %HoH ) {
         print "$family: { ";
         for $role ( sort keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }

     # print the whole thing sorted by number of members
     foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} } keys %HoH ) {
         print "$family: { ";
         for $role ( sort keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }

     # establish a sort order (rank) for each role
     $i = 0;
     for ( qw(lead wife son daughter pal pet) ) { $rank{$_} = ++$i }

     # now print the whole thing sorted by number of members
     foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } } keys %HoH ) {
         print "$family: { ";
         # and print these according to rank order
         for $role ( sort { $rank{$a} <=> $rank{$b} }  keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }

MORE ELABORATE RECORDS
======================

Declaration of MORE ELABORATE RECORDS
-------------------------------------

   Here's a sample showing how to create and use a record whose fields are
of many different sorts:

     $rec = {
     	 TEXT      => $string,
     	 SEQUENCE  => [ @old_values ],
     	 LOOKUP    => { %some_table },
     	 THATCODE  => \&some_function,
     	 THISCODE  => sub { $_[0] ** $_[1] },
     	 HANDLE    => \*STDOUT,
     };

     print $rec->{TEXT};

     print $rec->{SEQUENCE}[0];
     $last = pop @ { $rec->{SEQUENCE} };

     print $rec->{LOOKUP}{"key"};
     ($first_k, $first_v) = each %{ $rec->{LOOKUP} };

     $answer = $rec->{THATCODE}->($arg);
     $answer = $rec->{THISCODE}->($arg1, $arg2);

     # careful of extra block braces on fh ref
     print { $rec->{HANDLE} } "a string\n";

     use FileHandle;
     $rec->{HANDLE}->autoflush(1);
     $rec->{HANDLE}->print(" a string\n");

Declaration of a HASH OF COMPLEX RECORDS
----------------------------------------

     %TV = (
        flintstones => {
            series   => "flintstones",
            nights   => [ qw(monday thursday friday) ],
            members  => [
                { name => "fred",    role => "lead", age  => 36, },
                { name => "wilma",   role => "wife", age  => 31, },
                { name => "pebbles", role => "kid",  age  =>  4, },
            ],
        },

     jetsons     => {
         series   => "jetsons",
         nights   => [ qw(wednesday saturday) ],
         members  => [
             { name => "george",  role => "lead", age  => 41, },
             { name => "jane",    role => "wife", age  => 39, },
             { name => "elroy",   role => "kid",  age  =>  9, },
         ],
      },

     simpsons    => {
         series   => "simpsons",
         nights   => [ qw(monday) ],
         members  => [
             { name => "homer", role => "lead", age  => 34, },
             { name => "marge", role => "wife", age => 37, },
             { name => "bart",  role => "kid",  age  =>  11, },
         ],
      },
           );

Generation of a HASH OF COMPLEX RECORDS
---------------------------------------

     # reading from file
     # this is most easily done by having the file itself be
     # in the raw data format as shown above.  perl is happy
     # to parse complex data structures if declared as data, so
     # sometimes it's easiest to do that

     # here's a piece by piece build up
     $rec = {};
     $rec->{series} = "flintstones";
     $rec->{nights} = [ find_days() ];

     @members = ();
     # assume this file in field=value syntax
     while (<>) {
         %fields = split /[\s=]+/;
         push @members, { %fields };
     }
     $rec->{members} = [ @members ];

     # now remember the whole thing
     $TV{ $rec->{series} } = $rec;

     ###########################################################
     # now, you might want to make interesting extra fields that
     # include pointers back into the same data structure so if
     # change one piece, it changes everywhere, like for example
     # if you wanted a {kids} field that was a reference
     # to an array of the kids' records without having duplicate
     # records and thus update problems.
     ###########################################################
     foreach $family (keys %TV) {
         $rec = $TV{$family}; # temp pointer
         @kids = ();
         for $person ( @{ $rec->{members} } ) {
             if ($person->{role} =~ /kid|son|daughter/) {
                 push @kids, $person;
             }
         }
         # REMEMBER: $rec and $TV{$family} point to same data!!
         $rec->{kids} = [ @kids ];
     }

     # you copied the array, but the array itself contains pointers
     # to uncopied objects. this means that if you make bart get
     # older via

     $TV{simpsons}{kids}[0]{age}++;

     # then this would also change in
     print $TV{simpsons}{members}[2]{age};

     # because $TV{simpsons}{kids}[0] and $TV{simpsons}{members}[2]
     # both point to the same underlying anonymous hash table

     # print the whole thing
     foreach $family ( keys %TV ) {
         print "the $family";
         print " is on during @{ $TV{$family}{nights} }\n";
         print "its members are:\n";
         for $who ( @{ $TV{$family}{members} } ) {
             print " $who->{name} ($who->{role}), age $who->{age}\n";
         }
         print "it turns out that $TV{$family}{lead} has ";
         print scalar ( @{ $TV{$family}{kids} } ), " kids named ";
         print join (", ", map { $_->{name} } @{ $TV{$family}{kids} } );
         print "\n";
     }

Database Ties
=============

   You cannot easily tie a multilevel data structure (such as a hash of
hashes) to a dbm file.  The first problem is that all but GDBM and
Berkeley DB have size limitations, but beyond that, you also have problems
with how references are to be represented on disk.  One experimental
module that does partially attempt to address this need is the MLDBM
module.  Check your nearest CPAN site as described in *Note Perlmodlib:
perlmodlib, for source code to MLDBM.

SEE ALSO
========

   perlref(1), perllol(1), perldata(1), perlobj(1)

AUTHOR
======

   Tom Christiansen <`tchrist@perl.com'>

   Last update: Wed Oct 23 04:57:50 MET DST 1996


File: perl.info,  Node: perlembed,  Next: perlapio,  Prev: perlbook,  Up: Top

how to embed perl in your C program
***********************************

NAME
====

   perlembed - how to embed perl in your C program

DESCRIPTION
===========

PREAMBLE
--------

   Do you want to:

*Use C from Perl?*
     Read *Note Perlxstut: perlxstut,, *Note Perlxs: perlxs,, `h2xs' in
     this node, *Note Perlguts: perlguts,, and *Note Perlapi: perlapi,.

*Use a Unix program from Perl?*
     Read about back-quotes and about system and exec in *Note Perlfunc:
     perlfunc,.

*Use Perl from Perl?*
     Read about `do', *Note Perlfunc: perlfunc, and `eval', *Note
     Perlfunc: perlfunc, and `require', *Note Perlfunc: perlfunc, and
     `use', *Note Perlfunc: perlfunc,.

*Use C from C?*
     Rethink your design.

*Use Perl from C?*
     Read on...

ROADMAP
-------

   `Compiling your C program' in this node

   `Adding a Perl interpreter to your C program' in this node

   `Calling a Perl subroutine from your C program' in this node

   `Evaluating a Perl statement from your C program' in this node

   `Performing Perl pattern matches and substitutions from your C program'
in this node

   `Fiddling with the Perl stack from your C program' in this node

   `Maintaining a persistent interpreter' in this node

   `Maintaining multiple interpreter instances' in this node

   `Using Perl modules, which themselves use C libraries, from your C
program' in this node

   `Embedding Perl under Win32' in this node

Compiling your C program
------------------------

   If you have trouble compiling the scripts in this documentation, you're
not alone.  The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE SAME
WAY THAT YOUR PERL WAS COMPILED.  (Sorry for yelling.)

   Also, every C program that uses Perl must link in the *perl library*.
What's that, you ask?  Perl is itself written in C; the perl library is
the collection of compiled C programs that were used to create your perl
executable (*/usr/bin/perl* or equivalent).  (Corollary: you can't use
Perl from your C program unless Perl has been compiled on your machine, or
installed properly-that's why you shouldn't blithely copy Perl executables
from machine to machine without also copying the lib directory.)

   When you use Perl from C, your C program will-usually-allocate, "run",
and deallocate a *PerlInterpreter* object, which is defined by the perl
library.

   If your copy of Perl is recent enough to contain this documentation
(version 5.002 or later), then the perl library (and *EXTERN.h* and
*perl.h*, which you'll also need) will reside in a directory that looks
like this:

     /usr/local/lib/perl5/your_architecture_here/CORE

   or perhaps just

     /usr/local/lib/perl5/CORE

   or maybe something like

     /usr/opt/perl5/CORE

   Execute this statement for a hint about where to find CORE:

     perl -MConfig -e 'print $Config{archlib}'

   Here's how you'd compile the example in the next section, `Adding a
Perl interpreter to your C program' in this node, on my Linux box:

     % gcc -O2 -Dbool=char -DHAS_BOOL -I/usr/local/include
     -I/usr/local/lib/perl5/i586-linux/5.003/CORE
     -L/usr/local/lib/perl5/i586-linux/5.003/CORE
     -o interp interp.c -lperl -lm

   (That's all one line.)  On my DEC Alpha running old 5.003_05, the
incantation is a bit different:

     % cc -O2 -Olimit 2900 -DSTANDARD_C -I/usr/local/include
     -I/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE
     -L/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE -L/usr/local/lib
     -D__LANGUAGE_C__ -D_NO_PROTO -o interp interp.c -lperl -lm

   How can you figure out what to add?  Assuming your Perl is post-5.001,
execute a `perl -V' command and pay special attention to the "cc" and
"ccflags" information.

   You'll have to choose the appropriate compiler (cc, *gcc*, et al.) for
your machine: `perl -MConfig -e 'print $Config{cc}'' will tell you what to
use.

   You'll also have to choose the appropriate library directory
(*/usr/local/lib/...*) for your machine.  If your compiler complains that
certain functions are undefined, or that it can't locate *-lperl*, then
you need to change the path following the -L.  If it complains that it
can't find *EXTERN.h* and *perl.h*, you need to change the path following
the -I.

   You may have to add extra libraries as well.  Which ones?  Perhaps
those printed by

     perl -MConfig -e 'print $Config{libs}'

   Provided your perl binary was properly configured and installed the
ExtUtils::Embed module will determine all of this information for you:

     % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

   If the ExtUtils::Embed module isn't part of your Perl distribution, you
can retrieve it from
http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/.  (If this
documentation came from your Perl distribution, then you're running 5.004
or better and you already have it.)

   The ExtUtils::Embed kit on CPAN also contains all source code for the
examples in this document, tests, additional examples and other
information you may find useful.

Adding a Perl interpreter to your C program
-------------------------------------------

   In a sense, perl (the C program) is a good example of embedding Perl
(the language), so I'll demonstrate embedding with *miniperlmain.c*,
included in the source distribution.  Here's a bastardized, nonportable
version of *miniperlmain.c* containing the essentials of embedding:

     #include <EXTERN.h>               /* from the Perl distribution     */
     #include <perl.h>                 /* from the Perl distribution     */

     static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/

     int main(int argc, char **argv, char **env)
     {
         my_perl = perl_alloc();
         perl_construct(my_perl);
         perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
         perl_run(my_perl);
         perl_destruct(my_perl);
         perl_free(my_perl);
     }

   Notice that we don't use the env pointer.  Normally handed to
perl_parse as its final argument, env here is replaced by NULL, which
means that the current environment will be used.

   Now compile this program (I'll call it *interp.c*) into an executable:

     % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

   After a successful compilation, you'll be able to use interp just like
perl itself:

     % interp
     print "Pretty Good Perl \n";
     print "10890 - 9801 is ", 10890 - 9801;
     <CTRL-D>
     Pretty Good Perl
     10890 - 9801 is 1089

   or

     % interp -e 'printf("%x", 3735928559)'
     deadbeef

   You can also read and execute Perl statements from a file while in the
midst of your C program, by placing the filename in *argv[1]* before
calling perl_run.

Calling a Perl subroutine from your C program
---------------------------------------------

   To call individual Perl subroutines, you can use any of the *call_**
functions documented in *Note Perlcall: perlcall,.  In this example we'll
use call_argv.

   That's shown below, in a program I'll call *showtime.c*.

     #include <EXTERN.h>
     #include <perl.h>

     static PerlInterpreter *my_perl;

     int main(int argc, char **argv, char **env)
     {
         char *args[] = { NULL };
         my_perl = perl_alloc();
         perl_construct(my_perl);

     perl_parse(my_perl, NULL, argc, argv, NULL);

     /*** skipping perl_run() ***/

     call_argv("showtime", G_DISCARD | G_NOARGS, args);

     perl_destruct(my_perl);
     perl_free(my_perl);
         }

   where *showtime* is a Perl subroutine that takes no arguments (that's
the G_NOARGS) and for which I'll ignore the return value (that's the
G_DISCARD).  Those flags, and others, are discussed in *Note Perlcall:
perlcall,.

   I'll define the *showtime* subroutine in a file called *showtime.pl*:

     print "I shan't be printed.";

     sub showtime {
         print time;
     }

   Simple enough.  Now compile and run:

     % cc -o showtime showtime.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

     % showtime showtime.pl
     818284590

   yielding the number of seconds that elapsed between January 1, 1970
(the beginning of the Unix epoch), and the moment I began writing this
sentence.

   In this particular case we don't have to call perl_run, but in general
it's considered good practice to ensure proper initialization of library
code, including execution of all object DESTROY methods and package `END
{}' blocks.

   If you want to pass arguments to the Perl subroutine, you can add
strings to the NULL-terminated args list passed to call_argv.  For other
data types, or to examine return values, you'll need to manipulate the
Perl stack.  That's demonstrated in the last section of this document:
`Fiddling with the Perl stack from your C program' in this node.

Evaluating a Perl statement from your C program
-----------------------------------------------

   Perl provides two API functions to evaluate pieces of Perl code.  These
are `eval_sv', *Note Perlapi: perlapi, and `eval_pv', *Note Perlapi:
perlapi,.

   Arguably, these are the only routines you'll ever need to execute
snippets of Perl code from within your C program.  Your code can be as
long as you wish; it can contain multiple statements; it can employ `use',
*Note Perlfunc: perlfunc,, `require', *Note Perlfunc: perlfunc,, and `do',
*Note Perlfunc: perlfunc, to include external Perl files.

   eval_pv lets us evaluate individual Perl strings, and then extract
variables for coercion into C types.  The following program, *string.c*,
executes three Perl strings, extracting an int from the first, a float
from the second, and a `char *' from the third.

     #include <EXTERN.h>
     #include <perl.h>

     static PerlInterpreter *my_perl;

     main (int argc, char **argv, char **env)
     {
         STRLEN n_a;
         char *embedding[] = { "", "-e", "0" };

     my_perl = perl_alloc();
     perl_construct( my_perl );

     perl_parse(my_perl, NULL, 3, embedding, NULL);
     perl_run(my_perl);

     /** Treat $a as an integer **/
     eval_pv("$a = 3; $a **= 2", TRUE);
     printf("a = %d\n", SvIV(get_sv("a", FALSE)));

     /** Treat $a as a float **/
     eval_pv("$a = 3.14; $a **= 2", TRUE);
     printf("a = %f\n", SvNV(get_sv("a", FALSE)));

     /** Treat $a as a string **/
     eval_pv("$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a);", TRUE);
     printf("a = %s\n", SvPV(get_sv("a", FALSE), n_a));

     perl_destruct(my_perl);
     perl_free(my_perl);
        }

   All of those strange functions with sv in their names help convert Perl
scalars to C types.  They're described in *Note Perlguts: perlguts, and
*Note Perlapi: perlapi,.

   If you compile and run *string.c*, you'll see the results of using
*SvIV()* to create an int, *SvNV()* to create a float, and *SvPV()* to
create a string:

     a = 9
     a = 9.859600
     a = Just Another Perl Hacker

   In the example above, we've created a global variable to temporarily
store the computed value of our eval'd expression.  It is also possible
and in most cases a better strategy to fetch the return value from
*eval_pv()* instead.  Example:

     ...
     STRLEN n_a;
     SV *val = eval_pv("reverse 'rekcaH lreP rehtonA tsuJ'", TRUE);
     printf("%s\n", SvPV(val,n_a));
     ...

   This way, we avoid namespace pollution by not creating global variables
and we've simplified our code as well.

Performing Perl pattern matches and substitutions from your C program
---------------------------------------------------------------------

   The *eval_sv()* function lets us evaluate strings of Perl code, so we
can define some functions that use it to "specialize" in matches and
substitutions: match(), *substitute()*, and *matches()*.

     I32 match(SV *string, char *pattern);

   Given a string and a pattern (e.g., `m/clasp/' or `/\b\w*\b/', which in
your C program might appear as "/\\b\\w*\\b/"), match() returns 1 if the
string matches the pattern and 0 otherwise.

     int substitute(SV **string, char *pattern);

   Given a pointer to an SV and an `=~' operation (e.g., `s/bob/robert/g'
or `tr[A-Z][a-z]'), substitute() modifies the string within the AV at
according to the operation, returning the number of substitutions made.

     int matches(SV *string, char *pattern, AV **matches);

   Given an SV, a pattern, and a pointer to an empty AV, matches()
evaluates `$string =~ $pattern' in an array context, and fills in matches
with the array elements, returning the number of matches found.

   Here's a sample program, *match.c*, that uses all three (long lines have
been wrapped here):

     #include <EXTERN.h>
     #include <perl.h>

     /** my_eval_sv(code, error_check)
     ** kinda like eval_sv(),
     ** but we pop the return value off the stack
     **/
     SV* my_eval_sv(SV *sv, I32 croak_on_error)
     {
         dSP;
         SV* retval;
         STRLEN n_a;

     PUSHMARK(SP);
     eval_sv(sv, G_SCALAR);

     SPAGAIN;
     retval = POPs;
     PUTBACK;

     if (croak_on_error && SvTRUE(ERRSV))
      	croak(SvPVx(ERRSV, n_a));

     return retval;
      }

     /** match(string, pattern)
     **
     ** Used for matches in a scalar context.
     **
     ** Returns 1 if the match was successful; 0 otherwise.
     **/

     I32 match(SV *string, char *pattern)
     {
         SV *command = NEWSV(1099, 0), *retval;
         STRLEN n_a;

     sv_setpvf(command, "my $string = '%s'; $string =~ %s",
      	      SvPV(string,n_a), pattern);

     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);

     return SvIV(retval);
      }

     /** substitute(string, pattern)
     **
     ** Used for =~ operations that modify their left-hand side (s/// and tr///)
     **
     ** Returns the number of successful matches, and
     ** modifies the input string if there were any.
     **/

     I32 substitute(SV **string, char *pattern)
     {
         SV *command = NEWSV(1099, 0), *retval;
         STRLEN n_a;

     sv_setpvf(command, "$string = '%s'; ($string =~ %s)",
      	      SvPV(*string,n_a), pattern);

     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);

     *string = get_sv("string", FALSE);
     return SvIV(retval);
      }

     /** matches(string, pattern, matches)
     **
     ** Used for matches in an array context.
     **
     ** Returns the number of matches,
     ** and fills in **matches with the matching substrings
     **/

     I32 matches(SV *string, char *pattern, AV **match_list)
     {
         SV *command = NEWSV(1099, 0);
         I32 num_matches;
         STRLEN n_a;

     sv_setpvf(command, "my $string = '%s'; @array = ($string =~ %s)",
      	      SvPV(string,n_a), pattern);

     my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);

     *match_list = get_av("array", FALSE);
     num_matches = av_len(*match_list) + 1; /** assume $[ is 0 **/

     return num_matches;
      }

     main (int argc, char **argv, char **env)
     {
         PerlInterpreter *my_perl = perl_alloc();
         char *embedding[] = { "", "-e", "0" };
         AV *match_list;
         I32 num_matches, i;
         SV *text = NEWSV(1099,0);
         STRLEN n_a;

     perl_construct(my_perl);
     perl_parse(my_perl, NULL, 3, embedding, NULL);

     sv_setpv(text, "When he is at a convenience store and the bill comes to some amount like 76 cents, Maynard is aware that there is something he *should* do, something that will enable him to get back a quarter, but he has no idea *what*.  He fumbles through his red squeezey changepurse and gives the boy three extra pennies with his dollar, hoping that he might luck into the correct amount.  The boy gives him back two of his own pennies and then the big shiny quarter that is his prize. -RICHH");

     if (match(text, "m/quarter/")) /** Does text contain 'quarter'? **/
      	printf("match: Text contains the word 'quarter'.\n\n");
     else
      	printf("match: Text doesn't contain the word 'quarter'.\n\n");

     if (match(text, "m/eighth/")) /** Does text contain 'eighth'? **/
      	printf("match: Text contains the word 'eighth'.\n\n");
     else
      	printf("match: Text doesn't contain the word 'eighth'.\n\n");

     /** Match all occurrences of /wi../ **/
     num_matches = matches(text, "m/(wi..)/g", &match_list);
     printf("matches: m/(wi..)/g found %d matches...\n", num_matches);

     for (i = 0; i < num_matches; i++)
      	printf("match: %s\n", SvPV(*av_fetch(match_list, i, FALSE),n_a));
     printf("\n");

     /** Remove all vowels from text **/
     num_matches = substitute(&text, "s/[aeiou]//gi");
     if (num_matches) {
      	printf("substitute: s/[aeiou]//gi...%d substitutions made.\n",
      	       num_matches);
      	printf("Now text is: %s\n\n", SvPV(text,n_a));
     }

     /** Attempt a substitution **/
     if (!substitute(&text, "s/Perl/C/")) {
      	printf("substitute: s/Perl/C...No substitution made.\n\n");
     }

     SvREFCNT_dec(text);
     PL_perl_destruct_level = 1;
     perl_destruct(my_perl);
     perl_free(my_perl);
      }

   which produces the output (again, long lines have been wrapped here)

     match: Text contains the word 'quarter'.

     match: Text doesn't contain the word 'eighth'.

     matches: m/(wi..)/g found 2 matches...
     match: will
     match: with

     substitute: s/[aeiou]//gi...139 substitutions made.
     Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
     Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
     qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
     thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
     hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. -RCHH

     substitute: s/Perl/C...No substitution made.

Fiddling with the Perl stack from your C program
------------------------------------------------

   When trying to explain stacks, most computer science textbooks mumble
something about spring-loaded columns of cafeteria plates: the last thing
you pushed on the stack is the first thing you pop off.  That'll do for
our purposes: your C program will push some arguments onto "the Perl
stack", shut its eyes while some magic happens, and then pop the
results-the return value of your Perl subroutine-off the stack.

   First you'll need to know how to convert between C types and Perl
types, with newSViv() and sv_setnv() and newAV() and all their friends.
They're described in *Note Perlguts: perlguts, and *Note Perlapi: perlapi,.

   Then you'll need to know how to manipulate the Perl stack.  That's
described in *Note Perlcall: perlcall,.

   Once you've understood those, embedding Perl in C is easy.

   Because C has no builtin function for integer exponentiation, let's
make Perl's ** operator available to it (this is less useful than it
sounds, because Perl implements ** with C's *pow()* function).  First I'll
create a stub exponentiation function in *power.pl*:

     sub expo {
         my ($a, $b) = @_;
         return $a ** $b;
     }

   Now I'll create a C program, *power.c*, with a function *PerlPower()*
that contains all the perlguts necessary to push the two arguments into
*expo()* and to pop the return value out.  Take a deep breath...

     #include <EXTERN.h>
     #include <perl.h>

     static PerlInterpreter *my_perl;

     static void
     PerlPower(int a, int b)
     {
       dSP;                            /* initialize stack pointer      */
       ENTER;                          /* everything created after here */
       SAVETMPS;                       /* ...is a temporary variable.   */
       PUSHMARK(SP);                   /* remember the stack pointer    */
       XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
       XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
       PUTBACK;                      /* make local stack pointer global */
       call_pv("expo", G_SCALAR);      /* call the function             */
       SPAGAIN;                        /* refresh stack pointer         */
                                     /* pop the return value from stack */
       printf ("%d to the %dth power is %d.\n", a, b, POPi);
       PUTBACK;
       FREETMPS;                       /* free that return value        */
       LEAVE;                       /* ...and the XPUSHed "mortal" args.*/
     }

     int main (int argc, char **argv, char **env)
     {
       char *my_argv[] = { "", "power.pl" };

     my_perl = perl_alloc();
     perl_construct( my_perl );

     perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
     perl_run(my_perl);

     PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/

     perl_destruct(my_perl);
     perl_free(my_perl);
         }

   Compile and run:

     % cc -o power power.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

     % power
     3 to the 4th power is 81.

Maintaining a persistent interpreter
------------------------------------

   When developing interactive and/or potentially long-running
applications, it's a good idea to maintain a persistent interpreter rather
than allocating and constructing a new interpreter multiple times.  The
major reason is speed: since Perl will only be loaded into memory once.

   However, you have to be more cautious with namespace and variable
scoping when using a persistent interpreter.  In previous examples we've
been using global variables in the default package main.  We knew exactly
what code would be run, and assumed we could avoid variable collisions and
outrageous symbol table growth.

   Let's say your application is a server that will occasionally run Perl
code from some arbitrary file.  Your server has no way of knowing what
code it's going to run.  Very dangerous.

   If the file is pulled in by `perl_parse()', compiled into a newly
constructed interpreter, and subsequently cleaned out with
`perl_destruct()' afterwards, you're shielded from most namespace troubles.

   One way to avoid namespace collisions in this scenario is to translate
the filename into a guaranteed-unique package name, and then compile the
code into that package using `eval', *Note Perlfunc: perlfunc,.  In the
example below, each file will only be compiled once.  Or, the application
might choose to clean out the symbol table associated with the file after
it's no longer needed.  Using `call_argv', *Note Perlapi: perlapi,, We'll
call the subroutine `Embed::Persistent::eval_file' which lives in the file
`persistent.pl' and pass the filename and boolean cleanup/cache flag as
arguments.

   Note that the process will continue to grow for each file that it uses.
In addition, there might be AUTOLOADed subroutines and other conditions
that cause Perl's symbol table to grow.  You might want to add some logic
that keeps track of the process size, or restarts itself after a certain
number of requests, to ensure that memory consumption is minimized.
You'll also want to scope your variables with `my', *Note Perlfunc:
perlfunc, whenever possible.

     package Embed::Persistent;
     #persistent.pl

     use strict;
     our %Cache;
     use Symbol qw(delete_package);

     sub valid_package_name {
         my($string) = @_;
         $string =~ s/([^A-Za-z0-9\/])/sprintf("_%2x",unpack("C",$1))/eg;
         # second pass only for words starting with a digit
         $string =~ s|/(\d)|sprintf("/_%2x",unpack("C",$1))|eg;

     # Dress it up as a real package name
     $string =~ s|/|::|g;
     return "Embed" . $string;
      }

     sub eval_file {
         my($filename, $delete) = @_;
         my $package = valid_package_name($filename);
         my $mtime = -M $filename;
         if(defined $Cache{$package}{mtime}
            &&
            $Cache{$package}{mtime} <= $mtime)
         {
            # we have compiled this subroutine already,
            # it has not been updated on disk, nothing left to do
            print STDERR "already compiled $package->handler\n";
         }
         else {
            local *FH;
            open FH, $filename or die "open '$filename' $!";
            local($/) = undef;
            my $sub = <FH>;
            close FH;

     #wrap the code into a subroutine inside our unique package
     my $eval = qq{package $package; sub handler { $sub; }};
     {
         # hide our variables within this block
         my($filename,$mtime,$package,$sub);
         eval $eval;
     }
     die $@ if $@;

     #cache it unless we're cleaning out each time
     $Cache{$package}{mtime} = $mtime unless $delete;
          }

     eval {$package->handler;};
     die $@ if $@;

     delete_package($package) if $delete;

     #take a look if you want
     #print Devel::Symdump->rnew($package)->as_string, $/;
      }

     1;

     __END__

     /* persistent.c */
     #include <EXTERN.h>
     #include <perl.h>

     /* 1 = clean out filename's symbol table after each request, 0 = don't */
     #ifndef DO_CLEAN
     #define DO_CLEAN 0
     #endif

     static PerlInterpreter *perl = NULL;

     int
     main(int argc, char **argv, char **env)
     {
         char *embedding[] = { "", "persistent.pl" };
         char *args[] = { "", DO_CLEAN, NULL };
         char filename [1024];
         int exitstatus = 0;
         STRLEN n_a;

     if((perl = perl_alloc()) == NULL) {
        fprintf(stderr, "no memory!");
        exit(1);
     }
     perl_construct(perl);

     exitstatus = perl_parse(perl, NULL, 2, embedding, NULL);

     if(!exitstatus) {
        exitstatus = perl_run(perl);

     while(printf("Enter file name: ") && gets(filename)) {

     /* call the subroutine, passing it the filename as an argument */
     args[0] = filename;
     call_argv("Embed::Persistent::eval_file",
                    G_DISCARD | G_EVAL, args);

     /* check $@ */
     if(SvTRUE(ERRSV))
         fprintf(stderr, "eval error: %s\n", SvPV(ERRSV,n_a));
             }
          }

     PL_perl_destruct_level = 0;
     perl_destruct(perl);
     perl_free(perl);
     exit(exitstatus);
      }

   Now compile:

     % cc -o persistent persistent.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

   Here's a example script file:

     #test.pl
     my $string = "hello";
     foo($string);

     sub foo {
         print "foo says: @_\n";
     }

   Now run:

     % persistent
     Enter file name: test.pl
     foo says: hello
     Enter file name: test.pl
     already compiled Embed::test_2epl->handler
     foo says: hello
     Enter file name: ^C

Maintaining multiple interpreter instances
------------------------------------------

   Some rare applications will need to create more than one interpreter
during a session.  Such an application might sporadically decide to
release any resources associated with the interpreter.

   The program must take care to ensure that this takes place before the
next interpreter is constructed.  By default, the global variable
`PL_perl_destruct_level' is set to 0, since extra cleaning isn't needed
when a program has only one interpreter.

   Setting `PL_perl_destruct_level' to 1 makes everything squeaky clean:

     PL_perl_destruct_level = 1;

     while(1) {
         ...
         /* reset global variables here with PL_perl_destruct_level = 1 */
         perl_construct(my_perl);
         ...
         /* clean and reset _everything_ during perl_destruct */
         perl_destruct(my_perl);
         perl_free(my_perl);
         ...
         /* let's go do it again! */
     }

   When *perl_destruct()* is called, the interpreter's syntax parse tree
and symbol tables are cleaned up, and global variables are reset.

   Now suppose we have more than one interpreter instance running at the
same time.  This is feasible, but only if you used the `-DMULTIPLICITY'
flag when building Perl.  By default, that sets `PL_perl_destruct_level'
to 1.

   Let's give it a try:

     #include <EXTERN.h>
     #include <perl.h>

     /* we're going to embed two interpreters */
     /* we're going to embed two interpreters */

     #define SAY_HELLO "-e", "print qq(Hi, I'm $^X\n)"

     int main(int argc, char **argv, char **env)
     {
         PerlInterpreter
             *one_perl = perl_alloc(),
             *two_perl = perl_alloc();
         char *one_args[] = { "one_perl", SAY_HELLO };
         char *two_args[] = { "two_perl", SAY_HELLO };

     perl_construct(one_perl);
     perl_construct(two_perl);

     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);

     perl_run(one_perl);
     perl_run(two_perl);

     perl_destruct(one_perl);
     perl_destruct(two_perl);

     perl_free(one_perl);
     perl_free(two_perl);
      }

   Compile as usual:

     % cc -o multiplicity multiplicity.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

   Run it, Run it:

     % multiplicity
     Hi, I'm one_perl
     Hi, I'm two_perl

Using Perl modules, which themselves use C libraries, from your C program
-------------------------------------------------------------------------

   If you've played with the examples above and tried to embed a script
that *use()*s a Perl module (such as Socket) which itself uses a C or C++
library, this probably happened:

     Can't load module Socket, dynamic loading not available in this perl.
      (You may need to build a new perl executable which either supports
      dynamic loading or has the Socket module statically linked into it.)

   What's wrong?

   Your interpreter doesn't know how to communicate with these extensions
on its own.  A little glue will help.  Up until now you've been calling
*perl_parse()*, handing it NULL for the second argument:

     perl_parse(my_perl, NULL, argc, my_argv, NULL);

   That's where the glue code can be inserted to create the initial
contact between Perl and linked C/C++ routines.  Let's take a look some
pieces of *perlmain.c* to see how Perl does this:

     #ifdef __cplusplus
     #  define EXTERN_C extern "C"
     #else
     #  define EXTERN_C extern
     #endif

     static void xs_init (void);

     EXTERN_C void boot_DynaLoader (CV* cv);
     EXTERN_C void boot_Socket (CV* cv);

     EXTERN_C void
     xs_init()
     {
            char *file = __FILE__;
            /* DynaLoader is a special case */
            newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
            newXS("Socket::bootstrap", boot_Socket, file);
     }

   Simply put: for each extension linked with your Perl executable
(determined during its initial configuration on your computer or when
adding a new extension), a Perl subroutine is created to incorporate the
extension's routines.  Normally, that subroutine is named
*Module::bootstrap()* and is invoked when you say *use Module*.  In turn,
this hooks into an XSUB, *boot_Module*, which creates a Perl counterpart
for each of the extension's XSUBs.  Don't worry about this part; leave
that to the xsubpp and extension authors.  If your extension is
dynamically loaded, DynaLoader creates *Module::bootstrap()* for you on
the fly.  In fact, if you have a working DynaLoader then there is rarely
any need to link in any other extensions statically.

   Once you have this code, slap it into the second argument of
*perl_parse()*:

     perl_parse(my_perl, xs_init, argc, my_argv, NULL);

   Then compile:

     % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

     % interp
       use Socket;
       use SomeDynamicallyLoadedModule;

     print "Now I can use extensions!\n"'

   ExtUtils::Embed can also automate writing the *xs_init* glue code.

     % perl -MExtUtils::Embed -e xsinit -- -o perlxsi.c
     % cc -c perlxsi.c `perl -MExtUtils::Embed -e ccopts`
     % cc -c interp.c  `perl -MExtUtils::Embed -e ccopts`
     % cc -o interp perlxsi.o interp.o `perl -MExtUtils::Embed -e ldopts`

   Consult *Note Perlxs: perlxs,, *Note Perlguts: perlguts,, and *Note
Perlapi: perlapi, for more details.

Embedding Perl under Win32
==========================

   At the time of this writing (5.004), there are two versions of Perl
which run under Win32.  (The two versions are merging in 5.005.)
Interfacing to ActiveState's Perl library is quite different from the
examples in this documentation, as significant changes were made to the
internal Perl API.  However, it is possible to embed ActiveState's Perl
runtime.  For details, see the Perl for Win32 FAQ at
http://www.perl.com/CPAN/doc/FAQs/win32/perlwin32faq.html.

   With the "official" Perl version 5.004 or higher, all the examples
within this documentation will compile and run untouched, although the
build process is slightly different between Unix and Win32.

   For starters, backticks don't work under the Win32 native command shell.
The ExtUtils::Embed kit on CPAN ships with a script called *genmake*,
which generates a simple makefile to build a program from a single C
source file.  It can be used like this:

     C:\ExtUtils-Embed\eg> perl genmake interp.c
     C:\ExtUtils-Embed\eg> nmake
     C:\ExtUtils-Embed\eg> interp -e "print qq{I'm embedded in Win32!\n}"

   You may wish to use a more robust environment such as the Microsoft
Developer Studio.  In this case, run this to generate perlxsi.c:

     perl -MExtUtils::Embed -e xsinit

   Create a new project and Insert -> Files into Project: perlxsi.c,
perl.lib, and your own source files, e.g. interp.c.  Typically you'll find
perl.lib in *C:\perl\lib\CORE*, if not, you should see the *CORE*
directory relative to `perl -V:archlib'.  The studio will also need this
path so it knows where to find Perl include files.  This path can be added
via the Tools -> Options -> Directories menu.  Finally, select Build ->
Build interp.exe and you're ready to go.

MORAL
=====

   You can sometimes *write faster code* in C, but you can always *write
code faster* in Perl.  Because you can use each from the other, combine
them as you wish.

AUTHOR
======

   Jon Orwant <`orwant@tpj.com'> and Doug MacEachern <`dougm@osf.org'>,
with small contributions from Tim Bunce, Tom Christiansen, Guy Decoux,
Hallvard Furuseth, Dov Grobgeld, and Ilya Zakharevich.

   Doug MacEachern has an article on embedding in Volume 1, Issue 4 of The
Perl Journal (http://tpj.com).  Doug is also the developer of the most
widely-used Perl embedding: the mod_perl system (perl.apache.org), which
embeds Perl in the Apache web server.  Oracle, Binary Evolution,
ActiveState, and Ben Sugars's nsapi_perl have used this model for Oracle,
Netscape and Internet Information Server Perl plugins.

   July 22, 1998

COPYRIGHT
=========

   Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant.
All Rights Reserved.

   Permission is granted to make and distribute verbatim copies of this
documentation provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of this
documentation under the conditions for verbatim copying, provided also
that they are marked clearly as modified versions, that the authors' names
and title are unchanged (though subtitles and additional authors' names
may be added), and that the entire resulting derived work is distributed
under the terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
documentation into another language, under the above conditions for
modified versions.


File: perl.info,  Node: perlfaq,  Next: perltoc,  Prev: perl5004delta,  Up: Top

frequently asked questions about Perl ($Date: 1999/05/23 20:38:02 $)
********************************************************************

NAME
====

   perlfaq - frequently asked questions about Perl ($Date: 1999/05/23
20:38:02 $)

DESCRIPTION
===========

   This document is structured into the following sections:

perlfaq: Structural overview of the FAQ.
     This document.

*Note Perlfaq1: perlfaq1,: General Questions About Perl
     Very general, high-level information about Perl.

        * What is Perl?

        * Who supports Perl?  Who develops it?  Why is it free?

        * Which version of Perl should I use?

        * What are perl4 and perl5?

        * What is perl6?

        * How stable is Perl?

        * Is Perl difficult to learn?

        * How does Perl compare with other languages like Java, Python,
          REXX, Scheme, or Tcl?

        * Can I do [task] in Perl?

        * When shouldn't I program in Perl?

        * What's the difference between "perl" and "Perl"?

        * Is it a Perl program or a Perl script?

        * What is a JAPH?

        * Where can I get a list of Larry Wall witticisms?

        * How can I convince my sysadmin/supervisor/employees to use
          version (5/5.005/Perl instead of some other language)?

*Note Perlfaq2: perlfaq2,: Obtaining and Learning about Perl
     Where to find source and documentation to Perl, support, and related
     matters.

        * What machines support Perl?  Where do I get it?

        * How can I get a binary version of Perl?

        * I don't have a C compiler on my system.  How can I compile perl?

        * I copied the Perl binary from one machine to another, but
          scripts don't work.

        * I grabbed the sources and tried to compile but gdbm/dynamic
          loading/malloc/linking/... failed.  How do I make it work?

        * What modules and extensions are available for Perl?  What is
          CPAN?  What does CPAN/src/... mean?

        * Is there an ISO or ANSI certified version of Perl?

        * Where can I get information on Perl?

        * What are the Perl newsgroups on USENET?  Where do I post
          questions?

        * Where should I post source code?

        * Perl Books

        * Perl in Magazines

        * Perl on the Net: FTP and WWW Access

        * What mailing lists are there for perl?

        * Archives of comp.lang.perl.misc

        * Where can I buy a commercial version of Perl?

        * Where do I send bug reports?

        * What is perl.com?

*Note Perlfaq3: perlfaq3,: Programming Tools
     Programmer tools and programming support.

        * How do I do (anything)?

        * How can I use Perl interactively?

        * Is there a Perl shell?

        * How do I debug my Perl programs?

        * How do I profile my Perl programs?

        * How do I cross-reference my Perl programs?

        * Is there a pretty-printer (formatter) for Perl?

        * Is there a ctags for Perl?

        * Is there an IDE or Windows Perl Editor?

        * Where can I get Perl macros for vi?

        * Where can I get perl-mode for emacs?

        * How can I use curses with Perl?

        * How can I use X or Tk with Perl?

        * How can I generate simple menus without using CGI or Tk?

        * What is undump?

        * How can I make my Perl program run faster?

        * How can I make my Perl program take less memory?

        * Is it unsafe to return a pointer to local data?

        * How can I free an array or hash so my program shrinks?

        * How can I make my CGI script more efficient?

        * How can I hide the source for my Perl program?

        * How can I compile my Perl program into byte code or C?

        * How can I compile Perl into Java?

        * How can I get `#!perl' to work on [MS-DOS,NT,...]?

        * Can I write useful perl programs on the command line?

        * Why don't perl one-liners work on my DOS/Mac/VMS system?

        * Where can I learn about CGI or Web programming in Perl?

        * Where can I learn about object-oriented Perl programming?

        * Where can I learn about linking C with Perl? [h2xs, xsubpp]

        * I've read perlembed, perlguts, etc., but I can't embed perl in
          my C program, what am I doing wrong?

        * When I tried to run my script, I got this message. What does it
          mean?

        * What's MakeMaker?

*Note Perlfaq4: perlfaq4,: Data Manipulation
     Manipulating numbers, dates, strings, arrays, hashes, and
     miscellaneous data issues.

        * Why am I getting long decimals (eg, 19.9499999999999) instead of
          the numbers I should be getting (eg, 19.95)?

        * Why isn't my octal data interpreted correctly?

        * Does Perl have a round() function?  What about ceil() and
          floor()?  Trig functions?

        * How do I convert bits into ints?

        * Why doesn't & work the way I want it to?

        * How do I multiply matrices?

        * How do I perform an operation on a series of integers?

        * How can I output Roman numerals?

        * Why aren't my random numbers random?

        * How do I find the week-of-the-year/day-of-the-year?

        * How do I find the current century or millennium?

        * How can I compare two dates and find the difference?

        * How can I take a string and turn it into epoch seconds?

        * How can I find the Julian Day?

        * How do I find yesterday's date?

        * Does Perl have a year 2000 problem?  Is Perl Y2K compliant?

        * How do I validate input?

        * How do I unescape a string?

        * How do I remove consecutive pairs of characters?

        * How do I expand function calls in a string?

        * How do I find matching/nesting anything?

        * How do I reverse a string?

        * How do I expand tabs in a string?

        * How do I reformat a paragraph?

        * How can I access/change the first N letters of a string?

        * How do I change the Nth occurrence of something?

        * How can I count the number of occurrences of a substring within
          a string?

        * How do I capitalize all the words on one line?

        * How can I split a [character] delimited string except when
          inside [character]? (Comma-separated files)

        * How do I strip blank space from the beginning/end of a string?

        * How do I pad a string with blanks or pad a number with zeroes?

        * How do I extract selected columns from a string?

        * How do I find the soundex value of a string?

        * How can I expand variables in text strings?

        * What's wrong with always quoting "$vars"?

        * Why don't my <<HERE documents work?

        * What is the difference between a list and an array?

        * What is the difference between $array[1] and @array[1]?

        * How can I remove duplicate elements from a list or array?

        * How can I tell whether a list or array contains a certain
          element?

        * How do I compute the difference of two arrays?  How do I compute
          the intersection of two arrays?

        * How do I test whether two arrays or hashes are equal?

        * How do I find the first array element for which a condition is
          true?

        * How do I handle linked lists?

        * How do I handle circular lists?

        * How do I shuffle an array randomly?

        * How do I process/modify each element of an array?

        * How do I select a random element from an array?

        * How do I permute N elements of a list?

        * How do I sort an array by (anything)?

        * How do I manipulate arrays of bits?

        * Why does defined() return true on empty arrays and hashes?

        * How do I process an entire hash?

        * What happens if I add or remove keys from a hash while iterating
          over it?

        * How do I look up a hash element by value?

        * How can I know how many entries are in a hash?

        * How do I sort a hash (optionally by value instead of key)?

        * How can I always keep my hash sorted?

        * What's the difference between "delete" and "undef" with hashes?

        * Why don't my tied hashes make the defined/exists distinction?

        * How do I reset an each() operation part-way through?

        * How can I get the unique keys from two hashes?

        * How can I store a multidimensional array in a DBM file?

        * How can I make my hash remember the order I put elements into it?

        * Why does passing a subroutine an undefined element in a hash
          create it?

        * How can I make the Perl equivalent of a C structure/C++
          class/hash or array of hashes or arrays?

        * How can I use a reference as a hash key?

        * How do I handle binary data correctly?

        * How do I determine whether a scalar is a
          number/whole/integer/float?

        * How do I keep persistent data across program calls?

        * How do I print out or copy a recursive data structure?

        * How do I define methods for every class/object?

        * How do I verify a credit card checksum?

        * How do I pack arrays of doubles or floats for XS code?

*Note Perlfaq5: perlfaq5,: Files and Formats
     I/O and the "f" issues: filehandles, flushing, formats and footers.

        * How do I flush/unbuffer an output filehandle?  Why must I do
          this?

        * How do I change one line in a file/delete a line in a
          file/insert a line in the middle of a file/append to the
          beginning of a file?

        * How do I count the number of lines in a file?

        * How do I make a temporary file name?

        * How can I manipulate fixed-record-length files?

        * How can I make a filehandle local to a subroutine?  How do I
          pass filehandles between subroutines?  How do I make an array of
          filehandles?

        * How can I use a filehandle indirectly?

        * How can I set up a footer format to be used with write()?

        * How can I write() into a string?

        * How can I output my numbers with commas added?

        * How can I translate tildes (~) in a filename?

        * How come when I open a file read-write it wipes it out?

        * Why do I sometimes get an "Argument list too long" when I use
          <*>?

        * Is there a leak/bug in glob()?

        * How can I open a file with a leading ">" or trailing blanks?

        * How can I reliably rename a file?

        * How can I lock a file?

        * Why can't I just open(FH, ">file.lock")?

        * I still don't get locking.  I just want to increment the number
          in the file.  How can I do this?

        * How do I randomly update a binary file?

        * How do I get a file's timestamp in perl?

        * How do I set a file's timestamp in perl?

        * How do I print to more than one file at once?

        * How can I read in an entire file all at once?

        * How can I read in a file by paragraphs?

        * How can I read a single character from a file?  From the
          keyboard?

        * How can I tell whether there's a character waiting on a
          filehandle?

        * How do I do a `tail -f' in perl?

        * How do I dup() a filehandle in Perl?

        * How do I close a file descriptor by number?

        * Why can't I use "C:\temp\foo" in DOS paths?  What doesn't
          `C:\temp\foo.exe` work?

        * Why doesn't glob("*.*") get all the files?

        * Why does Perl let me delete read-only files?  Why does -i
          clobber protected files?  Isn't this a bug in Perl?

        * How do I select a random line from a file?

        * Why do I get weird spaces when I print an array of lines?

*Note Perlfaq6: perlfaq6,: Regexps
     Pattern matching and regular expressions.

        * How can I hope to use regular expressions without creating
          illegible and unmaintainable code?

        * I'm having trouble matching over more than one line.  What's
          wrong?

        * How can I pull out lines between two patterns that are
          themselves on different lines?

        * I put a regular expression into $/ but it didn't work. What's
          wrong?

        * How do I substitute case insensitively on the LHS, but
          preserving case on the RHS?

        * How can I make `\w' match national character sets?

        * How can I match a locale-smart version of `/[a-zA-Z]/'?

        * How can I quote a variable to use in a regex?

        * What is `/o' really for?

        * How do I use a regular expression to strip C style comments from
          a file?

        * Can I use Perl regular expressions to match balanced text?

        * What does it mean that regexes are greedy?  How can I get around
          it?

        * How do I process each word on each line?

        * How can I print out a word-frequency or line-frequency summary?

        * How can I do approximate matching?

        * How do I efficiently match many regular expressions at once?

        * Why don't word-boundary searches with `\b' work for me?

        * Why does using $&, $`, or $' slow my program down?

        * What good is `\G' in a regular expression?

        * Are Perl regexes DFAs or NFAs?  Are they POSIX compliant?

        * What's wrong with using grep or map in a void context?

        * How can I match strings with multibyte characters?

        * How do I match a pattern that is supplied by the user?

*Note Perlfaq7: perlfaq7,: General Perl Language Issues
     General Perl language issues that don't clearly fit into any of the
     other sections.

        * Can I get a BNF/yacc/RE for the Perl language?

        * What are all these $@%&* punctuation signs, and how do I know
          when to use them?

        * Do I always/never have to quote my strings or use semicolons and
          commas?

        * How do I skip some return values?

        * How do I temporarily block warnings?

        * What's an extension?

        * Why do Perl operators have different precedence than C operators?

        * How do I declare/create a structure?

        * How do I create a module?

        * How do I create a class?

        * How can I tell if a variable is tainted?

        * What's a closure?

        * What is variable suicide and how can I prevent it?

        * How can I pass/return a {Function, FileHandle, Array, Hash,
          Method, Regex}?

        * How do I create a static variable?

        * What's the difference between dynamic and lexical (static)
          scoping?  Between local() and my()?

        * How can I access a dynamic variable while a similarly named
          lexical is in scope?

        * What's the difference between deep and shallow binding?

        * Why doesn't "my($foo) = <FILE>;" work right?

        * How do I redefine a builtin function, operator, or method?

        * What's the difference between calling a function as &foo and
          foo()?

        * How do I create a switch or case statement?

        * How can I catch accesses to undefined
          variables/functions/methods?

        * Why can't a method included in this same file be found?

        * How can I find out my current package?

        * How can I comment out a large block of perl code?

        * How do I clear a package?

        * How can I use a variable as a variable name?

*Note Perlfaq8: perlfaq8,: System Interaction
     Interprocess communication (IPC), control over the user-interface
     (keyboard, screen and pointing devices).

        * How do I find out which operating system I'm running under?

        * How come exec() doesn't return?

        * How do I do fancy stuff with the keyboard/screen/mouse?

        * How do I print something out in color?

        * How do I read just one key without waiting for a return key?

        * How do I check whether input is ready on the keyboard?

        * How do I clear the screen?

        * How do I get the screen size?

        * How do I ask the user for a password?

        * How do I read and write the serial port?

        * How do I decode encrypted password files?

        * How do I start a process in the background?

        * How do I trap control characters/signals?

        * How do I modify the shadow password file on a Unix system?

        * How do I set the time and date?

        * How can I sleep() or alarm() for under a second?

        * How can I measure time under a second?

        * How can I do an atexit() or setjmp()/longjmp()? (Exception
          handling)

        * Why doesn't my sockets program work under System V (Solaris)?
          What does the error message "Protocol not supported" mean?

        * How can I call my system's unique C functions from Perl?

        * Where do I get the include files to do ioctl() or syscall()?

        * Why do setuid perl scripts complain about kernel problems?

        * How can I open a pipe both to and from a command?

        * Why can't I get the output of a command with system()?

        * How can I capture STDERR from an external command?

        * Why doesn't open() return an error when a pipe open fails?

        * What's wrong with using backticks in a void context?

        * How can I call backticks without shell processing?

        * Why can't my script read from STDIN after I gave it EOF (^D on
          Unix, ^Z on MS-DOS)?

        * How can I convert my shell script to perl?

        * Can I use perl to run a telnet or ftp session?

        * How can I write expect in Perl?

        * Is there a way to hide perl's command line from programs such as
          "ps"?

        * I {changed directory, modified my environment} in a perl script.
          How come the change disappeared when I exited the script?  How
          do I get my changes to be visible?

        * How do I close a process's filehandle without waiting for it to
          complete?

        * How do I fork a daemon process?

        * How do I make my program run with sh and csh?

        * How do I find out if I'm running interactively or not?

        * How do I timeout a slow event?

        * How do I set CPU limits?

        * How do I avoid zombies on a Unix system?

        * How do I use an SQL database?

        * How do I make a system() exit on control-C?

        * How do I open a file without blocking?

        * How do I install a module from CPAN?

        * What's the difference between require and use?

        * How do I keep my own module/library directory?

        * How do I add the directory my program lives in to the
          module/library search path?

        * How do I add a directory to my include path at runtime?

        * What is socket.ph and where do I get it?

*Note Perlfaq9: perlfaq9,: Networking
     Networking, the Internet, and a few on the web.

        * My CGI script runs from the command line but not the browser.
          (500 Server Error)

        * How can I get better error messages from a CGI program?

        * How do I remove HTML from a string?

        * How do I extract URLs?

        * How do I download a file from the user's machine?  How do I open
          a file on another machine?

        * How do I make a pop-up menu in HTML?

        * How do I fetch an HTML file?

        * How do I automate an HTML form submission?

        * How do I decode or create those %-encodings on the web?

        * How do I redirect to another page?

        * How do I put a password on my web pages?

        * How do I edit my .htpasswd and .htgroup files with Perl?

        * How do I make sure users can't enter values into a form that
          cause my CGI script to do bad things?

        * How do I parse a mail header?

        * How do I decode a CGI form?

        * How do I check a valid mail address?

        * How do I decode a MIME/BASE64 string?

        * How do I return the user's mail address?

        * How do I send mail?

        * How do I read mail?

        * How do I find out my hostname/domainname/IP address?

        * How do I fetch a news article or the active newsgroups?

        * How do I fetch/put an FTP file?

        * How can I do RPC in Perl?

Where to get this document
--------------------------

   This document is posted regularly to comp.lang.perl.announce and
several other related newsgroups.  It is available in a variety of formats
from CPAN in the /CPAN/doc/FAQs/FAQ/ directory, or on the web at
http://www.perl.com/perl/faq/ .

How to contribute to this document
----------------------------------

   You may mail corrections, additions, and suggestions to
perlfaq-suggestions@perl.com .  This alias should not be used to *ask*
FAQs.  It's for fixing the current FAQ.  Send questions to the
comp.lang.perl.misc newsgroup.

What will happen if you mail your Perl programming problems to the authors
--------------------------------------------------------------------------

   Your questions will probably go unread, unless they're suggestions of
new questions to add to the FAQ, in which case they should have gone to
the perlfaq-suggestions@perl.com instead.

   You should have read section 2 of this faq.  There you would have
learned that comp.lang.perl.misc is the appropriate place to go for free
advice.  If your question is really important and you require a prompt and
correct answer, you should hire a consultant.

Credits
=======

   When I first began the Perl FAQ in the late 80s, I never realized it
would have grown to over a hundred pages, nor that Perl would ever become
so popular and widespread.  This document could not have been written
without the tremendous help provided by Larry Wall and the rest of the
Perl Porters.

Author and Copyright Information
================================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

Bundled Distributions
---------------------

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in these files are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.

Disclaimer
----------

   This information is offered in good faith and in the hope that it may
be of use, but is not guaranteed to be correct, up to date, or suitable
for any particular purpose whatsoever.  The authors accept no liability in
respect of this information or its use.

Changes
=======

  1. Extensive updates from the net in preparation for 5.6 release.

  2. More minor touch-ups.  Added new question at the end of perlfaq7 on
     variable names within variables.

  3. Small touchups here and there.  Added all questions in this document
     as a sort of table of contents.

  4. Significant changes throughout in preparation for the 5.005 release.

  5. Style and whitespace changes from Chip, new question on reading one
     character at a time from a terminal using POSIX from Tom.

  6. Added http://www.oasis.leo.org/perl/ to *Note Perlfaq2: perlfaq2,.
     Style fix to *Note Perlfaq3: perlfaq3,.  Added floating point
     precision, fixed complex number arithmetic, cross-references, caveat
     for Text::Wrap, alternative answer for initial capitalizing, fixed
     incorrect regexp, added example of Tie::IxHash to *Note Perlfaq4:
     perlfaq4,.  Added example of passing and storing filehandles, added
     commify to *Note Perlfaq5: perlfaq5,.  Restored variable suicide, and
     added mass commenting to *Note Perlfaq7: perlfaq7,.  Added
     Net::Telnet, fixed backticks, added reader/writer pair to telnet
     question, added FindBin, grouped module questions together in *Note
     Perlfaq8: perlfaq8,.  Expanded caveats for the simple URL extractor,
     gave LWP example, added CGI security question, expanded on the mail
     address answer in *Note Perlfaq9: perlfaq9,.

  7. Added more info to the binary distribution section of *Note Perlfaq2:
     perlfaq2,.  Added Net::Telnet to *Note Perlfaq6: perlfaq6,.  Fixed
     typos in *Note Perlfaq8: perlfaq8,.  Added mail sending example to
     *Note Perlfaq9: perlfaq9,.  Added Merlyn's columns to *Note Perlfaq2:
     perlfaq2,.

  8. Added the DATE to the NAME section, indicating which sections have
     changed.

     Mentioned SIGPIPE and *Note Perlipc: perlipc, in the forking open
     answer in *Note Perlfaq8: perlfaq8,.

     Fixed description of a regular expression in *Note Perlfaq4:
     perlfaq4,.

  9. Version Various typos fixed throughout.

     Added new question on Perl BNF on *Note Perlfaq7: perlfaq7,.

 10. Initial Release: 11/March/97 This is the initial release of version 3
     of the FAQ; consequently there have been no changes since its initial
     release.



File: perl.info,  Node: perlfaq1,  Next: Top,  Prev: Top,  Up: Top

General Questions About Perl ($Revision: 1.23 $, $Date: 1999/05/23 16:08:30 $)
******************************************************************************

NAME
====

   perlfaq1 - General Questions About Perl ($Revision: 1.23 $, $Date:
1999/05/23 16:08:30 $)

DESCRIPTION
===========

   This section of the FAQ answers very general, high-level questions
about Perl.

What is Perl?
-------------

   Perl is a high-level programming language with an eclectic heritage
written by Larry Wall and a cast of thousands.  It derives from the
ubiquitous C programming language and to a lesser extent from sed, awk,
the Unix shell, and at least a dozen other tools and languages.  Perl's
process, file, and text manipulation facilities make it particularly
well-suited for tasks involving quick prototyping, system utilities,
software tools, system management tasks, database access, graphical
programming, networking, and world wide web programming.  These strengths
make it especially popular with system administrators and CGI script
authors, but mathematicians, geneticists, journalists, and even managers
also use Perl.  Maybe you should, too.

Who supports Perl?  Who develops it?  Why is it free?
-----------------------------------------------------

   The original culture of the pre-populist Internet and the deeply-held
beliefs of Perl's author, Larry Wall, gave rise to the free and open
distribution policy of perl.  Perl is supported by its users.  The core,
the standard Perl library, the optional modules, and the documentation
you're reading now were all written by volunteers.  See the personal note
at the end of the README file in the perl source distribution for more
details.  See *Note Perlhist: perlhist, (new as of 5.005) for Perl's
milestone releases.

   In particular, the core development team (known as the Perl Porters)
are a rag-tag band of highly altruistic individuals committed to producing
better software for free than you could hope to purchase for money.  You
may snoop on pending developments via
news://news.perl.com/perl.porters-gw/ and the Deja archive at
http://www.deja.com/ using the perl.porters-gw newsgroup, or you can
subscribe to the mailing list by sending perl5-porters-request@perl.org a
subscription request.

   While the GNU project includes Perl in its distributions, there's no
such thing as "GNU Perl".  Perl is not produced nor maintained by the Free
Software Foundation.  Perl's licensing terms are also more open than GNU
software's tend to be.

   You can get commercial support of Perl if you wish, although for most
users the informal support will more than suffice.  See the answer to
"Where can I buy a commercial version of perl?" for more information.

Which version of Perl should I use?
-----------------------------------

   You should definitely use version 5.  Version 4 is old, limited, and no
longer maintained; its last patch (4.036) was in 1992, long ago and far
away.  Sure, it's stable, but so is anything that's dead; in fact, perl4
had been called a dead, flea-bitten camel carcass.  The most recent
production release is 5.005_03 (although 5.004_05 is still supported).
The most cutting-edge development release is 5.005_57.  Further references
to the Perl language in this document refer to the production release
unless otherwise specified.  There may be one or more official bug fixes
by the time you read this, and also perhaps some experimental versions on
the way to the next release.  All releases prior to 5.004 were subject to
buffer overruns, a grave security issue.

What are perl4 and perl5?
-------------------------

   Perl4 and perl5 are informal names for different versions of the Perl
programming language.  It's easier to say "perl5" than it is to say "the
5(.004) release of Perl", but some people have interpreted this to mean
there's a language called "perl5", which isn't the case.  Perl5 is merely
the popular name for the fifth major release (October 1994), while perl4
was the fourth major release (March 1991).  There was also a perl1 (in
January 1988), a perl2 (June 1988), and a perl3 (October 1989).

   The 5.0 release is, essentially, a ground-up rewrite of the original
perl source code from releases 1 through 4.  It has been modularized,
object-oriented, tweaked, trimmed, and optimized until it almost doesn't
look like the old code.  However, the interface is mostly the same, and
compatibility with previous releases is very high. See `"Perl4 to Perl5
Traps"', *Note Perltrap: perltrap,.

   To avoid the "what language is perl5?" confusion, some people prefer to
simply use "perl" to refer to the latest version of perl and avoid using
"perl5" altogether.  It's not really that big a deal, though.

   See *Note Perlhist: perlhist, for a history of Perl revisions.

What is perl6?
--------------

   Perl6 is a semi-jocular reference to the Topaz project.  Headed by Chip
Salzenberg, Topaz is yet-another ground-up rewrite of the current release
of Perl, one whose major goal is to create a more maintainable core than
found in release 5.  Written in nominally portable C++, Topaz hopes to
maintain 100% source-compatibility with previous releases of Perl but to
run significantly faster and smaller.  The Topaz team hopes to provide an
XS compatibility interface to allow most XS modules to work unchanged,
albeit perhaps without the efficiency that the new interface would allow.
New features in Topaz are as yet undetermined, and will be addressed once
compatibility and performance goals are met.

   If you are a hard-working C++ wizard with a firm command of Perl's
internals, and you would like to work on the project, send a request to
perl6-porters-request@perl.org to subscribe to the Topaz mailing list.

   There is no ETA for Topaz.  It is expected to be several years before it
achieves enough robustness, compatibility, portability, and performance to
replace perl5 for ordinary use by mere mortals.

How stable is Perl?
-------------------

   Production releases, which incorporate bug fixes and new functionality,
are widely tested before release.  Since the 5.000 release, we have
averaged only about one production release per year.

   Larry and the Perl development team occasionally make changes to the
internal core of the language, but all possible efforts are made toward
backward compatibility.  While not quite all perl4 scripts run flawlessly
under perl5, an update to perl should nearly never invalidate a program
written for an earlier version of perl (barring accidental bug fixes and
the rare new keyword).

Is Perl difficult to learn?
---------------------------

   No, Perl is easy to start learning - and easy to keep learning.  It
looks like most programming languages you're likely to have experience
with, so if you've ever written a C program, an awk script, a shell
script, or even a BASIC program, you're already part way there.

   Most tasks only require a small subset of the Perl language.  One of
the guiding mottos for Perl development is "there's more than one way to
do it" (TMTOWTDI, sometimes pronounced "tim toady").  Perl's learning
curve is therefore shallow (easy to learn) and long (there's a whole lot
you can do if you really want).

   Finally, because Perl is frequently (but not always, and certainly not
by definition) an interpreted language, you can write your programs and
test them without an intermediate compilation step, allowing you to
experiment and test/debug quickly and easily.  This ease of
experimentation flattens the learning curve even more.

   Things that make Perl easier to learn: Unix experience, almost any kind
of programming experience, an understanding of regular expressions, and
the ability to understand other people's code.  If there's something you
need to do, then it's probably already been done, and a working example is
usually available for free.  Don't forget the new perl modules, either.
They're discussed in Part 3 of this FAQ, along with CPAN, which is
discussed in Part 2.

How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?
-----------------------------------------------------------------------------------

   Favorably in some areas, unfavorably in others.  Precisely which areas
are good and bad is often a personal choice, so asking this question on
Usenet runs a strong risk of starting an unproductive Holy War.

   Probably the best thing to do is try to write equivalent code to do a
set of tasks.  These languages have their own newsgroups in which you can
learn about (but hopefully not argue about) them.

   Some comparison documents can be found at
http://language.perl.com/versus/ if you really can't stop yourself.

Can I do [task] in Perl?
------------------------

   Perl is flexible and extensible enough for you to use on virtually any
task, from one-line file-processing tasks to large, elaborate systems.
For many people, Perl serves as a great replacement for shell scripting.
For others, it serves as a convenient, high-level replacement for most of
what they'd program in low-level languages like C or C++.  It's ultimately
up to you (and possibly your management) which tasks you'll use Perl for
and which you won't.

   If you have a library that provides an API, you can make any component
of it available as just another Perl function or variable using a Perl
extension written in C or C++ and dynamically linked into your main perl
interpreter.  You can also go the other direction, and write your main
program in C or C++, and then link in some Perl code on the fly, to create
a powerful application.  See *Note Perlembed: perlembed,.

   That said, there will always be small, focused, special-purpose
languages dedicated to a specific problem domain that are simply more
convenient for certain kinds of problems.  Perl tries to be all things to
all people, but nothing special to anyone.  Examples of specialized
languages that come to mind include prolog and matlab.

When shouldn't I program in Perl?
---------------------------------

   When your manager forbids it - but do consider replacing them :-).

   Actually, one good reason is when you already have an existing
application written in another language that's all done (and done well),
or you have an application language specifically designed for a certain
task (e.g. prolog, make).

   For various reasons, Perl is probably not well-suited for real-time
embedded systems, low-level operating systems development work like device
drivers or context-switching code, complex multi-threaded shared-memory
applications, or extremely large applications.  You'll notice that perl is
not itself written in Perl.

   The new, native-code compiler for Perl may eventually reduce the
limitations given in the previous statement to some degree, but understand
that Perl remains fundamentally a dynamically typed language, not a
statically typed one.  You certainly won't be chastised if you don't trust
nuclear-plant or brain-surgery monitoring code to it.  And Larry will
sleep easier, too - Wall Street programs not withstanding. :-)

What's the difference between "perl" and "Perl"?
------------------------------------------------

   One bit.  Oh, you weren't talking ASCII? :-) Larry now uses "Perl" to
signify the language proper and "perl" the implementation of it, i.e. the
current interpreter.  Hence Tom's quip that "Nothing but perl can parse
Perl."  You may or may not choose to follow this usage.  For example,
parallelism means "awk and perl" and "Python and Perl" look OK, while "awk
and Perl" and "Python and perl" do not.  But never write "PERL", because
perl isn't really an acronym, apocryphal folklore and post-facto
expansions notwithstanding.

Is it a Perl program or a Perl script?
--------------------------------------

   Larry doesn't really care.  He says (half in jest) that "a script is
what you give the actors.  A program is what you give the audience."

   Originally, a script was a canned sequence of normally interactive
commands, that is, a chat script.  Something like a UUCP or PPP chat
script or an expect script fits the bill nicely, as do configuration
scripts run by a program at its start up, such `.cshrc' or `.ircrc', for
example.  Chat scripts were just drivers for existing programs, not
stand-alone programs in their own right.

   A computer scientist will correctly explain that all programs are
interpreted, and that the only question is at what level.  But if you ask
this question of someone who isn't a computer scientist, they might tell
you that a program has been compiled to physical machine code once, and
can then be run multiple times, whereas a *script* must be translated by a
program each time it's used.

   Perl programs are (usually) neither strictly compiled nor strictly
interpreted.  They can be compiled to a byte-code form (something of a
Perl virtual machine) or to completely different languages, like C or
assembly language.  You can't tell just by looking at it whether the
source is destined for a pure interpreter, a parse-tree interpreter, a
byte-code interpreter, or a native-code compiler, so it's hard to give a
definitive answer here.

   Now that "script" and "scripting" are terms that have been seized by
unscrupulous or unknowing marketeers for their own nefarious purposes,
they have begun to take on strange and often pejorative meanings, like
"non serious" or "not real programming".  Consequently, some Perl
programmers prefer to avoid them altogether.

What is a JAPH?
---------------

   These are the "just another perl hacker" signatures that some people
sign their postings with.  Randal Schwartz made these famous.  About 100
of the earlier ones are available from http://www.perl.com/CPAN/misc/japh .

Where can I get a list of Larry Wall witticisms?
------------------------------------------------

   Over a hundred quips by Larry, from postings of his or source code, can
be found at http://www.perl.com/CPAN/misc/lwall-quotes.txt.gz .

   Newer examples can be found by perusing Larry's postings:

     http://x1.dejanews.com/dnquery.xp?QRY=*&DBS=2&ST=PS&defaultOp=AND&LNG=ALL&format=terse&showsort=date&maxhits=100&subjects=&groups=&authors=larry@*wall.org&fromdate=&todate=

How can I convince my sysadmin/supervisor/employees to use version (5/5.005/Perl instead of some other language)?
-----------------------------------------------------------------------------------------------------------------

   If your manager or employees are wary of unsupported software, or
software which doesn't officially ship with your operating system, you
might try to appeal to their self-interest.  If programmers can be more
productive using and utilizing Perl constructs, functionality, simplicity,
and power, then the typical manager/supervisor/employee may be persuaded.
Regarding using Perl in general, it's also sometimes helpful to point out
that delivery times may be reduced using Perl, as compared to other
languages.

   If you have a project which has a bottleneck, especially in terms of
translation or testing, Perl almost certainly will provide a viable, and
quick solution.  In conjunction with any persuasion effort, you should not
fail to point out that Perl is used, quite extensively, and with extremely
reliable and valuable results, at many large computer software and/or
hardware companies throughout the world.  In fact, many Unix vendors now
ship Perl by default, and support is usually just a news-posting away, if
you can't find the answer in the *comprehensive* documentation, including
this FAQ.

   See http://www.perl.org/advocacy/ for more information.

   If you face reluctance to upgrading from an older version of perl, then
point out that version 4 is utterly unmaintained and unsupported by the
Perl Development Team.  Another big sell for Perl5 is the large number of
modules and extensions which greatly reduce development time for any given
task.  Also mention that the difference between version 4 and version 5 of
Perl is like the difference between awk and C++.  (Well, OK, maybe not
quite that distinct, but you get the idea.)  If you want support and a
reasonable guarantee that what you're developing will continue to work in
the future, then you have to run the supported version.  That probably
means running the 5.005 release, although 5.004 isn't that bad.  Several
important bugs were fixed from the 5.000 through 5.003 versions, though,
so try upgrading past them if possible.

   Of particular note is the massive bug hunt for buffer overflow problems
that went into the 5.004 release.  All releases prior to that, including
perl4, are considered insecure and should be upgraded as soon as possible.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997, 1998, 1999 Tom Christiansen and Nathan Torkington.
All rights reserved.

   When included as an integrated part of the Standard Distribution of
Perl or of its documentation (printed or otherwise), this works is covered
under Perl's Artistic Licence.  For separate distributions of all or part
of this FAQ outside of that, see *Note Perlfaq: perlfaq,.

   Irrespective of its distribution, all code examples here are in the
public domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you see
fit.  A simple comment in the code giving credit to the FAQ would be
courteous but is not required.


File: perl.info,  Node: perlfaq2,  Next: Top,  Prev: Top,  Up: Top

Obtaining and Learning about Perl ($Revision: 1.32 $, $Date: 1999/10/14 18:46:09 $)
***********************************************************************************

NAME
====

   perlfaq2 - Obtaining and Learning about Perl ($Revision: 1.32 $, $Date:
1999/10/14 18:46:09 $)

DESCRIPTION
===========

   This section of the FAQ answers questions about where to find source
and documentation for Perl, support, and related matters.

What machines support Perl?  Where do I get it?
-----------------------------------------------

   The standard release of Perl (the one maintained by the perl
development team) is distributed only in source code form.  You can find
this at http://www.perl.com/CPAN/src/latest.tar.gz , which in standard
Internet format (a gzipped archive in POSIX tar format).

   Perl builds and runs on a bewildering number of platforms.  Virtually
all known and current Unix derivatives are supported (Perl's native
platform), as are other systems like VMS, DOS, OS/2, Windows, QNX, BeOS,
and the Amiga.  There are also the beginnings of support for MPE/iX.

   Binary distributions for some proprietary platforms, including Apple
systems, can be found http://www.perl.com/CPAN/ports/ directory.  Because
these are not part of the standard distribution, they may and in fact do
differ from the base Perl port in a variety of ways.  You'll have to check
their respective release notes to see just what the differences are.
These differences can be either positive (e.g. extensions for the features
of the particular platform that are not supported in the source release of
perl) or negative (e.g.  might be based upon a less current source release
of perl).

How can I get a binary version of Perl?
---------------------------------------

   If you don't have a C compiler because your vendor for whatever reasons
did not include one with your system, the best thing to do is grab a
binary version of gcc from the net and use that to compile perl with.
CPAN only has binaries for systems that are terribly hard to get free
compilers for, not for Unix systems.

   Some URLs that might help you are:

     http://language.perl.com/info/software.html
     http://www.perl.com/pub/language/info/software.html#binary
     http://www.perl.com/CPAN/ports/

   Someone looking for a Perl for Win16 might look to Laszlo Molnar's djgpp
port in http://www.perl.com/CPAN/ports/msdos/ , which comes with clear
installation instructions.  A simple installation guide for MS-DOS using
Ilya Zakharevich's OS/2 port is available at
http://www.cs.ruu.nl/%7Epiet/perl5dos.html and similarly for Windows 3.1
at http://www.cs.ruu.nl/%7Epiet/perlwin3.html .

I don't have a C compiler on my system.  How can I compile perl?
----------------------------------------------------------------

   Since you don't have a C compiler, you're doomed and your vendor should
be sacrificed to the Sun gods.  But that doesn't help you.

   What you need to do is get a binary version of gcc for your system
first.  Consult the Usenet FAQs for your operating system for information
on where to get such a binary version.

I copied the Perl binary from one machine to another, but scripts don't work.
-----------------------------------------------------------------------------

   That's probably because you forgot libraries, or library paths differ.
You really should build the whole distribution on the machine it will
eventually live on, and then type make install.  Most other approaches are
doomed to failure.

   One simple way to check that things are in the right place is to print
out the hard-coded @INC which perl is looking for.

     % perl -e 'print join("\n",@INC)'

   If this command lists any paths which don't exist on your system, then
you may need to move the appropriate libraries to these locations, or
create symbolic links, aliases, or shortcuts appropriately.  @INC is also
printed as part of the output of

     % perl -V

   You might also want to check out `"How do I keep my own module', *Note
Perlfaq8: perlfaq8,.

I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed.  How do I make it work?
----------------------------------------------------------------------------------------------------------------------

   Read the INSTALL file, which is part of the source distribution.  It
describes in detail how to cope with most idiosyncrasies that the
Configure script can't work around for any given system or architecture.

What modules and extensions are available for Perl?  What is CPAN?  What does CPAN/src/... mean?
------------------------------------------------------------------------------------------------

   CPAN stands for Comprehensive Perl Archive Network, a huge archive
replicated on dozens of machines all over the world.  CPAN contains source
code, non-native ports, documentation, scripts, and many third-party
modules and extensions, designed for everything from commercial database
interfaces to keyboard/screen control to web walking and CGI scripts.  The
master machine for CPAN is ftp://ftp.funet.fi/pub/languages/perl/CPAN/,
but you can use the address http://www.perl.com/CPAN/CPAN.html to fetch a
copy from a "site near you".  See http://www.perl.com/CPAN (without a
slash at the end) for how this process works.

   CPAN/path/... is a naming convention for files available on CPAN sites.
CPAN indicates the base directory of a CPAN mirror, and the rest of the
path is the path from that directory to the file.  For instance, if you're
using ftp://ftp.funet.fi/pub/languages/perl/CPAN as your CPAN site, the
file CPAN/misc/japh file is downloadable as
ftp://ftp.funet.fi/pub/languages/perl/CPAN/misc/japh .

   Considering that there are hundreds of existing modules in the archive,
one probably exists to do nearly anything you can think of.  Current
categories under CPAN/modules/by-category/ include Perl core modules;
development support; operating system interfaces; networking, devices, and
interprocess communication; data type utilities; database interfaces; user
interfaces; interfaces to other languages; filenames, file systems, and
file locking; internationalization and locale; world wide web support;
server and daemon utilities; archiving and compression; image
manipulation; mail and news; control flow utilities; filehandle and I/O;
Microsoft Windows modules; and miscellaneous modules.

Is there an ISO or ANSI certified version of Perl?
--------------------------------------------------

   Certainly not.  Larry expects that he'll be certified before Perl is.

Where can I get information on Perl?
------------------------------------

   The complete Perl documentation is available with the Perl distribution.
If you have Perl installed locally, you probably have the documentation
installed as well: type `man perl' if you're on a system resembling Unix.
This will lead you to other important man pages, including how to set your
$MANPATH.  If you're not on a Unix system, access to the documentation
will be different; for example, it might be only in HTML format.  But all
proper Perl installations have fully-accessible documentation.

   You might also try `perldoc perl' in case your system doesn't have a
proper man command, or it's been misinstalled.  If that doesn't work, try
looking in /usr/local/lib/perl5/pod for documentation.

   If all else fails, consult the CPAN/doc directory, which contains the
complete documentation in various formats, including native pod, troff,
html, and plain text.  There's also a web page at
http://www.perl.com/perl/info/documentation.html that might help.

   Many good books have been written about Perl - see the section below
for more details.

   Tutorial documents are included in current or upcoming Perl releases
include *Note Perltoot: perltoot, for objects, *Note Perlopentut:
perlopentut, for file opening semantics, *Note Perlreftut: perlreftut, for
managing references, and *Note Perlxstut: perlxstut, for linking C and
Perl together.  There may be more by the time you read this.  The
following URLs might also be of assistance:

     http://language.perl.com/info/documentation.html
     http://reference.perl.com/query.cgi?tutorials

What are the Perl newsgroups on Usenet?  Where do I post questions?
-------------------------------------------------------------------

   The now defunct comp.lang.perl newsgroup has been superseded by the
following groups:

     comp.lang.perl.announce 		Moderated announcement group
     comp.lang.perl.misc     		Very busy group about Perl in general
     comp.lang.perl.moderated            Moderated discussion group
     comp.lang.perl.modules  		Use and development of Perl modules
     comp.lang.perl.tk           	Using Tk (and X) from Perl

     comp.infosystems.www.authoring.cgi 	Writing CGI scripts for the Web.

   There is also Usenet gateway to the mailing list used by the crack Perl
development team (perl5-porters) at news://news.perl.com/perl.porters-gw/ .

Where should I post source code?
--------------------------------

   You should post source code to whichever group is most appropriate, but
feel free to cross-post to comp.lang.perl.misc.  If you want to cross-post
to alt.sources, please make sure it follows their posting standards,
including setting the Followup-To header line to NOT include alt.sources;
see their FAQ (http://www.faqs.org/faqs/alt-sources-intro/) for details.

   If you're just looking for software, first use AltaVista
(http://www.altavista.com), Deja (http://www.deja.com), and search CPAN.
This is faster and more productive than just posting a request.

Perl Books
----------

   A number of books on Perl and/or CGI programming are available.  A few
of these are good, some are OK, but many aren't worth your money.  Tom
Christiansen maintains a list of these books, some with extensive reviews,
at http://www.perl.com/perl/critiques/index.html.

   The incontestably definitive reference book on Perl, written by the
creator of Perl, is now in its second edition:

     Programming Perl (the "Camel Book"):
     	by Larry Wall, Tom Christiansen, and Randal Schwartz
         ISBN 1-56592-149-6      (English)
         ISBN 4-89052-384-7      (Japanese)
     	URL: http://www.oreilly.com/catalog/pperl2/
     (French, German, Italian, and Hungarian translations also
     available)

   The companion volume to the Camel containing thousands of real-world
examples, mini-tutorials, and complete programs (first premiering at the
1998 Perl Conference), is:

     The Perl Cookbook (the "Ram Book"):
     	by Tom Christiansen and Nathan Torkington,
     		    with Foreword by Larry Wall
     	ISBN: 1-56592-243-3
     	URL:  http://perl.oreilly.com/cookbook/

   If you're already a hard-core systems programmer, then the Camel Book
might suffice for you to learn Perl from.  But if you're not, check out:

     Learning Perl (the "Llama Book"):
     	by Randal Schwartz and Tom Christiansen
     		    with Foreword by Larry Wall
     	ISBN: 1-56592-284-0
     	URL:  http://www.oreilly.com/catalog/lperl2/

   Despite the picture at the URL above, the second edition of "Llama
Book" really has a blue cover, and is updated for the 5.004 release of
Perl.  Various foreign language editions are available, including
*Learning Perl on Win32 Systems* (the Gecko Book).

   If you're not an accidental programmer, but a more serious and possibly
even degreed computer scientist who doesn't need as much hand-holding as
we try to provide in the Llama or its defurred cousin the Gecko, please
check out the delightful book, *Perl: The Programmer's Companion*, written
by Nigel Chapman.

   You can order O'Reilly books directly from O'Reilly & Associates,
1-800-998-9938.  Local/overseas is 1-707-829-0515.  If you can locate an
O'Reilly order form, you can also fax to 1-707-829-0104.  See
http://www.ora.com/ on the Web.

   What follows is a list of the books that the FAQ authors found
personally useful.  Your mileage may (but, we hope, probably won't) vary.

   Recommended books on (or mostly on) Perl follow; those marked with a
star may be ordered from O'Reilly.

References
          *Programming Perl
          	by Larry Wall, Tom Christiansen, and Randal L. Schwartz

          *Perl 5 Desktop Reference
              by Johan Vromans

          *Perl in a Nutshell
              by Ellen Siever, Stephan Spainhour, and Nathan Patwardhan

Tutorials
          *Learning Perl [2nd edition]
          	by Randal L. Schwartz and Tom Christiansen
          	    with foreword by Larry Wall

          *Learning Perl on Win32 Systems
          	by Randal L. Schwartz, Erik Olson, and Tom Christiansen,
          	    with foreword by Larry Wall

          Perl: The Programmer's Companion
          	by Nigel Chapman

          Cross-Platform Perl
          	by Eric F. Johnson

          MacPerl: Power and Ease
          	by Vicki Brown and Chris Nandor, foreword by Matthias Neeracher

Task-Oriented
          *The Perl Cookbook
          	by Tom Christiansen and Nathan Torkington
          	    with foreword by Larry Wall

          Perl5 Interactive Course [2nd edition]
          	by Jon Orwant

          *Advanced Perl Programming
          	by Sriram Srinivasan

          Effective Perl Programming
          	by Joseph Hall

Special Topics
          *Mastering Regular Expressions
          	by Jeffrey Friedl

          How to Set up and Maintain a World Wide Web Site [2nd edition]
          	by Lincoln Stein

          *Learning Perl/Tk
              by Nancy Walsh

Perl in Magazines
-----------------

   The first and only periodical devoted to All Things Perl, *The Perl
Journal* contains tutorials, demonstrations, case studies, announcements,
contests, and much more.  TPJ has columns on web development, databases,
Win32 Perl, graphical programming, regular expressions, and networking,
and sponsors the Obfuscated Perl Contest.  It is published quarterly under
the gentle hand of its editor, Jon Orwant.  See http://www.tpj.com/ or
send mail to subscriptions@tpj.com .

   Beyond this, magazines that frequently carry high-quality articles on
Perl are *Web Techniques* (see http://www.webtechniques.com/),
*Performance Computing* (http://www.performance-computing.com/), and
Usenix's newsletter/magazine to its members, *login:*, at
http://www.usenix.org/.  Randal's Web Technique's columns are available on
the web at http://www.stonehenge.com/merlyn/WebTechniques/.

Perl on the Net: FTP and WWW Access
-----------------------------------

   To get the best (and possibly cheapest) performance, pick a site from
the list below and use it to grab the complete list of mirror sites.  From
there you can find the quickest site for you.  Remember, the following
list is not the complete list of CPAN mirrors.

     http://www.perl.com/CPAN-local
     http://www.perl.com/CPAN	(redirects to an ftp mirror)
     ftp://cpan.valueclick.com/pub/CPAN/
     ftp://ftp.funet.fi/pub/languages/perl/CPAN/
     http://www.cs.ruu.nl/pub/PERL/CPAN/
     ftp://ftp.cs.colorado.edu/pub/perl/CPAN/

What mailing lists are there for Perl?
--------------------------------------

   Most of the major modules (Tk, CGI, libwww-perl) have their own mailing
lists.  Consult the documentation that came with the module for
subscription information.  The Perl Mongers attempt to maintain a list of
mailing lists at:

     http://www.perl.org/support/online_support.html#mail

Archives of comp.lang.perl.misc
-------------------------------

   Have you tried Deja or AltaVista?  Those are the best archives.  Just
look up "*perl*" as a newsgroup.

     http://www.deja.com/dnquery.xp?QRY=&DBS=2&ST=PS&defaultOp=AND&LNG=ALL&format=terse&showsort=date&maxhits=25&subjects=&groups=*perl*&authors=&fromdate=&todate=

   You'll probably want to trim that down a bit, though.

   You'll probably want more a sophisticated query and retrieval mechanism
than a file listing, preferably one that allows you to retrieve articles
using a fast-access indices, keyed on at least author, date, subject,
thread (as in "trn") and probably keywords.  The best solution the FAQ
authors know of is the MH pick command, but it is very slow to select on
18000 articles.

   If you have, or know where can be found, the missing sections, please
let perlfaq-suggestions@perl.com know.

Where can I buy a commercial version of Perl?
---------------------------------------------

   In a real sense, Perl already *is* commercial software: It has a license
that you can grab and carefully read to your manager. It is distributed in
releases and comes in well-defined packages. There is a very large user
community and an extensive literature.  The comp.lang.perl.* newsgroups
and several of the mailing lists provide free answers to your questions in
near real-time.  Perl has traditionally been supported by Larry, scores of
software designers and developers, and myriads of programmers, all working
for free to create a useful thing to make life better for everyone.

   However, these answers may not suffice for managers who require a
purchase order from a company whom they can sue should anything go awry.
Or maybe they need very serious hand-holding and contractual obligations.
Shrink-wrapped CDs with Perl on them are available from several sources if
that will help.  For example, many Perl books carry a Perl distribution on
them, as do the O'Reilly Perl Resource Kits (in both the Unix flavor and
in the proprietary Microsoft flavor); the free Unix distributions also all
come with Perl.

   Or you can purchase commercial incidence based support through the Perl
Clinic.  The following is a commercial from them:

   "The Perl Clinic is a commercial Perl support service operated by
ActiveState Tool Corp. and The Ingram Group.  The operators have many
years of in-depth experience with Perl applications and Perl internals on
a wide range of platforms.

   "Through our group of highly experienced and well-trained support
engineers, we will put our best effort into understanding your problem,
providing an explanation of the situation, and a recommendation on how to
proceed."

   Contact The Perl Clinic at:

     www.PerlClinic.com

     North America Pacific Standard Time (GMT-8)
     Tel:    1 604 606-4611 hours 8am-6pm
     Fax:    1 604 606-4640

     Europe (GMT)
     Tel:    00 44 1483 862814
     Fax:    00 44 1483 862801

   See also www.perl.com for updates on tutorials, training, and support.

Where do I send bug reports?
----------------------------

   If you are reporting a bug in the perl interpreter or the modules
shipped with Perl, use the *perlbug* program in the Perl distribution or
mail your report to perlbug@perl.com .

   If you are posting a bug with a non-standard port (see the answer to
"What platforms is Perl available for?"), a binary distribution, or a
non-standard module (such as Tk, CGI, etc), then please see the
documentation that came with it to determine the correct place to post
bugs.

   Read the perlbug(1) man page (perl5.004 or later) for more information.

What is perl.com? Perl Mongers? pm.org? perl.org?
-------------------------------------------------

   The perl.com domain is owned by Tom Christiansen, who created it as a
public service long before perl.org came about.  Despite the name, it's a
pretty non-commercial site meant to be a clearinghouse for information
about all things Perlian, accepting no paid advertisements, bouncy happy
GIFs, or silly Java applets on its pages.  The Perl Home Page at
http://www.perl.com/ is currently hosted on a T3 line courtesy of Songline
Systems, a software-oriented subsidiary of O'Reilly and Associates.  Other
starting points include

     http://language.perl.com/
     http://conference.perl.com/
     http://reference.perl.com/

   Perl Mongers is an advocacy organization for the Perl language.  For
details, see the Perl Mongers web site at http://www.perlmongers.org/.

   Perl Mongers uses the pm.org domain for services related to Perl user
groups.  See the Perl user group web site at http://www.pm.org/ for more
information about joining, starting, or requesting services for a Perl
user group.

   Perl Mongers also maintains the perl.org domain to provide general
support services to the Perl community, including the hosting of mailing
lists, web sites, and other services.  The web site http://www.perl.org/
is a general advocacy site for the Perl language, and there are many other
sub-domains for special topics, such as

     http://history.perl.org/
     http://bugs.perl.org/
     http://www.news.perl.org/

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as an integrated part of the Standard Distribution of
Perl or of its documentation (printed or otherwise), this works is covered
under Perl's Artistic License.  For separate distributions of all or part
of this FAQ outside of that, see *Note Perlfaq: perlfaq,.

   Irrespective of its distribution, all code examples here are in the
public domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you see
fit.  A simple comment in the code giving credit to the FAQ would be
courteous but is not required.


File: perl.info,  Node: perlfaq3,  Next: Top,  Prev: Top,  Up: Top

Programming Tools ($Revision: 1.38 $, $Date: 1999/05/23 16:08:30 $)
*******************************************************************

NAME
====

   perlfaq3 - Programming Tools ($Revision: 1.38 $, $Date: 1999/05/23
16:08:30 $)

DESCRIPTION
===========

   This section of the FAQ answers questions related to programmer tools
and programming support.

How do I do (anything)?
-----------------------

   Have you looked at CPAN (see *Note Perlfaq2: perlfaq2,)?  The chances
are that someone has already written a module that can solve your problem.
Have you read the appropriate man pages?  Here's a brief index:

     Basics	        perldata, perlvar, perlsyn, perlop, perlsub
     Execution	perlrun, perldebug
     Functions	perlfunc
     Objects		perlref, perlmod, perlobj, perltie
     Data Structures	perlref, perllol, perldsc
     Modules		perlmod, perlmodlib, perlsub
     Regexes		perlre, perlfunc, perlop, perllocale
     Moving to perl5	perltrap, perl
     Linking w/C	perlxstut, perlxs, perlcall, perlguts, perlembed
     Various 	http://www.perl.com/CPAN/doc/FMTEYEWTK/index.html
     		(not a man-page but still useful)

   A crude table of contents for the Perl man page set is found in *Note
Perltoc: perltoc,.

How can I use Perl interactively?
---------------------------------

   The typical approach uses the Perl debugger, described in the
perldebug(1) man page, on an "empty" program, like this:

     perl -de 42

   Now just type in any legal Perl code, and it will be immediately
evaluated.  You can also examine the symbol table, get stack backtraces,
check variable values, set breakpoints, and other operations typically
found in symbolic debuggers.

Is there a Perl shell?
----------------------

   In general, no.  The Shell.pm module (distributed with Perl) makes Perl
try commands which aren't part of the Perl language as shell commands.
perlsh from the source distribution is simplistic and uninteresting, but
may still be what you want.

How do I debug my Perl programs?
--------------------------------

   Have you tried `use warnings' or used -w?  They enable warnings for
dubious practices.

   Have you tried `use strict'?  It prevents you from using symbolic
references, makes you predeclare any subroutines that you call as bare
words, and (probably most importantly) forces you to predeclare your
variables with my or our or `use vars'.

   Did you check the returns of each and every system call?  The operating
system (and thus Perl) tells you whether they worked or not, and if not
why.

     open(FH, "> /etc/cantwrite")
       or die "Couldn't write to /etc/cantwrite: $!\n";

   Did you read *Note Perltrap: perltrap,?  It's full of gotchas for old
and new Perl programmers, and even has sections for those of you who are
upgrading from languages like *awk* and C.

   Have you tried the Perl debugger, described in *Note Perldebug:
perldebug,?  You can step through your program and see what it's doing and
thus work out why what it's doing isn't what it should be doing.

How do I profile my Perl programs?
----------------------------------

   You should get the Devel::DProf module from CPAN, and also use
Benchmark.pm from the standard distribution.  Benchmark lets you time
specific portions of your code, while Devel::DProf gives detailed
breakdowns of where your code spends its time.

   Here's a sample use of Benchmark:

     use Benchmark;

     @junk = `cat /etc/motd`;
     $count = 10_000;

     timethese($count, {
               'map' => sub { my @a = @junk;
     			   map { s/a/b/ } @a;
     			   return @a
     			 },
               'for' => sub { my @a = @junk;
     			   local $_;
     			   for (@a) { s/a/b/ };
     			   return @a },
              });

   This is what it prints (on one machine-your results will be dependent
on your hardware, operating system, and the load on your machine):

     Benchmark: timing 10000 iterations of for, map...
            for:  4 secs ( 3.97 usr  0.01 sys =  3.98 cpu)
            map:  6 secs ( 4.97 usr  0.00 sys =  4.97 cpu)

   Be aware that a good benchmark is very hard to write.  It only tests the
data you give it, and really proves little about differing complexities of
contrasting algorithms.

How do I cross-reference my Perl programs?
------------------------------------------

   The B::Xref module, shipped with the new, alpha-release Perl compiler
(not the general distribution prior to the 5.005 release), can be used to
generate cross-reference reports for Perl programs.

     perl -MO=Xref[,OPTIONS] scriptname.plx

Is there a pretty-printer (formatter) for Perl?
-----------------------------------------------

   There is no program that will reformat Perl as much as indent(1) does
for C.  The complex feedback between the scanner and the parser (this
feedback is what confuses the vgrind and emacs programs) makes it
challenging at best to write a stand-alone Perl parser.

   Of course, if you simply follow the guidelines in *Note Perlstyle:
perlstyle,, you shouldn't need to reformat.  The habit of formatting your
code as you write it will help prevent bugs.  Your editor can and should
help you with this.  The perl-mode for emacs can provide a remarkable
amount of help with most (but not all) code, and even less programmable
editors can provide significant assistance.  Tom swears by the following
settings in vi and its clones:

     set ai sw=4
     map! ^O {^M}^[O^T

   Now put that in your `.exrc' file (replacing the caret characters with
control characters) and away you go.  In insert mode, ^T is for indenting,
^D is for undenting, and ^O is for blockdenting - as it were.  If you
haven't used the last one, you're missing a lot.  A more complete example,
with comments, can be found at
http://www.perl.com/CPAN-local/authors/id/TOMC/scripts/toms.exrc.gz

   If you are used to using the *vgrind* program for printing out nice code
to a laser printer, you can take a stab at this using
http://www.perl.com/CPAN/doc/misc/tips/working.vgrind.entry, but the
results are not particularly satisfying for sophisticated code.

   The a2ps at http://www.infres.enst.fr/%7Edemaille/a2ps/ does lots of
things related to generating nicely printed output of documents.

Is there a ctags for Perl?
--------------------------

   There's a simple one at
http://www.perl.com/CPAN/authors/id/TOMC/scripts/ptags.gz which may do the
trick.  And if not, it's easy to hack into what you want.

Is there an IDE or Windows Perl Editor?
---------------------------------------

   If you're on Unix, you already have an IDE - Unix itself.  This powerful
IDE derives from its interoperability, flexibility, and configurability.
If you really want to get a feel for Unix-qua-IDE, the best thing to do is
to find some high-powered programmer whose native language is Unix.  Find
someone who has been at this for many years, and just sit back and watch
them at work.  They have created their own IDE, one that suits their own
tastes and aptitudes.  Quietly observe them edit files, move them around,
compile them, debug them, test them, etc.  The entire development *is*
integrated, like a top-of-the-line German sports car: functional,
powerful, and elegant.  You will be absolutely astonished at the speed and
ease exhibited by the native speaker of Unix in his home territory.  The
art and skill of a virtuoso can only be seen to be believed.  That is the
path to mastery - all these cobbled little IDEs are expensive toys
designed to sell a flashy demo using cheap tricks, and being optimized for
immediate but shallow understanding rather than enduring use, are but a
dim palimpsest of real tools.

   In short, you just have to learn the toolbox.  However, if you're not
on Unix, then your vendor probably didn't bother to provide you with a
proper toolbox on the so-called complete system that you forked out your
hard-earned cash on.

   PerlBuilder (XXX URL to follow) is an integrated development environment
for Windows that supports Perl development.  Perl programs are just plain
text, though, so you could download emacs for Windows (???) or a vi clone
(vim) which runs on for win32 (http://www.cs.vu.nl/%7Etmgil/vi.html).  If
you're transferring Windows files to Unix, be sure to transfer in ASCII
mode so the ends of lines are appropriately mangled.

Where can I get Perl macros for vi?
-----------------------------------

   For a complete version of Tom Christiansen's vi configuration file, see
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/toms.exrc.gz,
the standard benchmark file for vi emulators.  This runs best with nvi,
the current version of vi out of Berkeley, which incidentally can be built
with an embedded Perl interpreter - see http://www.perl.com/CPAN/src/misc.

Where can I get perl-mode for emacs?
------------------------------------

   Since Emacs version 19 patchlevel 22 or so, there have been both a
perl-mode.el and support for the Perl debugger built in.  These should
come with the standard Emacs 19 distribution.

   In the Perl source directory, you'll find a directory called "emacs",
which contains a cperl-mode that color-codes keywords, provides
context-sensitive help, and other nifty things.

   Note that the perl-mode of emacs will have fits with `"main'foo"'
(single quote), and mess up the indentation and highlighting.  You are
probably using `"main::foo"' in new Perl code anyway, so this shouldn't be
an issue.

How can I use curses with Perl?
-------------------------------

   The Curses module from CPAN provides a dynamically loadable object
module interface to a curses library.  A small demo can be found at the
directory http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/rep;
this program repeats a command and updates the screen as needed, rendering
*rep ps axu* similar to top.

How can I use X or Tk with Perl?
--------------------------------

   Tk is a completely Perl-based, object-oriented interface to the Tk
toolkit that doesn't force you to use Tcl just to get at Tk.  Sx is an
interface to the Athena Widget set.  Both are available from CPAN.  See the
directory http://www.perl.com/CPAN/modules/by-category/08_User_Interfaces/

   Invaluable for Perl/Tk programming are: the Perl/Tk FAQ at
http://w4.lns.cornell.edu/%7Epvhp/ptk/ptkTOC.html , the Perl/Tk Reference
Guide available at http://www.perl.com/CPAN-local/authors/Stephen_O_Lidie/
, and the online manpages at
http://www-users.cs.umn.edu/%7Eamundson/perl/perltk/toc.html .

How can I generate simple menus without using CGI or Tk?
--------------------------------------------------------

   The http://www.perl.com/CPAN/authors/id/SKUNZ/perlmenu.v4.0.tar.gz
module, which is curses-based, can help with this.

What is undump?
---------------

   See the next questions.

How can I make my Perl program run faster?
------------------------------------------

   The best way to do this is to come up with a better algorithm.  This
can often make a dramatic difference.  Chapter 8 in the Camel has some
efficiency tips in it you might want to look at.  Jon Bentley's book
"Programming Pearls" (that's not a misspelling!)  has some good tips on
optimization, too.  Advice on benchmarking boils down to: benchmark and
profile to make sure you're optimizing the right part, look for better
algorithms instead of microtuning your code, and when all else fails
consider just buying faster hardware.

   A different approach is to autoload seldom-used Perl code.  See the
AutoSplit and AutoLoader modules in the standard distribution for that.
Or you could locate the bottleneck and think about writing just that part
in C, the way we used to take bottlenecks in C code and write them in
assembler.  Similar to rewriting in C is the use of modules that have
critical sections written in C (for instance, the PDL module from CPAN).

   In some cases, it may be worth it to use the backend compiler to
produce byte code (saving compilation time) or compile into C, which will
certainly save compilation time and sometimes a small amount (but not
much) execution time.  See the question about compiling your Perl programs
for more on the compiler-the wins aren't as obvious as you'd hope.

   If you're currently linking your perl executable to a shared *libc.so*,
you can often gain a 10-25% performance benefit by rebuilding it to link
with a static libc.a instead.  This will make a bigger perl executable,
but your Perl programs (and programmers) may thank you for it.  See the
INSTALL file in the source distribution for more information.

   Unsubstantiated reports allege that Perl interpreters that use sfio
outperform those that don't (for I/O intensive applications).  To try
this, see the INSTALL file in the source distribution, especially the
"Selecting File I/O mechanisms" section.

   The undump program was an old attempt to speed up your Perl program by
storing the already-compiled form to disk.  This is no longer a viable
option, as it only worked on a few architectures, and wasn't a good
solution anyway.

How can I make my Perl program take less memory?
------------------------------------------------

   When it comes to time-space tradeoffs, Perl nearly always prefers to
throw memory at a problem.  Scalars in Perl use more memory than strings
in C, arrays take more than that, and hashes use even more.  While there's
still a lot to be done, recent releases have been addressing these issues.
For example, as of 5.004, duplicate hash keys are shared amongst all
hashes using them, so require no reallocation.

   In some cases, using substr() or vec() to simulate arrays can be highly
beneficial.  For example, an array of a thousand booleans will take at
least 20,000 bytes of space, but it can be turned into one 125-byte bit
vector for a considerable memory savings.  The standard Tie::SubstrHash
module can also help for certain types of data structure.  If you're
working with specialist data structures (matrices, for instance) modules
that implement these in C may use less memory than equivalent Perl modules.

   Another thing to try is learning whether your Perl was compiled with
the system malloc or with Perl's builtin malloc.  Whichever one it is, try
using the other one and see whether this makes a difference.  Information
about malloc is in the INSTALL file in the source distribution.  You can
find out whether you are using perl's malloc by typing `perl
-V:usemymalloc'.

Is it unsafe to return a pointer to local data?
-----------------------------------------------

   No, Perl's garbage collection system takes care of this.

     sub makeone {
     	my @a = ( 1 .. 10 );
     	return \@a;
     }

     for $i ( 1 .. 10 ) {
         push @many, makeone();
     }

     print $many[4][5], "\n";

     print "@many\n";

How can I free an array or hash so my program shrinks?
------------------------------------------------------

   You can't.  On most operating systems, memory allocated to a program
can never be returned to the system.  That's why long-running programs
sometimes re-exec themselves.  Some operating systems (notably, FreeBSD
and Linux) allegedly reclaim large chunks of memory that is no longer
used, but it doesn't appear to happen with Perl (yet).  The Mac appears to
be the only platform that will reliably (albeit, slowly) return memory to
the OS.

   We've had reports that on Linux (Redhat 5.1) on Intel, `undef $scalar'
will return memory to the system, while on Solaris 2.6 it won't.  In
general, try it yourself and see.

   However, judicious use of my() on your variables will help make sure
that they go out of scope so that Perl can free up their storage for use
in other parts of your program.  A global variable, of course, never goes
out of scope, so you can't get its space automatically reclaimed, although
undef()ing and/or delete()ing it will achieve the same effect.  In
general, memory allocation and de-allocation isn't something you can or
should be worrying about much in Perl, but even this capability
(preallocation of data types) is in the works.

How can I make my CGI script more efficient?
--------------------------------------------

   Beyond the normal measures described to make general Perl programs
faster or smaller, a CGI program has additional issues.  It may be run
several times per second.  Given that each time it runs it will need to be
re-compiled and will often allocate a megabyte or more of system memory,
this can be a killer.  Compiling into C *isn't going to help you* because
the process start-up overhead is where the bottleneck is.

   There are two popular ways to avoid this overhead.  One solution
involves running the Apache HTTP server (available from
http://www.apache.org/) with either of the mod_perl or mod_fastcgi plugin
modules.

   With mod_perl and the Apache::Registry module (distributed with
mod_perl), httpd will run with an embedded Perl interpreter which
pre-compiles your script and then executes it within the same address
space without forking.  The Apache extension also gives Perl access to the
internal server API, so modules written in Perl can do just about anything
a module written in C can.  For more on mod_perl, see
http://perl.apache.org/

   With the FCGI module (from CPAN) and the mod_fastcgi module (available
from http://www.fastcgi.com/) each of your Perl programs becomes a
permanent CGI daemon process.

   Both of these solutions can have far-reaching effects on your system
and on the way you write your CGI programs, so investigate them with care.

   See
http://www.perl.com/CPAN/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/
.

   A non-free, commercial product, "The Velocity Engine for Perl",
(http://www.binevolve.com/ or http://www.binevolve.com/velocigen/) might
also be worth looking at.  It will allow you to increase the performance
of your Perl programs, up to 25 times faster than normal CGI Perl by
running in persistent Perl mode, or 4 to 5 times faster without any
modification to your existing CGI programs. Fully functional evaluation
copies are available from the web site.

How can I hide the source for my Perl program?
----------------------------------------------

   Delete it. :-) Seriously, there are a number of (mostly unsatisfactory)
solutions with varying levels of "security".

   First of all, however, you *can't* take away read permission, because
the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is readable by
people on the web, though, only by people with access to the filesystem)
So you have to leave the permissions at the socially friendly 0755 level.

   Some people regard this as a security problem.  If your program does
insecure things, and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the source.
Security through obscurity, the name for hiding your bugs instead of
fixing them, is little security indeed.

   You can try using encryption via source filters (Filter::* from CPAN),
but any decent programmer will be able to decrypt it.  You can try using
the byte code compiler and interpreter described below, but the curious
might still be able to de-compile it.  You can try using the native-code
compiler described below, but crackers might be able to disassemble it.
These pose varying degrees of difficulty to people wanting to get at your
code, but none can definitively conceal it (this is true of every
language, not just Perl).

   If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive license will give you legal
security.  License your software and pepper it with threatening statements
like "This is unpublished proprietary software of XYZ Corp.  Your access
to it does not give you permission to use it blah blah blah."  We are not
lawyers, of course, so you should see a lawyer if you want to be sure your
license's wording will stand up in court.

How can I compile my Perl program into byte code or C?
------------------------------------------------------

   Malcolm Beattie has written a multifunction backend compiler, available
from CPAN, that can do both these things.  It is included in the perl5.005
release, but is still considered experimental.  This means it's fun to
play with if you're a programmer but not really for people looking for
turn-key solutions.

   Merely compiling into C does not in and of itself guarantee that your
code will run very much faster.  That's because except for lucky cases
where a lot of native type inferencing is possible, the normal Perl run
time system is still present and so your program will take just as long to
run and be just as big.  Most programs save little more than compilation
time, leaving execution no more than 10-30% faster.  A few rare programs
actually benefit significantly (like several times faster), but this takes
some tweaking of your code.

   You'll probably be astonished to learn that the current version of the
compiler generates a compiled form of your script whose executable is just
as big as the original perl executable, and then some.  That's because as
currently written, all programs are prepared for a full eval() statement.
You can tremendously reduce this cost by building a shared *libperl.so*
library and linking against that.  See the INSTALL podfile in the Perl
source distribution for details.  If you link your main perl binary with
this, it will make it minuscule.  For example, on one author's system,
`/usr/bin/perl' is only 11k in size!

   In general, the compiler will do nothing to make a Perl program smaller,
faster, more portable, or more secure.  In fact, it will usually hurt all
of those.  The executable will be bigger, your VM system may take longer
to load the whole thing, the binary is fragile and hard to fix, and
compilation never stopped software piracy in the form of crackers,
viruses, or bootleggers.  The real advantage of the compiler is merely
packaging, and once you see the size of what it makes (well, unless you
use a shared *libperl.so*), you'll probably want a complete Perl install
anyway.

How can I compile Perl into Java?
---------------------------------

   You can't.  Not yet, anyway.  You can integrate Java and Perl with the
Perl Resource Kit from O'Reilly and Associates.  See
http://www.oreilly.com/catalog/prkunix/ for more information.  The Java
interface will be supported in the core 5.6 release of Perl.

How can I get `#!perl' to work on [MS-DOS,NT,...]?
--------------------------------------------------

   For OS/2 just use

     extproc perl -S -your_switches

   as the first line in `*.cmd' file (-S due to a bug in cmd.exe's
`extproc' handling).  For DOS one should first invent a corresponding
batch file, and codify it in `ALTERNATIVE_SHEBANG' (see the INSTALL file
in the source distribution for more information).

   The Win95/NT installation, when using the ActiveState port of Perl,
will modify the Registry to associate the `.pl' extension with the perl
interpreter.  If you install another port, perhaps even building your own
Win95/NT Perl from the standard sources by using a Windows port of gcc
(e.g., with cygwin or mingw32), then you'll have to modify the Registry
yourself.  In addition to associating `.pl' with the interpreter, NT
people can use: `SET PATHEXT=%PATHEXT%;.PL' to let them run the program
`install-linux.pl' merely by typing `install-linux'.

   Macintosh Perl programs will have the appropriate Creator and Type, so
that double-clicking them will invoke the Perl application.

   *IMPORTANT!*: Whatever you do, PLEASE don't get frustrated, and just
throw the perl interpreter into your cgi-bin directory, in order to get
your programs working for a web server.  This is an EXTREMELY big security
risk.  Take the time to figure out how to do it correctly.

Can I write useful Perl programs on the command line?
-----------------------------------------------------

   Yes.  Read *Note Perlrun: perlrun, for more information.  Some examples
follow.  (These assume standard Unix shell quoting rules.)

     # sum first and last fields
     perl -lane 'print $F[0] + $F[-1]' *

     # identify text files
     perl -le 'for(@ARGV) {print if -f && -T _}' *

     # remove (most) comments from C program
     perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

     # make file a month younger than today, defeating reaper daemons
     perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *

     # find first unused uid
     perl -le '$i++ while getpwuid($i); print $i'

     # display reasonable manpath
     echo $PATH | perl -nl -072 -e '
     	s![^/+]*$!man!&&-d&&!$s{$_}++&&push@m,$_;END{print"@m"}'

   OK, the last one was actually an Obfuscated Perl Contest entry. :-)

Why don't Perl one-liners work on my DOS/Mac/VMS system?
--------------------------------------------------------

   The problem is usually that the command interpreters on those systems
have rather different ideas about quoting than the Unix shells under which
the one-liners were created.  On some systems, you may have to change
single-quotes to double ones, which you must *NOT* do on Unix or Plan9
systems.  You might also have to change a single % to a %%.

   For example:

     # Unix
     perl -e 'print "Hello world\n"'

     # DOS, etc.
     perl -e "print \"Hello world\n\""

     # Mac
     print "Hello world\n"
      (then Run "Myscript" or Shift-Command-R)

     # VMS
     perl -e "print ""Hello world\n"""

   The problem is that none of this is reliable: it depends on the command
interpreter.  Under Unix, the first two often work. Under DOS, it's
entirely possible neither works.  If 4DOS was the command shell, you'd
probably have better luck like this:

     perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

   Under the Mac, it depends which environment you are using.  The MacPerl
shell, or MPW, is much like Unix shells in its support for several quoting
variants, except that it makes free use of the Mac's non-ASCII characters
as control characters.

   Using qq(), q(), and qx(), instead of "double quotes", 'single quotes',
and `backticks`, may make one-liners easier to write.

   There is no general solution to all of this.  It is a mess, pure and
simple.  Sucks to be away from Unix, huh? :-)

   [Some of this answer was contributed by Kenneth Albanowski.]

Where can I learn about CGI or Web programming in Perl?
-------------------------------------------------------

   For modules, get the CGI or LWP modules from CPAN.  For textbooks, see
the two especially dedicated to web stuff in the question on books.  For
problems and questions related to the web, like "Why do I get 500 Errors"
or "Why doesn't it run from the browser right when it runs fine on the
command line", see these sources:

     WWW Security FAQ
         http://www.w3.org/Security/Faq/

     Web FAQ
         http://www.boutell.com/faq/

     CGI FAQ
         http://www.webthing.com/tutorials/cgifaq.html

     HTTP Spec
         http://www.w3.org/pub/WWW/Protocols/HTTP/

     HTML Spec
         http://www.w3.org/TR/REC-html40/
         http://www.w3.org/pub/WWW/MarkUp/

     CGI Spec
         http://www.w3.org/CGI/

     CGI Security FAQ
         http://www.go2net.com/people/paulp/cgi-security/safe-cgi.txt

Where can I learn about object-oriented Perl programming?
---------------------------------------------------------

   A good place to start is *Note Perltoot: perltoot,, and you can use
*Note Perlobj: perlobj, and *Note Perlbot: perlbot, for reference.
Perltoot didn't come out until the 5.004 release, but you can get a copy
(in pod, html, or postscript) from http://www.perl.com/CPAN/doc/FMTEYEWTK/
.

Where can I learn about linking C with Perl? [h2xs, xsubpp]
-----------------------------------------------------------

   If you want to call C from Perl, start with *Note Perlxstut: perlxstut,,
moving on to *Note Perlxs: perlxs,, `xsubpp' in this node, and *Note
Perlguts: perlguts,.  If you want to call Perl from C, then read *Note
Perlembed: perlembed,, *Note Perlcall: perlcall,, and *Note Perlguts:
perlguts,.  Don't forget that you can learn a lot from looking at how the
authors of existing extension modules wrote their code and solved their
problems.

I've read perlembed, perlguts, etc., but I can't embed perl in my C program, what am I doing wrong?
---------------------------------------------------------------------------------------------------

   Download the ExtUtils::Embed kit from CPAN and run `make test'.  If the
tests pass, read the pods again and again and again.  If they fail, see
`perlbug' in this node and send a bug report with the output of `make test
TEST_VERBOSE=1' along with `perl -V'.

When I tried to run my script, I got this message. What does it mean?
---------------------------------------------------------------------

   A complete list of Perl's error messages and warnings with explanatory
text can be found in *Note Perldiag: perldiag,. You can also use the
splain program (distributed with Perl) to explain the error messages:

     perl program 2>diag.out
     splain [-v] [-p] diag.out

   or change your program to explain the messages for you:

     use diagnostics;

   or

     use diagnostics -verbose;

What's MakeMaker?
-----------------

   This module (part of the standard Perl distribution) is designed to
write a Makefile for an extension module from a Makefile.PL.  For more
information, see *Note ExtUtils/MakeMaker: (pm.info)ExtUtils/MakeMaker,.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as an integrated part of the Standard Distribution of
Perl or of its documentation (printed or otherwise), this works is covered
under Perl's Artistic License.  For separate distributions of all or part
of this FAQ outside of that, see *Note Perlfaq: perlfaq,.

   Irrespective of its distribution, all code examples here are in the
public domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you see
fit.  A simple comment in the code giving credit to the FAQ would be
courteous but is not required.


File: perl.info,  Node: perlfaq4,  Next: Top,  Prev: Top,  Up: Top

Data Manipulation ($Revision: 1.49 $, $Date: 1999/05/23 20:37:49 $)
*******************************************************************

NAME
====

   perlfaq4 - Data Manipulation ($Revision: 1.49 $, $Date: 1999/05/23
20:37:49 $)

DESCRIPTION
===========

   The section of the FAQ answers question related to the manipulation of
data as numbers, dates, strings, arrays, hashes, and miscellaneous data
issues.

Data: Numbers
=============

Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?
-------------------------------------------------------------------------------------------------------------

   The infinite set that a mathematician thinks of as the real numbers can
only be approximate on a computer, since the computer only has a finite
number of bits to store an infinite number of, um, numbers.

   Internally, your computer represents floating-point numbers in binary.
Floating-point numbers read in from a file or appearing as literals in
your program are converted from their decimal floating-point
representation (eg, 19.95) to the internal binary representation.

   However, 19.95 can't be precisely represented as a binary
floating-point number, just like 1/3 can't be exactly represented as a
decimal floating-point number.  The computer's binary representation of
19.95, therefore, isn't exactly 19.95.

   When a floating-point number gets printed, the binary floating-point
representation is converted back to decimal.  These decimal numbers are
displayed in either the format you specify with printf(), or the current
output format for numbers (see `"$#"', *Note Perlvar: perlvar, if you use
print.  $# has a different default value in Perl5 than it did in Perl4.
Changing $# yourself is deprecated.)

   This affects all computer languages that represent decimal
floating-point numbers in binary, not just Perl.  Perl provides
arbitrary-precision decimal numbers with the Math::BigFloat module (part
of the standard Perl distribution), but mathematical operations are
consequently slower.

   To get rid of the superfluous digits, just use a format (eg,
`printf("%.2f", 19.95)') to get the required precision.  See
`"Floating-point Arithmetic"', *Note Perlop: perlop,.

Why isn't my octal data interpreted correctly?
----------------------------------------------

   Perl only understands octal and hex numbers as such when they occur as
literals in your program.  If they are read in from somewhere and
assigned, no automatic conversion takes place.  You must explicitly use
oct() or hex() if you want the values converted.  oct() interprets both
hex ("0x350") numbers and octal ones ("0350" or even without the leading
"0", like "377"), while hex() only converts hexadecimal ones, with or
without a leading "0x", like "0x255", "3A", "ff", or "deadbeef".

   This problem shows up most often when people try using chmod(), mkdir(),
umask(), or sysopen(), which all want permissions in octal.

     chmod(644,  $file);	# WRONG -- perl -w catches this
     chmod(0644, $file);	# right

Does Perl have a round() function?  What about ceil() and floor()?  Trig functions?
-----------------------------------------------------------------------------------

   Remember that int() merely truncates toward 0.  For rounding to a
certain number of digits, sprintf() or printf() is usually the easiest
route.

     printf("%.3f", 3.1415926535);	# prints 3.142

   The POSIX module (part of the standard Perl distribution) implements
ceil(), floor(), and a number of other mathematical and trigonometric
functions.

     use POSIX;
     $ceil   = ceil(3.5);			# 4
     $floor  = floor(3.5);			# 3

   In 5.000 to 5.003 Perls, trigonometry was done in the Math::Complex
module.  With 5.004, the Math::Trig module (part of the standard Perl
distribution) implements the trigonometric functions. Internally it uses
the Math::Complex module and some functions can break out from the real
axis into the complex plane, for example the inverse sine of 2.

   Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.  In these cases,
it probably pays not to trust whichever system rounding is being used by
Perl, but to instead implement the rounding function you need yourself.

   To see why, notice how you'll still have an issue on half-way-point
alternation:

     for ($i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}

     0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
     0.8 0.8 0.9 0.9 1.0 1.0

   Don't blame Perl.  It's the same as in C.  IEEE says we have to do this.
Perl numbers whose absolute values are integers under 2**31 (on 32 bit
machines) will work pretty much like mathematical integers.  Other numbers
are not guaranteed.

How do I convert bits into ints?
--------------------------------

   To turn a string of 1s and 0s like `10110110' into a scalar containing
its binary value, use the pack() and unpack() functions (documented in
`"pack"', *Note Perlfunc: perlfunc, and `"unpack"', *Note Perlfunc:
perlfunc,):

     $decimal = unpack('c', pack('B8', '10110110'));

   This packs the string `10110110' into an eight bit binary structure.
This is then unpacked as a character, which returns its ordinal value.

   This does the same thing:

     $decimal = ord(pack('B8', '10110110'));

   Here's an example of going the other way:

     $binary_string = unpack('B*', "\x29");

Why doesn't & work the way I want it to?
----------------------------------------

   The behavior of binary arithmetic operators depends on whether they're
used on numbers or strings.  The operators treat a string as a series of
bits and work with that (the string `"3"' is the bit pattern `00110011').
The operators work with the binary form of a number (the number 3 is
treated as the bit pattern `00000011').

   So, saying `11 & 3' performs the "and" operation on numbers (yielding
1).  Saying `"11" & "3"' performs the "and" operation on strings (yielding
`"1"').

   Most problems with & and | arise because the programmer thinks they
have a number but really it's a string.  The rest arise because the
programmer says:

     if ("\020\020" & "\101\101") {
     	# ...
     }

   but a string consisting of two null bytes (the result of `"\020\020" &
"\101\101"') is not a false value in Perl.  You need:

     if ( ("\020\020" & "\101\101") !~ /[^\000]/) {
     	# ...
     }

How do I multiply matrices?
---------------------------

   Use the Math::Matrix or Math::MatrixReal modules (available from CPAN)
or the PDL extension (also available from CPAN).

How do I perform an operation on a series of integers?
------------------------------------------------------

   To call a function on each element in an array, and collect the
results, use:

     @results = map { my_func($_) } @array;

   For example:

     @triple = map { 3 * $_ } @single;

   To call a function on each element of an array, but ignore the results:

     foreach $iterator (@array) {
         some_func($iterator);
     }

   To call a function on each integer in a (small) range, you can use:

     @results = map { some_func($_) } (5 .. 25);

   but you should be aware that the `..' operator creates an array of all
integers in the range.  This can take a lot of memory for large ranges.
Instead use:

     @results = ();
     for ($i=5; $i < 500_005; $i++) {
         push(@results, some_func($i));
     }

   This situation has been fixed in Perl5.005. Use of `..' in a for loop
will iterate over the range, without creating the entire range.

     for my $i (5 .. 500_005) {
         push(@results, some_func($i));
     }

   will not create a list of 500,000 integers.

How can I output Roman numerals?
--------------------------------

   Get the http://www.perl.com/CPAN/modules/by-module/Roman module.

Why aren't my random numbers random?
------------------------------------

   If you're using a version of Perl before 5.004, you must call srand
once at the start of your program to seed the random number generator.
5.004 and later automatically call srand at the beginning.  Don't call
srand more than once-you make your numbers less random, rather than more.

   Computers are good at being predictable and bad at being random
(despite appearances caused by bugs in your programs :-).
http://www.perl.com/CPAN/doc/FMTEYEWTK/random, courtesy of Tom Phoenix,
talks more about this..  John von Neumann said, "Anyone who attempts to
generate random numbers by deterministic means is, of course, living in a
state of sin."

   If you want numbers that are more random than rand with srand provides,
you should also check out the Math::TrulyRandom module from CPAN.  It uses
the imperfections in your system's timer to generate random numbers, but
this takes quite a while.  If you want a better pseudorandom generator
than comes with your operating system, look at "Numerical Recipes in C" at
http://www.nr.com/ .

Data: Dates
===========

How do I find the week-of-the-year/day-of-the-year?
---------------------------------------------------

   The day of the year is in the array returned by localtime() (see
`"localtime"', *Note Perlfunc: perlfunc,):

     $day_of_year = (localtime(time()))[7];

   or more legibly (in 5.004 or higher):

     use Time::localtime;
     $day_of_year = localtime(time())->yday;

   You can find the week of the year by dividing this by 7:

     $week_of_year = int($day_of_year / 7);

   Of course, this believes that weeks start at zero.  The Date::Calc
module from CPAN has a lot of date calculation functions, including day of
the year, week of the year, and so on.   Note that not all businesses
consider "week 1" to be the same; for example, American businesses often
consider the first week with a Monday in it to be Work Week #1, despite
ISO 8601, which considers WW1 to be the first week with a Thursday in it.

How do I find the current century or millennium?
------------------------------------------------

   Use the following simple functions:

     sub get_century    {
     	return int((((localtime(shift || time))[5] + 1999))/100);
     }
     sub get_millennium {
     	return 1+int((((localtime(shift || time))[5] + 1899))/1000);
     }

   On some systems, you'll find that the POSIX module's strftime() function
has been extended in a non-standard way to use a %C format, which they
sometimes claim is the "century".  It isn't, because on most such systems,
this is only the first two digits of the four-digit year, and thus cannot
be used to reliably determine the current century or millennium.

How can I compare two dates and find the difference?
----------------------------------------------------

   If you're storing your dates as epoch seconds then simply subtract one
from the other.  If you've got a structured date (distinct year, day,
month, hour, minute, seconds values), then for reasons of accessibility,
simplicity, and efficiency, merely use either timelocal or timegm (from
the Time::Local module in the standard distribution) to reduce structured
dates to epoch seconds.  However, if you don't know the precise format of
your dates, then you should probably use either of the Date::Manip and
Date::Calc modules from CPAN before you go hacking up your own parsing
routine to handle arbitrary date formats.

How can I take a string and turn it into epoch seconds?
-------------------------------------------------------

   If it's a regular enough string that it always has the same format, you
can split it up and pass the parts to `timelocal' in the standard
Time::Local module.  Otherwise, you should look into the Date::Calc and
Date::Manip modules from CPAN.

How can I find the Julian Day?
------------------------------

   Use the Time::JulianDay module (part of the Time-modules bundle
available from CPAN.)

   Before you immerse yourself too deeply in this, be sure to verify that
it is the Julian Day you really want.  Are they really just interested in
a way of getting serial days so that they can do date arithmetic?  If you
are interested in performing date arithmetic, this can be done using
either Date::Manip or Date::Calc, without converting to Julian Day first.

   There is too much confusion on this issue to cover in this FAQ, but the
term is applied (correctly) to a calendar now supplanted by the Gregorian
Calendar, with the Julian Calendar failing to adjust properly for leap
years on centennial years (among other annoyances).  The term is also used
(incorrectly) to mean: [1] days in the Gregorian Calendar; and [2] days
since a particular starting time or `epoch', usually 1970 in the Unix
world and 1980 in the MS-DOS/Windows world.  If you find that it is not
the first meaning that you really want, then check out the Date::Manip and
Date::Calc modules.  (Thanks to David Cassell for most of this text.)

How do I find yesterday's date?
-------------------------------

   The `time()' function returns the current time in seconds since the
epoch.  Take twenty-four hours off that:

     $yesterday = time() - ( 24 * 60 * 60 );

   Then you can pass this to `localtime()' and get the individual year,
month, day, hour, minute, seconds values.

   Note very carefully that the code above assumes that your days are
twenty-four hours each.  For most people, there are two days a year when
they aren't: the switch to and from summer time throws this off.  A
solution to this issue is offered by Russ Allbery.

     sub yesterday {
     	my $now  = defined $_[0] ? $_[0] : time;
     	my $then = $now - 60 * 60 * 24;
     	my $ndst = (localtime $now)[8] > 0;
     	my $tdst = (localtime $then)[8] > 0;
     	$then - ($tdst - $ndst) * 60 * 60;
     }
     # Should give you "this time yesterday" in seconds since epoch relative to
     # the first argument or the current time if no argument is given and
     # suitable for passing to localtime or whatever else you need to do with
     # it.  $ndst is whether we're currently in daylight savings time; $tdst is
     # whether the point 24 hours ago was in daylight savings time.  If $tdst
     # and $ndst are the same, a boundary wasn't crossed, and the correction
     # will subtract 0.  If $tdst is 1 and $ndst is 0, subtract an hour more
     # from yesterday's time since we gained an extra hour while going off
     # daylight savings time.  If $tdst is 0 and $ndst is 1, subtract a
     # negative hour (add an hour) to yesterday's time since we lost an hour.
     #
     # All of this is because during those days when one switches off or onto
     # DST, a "day" isn't 24 hours long; it's either 23 or 25.
     #
     # The explicit settings of $ndst and $tdst are necessary because localtime
     # only says it returns the system tm struct, and the system tm struct at
     # least on Solaris doesn't guarantee any particular positive value (like,
     # say, 1) for isdst, just a positive value.  And that value can
     # potentially be negative, if DST information isn't available (this sub
     # just treats those cases like no DST).
     #
     # Note that between 2am and 3am on the day after the time zone switches
     # off daylight savings time, the exact hour of "yesterday" corresponding
     # to the current hour is not clearly defined.  Note also that if used
     # between 2am and 3am the day after the change to daylight savings time,
     # the result will be between 3am and 4am of the previous day; it's
     # arguable whether this is correct.
     #
     # This sub does not attempt to deal with leap seconds (most things don't).
     #
     # Copyright relinquished 1999 by Russ Allbery <rra@stanford.edu>
     # This code is in the public domain

Does Perl have a Year 2000 problem?  Is Perl Y2K compliant?
-----------------------------------------------------------

   Short answer: No, Perl does not have a Year 2000 problem.  Yes, Perl is
Y2K compliant (whatever that means).  The programmers you've hired to use
it, however, probably are not.

   Long answer: The question belies a true understanding of the issue.
Perl is just as Y2K compliant as your pencil-no more, and no less.  Can
you use your pencil to write a non-Y2K-compliant memo?  Of course you can.
Is that the pencil's fault?  Of course it isn't.

   The date and time functions supplied with Perl (gmtime and localtime)
supply adequate information to determine the year well beyond 2000 (2038
is when trouble strikes for 32-bit machines).  The year returned by these
functions when used in an array context is the year minus 1900.  For years
between 1910 and 1999 this *happens* to be a 2-digit decimal number. To
avoid the year 2000 problem simply do not treat the year as a 2-digit
number.  It isn't.

   When gmtime() and localtime() are used in scalar context they return a
timestamp string that contains a fully-expanded year.  For example,
`$timestamp = gmtime(1005613200)' sets $timestamp to "Tue Nov 13 01:00:00
2001".  There's no year 2000 problem here.

   That doesn't mean that Perl can't be used to create non-Y2K compliant
programs.  It can.  But so can your pencil.  It's the fault of the user,
not the language.  At the risk of inflaming the NRA: "Perl doesn't break
Y2K, people do."  See http://language.perl.com/news/y2k.html for a longer
exposition.

Data: Strings
=============

How do I validate input?
------------------------

   The answer to this question is usually a regular expression, perhaps
with auxiliary logic.  See the more specific questions (numbers, mail
addresses, etc.) for details.

How do I unescape a string?
---------------------------

   It depends just what you mean by "escape".  URL escapes are dealt with
in *Note Perlfaq9: perlfaq9,.  Shell escapes with the backslash (\)
character are removed with:

     s/\\(.)/$1/g;

   This won't expand `"\n"' or `"\t"' or any other special escapes.

How do I remove consecutive pairs of characters?
------------------------------------------------

   To turn `"abbcccd"' into `"abccd"':

     s/(.)\1/$1/g;	# add /s to include newlines

   Here's a solution that turns "abbcccd" to "abcd":

     y///cs;	# y == tr, but shorter :-)

How do I expand function calls in a string?
-------------------------------------------

   This is documented in *Note Perlref: perlref,.  In general, this is
fraught with quoting and readability problems, but it is possible.  To
interpolate a subroutine call (in list context) into a string:

     print "My sub returned @{[mysub(1,2,3)]} that time.\n";

   If you prefer scalar context, similar chicanery is also useful for
arbitrary expressions:

     print "That yields ${\($n + 5)} widgets\n";

   Version 5.004 of Perl had a bug that gave list context to the
expression in `${...}', but this is fixed in version 5.005.

   See also "How can I expand variables in text strings?" in this section
of the FAQ.

How do I find matching/nesting anything?
----------------------------------------

   This isn't something that can be done in one regular expression, no
matter how complicated.  To find something between two single characters,
a pattern like `/x([^x]*)x/' will get the intervening bits in $1. For
multiple ones, then something more like `/alpha(.*?)omega/' would be
needed.  But none of these deals with nested patterns, nor can they.  For
that you'll have to write a parser.

   If you are serious about writing a parser, there are a number of
modules or oddities that will make your life a lot easier.  There are the
CPAN modules Parse::RecDescent, Parse::Yapp, and Text::Balanced; and the
byacc program.

   One simple destructive, inside-out approach that you might try is to
pull out the smallest nesting parts one at a time:

     while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {
     	# do something with $1
     }

   A more complicated and sneaky approach is to make Perl's regular
expression engine do it for you.  This is courtesy Dean Inada, and rather
has the nature of an Obfuscated Perl Contest entry, but it really does
work:

     # $_ contains the string to parse
     # BEGIN and END are the opening and closing markers for the
     # nested text.

     @( = ('(','');
     @) = (')','');
     ($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;
     @$ = (eval{/$re/},$@!~/unmatched/);
     print join("\n",@$[0..$#$]) if( $$[-1] );

How do I reverse a string?
--------------------------

   Use reverse() in scalar context, as documented in `reverse', *Note
Perlfunc: perlfunc,.

     $reversed = reverse $string;

How do I expand tabs in a string?
---------------------------------

   You can do it yourself:

     1 while $string =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;

   Or you can just use the Text::Tabs module (part of the standard Perl
distribution).

     use Text::Tabs;
     @expanded_lines = expand(@lines_with_tabs);

How do I reformat a paragraph?
------------------------------

   Use Text::Wrap (part of the standard Perl distribution):

     use Text::Wrap;
     print wrap("\t", '  ', @paragraphs);

   The paragraphs you give to Text::Wrap should not contain embedded
newlines.  Text::Wrap doesn't justify the lines (flush-right).

How can I access/change the first N letters of a string?
--------------------------------------------------------

   There are many ways.  If you just want to grab a copy, use substr():

     $first_byte = substr($a, 0, 1);

   If you want to modify part of a string, the simplest way is often to
use substr() as an lvalue:

     substr($a, 0, 3) = "Tom";

   Although those with a pattern matching kind of thought process will
likely prefer:

     $a =~ s/^.../Tom/;

How do I change the Nth occurrence of something?
------------------------------------------------

   You have to keep track of N yourself.  For example, let's say you want
to change the fifth occurrence of `"whoever"' or `"whomever"' into
`"whosoever"' or `"whomsoever"', case insensitively.  These all assume
that $_ contains the string to be altered.

     $count = 0;
     s{((whom?)ever)}{
     	++$count == 5   	# is it the 5th?
     	    ? "${2}soever"	# yes, swap
     	    : $1		# renege and leave it there
     }ige;

   In the more general case, you can use the `/g' modifier in a while
loop, keeping count of matches.

     $WANT = 3;
     $count = 0;
     $_ = "One fish two fish red fish blue fish";
     while (/(\w+)\s+fish\b/gi) {
         if (++$count == $WANT) {
             print "The third fish is a $1 one.\n";
         }
     }

   That prints out: `"The third fish is a red one."'  You can also use a
repetition count and repeated pattern like this:

     /(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;

How can I count the number of occurrences of a substring within a string?
-------------------------------------------------------------------------

   There are a number of ways, with varying efficiency: If you want a
count of a certain single character (X) within a string, you can use the
tr/// function like so:

     $string = "ThisXlineXhasXsomeXx'sXinXit";
     $count = ($string =~ tr/X//);
     print "There are $count X characters in the string";

   This is fine if you are just looking for a single character.  However,
if you are trying to count multiple character substrings within a larger
string, tr/// won't work.  What you can do is wrap a while() loop around a
global pattern match.  For example, let's count negative integers:

     $string = "-9 55 48 -2 23 -76 4 14 -44";
     while ($string =~ /-\d+/g) { $count++ }
     print "There are $count negative numbers in the string";

How do I capitalize all the words on one line?
----------------------------------------------

   To make the first letter of each word upper case:

     $line =~ s/\b(\w)/\U$1/g;

   This has the strange effect of turning "`don't do it'" into "`Don'T Do
It'".  Sometimes you might want this, instead (Suggested by brian d.  foy):

     $string =~ s/ (
                  (^\w)    #at the beginning of the line
                    |      # or
                  (\s\w)   #preceded by whitespace
                    )
                 /\U$1/xg;
     $string =~ /([\w']+)/\u\L$1/g;

   To make the whole line upper case:

     $line = uc($line);

   To force each word to be lower case, with the first letter upper case:

     $line =~ s/(\w+)/\u\L$1/g;

   You can (and probably should) enable locale awareness of those
characters by placing a `use locale' pragma in your program.  See *Note
Perllocale: perllocale, for endless details on locales.

   This is sometimes referred to as putting something into "title case",
but that's not quite accurate.  Consider the proper capitalization of the
movie *Dr. Strangelove or: How I Learned to Stop Worrying and Love the
Bomb*, for example.

How can I split a [character] delimited string except when inside [character]? (Comma-separated files)
------------------------------------------------------------------------------------------------------

   Take the example case of trying to split a string that is
comma-separated into its different fields.  (We'll pretend you said
comma-separated, not comma-delimited, which is different and almost never
what you mean.) You can't use `split(/,/)' because you shouldn't split if
the comma is inside quotes.  For example, take a data line like this:

     SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"

   Due to the restriction of the quotes, this is a fairly complex problem.
Thankfully, we have Jeffrey Friedl, author of a highly recommended book
on regular expressions, to handle these for us.  He suggests (assuming
your string is contained in $text):

     @new = ();
     push(@new, $+) while $text =~ m{
         "([^\"\\]*(?:\\.[^\"\\]*)*)",?  # groups the phrase inside the quotes
       | ([^,]+),?
       | ,
     }gx;
     push(@new, undef) if substr($text,-1,1) eq ',';

   If you want to represent quotation marks inside a
quotation-mark-delimited field, escape them with backslashes (eg, `"like
\"this\""'.  Unescaping them is a task addressed earlier in this section.

   Alternatively, the Text::ParseWords module (part of the standard Perl
distribution) lets you say:

     use Text::ParseWords;
     @new = quotewords(",", 0, $text);

   There's also a Text::CSV module on CPAN.

How do I strip blank space from the beginning/end of a string?
--------------------------------------------------------------

   Although the simplest approach would seem to be:

     $string =~ s/^\s*(.*?)\s*$/$1/;

   Not only is this unnecessarily slow and destructive, it also fails with
embedded newlines.  It is much faster to do this operation in two steps:

     $string =~ s/^\s+//;
     $string =~ s/\s+$//;

   Or more nicely written as:

     for ($string) {
     	s/^\s+//;
     	s/\s+$//;
     }

   This idiom takes advantage of the foreach loop's aliasing behavior to
factor out common code.  You can do this on several strings at once, or
arrays, or even the values of a hash if you use a slice:

     # trim whitespace in the scalar, the array,
     # and all the values in the hash
     foreach ($scalar, @array, @hash{keys %hash}) {
         s/^\s+//;
         s/\s+$//;
     }

How do I pad a string with blanks or pad a number with zeroes?
--------------------------------------------------------------

   (This answer contributed by Uri Guttman, with kibitzing from Bart
Lateur.)

   In the following examples, `$pad_len' is the length to which you wish
to pad the string, $text or $num contains the string to be padded, and
`$pad_char' contains the padding character. You can use a single character
string constant instead of the `$pad_char' variable if you know what it is
in advance. And in the same way you can use an integer in place of
`$pad_len' if you know the pad length in advance.

   The simplest method uses the sprintf function. It can pad on the left
or right with blanks and on the left with zeroes and it will not truncate
the result. The pack function can only pad strings on the right with
blanks and it will truncate the result to a maximum length of `$pad_len'.

     # Left padding a string with blanks (no truncation):
     $padded = sprintf("%${pad_len}s", $text);

     # Right padding a string with blanks (no truncation):
     $padded = sprintf("%-${pad_len}s", $text);

     # Left padding a number with 0 (no truncation):
     $padded = sprintf("%0${pad_len}d", $num);

     # Right padding a string with blanks using pack (will truncate):
     $padded = pack("A$pad_len",$text);

   If you need to pad with a character other than blank or zero you can use
one of the following methods.  They all generate a pad string with the x
operator and combine that with $text. These methods do not truncate $text.

   Left and right padding with any character, creating a new string:

     $padded = $pad_char x ( $pad_len - length( $text ) ) . $text;
     $padded = $text . $pad_char x ( $pad_len - length( $text ) );

   Left and right padding with any character, modifying $text directly:

     substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) );
     $text .= $pad_char x ( $pad_len - length( $text ) );

How do I extract selected columns from a string?
------------------------------------------------

   Use substr() or unpack(), both documented in *Note Perlfunc: perlfunc,.
If you prefer thinking in terms of columns instead of widths, you can use
this kind of thing:

     # determine the unpack format needed to split Linux ps output
     # arguments are cut columns
     my $fmt = cut2fmt(8, 14, 20, 26, 30, 34, 41, 47, 59, 63, 67, 72);

     sub cut2fmt {
     	my(@positions) = @_;
     	my $template  = '';
     	my $lastpos   = 1;
     	for my $place (@positions) {
     	    $template .= "A" . ($place - $lastpos) . " ";
     	    $lastpos   = $place;
     	}
     	$template .= "A*";
     	return $template;
     }

How do I find the soundex value of a string?
--------------------------------------------

   Use the standard Text::Soundex module distributed with Perl.  But
before you do so, you may want to determine whether `soundex' is in fact
what you think it is.  Knuth's soundex algorithm compresses words into a
small space, and so it does not necessarily distinguish between two words
which you might want to appear separately.  For example, the last names
`Knuth' and `Kant' are both mapped to the soundex code K530.  If
Text::Soundex does not do what you are looking for, you might want to
consider the String::Approx module available at CPAN.

How can I expand variables in text strings?
-------------------------------------------

   Let's assume that you have a string like:

     $text = 'this has a $foo in it and a $bar';

   If those were both global variables, then this would suffice:

     $text =~ s/\$(\w+)/${$1}/g;  # no /e needed

   But since they are probably lexicals, or at least, they could be, you'd
have to do this:

     $text =~ s/(\$\w+)/$1/eeg;
     die if $@;			# needed /ee, not /e

   It's probably better in the general case to treat those variables as
entries in some special hash.  For example:

     %user_defs = (
     	foo  => 23,
     	bar  => 19,
     );
     $text =~ s/\$(\w+)/$user_defs{$1}/g;

   See also "How do I expand function calls in a string?" in this section
of the FAQ.

What's wrong with always quoting "$vars"?
-----------------------------------------

   The problem is that those double-quotes force stringification, coercing
numbers and references into strings, even when you don't want them to be.
Think of it this way: double-quote expansion is used to produce new
strings.  If you already have a string, why do you need more?

   If you get used to writing odd things like these:

     print "$var";   	# BAD
     $new = "$old";   	# BAD
     somefunc("$var");	# BAD

   You'll be in trouble.  Those should (in 99.8% of the cases) be the
simpler and more direct:

     print $var;
     $new = $old;
     somefunc($var);

   Otherwise, besides slowing you down, you're going to break code when
the thing in the scalar is actually neither a string nor a number, but a
reference:

     func(\@array);
     sub func {
     	my $aref = shift;
     	my $oref = "$aref";  # WRONG
     }

   You can also get into subtle problems on those few operations in Perl
that actually do care about the difference between a string and a number,
such as the magical `++' autoincrement operator or the syscall() function.

   Stringification also destroys arrays.

     @lines = `command`;
     print "@lines";		# WRONG - extra blanks
     print @lines;		# right

Why don't my <<HERE documents work?
-----------------------------------

   Check for these three things:

  1. There must be no space after the << part.

  2. There (probably) should be a semicolon at the end.

  3. You can't (easily) have any space in front of the tag.
        If you want to indent the text in the here document, you can do
this:

     # all in one
     ($VAR = <<HERE_TARGET) =~ s/^\s+//gm;
         your text
         goes here
     HERE_TARGET

   But the HERE_TARGET must still be flush against the margin.  If you
want that indented also, you'll have to quote in the indentation.

     ($quote = <<'    FINIS') =~ s/^\s+//gm;
             ...we will have peace, when you and all your works have
             perished--and the works of your dark master to whom you
             would deliver us. You are a liar, Saruman, and a corrupter
             of men's hearts.  --Theoden in /usr/src/perl/taint.c
         FINIS
     $quote =~ s/\s*--/\n--/;

   A nice general-purpose fixer-upper function for indented here documents
follows.  It expects to be called with a here document as its argument.
It looks to see whether each line begins with a common substring, and if
so, strips that off.  Otherwise, it takes the amount of leading white
space found on the first line and removes that much off each subsequent
line.

     sub fix {
         local $_ = shift;
         my ($white, $leader);  # common white space and common leading string
         if (/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/) {
             ($white, $leader) = ($2, quotemeta($1));
         } else {
             ($white, $leader) = (/^(\s+)/, '');
         }
         s/^\s*?$leader(?:$white)?//gm;
         return $_;
     }

   This works with leading special strings, dynamically determined:

     $remember_the_main = fix<<'    MAIN_INTERPRETER_LOOP';
     	@@@ int
     	@@@ runops() {
     	@@@     SAVEI32(runlevel);
     	@@@     runlevel++;
     	@@@     while ( op = (*op->op_ppaddr)() );
     	@@@     TAINT_NOT;
     	@@@     return 0;
     	@@@ }
     MAIN_INTERPRETER_LOOP

   Or with a fixed amount of leading white space, with remaining
indentation correctly preserved:

     $poem = fix<<EVER_ON_AND_ON;
        Now far ahead the Road has gone,
     	  And I must follow, if I can,
        Pursuing it with eager feet,
     	  Until it joins some larger way
        Where many paths and errands meet.
     	  And whither then? I cannot say.
     		--Bilbo in /usr/src/perl/pp_ctl.c
     EVER_ON_AND_ON

Data: Arrays
============

What is the difference between a list and an array?
---------------------------------------------------

   An array has a changeable length.  A list does not.  An array is
something you can push or pop, while a list is a set of values.  Some
people make the distinction that a list is a value while an array is a
variable.  Subroutines are passed and return lists, you put things into
list context, you initialize arrays with lists, and you foreach() across a
list.  `@' variables are arrays, anonymous arrays are arrays, arrays in
scalar context behave like the number of elements in them, subroutines
access their arguments through the array `@_', push/pop/shift only work on
arrays.

   As a side note, there's no such thing as a list in scalar context.
When you say

     $scalar = (2, 5, 7, 9);

   you're using the comma operator in scalar context, so it uses the scalar
comma operator.  There never was a list there at all!  This causes the
last value to be returned: 9.

What is the difference between $array[1] and @array[1]?
-------------------------------------------------------

   The former is a scalar value, the latter an array slice, which makes it
a list with one (scalar) value.  You should use $ when you want a scalar
value (most of the time) and @ when you want a list with one scalar value
in it (very, very rarely; nearly never, in fact).

   Sometimes it doesn't make a difference, but sometimes it does.  For
example, compare:

     $good[0] = `some program that outputs several lines`;

   with

     @bad[0]  = `same program that outputs several lines`;

   The `use warnings' pragma and the -w flag will warn you about these
matters.

How can I remove duplicate elements from a list or array?
---------------------------------------------------------

   There are several possible ways, depending on whether the array is
ordered and whether you wish to preserve the ordering.

a) If @in is sorted, and you want @out to be sorted: (this assumes all true values in the array)
          $prev = 'nonesuch';
          @out = grep($_ ne $prev && ($prev = $_), @in);

     This is nice in that it doesn't use much extra memory, simulating
     uniq(1)'s behavior of removing only adjacent duplicates.  It's less
     nice in that it won't work with false values like undef, 0, or ""; "0
     but true" is OK, though.

b) If you don't know whether @in is sorted:
          undef %saw;
          @out = grep(!$saw{$_}++, @in);

c) Like (b), but @in contains only small integers:
          @out = grep(!$saw[$_]++, @in);

d) A way to do (b) without any loops or greps:
          undef %saw;
          @saw{@in} = ();
          @out = sort keys %saw;  # remove sort if undesired

e) Like (d), but @in contains only small positive integers:
          undef @ary;
          @ary[@in] = @in;
          @out = grep {defined} @ary;

   But perhaps you should have been using a hash all along, eh?

How can I tell whether a list or array contains a certain element?
------------------------------------------------------------------

   Hearing the word "in" is an indication that you probably should have
used a hash, not a list or array, to store your data.  Hashes are designed
to answer this question quickly and efficiently.  Arrays aren't.

   That being said, there are several ways to approach this.  If you are
going to make this query many times over arbitrary string values, the
fastest way is probably to invert the original array and keep an
associative array lying about whose keys are the first array's values.

     @blues = qw/azure cerulean teal turquoise lapis-lazuli/;
     undef %is_blue;
     for (@blues) { $is_blue{$_} = 1 }

   Now you can check whether $is_blue{$some_color}.  It might have been a
good idea to keep the blues all in a hash in the first place.

   If the values are all small integers, you could use a simple indexed
array.  This kind of an array will take up less space:

     @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
     undef @is_tiny_prime;
     for (@primes) { $is_tiny_prime[$_] = 1 }
     # or simply  @istiny_prime[@primes] = (1) x @primes;

   Now you check whether $is_tiny_prime[$some_number].

   If the values in question are integers instead of strings, you can save
quite a lot of space by using bit strings instead:

     @articles = ( 1..10, 150..2000, 2017 );
     undef $read;
     for (@articles) { vec($read,$_,1) = 1 }

   Now check whether `vec($read,$n,1)' is true for some $n.

   Please do not use

     $is_there = grep $_ eq $whatever, @array;

   or worse yet

     $is_there = grep /$whatever/, @array;

   These are slow (checks every element even if the first matches),
inefficient (same reason), and potentially buggy (what if there are regex
characters in $whatever?).  If you're only testing once, then use:

     $is_there = 0;
     foreach $elt (@array) {
     	if ($elt eq $elt_to_find) {
     	    $is_there = 1;
     	    last;
     	}
     }
     if ($is_there) { ... }

How do I compute the difference of two arrays?  How do I compute the intersection of two arrays?
------------------------------------------------------------------------------------------------

   Use a hash.  Here's code to do both and more.  It assumes that each
element is unique in a given array:

     @union = @intersection = @difference = ();
     %count = ();
     foreach $element (@array1, @array2) { $count{$element}++ }
     foreach $element (keys %count) {
     	push @union, $element;
     	push @{ $count{$element} > 1 ? \@intersection : \@difference }, $element;
     }

   Note that this is the *symmetric difference*, that is, all elements in
either A or in B, but not in both.  Think of it as an xor operation.

How do I test whether two arrays or hashes are equal?
-----------------------------------------------------

   The following code works for single-level arrays.  It uses a stringwise
comparison, and does not distinguish defined versus undefined empty
strings.  Modify if you have other needs.

     $are_equal = compare_arrays(\@frogs, \@toads);

     sub compare_arrays {
     	my ($first, $second) = @_;
     	no warnings;  # silence spurious -w undef complaints
     	return 0 unless @$first == @$second;
     	for (my $i = 0; $i < @$first; $i++) {
     	    return 0 if $first->[$i] ne $second->[$i];
     	}
     	return 1;
     }

   For multilevel structures, you may wish to use an approach more like
this one.  It uses the CPAN module FreezeThaw:

     use FreezeThaw qw(cmpStr);
     @a = @b = ( "this", "that", [ "more", "stuff" ] );

     printf "a and b contain %s arrays\n",
         cmpStr(\@a, \@b) == 0
     	    ? "the same"
     	    : "different";

   This approach also works for comparing hashes.  Here we'll demonstrate
two different answers:

     use FreezeThaw qw(cmpStr cmpStrHard);

     %a = %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
     $a{EXTRA} = \%b;
     $b{EXTRA} = \%a;

     printf "a and b contain %s hashes\n",
     	cmpStr(\%a, \%b) == 0 ? "the same" : "different";

     printf "a and b contain %s hashes\n",
     	cmpStrHard(\%a, \%b) == 0 ? "the same" : "different";

   The first reports that both those the hashes contain the same data,
while the second reports that they do not.  Which you prefer is left as an
exercise to the reader.

How do I find the first array element for which a condition is true?
--------------------------------------------------------------------

   You can use this if you care about the index:

     for ($i= 0; $i < @array; $i++) {
         if ($array[$i] eq "Waldo") {
     	    $found_index = $i;
             last;
         }
     }

   Now `$found_index' has what you want.

How do I handle linked lists?
-----------------------------

   In general, you usually don't need a linked list in Perl, since with
regular arrays, you can push and pop or shift and unshift at either end,
or you can use splice to add and/or remove arbitrary number of elements at
arbitrary points.  Both pop and shift are both O(1) operations on Perl's
dynamic arrays.  In the absence of shifts and pops, push in general needs
to reallocate on the order every log(N) times, and unshift will need to
copy pointers each time.

   If you really, really wanted, you could use structures as described in
*Note Perldsc: perldsc, or *Note Perltoot: perltoot, and do just what the
algorithm book tells you to do.  For example, imagine a list node like
this:

     $node = {
         VALUE => 42,
         LINK  => undef,
     };

   You could walk the list this way:

     print "List: ";
     for ($node = $head;  $node; $node = $node->{LINK}) {
         print $node->{VALUE}, " ";
     }
     print "\n";

   You could grow the list this way:

     my ($head, $tail);
     $tail = append($head, 1);       # grow a new head
     for $value ( 2 .. 10 ) {
         $tail = append($tail, $value);
     }

     sub append {
         my($list, $value) = @_;
         my $node = { VALUE => $value };
         if ($list) {
             $node->{LINK} = $list->{LINK};
             $list->{LINK} = $node;
         } else {
             $_[0] = $node;      # replace caller's version
         }
         return $node;
     }

   But again, Perl's built-in are virtually always good enough.

How do I handle circular lists?
-------------------------------

   Circular lists could be handled in the traditional fashion with linked
lists, or you could just do something like this with an array:

     unshift(@array, pop(@array));  # the last shall be first
     push(@array, shift(@array));   # and vice versa

How do I shuffle an array randomly?
-----------------------------------

   Use this:

     # fisher_yates_shuffle( \@array ) :
     # generate a random permutation of @array in place
     sub fisher_yates_shuffle {
         my $array = shift;
         my $i;
         for ($i = @$array; --$i; ) {
             my $j = int rand ($i+1);
             next if $i == $j;
             @$array[$i,$j] = @$array[$j,$i];
         }
     }

     fisher_yates_shuffle( \@array );    # permutes @array in place

   You've probably seen shuffling algorithms that work using splice,
randomly picking another element to swap the current element with:

     srand;
     @new = ();
     @old = 1 .. 10;  # just a demo
     while (@old) {
     	push(@new, splice(@old, rand @old, 1));
     }

   This is bad because splice is already O(N), and since you do it N times,
you just invented a quadratic algorithm; that is, O(N**2).  This does not
scale, although Perl is so efficient that you probably won't notice this
until you have rather largish arrays.

How do I process/modify each element of an array?
-------------------------------------------------

   Use for/foreach:

     for (@lines) {
     	s/foo/bar/;	# change that word
     	y/XZ/ZX/;	# swap those letters
     }

   Here's another; let's compute spherical volumes:

     for (@volumes = @radii) {   # @volumes has changed parts
     	$_ **= 3;
     	$_ *= (4/3) * 3.14159;  # this will be constant folded
     }

   If you want to do the same thing to modify the values of the hash, you
may not use the values function, oddly enough.  You need a slice:

     for $orbit ( @orbits{keys %orbits} ) {
     	($orbit **= 3) *= (4/3) * 3.14159;
     }

How do I select a random element from an array?
-----------------------------------------------

   Use the rand() function (see `rand', *Note Perlfunc: perlfunc,):

     # at the top of the program:
     srand;			# not needed for 5.004 and later

     # then later on
     $index   = rand @array;
     $element = $array[$index];

   Make sure you *only call srand once per program, if then*.  If you are
calling it more than once (such as before each call to rand), you're
almost certainly doing something wrong.

How do I permute N elements of a list?
--------------------------------------

   Here's a little program that generates all permutations of all the
words on each line of input.  The algorithm embodied in the permute()
function should work on any list:

     #!/usr/bin/perl -n
     # tsc-permute: permute each word of input
     permute([split], []);
     sub permute {
         my @items = @{ $_[0] };
         my @perms = @{ $_[1] };
         unless (@items) {
             print "@perms\n";
     	} else {
             my(@newitems,@newperms,$i);
             foreach $i (0 .. $#items) {
                 @newitems = @items;
                 @newperms = @perms;
                 unshift(@newperms, splice(@newitems, $i, 1));
                 permute([@newitems], [@newperms]);
     	    }
     	}
     }

How do I sort an array by (anything)?
-------------------------------------

   Supply a comparison function to sort() (described in `sort', *Note
Perlfunc: perlfunc,):

     @list = sort { $a <=> $b } @list;

   The default sort function is cmp, string comparison, which would sort
`(1, 2, 10)' into `(1, 10, 2)'.  `< <=' >>, used above, is the numerical
comparison operator.

   If you have a complicated function needed to pull out the part you want
to sort on, then don't do it inside the sort function.  Pull it out first,
because the sort BLOCK can be called many times for the same element.
Here's an example of how to pull out the first word after the first number
on each item, and then sort those words case-insensitively.

     @idx = ();
     for (@data) {
     	($item) = /\d+\s*(\S+)/;
     	push @idx, uc($item);
     }
     @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];

   Which could also be written this way, using a trick that's come to be
known as the Schwartzian Transform:

     @sorted = map  { $_->[0] }
     	      sort { $a->[1] cmp $b->[1] }
     	      map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @data;

   If you need to sort on several fields, the following paradigm is useful.

     @sorted = sort { field1($a) <=> field1($b) ||
                      field2($a) cmp field2($b) ||
                      field3($a) cmp field3($b)
                    }     @data;

   This can be conveniently combined with precalculation of keys as given
above.

   See http://www.perl.com/CPAN/doc/FMTEYEWTK/sort.html for more about
this approach.

   See also the question below on sorting hashes.

How do I manipulate arrays of bits?
-----------------------------------

   Use pack() and unpack(), or else vec() and the bitwise operations.

   For example, this sets $vec to have bit N set if $ints[N] was set:

     $vec = '';
     foreach(@ints) { vec($vec,$_,1) = 1 }

   And here's how, given a vector in $vec, you can get those bits into
your @ints array:

     sub bitvec_to_list {
     	my $vec = shift;
     	my @ints;
     	# Find null-byte density then select best algorithm
     	if ($vec =~ tr/\0// / length $vec > 0.95) {
     	    use integer;
     	    my $i;
     	    # This method is faster with mostly null-bytes
     	    while($vec =~ /[^\0]/g ) {
     		$i = -9 + 8 * pos $vec;
     		push @ints, $i if vec($vec, ++$i, 1);
     		push @ints, $i if vec($vec, ++$i, 1);
     		push @ints, $i if vec($vec, ++$i, 1);
     		push @ints, $i if vec($vec, ++$i, 1);
     		push @ints, $i if vec($vec, ++$i, 1);
     		push @ints, $i if vec($vec, ++$i, 1);
     		push @ints, $i if vec($vec, ++$i, 1);
     		push @ints, $i if vec($vec, ++$i, 1);
     	    }
     	} else {
     	    # This method is a fast general algorithm
     	    use integer;
     	    my $bits = unpack "b*", $vec;
     	    push @ints, 0 if $bits =~ s/^(\d)// && $1;
     	    push @ints, pos $bits while($bits =~ /1/g);
     	}
     	return \@ints;
     }

   This method gets faster the more sparse the bit vector is.  (Courtesy
of Tim Bunce and Winfried Koenig.)

   Here's a demo on how to use vec():

     # vec demo
     $vector = "\xff\x0f\xef\xfe";
     print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ",
     	unpack("N", $vector), "\n";
     $is_set = vec($vector, 23, 1);
     print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\n";
     pvec($vector);

     set_vec(1,1,1);
     set_vec(3,1,1);
     set_vec(23,1,1);

     set_vec(3,1,3);
     set_vec(3,2,3);
     set_vec(3,4,3);
     set_vec(3,4,7);
     set_vec(3,8,3);
     set_vec(3,8,7);

     set_vec(0,32,17);
     set_vec(1,32,17);

     sub set_vec {
     	my ($offset, $width, $value) = @_;
     	my $vector = '';
     	vec($vector, $offset, $width) = $value;
     	print "offset=$offset width=$width value=$value\n";
     	pvec($vector);
     }

     sub pvec {
     	my $vector = shift;
     	my $bits = unpack("b*", $vector);
     	my $i = 0;
     	my $BASE = 8;

     print "vector length in bytes: ", length($vector), "\n";
     @bytes = unpack("A8" x length($vector), $bits);
     print "bits are: @bytes\n\n";
         }

Why does defined() return true on empty arrays and hashes?
----------------------------------------------------------

   The short story is that you should probably only use defined on scalars
or functions, not on aggregates (arrays and hashes).  See `defined', *Note
Perlfunc: perlfunc, in the 5.004 release or later of Perl for more detail.

Data: Hashes (Associative Arrays)
=================================

How do I process an entire hash?
--------------------------------

   Use the each() function (see `each', *Note Perlfunc: perlfunc,) if you
don't care whether it's sorted:

     while ( ($key, $value) = each %hash) {
     	print "$key = $value\n";
     }

   If you want it sorted, you'll have to use foreach() on the result of
sorting the keys as shown in an earlier question.

What happens if I add or remove keys from a hash while iterating over it?
-------------------------------------------------------------------------

   Don't do that. :-)

   [lwall] In Perl 4, you were not allowed to modify a hash at all while
iterating over it.  In Perl 5 you can delete from it, but you still can't
add to it, because that might cause a doubling of the hash table, in which
half the entries get copied up to the new top half of the table, at which
point you've totally bamboozled the iterator code.  Even if the table
doesn't double, there's no telling whether your new entry will be inserted
before or after the current iterator position.

   Either treasure up your changes and make them after the iterator
finishes, or use keys to fetch all the old keys at once, and iterate over
the list of keys.

How do I look up a hash element by value?
-----------------------------------------

   Create a reverse hash:

     %by_value = reverse %by_key;
     $key = $by_value{$value};

   That's not particularly efficient.  It would be more space-efficient to
use:

     while (($key, $value) = each %by_key) {
     	$by_value{$value} = $key;
     }

   If your hash could have repeated values, the methods above will only
find one of the associated keys.   This may or may not worry you.  If it
does worry you, you can always reverse the hash into a hash of arrays
instead:

     while (($key, $value) = each %by_key) {
     	 push @{$key_list_by_value{$value}}, $key;
     }

How can I know how many entries are in a hash?
----------------------------------------------

   If you mean how many keys, then all you have to do is take the scalar
sense of the keys() function:

     $num_keys = scalar keys %hash;

   In void context, the keys() function just resets the iterator, which is
faster for tied hashes than would be iterating through the whole hash, one
key-value pair at a time.

How do I sort a hash (optionally by value instead of key)?
----------------------------------------------------------

   Internally, hashes are stored in a way that prevents you from imposing
an order on key-value pairs.  Instead, you have to sort a list of the keys
or values:

     @keys = sort keys %hash;	# sorted by key
     @keys = sort {
     		    $hash{$a} cmp $hash{$b}
     	    } keys %hash; 	# and by value

   Here we'll do a reverse numeric sort by value, and if two keys are
identical, sort by length of key, and if that fails, by straight ASCII
comparison of the keys (well, possibly modified by your locale - see *Note
Perllocale: perllocale,).

     @keys = sort {
     		$hash{$b} <=> $hash{$a}
     			  ||
     		length($b) <=> length($a)
     			  ||
     		      $a cmp $b
     } keys %hash;

How can I always keep my hash sorted?
-------------------------------------

   You can look into using the DB_File module and tie() using the
$DB_BTREE hash bindings as documented in `"In Memory Databases"', *Note
DB_File: (pm.info)DB_File,.  The Tie::IxHash module from CPAN might also
be instructive.

What's the difference between "delete" and "undef" with hashes?
---------------------------------------------------------------

   Hashes are pairs of scalars: the first is the key, the second is the
value.  The key will be coerced to a string, although the value can be any
kind of scalar: string, number, or reference.  If a key $key is present in
the array, `exists($key)' will return true.  The value for a given key can
be undef, in which case `$array{$key}' will be undef while `$exists{$key}'
will return true.  This corresponds to ($key, undef) being in the hash.

   Pictures help...  here's the `%ary' table:

     keys  values
     	+------+------+
     	|  a   |  3   |
     	|  x   |  7   |
     	|  d   |  0   |
     	|  e   |  2   |
     	+------+------+

   And these conditions hold

     $ary{'a'}                       is true
     $ary{'d'}                       is false
     defined $ary{'d'}               is true
     defined $ary{'a'}               is true
     exists $ary{'a'}                is true (Perl5 only)
     grep ($_ eq 'a', keys %ary)     is true

   If you now say

     undef $ary{'a'}

   your table now reads:

     keys  values
     	+------+------+
     	|  a   | undef|
     	|  x   |  7   |
     	|  d   |  0   |
     	|  e   |  2   |
     	+------+------+

   and these conditions now hold; changes in caps:

     $ary{'a'}                       is FALSE
     $ary{'d'}                       is false
     defined $ary{'d'}               is true
     defined $ary{'a'}               is FALSE
     exists $ary{'a'}                is true (Perl5 only)
     grep ($_ eq 'a', keys %ary)     is true

   Notice the last two: you have an undef value, but a defined key!

   Now, consider this:

     delete $ary{'a'}

   your table now reads:

     keys  values
     	+------+------+
     	|  x   |  7   |
     	|  d   |  0   |
     	|  e   |  2   |
     	+------+------+

   and these conditions now hold; changes in caps:

     $ary{'a'}                       is false
     $ary{'d'}                       is false
     defined $ary{'d'}               is true
     defined $ary{'a'}               is false
     exists $ary{'a'}                is FALSE (Perl5 only)
     grep ($_ eq 'a', keys %ary)     is FALSE

   See, the whole entry is gone!

Why don't my tied hashes make the defined/exists distinction?
-------------------------------------------------------------

   They may or may not implement the EXISTS() and DEFINED() methods
differently.  For example, there isn't the concept of undef with hashes
that are tied to DBM* files. This means the true/false tables above will
give different results when used on such a hash.  It also means that
exists and defined do the same thing with a DBM* file, and what they end
up doing is not what they do with ordinary hashes.

How do I reset an each() operation part-way through?
----------------------------------------------------

   Using `keys %hash' in scalar context returns the number of keys in the
hash and resets the iterator associated with the hash.  You may need to do
this if you use last to exit a loop early so that when you re-enter it,
the hash iterator has been reset.

How can I get the unique keys from two hashes?
----------------------------------------------

   First you extract the keys from the hashes into lists, then solve the
"removing duplicates" problem described above.  For example:

     %seen = ();
     for $element (keys(%foo), keys(%bar)) {
     	$seen{$element}++;
     }
     @uniq = keys %seen;

   Or more succinctly:

     @uniq = keys %{{%foo,%bar}};

   Or if you really want to save space:

     %seen = ();
     while (defined ($key = each %foo)) {
         $seen{$key}++;
     }
     while (defined ($key = each %bar)) {
         $seen{$key}++;
     }
     @uniq = keys %seen;

How can I store a multidimensional array in a DBM file?
-------------------------------------------------------

   Either stringify the structure yourself (no fun), or else get the MLDBM
(which uses Data::Dumper) module from CPAN and layer it on top of either
DB_File or GDBM_File.

How can I make my hash remember the order I put elements into it?
-----------------------------------------------------------------

   Use the Tie::IxHash from CPAN.

     use Tie::IxHash;
     tie(%myhash, Tie::IxHash);
     for ($i=0; $i<20; $i++) {
         $myhash{$i} = 2*$i;
     }
     @keys = keys %myhash;
     # @keys = (0,1,2,3,...)

Why does passing a subroutine an undefined element in a hash create it?
-----------------------------------------------------------------------

   If you say something like:

     somefunc($hash{"nonesuch key here"});

   Then that element "autovivifies"; that is, it springs into existence
whether you store something there or not.  That's because functions get
scalars passed in by reference.  If somefunc() modifies `$_[0]', it has to
be ready to write it back into the caller's version.

   This has been fixed as of Perl5.004.

   Normally, merely accessing a key's value for a nonexistent key does not
cause that key to be forever there.  This is different than awk's behavior.

How can I make the Perl equivalent of a C structure/C++ class/hash or array of hashes or arrays?
------------------------------------------------------------------------------------------------

   Usually a hash ref, perhaps like this:

     $record = {
         NAME   => "Jason",
         EMPNO  => 132,
         TITLE  => "deputy peon",
         AGE    => 23,
         SALARY => 37_000,
         PALS   => [ "Norbert", "Rhys", "Phineas"],
     };

   References are documented in *Note Perlref: perlref, and the upcoming
*Note Perlreftut: perlreftut,.  Examples of complex data structures are
given in *Note Perldsc: perldsc, and *Note Perllol: perllol,.  Examples of
structures and object-oriented classes are in *Note Perltoot: perltoot,.

How can I use a reference as a hash key?
----------------------------------------

   You can't do this directly, but you could use the standard Tie::Refhash
module distributed with Perl.

Data: Misc
==========

How do I handle binary data correctly?
--------------------------------------

   Perl is binary clean, so this shouldn't be a problem.  For example,
this works fine (assuming the files are found):

     if (`cat /vmunix` =~ /gzip/) {
     	print "Your kernel is GNU-zip enabled!\n";
     }

   On less elegant (read: Byzantine) systems, however, you have to play
tedious games with "text" versus "binary" files.  See `"binmode"', *Note
Perlfunc: perlfunc, or `"binmode"', *Note Perlopentut: perlopentut,.  Most
of these ancient-thinking systems are curses out of Microsoft, who seem to
be committed to putting the backward into backward compatibility.

   If you're concerned about 8-bit ASCII data, then see *Note Perllocale:
perllocale,.

   If you want to deal with multibyte characters, however, there are some
gotchas.  See the section on Regular Expressions.

How do I determine whether a scalar is a number/whole/integer/float?
--------------------------------------------------------------------

   Assuming that you don't care about IEEE notations like "NaN" or
"Infinity", you probably just want to use a regular expression.

     if (/\D/)            { print "has nondigits\n" }
     if (/^\d+$/)         { print "is a whole number\n" }
     if (/^-?\d+$/)       { print "is an integer\n" }
     if (/^[+-]?\d+$/)    { print "is a +/- integer\n" }
     if (/^-?\d+\.?\d*$/) { print "is a real number\n" }
     if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number" }
     if (/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
     			{ print "a C float" }

   If you're on a POSIX system, Perl's supports the `POSIX::strtod'
function.  Its semantics are somewhat cumbersome, so here's a `getnum'
wrapper function for more convenient access.  This function takes a string
and returns the number it found, or undef for input that isn't a C float.
The `is_numeric' function is a front end to `getnum' if you just want to
say, "Is this a float?"

     sub getnum {
         use POSIX qw(strtod);
         my $str = shift;
         $str =~ s/^\s+//;
         $str =~ s/\s+$//;
         $! = 0;
         my($num, $unparsed) = strtod($str);
         if (($str eq '') || ($unparsed != 0) || $!) {
             return undef;
         } else {
             return $num;
         }
     }

     sub is_numeric { defined getnum($_[0]) }

   Or you could check out the String::Scanf module on CPAN instead.  The
POSIX module (part of the standard Perl distribution) provides the strtol
and strtod for converting strings to double and longs, respectively.

How do I keep persistent data across program calls?
---------------------------------------------------

   For some specific applications, you can use one of the DBM modules.
See *Note AnyDBM_File: (pm.info)AnyDBM_File,.  More generically, you
should consult the FreezeThaw, Storable, or Class::Eroot modules from
CPAN.  Here's one example using Storable's store and retrieve functions:

     use Storable;
     store(\%hash, "filename");

     # later on...
     $href = retrieve("filename");        # by ref
     %hash = %{ retrieve("filename") };   # direct to hash

How do I print out or copy a recursive data structure?
------------------------------------------------------

   The Data::Dumper module on CPAN (or the 5.005 release of Perl) is great
for printing out data structures.  The Storable module, found on CPAN,
provides a function called `dclone' that recursively copies its argument.

     use Storable qw(dclone);
     $r2 = dclone($r1);

   Where $r1 can be a reference to any kind of data structure you'd like.
It will be deeply copied.  Because `dclone' takes and returns references,
you'd have to add extra punctuation if you had a hash of arrays that you
wanted to copy.

     %newhash = %{ dclone(\%oldhash) };

How do I define methods for every class/object?
-----------------------------------------------

   Use the UNIVERSAL class (see *Note UNIVERSAL: (pm.info)UNIVERSAL,).

How do I verify a credit card checksum?
---------------------------------------

   Get the Business::CreditCard module from CPAN.

How do I pack arrays of doubles or floats for XS code?
------------------------------------------------------

   The kgbpack.c code in the PGPLOT module on CPAN does just this.  If
you're doing a lot of float or double processing, consider using the PDL
module from CPAN instead-it makes number-crunching easy.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.


File: perl.info,  Node: perlfaq5,  Next: Top,  Prev: Top,  Up: Top

Files and Formats ($Revision: 1.38 $, $Date: 1999/05/23 16:08:30 $)
*******************************************************************

NAME
====

   perlfaq5 - Files and Formats ($Revision: 1.38 $, $Date: 1999/05/23
16:08:30 $)

DESCRIPTION
===========

   This section deals with I/O and the "f" issues: filehandles, flushing,
formats, and footers.

How do I flush/unbuffer an output filehandle?  Why must I do this?
------------------------------------------------------------------

   The C standard I/O library (stdio) normally buffers characters sent to
devices.  This is done for efficiency reasons, so that there isn't a
system call for each byte.  Any time you use print() or write() in Perl,
you go though this buffering.  syswrite() circumvents stdio and buffering.

   In most stdio implementations, the type of output buffering and the
size of the buffer varies according to the type of device.  Disk files are
block buffered, often with a buffer size of more than 2k.  Pipes and
sockets are often buffered with a buffer size between 1/2 and 2k.  Serial
devices (e.g. modems, terminals) are normally line-buffered, and stdio
sends the entire line when it gets the newline.

   Perl does not support truly unbuffered output (except insofar as you can
`syswrite(OUT, $char, 1)').  What it does instead support is "command
buffering", in which a physical write is performed after every output
command.  This isn't as hard on your system as unbuffering, but does get
the output where you want it when you want it.

   If you expect characters to get to your device when you print them
there, you'll want to autoflush its handle.  Use select() and the $|
variable to control autoflushing (see `$|', *Note Perlvar: perlvar, and
`select', *Note Perlfunc: perlfunc,):

     $old_fh = select(OUTPUT_HANDLE);
     $| = 1;
     select($old_fh);

   Or using the traditional idiom:

     select((select(OUTPUT_HANDLE), $| = 1)[0]);

   Or if don't mind slowly loading several thousand lines of module code
just because you're afraid of the $| variable:

     use FileHandle;
     open(DEV, "+</dev/tty"); 	  # ceci n'est pas une pipe
     DEV->autoflush(1);

   or the newer IO::* modules:

     use IO::Handle;
     open(DEV, ">/dev/printer");   # but is this?
     DEV->autoflush(1);

   or even this:

     use IO::Socket;		  # this one is kinda a pipe?
     $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.com',
     				  PeerPort => 'http(80)',
     				  Proto    => 'tcp');
     die "$!" unless $sock;

     $sock->autoflush();
     print $sock "GET / HTTP/1.0" . "\015\012" x 2;
     $document = join('', <$sock>);
     print "DOC IS: $document\n";

   Note the bizarrely hardcoded carriage return and newline in their octal
equivalents.  This is the ONLY way (currently) to assure a proper flush on
all platforms, including Macintosh.  That's the way things work in network
programming: you really should specify the exact bit pattern on the
network line terminator.  In practice, `"\n\n"' often works, but this is
not portable.

   See *Note Perlfaq9: perlfaq9, for other examples of fetching URLs over
the web.

How do I change one line in a file/delete a line in a file/insert a line in the middle of a file/append to the beginning of a file?
-----------------------------------------------------------------------------------------------------------------------------------

   Those are operations of a text editor.  Perl is not a text editor.
Perl is a programming language.  You have to decompose the problem into
low-level calls to read, write, open, close, and seek.

   Although humans have an easy time thinking of a text file as being a
sequence of lines that operates much like a stack of playing cards - or
punch cards - computers usually see the text file as a sequence of bytes.
In general, there's no direct way for Perl to seek to a particular line of
a file, insert text into a file, or remove text from a file.

   (There are exceptions in special circumstances.  You can add or remove
at the very end of the file.  Another is replacing a sequence of bytes with
another sequence of the same length.  Another is using the `$DB_RECNO'
array bindings as documented in *Note DB_File: (pm.info)DB_File,.  Yet
another is manipulating files with all lines the same length.)

   The general solution is to create a temporary copy of the text file with
the changes you want, then copy that over the original.  This assumes no
locking.

     $old = $file;
     $new = "$file.tmp.$$";
     $bak = "$file.orig";

     open(OLD, "< $old") 	or die "can't open $old: $!";
     open(NEW, "> $new") 	or die "can't open $new: $!";

     # Correct typos, preserving case
     while (<OLD>) {
     	s/\b(p)earl\b/${1}erl/i;
     	(print NEW $_)		or die "can't write to $new: $!";
     }

     close(OLD)			or die "can't close $old: $!";
     close(NEW) 			or die "can't close $new: $!";

     rename($old, $bak)		or die "can't rename $old to $bak: $!";
     rename($new, $old)		or die "can't rename $new to $old: $!";

   Perl can do this sort of thing for you automatically with the -i
command-line switch or the closely-related $^I variable (see *Note
Perlrun: perlrun, for more details).  Note that -i may require a suffix on
some non-Unix systems; see the platform-specific documentation that came
with your port.

     # Renumber a series of tests from the command line
     perl -pi -e 's/(^\s+test\s+)\d+/ $1 . ++$count /e' t/op/taint.t

     # form a script
     local($^I, @ARGV) = ('.orig', glob("*.c"));
     while (<>) {
     	if ($. == 1) {
     	    print "This line should appear at the top of each file\n";
     	}
     	s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
     	print;
     	close ARGV if eof;              # Reset $.
     }

   If you need to seek to an arbitrary line of a file that changes
infrequently, you could build up an index of byte positions of where the
line ends are in the file.  If the file is large, an index of every tenth
or hundredth line end would allow you to seek and read fairly efficiently.
If the file is sorted, try the look.pl library (part of the standard perl
distribution).

   In the unique case of deleting lines at the end of a file, you can use
tell() and truncate().  The following code snippet deletes the last line
of a file without making a copy or reading the whole file into memory:

     open (FH, "+< $file");
             while ( <FH> ) { $addr = tell(FH) unless eof(FH) }
             truncate(FH, $addr);

   Error checking is left as an exercise for the reader.

How do I count the number of lines in a file?
---------------------------------------------

   One fairly efficient way is to count newlines in the file. The
following program uses a feature of tr///, as documented in *Note Perlop:
perlop,.  If your text file doesn't end with a newline, then it's not
really a proper text file, so this may report one fewer line than you
expect.

     $lines = 0;
     open(FILE, $filename) or die "Can't open `$filename': $!";
     while (sysread FILE, $buffer, 4096) {
     	$lines += ($buffer =~ tr/\n//);
     }
     close FILE;

   This assumes no funny games with newline translations.

How do I make a temporary file name?
------------------------------------

   Use the new_tmpfile class method from the IO::File module to get a
filehandle opened for reading and writing.  Use this if you don't need to
know the file's name.

     use IO::File;
     $fh = IO::File->new_tmpfile()
     	or die "Unable to make new temporary file: $!";

   Or you can use the tmpnam function from the POSIX module to get a
filename that you then open yourself.  Use this if you do need to know the
file's name.

     use Fcntl;
     use POSIX qw(tmpnam);

     # try new temporary filenames until we get one that didn't already
     # exist;  the check should be unnecessary, but you can't be too careful
     do { $name = tmpnam() }
         until sysopen(FH, $name, O_RDWR|O_CREAT|O_EXCL);

     # install atexit-style handler so that when we exit or die,
     # we automatically delete this temporary file
     END { unlink($name) or die "Couldn't unlink $name : $!" }

     # now go on to use the file ...

   If you're committed to doing this by hand, use the process ID and/or
the current time-value.  If you need to have many temporary files in one
process, use a counter:

     BEGIN {
     	use Fcntl;
     	my $temp_dir = -d '/tmp' ? '/tmp' : $ENV{TMP} || $ENV{TEMP};
     	my $base_name = sprintf("%s/%d-%d-0000", $temp_dir, $$, time());
     	sub temp_file {
     	    local *FH;
     	    my $count = 0;
     	    until (defined(fileno(FH)) || $count++ > 100) {
     		$base_name =~ s/-(\d+)$/"-" . (1 + $1)/e;
     		sysopen(FH, $base_name, O_WRONLY|O_EXCL|O_CREAT);
     	    }
     	    if (defined(fileno(FH))
     		return (*FH, $base_name);
     	    } else {
     		return ();
     	    }
     	}
     }

How can I manipulate fixed-record-length files?
-----------------------------------------------

   The most efficient way is using pack() and unpack().  This is faster
than using substr() when taking many, many strings.  It is slower for just
a few.

   Here is a sample chunk of code to break up and put back together again
some fixed-format input lines, in this case from the output of a normal,
Berkeley-style ps:

     # sample input line:
     #   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
     $PS_T = 'A6 A4 A7 A5 A*';
     open(PS, "ps|");
     print scalar <PS>;
     while (<PS>) {
     	($pid, $tt, $stat, $time, $command) = unpack($PS_T, $_);
     	for $var (qw!pid tt stat time command!) {
     	    print "$var: <$$var>\n";
     	}
     	print 'line=', pack($PS_T, $pid, $tt, $stat, $time, $command),
     		"\n";
     }

   We've used `$$var' in a way that forbidden by `use strict 'refs''.
That is, we've promoted a string to a scalar variable reference using
symbolic references.  This is ok in small programs, but doesn't scale
well.   It also only works on global variables, not lexicals.

How can I make a filehandle local to a subroutine?  How do I pass filehandles between subroutines?  How do I make an array of filehandles?
------------------------------------------------------------------------------------------------------------------------------------------

   The fastest, simplest, and most direct way is to localize the typeglob
of the filehandle in question:

     local *TmpHandle;

   Typeglobs are fast (especially compared with the alternatives) and
reasonably easy to use, but they also have one subtle drawback.  If you
had, for example, a function named TmpHandle(), or a variable named
%TmpHandle, you just hid it from yourself.

     sub findme {
         local *HostFile;
     	open(HostFile, "</etc/hosts") or die "no /etc/hosts: $!";
     	local $_;		# <- VERY IMPORTANT
         while (<HostFile>) {
     	    print if /\b127\.(0\.0\.)?1\b/;
     	}
     	# *HostFile automatically closes/disappears here
     }

   Here's how to use this in a loop to open and store a bunch of
filehandles.  We'll use as values of the hash an ordered pair to make it
easy to sort the hash in insertion order.

     @names = qw(motd termcap passwd hosts);
     my $i = 0;
     foreach $filename (@names) {
     	local *FH;
     	open(FH, "/etc/$filename") || die "$filename: $!";
         $file{$filename} = [ $i++, *FH ];
     }

     # Using the filehandles in the array
     foreach $name (sort { $file{$a}[0] <=> $file{$b}[0] } keys %file) {
         my $fh = $file{$name}[1];
         my $line = <$fh>;
         print "$name $. $line";
     }

   For passing filehandles to functions, the easiest way is to preface
them with a star, as in func(*STDIN).  See `"Passing Filehandles"', *Note
Perlfaq7: perlfaq7, for details.

   If you want to create many anonymous handles, you should check out the
Symbol, FileHandle, or IO::Handle (etc.) modules.  Here's the equivalent
code with Symbol::gensym, which is reasonably light-weight:

     foreach $filename (@names) {
     	use Symbol;
     	my $fh = gensym();
     	open($fh, "/etc/$filename") || die "open /etc/$filename: $!";
         $file{$filename} = [ $i++, $fh ];
     }

   Or here using the semi-object-oriented FileHandle module, which
certainly isn't light-weight:

     use FileHandle;

     foreach $filename (@names) {
         my $fh = FileHandle->new("/etc/$filename") or die "$filename: $!";
         $file{$filename} = [ $i++, $fh ];
     }

   Please understand that whether the filehandle happens to be a (probably
localized) typeglob or an anonymous handle from one of the modules, in no
way affects the bizarre rules for managing indirect handles.  See the next
question.

How can I use a filehandle indirectly?
--------------------------------------

   An indirect filehandle is using something other than a symbol in a
place that a filehandle is expected.  Here are ways to get those:

     $fh =   SOME_FH;       # bareword is strict-subs hostile
     $fh =  "SOME_FH";      # strict-refs hostile; same package only
     $fh =  *SOME_FH;       # typeglob
     $fh = \*SOME_FH;       # ref to typeglob (bless-able)
     $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob

   Or to use the new method from the FileHandle or IO modules to create an
anonymous filehandle, store that in a scalar variable, and use it as
though it were a normal filehandle.

     use FileHandle;
     $fh = FileHandle->new();

     use IO::Handle;                     # 5.004 or higher
     $fh = IO::Handle->new();

   Then use any of those as you would a normal filehandle.  Anywhere that
Perl is expecting a filehandle, an indirect filehandle may be used
instead. An indirect filehandle is just a scalar variable that contains a
filehandle.  Functions like print, open, seek, or the `< <FH' >> diamond
operator will accept either a read filehandle or a scalar variable
containing one:

     ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
     print $ofh "Type it: ";
     $got = <$ifh>
     print $efh "What was that: $got";

   If you're passing a filehandle to a function, you can write the
function in two ways:

     sub accept_fh {
         my $fh = shift;
         print $fh "Sending to indirect filehandle\n";
     }

   Or it can localize a typeglob and use the filehandle directly:

     sub accept_fh {
         local *FH = shift;
         print  FH "Sending to localized filehandle\n";
     }

   Both styles work with either objects or typeglobs of real filehandles.
(They might also work with strings under some circumstances, but this is
risky.)

     accept_fh(*STDOUT);
     accept_fh($handle);

   In the examples above, we assigned the filehandle to a scalar variable
before using it.  That is because only simple scalar variables, not
expressions or subscripts into hashes or arrays, can be used with
built-ins like print, printf, or the diamond operator.  These are illegal
and won't even compile:

     @fd = (*STDIN, *STDOUT, *STDERR);
     print $fd[1] "Type it: ";                           # WRONG
     $got = <$fd[0]>                                     # WRONG
     print $fd[2] "What was that: $got";                 # WRONG

   With print and printf, you get around this by using a block and an
expression where you would place the filehandle:

     print  { $fd[1] } "funny stuff\n";
     printf { $fd[1] } "Pity the poor %x.\n", 3_735_928_559;
     # Pity the poor deadbeef.

   That block is a proper block like any other, so you can put more
complicated code there.  This sends the message out to one of two places:

     $ok = -x "/bin/cat";
     print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\n";
     print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\n";

   This approach of treating print and printf like object methods calls
doesn't work for the diamond operator.  That's because it's a real
operator, not just a function with a comma-less argument.  Assuming you've
been storing typeglobs in your structure as we did above, you can use the
built-in function named readline to reads a record just as `< <' >> does.
Given the initialization shown above for @fd, this would work, but only
because readline() require a typeglob.  It doesn't work with objects or
strings, which might be a bug we haven't fixed yet.

     $got = readline($fd[0]);

   Let it be noted that the flakiness of indirect filehandles is not
related to whether they're strings, typeglobs, objects, or anything else.
It's the syntax of the fundamental operators.  Playing the object game
doesn't help you at all here.

How can I set up a footer format to be used with write()?
---------------------------------------------------------

   There's no builtin way to do this, but *Note Perlform: perlform, has a
couple of techniques to make it possible for the intrepid hacker.

How can I write() into a string?
--------------------------------

   See `"Accessing Formatting Internals"', *Note Perlform: perlform, for
an swrite() function.

How can I output my numbers with commas added?
----------------------------------------------

   This one will do it for you:

     sub commify {
     	local $_  = shift;
     	1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
     	return $_;
     }

     $n = 23659019423.2331;
     print "GOT: ", commify($n), "\n";

     GOT: 23,659,019,423.2331

   You can't just:

     s/^([-+]?\d+)(\d{3})/$1,$2/g;

   because you have to put the comma in and then recalculate your position.

   Alternatively, this commifies all numbers in a line regardless of
whether they have decimal portions, are preceded by + or -, or whatever:

     # from Andrew Johnson <ajohnson@gpu.srv.ualberta.ca>
     sub commify {
        my $input = shift;
         $input = reverse $input;
         $input =~ s<(\d\d\d)(?=\d)(?!\d*\.)><$1,>g;
         return scalar reverse $input;
     }

How can I translate tildes (~) in a filename?
---------------------------------------------

   Use the <> (glob()) operator, documented in *Note Perlfunc: perlfunc,.
This requires that you have a shell installed that groks tildes, meaning
csh or tcsh or (some versions of) ksh, and thus may have portability
problems.  The Glob::KGlob module (available from CPAN) gives more
portable glob functionality.

   Within Perl, you may use this directly:

     $filename =~ s{
       ^ ~             # find a leading tilde
       (               # save this in $1
           [^/]        # a non-slash character
                 *     # repeated 0 or more times (0 means me)
       )
     }{
       $1
           ? (getpwnam($1))[7]
           : ( $ENV{HOME} || $ENV{LOGDIR} )
     }ex;

How come when I open a file read-write it wipes it out?
-------------------------------------------------------

   Because you're using something like this, which truncates the file and
*then* gives you read-write access:

     open(FH, "+> /path/name");		# WRONG (almost always)

   Whoops.  You should instead use this, which will fail if the file
doesn't exist.

     open(FH, "+< /path/name");  	# open for update

   Using ">" always clobbers or creates.  Using "<" never does either.
The "+" doesn't change this.

   Here are examples of many kinds of file opens.  Those using sysopen()
all assume

     use Fcntl;

   To open file for reading:

     open(FH, "< $path")                                 || die $!;
     sysopen(FH, $path, O_RDONLY)                        || die $!;

   To open file for writing, create new file if needed or else truncate
old file:

     open(FH, "> $path") || die $!;
     sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        || die $!;
     sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666)  || die $!;

   To open file for writing, create new file, file must not exist:

     sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         || die $!;
     sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0666)   || die $!;

   To open file for appending, create if necessary:

     open(FH, ">> $path") || die $!;
     sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       || die $!;
     sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0666) || die $!;

   To open file for appending, file must exist:

     sysopen(FH, $path, O_WRONLY|O_APPEND)               || die $!;

   To open file for update, file must exist:

     open(FH, "+< $path")                                || die $!;
     sysopen(FH, $path, O_RDWR)                          || die $!;

   To open file for update, create file if necessary:

     sysopen(FH, $path, O_RDWR|O_CREAT)                  || die $!;
     sysopen(FH, $path, O_RDWR|O_CREAT, 0666)            || die $!;

   To open file for update, file must not exist:

     sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           || die $!;
     sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0666)     || die $!;

   To open a file without blocking, creating if necessary:

     sysopen(FH, "/tmp/somefile", O_WRONLY|O_NDELAY|O_CREAT)
     	    or die "can't open /tmp/somefile: $!":

   Be warned that neither creation nor deletion of files is guaranteed to
be an atomic operation over NFS.  That is, two processes might both
successful create or unlink the same file!  Therefore O_EXCL isn't so
exclusive as you might wish.

   See also the new *Note Perlopentut: perlopentut, if you have it (new
for 5.6).

Why do I sometimes get an "Argument list too long" when I use <*>?
------------------------------------------------------------------

   The `< <' >> operator performs a globbing operation (see above).  In
Perl versions earlier than v5.6.0, the internal glob() operator forks
csh(1) to do the actual glob expansion, but csh can't handle more than 127
items and so gives the error message `Argument list too long'.  People who
installed tcsh as csh won't have this problem, but their users may be
surprised by it.

   To get around this, either upgrade to Perl v5.6.0 or later, do the glob
yourself with readdir() and patterns, or use a module like Glob::KGlob,
one that doesn't use the shell to do globbing.

Is there a leak/bug in glob()?
------------------------------

   Due to the current implementation on some operating systems, when you
use the glob() function or its angle-bracket alias in a scalar context,
you may cause a leak and/or unpredictable behavior.  It's best therefore
to use glob() only in list context.

How can I open a file with a leading ">" or trailing blanks?
------------------------------------------------------------

   Normally perl ignores trailing blanks in filenames, and interprets
certain leading characters (or a trailing "|") to mean something special.
To avoid this, you might want to use a routine like this.  It makes
incomplete pathnames into explicit relative ones, and tacks a trailing
null byte on the name to make perl leave it alone:

     sub safe_filename {
     	local $_  = shift;
         s#^([^./])#./$1#;
         $_ .= "\0";
     	return $_;
     }

     $badpath = "<<<something really wicked   ";
     $fn = safe_filename($badpath");
     open(FH, "> $fn") or "couldn't open $badpath: $!";

   This assumes that you are using POSIX (portable operating systems
interface) paths.  If you are on a closed, non-portable, proprietary
system, you may have to adjust the `"./"' above.

   It would be a lot clearer to use sysopen(), though:

     use Fcntl;
     $badpath = "<<<something really wicked   ";
     open (FH, $badpath, O_WRONLY | O_CREAT | O_TRUNC)
     	or die "can't open $badpath: $!";

   For more information, see also the new *Note Perlopentut: perlopentut,
if you have it (new for 5.6).

How can I reliably rename a file?
---------------------------------

   Well, usually you just use Perl's rename() function.  But that may not
work everywhere, in particular, renaming files across file systems.  Some
sub-Unix systems have broken ports that corrupt the semantics of rename()
- for example, WinNT does this right, but Win95 and Win98 are broken.
(The last two parts are not surprising, but the first is. :-)

   If your operating system supports a proper mv(1) program or its moral
equivalent, this works:

     rename($old, $new) or system("mv", $old, $new);

   It may be more compelling to use the File::Copy module instead.  You
just copy to the new file to the new name (checking return values), then
delete the old one.  This isn't really the same semantics as a real
rename(), though, which preserves metainformation like permissions,
timestamps, inode info, etc.

   The newer version of File::Copy exports a move() function.

How can I lock a file?
----------------------

   Perl's builtin flock() function (see *Note Perlfunc: perlfunc, for
details) will call flock(2) if that exists, fcntl(2) if it doesn't (on
perl version 5.004 and later), and lockf(3) if neither of the two previous
system calls exists.  On some systems, it may even use a different form of
native locking.  Here are some gotchas with Perl's flock():

  1. Produces a fatal error if none of the three system calls (or their
     close equivalent) exists.

  2. lockf(3) does not provide shared locking, and requires that the
     filehandle be open for writing (or appending, or read/writing).

  3. Some versions of flock() can't lock files over a network (e.g. on NFS
     file systems), so you'd need to force the use of fcntl(2) when you
     build Perl.  But even this is dubious at best.  See the flock entry
     of *Note Perlfunc: perlfunc,, and the INSTALL file in the source
     distribution for information on building Perl to do this.

     Two potentially non-obvious but traditional flock semantics are that
     it waits indefinitely until the lock is granted, and that its locks
     *merely advisory*.  Such discretionary locks are more flexible, but
     offer fewer guarantees.  This means that files locked with flock() may
     be modified by programs that do not also use flock().  Cars that stop
     for red lights get on well with each other, but not with cars that
     don't stop for red lights.  See the perlport manpage, your port's
     specific documentation, or your system-specific local manpages for
     details.  It's best to assume traditional behavior if you're writing
     portable programs.  (But if you're not, you should as always feel
     perfectly free to write for your own system's idiosyncrasies
     (sometimes called "features").  Slavish adherence to portability
     concerns shouldn't get in the way of your getting your job done.)

     For more information on file locking, see also `"File Locking"',
     *Note Perlopentut: perlopentut, if you have it (new for 5.6).


Why can't I just open(FH, ">file.lock")?
----------------------------------------

   A common bit of code *NOT TO USE* is this:

     sleep(3) while -e "file.lock";	# PLEASE DO NOT USE
     open(LCK, "> file.lock");		# THIS BROKEN CODE

   This is a classic race condition: you take two steps to do something
which must be done in one.  That's why computer hardware provides an
atomic test-and-set instruction.   In theory, this "ought" to work:

     sysopen(FH, "file.lock", O_WRONLY|O_EXCL|O_CREAT)
     		or die "can't open  file.lock: $!":

   except that lamentably, file creation (and deletion) is not atomic over
NFS, so this won't work (at least, not every time) over the net.  Various
schemes involving link() have been suggested, but these tend to involve
busy-wait, which is also subdesirable.

I still don't get locking.  I just want to increment the number in the file.  How can I do this?
------------------------------------------------------------------------------------------------

   Didn't anyone ever tell you web-page hit counters were useless?  They
don't count number of hits, they're a waste of time, and they serve only
to stroke the writer's vanity.  Better to pick a random number.  It's more
realistic.

   Anyway, this is what you can do if you can't help yourself.

     use Fcntl ':flock';
     sysopen(FH, "numfile", O_RDWR|O_CREAT) 	 or die "can't open numfile: $!";
     flock(FH, LOCK_EX) 				 or die "can't flock numfile: $!";
     $num = <FH> || 0;
     seek(FH, 0, 0) 				 or die "can't rewind numfile: $!";
     truncate(FH, 0) 				 or die "can't truncate numfile: $!";
     (print FH $num+1, "\n")			 or die "can't write numfile: $!";
     # Perl as of 5.004 automatically flushes before unlocking
     flock(FH, LOCK_UN) 				 or die "can't flock numfile: $!";
     close FH 					 or die "can't close numfile: $!";

   Here's a much better web-page hit counter:

     $hits = int( (time() - 850_000_000) / rand(1_000) );

   If the count doesn't impress your friends, then the code might.  :-)

How do I randomly update a binary file?
---------------------------------------

   If you're just trying to patch a binary, in many cases something as
simple as this works:

     perl -i -pe 's{window manager}{window mangler}g' /usr/bin/emacs

   However, if you have fixed sized records, then you might do something
more like this:

     $RECSIZE = 220; # size of record, in bytes
     $recno   = 37;  # which record to update
     open(FH, "+<somewhere") || die "can't update somewhere: $!";
     seek(FH, $recno * $RECSIZE, 0);
     read(FH, $record, $RECSIZE) == $RECSIZE || die "can't read record $recno: $!";
     # munge the record
     seek(FH, -$RECSIZE, 1);
     print FH $record;
     close FH;

   Locking and error checking are left as an exercise for the reader.
Don't forget them, or you'll be quite sorry.

How do I get a file's timestamp in perl?
----------------------------------------

   If you want to retrieve the time at which the file was last read,
written, or had its meta-data (owner, etc) changed, you use the -M, -A, or
-C filetest operations as documented in *Note Perlfunc: perlfunc,.  These
retrieve the age of the file (measured against the start-time of your
program) in days as a floating point number.  To retrieve the "raw" time
in seconds since the epoch, you would call the stat function, then use
localtime(), gmtime(), or POSIX::strftime() to convert this into
human-readable form.

   Here's an example:

     $write_secs = (stat($file))[9];
     printf "file %s updated at %s\n", $file,
     	scalar localtime($write_secs);

   If you prefer something more legible, use the File::stat module (part
of the standard distribution in version 5.004 and later):

     # error checking left as an exercise for reader.
     use File::stat;
     use Time::localtime;
     $date_string = ctime(stat($file)->mtime);
     print "file $file updated at $date_string\n";

   The POSIX::strftime() approach has the benefit of being, in theory,
independent of the current locale.  See *Note Perllocale: perllocale, for
details.

How do I set a file's timestamp in perl?
----------------------------------------

   You use the utime() function documented in `utime', *Note Perlfunc:
perlfunc,.  By way of example, here's a little program that copies the
read and write times from its first argument to all the rest of them.

     if (@ARGV < 2) {
     	die "usage: cptimes timestamp_file other_files ...\n";
     }
     $timestamp = shift;
     ($atime, $mtime) = (stat($timestamp))[8,9];
     utime $atime, $mtime, @ARGV;

   Error checking is, as usual, left as an exercise for the reader.

   Note that utime() currently doesn't work correctly with Win95/NT ports.
A bug has been reported.  Check it carefully before using it on those
platforms.

How do I print to more than one file at once?
---------------------------------------------

   If you only have to do this once, you can do this:

     for $fh (FH1, FH2, FH3) { print $fh "whatever\n" }

   To connect up to one filehandle to several output filehandles, it's
easiest to use the tee(1) program if you have it, and let it take care of
the multiplexing:

     open (FH, "| tee file1 file2 file3");

   Or even:

     # make STDOUT go to three files, plus original STDOUT
     open (STDOUT, "| tee file1 file2 file3") or die "Teeing off: $!\n";
     print "whatever\n"                       or die "Writing: $!\n";
     close(STDOUT)                            or die "Closing: $!\n";

   Otherwise you'll have to write your own multiplexing print function -
or your own tee program - or use Tom Christiansen's, at
http://www.perl.com/CPAN/authors/id/TOMC/scripts/tct.gz, which is written
in Perl and offers much greater functionality than the stock version.

How can I read in an entire file all at once?
---------------------------------------------

   The customary Perl approach for processing all the lines in a file is to
do so one line at a time:

     open (INPUT, $file) 	|| die "can't open $file: $!";
     while (<INPUT>) {
     	chomp;
     	# do something with $_
     }
     close(INPUT)	    	|| die "can't close $file: $!";

   This is tremendously more efficient than reading the entire file into
memory as an array of lines and then processing it one element at a time,
which is often - if not almost always - the wrong approach.  Whenever you
see someone do this:

     @lines = <INPUT>;

   You should think long and hard about why you need everything loaded at
once.  It's just not a scalable solution.  You might also find it more fun
to use the the standard DB_File module's $DB_RECNO bindings, which allow
you to tie an array to a file so that accessing an element the array
actually accesses the corresponding line in the file.

   On very rare occasion, you may have an algorithm that demands that the
entire file be in memory at once as one scalar.  The simplest solution to
that is:

     $var = `cat $file`;

   Being in scalar context, you get the whole thing.  In list context,
you'd get a list of all the lines:

     @lines = `cat $file`;

   This tiny but expedient solution is neat, clean, and portable to all
systems on which decent tools have been installed.  For those who prefer
not to use the toolbox, you can of course read the file manually, although
this makes for more complicated code.

     {
     	local(*INPUT, $/);
     	open (INPUT, $file) 	|| die "can't open $file: $!";
     	$var = <INPUT>;
     }

   That temporarily undefs your record separator, and will automatically
close the file at block exit.  If the file is already open, just use this:

     $var = do { local $/; <INPUT> };

How can I read in a file by paragraphs?
---------------------------------------

   Use the $/ variable (see *Note Perlvar: perlvar, for details).  You can
either set it to "" to eliminate empty paragraphs (`"abc\n\n\n\ndef"', for
instance, gets treated as two paragraphs and not three), or `"\n\n"' to
accept empty paragraphs.

   Note that a blank line must have no blanks in it.  Thus `"fred\n
\nstuff\n\n"' is one paragraph, but `"fred\n\nstuff\n\n"' is two.

How can I read a single character from a file?  From the keyboard?
------------------------------------------------------------------

   You can use the builtin `getc()' function for most filehandles, but it
won't (easily) work on a terminal device.  For STDIN, either use the
Term::ReadKey module from CPAN, or use the sample code in `getc', *Note
Perlfunc: perlfunc,.

   If your system supports the portable operating system programming
interface (POSIX), you can use the following code, which you'll note turns
off echo processing as well.

     #!/usr/bin/perl -w
     use strict;
     $| = 1;
     for (1..4) {
     	my $got;
     	print "gimme: ";
     	$got = getone();
     	print "--> $got\n";
     }
     exit;

     BEGIN {
     	use POSIX qw(:termios_h);

     my ($term, $oterm, $echo, $noecho, $fd_stdin);

     $fd_stdin = fileno(STDIN);

     $term     = POSIX::Termios->new();
     $term->getattr($fd_stdin);
     $oterm     = $term->getlflag();

     $echo     = ECHO | ECHOK | ICANON;
     $noecho   = $oterm & ~$echo;

     sub cbreak {
         $term->setlflag($noecho);
         $term->setcc(VTIME, 1);
         $term->setattr($fd_stdin, TCSANOW);
     }

     sub cooked {
         $term->setlflag($oterm);
         $term->setcc(VTIME, 0);
         $term->setattr($fd_stdin, TCSANOW);
     }

     sub getone {
         my $key = '';
         cbreak();
         sysread(STDIN, $key, 1);
         cooked();
         return $key;
     }

     }

     END { cooked() }

   The Term::ReadKey module from CPAN may be easier to use.  Recent version
include also support for non-portable systems as well.

     use Term::ReadKey;
     open(TTY, "</dev/tty");
     print "Gimme a char: ";
     ReadMode "raw";
     $key = ReadKey 0, *TTY;
     ReadMode "normal";
     printf "\nYou said %s, char number %03d\n",
         $key, ord $key;

   For legacy DOS systems, Dan Carson <dbc@tc.fluke.COM> reports the
following:

   To put the PC in "raw" mode, use ioctl with some magic numbers gleaned
from msdos.c (Perl source file) and Ralf Brown's interrupt list (comes
across the net every so often):

     $old_ioctl = ioctl(STDIN,0,0);     # Gets device info
     $old_ioctl &= 0xff;
     ioctl(STDIN,1,$old_ioctl | 32);    # Writes it back, setting bit 5

   Then to read a single character:

     sysread(STDIN,$c,1);               # Read a single character

   And to put the PC back to "cooked" mode:

     ioctl(STDIN,1,$old_ioctl);         # Sets it back to cooked mode.

   So now you have $c.  If `ord($c) == 0', you have a two byte code, which
means you hit a special key.  Read another byte with `sysread(STDIN,$c,1)',
and that value tells you what combination it was according to this table:

     # PC 2-byte keycodes = ^@ + the following:

     # HEX     KEYS
     # ---     ----
     # 0F      SHF TAB
     # 10-19   ALT QWERTYUIOP
     # 1E-26   ALT ASDFGHJKL
     # 2C-32   ALT ZXCVBNM
     # 3B-44   F1-F10
     # 47-49   HOME,UP,PgUp
     # 4B      LEFT
     # 4D      RIGHT
     # 4F-53   END,DOWN,PgDn,Ins,Del
     # 54-5D   SHF F1-F10
     # 5E-67   CTR F1-F10
     # 68-71   ALT F1-F10
     # 73-77   CTR LEFT,RIGHT,END,PgDn,HOME
     # 78-83   ALT 1234567890-=
     # 84      CTR PgUp

   This is all trial and error I did a long time ago, I hope I'm reading
the file that worked.

How can I tell whether there's a character waiting on a filehandle?
-------------------------------------------------------------------

   The very first thing you should do is look into getting the
Term::ReadKey extension from CPAN.  As we mentioned earlier, it now even
has limited support for non-portable (read: not open systems, closed,
proprietary, not POSIX, not Unix, etc) systems.

   You should also check out the Frequently Asked Questions list in
comp.unix.* for things like this: the answer is essentially the same.
It's very system dependent.  Here's one solution that works on BSD systems:

     sub key_ready {
     	my($rin, $nfd);
     	vec($rin, fileno(STDIN), 1) = 1;
     	return $nfd = select($rin,undef,undef,0);
     }

   If you want to find out how many characters are waiting, there's also
the FIONREAD ioctl call to be looked at.  The h2ph tool that comes with
Perl tries to convert C include files to Perl code, which can be required.
FIONREAD ends up defined as a function in the *sys/ioctl.ph* file:

     require 'sys/ioctl.ph';

     $size = pack("L", 0);
     ioctl(FH, FIONREAD(), $size)    or die "Couldn't call ioctl: $!\n";
     $size = unpack("L", $size);

   If h2ph wasn't installed or doesn't work for you, you can grep the
include files by hand:

     % grep FIONREAD /usr/include/*/*
     /usr/include/asm/ioctls.h:#define FIONREAD      0x541B

   Or write a small C program using the editor of champions:

     % cat > fionread.c
     #include <sys/ioctl.h>
     main() {
         printf("%#08x\n", FIONREAD);
     }
     ^D
     % cc -o fionread fionread.c
     % ./fionread
     0x4004667f

   And then hard-code it, leaving porting as an exercise to your successor.

     $FIONREAD = 0x4004667f;         # XXX: opsys dependent

     $size = pack("L", 0);
     ioctl(FH, $FIONREAD, $size)     or die "Couldn't call ioctl: $!\n";
     $size = unpack("L", $size);

   FIONREAD requires a filehandle connected to a stream, meaning sockets,
pipes, and tty devices work, but not files.

How do I do a `tail -f' in perl?
--------------------------------

   First try

     seek(GWFILE, 0, 1);

   The statement `seek(GWFILE, 0, 1)' doesn't change the current position,
but it does clear the end-of-file condition on the handle, so that the
next <GWFILE> makes Perl try again to read something.

   If that doesn't work (it relies on features of your stdio
implementation), then you need something more like this:

     for (;;) {
       for ($curpos = tell(GWFILE); <GWFILE>; $curpos = tell(GWFILE)) {
         # search for some stuff and put it into files
       }
       # sleep for a while
       seek(GWFILE, $curpos, 0);  # seek to where we had been
     }

   If this still doesn't work, look into the POSIX module.  POSIX defines
the clearerr() method, which can remove the end of file condition on a
filehandle.  The method: read until end of file, clearerr(), read some
more.  Lather, rinse, repeat.

   There's also a File::Tail module from CPAN.

How do I dup() a filehandle in Perl?
------------------------------------

   If you check `open', *Note Perlfunc: perlfunc,, you'll see that several
of the ways to call open() should do the trick.  For example:

     open(LOG, ">>/tmp/logfile");
     open(STDERR, ">&LOG");

   Or even with a literal numeric descriptor:

     $fd = $ENV{MHCONTEXTFD};
     open(MHCONTEXT, "<&=$fd");	# like fdopen(3S)

   Note that "<&STDIN" makes a copy, but "<&=STDIN" make an alias.  That
means if you close an aliased handle, all aliases become inaccessible.
This is not true with a copied one.

   Error checking, as always, has been left as an exercise for the reader.

How do I close a file descriptor by number?
-------------------------------------------

   This should rarely be necessary, as the Perl close() function is to be
used for things that Perl opened itself, even if it was a dup of a numeric
descriptor, as with MHCONTEXT above.  But if you really have to, you may
be able to do this:

     require 'sys/syscall.ph';
     $rc = syscall(&SYS_close, $fd + 0);  # must force numeric
     die "can't sysclose $fd: $!" unless $rc == -1;

   Or just use the fdopen(3S) feature of open():

     {
     	local *F;
     	open F, "<&=$fd" or die "Cannot reopen fd=$fd: $!";
     	close F;
     }

Why can't I use "C:\temp\foo" in DOS paths?  What doesn't `C:\temp\foo.exe` work?
---------------------------------------------------------------------------------

   Whoops!  You just put a tab and a formfeed into that filename!
Remember that within double quoted strings ("like\this"), the backslash is
an escape character.  The full list of these is in `Quote and Quote-like
Operators', *Note Perlop: perlop,.  Unsurprisingly, you don't have a file
called "c:(tab)emp(formfeed)oo" or "c:(tab)emp(formfeed)oo.exe" on your
legacy DOS filesystem.

   Either single-quote your strings, or (preferably) use forward slashes.
Since all DOS and Windows versions since something like MS-DOS 2.0 or so
have treated / and \ the same in a path, you might as well use the one
that doesn't clash with Perl - or the POSIX shell, ANSI C and C++, awk,
Tcl, Java, or Python, just to mention a few.  POSIX paths are more
portable, too.

Why doesn't glob("*.*") get all the files?
------------------------------------------

   Because even on non-Unix ports, Perl's glob function follows standard
Unix globbing semantics.  You'll need `glob("*")' to get all (non-hidden)
files.  This makes glob() portable even to legacy systems.  Your port may
include proprietary globbing functions as well.  Check its documentation
for details.

Why does Perl let me delete read-only files?  Why does -i clobber protected files?  Isn't this a bug in Perl?
-------------------------------------------------------------------------------------------------------------

   This is elaborately and painstakingly described in the "Far More Than
You Ever Wanted To Know" in
http://www.perl.com/CPAN/doc/FMTEYEWTK/file-dir-perms .

   The executive summary: learn how your filesystem works.  The
permissions on a file say what can happen to the data in that file.  The
permissions on a directory say what can happen to the list of files in
that directory.  If you delete a file, you're removing its name from the
directory (so the operation depends on the permissions of the directory,
not of the file).  If you try to write to the file, the permissions of the
file govern whether you're allowed to.

How do I select a random line from a file?
------------------------------------------

   Here's an algorithm from the Camel Book:

     srand;
     rand($.) < 1 && ($line = $_) while <>;

   This has a significant advantage in space over reading the whole file
in.  A simple proof by induction is available upon request if you doubt
its correctness.

Why do I get weird spaces when I print an array of lines?
---------------------------------------------------------

   Saying

     print "@lines\n";

   joins together the elements of `@lines' with a space between them.  If
`@lines' were `("little", "fluffy", "clouds")' then the above statement
would print:

     little fluffy clouds

   but if each element of `@lines' was a line of text, ending a newline
character `("little\n", "fluffy\n", "clouds\n")' then it would print:

     little
      fluffy
      clouds

   If your array contains lines, just print them:

     print @lines;

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as an integrated part of the Standard Distribution of
Perl or of its documentation (printed or otherwise), this works is covered
under Perl's Artistic License.  For separate distributions of all or part
of this FAQ outside of that, see *Note Perlfaq: perlfaq,.

   Irrespective of its distribution, all code examples here are in the
public domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you see
fit.  A simple comment in the code giving credit to the FAQ would be
courteous but is not required.


