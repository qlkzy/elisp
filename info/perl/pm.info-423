This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Win32/Mutex,  Next: Win32/NetAdmin,  Prev: Win32/Internet,  Up: Module List

Use Win32 mutex objects from Perl
*********************************

NAME
====

   Win32::Mutex - Use Win32 mutex objects from Perl

SYNOPSIS
========

     require Win32::Mutex;

     $mutex = Win32::Mutex->new($initial,$name);
     $mutex->wait;

DESCRIPTION
===========

   This module allows access to the Win32 mutex objects.  The wait method
and `wait_all' & `wait_any' functions are inherited from the
`"Win32::IPC"' in this node module.

Methods
-------

$mutex = Win32::Mutex->new([$initial, [$name]])
     Constructor for a new mutex object.  If `$initial' is true, requests
     immediate ownership of the mutex (default false).  If $name is
     omitted, creates an unnamed mutex object.

     If $name signifies an existing mutex object, then `$initial' is
     ignored and the object is opened.

$mutex = Win32::Mutex->open($name)
     Constructor for opening an existing mutex object.

$mutex->release
     Release ownership of a $mutex.  You should have obtained ownership of
     the mutex through new or one of the wait functions.  Returns true if
     successful.

$mutex->wait([$timeout])
     Wait for ownership of $mutex.  See `"Win32::IPC"' in this node.

Deprecated Functions and Methods
--------------------------------

   *Win32::Mutex* still supports the ActiveWare syntax, but its use is
deprecated.

Create($MutObj,$Initial,$Name)
     Use `$MutObj = Win32::Mutex->new($Initial,$Name)' instead.

Open($MutObj,$Name)
     Use `$MutObj = Win32::Mutex->open($Name)' instead.

$MutObj->Release()
     Use `$MutObj->release' instead.

AUTHOR
======

   Christopher J. Madsen <`chris_madsen@geocities.com'>

   Loosely based on the original module by ActiveWare Internet Corp.,
`http://www.ActiveWare.com'


File: pm.info,  Node: Win32/NetAdmin,  Next: Win32/NetResource,  Prev: Win32/Mutex,  Up: Module List

manage network groups and users in perl
***************************************

NAME
====

   Win32::NetAdmin - manage network groups and users in perl

SYNOPSIS
========

     use Win32::NetAdmin;

DESCRIPTION
===========

   This module offers control over the administration of groups and users
over a network.

FUNCTIONS
=========

NOTE
----

   All of the functions return FALSE (0) if they fail, unless otherwise
noted.  server is optional for all the calls below. If not given the local
machine is assumed.

GetDomainController(server, domain, returnedName)
     Returns the name of the domain controller for server.

GetAnyDomainController(server, domain, returnedName)
     Returns the name of any domain controller for a domain that is
     directly trusted by the server.

UserCreate(server, userName, password, passwordAge, privilege, homeDir, comment, flags, scriptPath)
     Creates a user on server with password, passwordAge, privilege,
     homeDir, comment, flags, and scriptPath.

UserDelete(server, user)
     Deletes a user from server.

UserGetAttributes(server, userName, password, passwordAge, privilege, homeDir, comment, flags, scriptPath)
     Gets password, passwordAge, privilege, homeDir, comment, flags, and
     scriptPath for user.

UserSetAttributes(server, userName, password, passwordAge, privilege, homeDir, comment, flags, scriptPath)
     Sets password, passwordAge, privilege, homeDir, comment, flags, and
     scriptPath for user.

UserChangePassword(domainname, username, oldpassword, newpassword)
     Changes a users password. Can be run under any account.

UsersExist(server, userName)
     Checks if a user exists.

GetUsers(server, filter, userRef)
     Fills userRef with user names if it is an array reference and with
     the user names and the full names if it is a hash reference.

GroupCreate(server, group, comment)
     Creates a group.

GroupDelete(server, group)
     Deletes a group.

GroupGetAttributes(server, groupName, comment)
     Gets the comment.

GroupSetAttributes(server, groupName, comment)
     Sets the comment.

GroupAddUsers(server, groupName, users)
     Adds a user to a group.

GroupDeleteUsers(server, groupName, users)
     Deletes a users from a group.

GroupIsMember(server, groupName, user)
     Returns TRUE if user is a member of groupName.

GroupGetMembers(server, groupName, userArrayRef)
     Fills userArrayRef with the members of groupName.

LocalGroupCreate(server, group, comment)
     Creates a local group.

LocalGroupDelete(server, group)
     Deletes a local group.

LocalGroupGetAttributes(server, groupName, comment)
     Gets the comment.

LocalGroupSetAttributes(server, groupName, comment)
     Sets the comment.

LocalGroupIsMember(server, groupName, user)
     Returns TRUE if user is a member of groupName.

LocalGroupGetMembers(server, groupName, userArrayRef)
     Fills userArrayRef with the members of groupName.

LocalGroupGetMembersWithDomain(server, groupName, userRef)
     This function is similar LocalGroupGetMembers but accepts an array or
     a hash reference. Unlike LocalGroupGetMembers it returns each user
     name as `DOMAIN\USERNAME'. If a hash reference is given, the function
     returns to each user or group name the type (group, user, alias etc.).
     The possible types are as follows:

          $SidTypeUser = 1;
          $SidTypeGroup = 2;
          $SidTypeDomain = 3;
          $SidTypeAlias = 4;
          $SidTypeWellKnownGroup = 5;
          $SidTypeDeletedAccount = 6;
          $SidTypeInvalid = 7;
          $SidTypeUnknown = 8;

LocalGroupAddUsers(server, groupName, users)
     Adds a user to a group.

LocalGroupDeleteUsers(server, groupName, users)
     Deletes a users from a group.

GetServers(server, domain, flags, serverRef)
     Gets an array of server names or an hash with the server names and the
     comments as seen in the Network Neighborhood or the server manager.
     For flags, see SV_TYPE_* constants.

GetTransports(server, transportRef)
     Enumerates the network transports of a computer. If transportRef is
     an array reference, it is filled with the transport names. If
     transportRef is a hash reference then a hash of hashes is filled with
     the data for the transports.

LoggedOnUsers(server, userRef)
     Gets an array or hash with the users logged on at the specified
     computer. If userRef is a hash reference, the value is a semikolon
     separated string of username, logon domain and logon server.

GetAliasFromRID(server, RID, returnedName)
GetUserGroupFromRID(server, RID, returnedName)
     Retrieves the name of an alias (i.e local group) or a user group for
     a RID from the specified server. These functions can be used for
     example to get the account name for the administrator account if it
     is renamed or localized.

     Possible values for `RID':

          DOMAIN_ALIAS_RID_ACCOUNT_OPS
          DOMAIN_ALIAS_RID_ADMINS
          DOMAIN_ALIAS_RID_BACKUP_OPS
          DOMAIN_ALIAS_RID_GUESTS
          DOMAIN_ALIAS_RID_POWER_USERS
          DOMAIN_ALIAS_RID_PRINT_OPS
          DOMAIN_ALIAS_RID_REPLICATOR
          DOMAIN_ALIAS_RID_SYSTEM_OPS
          DOMAIN_ALIAS_RID_USERS
          DOMAIN_GROUP_RID_ADMINS
          DOMAIN_GROUP_RID_GUESTS
          DOMAIN_GROUP_RID_USERS
          DOMAIN_USER_RID_ADMIN
          DOMAIN_USER_RID_GUEST

GetServerDisks(server, arrayRef)
     Returns an array with the disk drives of the specified server. The
     array contains two-character strings (drive letter followed by a
     colon).

EXAMPLE
=======

     # Simple script using Win32::NetAdmin to set the login script for
     # all members of the NT group "Domain Users".  Only works if you
     # run it on the PDC. (From Robert Spier <rspier@seas.upenn.edu>)
     #
     # FILTER_TEMP_DUPLICATE_ACCOUNTS
     #	Enumerates local user account data on a domain controller.
     #
     # FILTER_NORMAL_ACCOUNT
     #	Enumerates global user account data on a computer.
     #
     # FILTER_INTERDOMAIN_TRUST_ACCOUNT
     #	Enumerates domain trust account data on a domain controller.
     #
     # FILTER_WORKSTATION_TRUST_ACCOUNT
     #	Enumerates workstation or member server account data on a domain
     #	controller.
     #
     # FILTER_SERVER_TRUST_ACCOUNT
     #	Enumerates domain controller account data on a domain controller.

     use Win32::NetAdmin qw(GetUsers GroupIsMember
     			   UserGetAttributes UserSetAttributes);

     my %hash;
     GetUsers("", FILTER_NORMAL_ACCOUNT , \%hash)
     	or die "GetUsers() failed: $^E";

     foreach (keys %hash) {
     	my ($password, $passwordAge, $privilege,
     	    $homeDir, $comment, $flags, $scriptPath);
     	if (GroupIsMember("", "Domain Users", $_)) {
     	    print "Updating $_ ($hash{$_})\n";
     	    UserGetAttributes("", $_, $password, $passwordAge, $privilege,
     			      $homeDir, $comment, $flags, $scriptPath)
     		or die "UserGetAttributes() failed: $^E";
     	    $scriptPath = "dnx_login.bat"; # this is the new login script
     	    UserSetAttributes("", $_, $password, $passwordAge, $privilege,
     			      $homeDir, $comment, $flags, $scriptPath)
     		or die "UserSetAttributes() failed: $^E";
     	}
     }


File: pm.info,  Node: Win32/NetResource,  Next: Win32/PerfLib,  Prev: Win32/NetAdmin,  Up: Module List

manage network resources in perl
********************************

NAME
====

   Win32::NetResource - manage network resources in perl

SYNOPSIS
========

     use Win32::NetResource;

     $ShareInfo = {
                     'path' => "C:\\MyShareDir",
                     'netname' => "MyShare",
                     'remark' => "It is good to share",
                     'passwd' => "",
                     'current-users' =>0,
                     'permissions' => 0,
                     'maxusers' => -1,
                     'type'  => 0,
                     };
     
     Win32::NetResource::NetShareAdd( $ShareInfo,$parm )
         or die "unable to add share";

DESCRIPTION
===========

   This module offers control over the network resources of Win32.Disks,
printers etc can be shared over a network.

DATA TYPES
==========

   There are two main data types required to control network resources.
In Perl these are represented by hash types.

%NETRESOURCE
          KEY                    VALUE
          
          'Scope'         =>  Scope of an Enumeration
                              RESOURCE_CONNECTED,
                              RESOURCE_GLOBALNET,
                              RESOURCE_REMEMBERED.
          
          'Type'          =>  The type of resource to Enum
                              RESOURCETYPE_ANY    All resources
                              RESOURCETYPE_DISK    Disk resources
                              RESOURCETYPE_PRINT    Print resources
          
          'DisplayType'   =>  The way the resource should be displayed.
                              RESOURCEDISPLAYTYPE_DOMAIN
                              The object should be displayed as a domain.
                              RESOURCEDISPLAYTYPE_GENERIC
                              The method used to display the object does not matter.
                              RESOURCEDISPLAYTYPE_SERVER
                              The object should be displayed as a server.
                              RESOURCEDISPLAYTYPE_SHARE
                              The object should be displayed as a sharepoint.
          
          'Usage'         =>  Specifies the Resources usage:
                              RESOURCEUSAGE_CONNECTABLE
                              RESOURCEUSAGE_CONTAINER.
          
          'LocalName'     =>  Name of the local device the resource is
                              connected to.
          
          'RemoteName'    =>  The network name of the resource.
          
          'Comment'       =>  A string comment.
          
          'Provider'      =>  Name of the provider of the resource.

%SHARE_INFO
     This hash represents the SHARE_INFO_502 struct.

          KEY                    VALUE
          'netname'        =>    Name of the share.
          'type'           =>    type of share.
          'remark'         =>    A string comment.
          'permissions'    =>    Permissions value
          'maxusers'       =>    the max # of users.
          'current-users'  =>    the current # of users.
          'path'           =>    The path of the share.
          'passwd'         =>    A password if one is req'd

FUNCTIONS
=========

NOTE
----

   All of the functions return FALSE (0) if they fail.

GetSharedResources(\@Resources,dwType)
     Creates a list in @Resources of %NETRESOURCE hash references.

     The return value indicates whether there was an error in accessing
     any of the shared resources.  All the shared resources that were
     encountered (until the point of an error, if any) are pushed into
     @Resources as references to %NETRESOURCE hashes.  See example below.

AddConnection(\%NETRESOURCE,$Password,$UserName,$Connection)
     Makes a connection to a network resource specified by %NETRESOURCE

CancelConnection($Name,$Connection,$Force)
     Cancels a connection to a network resource connected to local device
     $name.$Connection is either 1 - persistent connection or 0,
     non-persistent.

WNetGetLastError($ErrorCode,$Description,$Name)
     Gets the Extended Network Error.

GetError( $ErrorCode )
     Gets the last Error for a Win32::NetResource call.

GetUNCName( $UNCName, $LocalPath );
     Returns the UNC name of the disk share connected to $LocalPath in
     $UNCName.

NOTE
----

   $servername is optional for all the calls below. (if not given the
local machine is assumed.)

NetShareAdd(\%SHARE,$parm_err,$servername = NULL )
     Add a share for sharing.

NetShareCheck($device,$type,$servername = NULL )
     Check if a share is available for connection.

NetShareDel( $netname, $servername = NULL )
     Remove a share from a machines list of shares.

NetShareGetInfo( $netname, \%SHARE,$servername=NULL )
     Get the %SHARE_INFO information about the share $netname on the
     server $servername.

NetShareSetInfo( $netname,\%SHARE,$parm_err,$servername=NULL)
     Set the information for share $netname.

EXAMPLE
=======

     #
     # This example displays all the share points in the entire
     # visible part of the network.
     #

     use strict;
     use Win32::NetResource qw(:DEFAULT GetSharedResources GetError);
     my $resources = [];
     unless(GetSharedResources($resources, RESOURCETYPE_ANY)) {
     	my $err = undef;
     	GetError($err);
     	warn Win32::FormatMessage($err);
     }

     foreach my $href (@$resources) {
     	next if ($$href{DisplayType} != RESOURCEDISPLAYTYPE_SHARE);
     	print "-----\n";
     	foreach( keys %$href){
     	    print "$_: $href->{$_}\n";
     	}
     }

AUTHOR
======

   Jesse Dougherty for Hip Communications.

   Additional general cleanups and bug fixes by Gurusamy Sarathy
<gsar@activestate.com>.


File: pm.info,  Node: Win32/PerfLib,  Next: Win32/ProcFarm/Parent,  Prev: Win32/NetResource,  Up: Module List

accessing the Windows NT Performance Counter
********************************************

NAME
====

   Win32::PerfLib - accessing the Windows NT Performance Counter

SYNOPSIS
========

     use Win32::PerfLib;
     my $server = "";
     Win32::PerfLib::GetCounterNames($server, \%counter);
     %r_counter = map { $counter{$_} => $_ } keys %counter;
     # retrieve the id for process object
     $process_obj = $r_counter{Process};
     # retrieve the id for the process ID counter
     $process_id = $r_counter{'ID Process'};

     # create connection to $server
     $perflib = new Win32::PerfLib($server);
     $proc_ref = {};
     # get the performance data for the process object
     $perflib->GetObjectList($process_obj, $proc_ref);
     $perflib->Close();
     $instance_ref = $proc_ref->{Objects}->{$process_obj}->{Instances};
     foreach $p (sort keys %{$instance_ref})
     {
         $counter_ref = $instance_ref->{$p}->{Counters};
         foreach $i (keys %{$counter_ref})
         {
     	  if($counter_ref->{$i}->{CounterNameTitleIndex} == $process_id)
     	  {
     	      printf( "% 6d %s\n", $counter_ref->{$i}->{Counter},
     		      $instance_ref->{$p}->{Name}
     		    );
     	  }
         }
     }

DESCRIPTION
===========

   This module allows to retrieve the performance counter of any computer
(running Windows NT) in the network.

FUNCTIONS
=========

NOTE
----

   All of the functions return FALSE (0) if they fail, unless otherwise
noted.  If the $server argument is undef the local machine is assumed.

Win32::PerfLib::GetCounterNames($server,$hashref)
     Retrieves the counter names and their indices from the registry and
     stores them in the hash reference

Win32::PerfLib::GetCounterHelp($server,$hashref)
     Retrieves the counter help strings and their indices from the
     registry and stores them in the hash reference

$perflib = Win32::PerfLib->new ($server)
     Creates a connection to the performance counters of the given server

$perflib->GetObjectList($objectid,$hashref)
     retrieves the object and counter list of the given performance object.

$perflib->Close($hashref)
     closes the connection to the performance counters

Win32::PerfLib::GetCounterType(countertype)
     converts the counter type to readable string as referenced in
     `calc.html' in this node so that it is easier to find the appropriate
     formula to calculate the raw counter data.

Datastructures
==============

   The performance data is returned in the following data structure:

Level 1
          $hashref = {
              'NumObjectTypes'   => VALUE
              'Objects'          => HASHREF
              'PerfFreq'         => VALUE
              'PerfTime'         => VALUE
              'PerfTime100nSec'  => VALUE
              'SystemName'       => STRING
              'SystemTime'       => VALUE
          }

Level 2
     The hash reference $hashref->{Objects} has the returned object ID(s)
     as keys and a hash reference to the object counter data as value.
     Even there is only one object requested in the call to GetObjectList
     there may be more than one object in the result.

          $hashref->{Objects} = {
              <object1>  => HASHREF
              <object2>  => HASHREF
              ...
          }

Level 3
     Each returned object ID has object-specific performance information.
     If an object has instances like the process object there is also a
     reference to the instance information.

          $hashref->{Objects}->{<object1>} = {
              'DetailLevel'           => VALUE
              'Instances'             => HASHREF
              'Counters'              => HASHREF
              'NumCounters'           => VALUE
              'NumInstances'          => VALUE
              'ObjectHelpTitleIndex'  => VALUE
              'ObjectNameTitleIndex'  => VALUE
              'PerfFreq'              => VALUE
              'PerfTime'              => VALUE
          }

Level 4
     If there are instance information for the object available they are
     stored in the 'Instances' hashref. If the object has no instances
     there is an 'Counters' key instead. The instances or counters are
     numbered.

          $hashref->{Objects}->{<object1>}->{Instances} = {
              <1>     => HASHREF
              <2>     => HASHREF
              ...
              <n>     => HASHREF
          }
          or
          $hashref->{Objects}->{<object1>}->{Counters} = {
              <1>     => HASHREF
              <2>     => HASHREF
              ...
              <n>     => HASHREF
          }

Level 5
          $hashref->{Objects}->{<object1>}->{Instances}->{<1>} = {
              Counters               => HASHREF
              Name                   => STRING
              ParentObjectInstance   => VALUE
              ParentObjectTitleIndex => VALUE
          }
          or
          $hashref->{Objects}->{<object1>}->{Counters}->{<1>} = {
              Counter               => VALUE
              CounterHelpTitleIndex => VALUE
              CounterNameTitleIndex => VALUE
              CounterSize           => VALUE
              CounterType           => VALUE
              DefaultScale          => VALUE
              DetailLevel           => VALUE
              Display               => STRING
          }

Level 6
          $hashref->{Objects}->{<object1>}->{Instances}->{<1>}->{Counters} = {
              <1>     => HASHREF
              <2>     => HASHREF
              ...
              <n>     => HASHREF
          }

Level 7
          $hashref->{Objects}->{<object1>}->{Instances}->{<1>}->{Counters}->{<1>} = {
              Counter               => VALUE
              CounterHelpTitleIndex => VALUE
              CounterNameTitleIndex => VALUE
              CounterSize           => VALUE
              CounterType           => VALUE
              DefaultScale          => VALUE
              DetailLevel           => VALUE
              Display               => STRING
          }

     Depending on the *CounterType* there are calculations to do (see
     calc.html).

AUTHOR
======

   Jutta M. Klebe, jmk@bybyte.de

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Win32/ProcFarm/Parent,  Next: Win32/ProcFarm/PerpetualPool,  Prev: Win32/PerfLib,  Up: Module List

stand-in for child process in ProcFarm RPC system
*************************************************

NAME
====

   Win32::ProcFarm::Parent - stand-in for child process in ProcFarm RPC
system

SYNOPSIS
========

     use Win32::ProcFarm::Parent;
     use Win32::ProcFarm::Port;

     $port_obj = Win32::ProcFarm::Port->new(9000, 1);

     $iface = Win32::ProcFarm::Parent->new_async($port_obj, 'Child.pl', Win32::GetCwd);

     $iface->connect;

     $iface->execute('child_sub', @params);

     until($iface->get_state eq 'fin') {
       print "Waiting for ReturnValue.\n";
       sleep(1);
     }
     print "GotReturnValue.\n";
     print $iface->get_retval;

DESCRIPTION
===========

Installation instructions
-------------------------

   This installs with MakeMaker as part of Win32::ProcFarm.

   To install via MakeMaker, it's the usual procedure - download from CPAN,
extract, type "perl Makefile.PL", "nmake" then "nmake install". Don't do
an "nmake test" because the I haven't written a test suite yet.

State Diagram
-------------

   `Win32::ProcFarm::Parent' is designed to provide support for
asynchronous subroutine calls against the child process.  To support this,
the `Win32::ProcFarm::Parent' object can be in one of four states.

init
     In the init state, the `Win32::ProcFarm::Parent' object has been
     asynchronously spun off, but has yet to establish a communications
     channel via the `Win32::ProcFarm::Port' object.  A call to the
     connect method will rectify this situation and move the object into
     the idle state.

idle
     In the idle state, the child process has yet to be assigned a task
     and is waiting for one to be assigned.  A call to the execute method
     will assign the child process a task and move the
     `Win32::ProcFarm::Parent' object into the wait state.

wait
     In the wait state, the child process has been assigned a task and is
     busy executing it.  Calls to the get_state method will check to see
     if the task has finished executing.  If it has, the
     `Win32::ProcFarm::Parent' object will retrieve the return values,
     store them internally, and move the object into the `fin' state.

`fin'
     In the `fin' state, the `Win32::ProcFarm::Parent' object is waiting
     for the return values to be retrieved by the get_retval method.  A
     call to that method will return the values and move the object back
     into the idle state.

METHODS
=======

new_async
---------

   The new_async method creates a new `Win32::ProcFarm::Parent' object and
spins off the child process, but does not initiate communication with it.
The `Win32::ProcFarm::Parent' object is left in the init state.

   The parameters are:

$port_obj
     A `Win32::ProcFarm::Port' object that will be connected to by the
     child processes.

$script
     The script name to execute for the child processes.

$curdir
     The working directory to use when running the script.  If this is the
     same directory the script is in, the script name can be specified
     without a path.

$timeout
     An optional value indicating how long jobs should be allowed to
     execute before they are deemed to have blocked.  Blocked jobs will be
     terminated and a new process created to take their place.

connect
-------

   The connect method initiates communication with a child process.  Note
that we cannot presume that the order in which the child processes connect
to the TCP port is the same order in which they were started.  The first
thing the child process does upon the TCP connection being accepted is to
send its unique identifier, which the `Win32::ProcFarm::Parent' object
uses to retrieve the appropriate `Win32::Process' from the class hash of
those objects.

   The connect call moves the `Win32::ProcFarm::Parent' object into the
idle state.

execute
-------

   The execute command instructs the child process to start executing a
given subroutine with a list of passed parameters.  The data is send over
the socket connection and the `Win32::ProcFarm::Parent' object moved into
the wait state.

get_state
---------

   The get_state method returns the current state.  If the current state
is wait, the method first checks to see if the child process has finished
executing the subrouting call.  If it has, the method retrieves the return
data and moves the `Win32::ProcFarm::Parent' object into the `fin' state.

   The get_state method is also responsible for dealing with timeout
scenarios where the child process has exceeded the time allowed to execute
the subroutine.  In that situation, the child process is terminated and a
new child process initiated, connected to, and the
`Win32::ProcFarm::Parent' object placed in the `fin' state.

get_retval
----------

   The get_retval method returns the list of return values returned by the
child process and moves the `Win32::ProcFarm::Parent' object into the idle
state.


File: pm.info,  Node: Win32/ProcFarm/PerpetualPool,  Next: Win32/ProcFarm/Pool,  Prev: Win32/ProcFarm/Parent,  Up: Module List

manages a pool of child processes for perpetual jobs
****************************************************

NAME
====

   Win32::ProcFarm::PerpetualPool - manages a pool of child processes for
perpetual jobs

SYNOPSIS
========

     use Win32::ProcFarm::PerpetualPool;

     $Pool = Win32::ProcFarm::PerpetualPool->new($poolsize, $portnum, $scriptname, Win32::GetCwd,
       command => 'whatever',
       list_check_intvl => 30,
       exit_check_intvl => 5,
       list_sub => sub { return ('Fred', 'Julie', 'Joe') },
       exit_sub => sub { return -e 'killme'; },
       result_sub => sub { print join(', ' @_)."\n"; },
     );

     $Pool->start_pool(0.1);

DESCRIPTION
===========

Installation instructions
-------------------------

   This installs with MakeMaker as part of Win32::ProcFarm.

   To install via MakeMaker, it's the usual procedure - download from CPAN,
extract, type "perl Makefile.PL", "nmake" then "nmake install". Don't do
an "nmake test" because the I haven't written a test suite yet.

More usage instructions
-----------------------

   This is a version of Win32::ProcFarm::Pool designed for continuous
operation.  You supply a single command name and a subroutine that returns
a list of keys.  The keys are passed as the sole parameter to the command
(it is presumed that the child process can do whatever needs to be done
based on that single key).  The subroutine that returns the list of keys
will be periodically executed (every 120 seconds by default, but
adjustable via list_intvl) and the running list updated as needed.
Whenever a job finishes, that key is added back onto the end of the waiting
pool.

METHODS
=======


File: pm.info,  Node: Win32/ProcFarm/Pool,  Next: Win32/ProcFarm/Port,  Prev: Win32/ProcFarm/PerpetualPool,  Up: Module List

manages a pool of child processes
*********************************

NAME
====

   Win32::ProcFarm::Pool - manages a pool of child processes

SYNOPSIS
========

     use Win32::ProcFarm::Pool;

     $Pool = Win32::ProcFarm::Pool->new($poolsize, $portnum, $scriptname, Win32::GetCwd);

     foreach $i (@list) {
       $Pool->add_waiting_job($i, 'child_sub', $i);
     }

     $Pool->do_all_jobs(0.1);

     %ping_data = $Pool->get_return_data;
     $Pool->clear_return_data;

     foreach $i (@list) {
       print "$i:\t$ping_data{$i}->[0]\n";
     }

DESCRIPTION
===========

Installation instructions
-------------------------

   This installs with MakeMaker as part of Win32::ProcFarm.

   To install via MakeMaker, it's the usual procedure - download from CPAN,
extract, type "perl Makefile.PL", "nmake" then "nmake install". Don't do
an "nmake test" because the I haven't written a test suite yet.

More usage instructions
-----------------------

   See `Docs/tutorial.pod' for more information.

METHODS
=======

new
---

   The new method creates a new `Win32::ProcFarm::Pool' object (amazing,
eh!).  It takes 5 parameters:

$num_threads
     This indicates the number of threads that should be created.

$port_num
     This indicates the port number to use for the listener.

$script
     The script name to execute for the child processes.

$curdir
     The working directory to use when running the script.  If this is the
     same directory the script is in, the script name can be specified
     without a path.

%options
     A hash of options.  The current options are:

    timeout
          Indicates how long jobs should be allowed to execute before they
          are deemed to have blocked.  Blocked jobs will be terminated and
          a new process created to take their place.

add_waiting_job
---------------

   The add_waiting_job method adds a job to the waiting pool.  It takes
three parameters:

$key
     This should be a unique identifier that will be used to retrieve the
     return values from the return data hash.

$command
     The name of the subroutine that the child process will execute.

@params
     A list of parameters for that subroutine.

do_all_jobs
-----------

   The do_all_jobs command will execute all the jobs in the waiting pool.
The single passed parameter specifies the number of seconds to wait
between sweeps through the thread pool to check for completed jobs.  The
number of seconds can be fractional (i.e. 0.1 for a tenth of a second).

get_return_data
---------------

   Return the return_data hash, indexed on the unique key passed initially.

clear_return_data
-----------------

   Clears out the return_data hash.

INTERNAL METHODS
================

   These methods are considered internal methods.  Child classes of
Win32::ProcFarm::Pool may modify these methods in order to change the
behavior of the resultant Pool object.


File: pm.info,  Node: Win32/ProcFarm/Port,  Next: Win32/RASE,  Prev: Win32/ProcFarm/Pool,  Up: Module List

manages access to the TCP port for ProcFarm system
**************************************************

NAME
====

   Win32::ProcFarm::Port - manages access to the TCP port for ProcFarm
system

SYNOPSIS
========

     use Win32::ProcFarm::Port;

     $port_obj = Win32::ProcFarm::Port->new(9000, 1);

     print $port_obj->get_port_num;

     $socket = $port_obj->get_next_connection;

DESCRIPTION
===========

Installation instructions
-------------------------

   This installs with MakeMaker as part of Win32::ProcFarm.

   To install via MakeMaker, it's the usual procedure - download from CPAN,
extract, type "perl Makefile.PL", "nmake" then "nmake install". Don't do
an "nmake test" because the I haven't written a test suite yet.

METHODS
=======

new
---

   The new method creates a new `Win32::ProcFarm::Port' object (fancy
that!).  It takes two parameters - the first is the port number to listen
on, and the second is the number of listeners to create - this will
specify the number of "hold lines" for the port object.

get_port_num
------------

   This returns the port number passed in the new method.

get_next_connection
-------------------

   This accepts an inbound connection and returns the socket object.  If
the inbound connection is not from 127.0.0.1, the method calls die as this
indicates an attempt to hack the system by an external host.


File: pm.info,  Node: Win32/RASE,  Next: Win32/Semaphore,  Prev: Win32/ProcFarm/Port,  Up: Module List

managing dialup entries and network connections on Win32
********************************************************

NAME
====

   Win32::RASE - managing dialup entries and network connections on Win32

SYNOPSIS
========

     use Win32::RASE;

ABSTRACT
========

   This module implements the client part of Win32 RAS API.

   It is named RASE(RAS-entry) because it was originally designed to
create/delete/change/manage RAS/DUN entries. Now it implements synchronous
dialing, hang up and the wide range of RAS/DUN entry manipulations.

   The current version of Win32::RASE is available at:

     http://www.dux.ru/guest/fno/perl/

DESCRIPTION
===========

   This module is a collection of subroutines. As their names are very long
and specific and almost each corresponds to a Win32 API call I decided to
export a lot of them by default. Everything is exported except those subs
that are claimed as non-exported.

   OK, you can require it instead of use.

   *!!! IMPORTANT !!!* All functions (if the other behavior is not stated
explicitly) return TRUE on success, FALSE on error to conform the handy
calling rule

     RESULT = function(PARAMS) or die MESSAGE;

   where RESULT could be scalar or list either. Note that "||" is not the
same thing as "or".

   The following logic is used: almost all functions croak on obvious
programmer's errors like invalid entry-name or such.  But they return
FALSE and set LastError on internal API errors.  It is made to give the
programmer a chance to complete all actions and may be to trap some errors
without exiting the program.

   For example if some phonebook file is corrupted you have a chance to
try another one etc.

   The following two functions are available after any other function was
executed.  They are both non-exported to provide feel and look of
Win32-Perl built-in functions with the same names.

GetLastError ( )
     Returns 0 or the last encountered RAS, TAPI or Windows error number.

          $lastErr = Win32::RASE::GetLastError();

     Usually you should call this function after some other function
     returned undef. In case of Windows error it returns the same value as
     `Win32::GetLastError'. Unlike the built-in one it always returns 0 if
     the last called function finished successfully.

     You can use it for example like this:

          some_function();
          Win32::RASE::GetLastError and die Win32::RASE::FormatMessage;

     or implicitly

          some_function() or die Win32::RASE::FormatMessage;

FormatMessage ( )
     Converts the supplied RAS, TAPI or Win32 error number (e.g.  returned
     by `Win32::RASE::GetLastError()') to a descriptive string.

          $message = Win32::RASE::FormatMessage($err_num);

     Without the parameter assumes that the result of
     `Win32::RASE::GetLastError()' was sent.

IsWindow ( )
     This function is non-exported for not to corrupt some other GUI
     related synonym.

          Win32::RASE::IsWindow( $hwnd );

     Returns TRUE if $hwnd identifies an existing window, otherwise FALSE.

     This function is handy to use before the functions that display a
     dialog box - to verify the parent window.

   * =====================================*

   * PHONEBOOK RELATED FUNCTIONS*

   * =====================================*

   Note that by default all functions in this section work with the
default phonebook (on Windows NT).

   The registry key `"HKEY_CURRENT_USER\Software\Microsoft\RAS Phonebook"'
has a dword subkey "PhonebookMode" which could have 3 values:

     0 - the "system" phonebook is in use.
         This is probably %SYSTEMROOT%\system32\ras\rasphone.pbk
     1 - the "user" phonebook is in use.
         This one is located in  %SYSTEMROOT%\system32\ras\<filename>
         <filename> here is the value of "PersonalPhonebookFile" subkey
         that is located under the same key.
     2 - the "alternate" phonebook is in use.
         The full path to the alternate phonebook could be found in the
         "AlternatePhonebookPath" subkey under the same key.

   This version of `Win32::RASE' provides no way to change these registry
settings. If `"HKEY_CURRENT_USER\Software\Microsoft\RAS
Phonebook\PhonebookMode"' is equal to 0 `Win32::RASE' will use the
"system" phonebook, in case 1 - the "user" phonebook, in case 2 - the
"alternate" phonebook.

   The user can use the main Dial-Up Networking dialog box to create
personal phonebook files or change defaults (registry settings). The Win32
API does not currently provide support for creating a phonebook file.

   *IMPORTANT:*

   At any time you can set a global variable *$Win32::RASE::PHONEBOOK* to
the full path of your phonebook file, and this phonebook will be in use
until *$Win32::RASE::PHONEBOOK* is changed. Setting this variable to 0 or
undef returns us to registry defined phonebook(s).

   *Windows 95/98:* Dial-up networking stores phonebook entries in the
registry rather than in a phonebook file. Windows 9x does not support
personal phonebook files. So *$Win32::RASE::PHONEBOOK* has no meaning and
must always be undef.

   All functions treat entry-names as case-sensitive because RAS functions
are kinda semi-case-sensitive. Some of them fail when entry was given with
case-changes. But at the same time RasSetEntryProperties API call (in
`RasCopyEntry()') fails to create both QWERTY and QwErTy, it renames
instead. Ou-h-h MS, MS...

   The moral is: don't use names that differ only in upper/lower case.

   There also is a danger in using multiple processes that are calling RAS
APIs that update the phonebook. Microsoft reported this problem has been
corrected in Service Pack 3.


http://support.microsoft.com/support/ntserver/serviceware/nts40/E9MSKWBJI.ASP

   *A note on multilink functionality*: there are no ways to use Multilink
programmatically on Win95/98. So, the current version of the module does
not support it for WinNT also. For more info read:

   http://support.microsoft.com/support/kb/articles/q198/7/77.asp

   Entry names for Windows CE cannot exceed 20 characters.
http://msdn.microsoft.com/library/wincesdk/wcecomm/ras_24.htm

   A similiar problem is reported for the InternetMail Service (IMS) on MS
BackOffice Small Business Server version 4.5 and Windows NT Server version
4.0 http://support.microsoft.com/support/kb/articles/Q217/9/37.asp

   So, the entries with long names may be unusable by the other
applications.

RasCreateEntryDlg ( )
     This function displays a dialog box in which the user types
     information about the phonebook entry.

          RasCreateEntryDlg( [$hwnd] );

          $hwnd  - handle to the parent window of the dialog box. Optional.
                   If you are using Win32::GUI this would be $Window->{handle}

     As this is a synchronous operation and waits for user input it
     provides no way to find out whether the new entry was created or not.
     You should use `RasEnumEntries()' to understand what has happened.

     Here and everywhere in the functions that display a dialog box - if
     `$hwnd' is omitted or does not identify an existing window a dialog
     box is centered on the screen.

RasEditEntryDlg ( )
     This function displays a dialog box in which the user types
     information about the phonebook entry. For a programmatical way to
     edit an existing entry take a look at `RasSetEntryProperties()'.

          RasEditEntryDlg( $entry [, $hwnd] );

          $entry - existing phonebook entry to edit.

          $hwnd  - handle to the parent window of the dialog box. Optional.
                   If you are using Win32::GUI this would be $Window->{handle}

     This is a synchronous operation and waits for user input.

     Croaks if $entry does not exist.  You should call `IsEntry()' before
     to verify $entry.

RasRenameEntry ( )
          RasRenameEntry( $oldname, $newname );

     Croaks if `$oldname' does not exist or `$newname' already exists.
     You should call `IsEntry()' or `RasEnumEntries()' before to verify
     both.

RasDeleteEntry ( )
          RasDeleteEntry( $entry );

     Croaks if $entry does not exist.  You should call `IsEntry()' or
     `RasEnumEntries()' before to verify $entry.

RasEnumEntries ( )
          @entries = RasEnumEntries();

     This function lists all entry names in the phonebook.

     As this function is heavily used internally it croaks on errors - for
     example if non-existing phonebook name is given. So, FALSE result
     means that the selected phonebook is empty.

     Command line syntax:

          perl -MWin32::RASE -e "$,=q{, };print RasEnumEntries"

IsEntry ( )
          IsEntry ( $entry );

          $entry  - name of the RAS/DUN entry

     Returns TRUE if $entry was found in the phonebook, otherwise FALSE.

     *NOTE!* It treats entry-names as case-sensitive (see above).

RasGetEntryDialParams ( )
     This function retrieves the connection information saved by the last
     successful call to the `RasDial()' or `RasSetEntryDialParams()'
     function for a specified phonebook entry.

          ($UserName, $Password, $Domain, $CallbackNumber) =
                                     RasGetEntryDialParams($entry);

          $entry          - name of RAS/DUN entry
          $UserName       - user's user name ;-)
          $Password       - yes, it's that secure
          $Domain         - domain on which authentication is to occur
          $CallbackNumber - callback phone number

     Croaks if $entry does not exist.

RasGetUserPwd ( )
     The short variant of previous.

          ($UserName, $Password) = RasGetUserPwd($entry);

     Croaks if $entry does not exist.

     Command line syntax:

          perl -MWin32::RASE -e "print ((RasGetUserPwd('NEV1'))[0])"
          perl -MWin32::RASE -e "@_=RasGetUserPwd('NEV1');print qq{@_}"

RasSetEntryDialParams ( )
     This function changes the connection information for a specified
     phonebook entry.

          RasSetEntryDialParams($entry, $UserName, $Password, $Domain,
                                $CallbackNumber, $fRemovePassword);

     All parameters except $entry are optional. undef or omitted
     parameters are considered to be "" - this means that no changes will
     be made to this parameter.

          $entry           - name of RAS/DUN entry
          $UserName        - user name
          $Password        - password for the user specified by $UserName.
               If $UserName is an empty string, the password is not changed.
               If $Password is an empty string and $fRemovePassword is FALSE,
               the password is set to the empty string. If $fRemovePassword is
               TRUE, the password stored in this phonebook entry for the user
               specified by $UserName is removed regardless of the contents
               of the $Password string.
          $Domain          - domain on which authentication is to occur.
                             15 chars limitation.
          $CallbackNumber  - callback phone number
          $fRemovePassword - (above) 0 if undefined/omitted

     This is another excerpt from the API docs:

     *Windows NT:* You can use $Password to send a new password to the
     remote server when you restart a RasDial() connection from a
     RASCS_PasswordExpired paused state.  When changing a password on an
     entry that calls Microsoft Networks, you should limit the new
     password to 14 characters in length to avoid down-level compatibility
     problems.

     Croaks if $entry does not exist.

RasGetEntryProperties ( )
     This function retrieves the properties of a phonebook entry.

          $props = RasGetEntryProperties($entry);

          $entry          - name of RAS/DUN entry
          $props          - pointer to hash

     The description of the %$props hash is common for this function and
     `RasSetEntryProperties()'.

          KEY                         VALUE

          name           - copy of $entry
          Flags          - numeric flag value, combination of RASEO_* flags.
                           You don't need to use it directly, it's here for
                           information purpose only. In RasSetEntryProperties()
                           it is ignored if present, you should manipulate
                           mnemonic flags as described below, with the
                           'newFlags' key.
          FlagsReadable  - $props->{FlagsReadable} refers to array of
                           "mnemonic flags" that are affecting the behavior
                           of the other properties.
                           Not used by RasSetEntryProperties().

     Manipulating these flags is described in `RasSetEntryProperties()'
     section.

          ipaddr         - constant ip-address, ignored unless "SpecificIpAddr"
                           is present in the array of "mnemonic flags"
          ipaddrDns      - primary DNS server
          ipaddrDnsAlt   - secondary(backup) DNS server
          ipaddrWins     - IP address of the primary WINS server
          ipaddrWinsAlt  - secondary WINS server

     `ipaddrDns', `ipaddrDnsAlt', `ipaddrWins', `ipaddrWinsAlt' are
     ignored unless "SpecificNameServers" is present in the array of
     "mnemonic flags"

     All IP-addresses are in xxx.xxx.xxx.xxx decimal form without leading
     zeros in each part(octet). For example: 195.100.0.28

     The common rule here is that empty or blank values will produce
     0.0.0.0 (as well as "0.0.0.0" itself).

          CountryID        -
          CountryName      -
          CountryCode      -
          AreaCode         -

     (Country ID-Name-Code and AreaCode are described in the
     `TAPIlineGetTranslateCaps()' section except that here they are
     describing the computer you want to dial to.)

     In `RasSetEntryProperties()' `CountryName' would be ignored.
     `CountryID' not matching `CountryCode' would give error. You could
     easily give only one of these two values. `CountryCode' would be
     counted properly if `CountryID' is given (described in
     `TAPIlineGetTranslateCaps()' section). But if you'll give
     `CountryCode' `CountryID' would be set equal to `CountryCode' that is
     sometimes incorrect but does not affect the dialup connection.

     You can also check the correctness of the `CountryID' with the
     `IsCountryID()' function.

          LocalPhoneNumber - phone number without country/area parts

          Script           - script file's path.
                             On Win95 this is DialUp Scripting Tool script.

     Windows NT: To indicate a SWITCH.INF script name, set the first
     character of the name to "[".

     `RasSetEntryProperties()' function may have a problem saving the full
     script path (NT, fixed in the Service Pack 4).
     http://support.microsoft.com/support/kb/articles/Q160/1/90.asp

          DeviceType     - one of the following string constants
                           (case-insensitive):
            "modem"    A modem accessed through a COM port
            "isdn"     An ISDN card with corresponding NDISWAN driver installed
            "x25"      An X.25 card with corresponding NDISWAN driver installed
                       "x25" type is not implemented in RasSetEntryProperties()
                       in this version of the module
            "vpn"      A Microsoft VPN Adapter

     You can read a note about VPN and PPTP in the
     `RasSetEntryProperties()' section.

          DeviceName    - name of a TAPI device to use with this phonebook entry

          NetProtocols  - network protocols to negotiate.
                          $props->{NetProtocols} refers to the array that can
                          contain one or more of the strings
                          (case insensitive in RasSetEntryProperties()):
            "NetBEUI"  NetBIOS End User Interface standard
            "Ipx"      IPX/SPX Compartible
            "Ip"       TCP/IP

          FramingProtocol  - framing protocol used by the server.
                             One of the following strings:
                             "PPP", "Slip", "RAS"
                             (case insensitive in RasSetEntryProperties())

     *Limitations:*

     Subentries(multilink dialing) are currently not supported as well as
     X.25-related parameters. Current version of Win32::RASE also does not
     allow you to change 'DeviceType' and 'DeviceName' elements. This will
     be added in some future.  Right now any changes in these fields will
     not affect the `RasSetEntryProperties()' execution.

     Note: don't misuse this function, in list context it returns
     unreadable things for internal needs.

     Croaks if $entry does not exist.

     For an easy way to change just the phone-number take a look at the
     `RasChangePhoneNumber()' section.

RasPrintEntryProperties ( )
     This function provides nice printing of a phonebook entry properties.
     For debugging, for fun etc.

          RasPrintEntryProperties( $entry );

          $entry          - name of RAS/DUN entry

     Croaks if $entry does not exist.

RasGetEntryDevProperties ( )
     This function retrieves the properties of a device used by the
     phonebook entry if this entry uses MS Unimodem compartible TSP
     (Telephone Service Provider) or in other words - Unimodem compartible
     driver, on Win95 - always.

          $props = RasGetEntryDevProperties($entry);

          $entry          - name of RAS/DUN entry
          $props          - pointer to hash

     (Sorry, the description might not be clear enough, just print your
     properties with the `RasPrintEntryDevProperties()' and it'd be much
     easier.)

     The description of the `%$props' hash is common for this function and
     `RasSetEntryDevProperties()' (not implemented yet).

     It's much likely that only a small part of the described data is
     really usefull. Look at the Win32 SDK/MS Platform SDK (TAPI
     Prorammer's Reference - "comm/datamodem", "COMMCONFIG", "DCB",
     "MODEMSETTINGS" sections) for more info.

          KEY                         VALUE

          name         - copy of $entry
          DeviceName   - name of a TAPI device to use with this phonebook entry
          DeviceType   - described in the RasGetEntryProperties() section

          Options      - numeric flag value, combination of the Option flags
                         that appear on the Unimodem Option page.
                         This member can be a combination of these values:

          TERMINAL_PRE  (1) - Displays the pre-terminal screen.
          TERMINAL_POST (2) - Displays the post-terminal screen.
          MANUAL_DIAL   (4) - Dials the phone manually, if capable of doing so
          LAUNCH_LIGHTS (8) - Displays the modem tray icon.

          Only the LAUNCH_LIGHTS value is set by default

          OptionsReadable  - an array ref, a readable representation of those
                Options, that are switched on. The array consists of zero or more
                strings
                "TERMINAL_PRE", "TERMINAL_POST", "MANUAL_DIAL", "LAUNCH_LIGHTS"

          WaitBong         - Number of seconds (in two seconds granularity) to
                             replace the wait for credit tone (default - 10 s)

          CallSetupFailTimer - the maximum number of seconds the modem should
                wait, after dialing is completed, for an indication that a
                modem-to-modem connection has been established. If a connection
                is not established in this interval, the call is assumed to have
                failed. This member is equivalent to register S7 in Hayes
                compatible modems.

          InactivityTimeout  - the maximum number of seconds of inactivity
                allowed after a connection is established. If no data is either
                transmitted or received for this period of time, the call is
                automatically terminated.
                This time-out is used to avoid excessive long distance charges
                or online service charges if an application unexpectedly locks up
                or the user leaves.

          SpeakerVolume    - one of the following values: "LOW", "MEDIUM", "HIGH"
                Note that actual volumes are hardware-specific.

          SpeakerMode      - one of the following values:
               "OFF"       - The speaker is always off
               "CALLSETUP" - The speaker is on until a connection is established
               "ON"        - The speaker is always on
               "DIAL"      - The speaker is on until a connection is established,
                        except that it is off while the modem is actually dialing

          PreferredModemOptions - a numeric flag value. Specifies the modem
               options requested by the application. The local and remote modems
               negotiate modem options during call setup; this member specifies
               the initial negotiating position of the local modem. A combination
               of bit flags.

          PreferredModemOptionsReadable - refers to array of strings that
               represent bit flags of the previous. Contains zero or more of the
               following strings:
               "COMPRESSION", "ERROR_CONTROL", "FORCED_EC",
               "CELLULAR", "FLOWCONTROL_HARD", "FLOWCONTROL_SOFT",
               "CCITT_OVERRIDE", "SPEED_ADJUST",
               "TONE_DIAL", "BLIND_DIAL", "V23_OVERRIDE"

          Comments:
          CCITT_OVERRIDE - When set, CCITT modulations are enabled for V.21
                           and V.22 or V.23.When clear, bell modulations
                           are enabled for 103 and 212A.
          V23_OVERRIDE   - When set, CCITT modulations are enabled for V.23.
                           When clear, CCITT modulations are enabled for
                           V.21 and V.22.

     For V.23 to be set, both CCITT_OVERRIDE and V23_OVERRIDE must be set.

          NegotiatedModemOptions - a numeric flag value. Specifies the modem
               options that are actually in effect. This member is filled in
               after a connection is established and the local and remote
               modems negotiate modem options. This value is read only.
               (On my Win95 - always 0).

          NegotiatedModemOptionsReadable - the same ref to array of the readable
               strings as PreferredModemOptionsReadable,
               but for NegotiatedModemOptions.

          NegotiatedDCERate - Specifies the DCE rate that is in effect.
               This member is filled in after a connection is established and
               the local and remote modems negotiate modem modulations.
               Also read-only.
          
          DCE - Open Software Foundation (OSF) Distributed Computing Environment.

     The DCB structure defines the control setting for a serial
     communications device.  The following keys are members of the DCB
     structure.

          DCB_BaudRate     - Specifies the baud rate at which the communications
               device operates. This member can be one of the following values:
               110, 300, 600, 1200, 2400, 4800, 9600, 14400, 38400,
               56000, 57600, 115200, 128000, 256000

          DCB_Flags        - numeric flag value, concatenation of many DCB flags.
                             You don't need to use it directly, it's here for
                             information purpose only.

          DCB_FlagsReadable - an array ref. The array consists of the 13 string
               values. Each string is in the form "flagname:value".
               The values are in most cases 0/1. The flags names are:

          fBinary          - Specifies whether binary mode is enabled.
              The Win32 API does not support nonbinary mode transfers, so this
              member should be 1. Trying to use 0 will not work.
              Under Windows 3.1, if this member is 0, nonbinary mode is
              enabled, and the character specified by the DBC_EofChar member
              is recognized on input and remembered as the end of data. (0/1)

          fParity          - Specifies whether parity checking is enabled (0/1)

          fOutxCtsFlow     - Specifies whether the CTS (clear-to-send) signal
              is monitored for output flow control. If this member is 1 and CTS
              is turned off, output is suspended until CTS is sent again. (0/1)

          fOutxDsrFlow     - Specifies whether the DSR (data-set-ready) signal
              is monitored for output flow control. If this member is 1 and DSR
              is turned off, output is suspended until DSR is sent again. (0/1)

          fDtrControl      - Specifies the DTR (data-terminal-ready)
                             flow control.
            This member can be one of the following values:
            0 - Disables the DTR line when the device is opened and leaves it
                disabled
            1 - Enables the DTR line when the device is opened and leaves it on
            2 - Enables DTR handshaking

          fDsrSensitivity  - Specifies whether the communications driver is
              sensitive to the state of the DSR signal. If this member is 1,
              the driver ignores any bytes received, unless the DSR modem input
              line is high. (0/1)

          fTXContinueOnXoff - Specifies whether transmission stops when the
              input buffer is full and the driver has transmitted the
              DCB_XoffChar character.
              If this member is 1, transmission continues after the input
              buffer has come within DCB_XoffLim bytes of being full and the
              driver has transmitted the DCB_XoffChar character to stop
              receiving bytes.
              If this member is 0, transmission does not continue until the
              input buffer is within DCB_XonLim bytes of being empty and the
              driver has transmitted the DCB_XonChar character to resume
              reception. (0/1)

          fOutX            - Specifies whether XON/XOFF flow control is used
              during transmission. If this member is 1, transmission stops when
              the DCB_XoffChar character is received and starts again when the
              DCB_XonChar character is received. (0/1)

          fInX              - Specifies whether XON/XOFF flow control is used
              during reception. If this member is 1, the DCB_XoffChar character
              is sent when the input buffer comes within DCB_XoffLim bytes of
              being full, and the DCB_XonChar character is sent when the input
              buffer comes within DCB_XonLim bytes of being empty. (0/1)

          fErrorChar        - Specifies whether bytes received with parity
              errors are replaced with the character specified by the
              DCB_ErrorChar member.
              If this member is 1 and the fParity member is 1, replacement
              occurs. (0/1)

          fNull             - pecifies whether null bytes are discarded.
              If this member is 1, null bytes are discarded when received.(0/1)

          fRtsControl       - Specifies the RTS (request-to-send) flow control.
              This member can be one of the following values:
              0 - Disables the RTS line when the device is opened and leaves
                  it disabled.
              1 - Enables the RTS line when the device is opened and leaves
                  it on.
              2 - Enables RTS handshaking. The driver raises the RTS line when
                  the "type-ahead" (input) buffer is less than one-half full
                  and lowers the RTS line when the buffer is more than
                  three-quarters full.
              3 - Specifies that the RTS line will be high if bytes are
                  available for transmission. After all buffered bytes have
                  been sent, the RTS line will be low.

          fAbortOnError    - Specifies whether read and write operations are
              terminated if an error occurs. If this member is 1, the driver
              terminates all read and write operations with an error status if
              an error occurs. (0/1)

          DCB_XonLim      - Specifies the minimum number of bytes allowed in the
                input buffer before the XON character is sent.

          DCB_XoffLim     - Specifies the maximum number of bytes allowed in the
                input buffer before the XOFF character is sent. The maximum
                number of bytes allowed is calculated by subtracting this value
                from the size, in bytes, of the input buffer.

          DCB_ByteSize    - Specifies the number of bits in the bytes transmitted
                            and received.

          DCB_Parity      - Specifies the parity scheme to be used. This member
                            can be one of the following values:
                            "No parity", "Odd", "Even", "Mark", "Space"

          DCB_StopBits    - Specifies the number of stop bits to be used.
                            This member can be one of the following values:
                0 - 1 stop bit
                1 - 1.5 stop bits
                2 - 2 stop bits

          DCB_XonChar     - Specifies the value of the XON character for both
                            transmission and reception.

          DCB_XoffChar    - Specifies the value of the XOFF character for both
                            transmission and reception.

          DCB_ErrorChar   - Specifies the value of the character used to replace
                            bytes received with a parity error.

          DCB_EofChar     - Specifies the value of the character used to signal
                            the end of data.

          DCB_EvtChar     - Specifies the value of the character used to signal
                            an event.

     Manipulating these flags is described in `RasSetEntryDevProperties()'
     section.  (not implemented yet).

     The function croaks if $entry does not exist.

RasPrintEntryDevProperties ( )
     This function provides nice printing of a phonebook entry device
     properties if this entry uses MS Unimodem compartible TSP (Telephone
     Service Provider) or in other words - Unimodem compartible driver, on
     Win95 - always.

     Look at the `RasGetEntryDevProperties()' section and Win32 SDK for
     more info.

     Char values (XonChar, XoffChar, ErrorChar, EofChar, EvtChar) are
     printed in hexadecimal form like 0x13.

     For debugging, for fun etc.

          RasPrintEntryDevProperties( $entry );

          $entry          - name of RAS/DUN entry

     Croaks if $entry does not exist. Silently returns if the device is not
     Unimodem-compartible.

RasCopyEntry ( )
     This function makes a copy of the existing RAS entry.  Some
     properties of this newly created entry could then be changed with the
     use of `RasSetEntryProperties()'. In previous versions of the module
     it was the only way to create a new entry silently, programmatically.
     But as of 0.07 we have full featured `RasCreateEntry()'.

     You can also create new entry via dialog, see `RasCreateEntryDlg()'.

          RasCopyEntry( $oldname, $newname );

     Croaks if `$oldname' does not exist or `$newname' already exists.
     You should call `IsEntry()' or `RasEnumEntries()' before to verify
     both.

     `$newname' must contain at least one non-white-space alphanumeric
     character and cannot begin with a period (".").

     Username, password etc. (see `RasGetEntryDialParams()' and
     `RasSetEntryDialParams()') are not copied to the newly created entry.

RasSetEntryProperties ( )
     This function changes the connection information for an existing
     entry.

          RasSetEntryProperties( $props );

          $props          - reference to hash with replacing properties

     Mainly keys/values of the %$props hash are described in the
     `RasGetEntryProperties()' section. But here we can use just part of
     the full hash - if keys are undefined no changes will be made to the
     corresponding properties. Only $props->{name} has to contain a name
     of the existing phonebook entry, all other keys are optional.

     Those properties that do exist in %$props will replace current
     properties.  If $props->{some-key} is defined and empty ("") the
     corresponding property will be empty.

     `DeviceType', `CountryName', Flags and `FlagsReadable' keys are not
     used by this function. Anyway, all unneeded keys will be ignored
     without any errors.

     As of the version 0.07 you can change the RAS device using with the
     entry by specifying the new device name in $props->{DeviceName}.  The
     function finds the device type internally, so $props->{DeviceType} is
     ignored if specified.

     If "DeviceName" key is present in the `%$props' the function resets
     device properties for `$props-'{name}> entry to the default values
     (for the list of device properties see `RasGetEntryDevProperties()').
     `RasEnumDevices()' function gives the RAS-capable devices enumeration.

     *Microsoft has confirmed a possible problem*: With multiple modems
     installed under Windows NT 4.0, the RasSetEntryProperties API
     function calls will reset the selected modem to the first available
     modem.  This problem has been corrected in the latest U.S. Service
     Pack (4).

     Print the whole enumeraton like this:

          %devices = RasEnumDevices() or die "Error";
          print map "\"$_\" of type \"$devices{$_}\"\n", keys %devices;

     In addition to the keys decribed in the `RasGetEntryProperties()'
     section the string value $props->{newFlags} can be used for
     adding/removing the existing flags within the RAS-entry.

     This string has the format: "<token1> <token2>..." (any `\s'
     separators are possible)

     Each token can be one of the following values (same as mnemonic flags
     described in the `RasGetEntryProperties()' section):

          UseCountryAndAreaCodes
          SpecificIpAddr
          SpecificNameServers
          IpHeaderCompression
          RemoteDefaultGateway
          DisableLcpExtensions
          TerminalBeforeDial
          TerminalAfterDial
          ModemLights
          SwCompression
          RequireEncryptedPw
          RequireMsEncryptedPw
          RequireDataEncryption
          NetworkLogon
          UseLogonCredentials
          PromoteAlternates
          SecureLocalFiles

     These strings are just the meaningful parts of `RASEO_*' constants'
     names (from "ras.h" file). They are rather descriptive, you can
     easily find their meaning by changing and printing an existing RAS
     entry. Not all of them will work in this version of the module.

     Each of these flags could be used with or without the "RASEO_" prefix.
     With or without `+' or `-' prefix (no blanks between [+-] and
     "mnemonic flag") - this is the token mentioned above.

     Additional token that can't be prefixed with `+' or `-' is
     "KeepOldFlags", it still can be prefixed with "RASEO_".

     If this new flag-string ($props->{newFlags}) is defined the default
     action is to reset all old flags. "KeepOldFlags" prevents from this
     cleanup.

     The token with `-' will reset the corresponding flag if it was set,
     otherwise - no effect. The token with `+' will set the corresponding
     flag if it was not set, otherwise - no effect. The order of tokens is
     not important, tokens are separated by any number of blanks. Token
     without `+' or `-' means `+'.

     Examples:

     `"NetworkLogon +SwCompression"' - reset old flags and add these two.

     `"-NetworkLogon -SwCompression KeepOldFlags"' - keep old flags and
     clean these two.

     The function croaks if $entry does not exist and on some impossible
     values of the parameters.

     *PPTP note* (Point to Point Tunneling Protocol): You can use an
     ip-address in place of LocalPhoneNumber if your DUN/RAS entry is
     configured to work with VPN (Virtual Private Networking) via PPTP.
     PPTP appears as a new modem type that can be selected in DUN entry
     only manually.  It DeviceName is "Microsoft VPN Adapter" and
     DeviceType is "vpn".  In this case you can change the ip-address of
     the VPN-host as if it were local phone number. For example

          RasSetEntryProperties({
                name=>"NEV5",
                LocalPhoneNumber=>"21.100.14.12",
          });

     You can get info about VPN and PPTP at

     http://support.microsoft.com/support/kb/articles/q154/0/91.asp

     DUN 1.3 that supports VPN is downloadable from

     http://support.microsoft.com/download/support/mslfiles/MSDUN13.EXE

     and is described here

     http://support.microsoft.com/support/kb/articles/q194/4/77.asp

     Thanks to Carl Sewell <csewell@hiwaay.net> for his explanations and
     testing of VPN features.

     *Microsoft has confirmed the possible problem:* After applying
     Service Pack 2, the RasSetEntryProperties flags for
     RASEO_TerminalAfterDial and RASEO_TerminalBeforeDial specified in the
     Win32 function call are not set. This problem occurs because Service
     Pack 2 causes the parameters to be ignored.  This problem has been
     corrected in Service Pack 3.








     http://support.microsoft.com/support/ntserver/serviceware/nts40/E9MSL2CSA.ASP

     *Microsoft:* When using the RasSetEntryProperties API call to change
     the connection information for an entry in the phone book or create a
     new phone-book entry, the szScript (`$props-'{Script}> in
     `Win32::RASE') parameter of the RASENTRY structure is not always
     preserved.

     http://support.microsoft.com/support/kb/articles/q160/1/90.asp

     This problem applies to WinNT 4.0 and was corrected in the latest
     Microsoft Windows NT 4.0 U.S. Service Pack (4).

     The function croaks if the specfied device is not found.

RasCreateEntry ( )
     This function creates RAS/DUN entry programmatically (note that
     `RasCreateEntryDlg()' displays dialo boxes).

          RasCreateEntry( $props );

     `Win32::RASE::PHONEBOOK' defines the phonebook in which the new entry
     will be created (WinNT).

     For the explanation of the `%$props' hash see the previous
     `RasSetEntryProperties()' function. The main difference is that these
     keys

          name, LocalPhoneNumber, NetProtocols, FramingProtocol, DeviceName

     are mandatory in this hash.

     You have to specify at least one of CountryID and CountryCode keys
     and AreaCode key if `$props-'{newFlags}> contains
     "+UseCountryAndAreaCodes".

     All ip-addresses if omitted are assumed to be "0.0.0.0". Empty or
     non-existing `$props-'{newFlags}> gives zero numeric flag which means
     that none of the `RASEO_*' options are in use. Flag "KeepOldFlags"
     has no meaning but makes no error.

     Note that the device settings would be copied from your system
     defaults and some minor features still could not be customized (see
     `RasGetEntryDevProperties()').

RasChangePhoneNumber ( )
     This is a simplified version of the `RasSetEntryProperties()'.

          RasChangePhoneNumber($entry, $new_phone_number);

          $entry             - name of RAS/DUN entry
          $new_phone_number  - fully qualified phone number of the remote
                               computer in almost any human-readable form.

     For example:

          '7-095-5555555' or '7(095)5555555' or '7 -( 095)-555-5555'
          or '+7 (095) - 5-5-5-5-5-5-5' or '7 095 5555555'

     It is smart enough to adjust entry flags to avoid long distance
     dialing if country and area codes are the same as in Dialing
     Properties/Default Location.  All other flags are kept unchanged.

     *Note!* country code here is not TAPI `countryID'.

   * =====================================*

   * CONNECTION RELATED FUNCTIONS*

   * =====================================*

RasEnumConnections ( )
          %connections = RasEnumConnections ( );  or as list

          ($entry1, $hrasconn1, ...) = RasEnumConnections ( );

     Returns handles for each active RAS/DUN connection. $entry is
     entry-name.  `$hrasconn' is a numeric handle that might be used in
     `RasHangUp()' to hang up the active connection or in
     `RasGetConnectStatus()' or in `RasGetProjectionInfo()'.

     Croaks on errors. Returns FALSE if no one active connection was found.

     Note that `RasDial()' also returns $hrasconn on success.

RasGetProjectionInfo ( )
     In the current version projection info is implemented for IP protocol
     only.  This is a subject to change.

          ($ip, $server_ip) = RasGetProjectionInfo ( $hrasconn );

          $hrasconn  - handle of the active connection returned by either
                       RasDial() or RasEnumConnections().
          $ip        - the client's IP address on the RAS connection
          $server_ip - the IP address of the remote PPP peer (that is, the
                       server's IP address)

     Both IP addrs are in "nnn.nnn.nnn.nnn" form.

     *From the API docs:*

     Remote access projection is the process whereby a remote access server
     and a remote client negotiate network protocol-specific information.
     A remote access server uses this network protocol-specific information
     to represent a remote client on the network.

     *Windows NT:* Remote access projection information is not available
     until the operating system has executed the RasDial `RASCS_Projected'
     state on the remote access connection. If `RasGetProjectionInfo()' is
     called prior to the `RASCS_Projected' state, it returns
     `ERROR_PROJECTION_NOT_COMPLETE'.

     *Windows 95:* Windows 95 Dial-Up Networking does not support the
     `RASCS_Projected' state. The projection phase may be done during the
     `RASCS_Authenticate' state. If the authentication is successful, the
     connection operation proceeds to the `RASCS_Authenticated' state, and
     projection information is available for successfully configured
     protocols. If `RasGetProjectionInfo()' is called prior to the
     `RASCS_Authenticated' state, it returns
     `ERROR_PROTOCOL_NOT_CONFIGURED'.

     PPP does not require that servers provide this address, but Windows NT
     servers will consistently return the address anyway. Other PPP vendors
     may not provide the address. If the address is not available, this
     member returns an empty string ("").

     I guess the last note is probably outdated because my Advanced Dialer
     has a field for "Server's IP address" - so, it expects that it's
     always available.

     If you are using `Win32::RASE' in a single process application you
     can't monitor `RASCS_*' states (for more info look at
     `RasGetConnectStatus()').  So, the rule is: use this function after
     `RasDial()' successfully returned `$hrasconn'.

     The typical usage if you have only one connection is:

          unless ( $hrasconn = (RasEnumConnections())[1] ) {
          	 print "Dialing sequence not started\n";

          } elsif ( ($ip, $server_ip) = RasGetProjectionInfo( $hrasconn ) ) {
          	 print "LOCAL:$ip  SERVER:$server_ip\n";

          } elsif ( Win32::RASE::GetLastError == 731 ) {
          	 print "Protocol not configured yet\n";

          } else {
          	 die Win32::RASE::FormatMessage();
          }

     Note also that LastError=6  means that `$hrasconn' is an invalid
     handle.

     Command line syntax:

          perl -MWin32::RASE -e "$,=', ';print RasGetProjectionInfo((RasEnumConnections)[1])"

RasHangUp ( )
          RasHangUp($hrasconn [, $timeout]);

          $hrasconn  - handle of the active connection returned by either
                       RasDial() or RasEnumConnections().

          $timeout   - in sec, optional (3 sec by default). Maximum time to wait
                       for graceful disconnection. You can use float values if
          	      Time::HiRes is installed. Otherwise cycle uses sleep(1)
                       and thus wastes some additional time.

     This function gracefully terminates the connection. You don't need to
     add any sleep after it.

     The connection is terminated even if the `RasDial()' call has not yet
     been completed.

     After this call, the $hrasconn handle can no longer be used.

     Returns FALSE if invalid handle was given but this is harmless most
     of the time. Probably the connection failed itself and `$hrasconn' is
     not valid any more. So, you don't have to trap this error.

     Returns FALSE on timeout also (connection might be still active).
     LastError is 0 in this case. So the exact logic is:

          if ( RasHangUp($hrasconn, $timeout) ) {
          	 print "Connection is terminated successfully.\n";

          } elsif ( !Win32::RASE::GetLastError ) {
          	 print "Timeout. Connection is still active.\n";

          } else {
          	 # we don't have to die here
          	 warn Win32::RASE::FormatMessage(), "\n";
          }

     For more take a look at the API docs.

HangUp ( )
     This is the easier version of previous.

     Without parameters it will terminate all active connections, otherwise
     terminates connections by *entry-names* given as parameters. Note that
     this function uses entry-names, not handles.

          $code = HangUp ( [$entry1, ...] );

     Returns FALSE if at least one connection was not terminated
     gracefully, otherwise TRUE even if no one active connecton was found.

     Command line syntax:

          perl -MWin32::RASE -e HangUp

RasGetConnectStatus ( )
     This function is used to monitor active connection in progress. In
     most cases it's good to cycle calls to this function after a very
     small interval, say 0.1 sec or less - at least at the dialing time.
     It's possible in multithreading process (thread safety is not
     verified in this version) or one process can monitor another, which
     is closer to perl practice.

          $status = RasGetConnectStatus($hrasconn);

     or

          ($status, $status_text) = RasGetConnectStatus($hrasconn);

          $hrasconn - handle to active RAS/DUN connection

     In scalar context returns numeric status (RASCS_* enumerator values)
     or FALSE if `$hrasconn' is not a valid handle (LastError is set to 6).

     In list context returns numeric status and the string that
     characterizes this status in short (the descriptive part of the
     corresponding RASCS_ constant's name, like "OpenPort") or FALSE if
     handle is invalid.

     FALSE is also returned if handle is "not valid any more", i.e.
     connection is terminated.

     These string constants ("PortOpened" etc.) are stored in a
     non-exported hash *%Win32::RASE::RASCS* where the keys are numeric
     values of the corresponding RASCS_* constants. So

          $Win32::RASE::RASCS{1} eq "PortOpened"

     You can check status yourself against exported RASCS_* constants:

          RASCS_OpenPort
          RASCS_PortOpened
          RASCS_ConnectDevice
          RASCS_DeviceConnected
          RASCS_AllDevicesConnected
          RASCS_Authenticate
          RASCS_AuthNotify
          RASCS_AuthRetry
          RASCS_AuthCallback
          RASCS_AuthChangePassword
          RASCS_AuthProject
          RASCS_AuthLinkSpeed
          RASCS_AuthAck
          RASCS_ReAuthenticate
          RASCS_Authenticated
          RASCS_PrepareForCallback
          RASCS_WaitForModemReset
          RASCS_WaitForCallback
          RASCS_Projected
          RASCS_StartAuthentication    // Windows 95 only
          RASCS_CallbackComplete       // Windows 95 only
          RASCS_LogonNetwork           // Windows 95 only
          RASCS_SubEntryConnected
          RASCS_SubEntryDisconnected
          RASCS_Interactive  =  RASCS_PAUSED
          RASCS_RetryAuthentication
          RASCS_CallbackSetByCaller
          RASCS_PasswordExpired
          RASCS_Connected  = RASCS_DONE
          RASCS_Disconnected

     *From the API docs:*

     The connection process states are divided into three classes: running
     states, paused states, and terminal states. An application can easily
     determine the class of a specific state by performing Boolean bit
     operations with the RASCS_PAUSED and RASCS_DONE bitmasks. Here are
     some examples:

          $fDoneState = $status & RASCS_DONE;
          $fPausedState = $status & RASCS_PAUSED;
          $fRunState = !($fDoneState || $fPausedState);

RasDialDlg ( )
     This function tries to establish a RAS connection using a specified
     phonebook entry and the credentials of the logged-on user.  It
     displays a stream of dialog boxes that indicate the state of the
     connection operation and returns when the connection is established,
     or when the user cancels the operation. *Windows NT only.*

          RasDialDlg( $EntryName [, $hwnd, $PhoneNumber] );

          $EntryName    - RAS/DUN entry, the only mandatory parameter
          $hwnd         - Identifies the window that owns the modal RasDialDlg
                          dialog boxes.
                          This member can be any valid window handle, or it can
                          be 0, undef (or omitted) if the dialog box has no owner

     The dialog box is centered on the owner window unless `$hwnd' is FALSE
     or invalid handle, in which case the dialog box is centered on the
     screen.

          $PhoneNumber  - an overriding phone number (if not needed - use "" or
                          undef).

     It does not inherit anything from phonebook if specified - no prefix,
     no callin card, no waiting.  You should even add DP before the number
     for pulse dialing.

     Returns TRUE on success, FALSE if user selects "Cancel" button or an
     error occurs.  You can check the last case with
     `Win32::RASE::GetLastError()'.

          if ( RasDialDlg("NEV4") ) {
          	 print "Connection established\n";
          } elsif ( !Win32::RASE::GetLastError ) {
          	 print "User selected <Cancel>\n";
          } else {
          	 warn Win32::RASE::FormatMessage(), "\n";
          }

RasDial ( )
     This function establishes a RAS/DUN connection. The connection data
     includes callback and user authentication information.

          $hrasconn = RasDial($EntryName, $PhoneNumber, $UserName, $Password,
                               $Domain, $CallbackNumber);

          $EntryName   - RAS/DUN entry, the only mandatory parameter
          $PhoneNumber - an overriding phone number (if not needed - use "" or
                         undef).
          
          It does not inherit anything from the phonebook if specified -
          no prefix, no calling card, no waiting.
          You should add DP before the number for pulse dialing.

          $UserName    - user's user name (look below)
          $Password    - user's password
          $Domain      - domain on which authentication is to occur. An empty
               string ("" or undef) specifies the domain in which the remote
               access server is a member (NT only). An asterisk specifies the
               domain stored in the phonebook for the entry.
               It's in addr form (size is limited to 15 chars).
          $CallbackNumber - a callback phone number. An empty string ("") or
               undef indicates that callback should not be used. This string is
               ignored unless the user has "Set By Caller" callback permission
               on the RAS server (NT only). An asterisk indicates that the number
               stored in the phonebook should be used for callback.

     *Windows NT:* [These 2 paragraphs are copied from the API docs. I
     wanted to add this for some completeness but I was told that probably
     this is not truth and if Username or Password are empty user will get
     a dialog box with Username/Password prompts.]

     RAS does not actually log the user onto the network. The user does
     this in the usual manner, for example, by logging on with cached
     credentials prior to making the connection or by using CTRL+ALT+DEL,
     after the RAS connection is established.

     If both the UserName and Password members are empty strings (""), RAS
     uses the user name and password of the current logon context for
     authentication. For a user mode application, RAS uses the credentials
     of the currently logged-on interactive user.  For a Win32 service
     process, RAS uses the credentials associated with the service.

     *Windows 95:*

     RAS uses the UserName and Password strings to log the user onto the
     network.  Windows 95 cannot get the password of the currently
     logged-on user, so if both the UserName and the Password members are
     empty strings ("" or undef), RAS leaves the user name and password
     empty during authentication. I.e. it provides no additional search
     (look at `RasGetEntryDialParams()' for that).

     Note: It seems that overriding phone number is being dialed "as is" -
     without using any long-distance/international phone settings. So you
     have to provide this number with all prefixes and waitings (W etc.)
     if needed. Additional dashes, blanks and brackets are OK.

          $hrasconn  - on success - handle to active RAS/DUN connection,
                       otherwise undef

     You can use `$hrasconn' in `RasGetConnectStatus()' or `RasHangUp()'.
     Note that this function calls `RasHangUp()' internally on error, so
     after that, the handle of the failed connection is not available and
     the port is ready for the next try.

     Example:

          ($err, $errtext) = RasDial("CLICK",undef,"ppblazer","qwerty");
          if ($err) {
             print "$err, $errtext\n"; exit;
          } else {
             ... your work here ...
          }

     *Last note:* this is the *synchronous* operation. Nobody knows if it
     could really hang fast enough if the line is busy (for ex.) The best
     way would be to run `RasDial()' in the separate process or thread. In
     most cases you don't really need `$hrasconn' in the main process -
     you can terminate the connection at any time with `HangUp()'.  Or you
     can easily get `$hrasconn' with the use of `RasEnumConnections()'.

     If you run `RasDial()' in a child-process and terminate dialing in
     progress (for ex.  on timeout) you have to free the port yourself
     (`RasHangUp()' or `HangUp()').

     For more info take a look at Win32 API docs (RASDIALPARAMS etc).

     Command line syntax:

          perl -MWin32::RASE -e RasDial(NEV1,undef,ppblazer,'6hTR7dwA')
          perl -MWin32::RASE -e "RasDial(NEV1,undef,ppblazer,'6hTR7dwA') or print Win32::RASE::FormatMessage"
          perl -MWin32::RASE -e "print RasDial(NEV1,undef,ppblazer,'6hTR7dwA')||Win32::RASE::FormatMessage"

   * =====================================*

   * TAPI RELATED FUNCTIONS*

   * =====================================*

RasEnumDevices ( )
          %devices = RasEnumDevices();

     This function returns the name and type of all available RAS-capable
     devices.  In the `%devices' hash device names are keys and types are
     values. Common device types are "modem", "x25", "vpn", "isdn",
     "rastapi" etc.

     Croaks on errors. Returns FALSE if no one RAS capable device was
     found.

     For example the first RAS-capable device name is

          $DeviceName = (RasEnumDevices())[0];

     This function fills out a non-exported hash
     `%Win32::RASE::RasDevEnumeration' of the same structure as
     `%devices', so in most cases there is no need to call this function
     more then once.

     Command line syntax:

          perl -MWin32::RASE -e "print ((RasEnumDevices)[0])"

RasEnumDevicesByType ( )
     The easier version of previous.

          @DevNames = RasEnumDevicesByType( $devtype );

     Returns names of RAS-capable devices of type `$devtype'. For example
     the first modem's name

          $ModemName = (RasEnumDevicesByType("modem"))[0];

     `$devtype' is case insensitive.

TAPIlineGetTranslateCaps ( )
     This function is not exported and is not intended for public use.  It
     is called each time you load Win32::RASE and fills out 3 global
     variables and global hash (below).

     It takes local information from your dialup settings.

          ($countryID, $countryCode, $areaCode) =
             Win32::RASE::TAPIlineGetTranslateCaps ();

     The return values are describing the *Current Location* that is
     selected in you dialing properties.

          $countryID  -  the unique number that TAPI assigns to each country.
                         It is not what you are typing on your phone, though it
                         sometimes has the same value. Different countries always
                         have different countryID. This allows multiple entries
                         to exist in the country list with the same country code
                         (for example, all countries in North America and the
                         Caribbean share country code 1, but require separate
                         entries in the list).

          $countryCode - this really is the code that would be dialed in an
          	        international call to your computer's location.

          $areaCode    - city or area code (local).

     These 3 values are copied to non-exported global variables
     *$Win32::RASE::LOCAL_ID*, *$Win32::RASE::LOCAL_CODE* and
     *$Win32::RASE::LOCAL_AREA*.

     They are mainly for internal use, just note that they are here.

     The complete TAPI countries list is being copied to non-exported
     global hash *%Win32::RASE::TAPIEnumeration*. Keys are countryID's,
     each value points to 3-element array: [0] is country-name, [1] is
     countryCode described above, [2] is NextCountryID in TAPI-enumeration
     (TAPI docs, but in most cases you don't need to use this hash
     explicitly).

     Use `TAPIEnumerationPrint()' to print this hash (for fun ;)

TAPIEnumLocations ( )
     Just a handy function (non-exported) to enumerate locations in your
     Dialing Properties.  It's being executed internally when Win32::RASE
     needs it, so in most cases you don't need to use it explicitly.

          ($CurrentLocation, %locations) = Win32::RASE::TAPIEnumLocations;

          $CurrentLocation   - current dialing location's name
          %locations         - keys are location-names, values are anonymous
                               arrays that are filled out like:
             [$CountryID, $CountryCode, $CityCode, $Options, $LocalAccessCode,
              $LongDistanceAccessCode, $TollPrefixList, $PermanentLocationID]

          $Options                - 0/1 tone/pulse dialing, this value could be
                                    used to define good timeout for RasDial()
          $LocalAccessCode        - the access code to be dialed before calls to
                                    addresses in the local calling area
          $LongDistanceAccessCode - the access code to be dialed before calls to
                                    addresses outside the local calling area
          $TollPrefixList         - the toll prefix list for the location. The
                                    string will contain only prefixes consisting
                                    of the digits "0" through "9", separated
                                    from each other by a single comma
          $PermanentLocationID    - internal unique identifier of the location

     Other values in array are described in `TAPIlineGetTranslateCaps()'.

     Example:

          ($CurrentLocation, %locations) = Win32::RASE::TAPIEnumLocations;
          print "$CurrentLocation\n";
          print map "$_ => [".(join", ",@{$locations{$_}})."]\n",
              keys %locations;

TAPISetCurrentLocation ( )
          TAPISetCurrentLocation( $location );

          $location   - optional, the name of the location that is configured
                        in the Dialing Properies.
                        If omitted the "Default Location" is used.

     Returns TRUE on success, FALSE if `$location' was not found in the
     Dialing Properties, croaks on TAPI errors.

TAPIEnumerationPrint ( )
     This function prints nicely formatted TAPI countries table that is
     stored in the *%Win32::RASE::TAPIEnumeration* (see above). Not
     exported by default;

          Win32::RASE::TAPIEnumerationPrint();

     Columns: CountryID, CountryName, CountryCode, NextCountryID

     For more: `TAPIlineGetTranslateCaps()' and TAPI docs.

     Always returns TRUE.

TAPICountryName ( )
     Returns CountryName by CountryID or FALSE if given CountryID does not
     exist in TAPI-table.

          $CountryName = TAPICountryName($CountryID);

     Command line syntax:

          perl -MWin32::RASE -e "print TAPICountryName(1)"

TAPICountryCode ( )
     Returns CountryCode by CountryID or FALSE if given CountryID does not
     exist in TAPI-table.

          $CountryCode = TAPICountryCode($CountryID);

IsCountryID ( )
     Returns TRUE if given $CountryID exist in TAPI-table, otherwise FALSE.

          IsCountryID($CountryID);

     Just to have such a pretty name ;)

TAPIlineInitialize ( )
     This is a non-exported function mainly for internal use. It could be
     handy only if you'd start writing your own TAPI-related functions.

          ($hLineApp, $dwNumDevs) = Win32::RASE::TAPIlineInitialize();

     or in scalar context

          $hLineApp = Win32::RASE::TAPIlineInitialize();

          $hLineApp  - the application's usage non-zero handle for TAPI
          $dwNumDevs - number of line devices available to the TAPI application

     Croaks on TAPI errors.

     The applicaton should always call `TAPIlineShutdown()' to release
     memory resources allocated by TAPI.DLL.

TAPIlineShutdown ( )
     This is a non-exported function mainly for internal use. It could be
     handy only if you'd start writing your own TAPI-related functions.

          Win32::RASE::TAPIlineShutdown($hLineApp);

          $hLineApp  - the application's usage handle for TAPI

     Returns zero if the request is successful or a negative error number
     if an error has occurred.

INSTALLATION
============

   As this is just a plain module no special installation is needed. Put it
into the Win32 subdirectory somewhere in your @INC.

   This module needs Windows Remote Access Service (RAS) or DialUp
Networking (DUN) to be properly installed including dialing properties.

   rasapi32.dll, tapi32.dll

   Win32::API module by Aldo Calpini.

   enum.pm (1.014 or later, no compilations) by Byron Brummer (aka Zenin)

   Time::HiRes (0.18 or later) by Douglas E. Wegscheid makes work more
precise.

CAVEATS
=======

   This module has been created and tested in a Win95 environment.
Although I expect it to function correctly on any version of Windows NT,
that fact has been confirmed for NT 4.0 build 1381 only.

   Some of the RAS APIs were not included in the RasAPI32.dll that was
shipped with the old releases of Windows 95. To use the RAS APIs mentioned
here, you need to install the at least Dial Up Networking (DUN) 1.2b
upgrade.  This upgrade is available for download on:


http://www.microsoft.com/windows/downloads/contents/Updates/W95DialUpNetw/default.asp

   This upgrade was incorporated in Win95 OSR.

   From the *MS KB# Q157765*: Early releases of Windows 95 may require an
additional RNAPH.DLL that contains some of new phonebook manipulation
APIs. There currently is no workaround for this situation in this version
of the module.

   Some APIs may also not work properly on WinNT with old Service Packs.
Make sure that you are using the last Service Pack available.  List of
Bugs Fixed in Windows NT 4.0 Service Pack 1, 2, and 3 is available at

   http://support.microsoft.com/support/kb/articles/q224/7/92.asp

   What can we do here, guys? That's how it goes...

CHANGES
=======

     1.00  First public release
     1.01  The only thing touched is Makefile.PL. The distribution is packed
           now using UNIX conventions (LF only, unlike the 1.00 dist)

TODO
====

   NT-only API: RasGetCredentials, RasSetCredentials, RasMonitorDlg,
RasPhonebookDlg.

   Any suggestions are much appreciated.

BUGS
====

   Please report.

VERSION
=======

   This man page documents "Win32::RASE" version 1.01.

   January 19, 2000.

CREDITS
=======

   Thanks to Carl Sewell <csewell@hiwaay.net> for his great help and
patience in testing on NT. If these docs are more or less readable - it's
due to his corrections and improvement.

   Thanks to Jan Dubois <jan.dubois@ibm.net> for numerous great tips and
explanations.

   Guys, you are cool! ;)

AUTHOR
======

   Mike Blazer, blazer@mail.nevalink.ru

   http://www.dux.ru/guest/fno/perl/

SEE ALSO
========

   Win32 SDK, TAPI docs.

COPYRIGHT
=========

   Copyright (C) 1999 Mike Blazer.

   This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


