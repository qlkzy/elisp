This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Ace/Sequence/Feature,  Next: Ace/Sequence/FeatureList,  Prev: Ace/Sequence,  Up: Module List

Examine Sequence Feature Tables
*******************************

NAME
====

   Ace::Sequence::Feature - Examine Sequence Feature Tables

SYNOPSIS
========

     # open database connection and get an Ace::Object sequence
     use Ace::Sequence;

     # get a megabase from the middle of chromosome I
     $seq = Ace::Sequence->new(-name   => 'CHROMOSOME_I,
                               -db     => $db,
     			      -offset => 3_000_000,
     			      -length => 1_000_000);

     # get all the homologies (a list of Ace::Sequence::Feature objs)
     @homol = $seq->features('Similarity');

     # Get information about the first one
     $feature = $homol[0];
     $type    = $feature->type;
     $subtype = $feature->subtype;
     $start   = $feature->start;
     $end     = $feature->end;
     $score   = $feature->score;

     # Follow the target
     $target  = $feature->info;

     # print the target's start and end positions
     print $target->start,'-',$target->end, "\n";

DESCRIPTION
===========

   *Ace::Sequence::Feature* is a subclass of *Note Ace/Sequence/Feature:
Ace/Sequence/Feature, specialized for returning information about
particular features in a GFF format feature table.

OBJECT CREATION
===============

   You will not ordinarily create an *Ace::Sequence::Feature* object
directly.  Instead, objects will be created in response to a feature()
call to an *Ace::Sequence* object.  If you wish to create an
*Ace::Sequence::Feature* object directly, please consult the source code
for the new() method.

OBJECT METHODS
==============

   Most methods are inherited from *Ace::Sequence*.  The following methods
are also supported:

seqname()
          $object = $feature->seqname;

     Return the ACeDB Sequence object that this feature is attached to.
     The return value is an *Ace::Object* of the Sequence class.  This
     corresponds to the first field of the GFF format and does not
     necessarily correspond to the *Ace::Sequence* object from which the
     feature was obtained (use source_seq() for that).

source()
method()
subtype()
          $source = $feature->source;

     These three methods are all synonyms for the same thing.  They return
     the second field of the GFF format, called "source" in the
     documentation.  This is usually the method or algorithm used to
     predict the feature, such as "GeneFinder" or "tRNA" scan.  To avoid
     ambiguity and enhance readability, the method() and subtype() synonyms
     are also recognized.

feature()
type()
          $type = $feature->type;

     These two methods are also synonyms.  They return the type of the
     feature, such as "exon", "similarity" or "Predicted_gene".  In the GFF
     documentation this is called the "feature" field.  For readability,
     you can also use type() to fetch the field.

abs_start()
          $start = $feature->abs_start;

     This method returns the absolute start of the feature within the
     sequence segment indicated by seqname().  As in the *Ace::Sequence*
     method, use start() to obtain the start of the feature relative to its
     source.

abs_start()
          $start = $feature->abs_start;

     This method returns the start of the feature relative to the sequence
     segment indicated by seqname().  As in the *Ace::Sequence* method,
     you will more usually use the inherited start() method to obtain the
     start of the feature relative to its source sequence (the
     *Ace::Sequence* from which it was originally derived).

abs_end()
          $start = $feature->abs_end;

     This method returns the end of the feature relative to the sequence
     segment indicated by seqname().  As in the *Ace::Sequence* method,
     you will more usually use the inherited end() method to obtain the end
     of the feature relative to the *Ace::Sequence* from which it was
     derived.

score()
          $score = $feature->score;

     For features that are associated with a numeric score, such as
     similarities, this returns that value.  For other features, this
     method returns undef.

strand()
          $strand = $feature->strand;

     Returns the strandedness of this feature, either "+1" or "-1".  For
     features that are not stranded, returns 0.

reversed()
          $reversed = $feature->reversed;

     Returns true if the feature is reversed relative to its source
     sequence.

frame()
          $frame = $feature->frame;

     For features that have a frame, such as a predicted coding sequence,
     returns the frame, either 0, 1 or 2.  For other features, returns
     undef.

group()
info()
target()
          $info = $feature->info;

     These methods (synonyms for one another) return an Ace::Object
     containing other information about the feature derived from the 8th
     field of the GFF format, the so-called "group" field.  The type of the
     Ace::Object is dependent on the nature of the feature.  The
     possibilities are shown in the table below:

          Feature Type           Value of Group Field
          ------------            --------------------
          
          note                   A Text object containing the note.
          
          similarity             An Ace::Sequence::Homology object containing
                                 the target and its start/stop positions.

          intron                 An Ace::Object containing the gene from
          exon                   which the feature is derived.
          misc_feature

          other                  A Text object containing the group data.

asString()
          $label = $feature->asString;

     Returns a human-readable identifier describing the nature of the
     feature.  The format is:

          $type:$name/$start-$end

     for example:

          exon:ZK154.3/1-67

     This method is also called automatically when the object is treated in
     a string context.

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Object: Ace/Object,, *Note Ace/Sequence:
Ace/Sequence,,*Note Ace/Sequence/Homol: Ace/Sequence/Homol,, *Note
Ace/Sequence/FeatureList: Ace/Sequence/FeatureList,, `GFF' in this node

AUTHOR
======

   Lincoln Stein <lstein@cshl.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1999, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Ace/Sequence/FeatureList,  Next: Ace/Sequence/GappedAlignment,  Prev: Ace/Sequence/Feature,  Up: Module List

Lightweight Access to Features
******************************

NAME
====

   Ace::Sequence::FeatureList - Lightweight Access to Features

SYNOPSIS
========

     # get a megabase from the middle of chromosome I
     $seq = Ace::Sequence->new(-name   => 'CHROMOSOME_I,
                               -db     => $db,
     			      -offset => 3_000_000,
     			      -length => 1_000_000);

     # find out what's there
     $list = $seq->feature_list;

     # Scalar context: count all the features
     $feature_count = $list->types;

     # Array context: list all the feature types
     @feature_types = $list->types;

     # Scalar context, 1 argument.  Count this type
     $gene_cnt = $list->types('Predicted_gene');
     print "There are $gene_cnt genes here.\n";

     # Array context, 1 argument.  Get list of subtypes
     @subtypes = $list->types('Predicted_gene');

     # Two arguments. Count type & subtype
     $genefinder_cnt = $list->types('Predicted_gene','genefinder');

DESCRIPTION
===========

   *Ace::Sequence::FeatureList* is a small class that provides statistical
information about sequence features.  From it you can obtain summary
counts of the features and their types within a selected region.

OBJECT CREATION
===============

   You will not ordinarily create an *Ace::Sequence::FeatureList* object
directly.  Instead, objects will be created by calling a *Ace::Sequence*
object's feature_list() method.  If you wish to create an
*Ace::Sequence::FeatureList* object directly, please consult the source
code for the new() method.

OBJECT METHODS
==============

   There are only two methods in *Ace::Sequence::FeatureList*.

type()
     This method has five distinct behaviors, depending on its context and
     the number of parameters.  Usage should be intuitive

          Context       Arguments       Behavior
          -------       ---------       --------

          scalar         -none-         total count of features in list
          array          -none-         list feature types (e.g. "exon")
          scalar          type          count features of this type
          array           type          list subtypes of this type
          -any-       type,subtype      count features of this type & subtype

     For example, this code fragment will count the number of exons present
     on the list:

          $exon_count = $list->type('exon');

     This code fragment will count the number of exons found by
     "genefinder":

          $predicted_exon_count = $list->type('exon','genefinder');

     This code fragment will print out all subtypes of "exon" and their
     counts:

          for my $subtype ($list->type('exon')) {
              print $subtype,"\t",$list->type('exon',$subtype),"\n";
          }

asString()
          print $list->asString;

     This dumps the list out in tab-delimited format.  The order of columns
     is type, subtype, count.

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Object: Ace/Object,, *Note Ace/Sequence:
Ace/Sequence,, *Note Ace/Sequence/Feature: Ace/Sequence/Feature,, `GFF' in
this node

AUTHOR
======

   Lincoln Stein <lstein@w3.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1999, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Ace/Sequence/GappedAlignment,  Next: Ace/Sequence/Homol,  Prev: Ace/Sequence/FeatureList,  Up: Module List

Gapped alignment object
***********************

NAME
====

   Ace::Sequence::GappedAlignment - Gapped alignment object

SYNOPSIS
========

     # open database connection and get an Ace::Sequence object
     use Ace::Sequence;

     # get a megabase from the middle of chromosome I
     $seq = Ace::Sequence->new(-name   => 'CHROMOSOME_I,
                               -db     => $db,
     			      -offset => 3_000_000,
     			      -length => 1_000_000);

     # get all the gapped alignments
     @alignments = $seq->alignments('EST_GENOME');

     # get the aligned segments from the first one
     @segs = $alignments[0]->segments;

     # get the position of the first aligned segment on the
     # source sequence:
     ($s_start,$s_end) = ($segs[0]->start,$segs[0]->end);

     # get the target position for the first aligned segment
     ($t_start,$t_end) = ($segs[0]->target->start,$segs[0]->target->end);

DESCRIPTION
===========

   Ace::Sequence::GappedAlignment is a subclass of Ace::Sequence::Feature.
It inherits all the methods of Ace::Sequence::Feature, but adds the
ability to retrieve the positions of the aligned segments.  Each segment
is an Ace::Sequence::Feature, from which you can retrieve the source and
target coordinates.

OBJECT CREATION
===============

   You will not ordinarily create an *Ace::Sequence::GappedAlignment*
object directly.  Instead, objects will be created in response to a
alignments() call to an *Ace::Sequence* object.

OBJECT METHODS
==============

   Most methods are inherited from *Ace::Sequence::Feature*.  The
following methods are also supported:

segments()
          @segments = $gene->segments;

     Return a list of Ace::Sequence::Feature objects corresponding to
     similar segments.

relative()
          $relative = $gene->relative;
          $gene->relative(1);

     This turns on and off relative coordinates.  By default, the exons and
     intron features will be returned in the coordinate system used by the
     gene.  If relative() is set to a true value, then coordinates will be
     expressed as relative to the start of the gene.  The first exon will
     (usually) be 1.

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Object: Ace/Object,, *Note Ace/Sequence:
Ace/Sequence,,*Note Ace/Sequence/Homol: Ace/Sequence/Homol,, *Note
Ace/Sequence/Feature: Ace/Sequence/Feature,, *Note
Ace/Sequence/FeatureList: Ace/Sequence/FeatureList,, `GFF' in this node

AUTHOR
======

   Lincoln Stein <lstein@cshl.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1999, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Ace/Sequence/Homol,  Next: Ace/Sequence/Multi,  Prev: Ace/Sequence/GappedAlignment,  Up: Module List

Temporary Sequence Homology Class
*********************************

NAME
====

   Ace::Sequence::Homol - Temporary Sequence Homology Class

SYNOPSIS
========

     # Get all similarity features from an Ace::Sequence
     @homol = $seq->features('Similarity');

     # sort by score
     @sorted = sort { $a->score <=> $b->score } @homol;

     # the last one has the highest score
     $best = $sorted[$#sorted];

     # fetch its associated Ace::Sequence::Homol
     $homol = $best->target;

     # print out the sequence name, DNA, start and end
     print $homol->name,' ',$homol->start,'-',$homol->end,"\n";
     print $homol->asDNA;

DESCRIPTION
===========

   *Ace::Sequence::Homol* is a subclass of *Note Ace/Object: Ace/Object,
(not *Note Ace/Sequence: Ace/Sequence,) which is specialized for returning
information about a DNA or protein homology.  This is a temporary
placeholder for a more sophisticated homology class which will include
support for alignments.

OBJECT CREATION
===============

   You will not ordinarily create an *Ace::Sequence::Homol* object
directly.  Instead, objects will be created in response to an info() or
group() method call on a similarity feature in an *Ace::Sequence::Feature*
object.  If you wish to create an *Ace::Sequence::Homol* object directly,
please consult the source code for the new() method.

OBJECT METHODS
==============

   Most methods are inherited from *Ace::Object*.  The following methods
are also supported:

start()
          $start = $homol->start;

     Returns the start of the area that is similar to the
     *Ace::Sequence::Feature* from which his homology was derived.
     Coordinates are relative to the target homology.

end()
          $end = $homol->end;

     Returns the end of the area that is similar to the
     *Ace::Sequence::Feature* from which his homology was derived.
     Coordinates are relative to the target homology.

asString()
          $label = $homol->asString;

     Returns a human-readable identifier describing the nature of the
     feature.  The format is:

          $name/$start-$end

     for example:

          HUMGEN13/1-67

     This method is also called automatically when the object is treated in
     a string context.

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Object: Ace/Object,, *Note Ace/Sequence:
Ace/Sequence,,*Note Ace/Sequence/FeatureList: Ace/Sequence/FeatureList,,
*Note Ace/Sequence/Feature: Ace/Sequence/Feature,, `GFF' in this node

AUTHOR
======

   Lincoln Stein <lstein@w3.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1999, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Ace/Sequence/Multi,  Next: Ace/Sequence/Transcript,  Prev: Ace/Sequence/Homol,  Up: Module List

Combine Feature Tables from Multiple Databases
**********************************************

NAME
====

   Ace::Sequence::Multi - Combine Feature Tables from Multiple Databases

SYNOPSIS
========

     use Ace::Sequence::Multi;

     # open reference database
     $ref = Ace->connect(-host=>'stein.cshl.org',-port=>200009);

     # open some secondary databases
     $db1 = Ace->connect(-host=>'stein.cshl.org',-port=>200010);
     $db2 = Ace->connect(-path=>'/usr/local/acedb/mydata');

     # Make an Ace::Sequence::Multi object
     $seq = Ace::Sequence::Multi->new(-name   => 'CHROMOSOME_I,
                                      -db     => $ref,
     			             -offset => 3_000_000,
     			             -length => 1_000_000);

     # add the secondary databases
     $seq->add_secondary($db1,$db2);

     # get all the homologies (a list of Ace::Sequence::Feature objs)
     @homol = $seq->features('Similarity');

     # Get information about the first one -- goes to the correct db
     $feature = $homol[0];
     $type    = $feature->type;
     $subtype = $feature->subtype;
     $start   = $feature->start;
     $end     = $feature->end;
     $score   = $feature->score;

     # Follow the target
     $target  = $feature->info;

     # print the target's start and end positions
     print $target->start,'-',$target->end, "\n";

DESCRIPTION
===========

   *Ace::Sequence::Multi* transparently combines information stored about
a sequence in a reference database with features tables from any number of
annotation databases.  The resulting object can be used just like an
Ace::Sequence object, except that the features remember their database of
origin and go back to that database for information.

   This class will only work properly if the reference database and all
annotation databases share the same cosmid map.

OBJECT CREATION
===============

   You will use the new() method to create new Ace::Sequence::Multi
objects.  The arguments are identical to the those in the Ace::Sequence
parent class, with the addition of an option *-secondary* argument, which
points to one or more secondary databases from which to fetch annotation
information.

-source
     The sequence source.  This must be an *Ace::Object* of the "Sequence"
     class, or be a sequence-like object containing the SMap tag (see
     below).

-offset
     An offset from the beginning of the source sequence.  The retrieved
     *Ace::Sequence* will begin at this position.  The offset can be any
     positive or negative integer.  Offets are *0-based*.

-length
     The length of the sequence to return.  Either a positive or negative
     integer can be specified.  If a negative length is given, the returned
     sequence will be complemented relative to the source sequence.

-refseq
     The sequence to use to establish the coordinate system for the
     returned sequence.  Normally the source sequence is used to establish
     the coordinate system, but this can be used to override that choice.
     You can provide either an *Ace::Object* or just a sequence name for
     this argument.  The source and reference sequences must share a common
     ancestor, but do not have to be directly related.  An attempt to use a
     disjunct reference sequence, such as one on a different chromosome,
     will fail.

-name
     As an alternative to using an *Ace::Object* with the *-source*
     argument, you may specify a source sequence using *-name* and *-db*.
     The *Ace::Sequence* module will use the provided database accessor to
     fetch a Sequence object with the specified name. new() will return
     undef is no Sequence by this name is known.

-db
     This argument is required if the source sequence is specified by name
     rather than by object reference.  It must be a previously opened
     handle to the reference database.

-secondary
     This argument points to one or more previously-opened annotation
     databases.  You may use a scalar if there is only one annotation
     database.  Otherwise, use an array reference.  You may add and delete
     annotation databases after the object is created by using the
     add_secondary() and delete_secondary() methods.

   If new() is successful, it will create an *Ace::Sequence::Multi* object
and return it.  Otherwise it will return undef and return a descriptive
message in Ace->error().  Certain programming errors, such as a failure to
provide required arguments, cause a fatal error.

OBJECT METHODS
==============

   Most methods are inherited from *Ace::Sequence*.  The following
additional methods are supported:

secondary()
          @databases = $seq->secondary;

     Return a list of the secondary databases currently in use, or an empty
     list if none.

add_secondary()
          $seq->add_secondary($db1,$db2,...)

     Add one or more secondary databases to the list of annotation
     databases.  Duplicate databases will be silently ignored.

delete_secondary()
          $seq->delete_secondary($db1,$db2,...)

     Delete one or more secondary databases from the list of annotation
     databases.  Databases not already in use will be silently ignored.

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Object: Ace/Object,, *Note Ace/Sequence:
Ace/Sequence,,*Note Ace/Sequence/Homol: Ace/Sequence/Homol,, *Note
Ace/Sequence/FeatureList: Ace/Sequence/FeatureList,, *Note
Ace/Sequence/Feature: Ace/Sequence/Feature,, `GFF' in this node

AUTHOR
======

   Lincoln Stein <lstein@w3.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1999, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Ace/Sequence/Transcript,  Next: AddressBook,  Prev: Ace/Sequence/Multi,  Up: Module List

Simple "Gene" Object
********************

NAME
====

   Ace::Sequence::Transcript - Simple "Gene" Object

SYNOPSIS
========

     # open database connection and get an Ace::Object sequence
     use Ace::Sequence;

     # get a megabase from the middle of chromosome I
     $seq = Ace::Sequence->new(-name   => 'CHROMOSOME_I,
                               -db     => $db,
     			      -offset => 3_000_000,
     			      -length => 1_000_000);

     # get all the transcripts
     @genes = $seq->transcripts;

     # get the exons from the first one
     @exons = $genes[0]->exons;

     # get the introns
     @introns = $genes[0]->introns

     # get the CDSs (NOT IMPLEMENTED YET!)
     @cds = $genes[0]->cds;

DESCRIPTION
===========

   Ace::Sequence::Gene is a subclass of Ace::Sequence::Feature.  It
inherits all the methods of Ace::Sequence::Feature, but adds the ability
to retrieve the annotated introns and exons of the gene.

OBJECT CREATION
===============

   You will not ordinarily create an *Ace::Sequence::Gene* object
directly.  Instead, objects will be created in response to a transcripts()
call to an *Ace::Sequence* object.

OBJECT METHODS
==============

   Most methods are inherited from *Ace::Sequence::Feature*.  The
following methods are also supported:

exons()
          @exons = $gene->exons;

     Return a list of Ace::Sequence::Feature objects corresponding to
     annotated exons.

introns()
          @introns = $gene->introns;

     Return a list of Ace::Sequence::Feature objects corresponding to
     annotated introns.

cds()
          @cds = $gene->cds;

     Return a list of Ace::Sequence::Feature objects corresponding to
     coding sequence.  THIS IS NOT YET IMPLEMENTED.

relative()
          $relative = $gene->relative;
          $gene->relative(1);

     This turns on and off relative coordinates.  By default, the exons and
     intron features will be returned in the coordinate system used by the
     gene.  If relative() is set to a true value, then coordinates will be
     expressed as relative to the start of the gene.  The first exon will
     (usually) be 1.

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Object: Ace/Object,, *Note Ace/Sequence:
Ace/Sequence,,*Note Ace/Sequence/Homol: Ace/Sequence/Homol,, *Note
Ace/Sequence/Feature: Ace/Sequence/Feature,, *Note
Ace/Sequence/FeatureList: Ace/Sequence/FeatureList,, `GFF' in this node

AUTHOR
======

   Lincoln Stein <lstein@cshl.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1999, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: AddressBook,  Next: AddressBook/Config,  Prev: Ace/Sequence/Transcript,  Up: Module List

Abstract class for using AddressBooks
*************************************

NAME
====

   AddressBook - Abstract class for using AddressBooks

SYNOPSIS
========

     use AddressBook;
     $a = AddressBook->new(source => "LDAP:localhost");
     $b = AddressBook->new(source => "DBI:CSV:f_dir=/tmp/data");
     $c = AddressBook->new(source => "PDB");

     $a->search(name => "hersh");
     $entry = $a->read;
     $b->add($entry);

     $entry = AddressBook::Entry->new(attr=>{name => "dleigh"});
     $c->write($entry);

     AddressBook::sync(master=>$a,slave=>$c);

DESCRIPTION
===========

   AddressBook provides a unified interface to access various databases
for keeping track of contacts.  Included with this module are several
backends:

     AddressBook::DB::LDAP
     AddressBook::DB::LDIF
     AddressBook::DB::DBI
     AddressBook::DB::PDB
     AddressBook::DB::Text
     AddressBook::DB::HTML

   More will be added in the future.

new 	    Create a new AddressBook object.
-----------------------------------------

     AddressBook->new(source=$source,\%args)

   See the appropriate backend documentation for constructor details.

sync
----

     AddressBook::sync(master=>$master_db, slave=>$slave_db)
     AddressBook::sync(master=>$master_db, slave=>$slave_db,debug=>1)

   Synchronizes the "master" and "slave" databases.  The "master" database
type must be one that supports random-access methods.  The "slave"
database type must be one that supports sequential-access methods.

   When the 'debug' option is true, debug messages will be printed to
stdout.  The msg_function paramater, if included, should be a subroutine
reference which will be called with a status message is the argument.

  1. For each record in the slave, look for a corresponding record in the
     master, using the key_fields of each.


          If no match is found, the entry is added to the master.


          If multiple matches are found, an error occurrs.


          If one match is found, then:


               If the records match, nothing is done.


               If the records do not match, then:


                    If the slave record's timestamp is newer, the master's
                    entry is merged (see below) with the slave entry's
                    data.


                    If the master record's timestamp is newer, nothing is
                    done.

  2. The slave database is truncated.

  3. Each record of the master is added to the slave

        The 'merging' of the master and slave entries involves taking each
attribute in the slave's entry and replacing the corresponding attribute
in the master's entry.  Note that attributes that are deleted only on the
slave are therefore effectively ignored during synchronization.

   Similarly, deletions made on the slave database are effectively ignored
during synchronization.

search
------

     $abook->search(attr=>\%filter);
     while ($entry=$abook->read) {
       print $entry->dump;
     }

   \%filter is a list of cannonical attribute/value pairs.

read
----

     $entry=$abook->read;

   Returns an AddressBook::Entry object

update
------

     $abook->update(filter=>\%filter,entry=>$entry)

   \%filter is a list of cannonical attriute/value pairs used to identify
the entry to be updated.

   $entry is an AddressBook::Entry object

add
---

     $abook->add($entry)

   $entry is an AddressBook::Entry object

delete
------

     $abook->delete($entry)

   $entry is an AddressBook::Entry object

truncate
--------

     $abook->truncate

   Removes all records from the database.

get_attribute_names
-------------------

     @names = $abook->get_attribute_names;

   Returns a list of valid backend-specific attribute names

get_cannonical_attribute_names
------------------------------

     @names = $abook->get_cannonical_attribute_names;

   Returns a list of valid cannonical attribute names

AUTHOR
======

   Mark A. Hershberger, <mah@everybody.org> David L. Leigh,
<dleigh@sameasiteverwas.net>

SEE ALSO
========

     The perl-abook home page at http://perl-abook.sourceforge.net

   *Note AddressBook/Config: AddressBook/Config, *Note AddressBook/Entry:
AddressBook/Entry,

   *Note AddressBook/DB/LDAP: AddressBook/DB/LDAP, *Note
AddressBook/DB/LDIF: AddressBook/DB/LDIF, *Note AddressBook/DB/DBI:
AddressBook/DB/DBI, *Note AddressBook/DB/PDB: AddressBook/DB/PDB, *Note
AddressBook/DB/Text: AddressBook/DB/Text, *Note AddressBook/DB/HTML:
AddressBook/DB/HTML,


File: pm.info,  Node: AddressBook/Config,  Next: AddressBook/DB/BBDB,  Prev: AddressBook,  Up: Module List

AddressBook configuration object
********************************

NAME
====

   AddressBook::Config - AddressBook configuration object

SYNOPSIS
========

   The AddressBook::Config object contains the list of cannonical
attribute names, their respective backend database equivalents, attribute
metadata, and backend database attributes.

     $config = AddressBook::Config->new(config_file=>$filename);

   AddressBook::Config looks for a configuration file in
/etc/AddressBook.conf if no config_file parameter is present.

DESCRIPTION
===========

   Configuration is read from an XML configuration file which follows this
DTD:

     <?xml version="1.0"?>
     <!DOCTYPE AddressBook_config [
       <!ELEMENT fields (field)>
       <!ELEMENT field  (db)>
       <!ELEMENT db (EMPTY)>
       <!ELEMENT databases (LDAP,LDIF,DBI,PDB,Text,HTML)>
       <!ELEMENT LDAP (EMPTY)>
       <!ELEMENT LDIF (EMPTY)>
       <!ELEMENT DBI (EMPTY)>
       <!ELEMENT PDB (EMPTY)>
       <!ELEMENT Text (EMPTY)>
       <!ELEMENT HTML (EMPTY)>

     <!ATTLIST field 	name 		CDATA 	#REQUIRED
                   	order 		CDATA 	#IMPLIED
                   	type 		(text|textblock|phone|email|url|lurl|boolean) #IMPLIED
                   	values 		CDATA 	#IMPLIED
                   	non_multiple 	CDATA 	#IMPLIED
                   	read_only 	CDATA 	#IMPLIED
                   	calculate 	CDATA 	#IMPLIED
                   	calc_order 	CDATA 	#IMPLIED>

     <!ATTLIST db 	name 		CDATA 	#REQUIRED
                 	type 		CDATA 	#REQUIRED
                 	order 		CDATA 	#IMPLIED
                 	calculate 	CDATA 	#IMPLIED
                 	calc_order 	CDATA 	#IMPLIED>

     <!ATTLIST LDAP      key_fields 	CDATA 	#IMPLIED
     			hostname        CDATA   #IMPLIED
                      	objectclass 	CDATA 	#IMPLIED
                      	base 		CDATA 	#IMPLIED
                      	dn_calculate 	CDATA 	#IMPLIED
                      	username 	CDATA 	#IMPLIED
                      	password 	CDATA 	#IMPLIED>

     <!ATTLIST LDIF      key_fields 	CDATA 	#IMPLIED
     			filename        CDATA   #IMPLIED
                      	objectclass 	CDATA 	#IMPLIED
                      	base 		CDATA 	#IMPLIED
                      	dn_calculate 	CDATA 	#IMPLIED>

     <!ATTLIST DBI       key_fields 	CDATA 	#IMPLIED
                      	table 		CDATA 	#IMPLIED
     			dsn             CDATA   #IMPLIED>

     <!ATTLIST PDB       write_format 	CDATA 	#IMPLIED
     			intra_attr_sep  CDATA   #IMPLIED
                      	form_format 	CDATA 	#IMPLIED>

     <!ATTLIST HTML      key_fields 	CDATA 	#IMPLIED
     			filename        CDATA   #IMPLIED
                      	phone_display 	CDATA 	#IMPLIED>
       ]>

   For example,

     <AddressBook_config>
       <fields>
         <field name="firstname" type="text" order="1">
           <db type="LDAP" name="givenname" />
           <db type="HTML" name="First Name" order="2" />
         </field>
         <field name="lastname" type="text" order="2">
           <db type="LDAP" name="sn" />
           <db type="HTML" name="Last Name" order="1" />
         </field>
         <field name="fullname" type="text" order="3"
                calculate="$firstname . ' ' . $lastname">
           <db type="LDAP" name="cn" />
           <db type="HTML" name="Full Name" />
         </field>
       </fields>
       <databases>
         <LDAP objectclass="inetOrgPerson"
               base="o=abook"
               dn_calculate="'cn='.$cn"
               username="cn=Manager,o=abook"
               password="secret"
               key_fields="cn"
         />
       </databases>
     </AddressBook_config>

   This defines three attributes with cannonical names "firstname",
"lastname", and "fullname".  These are accessed in the LDAP backend
context as "givenname", "sn" and "cn", and in the HTML backend context as
"First Name", "Last Name" and "Full Name" respectively.

   The default attribute ordering  is "firstname", "lastname", "fullname",
however the HTML backend overrides this and in that context attributes are
ordered: "lastname", "firstname", "fullname".   All other meta-attributes
may be similarily overriden by specific backends

   "fullname" is a calculated attribute.  Calculation strings may
reference the names of other attributes by "$<attr_name>".

   Backend databases may also be named and then tied to a source type by
using the 'driver' attribute.  This technique is useful for defining
multiple backends of the same type.  For example,

     <AddressBook_config>
       <fields>
         <field name="firstname" >
           <db type="ldap_server_1" name="givenname" />
           <db type="ldap_server_2" name="givenname" />
         </field>
         <field name="lastname" >
           <db type="ldap_server_1" name="sn" />
           <db type="ldap_server_2" name="sn" />
         </field>
       </fields>
       <databases>
         <ldap_server_1 driver="LDAP"
                        hostname="server_1"
                        objectclass="inetOrgPerson"
                        base="o=abook"
                        dn_calculate="'cn='.$cn"
                        username="cn=Manager,o=abook"
                        password="secret"
                        key_fields="cn"
         />
         <ldap_server_2 driver="LDAP"
                        hostname="server_2"
                        objectclass="inetOrgPerson"
                        base="o=abook"
                        dn_calculate="'cn='.$cn"
                        username="cn=Manager,o=abook"
                        password="secret"
                        key_fields="cn"
         />
       </databases>
     </AddressBook_config>

   See the various backend man pages for information on the <database>
configuration attributes.  See also the sample configuration files in the
'examples' directory.

getMeta      %meta = %{$config->getMeta(attr=>$attr)}   %meta = %{$config->getMeta(attr=>$attr,db=>$db)}
--------------------------------------------------------------------------------------------------------

   Returns an attribute metadata hash

AUTHOR
======

   David L. Leigh, <dleigh@sameasiteverwas.net>

SEE ALSO
========

   *Note AddressBook: AddressBook, *Note AddressBook/Entry:
AddressBook/Entry,


File: pm.info,  Node: AddressBook/DB/BBDB,  Next: AddressBook/DB/DBI,  Prev: AddressBook/Config,  Up: Module List

Perl extension for reading and writing bbdb files
*************************************************

NAME
====

   bbdb - Perl extension for reading and writing bbdb files

SYNOPSIS
========

     use BBDB;
     my $x = new BBDB();
     $x->decode($string);
     my $str = $x->encode();
     # At this point, subject to the BUGS below
     # $str is the same as $string

     my $allR = BBDB::simple('/home/henry/.bbdb');
     map { print $_->part('first')} @$allR;   # print out all the first names

DESCRIPTION
===========

Data Format
-----------

   The following is the data layout for a BBDB record.  I have created a
sample record with my own data.  Each field is just separated by a space.
I have added comments to the right

     ["Henry"                             The first name - a string
     "Laxen"                              The last name - a string
     ("Henry, Enrique")                   Also Known As - comma separated list
     "Elegant Solution"                   Business name - a string
     (["home" 415 789 1159 0]             Phone number field - US style
      ["fax" 415 789 1156 0]              Phone number field - US style
      ["mazatlan" "011-5269-164195"]      Phone number field - International style
     )
     (["mailing" "PMB 141"                Address field - There are 3 fields for
       "524 San Anselmo Ave." ""           for the street address, then one each
       "San Anselmo" "CA" (94960 2614)"     for City, State, and Zip Code
      ]
      ["mazatlan" "Reino de Navarra #757" Address field - Note that there is no
       "Frac. El Cid" ""                   field for Country.  That is unfortunate
       "Mazatlan" "Sinaloa, Mexico"        The zip code field is quoted if its
       ("CP" "82110")                      not an integer
      ]
      )
     ("nadine.and.henry@pobox.com"        The net addresses - a list of strings
      "maztravel@maztravel.com")
     ((creation-date . "1999-09-02")      The notes field - a list of alists
      (timestamp . "1999-10-17")
      (notes . "Always split aces and eights")
      (birthday "6/15")
     )
     nil                                  The cache vector - always nil
     ]

   After this is decoded it will be returned as a reference to a BBDB
object.  The internal structure of the BBDB object mimics the lisp
structure of the BBDB string.  It consists of a reference to an array with
9 elements The Data::Dumper output of the above BBDB string would just
replaces all of the ()s with []s.  It can be accessed by using the
`$bbdb-'part('all')> method.

Methods
-------

new()
     called whenever you want to create a new BBDB object.         my
     $bbdb = new BBDB();

part(name [value])
     Called to get or set all or part of a BBDB object.  The parts of the
     object are:

          all first last aka company phone address net notes

     any other value in the name argument results in death.  Some of these
     parts, namely phone, address, net, and notes have an internal
     structure and are returned as references to arrays.  The others are
     returned just as strings.  The optional second argument sets the part
     of this BBDB object to the value you provided.  There is no
     consistency checking at this point, so be sure the value you are
     setting this to is correct.

          my $first = $bbdb->part('first');    # get the value of the first field
          $bbdb->part('last','Laxen');         # set the value of the last field
          my $everything = $bbdb->part('all'); # get the whole record

BBDB::simple(file_name,[array_ref_of_bbdb])
     This is a "simple" interface for reading or writing an entire BBDB
     file. If called with one argument, it returns a reference to an array
     of BBDB objects.  Each object contains the data from the file.  Thus
     the number of BBDB entries equals `scalar(@$bbdb)' if you use:

          $bbdb = BBDB::simple('/home/henry/.bbdb');

     If called with two arguments, the first is the filename to create, and
     the second is a reference to an array of BBDB objects, such as was
     returned in the one argument version.  The objects are scanned for
     unique user defined fields, which are written out as the 2nd line in
     the BBDB file, and then the individual records are written out.

decode(string)
     Takes a string as written in a BBDB file of a single BBDB record and
     decodes it into its PERL representation.  Returns undef if it
     couldn't decode the record for some reason, otherwise returns true.

          $bbdb->decode($entry);

encode()
     This is the inverse of decode.  Takes an internal PERL version of a
     BBDB records and returns a string which is a lisp version of the data
     that BBDB understands.  There are some ambiguities, noted in BUGS
     below.

          my $string = $bbdb->encode();

Debugging
---------

   If you find that some records in your BBDB file are failing to be
recognized, trying setting `$BBDB::debug = 1;' to turn on debugging.  We
will then print out to STDERR the first field of the record that we were
unable to recognize.  Very handy for complicated BBDB records.

AUTHOR
======

   Henry Laxen <nadine.and.henry@pobox.com> http://www.maztravel.com/perl

SEE ALSO
========

   BBDB texinfo documentation

BUGS
====

   Phone numbers and zip codes may be converted from strings to integers
if they are decoded and encoded.  This should not affect the operation of
BBDB.  Also a null last name is converted from "" to nil, which also
doesn't hurt anything.

   You might ask why I use arrays instead of hashes to encode the data in
the BBDB file.  The answer is that order matters in the bbdb file, and
order isn't well defined in hashes.  Also, if you use hashes, at least in
the simple minded way, you can easily find yourself with legitimate
duplicate keys.


File: pm.info,  Node: AddressBook/DB/DBI,  Next: AddressBook/DB/HTML,  Prev: AddressBook/DB/BBDB,  Up: Module List

Backend for AddressBook to use in databases
*******************************************

NAME
====

   AddressBook::DB::DBI - Backend for AddressBook to use in databases

SYNOPSIS
========

     use AddressBook;
     $a = AddressBook->new(source => "DBI:CSV:f_dir=/tmp/csv",
     			table=>"a_csv",
     			);

DESCRIPTION
===========

   The DBI perl library module is required in order to use this package.

   AddressBook::DB::DBI supports both sequential and random access backend
database methods.

   The DBI backend has so far only been tested against the CSV database
driver.

   AddressBook::DB::DBI behavior can be modified using the following
options:

table
     Required parameter

key_fields
     A list of DBI field names (not cannonical names) which can be used to
     uniquely identify a database record.

dsn
     See constructor details below

new
---

   The database driver and driver arguments may be specified in in the
constructor in one of two ways:

  1. As part of the "source" parameter, for example:

          $a = AddressBook->new(source => "DBI:CSV:f_dir=/tmp/csv",
          			table=>"a_csv",
          			);

  2. In a "dsn" parameter, for example:

          $a = AddressBook->new(source => "DBI",
          			dsn=>"CSV:f_dir=/tmp/csv",
          			table=>"a_csv",
          			);

     Like all AddressBook database constructor parameters, the "dsn" and
     "table" may also be specified in the configuration file.


Timestamps
----------

   For syncronization purposes, all records are timestamped depending on
the database driver type:

CSV
     All records are timestamped with the modification data of the CSV
     file.

AUTHOR
======

   Mark A. Hershberger, <mah@everybody.org> David L. Leigh,
<dleigh@sameasiteverwas.net>

SEE ALSO
========

   *Note AddressBook: AddressBook, *Note AddressBook/Config:
AddressBook/Config,, *Note AddressBook/Entry: AddressBook/Entry,.

   DBI DBD::CSV


File: pm.info,  Node: AddressBook/DB/HTML,  Next: AddressBook/DB/LDAP,  Prev: AddressBook/DB/DBI,  Up: Module List

Backend for AddressBook to print entries in HTML format
*******************************************************

NAME
====

   AddressBook::DB::HTML - Backend for AddressBook to print entries in
HTML format

SYNOPSIS
========

     use AddressBook;
     $a = AddressBook->new(source => "HTML");
     $a->write($entry);

DESCRIPTION
===========

   AddressBook::DB::HTML currently supports only the sequential write
method.

   Behavior can be modified using the following options:

write_format
     The write_format string is eval'd to determine how the entry is
     written.  The default write_format string is:

          'table(Tr([map{td(["$_:",$attributes{$_}])} keys %attributes]))'

     This displays the entry in a table with attribute names on the left
     and values on the right.  As can be seen, CGI.pm tag-generating
     functions can be used in format strings. The "%attributes" hash is
     available for use.  The keys of %attributes are HTML backend
     attribute names, and the values are the corresponding attribute
     values.  Specific attributes can also be referenced by name using a
     scalar with the same name as the attribute.   For example,

          'Name: $Name'

     Assuming that "Name" is a valid HTML attribute, this format string
     will display entry names.  This is equivalent to:

          'Name: $attributes{Name}'

     The HTML backend recognizes the string "keys %attributes", and
     substitues an expression which ensures that the "order"
     meta-attribute is obeyed.

form_format
     The form_format string is eval'd to construct an html entry form.
     The default form_format string is:

          table(Tr({-valign=>"TOP"},[map{td([$_,$attributes{$_}])} keys %attributes]))

     Which generates a table of fields with labels on the left.  The input
     type is based on the attribute type, eg. "text" attributes appear as
     text input fields, "boolean" attributes appear as checkbox inputs,
     etc...  The default values of the entry fields are the current values
     of the entry's attributes.

intra_attr_sep
     The string to use in joining multiple instances of the same
     attribute.  The default is "<br>"

AUTHOR
======

   Mark A. Hershberger, <mah@everybody.org> David L. Leigh,
<dleigh@sameasiteverwas.net>

SEE ALSO
========

   *Note AddressBook: AddressBook,, *Note AddressBook/Config:
AddressBook/Config,, *Note AddressBook/Entry: AddressBook/Entry,.


File: pm.info,  Node: AddressBook/DB/LDAP,  Next: AddressBook/DB/LDIF,  Prev: AddressBook/DB/HTML,  Up: Module List

Backend for AddressBook to use LDAP.
************************************

NAME
====

   AddressBook::DB::LDAP - Backend for AddressBook to use LDAP.

SYNOPSIS
========

     use AddressBook;
     $a = AddressBook->new(source => "LDAP:hostname/ou=People,dc=example,dc=com",
                           username => "user", password => "pass");
     $a->add($entry) || die $a->code;

DESCRIPTION
===========

   The Net::LDAP library module is required in order to use this package.

   AddressBook::DB::LDAP supports random access backend database methods.

   Behavior can be modified using the following options:

key_fields
     A list of LDAP attribute names (not cannonical names) which can be
     used to uniquely identify an entry.

hostname
     The LDAP host to which to connect.

base
     The base for LDAP queries.

objectclass
     The objectclass for AddressBook entries.

username
     An LDAP dn to use for accessing the server.

password
dn_calculate
     A perl expression which, when eval'd returns a valid LDAP "dn"
     (omitting the "base" part of the dn).  Other attributes may be
     referenced as "$<attr>".

     For example, if LDAP entries have a dn like: "cn=John
     Doe,mail=jdoe@mail.com", then use the following:

          dn_calculate="'cn=' . $cn . ',mail=' . $mail"

   Any of these options may be specified in the constructor, or in the
configuration file.

new
---

     $a = AddressBook->new(source => "LDAP");
     $a = AddressBook->new(source => "LDAP:localhost/ou=People,dc=example,dc=com");
     $a = AddressBook->new(source => "LDAP",
     			hostname=>"localhost",
     			base=>"o=test"
     			);

   Any or all options may be specified in the constructor, or in the
configuration file.

Timestamps
----------

   For syncronization purposes, all records are timestamped using the
"modifytimestamp" LDAP attribute.  If the record has no "modifytimestamp",
"createtimestamp" is used.  If there is no "createtimestamp", the current
time is used.

AUTHOR
======

   Mark A. Hershberger, <mah@everybody.org> David L. Leigh,
<dleigh@sameasiteverwas.net>

SEE ALSO
========

   *Note AddressBook: AddressBook,, *Note AddressBook/Config:
AddressBook/Config,, *Note AddressBook/Entry: AddressBook/Entry,.

   Net::LDAP


File: pm.info,  Node: AddressBook/DB/LDIF,  Next: AddressBook/DB/PDB,  Prev: AddressBook/DB/LDAP,  Up: Module List

Backend for AddressBook to use LDIF files.
******************************************

NAME
====

   AddressBook::DB::LDIF - Backend for AddressBook to use LDIF files.

SYNOPSIS
========

     use AddressBook;
     $a = AddressBook->new(source => "LDIF",
     			filename => "/tmp/ldif")

DESCRIPTION
===========

   AddressBook::DB::LDIF supports sequential backend database methods.

   AddressBook::DB::LDIF behavior can be modified using the following
options:

key_fields
     A list of LDIF attribute names (not cannonical names) which can be
     used to uniquely identify an entry.

base
     The LDAP base for all entries

objectclass
     The LDAP objectclass for entries

dn_calculate
     A perl expression which, when eval'd returns a valid LDAP "dn"
     (omitting the "base" part of the dn).  Other attributes may be
     referenced as "$<attr>".

     For example, if LDIF entries have a dn like: "cn=John
     Doe,mail=jdoe@mail.com", then use the following:

          dn_calculate="'cn=' . $cn . ',mail=' . $mail"

   Any of these options can be specified in the constructor, or in the
configuration file.

new
---

   The LDIF file is specified using the "filename" parameter:

     $a = AddressBook->new(source => "LDIF",
     			filename => "/tmp/ldif")

   The filename may also be specified in the configuration file.

Timestamps
----------

   For syncronization purposes, all records are timestamped with the
modification date of the LDIF file.

AUTHOR
======

   David L. Leigh, <dleigh@sameasiteverwas.net>

SEE ALSO
========

   *Note AddressBook: AddressBook,, *Note AddressBook/Config:
AddressBook/Config,, *Note AddressBook/Entry: AddressBook/Entry,.

   Net::LDAP


