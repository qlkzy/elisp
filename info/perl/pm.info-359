This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Template/Plugin/Format,  Next: Template/Plugin/Iterator,  Prev: Template/Plugin/Dumper,  Up: Module List

simple Template Plugin interface to create formatting function
**************************************************************

NAME
====

   Template::Plugin::Format - simple Template Plugin interface to create
formatting function

SYNOPSIS
========

     [% USE format %]
     [% commented = format('# %s') %]
     [% commented('The cat sat on the mat') %]
     
     [% USE bold = format('<b>%s</b>') %]
     [% bold('Hello') %]

DESCRIPTION
===========

   The format plugin constructs sub-routines which format text according to
a printf()-like format string.

AUTHOR
======

   Andy Wardley <kfs.org>

REVISION
========

   $Revision: 2.0 $

COPYRIGHT
=========

   Copyright (C) 1996-1999 Andy Wardley.  All Rights Reserved.  Copyright
(C) 1998-1999 Canon Research Centre Europe Ltd.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Template::Plugin|Template::Plugin' in this node,


File: pm.info,  Node: Template/Plugin/Iterator,  Next: Template/Plugin/Java,  Prev: Template/Plugin/Format,  Up: Module List

plugin to create Template::Iterator objects
*******************************************

NAME
====

   Template::Plugin::Iterator - plugin to create Template::Iterator objects

SYNOPSIS
========

     [% USE iterator(list, args) %]

     [% FOREACH item = iterator %]
        [% '<ul>' IF iterator.first %]
        <li>[% item %]
        [% '</ul>' IF iterator.last %]
     [% END %]

DESCRIPTION
===========

   The iterator plugin provides a way to create a Template::Iterator object
to iterate over a data set.  An iterator is implicitly automatically by the
FOREACH directive.  This plugin allows the iterator to be explicitly
created with a given name.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

REVISION
========

   $Revision: 2.0 $

COPYRIGHT
=========

   Copyright (C) 2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Template::Iterator|Template::Iterator' in this node,
`Template::Plugin|Template::Plugin' in this node


File: pm.info,  Node: Template/Plugin/Java,  Next: Template/Plugin/Java/Constants,  Prev: Template/Plugin/Iterator,  Up: Module List

Generate Java Classes from XML description files and templates.
***************************************************************

NAME
====

   Template::Plugin::Java - Generate Java Classes from XML description
files and templates.

SYNOPSIS
========

   From an xml file such as:

     <aBean>
     	<java: option1="value1">
     		<option2>value2</option2>
     	</java:>
     	<foo>10</foo>
     	<bar>String</bar>
     	<container>
     		<baz>20</baz>
     	</container>
     </aBean>

   Through the program "tjava":

   tjava [options] [file.xml ...]

   Via a template, such as:

     [% USE Java %]
     package $package;
     
     public class $class {
     
     [% FOREACH Java.variables %]
     $type $name = $initializer;
     [% END %]
     
     //... etc
     }

   To generated Java source code in the appropriate directory as
determined by the package of the .xml file's directory, specified package
option if any, and CLASSPATH.

OPTIONS
=======

   Any options may be given besides those listed, these are passed
directly to the Templates being processed in the stash (the variable table
at time of processing). They can be given in the <java:> ... </java:>
section of an XML file (in which case, don't use the - dashes) as
attributes or elements, or on the command line.

*-template*
     Name of the template to process. No extension is assumed by default
     unlike in the previous version.

*-package*
     Destination package to put the generated classes, otherwise will be
     determined from how the current directory relates to the CLASSPATH.

*-class*
     Class name to use, otherwise will infer from the root tag of the XML
     file.

*-templatePath*
     Colon separated path where the templates can be found, overrides the
     environment variable TEMPLATEPATH. This doesn't work right now, so
     use the TEMPLATEPATH environment variable.

*-genContainers*
     If set to 0, classes for subcontainers will not be generated. This is
     generally not useful.

*-containerTemplate*
     By default set to Container, this is the default template, as well as
     the template used for sub-containers.

*-containerNamePrefix*
     By default, if generating class Foo that needs to have a sub
     container wrapped in tag <bar>, it's name will be FooBar. This is
     safe and won't cause collisions with different classes having sub
     containers of the same name (until some sort  of dependency checking
     code is introduced). To turn this off, set it to the empty string "".

*-interface*
     Interface to add to list of implemented interfaces, can be supplied
     multiple times. Make sure you append any necessary code to implement
     any of these interfaces.

*-append*
     Text to insert in the generated class body.

*-appendFile*
     Will insert text read from the file specified into the generated
     class body.  This option and the *-append* option are mutually
     exclusive.

*-file[s]*
     The XML file(s) to parse. This is useful for when the Plugin is
     instantiated from a custom script, not via tjava or inside a template.

     Any other option will be placed into the stash for the templates to
     use, making tjava very useful with your custom templates.

     Anything that's not an option will be assumed to be a file.

DESCRIPTION
===========

   Template::Plugin::Java is a plugin module for the Template toolkit that
makes it easier to write templates for generating Java source code,
ultimately for transforming XML descriptions into Java language sources.

   It can be used either directly on the command line, or loaded from a
Template with a `[% USE Java %]' statement, or in many other ways. It
tries to be intelligent and figure out what context you are using it in.

   I'll write more eventually, for now see the examples in the
distribution.

METHODS
=======

new
     This, the constructor, does everything necessary to create a new
     instance of the Java plugin, based on context. If not given a
     context, takes control of the command line and then parses any
     options and files given. This is what the "tjava" utility does.

template
     Sets the Template of the instance (and therefore the context) when
     called with a parameter, returns it otherwise.

context
     Sets the Template::Context of the instance when called with a
     parameter, returns it otherwise.

getInitializer
     Returns an initializer string for a type.

variables
     Returns a list of variable description hashes.

variableDeclarations($options_hashref)
     Returns a list of <type> <name> strings such as: 	String foo 	int bar
     ...

     These can be used in a template in this way: 	function ([%
     Java.variableDeclarations.join(", ") %]) { 	...  	}

variableNames
     Returns a list of variable names.

getVariables
     Returns a hashref of variables, taking a raw variables hash.  Takes
     an optional variable type string.

scalar
     Whether or not a java type is a Scalar type.

string
     Whether or not a java type is a String type.

array
     Whether or not a java type is an Array type.

arrayType
     Figures out the type of elements a Vector will take.  Parameters:
     name, arrayref TODO: This should be an aggregate, not merely the type
     of the first element.

encapsulatePrimitive
     Translate int to Integer, long to Long, etc.

mapType
     Maps a perl scalar or reference to a Java type.  Parameters: name of
     element, value of element.

genClass
     Generates a container class.

     Parameters: name of tag to create container from, hashref to gen from.
     Returns:    name of class generated.

castJavaString
     Casts a java String to another type using the appropriate code.
     Parameters: name of variable to cast, type to cast to.

ENVIRONMENT
===========

   These are the environment variables used.

TEMPLATEPATH
     Colon separated path to where templates can be found. Overridden by
     the *-templatePath* command line option.

CLASSPATH
     Used for many things, like inferring the package of the current
     directory, where to put generated files that are in other packages,
     and other evil things I have not yet thought of.

AUTHOR
======

   Rafael Kitover (caelum@debian.org)

COPYRIGHT
=========

   This program is Copyright (c) 2000 by Rafael Kitover. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

BUGS
====

   Probably many.

   The *-templatePath* option should actually work.

TODO
====

   A very great deal.  Including more documentation.  DBClass doesn't work
in tt 1.x.  Non-sense options in java: contexts should be somehow handled?

SEE ALSO
========

   `perl(1)' in this node, `Template(3)' in this node,
`Template::Plugin::Java::Utils(3)' in this node,
`Template::Plugin::JavaSQL(3)' in this node
`Template::Plugin::Java::Constants(3)' in this node,


File: pm.info,  Node: Template/Plugin/Java/Constants,  Next: Template/Plugin/Java/Utils,  Prev: Template/Plugin/Java,  Up: Module List

Constants for the Java Template plugin modules.
***********************************************

NAME
====

   Template::Plugin::Java::Constants - Constants for the Java Template
plugin modules.

SYNOPSIS
========

   use Template::Plugin::Java::Constants qw/:regex/; use
Template::Plugin::Java::Constants qw/:boolean/; use
Template::Plugin::Java::Constants qw/:all/;

DESCRIPTION
===========

regex
     The "regex" tag exports qr// compiled regular expressions SCALAR,
     PRIMITIVE, STRING and ARRAY, these are for matching Java types. All
     of these match a whole line, with no extra whitespace, and return the
     matched java type as $1. They may be used as:

     $string =~ /@{[SCALAR]}/; # Ugly but effective and relatively fast.

    SCALAR
          Any primitive or encapsulated primitive: int, or Integer, or
          String, etc.

    PRIMITIVE
          Only primitive types like int, float, double, byte, etc.

    STRING
          An incarnation of java.lang.String.

    ARRAY
          A java.util.Vector.

boolean
     The boolean tag just exports the constants TRUE as 1 and FALSE as 0.

all
     Exports all of the proceeding.

AUTHOR
======

   Rafael Kitover (caelum@debian.org)

COPYRIGHT
=========

   This program is Copyright (c) 2000 by Rafael Kitover. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

SEE ALSO
========

   `perl(1)' in this node, `Template(3)' in this node,
`Template::Plugin::Java::Utils(3)' in this node,
`Template::Plugin::Java::SQL(3)' in this node


File: pm.info,  Node: Template/Plugin/Java/Utils,  Next: Template/Plugin/JavaSQL,  Prev: Template/Plugin/Java/Constants,  Up: Module List

Utility functions for Template::Plugin::Java.
*********************************************

NAME
====

   Template::Plugin::Java::Utils - Utility functions for
Template::Plugin::Java.

SYNOPSIS
========

     use Template::Plugin::Java::Utils qw/list of subroutines to import/;

SUBROUTINES
===========

createTemplate
     Creates a new Template with reasonable options.

parseOptions
     Replaces c_c with cC and nosomething=whatever with something=0 in the
     keys of a hash.

setOption
     Adds to or sets an option in a hash, supports nested arrays and
     boolean options. The logic here is one of those things that just
     works the way it is and seems decipherable, but don't mess with it.

parseCmdLine
     Parses @ARGV into a hash of options and values, leaving everything
     else that is most likely a list of files on @ARGV.

*sqlType2JavaType( type_name [, precision for numeric types] )*
     Maps some ANSI SQL data types to the closest Java variable types. The
     default case is byte[] for unrecognized sql types.

*simplifyPath( path )*
     Remove any dir/../ or /./ or extraneous / from a path, as well as
     prepending the current directory if necessary.

*findPackageDir( directory )*
     Find package in $ENV{CLASSPATH}.

*determinePackage([ optional directory ])*
     Determine the package of the current or passed-in directory.

*isNum( string )*
     Determines whether a string is a number or not. Uses the more powerful
     DBI::looks_like_number heuristic if available.

*castJavaString( variable_name, target_type )*
     Casts a java String to another type using the appropriate code.

*javaTypeName( javaType )*
     Transform a java type name to a character string version. In other
     words, String remains String, but byte[] becomes byteArray.

ENVIRONMENT
===========

   These are the environment variables used.

TEMPLATEPATH
     Colon separated path to where templates can be found, used by default
     in the createTemplate subroutine.

CLASSPATH
     Searched in *findPackageDir* to find a directory relative to it.

AUTHOR
======

   Rafael Kitover (caelum@debian.org)

COPYRIGHT
=========

   This program is Copyright (c) 2000 by Rafael Kitover. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

BUGS
====

   None known.

TODO
====

   Nothing here.

SEE ALSO
========

   `perl(1)' in this node, `Template(3)' in this node,
`Template::Plugin::Java(3)' in this node, `Template::Plugin::JavaSQL(3)'
in this node `Template::Plugin::Java::Constants(3)' in this node,


File: pm.info,  Node: Template/Plugin/JavaSQL,  Next: Template/Plugin/Table,  Prev: Template/Plugin/Java/Utils,  Up: Module List

Help generate Java from database schemas.
*****************************************

NAME
====

   Template::Plugin::JavaSQL - Help generate Java from database schemas.

SYNOPSES
========

   Within an XML file processed by the Java plugin:

     <sql:
     	query="select foo as f, bar as b from some_table"
     >

     or

     <sql:
     	table="some_table"
     >

   Via a template such as:

     [% USE Java %]
     [% Use JavaSQL %]
     ...
     String query =
     "select [% JavaSQL.columnNames.join(", ") %] from [% JavaSQL.tables.join(", ") %]";
     [% IF JavaSQL.where %]
     query += " where [% JavaSQL.where %] ";
     [% ELSE %]
     query += " where 0=0 ";
     [% END %]
     [% FOREACH JavaSQL.columns %]
     if (${varName}Set) { query += " and $name = ?"; }
     [% END %]
     [% IF JavaSQL.order %]
     query += "order by [% JavaSQL.order %]";
     [% END %]
     stmt = myConnection.prepareStatement(query);

   Just use the DBClass.template from the distribution for fully functional
database classes.

DESCRIPTION
===========

   In addition to methods that refer to parts of a SQL query, any columns
resultant from the query or table will be added as java variables to the
variables hash, with close-as-possible mapped types.

METHODS
=======

new
     Constructor. If given one parameter of type Template::Context, will
     use that as a context. Then process the contents of "sql:" within the
     stash. This is what typically happens inside a template when a [% USE
     JavaSQL %] directive is encountered.

context
     Returns Template::Context this instance has, if any.

query
     The complete query, either supplied at instantiation or inferred from
     other arguments.

where
     The "where" portion of the SQL query, excluding the word "where"
     itself.

tables
     A list of tables used by the query.

tableCount
     Number of tables used by query.

updatable
     Whether the query used can be used to update the table.

order
     An ORDER BY clause, if one was used.

columnNames
     A list of column names used in the query.

isColumn
     Check whether a variable name is a column.

varToColumn
     Gives the column name mapping of the Java variable name.

columnToVar
     Gives the Java variable name mapping of the column name.

columnCount
     Number of columns returned from query.

columns
     Intended to be used as [% FOREACH JavaSQL.columns %] ...  See `' in
     this node.

parseQuery
     Used internally to parse a SQL query and set the appropriate state
     variables.

ENVIRONMENT
===========

DBI_DSN
     DBI Data Source Name, for example, the data source for MySQL and
     database name "test" it would be: dbi:mysql:database=test

DBI_USER
     User name to connect to the database as.

DBI_PASS
     Password for database, can be blank for no password.

AUTHOR
======

   Rafael Kitover (caelum@debian.org) The concept and related templates
are based on Andrew Lanthier's dbgen framework (an unreleased development
utility).

COPYRIGHT
=========

   This program is Copyright (c) 2000 by Rafael Kitover. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

BUGS
====

   Probably many.

TODO
====

   A very great deal.

SEE ALSO
========

   `perl(1)' in this node, `Template(3)' in this node,
`Template::Plugin::Java::Utils(3)' in this node,
`Template::Plugin::Java::Constants(3)' in this node,


File: pm.info,  Node: Template/Plugin/Table,  Next: Template/Plugin/URL,  Prev: Template/Plugin/JavaSQL,  Up: Module List

presents a data set as rows and columns
***************************************

NAME
====

   Template::Plugin::Table - presents a data set as rows and columns

SYNOPSIS
========

     [% USE table(list, rows=n, cols=n, overlap=n, pad=0) %]

     [% FOREACH item = table.row(n) %]
        [% item %]
     [% END %]

     [% FOREACH item = table.col(n) %]
        [% item %]
     [% END %]

     [% FOREACH row = table.rows %]
        [% FOREACH item = row %]
           [% item %]
        [% END %]
     [% END %]

     [% FOREACH col = table.cols %]
        [% col.first %] - [% col.last %] ([% col.size %] entries)
     [% END %]

DESCRIPTION
===========

   The Table plugin allows you to format a list of data items into a
virtual table.  When you create a Table plugin via the USE directive,
simply pass a list reference as the first parameter and then specify a
fixed number of rows or columns.

     [% USE Table(list, rows=5) %]
     [% USE table(list, cols=5) %]

   The 'Table' plugin name can also be specified in lower case as shown in
the second example above.  You can also specify an alternative variable
name for the plugin as per regular Template Toolkit syntax.

     [% USE mydata = table(list, rows=5) %]

   The plugin then presents a table based view on the data set.  The data
isn't actually reorganised in any way but is available via the row(),
col(), rows() and cols() as if formatted into a simple two dimensional
table of n rows x n columns.  Thus, if our sample 'alphabet' list
contained the letters 'a' to 'z', the above USE directives would create
plugins that represented the following views of the alphabet.

     [% USE table(alphabet, ... %]

     rows=5                  cols=5
     a  f  k  p  u  z        a  g  m  s  y
     b  g  l  q  v           b  h  n  t  z
     c  h  m  r  w           c  i  o  u
     d  i  n  s  x           d  j  p  v
     e  j  o  t  y           e  k  q  w
                             f  l  r  x

   We can request a particular row or column using the row() and col()
methods.

     [% USE table(alphabet, rows=5) %]
     [% FOREACH item = table.row(0) %]
        # [% item %] set to each of [ a f k p u z ] in turn
     [% END %]

     [% FOREACH item = table.col(2) %]
        # [% item %] set to each of [ m n o p q r ] in turn
     [% END %]

   Data in rows is returned from left to right, columns from top to
bottom.  The first row/column is 0.  By default, rows or columns that
contain empty values will be padded with the undefined value to fill it to
the same size as all other rows or columns.  For example, the last row
(row 4) in the first example would contain the values [ e j o t y undef ].
The Template Toolkit will safely accept these undefined values and print a
empty string.  You can also use the IF directive to test if the value is
set.

     [% FOREACH item = table.row(4) %]
        [% IF item %]
           Item: [% item %]
        [% END %]
     [% END %]

   You can explicitly disable the 'pad' option when creating the plugin to
returned shortened rows/columns where the data is empty.

     [% USE table(alphabet, cols=5, pad=0) %]
     [% FOREACH item = table.col(4) %]
        # [% item %] set to each of 'y z'
     [% END %]

   The rows() method returns all rows/columns in the table as a reference
to a list of rows (themselves list references).  The row() methods when
called without any arguments calls rows() to return all rows in the table.

   Ditto for cols() and col().

     [% USE table(alphabet, cols=5) %]
     [% FOREACH row = table.rows %]
        [% FOREACH item = row %]
           [% item %]
        [% END %]
     [% END %]

   The Template Toolkit provides the first(), last() and size() methods
that can be called on list references to return the first/last entry or
the number of entried.  The following example shows how we might use this
to provide an alphabetical index split into 3 even parts.

     [% USE table(alphabet, cols=3, pad=0) %]
     [% FOREACH group = table.col %]
        [ [% group.first %] - [% group.last %] ([% group.size %] letters) ]
     [% END %]

   This produces the following output:

     [ a - i (9 letters) ]
     [ j - r (9 letters) ]
     [ s - z (8 letters) ]

   We can also use the general purpose join() list method which joins the
items of the list using the connecting string specified.

     [% USE table(alphabet, cols=5) %]
     [% FOREACH row = table.rows %]
        [% row.join(' - ') %]
     [% END %]

   Data in the table is ordered downwards rather than across but can easily
be transformed on output.  For example, to format our data in 5 columns
with data ordered across rather than down, we specify 'rows=5' to order
the data as such:

     a  f  .  .
     b  g  .
     c  h
     d  i
     e  j

   and then iterate down through each column (a-e, f-j, etc.) printing the
data across.

     a  b  c  d  e
     f  g  h  i  j
     .  .
     .

   In addition to a list reference, the Table plugin constructor may be
passed a reference to a Template::Iterator object or subclass thereof.
The get_all() method is first called on the iterator to return all
remaining items.  These are then available via the usual Table interface.

     [% USE DBI(dsn,user,pass) -%]

     # query() returns an iterator
     [% results = DBI.query('SELECT * FROM alphabet ORDER BY letter') %]
     
     # pass into Table plugin
     [% USE table(results, rows=8 overlap=1 pad=0) -%]

     [% FOREACH row = table.cols -%]
        [% row.first.letter %] - [% row.last.letter %]:
           [% row.join(', ') %]
     [% END %]

AUTHOR
======

   Andy Wardley <abw@kfs.org>

REVISION
========

   $Revision: 2.1 $

COPYRIGHT
=========

   Copyright (C) 2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Template::Plugin|Template::Plugin' in this node,


File: pm.info,  Node: Template/Plugin/URL,  Next: Template/Plugin/Wrap,  Prev: Template/Plugin/Table,  Up: Module List

constructs query URL's with parameters
**************************************

NAME
====

   Template::Plugin::URL - constructs query URL's with parameters

SYNOPSIS
========

     [% USE url('/cgi-bin/foo.pl') %]

     [% url(debug = 1, id = 123) %]
        # ==> /cgi/bin/foo.pl?debug=1&id=123

     [% USE mycgi = url('/cgi-bin/bar.pl', mode='browse', debug=1) %]

     [% mycgi %]
        # ==> /cgi/bin/bar.pl?mode=browse&debug=1

     [% mycgi(mode='submit') %]
        # ==> /cgi/bin/bar.pl?mode=submit&debug=1

     [% mycgi(debug='d2 p0', id='D4-2k[4]') %]
        # ==> /cgi-bin/bar.pl?mode=browse&debug=d2%20p0&id=D4-2k%5B4%5D

DESCRIPTION
===========

   The URL plugin can be used to construct complex URLs from a base stem
and a hash array of additional query parameters.

   The constructor should be passed a base URL and optionally, a hash array
reference of default parameters and values.  Used from with a Template
Documents, this would look something like the following:

     [% USE url('http://www.somewhere.com/cgi-bin/foo.pl') %]
     [% USE url('/cgi-bin/bar.pl', mode='browse') %]
     [% USE url('/cgi-bin/baz.pl', mode='browse', debug=1) %]

   When the plugin is then called without any arguments, the default base
and parameters are returned as a formatted query string.

     [% url %]

   For the above three examples, these will produce the following outputs:

     http://www.somewhere.com/cgi-bin/foo.pl
     /cgi-bin/bar.pl?mode=browse
     /cgi-bin/baz.pl?mode=browse&debug=1

   Additional parameters may be also be specified:

     [% url(mode='submit', id='wiz') %]

   Which, for the same three examples, produces:

     http://www.somewhere.com/cgi-bin/foo.pl?mode=submit&id=wiz
     /cgi-bin/bar.pl?mode=submit&id=wiz
     /cgi-bin/baz.pl?mode=browse&debug=1&id=wiz

   A new base URL may also be specified as the first option:

     [% url('/cgi-bin/waz.pl', test=1) %]

   producing

     /cgi-bin/waz.pl?test=1
     /cgi-bin/waz.pl?mode=browse&test=1
     /cgi-bin/waz.pl?mode=browse&debug=1&test=1

   The ordering of the parameters is non-deterministic due to fact that
Perl's hashes themselves are unordered.  This isn't a problem as the
ordering of CGI parameters is insignificant (to the best of my knowledge).
All values will be properly escaped thanks to some code borrowed from
Lincoln Stein's CGI.pm.  e.g.

     [% USE url('/cgi-bin/woz.pl') %]
     [% url(name="Elrich von Benjy d'Weiro") %]

   Here the spaces and "'" character are escaped in the output:

     /cgi-bin/woz.pl?name=Elrich%20von%20Benjy%20d%27Weiro

   Alternate name may be provided for the plugin at construction time as
per regular Template Toolkit syntax.

     [% USE mycgi = url('cgi-bin/min.pl') %]

     [% mycgi(debug=1) %]

AUTHOR
======

   Andy Wardley <abw@kfs.org>

REVISION
========

   $Revision: 2.0 $

COPYRIGHT
=========

   Copyright (C) 2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Template::Plugin|Template::Plugin' in this node,


File: pm.info,  Node: Template/Plugin/Wrap,  Next: Template/Plugin/XML/DOM,  Prev: Template/Plugin/URL,  Up: Module List

wrap text using the Text::Wrap module.
**************************************

NAME
====

   Template::Plugin::Wrap - wrap text using the Text::Wrap module.

SYNOPSIS
========

     [% USE wrap %]

     # call wrap subroutine
     [% wrap(mytext, width, initial_tab,  subsequent_tab) %]

     # or use wrap FILTER
     [% mytext FILTER wrap(width, initital_tab, subsequent_tab) %]

DESCRIPTION
===========

   This plugin provides an interface to the Text::Wrap module which
provides simple paragraph formatting.

   It defines a 'wrap' subroutine which can be called, passing the input
text and further optional parameters to specify the page width (default:
72), and tab characters for the first and subsequent lines (no defaults).

     [% USE wrap %]

     [% text = BLOCK %]
     First, attach the transmutex multiplier to the cross-wired
     quantum homogeniser.
     [% END %]

     [% wrap(text, 40, '* ', '  ') %]

   Output:

     * First, attach the transmutex
       multiplier to the cross-wired quantum
       homogeniser.

   It also registers a 'wrap' filter which accepts the same three optional
arguments but takes the input text directly via the filter input.

     [% FILTER bullet = wrap(40, '* ', '  ') -%]
     First, attach the transmutex multiplier to the cross-wired quantum
     homogeniser.
     [%- END %]

     [% FILTER bullet -%]
     Then remodulate the shield to match the harmonic frequency, taking
     care to correct the phase difference.
     [% END %]

   Output:

     * First, attach the transmutex
       multiplier to the cross-wired quantum
       homogeniser.

     * Then remodulate the shield to match
       the harmonic frequency, taking
       care to correct the phase difference.

AUTHOR
======

   Andy Wardley <kfs.org>

   The Text::Wrap module was written by David Muir Sharnoff
<muir@idiom.com> with help from Tim Pierce and many others.

REVISION
========

   $Revision: 2.1 $

COPYRIGHT
=========

   Copyright (C) 1996-2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Template::Plugin|Template::Plugin' in this node,
`Text::Wrap|Text::Wrap' in this node


File: pm.info,  Node: Template/Plugin/XML/DOM,  Next: Template/Plugin/XML/RSS,  Prev: Template/Plugin/Wrap,  Up: Module List

simple Template Toolkit plugin interfacing to the XML::DOM module
*****************************************************************

NAME
====

   Template::Plugin::XML::DOM - simple Template Toolkit plugin interfacing
to the XML::DOM module

SYNOPSIS
========

     [% USE doc = XML.DOM('/path/to/file.xml') %]

     # print all HREF attributes of all CODEBASE elements
     [% FOREACH node = doc.getElementsByTagName('CODEBASE') %]
        * [% s.getAttribute('href') %]     # or just '[% s.href %]'
     [% END %]

     # see XML::DOM docs for other methods provided by this object

PRE-REQUISITES
==============

   This plugin requires that the XML::Parser and XML::DOM modules be
installed.  These are available from CPAN:

     http://www.cpan.org/modules/by-module/XML

DESCRIPTION
===========

   This is a very simple Template Toolkit Plugin interface to the XML::DOM
module.   The plugin loads the XML::DOM module, instantiates a parser and
parser the file passed by name as a parameter.  An XML::DOM::Node object
is returned through which the XML document can be traverse.  See *Note
XML/DOM: XML/DOM, for full details.

     [% USE dom = XML.DOM('myxmlfile') %]

   The constructor will also accept configuration options destined for the
XML::Parser.

     [% USE dom = XML.DOM('myxmlfile',
     			  ProtocolEncoding => 'ISO-8859-1') %]

   This plugin also provides an AUTOLOAD method for XML::DOM::Node which
calls getAttribute() for any undefined methods.  Thus, you can use the
short form of

     [% node.attribute %]

   in place of

     [% node.getAttribute('attribute') %]

AUTHOR
======

   This plugin module was written by Andy Wardley <cre.canon.co.uk>.

   The XML::DOM module is by Enno Derksen <enno@att.com> and Clark Cooper
<coopercl@sch.ge.com>.  It extends the the XML::Parser module, also by
Clark Cooper which itself is built on James Clark's expat library.

REVISION
========

   $Revision: 2.1 $

COPYRIGHT
=========

   Copyright (C) 2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `XML::DOM|XML::DOM' in this node, `XML::Parser|XML::Parser' in this
node, `Template::Plugin|Template::Plugin' in this node,


File: pm.info,  Node: Template/Plugin/XML/RSS,  Next: Template/Plugin/XML/XPath,  Prev: Template/Plugin/XML/DOM,  Up: Module List

Template Toolkit plugin to the XML::RSS module
**********************************************

NAME
====

   Template::Plugin::XML::RSS - Template Toolkit plugin to the XML::RSS
module

SYNOPSIS
========

     [% USE news = XML.RSS($filename) %]
     
     [% FOREACH item = news.items %]
        [% item.title %]
        [% item.link  %]
     [% END %]

PRE-REQUISITES
==============

   This plugin requires that the XML::Parser and XML::RSS modules be
installed.  These are available from CPAN:

     http://www.cpan.org/modules/by-module/XML

DESCRIPTION
===========

   This Template Toolkit plugin provides a simple interface to the
XML::RSS module.

     [% USE news = XML.RSS('mysite.rdf') %]

   It creates an XML::RSS object, which is then used to parse the RSS file
specified as a parameter in the USE directive.  A reference to the
XML::RSS object is then returned.

   An RSS (Rich Site Summary) file is typically used to store short news
'headlines' describing different links within a site.  This example is
extracted from http://slashdot.org/slashdot.rdf.

     <?xml version="1.0"?><rdf:RDF
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns="http://my.netscape.com/rdf/simple/0.9/">
     
       <channel>
     	<title>Slashdot:News for Nerds. Stuff that Matters.</title>
     	<link>http://slashdot.org</link>
     	<description>News for Nerds.  Stuff that Matters</description>
       </channel>
     
       <image>
     	<title>Slashdot</title>
     	<url>http://slashdot.org/images/slashdotlg.gif</url>
     	<link>http://slashdot.org</link>
       </image>
     
       <item>
     	<title>DVD CCA Battle Continues Next Week</title>
     	<link>http://slashdot.org/article.pl?sid=00/01/12/2051208</link>
       </item>
     
       <item>
     	<title>Matrox to fund DRI Development</title>
     	<link>http://slashdot.org/article.pl?sid=00/01/13/0718219</link>
       </item>
     
       <item>
     	<title>Mike Shaver Leaving Netscape</title>
     	<link>http://slashdot.org/article.pl?sid=00/01/13/0711258</link>
       </item>
     
     </rdf:RDF>

   The attributes of the channel and image elements can be retrieved
directly from the plugin object using the familiar dotted compound
notation:

     [% news.channel.title  %]
     [% news.channel.link   %]
     [% news.channel.etc... %]

     [% news.image.title    %]
     [% news.image.url      %]
     [% news.image.link     %]
     [% news.image.etc...   %]

   The list of news items can be retrieved using the 'items' method:

     [% FOREACH item = news.items %]
        [% item.title %]
        [% item.link  %]
     [% END %]

AUTHOR
======

   Andy Wardley <cre.canon.co.uk>

CREDITS
=======

   The XML::RSS module, which implements all of the functionality that
this plugin delegates to, was written by Jonathan Eisenzopf
<eisen@pobox.com>.

   This plugin was inspired by an article in Web Techniques by Randal
Schwartz <merlyn@stonehenge.com>.

REVISION
========

   $Revision: 2.0 $

COPYRIGHT
=========

   Copyright (C) 2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `XML::RSS|XML::RSS' in this node,  `Template::Plugin|Template::Plugin'
in this node,


File: pm.info,  Node: Template/Plugin/XML/XPath,  Next: Template/Plugins,  Prev: Template/Plugin/XML/RSS,  Up: Module List

Template Toolkit plugin to the XML::XPath module
************************************************

NAME
====

   Template::Plugin::XML::XPath - Template Toolkit plugin to the
XML::XPath module

SYNOPSIS
========

     # load plugin and specify XML file to parse
     [% USE xpath = XML.XPath(xmlfile) %]
     [% USE xpath = XML.XPath(file => xmlfile) %]
     [% USE xpath = XML.XPath(filename => xmlfile) %]

     # load plugin and specify XML text to parse
     [% USE xpath = XML.XPath(xmltext) %]
     [% USE xpath = XML.XPath(xml => xmltext) %]
     [% USE xpath = XML.XPath(text => xmltext) %]

     # then call any XPath methods (see XML::XPath docs)
     [% FOREACH page = xpath.findnodes('/html/body/page') %]
        [% page.getAttribute('title') %]
     [% END %]

PRE-REQUISITES
==============

   This plugin requires that the XML::Parser and XML::XPath modules be
installed.  These are available from CPAN:

     http://www.cpan.org/modules/by-module/XML

DESCRIPTION
===========

   This is a Template Toolkit plugin interfacing to the XML::XPath module.
=head1 AUTHOR

   This plugin module was written by Andy Wardley <abw@kfs.org>.

   The XML::XPath module is by Matt Sergeant <matt@sergeant.org<gt>.

REVISION
========

   $Revision: 2.1 $

COPYRIGHT
=========

   Copyright (C) 2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   For further information see *Note XML/XPath: XML/XPath,, *Note
XML/Parser: XML/Parser, and *Note Template/Plugin: Template/Plugin,.


File: pm.info,  Node: Template/Plugins,  Next: Template/Provider,  Prev: Template/Plugin/XML/XPath,  Up: Module List

provider module for loading and instantiating plugins
*****************************************************

NAME
====

   Template::Plugins - provider module for loading and instantiating
plugins

SYNOPSIS
========

     use Template::Plugins;

     $plugin_provider = Template::Plugins->new(\%options);

     ($plugin, $error) = $plugin_provider->fetch($name, @args);

DESCRIPTION
===========

   The Template::Plugins module defines a provider class which can be used
to load and instantiate Template Toolkit plugin modules.

METHODS
=======

new(\%params)
-------------

   Constructor method which instantiates and returns a reference to a
Template::Plugins object.  A reference to a hash array of configuration
items may be passed as a parameter.  These are described below.

   Note that the Template.pm front-end module creates a Template::Plugins
provider, passing all configuration items.  Thus, the examples shown below
in the form:

     $plugprov = Template::Plugins->new({
     	PLUGIN_BASE => 'MyTemplate::Plugin',
         LOAD_PERL   => 1,
     	...
     });

   can also be used via the Template module as:

     $ttengine = Template->new({
     	PLUGIN_BASE => 'MyTemplate::Plugin',
         LOAD_PERL   => 1,
     	...
     });

   as well as the more explicit form of:

     $plugprov = Template::Plugins->new({
     	PLUGIN_BASE => 'MyTemplate::Plugin',
         LOAD_PERL   => 1,
     	...
     });

     $ttengine = Template->new({
     	LOAD_PLUGINS => [ $plugprov ],
     });

fetch($name, @args)
-------------------

   Called to request that a plugin of a given name be provided.  The
relevant module is first loaded (if necessary) and the load() class method
called to return the factory class name (usually the same package name) or
a factory object (a prototype).  The new() method is then called as a
class or object method against the factory, passing all remaining
parameters.

   Returns a reference to a new plugin object or ($error, STATUS_ERROR) on
error.  May also return (undef, STATUS_DECLINED) to decline to serve the
request.  If TOLERANT is set then all errors will be returned as declines.

CONFIGURATION OPTIONS
=====================

   The following list details the configuration options that can be
provided to the Template::Plugins new() constructor.

PLUGINS
     The PLUGINS options can be used to provide a reference to a hash array
     that maps plugin names to Perl module names.  A number of standard
     plugins are defined (e.g. 'table', 'cgi', 'dbi', etc.) which map to
     their corresponding Template::Plugin::* couterpart.  These can be
     redefined by values in the PLUGINS hash.

          my $plugins = Template::Plugins->new({
          	PLUGINS => [
          	    cgi => 'MyOrg::Template::Plugin::CGI',
          	    foo => 'MyOrg::Template::Plugin::Foo',
          	    bar => 'MyOrg::Template::Plugin::Bar',
          	],
          });

     The USE directive is used to create plugin objects and does so by
     calling the plugin() method on the current Template::Context object.
     If the plugin name is defined in the PLUGINS hash then the
     corresponding Perl module is loaded via require().  The context then
     calls the load() class method which should return the class name
     (default and general case) or a prototype object against which the
     new() method can be called to instantiate individual plugin objects.

     If the plugin name is not defined in the PLUGINS hash then the
     PLUGIN_BASE and/or LOAD_PERL options come into effect.

PLUGIN_BASE
     If a plugin is not defined in the PLUGINS hash then the PLUGIN_BASE
     is used to attempt to construct a correct Perl module name which can
     be successfully loaded.

     The PLUGIN_BASE can be specified as a single value or as a reference
     to an array of multiple values.  The default PLUGIN_BASE value,
     'Template::Plugin', is always added the the end of the PLUGIN_BASE
     list (a single value is first converted to a list).  Each value should
     contain a Perl package name to which the requested plugin name is
     appended.

     example 1:

          my $plugins = Template::Plugins->new({
          	PLUGIN_BASE => 'MyOrg::Template::Plugin',
          });

          [% USE Foo %]    # => MyOrg::Template::Plugin::Foo
                             or        Template::Plugin::Foo

     example 2:

          my $plugins = Template::Plugins->new({
          	PLUGIN_BASE => [   'MyOrg::Template::Plugin',
          			 'YourOrg::Template::Plugin'  ],
          });

          [% USE Foo %]    # =>   MyOrg::Template::Plugin::Foo
                             or YourOrg::Template::Plugin::Foo
                             or          Template::Plugin::Foo

LOAD_PERL
     If a plugin cannot be loaded using the PLUGINS or PLUGIN_BASE
     approaches then the provider can make a final attempt to load the
     module without prepending any prefix to the module path.  This allows
     regular Perl modules (i.e. those that don't reside in the
     Template::Plugin or some other such namespace) to be loaded and used
     as plugins.

     By default, the LOAD_PERL option is set to 0 and no attempt will be
     made to load any Perl modules that aren't named explicitly in the
     PLUGINS hash or reside in a package as named by one of the PLUGIN_BASE
     components.

     Plugins loaded using the PLUGINS or PLUGIN_BASE receive a reference to
     the current context object as the first argument to the new()
     constructor.  Modules loaded using LOAD_PERL are assumed to not
     conform to the plugin interface.  They must provide a new() class
     method for instantiating objects but it will not receive a reference
     to the context as the first argument.  Plugin modules should provide a
     load() class method (or inherit the default one from the
     Template::Plugin base class) which is called the first time the plugin
     is loaded.  Regular Perl modules need not.  In all other respects,
     regular Perl objects and Template Toolkit plugins are identical.

     If a particular Perl module does not conform to the common, but not
     unilateral, new() constructor convention then a simple plugin wrapper
     can be written to interface to it.

TOLERANT
     The TOLERANT flag is used by the various Template Toolkit provider
     modules (Template::Provider, Template::Plugins, Template::Filters) to
     control their behaviour when errors are encountered.  By default, any
     errors are reported as such, with the request for the particular
     resource (template, plugin, filter) being denied and an exception
     raised.  When the TOLERANT flag is set to any true values, errors will
     be silently ignored and the provider will instead return
     STATUS_DECLINED.  This allows a subsequent provider to take
     responsibility for providing the resource, rather than failing the
     request outright.  If all providers decline to service the request,
     either through tolerated failure or a genuine disinclination to
     comply, then a '<resource> not found' exception is raised.

TEMPLATE TOOLKIT PLUGINS
========================

   The following plugin modules are distributed with the Template Toolkit.

Date
     The Date plugin provides an easy way to generate formatted time and
     date strings by delegating to the POSIX strftime() routine.   See
     *Note Template/Plugin/Date: Template/Plugin/Date, for further details.

          [% USE date %]
          [% date.format %]		# current time/date

          File last modified: [% date.format(template.modtime) %]

Format
     The Format plugin provides a simple way to format text according to a
     printf()-like format.   See *Note Template/Plugin/Format:
     Template/Plugin/Format, for further details.

          [% USE bold = format('<b>%s</b>') %]
          [% bold('Hello') %]

URL
     The URL plugin provides a simple way of contructing URLs from a base
     part and a variable set of parameters.  See *Note
     Template/Plugin/URL: Template/Plugin/URL, for further details.

          [% USE mycgi = url('/cgi-bin/bar.pl', debug=1) %]

          [% mycgi %]
             # ==> /cgi/bin/bar.pl?debug=1

          [% mycgi(mode='submit') %]
             # ==> /cgi/bin/bar.pl?mode=submit&debug=1

Table
     The Table plugin allows you to format a list of data items into a
     virtual table by specifying a fixed number of rows or columns, with
     an optional overlap.  See *Note Template/Plugin/Table:
     Template/Plugin/Table, for further details.

          [% USE table(list, rows=10, overlap=1) %]

          [% FOREACH item = table.col(3) %]
             [% item %]
          [% END %]

CGI
     The CGI plugin is a wrapper around Lincoln Stein's
     <lstein@genome.wi.mit.edu> CGI.pm module.  The plugin is distributed
     with the Template Toolkit (see *Note Template/Plugin/CGI:
     Template/Plugin/CGI,) and the CGI module itself is distributed with
     recent versions Perl, or is available from CPAN.

Datafile
     Provides an interface to data stored in a plain text file in a simple
     delimited format.  The first line in the file specifies field names
     and subsequent lines contain data, delimited by the same non-word
     character as the fields in the first line.  Blank lines and comments
     (lines starting '#' are ignored).   See *Note
     Template/Plugin/Datafile: Template/Plugin/Datafile, for further
     details.

     /tmp/mydata:

          # define names for each field
          id : email : name : tel
          # here's the data
          fred : fred@here.com : Fred Smith : 555-1234
          bill : bill@here.com : Bill White : 555-5678

     example:

          [% USE userlist = datafile('/tmp/mydata') %]

          [% FOREACH user = userlist %]
             [% user.name %] ([% user.id %])
          [% END %]

XML::DOM
     The XML::DOM plugin gives access to the XML Document Object Module via
     Clark Cooper <cooper@sch.ge.com> and Enno Derksen's <enno@att.com>
     XML::DOM module.  The plugin is distributed with the Template Toolkit
     (see *Note Template/Plugin/XML/DOM: Template/Plugin/XML/DOM,) and
     requires the XML::DOM module, available from CPAN:

          http://www.cpan.org/modules/by-module/XML

XML::RSS
     The XML::RSS plugin is a simple interface to Jonathan Eisenzopf's
     <eisen@pobox.com> XML::RSS module.  An RSS (Rich Site Summary) file
     is typically used to store short news 'headlines' describing
     different links within a site.  This plugin allows you to parse RSS
     files and format the contents accordingly using templates.  The
     plugin is distributed with the Template Toolkit (see *Note
     Template/Plugin/XML/RSS: Template/Plugin/XML/RSS,) and requires the
     XML::RSS module, also available from CPAN:

          http://www.cpan.org/modules/by-module/XML

   The following module is distributed separately from the Template
Toolkit.

DBI
     Simon Matthews <sam@knowledgepool.com> has developed a DBI plugin for
     the Template Toolkit which brings the full power of Tim Bunce's
     <Tim.Bunce@ig.co.uk> database interface module (DBI) to your
     templates.  The DBI plugin and the DBI modules themselves are
     available from CPAN at:

          http://www.cpan.org/modules/by-module/Template/
          http://www.cpan.org/modules/by-module/DBI/

BUGS / ISSUES
=============

   * It might be worthwhile being able to distinguish between absolute
     module names and those which should be applied relative to PLUGIN_BASE
     directories.  For example, use 'MyNamespace::MyModule' to denote
     absolute module names (e.g. LOAD_PERL), and 'MyNamespace.MyModule' to
     denote relative to PLUGIN_BASE.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

     http://www.template-toolkit.org/
     http://www.kfs.org/~abw/

REVISION
========

   $Revision: 1.1 $

COPYRIGHT
=========

     Copyright (C) 1996-2000 Andy Wardley.  All Rights Reserved.
     Copyright (C) 1998-2000 Canon Research Centre Europe Ltd.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Template|Template' in this node, `Template::Plugin|Template::Plugin'
in this node, L<Template::Context|Template::Context


File: pm.info,  Node: Template/Provider,  Next: Template/Service,  Prev: Template/Plugins,  Up: Module List

repository for compiled templates, loaded from disk.
****************************************************

NAME
====

   Template::Provider - repository for compiled templates, loaded from
disk.

SYNOPSIS
========

     $provider = Template::Provider->new(\%options);

     ($template, $error) = $provider->fetch($name);

DESCRIPTION
===========

   The Template::Provider is used to load, parse, compile and cache
template documents.  This object may be sub-classed to provide more
specific facilities for loading, or otherwise providing access to
templates.

   The Template::Context objects maintain a list of Template::Provider
objects which are polled in turn (via fetch()) to return a requested
template.  Each may return a compiled template, raise an error, or decline
to serve the reqest, giving subsequent providers a chance to do so.

   This is the "Chain of Responsiblity" pattern.  See 'Design Patterns' for
further information.

   This documentation needs work.

PUBLIC METHODS
==============

new(\%options)
--------------

   Constructor method which instantiates and returns a new
Template::Provider object.  The optional parameter may be a hash reference
containing any of the following items:

INCLUDE_PATH
     The INCLUDE_PATH is used to specify one or more directories in which
     template files are located.  When a template is requested that isn't
     defined locally as a BLOCK, each of the INCLUDE_PATH directories is
     searched in turn to locate the template file.  Multiple directories
     can be specified as a reference to a list or as a single string where
     each directory is delimited by ':'. The DELIMITER option can be set
     to redefine the delimiter value.

          my $provider = Template::Provider->new({
              INCLUDE_PATH => '/usr/local/templates',
          });
          
          my $provider = Template::Provider->new({
              INCLUDE_PATH => '/usr/local/templates:/tmp/my/templates',
          });
          
          my $provider = Template::Provider->new({
              INCLUDE_PATH => [ '/usr/local/templates',
                                '/tmp/my/templates' ],
          });

DELIMITER
     Used to provide an alternative delimiter character sequence for
     separating paths specified in the INCLUDE_PATH.  May be useful for
     operating systems that permit the use of ':' in file names.

          # tolerate Silly Billy's file system conventions
          my $provider = Template::Provider->new({
          	DELIMITER    => ' ',
              INCLUDE_PATH => 'C:/HERE/NOW D:/THERE/THEN',
          });

          # better solution: install Linux!  :-)

ABSOLUTE
     The ABSOLUTE flag is used to indicate if templates specified with
     absolute filenames (e.g. '/foo/bar') should be processed.  It is
     disabled by default and any attempt to load a template by such a name
     will cause a 'file' exception to be raised.

          my $provider = Template::Provider->new({
          	ABSOLUTE => 1,
          });

          # this is why it's disabled by default
          [% INSERT /etc/passwd %]

RELATIVE
     The RELATIVE flag is used to indicate if templates specified with
     filenames relative to the current directory (e.g. './foo/bar' or
     '../../some/where/else') should be loaded.  It is also disabled by
     default, and will raise a 'file' error if such template names are
     encountered.

          my $provider = Template::Provider->new({
          	RELATIVE => 1,
          });

          [% INCLUDE ../logs/error.log %]

DEFAULT
     The DEFAULT option can be used to specify a default template which
     should be used whenever a specified template can't be found in the
     INCLUDE_PATH.

          my $provider = Template::Provider->new({
          	DEFAULT => 'notfound.html',
          });

     If a non-existant template is requested through the Template process()
     method, or by an INCLUDE, PROCESS or WRAPPER directive, then the
     DEFAULT template will instead be processed, if defined.  Note that the
     DEFAULT template is not used when templates are specified with
     absolute or relative filenames, or as a reference to a input file
     handle or text string.

CACHE_SIZE
     The Template::Provider module caches compiled templates to avoid the
     need to re-parse template files or blocks each time they are used.
     The CACHE_SIZE option is used to limit the number of compiled
     templates that the module should cache.

     By default, the CACHE_SIZE is undefined and all compiled templates are
     cached.  When set to any positive value, the cache will be limited to
     storing that many compiled templates.  When a new template is loaded
     and compiled and the cache is full (i.e. the number of entries ==
     CACHE_SIZE), the least recently used compiled template is discarded
     to make room for the new one.

     The CACHE_SIZE can be set to 0 to disable caching altogether.

          my $provider = Template::Provider->new({
          	CACHE_SIZE => 64,   # only cache 64 compiled templates
          });

          my $provider = Template::Provider->new({
          	CACHE_SIZE => 0,   # don't cache any compiled templates
          });

COMPILE_EXT
     From version 2 onwards, the Template Toolkit has the ability to
     compile templates to Perl code and save them to disk for subsequent
     use (e.g. cache persistance).  The COMPILE_EXT option may be provided
     to specify a filename extension for compiled template files.  It is
     undefined by default and no attempt will be made to read or write any
     compiled template file.

          my $provider = Template::Provider->new({
          	COMPILE_EXT => '.ttc',
          });

     If COMPILE_EXT is defined (and COMPILE_DIR isn't, see below) then
     compiled template files with the COMPILE_EXT extension will be
     written to the same directory from which the source template files
     were loaded.

     Compiling and subsequent reuse of templates happens automatically
     whenever the COMPILE_EXT or COMPILE_DIR options are set.  The Template
     Toolkit will automatically reload and reuse compiled files when it
     finds them on disk.  If the corresponding source file has been
     modified since the compiled version as written, then it will load and
     re-compile the source and write a new compiled version to disk.

     This form of cache persistance offers significant benefits in terms of
     time and resources required to reload templates.  Compiled templates
     can be reloaded by a simple call to Perl's require(), leaving Perl to
     handle all the parsing and compilation.  This is a Good Thing.

COMPILE_DIR
     The COMPILE_DIR option is used to specify an alternate directory root
     under which compiled template files should be saved.

          my $provider = Template::Provider->new({
          	COMPILE_DIR => '/tmp/ttc',
          });

     The COMPILE_EXT option may also be specified to have a consistent file
     extension added to these files.

          my $provider1 = Template::Provider->new({
          	COMPILE_DIR => '/tmp/ttc',
          	COMPILE_EXT => '.ttc1',
          });

          my $provider2 = Template::Provider->new({
          	COMPILE_DIR => '/tmp/ttc',
          	COMPILE_EXT => '.ttc2',
          });

     When COMPILE_EXT is undefined, the compiled template files have the
     same name as the original template files, but reside in a different
     directory tree.

     Each directory in the INCLUDE_PATH is replicated in full beneath the
     COMPILE_DIR directory.  This example:

          my $provider = Template::Provider->new({
          	COMPILE_DIR  => '/tmp/ttc',
          	INCLUDE_PATH => '/home/abw/templates:/usr/share/templates',
          });

     would create the following directory structure:

          /tmp/ttc/home/abw/templates/
          /tmp/ttc/usr/share/templates/

     Files loaded from different INCLUDE_PATH directories will have their
     compiled forms save in the relevant COMPILE_DIR directory.

TOLERANT
     The TOLERANT flag is used by the various Template Toolkit provider
     modules (Template::Provider, Template::Plugins, Template::Filters) to
     control their behaviour when errors are encountered.  By default, any
     errors are reported as such, with the request for the particular
     resource (template, plugin, filter) being denied and an exception
     raised.  When the TOLERANT flag is set to any true values, errors will
     be silently ignored and the provider will instead return
     STATUS_DECLINED.  This allows a subsequent provider to take
     responsibility for providing the resource, rather than failing the
     request outright.  If all providers decline to service the request,
     either through tolerated failure or a genuine disinclination to
     comply, then a '<resource> not found' exception is raised.

PARSER
     The Template::Parser module implements a parser object for compiling
     templates into Perl code which can then be executed.  A default object
     of this class is created automatically and then used by the
     Template::Provider whenever a template is loaded and requires
     compilation.  The PARSER option can be used to provide a reference to
     an alternate parser object.

          my $provider = Template::Provider->new({
          	PARSER => MyOrg::Template::Parser->new({ ... }),
          });

fetch($name)
------------

   Returns a compiled template for the name specified.  If the template
cannot be found then (undef, STATUS_DECLINED) is returned.  If an error
occurs (e.g. read error, parse error) then ($error, STATUS_ERROR) is
returned, where $error is the error message generated.  If the TOLERANT
flag is set the the method returns (undef, STATUS_DECLINED) instead of
returning an error.

store($name, $template)
-----------------------

   Stores the compiled template, $template, in the cache under the name,
$name.  Susbequent calls to fetch($name) will return this template in
preference to any disk-based file.

include_path(\@newpath))
------------------------

   Accessor method for the INCLUDE_PATH setting.  If called with an
argument, this method will replace the existing INCLUDE_PATH with the new
value.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

     http://www.template-toolkit.org/
     http://www.kfs.org/~abw/

REVISION
========

   $Revision: 1.1 $

COPYRIGHT
=========

     Copyright (C) 1996-2000 Andy Wardley.  All Rights Reserved.
     Copyright (C) 1998-2000 Canon Research Centre Europe Ltd.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   L<Template|Template


