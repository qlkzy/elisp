This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: File/MkTemp,  Next: File/MkTempO,  Prev: File/MMagic,  Up: Module List

Make temporary filename from template
*************************************

NAME
====

   File::MkTemp - Make temporary filename from template

SYNOPSIS
========

     use File::MkTemp;

     mktemp(tempXXXXXX,[dir]);

     $string = mktemp(tempXXXXXX,[dir]);
     open(F,$string);

     mkstemp(tempXXXXXX,dir);

     $fh = mkstemp(tempXXXXXX,dir);
     print $fh "stuff";
     $fh->close;

     mkstempt(tempXXXXXX,dir);

     ($fh,$template) = mkstempt(tempXXXXXX,dir);
     print $fh "stuff";
     $fh->close;
     print "Template is: $template\n";

DESCRIPTION
===========

   The MkTemp module provides three functions mktemp() mkstemp() and
mkstempt().

   The function mktemp() returns a unique string based upon the template.
The template must contain at least six trailing Xs.  The Xs are replaced
by a unique string and the template is returned.  The unique string is
made from picking random elements out of a 52 alpha character array
([a-z][A-Z]).  A directory can be specified in which to test for
duplicates of the string.

   The function mkstemp() does the same as mktemp() except it returns an
open file handle.  This prevents any possibility of opening up an
identical file.  The function requires that the directory be specified.

   The function mkstempt() does the same as mkstemp() except it returns
the name of the template in addition to the file handle.

AUTHOR
======

   File::MkTemp was written by Travis Gummels.  Please send bug reports
and or comments to: travis@gummels.com

COPYRIGHT
=========

   Copyright 1999|2000 Travis Gummels.  All rights reserved.  This may be
used and modified however you want.  If you redistribute after making
modifications please note modifications you made somewhere in the
distribution and notify the author.


File: pm.info,  Node: File/MkTempO,  Next: File/MultiTail,  Prev: File/MkTemp,  Up: Module List

Make temporary filename from template
*************************************

NAME
====

   File::MkTempO - Make temporary filename from template

SYNOPSIS
========

     use File::MkTempO;

     $object = new File::MkTempO('tempXXXXXX','dir');

     $string = $object->mktemp;
     open(F,$string);
     close(<F>);

     $fh = $object->mkstemp;
     print $fh "stuff";
     $fh->close;

     print "template stored in the object: $object->template\n";
     print "directory stored in the object: $object->dir\n";
     print "file handle in scalar form: $object->fhtmpl\n";
     print "fh and the directory in scalar form: $object->fhdirtmpl\n";

DESCRIPTION
===========

   The MkTempO module provides the following functions:

     new()      - for creation of the object.
     mktemp()   - for creation of a unique string based on the template
     mkstemp()  - for creation of a unique file handle opened in the
                  directory specified during creation of the object.
     template() - for returning the template stored in the object.
     dir()      - for returning the directory stored in the object.
     fhtmpl()   - for returning the file handle in scalar form.
     fhdirtmpl()- for returning the file handle and the directory its in.

   The function mktemp() returns a unique string based upon the template.
The template must contain at least six trailing Xs.  The Xs are replaced
by a unique string and the template is returned.  The unique string is
made from picking random elements out of a 52 alpha character array
([a-z][A-Z]).  A directory can be specified in which to test for
duplicates of the string.

   The function mkstemp() does the same as mktemp() except it returns an
open file handle.  This prevents any possibility of opening up an
identical file.  The function requires that the directory be specified
when creating the object with the new function.

AUTHOR
======

   File::MkTemp was written by Travis Gummels.  Please send bug reports
and or comments to: travis@gummels.com

COPYRIGHT
=========

   Copyright 1999|2000 Travis Gummels.  All rights reserved.  This may be
used and modified however you want.  If you redistribute after making
modifications please note modifications you made somewhere in the
distribution.


File: pm.info,  Node: File/MultiTail,  Next: File/NCopy,  Prev: File/MkTempO,  Up: Module List

Tail multiple files for Unix systems
************************************

NAME
====

     MultiTail - Tail multiple files for Unix systems

SYNOPSIS
========

     use File::MultiTail;

DESCRIPTION
===========

     This perl library uses perl5 objects to make it easy to
     tail a dynamic list of files and match/except lines using full
     regular expressions.

   File::MultiTail;

     will tail multiple files and return the records
     read to a Data Structure. The Data Structure can
     be processed by MultiTail functions

   The  files  specified  are processed in accordance with the following
rules:

   Note: File devices and inode number uniquely identify each entry in the
UNIX filesystem. If the stat() command shows them to be the same, then
only one will be used. Windows NT filesystem NTFS does not allow links so
I don't check for links on NT.

   (1) Files that exist at program start  time  will  be     positioned to
Object attribute "NumLines" before input.

   (2) Files that become available subsequently  will  be  read     from
the beginning. Attribute ScanForFiles must be set to     True (>=1) for
the option.

   (3) If a file that has been selected as per rules 1 or 2  is
deleted  or  truncated input will continue until end-of-file     is
reached before the file is closed.

   (4) If a file is deleted and  it is recreated it     is treated as a
new file, will  be  read     from the beginning

   (5) To conserve file descriptors, files that are selected for     input
are  not actually opened until data is present beyond     the input point
selected.  For example,     if a file exists when ptail starts, ptail will
determine the     file mtime at that time and only open the file when the
mtime     increases.

     Note: mtime = Time when data was last modified. Changed by  the
                   following functions: creat, mknod, pipe, utime,
                   and write.

   (6) If an opened file has not been updated for MultiTail Object
attribute     "MaxAge" minutes it will be closed.      It will be reopened
if it is later updated.

   (7) Since MultiTail is OO you can alway change its attributes. If you
change     the list of file to be tailed (Files attribute) the attribute
 ScanForFiles will set to true and all dir and files ilists will be
check for new files.

METHODS
=======

   new

   Creating a new PTAIL object

   $tail = File::MultiTail->new( 				OutputPrefix => 'tf',
RemoveDuplicate => $True,             Files =>
['/var/log','/var/adm/*.log'] );

   Or

   $tail = File::MultiTail->new;
$tail->Files(['/var/log','/var/adm/*.log']); $tail->RemoveDuplicate($True);

     class/object method takes arguments ( All have defaults )
     and returning a reference to a newly created MultiTail object.

     File     :  File attribute accepts file names that includes
     	both explicit  file/dir  names  and  file/dir expressions.
     	Duplicate  file  paths  are rejected, along with non-duplicate
        names  that  resolve to  a  device/inode combination that is
     	currently being read. NT file name must start with drive letter
        or //.
     
     Pattern  :  Arguments can be a file name or an array of patterns
         Stores in object attribute  "LineArray" all lines
         that contain the patterns
     	(Default is *)

     ExceptPattern : Arguments can be a file name or an array of patterns
     	Stores in object attribute  "LineArray" all lines except
     	those that contain the patterns
     	(Default is *)

     MaxAge  : Maximum time in minute that an open file will be held open
     	without an update.
     	(Default is 10 minute)

     NumLines : Files that exist at MultiTail start time will have up to
     	NumLines lines from the end of file displayed.
     	Similar to tail -NumLines.
     	(Default is 10)

     Fuction  : Reference to a function that will be run by the MultiTail
         object.
         MultiTail object will pass a ref array of all the lines read from
         the files and passed through any filters you set in the object
     		 to the function.
     	0 = (Default) No Fuction

     ScanForFiles : Maximum time in minute before Read will scan for new
     				 files.
     	If you change the attribute "Files" with fuction update_attribute
         the next Read will scan for new files.
     	0 = (Default) Off

     RemoveDuplicate : Removes all duplicate lines from LineArray
     	0 = (Default) Off
     	1 = On

     : Turn Debuging messages on for MultiTail.pm.
     	0 = (Default) Off
     	1 = On

     OutputPrefix : Determines the prefix applied to each output record.
     	Output records are store in MultiTail object attribute "LineArray"
         The prefix is separated from the record by ': '.
         Prefixes supported are:
     		       p  : path name of the input file
     		       f  : file name of the input file
     		       t  : time in HHMMSS
     		       tg : time in HHMMSS GMT
     		       tc : time in MM/DD/YYYY HH:MM:SS
     		       pt : path and time
     		       ptg: path and time GMT
     		       ptc: path and time complete
     		       ft : file and time
     		       ftg: file and time GMT
     		       ftc: file and time complete
     		       tp : time and path
     		       tpg: time and path GMT
     		       tpc: time complete and path
     		       tf : time and file
     		       tfg: time and file GMT
     		       tfc: time complete and file
     	0 = (Default) No prefix
     	GMT = Greenwich time ZONE

     Exit Codes

     1001 - MaxAge is less the zero
     1002 - NumLines is less the zero
     1003 - OutputPrefix must one ( )
     1004 - Pattern must is not a file or ARRAY
     1005 - ExceptPattern is not a file or ARRAY
     1006 - Debug is not 0 or 1
     1007 - ScanForFiles is less the zero
     1008 - RemoveDuplicate is not 0 or 1
     1009 - Function is not ref to fuction
     1010 - File attribute not set

read
     Read all new data from file

     $tail->read

     Read all new date from tailed files and return new lines as part of
     the Data Structure (MultiTail Object attribute LineArray)

print
     Print all line contained in MultiTail Object attribute LineArray

     $tail->print

update_attribute
     Allow you to Update (Change) any MultiTail Object attribute

     $tail->update_attribute( 	Files =>
     ["/var/log","/var/adm","/home/nnysgm/logwatcher/foo*"],
     ExceptPattern => /home/nnysgm/ExceptPattern.txt, 	RemoveDuplicate =>
     $True 	);

     This changes the Files, ExceptPattern and RemoveDuplicate attributes
     for the Object $tail.

     New files will be scanned for during next Read if "Files" attribute is
     changed.

     Also you can use supplied methods to set attribute values.

     $tail->RemoveDuplicate($True); $tail->NumLines(100);

version
     Return version number on PTAIL package

     $tail->version

debug
     Toggle the debug switch for MultiTail package

     $tail->debug

          There are a number of  function in the MultiTail.pm module.
          
          	o printstat :
          		Print out stat output for each file.
          	o printfilestates :
          		Print out All file states.
          		(See note in MultiTail.pm for function OpenUpdateFiles)
          	o printpat :
          		Print out lines from pattern file array.
          	o printexceptpat :
          		Print out line from pattern file except array.

close_all_files
     Closes all file that are being tailed

     $tail->close_all_files

EXAMPLE
=======

   1) 	use File::MultiTail;

     $tail1=File::MultiTail->new (  OutputPrefix => "f",
                           Debug => "$True",
                           Files => ["/var/adm/messages"]
     );

     while(1) {
     	$tail1->read;
     	#
     	$tail1->print;
     	sleep 10;
     }

   $tail1=MultiTail->new : Create new ptail object

   - Files => Tail file /var/adm/messages

   - OutputPrefix => Prepend the name of the file beginning of each   line
in object attribute  "LineArray"

   $tail1->read      : Read all line from files

   $tail1->print     : Print all line in object attribute  "LineArray";

   2) 	use File::MultiTail;

     $tail1=File::MultiTail->new (  OutputPrefix => "tf",
     	      Pattern => "/home/nnysgm/logwatcher/pattern",
     	      ExceptPattern => "/home/nnysgm/logwatcher/epattern",
     	      Fuction = > \&want,
                 Files => ["/var/adm","/var/log/*.log"]
     );

     while(1) {
     	$tail1->read;
     	#
     	$tail1->print;
     	sleep 10;
     }
     
     sub want {
     		(your code .... );
     }

   $tail1=File::MultiTail->new : Create new ptail object

   - OutputPrefix => Prepend the name of the file and time to the
beginning of each line in object attribute  "LineArray"

   - ExceptPattern => Stores in object attribute  "LineArray" all lines
except   those that contain the patterns from file "epattern" - Pattern =>
Stores in object attribute  "LineArray" all lines   that contain the
patterns from file "pattern"

   - Fuction => ref to a function that will be run by MultiTail object.
MultiTail object will pass a ref array to the function of all the lines
read from   the file and passed through any filters you set in the object.

   - Files => Tail all files in dir /var/adm and all .log files   dir
/var/log.

   $tail1->read      : Read all line from files

   $tail1->print     : Print all line in object attribute  "LineArray";

   3)    use File::MultiTail;

   $tail=File::MultiTail->new;

     $tail->OutputPrefix(tf);
        $tail->Fuction(\&want);
        $tail->Files(["/var/adm","/var/log/*.log"]);
     
        while(1) {
           $tail1->read;
        }
     
        sub want {
              (your code .... );
        }

AUTHOR
======

   Stephen Miano, smiano@mindspring.com

SEE ALSO   perl(1).
===================


File: pm.info,  Node: File/NCopy,  Next: File/Path,  Prev: File/MultiTail,  Up: Module List

Copy file, file               Copy file[s] | dir[s], dir
********************************************************

NAME
====

   *File::NCopy* - Copy file, file               Copy file[s] | dir[s], dir

SYNOPSIS
========

     use File::NCopy qw(copy);

     copy "file","other_file";
     copy "file1","file2","file3","directory";

     # we want to copy the directory recursively
     copy \1,"directory1","directory2";
     copy \1,"file1","file2","directory1","file3","directory2","file4",
         "directory";

     # can also use references to file handles, this is for backward
     # compatibility with File::Copy
     copy \*FILE1,\*FILE2;
     copy \*FILE1,"file";
     copy "file1",\*FILE2;

     # we don't specify \1 as the first argument because we don't want to
     # copy directories recursively
     copy "*.c","*.pl","programs";
     copy "*", "backup";

     use File::NCopy;

     # the below are the default config values
     $file = File::NCopy->new(
             'recursive'      => 0,
             'preserve'       => 0,
             'follow_links'   => 0,
             'force_write'   => 0,
             'set_permission' => \&File::NCopy::u_chmod,
             'file_check'     => \&File::NCopy::f_check,
             'set_times'      => \&File::NCopy::s_times,
     );

     set_permission will take two file names, the original to get the
     file permissions from and the new file to set the file permissions
     for.

     file_check takes two parameters, the file names to check the file to
     copy from and the file to copy to. I am using flock for Unix
     systems.
     Default for this is \&File::NCopy::f_check.  On Unix you can also use
     \&File::NCopy::unix_check.  This one compares the inode and device
     numbers.

     set_times is used if the preserve attribute is true.  It preserves
     the access and modification time of the file and also attempts to
     set the owner of the file to the original owner.  This can be useful
     in a script used by root, though enyone can preserve the access and
     modification times. This also takes two arguments.  The file to get
     the stats from and apply the stats to.

     On Unix boxes you shouldn't need to worry.  On other system you may
     want to supply your own sub references.

     $file = File::NCopy->new(recursive => 1);
     $file->copy "file","other_file";
     $file->copy "directory1","directory2";

     $file = File::NCopy->new(u_chmod => \&my_chmod,f_check => \&my_fcheck);
     $file->copy "directory1","directory2";

DESCRIPTION
===========

   *File::NCopy::copy* copies files to directories, or a single file to
another file.  You can also use a reference to a file handle if you wish
whem doing a file to file copy.  The functionality is very similar to cp.
If the argument is a directory to directory copy and the recursive flag is
set then it is done recursively like *cp -R*.  In fact it behaves like cp
on Unix for the most part.  If called in array context, an array of
successful copies is returned, otherwise the number of succesful copies is
returned.  If passed a file handle, it's difficult to make sure the file
we are copying isn't the same that we are copying to, since by opening the
file in write mode it gets pooched.  To avoid this use file names instead,
if at all possible, especially for the to file.  If passed a file handle,
it is not closed when copy returns, files opened by copy are closed.

copy
     Copies a file to another file.  Or a file to a directory.  Or multiple
     files and directories to another directory.  Or a directory to another
     directory.  Wildcard arguments are expanded, except for the last
     argument which should not be expanded.  The file and directory
     permissions are set to the orginating file's permissions and if
     preserve is set the access and modification times are also set.  If
     preserve is set then the uid and gid will also be attempted to be
     set, though this may only for for the men in white hats.  In list
     context it returns all the names of the files/directories that were
     successfully copied.  In scalar context it returns the number of
     successful copies made.  A directory argument is considerd a single
     successful copy if it manages to copy anything at all.  To make a
     directory to directory copy the recursive flag must be set.

cp
     Just calls copy.  It's there to be compatible with File::Copy.

new
     If used then you can treat this as an object oriented module with some
     configuration abilities.

recursive
     If used as an object then you can use this to set the recursive
     attribute.  It can also be set when instantiating with new.  The other
     attributes must all be set when instantiating the object.  If it isn't
     specified then directories are not followed.

preserve
     Attempt to preserve the last modification and access time as well as
     user and group id's.  This is a useful feature for sysadmins, though
     the access and modification time should always be preservable, the
     uid and gid may not.

follow_links
     If the link is to a directory and this attribute is true then the
     directory is followed and recursively copied.  Otherwise a link is
     made to the root directory the link points to. eg.

     /sys/ is a link to /usr/src/sys/ is a link to /usr/src/i386/sys then
     the link /sys/ is actually created in the source directory as a link
     to /usr/src/i386/sys/ rather than /usr/src/sys/ since if the link
     /usr/src/sys/ is removed then we lost the link even though the
     directory we originally intended to link to still exists.

force_write
     Force the writing of a file even if the permissions are read only on
     it.

EXAMPLE
=======

   See SYNOPSIS.

BUGS
====

   When following links the target directory might not exactly the same as
the source directory.  The reason is that we have to make sure we don't
follow circular or dead links.  This is really a feature though the result
may not quite resemble the source dir, the overall content will be the
same. :)

AUTHOR
======

   Gabor Egressy *gabor@vmunix.com*

   Copyright (c) 1998 Gabor Egressy.  All rights reserved.  All wrongs
reversed.  This program is free software; you can redistribute and/or
modify it under the same terms as Perl itself.

   Some ideas gleaned from File::Copy by Aaron Sherman & Charles Bailey,
but the code was written from scratch.


File: pm.info,  Node: File/Path,  Next: File/PathConvert,  Prev: File/NCopy,  Up: Module List

create or remove directory trees
********************************

NAME
====

   File::Path - create or remove directory trees

SYNOPSIS
========

     use File::Path;

     mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
     rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);

DESCRIPTION
===========

   The mkpath function provides a convenient way to create directories,
even if your mkdir kernel call won't create more than one level of
directory at a time.  mkpath takes three arguments:

   * the name of the path to create, or a reference to a list of paths to
     create,

   * a boolean value, which if TRUE will cause mkpath to print the name of
     each directory as it is created (defaults to FALSE), and

   * the numeric mode to use when creating the directories (defaults to
     0777)

   It returns a list of all directories (including intermediates,
determined using the Unix '/' separator) created.

   Similarly, the `rmtree' function provides a convenient way to delete a
subtree from the directory structure, much like the Unix command `rm -r'.
`rmtree' takes three arguments:

   * the root of the subtree to delete, or a reference to a list of roots.
     All of the files and directories below each root, as well as the
     roots themselves, will be deleted.

   * a boolean value, which if TRUE will cause `rmtree' to print a message
     each time it examines a file, giving the name of the file, and
     indicating whether it's using rmdir or unlink to remove it, or that
     it's skipping it.  (defaults to FALSE)

   * a boolean value, which if TRUE will cause `rmtree' to skip any files
     to which you do not have delete access (if running under VMS) or
     write access (if running under another OS).  This will change in the
     future when a criterion for 'delete permission' under OSs other than
     VMS is settled.  (defaults to FALSE)

   It returns the number of files successfully deleted.  Symlinks are
simply deleted and not followed.

   NOTE: If the third parameter is not TRUE, `rmtree' is *unsecure* in the
face of failure or interruption.  Files and directories which were not
deleted may be left with permissions reset to allow world read and write
access.  Note also that the occurrence of errors in rmtree can be
determined *only* by trapping diagnostic messages using `$SIG{__WARN__}';
it is not apparent from the return value.  Therefore, you must be
extremely careful about using `rmtree($foo,$bar,0' in situations where
security is an issue.

AUTHORS
=======

   Tim Bunce <`Tim.Bunce@ig.co.uk'> and Charles Bailey
<`bailey@newman.upenn.edu'>


File: pm.info,  Node: File/PathConvert,  Next: File/ReadBackwards,  Prev: File/Path,  Up: Module List

convert an absolute path to a relative path
*******************************************

NAME
====

   abs2rel - convert an absolute path to a relative path

   rel2abs - convert a relative path to an absolute path

   realpath - convert a logical path to a physical path (resolve symlinks)

   splitpath - split a path in to volume, directory and filename components

   joinpath - join volume, directory, and filename components to form a
path

   splitdirs - split directory specification in to component names

   joindirs - join component names in to a directory specification

   setfstype - set the file system type

SYNOPSIS
========

     use File::PathConvert qw(realpath abs2rel rel2abs setfstype splitpath
       joinpath splitdirs joindirs $resolved);

     $relpath = abs2rel($abspath);
     $abspath = abs2rel($abspath, $base);

     $abspath = rel2abs($relpath);
     $abspath = rel2abs($relpath, $base);

     $path = realpath($logpath) || die "resolution stopped at $resolved";

     ( $volume, $directory, $filename )= splitpath( $path ) ;
     ( $volume, $directory, $filename )= splitpath( $path, 'nofile' ) ;

     $path= joinpath( $volume, $directory, $filename ) ;

     @directories= splitdirs( $directory ) ;
     $directory= joindirs( @directories ) ;

DESCRIPTION
===========

   File::PathConvert provides functions to convert between absolute and
relative paths, and from logical paths to physical paths on a variety of
filesystems, including the URL 'filesystem'.

   Paths are decomposed internally in to volume, directory, and, sometimes
filename portions as appropriate to the operation and filesystem, then
recombined.  This preserves the volume and filename portions so that they
may be returned, and prevents them from interfering with the path
conversions.

   Here are some examples of path decomposition.  A '****' in a column
indicates the column is not used in abs2rel and rel2abs functions for that
filesystem type.

     FS      VOLUME                  Directory       filename
     ======= ======================= =============== =============
     URL     http:                   /a/b/           c?query
             http://fubar.com        /a/b/           c?query
             //p.d.q.com             /a/b/c/         ?query

     VMS     Server::Volume:         [a.b]           c
             Server"access spec"::   [a.b]           c
             Volume:                 [a.b]           c

     Win32   A:                      \a\b\c          ****
             \\server\Volume         \a\b\c          ****
             \\server\Volume         \a/b/c          ****

     Unix    ****                    \a\b\c          ****

     MacOS   Volume::                a:b:c           ****

   Many more examples abound in the test.pl included with this module.

   Only the VMS and URL filesystems indicate if the last name in a path is
a directory or file.  For other filesystems, all non-volume names are
assumed to be directory names.  For URLs, the last name in a path is
assumed to be a filename unless it ends in '/', '/.', or '/..'.

   Other assumptions are made as well, especially MacOS and VMS. THESE MAY
CHANGE BASED ON PROGRAMMER FEEDBACK!

   The conversion routines abs2rel, rel2abs, and realpath are the main
focus of this package.  splitpath and joinpath are provided to allow
volume oriented filesystems (almost anything non-unixian, actually) to be
accomodated.  splitdirs and joindirs provide directory path grammar
parsing and encoding, which is especially useful for VMS.

setfstype
     This is called automatically on module load to set the filesystem type
     according to $^O. The user can call this later set the filesystem type
     manually.  If the name is not recognized, unix defaults are used.
     Names matching /^URL$/i, /^VMS$/i, /^MacOS$/i, or
     /^(ms)?(win|dos)/32|nt)?$/i yield the appropriate (hopefully)
     filesystem settings.  These strings may be generalized in the future.

     Examples:

          File::PathConvert::setfstype( 'url' ) ;
          File::PathConvert::setfstype( 'Win32' ) ;
          File::PathConvert::setfstype( 'HAL9000' ) ; # Results in Unix default

abs2rel
     abs2rel converts an absolute path name to a relative path: converting
     /1/2/3/a/b/c relative to /1/2/3 returns a/b/c

          $relpath= abs2rel( $abspath ) ;
          $relpath= abs2rel( $abspath, $base ) ;

     If $abspath is already relative, it is returned unchanged.  Otherwise
     the relative path from $base to $abspath is returned.  If $base is
     undefined the current directory is used.

     The volume and filename portions of $base are ignored if present.  If
     $abspath and $base are on different volumes, the volume from $abspath
     is used.

     No filesystem calls are made except for getting the current working
     directory if $base is undefined, so symbolic links are not checked
     for or resolved, and no check is done for existance.

     Examples

          # Unix
          'a/b/c' == abs2rel( 'a/b/c', $anything )
          'a/b/c' == abs2rel( '/1/2/3/a/b/c', '/1/2/3' )

          # DOS
          'a\\b/c' == abs2rel( 'a\\b/c', $anything )
          'a\\b/c' == abs2rel( '/1\\2/3/a\\b/c', '/1/2/3' )

          # URL
          'http:a/b/c'           == abs2rel( 'http:a/b/c', $anything )
          'http:a/b/c'           == abs2rel( 'http:/1/2/3/a/b/c',
                                             'ftp://t.org/1/2/3/?z' )
          'http:a/b/c?q'         == abs2rel( 'http:/1/2/3/a/b/c/?q',
                                             'ftp://t.org/1/2/3?z'  )
          'http://s.com/a/b/c?q' == abs2rel( 'http://s.com/1/2/3/a/b/c?q',
                                             'ftp://t.org/1/2/3/?z')

rel2abs
     rel2abs makes converts a relative path name to an absolute path:
     converting a/b/c relative to /1/2/3 returns /1/2/3/a/b/c.

          $abspath= rel2abs( $relpath ) ;
          $abspath= rel2abs( $relpath, $base ) ;

     If $relpath is already absolute, it is returned unchanged.  Otherwise
     $relpath is taken to be relative to $base and the resulting absolute
     path is returned.  If $base is not supplied, the current working
     directory is used.

     The volume portion of $relpath is ignored.  The filename portion of
     $base is also ignored. The volume from $base is returned if present.
     The filename portion of $abspath is returned if present.

     No filesystem calls are made except for getting the current working
     directory if $base is undefined, so symbolic links are not checked
     for or resolved, and no check is done for existance.

     rel2abs will not return a path of the form "./file".

     Examples

          # Unix
          '/a/b/c'       == rel2abs( '/a/b/c', $anything )
          '/1/2/3/a/b/c' == rel2abs( 'a/b/c', '/1/2/3' )

          # DOS
          '\\a\\b/c'                == rel2abs( '\\a\\b/c', $anything )
          '/1\\2/3\\a\\b/c'         == rel2abs( 'a\\b/c', '/1\\2/3' )
          'C:/1\\2/3\\a\\b/c'       == rel2abs( 'D:a\\b/c', 'C:/1\\2/3' )
          '\\\\s\\v/1\\2/3\\a\\b/c' == rel2abs( 'D:a\\b/c', '\\\\s\\v/1\\2/3' )

          # URL
          'http:/a/b/c?q'            == rel2abs( 'http:/a/b/c?q', $anything )
          'ftp://t.org/1/2/3/a/b/c?q'== rel2abs( 'http:a/b/c?q',
                                                 'ftp://t.org/1/2/3?z' )

realpath
     realpath makes a canonicalized absolute pathname and resolves all
     symbolic links, extra "/" characters, and references to /./ and /../
     in the path.  realpath resolves both absolute and relative paths.  It
     returns the resolved name on success, otherwise it returns undef and
     sets the valiable `$File::PathConvert::resolved' to the pathname that
     caused the problem.

     All but the last component of the path must exist.

     This implementation is based on 4.4BSD realpath(3).  It is not tested
     under other operating systems at this time.

     If '/sys' is a symbolic link to '/usr/src/sys':

          chdir('/usr');
          '/usr/src/sys/kern' == realpath('../sys/kern');
          '/usr/src/sys/kern' == realpath('/sys/kern');

splitpath
     To be written...

joinpath
     To be written...

     Note that `joinpath( splitpath( $path ) )' usually yields path.  URLs
     with directory components ending in '/.' or '/..' will be fixed up to
     end in '/./' and '/../'.

splitdirs
     To be written...

joindirs
BUGS
====

   realpath is not fully multiplatform.

LIMITATIONS
===========

   * In URLs, paths not ending in '/' are split such that the last name in
     the path is a filename.  This is not intuitive: many people use such
     URLs for directories, and most servers send a redirect.  This may
     cause programers using this package to code in bugs, it may be more
     pragmatic to always assume all names are directory names.  (Note that
     the query portion is always part of the filename).

   * If the relative and base paths are on different volumes, no error is
     returned.  A silent, hopefully reasonable assumption is made.

   * No detection of unix style paths is done when other filesystems are
     selected, like File::Basename does.

AUTHORS
=======

   Barrie Slaymaker <rbs@telerama.com> Shigio Yamaguchi
<shigio@wafu.netgate.net>


File: pm.info,  Node: File/ReadBackwards,  Next: File/Remote,  Prev: File/PathConvert,  Up: Module List

Read a file backwards by lines.
*******************************

NAME
====

   File::ReadBackwards.pm - Read a file backwards by lines.

SYNOPSIS
========

     use File::ReadBackwards ;

     # Object interface

     $bw = File::ReadBackwards->new( 'log_file' ) or
     			die "can't read 'log_file' $!" ;

     while( defined( $log_line = $bw->readline ) ) {
     	    print $log_line ;
     }

     # Tied Handle Interface

     tie *BW, File::ReadBackwards, 'log_file' or
     			die "can't read 'log_file' $!" ;

     while( <BW> ) {
     	    print ;
     }

DESCRIPTION
===========

   This module reads a file backwards line by line. It is simple to use,
memory efficient and fast. It supports both an object and a tied handle
interface.

   It is intended for processing log and other similar text files which
typically have their newest entries appended to them. By default files are
assumed to be plain text and have a line ending appropriate to the OS. But
you can set the input record separator string on a per file basis.

OBJECT INTERFACE
================

   There are only 2 methods in Backwards' object interface, new and
readline.

new( $file, [$rec_sep] )
------------------------

   New takes as arguments a filename and an optional record separator. It
either returns the object on a successful open or undef upon failure. $!
is set to the error code if any.

readline
--------

   Readline takes no arguments and it returns the previous line in the file
or undef when there are no more lines in the file.

TIED HANDLE INTERFACE
=====================

tie( *HANDLE, File::ReadBackwards, $file, [$rec_sep] )
------------------------------------------------------

   The TIEHANDLE and READLINE methods are aliased to the new and readline
methods respectively so refer to them for their arguments and API.  Once
you have tied a handle to File::ReadBackwards the only operation
permissible is <> which will read the previous line. All other tied handle
operations will generate an unknown method error. Do not seek, write or
perform any other operation other than <> on the tied handle.

LINE AND RECORD ENDINGS
=======================

   Since this module needs to use low level I/O for efficiency, it can't
portably seek and do block I/O without managing line ending conversions.
This module supports the default record separators of normal line ending
strings used by the OS. You can also set the separator on a per file basis.

   Only if the record separator is not specified and it defaults to CR/LF
(e.g, VMS, redmondware) will it will be converted to a single newline.
Unix and MacOS files systems use only a single character for line endings
and the lines are left unchanged.  This means that for native text files,
you should be able to process their lines backwards without any problems
with line endings. If you specify a record separator, no conversions will
be done and you will get the records as if you read them in binary mode.

DESIGN
======

   It works by reading a large (8kb) block of data from the end of the
file.  It then splits them on the record separator and stores a list of
records in the object. Each call to readline returns the top record of the
list and if the list is empty it refills it by reading the previous block
from the file and splitting it.  When the beginning of the file is reached
and there are no more lines, undef is returned.  All boundary conditions
are handled correctly i.e. if there is a trailing partial line (no
newline) it will be the first line returned and lines larger than the read
buffer size are handled properly.

NOTES
=====

   There is no support for list context in either the object or tied
interfaces. If you want to slurp all of the lines into an array in
backwards order (and you don't care about memory usage) just do:

     @back_lines = reverse <FH>.

   This module is only intended to read one line at a time from the end of
a file to the beginning.

AUTHOR
======

   Uri Guttman, uri@sysarch.com

COPYRIGHT
=========

   Copyright (C) 2000 by Uri Guttman. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: File/Remote,  Next: File/Remove,  Prev: File/ReadBackwards,  Up: Module List

Read/write/edit remote files transparently
******************************************

NAME
====

   File::Remote - Read/write/edit remote files transparently

SYNOPSIS
========

     #
     # Two ways to use File::Remote
     # First, the object-oriented style
     #
     use File::Remote;
     my $remote = new File::Remote;
     
     # Standard filehandles
     $remote->open(FILE, '>>host:/remote/file') or die $!;
     print FILE "Here's a line that's added.\n";
     $remote->close(FILE);
     
     # Create a new file and change its permissions
     $remote->mkdir('host:/remote/dir');
     $remote->touch('host:/remote/dir/file');
     $remote->chown('root', 'other', 'host:/remote/dir/file');
     $remote->chmod('0600', 'host:/remote/dir/file');
     
     # Move files around
     $remote->copy('/local/file', 'host:/remote/file') or warn $!;
     $remote->move('host:/remote/file', '/local/file');
     
     # Read and write whole files
     my @file = $remote->readfile('host:/remote/file');
     $remote->writefile('/local/file', @file);
     
     # Backup a file with a suffix
     $remote->backup('host:/remote/oldfile', 'save');
     
     # Use secure connection methods
     my $secure = new File::Remote (rsh => '/usr/local/bin/ssh',
                                    rcp => '/usr/local/bin/scp');
     $secure->unlink('/local/file');
     $secure->rmdir('host:/remote/dir');
     
     #
     # Next, the function-based style. Here, we can use the
     # special :replace tag to overload Perl builtins!
     #
     use File::Remote qw(:replace);	# special :replace tag

     open(REMOTE, 'host:/remote/file') or die $!;
     print while (<REMOTE>);
     close(REMOTE);

     open(LOCAL, '>>/local/file');	# still works!
     print LOCAL "This is a new line.\n";
     close(LOCAL);
     
     mkdir('host:/remote/dir', 0755);
     unlink('host:/remote/file');
     unlink('/local/file');		# still works too!
     symlink('host:/remote/src', 'host:/remote/dest');

DESCRIPTION
===========

   This module takes care of dealing with files regardless of whether
they're local or remote.  It allows you to create and edit files without
having to worry about their physical location on the network.  If a file
passed into a function is of the form 'host:/path/to/file', then
File::Remote uses rsh/rcp (or ssh/scp, depending on how you configure it)
to edit the file remotely.  Otherwise, it assumes the file is local and
passes calls directly through to Perl's core functions.

   The nice thing about this module is that you can use it for all your
file calls, since it handles both remote and local files transparently.
This means you don't have to put a whole bunch of checks for remote files
in your code.  Plus, if you use the function-oriented interface along with
the `:replace' tag, you can actually redefine the Perl builtin file
functions so that your existing Perl scripts can automatically handle
remote files with no re-engineering!

   There are two ways to program with File::Remote, an object-oriented
style and a function-oriented style.  Both methods work equally well, it's
just a matter of taste.  One advantage of the object-oriented method is
that this allows you to read and write from different servers using
different methods (eg, rsh vs. ssh) simultaneously:

     # Object-oriented method
     use File::Remote;
     my $remote = new File::Remote;
     my $secure = new File::Remote (rsh => '/bin/ssh', rcp => '/bin/scp');

     # Securely copy, write, and remove a file in one swoop...
     $remote->open(LOCAL, '/local/file') or die "Open failed: $!\n";
     $secure->open(REMOTE, 'host:/remote/file') or die "Open failed: $!\n";
     print REMOTE "$_" while (<LOCAL>);

     $remote->close(LOCAL);
     $secure->close(REMOTE);

     # And let's move some files around securely
     $secure->move('/local/file', 'host:/remote/file');
     $secure->copy('host:/remote/file', '/local/file');

   Because the names for the File::Remote methods clash with the Perl
builtins, if you use the function-oriented style with the :standard tag
there is an extra 'r' added to the front of the function names.  Thus,
'$remote->open' becomes 'ropen' in the function-oriented version:

     # Function-oriented method
     use File::Remote qw(:standard);	# use standard functions
     setrsh('/local/bin/ssh');
     setrcp('/local/bin/scp');

     ropen(FILE, 'host:/remote/file') or die "Open failed: $!\n";
     print while (<FILE>);
     rclose(FILE) or die "Close failed: $!\n";

     runlink('host:/remote/file');
     rmkdir('host:/remote/dir');
     rchmod('0700', 'host:/remote/dir');

   With the function-oriented interface there is also a special tag called
`:replace' which will actually replace the Perl builtin functions:

     # Replace Perl's file methods with File::Remote's
     use File::Remote qw(:replace);

     open(FILE, '>host:/remote/file') or die "Open failed: $!\n";
     print FILE "Hello, world!\n";
     close(FILE) or die "Close failed: $!\n";

     mkdir('/local/new/dir', '2775');
     mkdir('host:/remote/new/dir');
     chown('root', 'other', '/local/new/dir');
     unlink('host:/remote/file');

   This is pretty neat; since File::Remote will pass calls to local files
straight through to Perl's core functions, you'll be able to do all this
"transparently" and not care about the locations of the files. Plus, this
has the big advantage of making your existing Perl scripts capable of
dealing with remote files without having to rewrite any code.

FUNCTIONS
=========

   Below are each of the functions you can make use of with File::Remote.
Remember, for the function-oriented style, unless you use the `:replace'
tag you'll have to add an extra 'r' to the start of each function name.
For all functions, the file arg can be either local or remote.

new(opt => val, opt => val)
---------------------------

   This is the main constructor when you're using the object-oriented
method of calling. You can pass it three arguments which change how it
works:

     rsh  -  path to your rsh or ssh program
     rcp  -  path to your rcp or scp program
     tmp  -  path to your tmp directory

   So, for example:

     use File::Remote;
     my $secure = File::Remote->new(rsh => '/usr/local/bin/ssh',
                                    rcp => '/usr/local/bin/scp',
                                    tmp => '/var/run');
     $secure->copy($src, $dest);

   The above would setup your $secure object so that calls to methods on
it would use ssh and scp for connections.

setrsh(prog) ; setrcp(prog) ; settmp(dir)
-----------------------------------------

   These perform the equivalent functionality to setting the above flags,
for use in the function-oriented method of calling. So, if you were to
decide you didn't want to use the OO method, but instead wanted to use the
drop-in replacement function method (which I prefer):

     use File::Remote qw(:replace);

     setrsh('/usr/local/bin/ssh');
     setrcp('/usr/local/bin/scp');
     settmp('/var/run');

     copy($src, $dest);

   That chain of calls would have the exact same effect, only using the
function-oriented format instead of the object-oriented format.

open(HANDLE, file) ; close(HANDLE)
----------------------------------

   Used to open and close files just like the Perl builtins. These
functions accept both string filehandles and typeglob references.

touch(file)
-----------

   Updates the modification time on a file, or creates it if it doesn't
exist.

mkdir(dir [, mode]) ; rmdir(dir [, recurse])
--------------------------------------------

   Create a dir with optional octal mode [mode]; remove a dir tree
optionally recursively. By default, rmdir works recursively, and the mode
of the new dir from mkdir depends on your umask.

copy(file1, file2)
------------------

   Simply copies a file, just like File::Copy's function of the same name.
You can also address it as 'cp' (if you import the :aliases tag).

move(file1, file2)
------------------

   Moves a file ala File::Copy.  You can also address it as 'mv' (if you
import the :aliases tag).

chmod(mode, file) ; chown(owner, group, file)
---------------------------------------------

   Change the permissions or the owner of a file.

unlink(file)
------------

   Remove a file. You can also address it as 'rm' (if you import the
:aliases tag).

link(file1, file2)
------------------

   Create a hard link between two files. The caveat to this function is
that both files must be local, or both files must be remote.

symlink(file1, file2)
---------------------

   Works just like link only creates symbolic instead of hard links.

readlink(file)
--------------

   This reads what a symbolic link points to, just like the Perl builtin.

backup(file, [file|suffix])
---------------------------

   This backs up a file, useful if you're going to be manipulating it.  If
you just call it without the optional second filename or suffix, the
suffix 'bkup' will be added to the file.  Either file can be local or
remote; this is really just a front-end to File::Remote::copy().

readfile(file) , writefile(file, @data)
---------------------------------------

   These read and write whole files in one swoop, just like File::Slurp.
readfile() returns an array of the file, and writefile just returns
success or failure.

append(file, @data) , prepend(file, @data)
------------------------------------------

   Similar to writefile(), only these don't overwrite the file, these
either append or prepend the data to the file.

EXAMPLES
========

   Here's some more examples of how to use this module:

1. Add a new user to /etc/passwd on your server
-----------------------------------------------

   This might be useful if you've got some type of web-based newuser
program that runs on a host other than the one you have to edit
/etc/passwd on:

     # Function-oriented method
     use File::Remote qw(:replace);

     $passwd = "server:/etc/passwd";
     backup($passwd, 'old');		# back it up to be safe
     open(PASSWD, ">>$passwd") or die "Couldn't write $passwd: $!\n";
     print PASSWD "$newuser_entry\n";
     close(PASSWD);

2. Securely copy over a bunch of files
--------------------------------------

   Hopefully you would use loops and variable names to make any actual
code look much cleaner...

     # Object-oriented method
     use File::Remote
     my $secure = File::Remote->new(rsh => '/share/bin/ssh',
                                    rcp => '/share/bin/scp',
                                    tmp => '/var/tmp');

     # Move files
     $secure->move('client:/home/bob/.cshrc', 'client:/home/bob/.cshrc.old');
     $secure->copy('/etc/skel/cshrc.user', 'client:/home/bob/.cshrc');
     $secure->copy('/etc/skel/kshrc.user', 'client:/home/bob/.kshrc');

3. Use rsync w/ ssh for really fast transfers
---------------------------------------------

   Here we're assuming we're getting some huge datastream from some other
process and having to dump it into a file in realtime.  Note that the
remote file won't be updated until close() is called.

     # Function-oriented, no :replace tag, so all functions
     # will be prefixed with an 'r'
     use File::Remote qw(:standard);

     setrsh('/local/bin/ssh');
     setrcp('/local/bin/rsync -z -e /local/bin/ssh');
     settmp('/var/stmp');

     $file = "server:/local/dir/some/huge/file";
     ropen(REMOTE, ">>$file") or die "Couldn't write $file: $!\n";
     while(<DATASTREAM>) {
        print REMOTE $_;
     }
     rclose(REMOTE);		# file is finally updated

NOTES
=====

   File::Remote only works on UNIX systems.

   The main caveat to File::Remote is that you have to have rsh/rcp or
ssh/scp access to the hosts you want to manipulate files on.  Make sure
you consider the security implications of this, especially if you live
outside a firewall.

   Enabling autoflush ($|) won't have any effect on remote filehandles,
since the remote file is not synched until close() is called on the
filehandle.

   File::Remote does not support writing to remote pipes.

   Because of speed, by default no checks are made as to whether or not
rsh/rcp or their equivalents are executable. To change this, see the
source.

BUGS
====

   Because of the internal implementation of open() on remote files, it is
not possible to read from an ever-growing remote file ("tail" it).
Basically, a snapshot of the remote file is taken when you open it for
reading. Patches to overcome this limitation are welcomed.

   Perl scripts that are tainted or setuid might not work with File::Remote
because of its reliance on system() calls, depending on your %ENV. To work
around this, simply add an "undef %ENV" statement to the top of your
script, which you should be doing anyways.

   If you have a bug report or suggestion, please direct them to me (see
below).  Please be specific and include the version of File::Remote you're
using.

VERSION
=======

   $Id: Remote.pm,v 1.12 2000/11/30 00:29:53 nwiger Exp $

AUTHOR
======

   Copyright (c) 1998-2000 Nathan Wiger <nate@nateware.com>. All Rights
Reserved.

   This module is free software; you may copy this under the terms of the
GNU General Public License, or the Artistic License, copies of which
should have accompanied your Perl kit.


