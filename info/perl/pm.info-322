This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: QGroupBox,  Next: QImage,  Prev: QGlobal,  Up: Module List

Interface to the Qt QGroupBox class
***********************************

NAME
====

   QGroupBox - Interface to the Qt QGroupBox class

SYNOPSIS
========

   `use QGroupBox;'

   Inherits QFrame.

Member functions
----------------

   new, alignment, setAlignment, setTitle, title

DESCRIPTION
===========

   What you see is what you get.

EXPORTED
========

   The following variables are exported into the user's namespace:

   %Align $SingleLine $DontClip $ExpandTabs $ShowPrefix $WordBreak
$GrayText $DontPrint

   See `QPainter(3)' in this node for info

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QImage,  Next: QLCDNumber,  Prev: QGroupBox,  Up: Module List

Interface to the Qt QImage class
********************************

NAME
====

   QImage - Interface to the Qt QImage class

SYNOPSIS
========

   `use QImage;'

Member functions
----------------

DESCRIPTION
===========

   What you see is what you get.

SEE ALSO
========

   QImage(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QLCDNumber,  Next: QLabel,  Prev: QImage,  Up: Module List

Interface to the Qt QLCDNumber class
************************************

NAME
====

   QLCDNumber - Interface to the Qt QLCDNumber class

SYNOPSIS
========

   `use QLCDNumber;'

   Inherits QFrame.

Member functions
----------------

   new, checkOverflow, display, intValue, mode, numDigits, setBinMode,
setDecMode, setHexMode, setMode, setNumDigits, setOctMode,
setSmallDecimalPoint, smallDecimalPoint, value

DESCRIPTION
===========

   What you see is what you get.

SEE ALSO
========

   QLCDNumber(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QLabel,  Next: QLayout,  Prev: QLCDNumber,  Up: Module List

Interface to the Qt QLabel class
********************************

NAME
====

   QLabel - Interface to the Qt QLabel class

SYNOPSIS
========

   `use QLabel;'

   Inherits QFrame.

   Requires QPixmap and QSize.

Member functions
----------------

   new, alignment, autoResize, buddy, margin, pixmap, setAlignment,
setAutoResize, setBuddy, setMargin, setNum, setText, setPixmap, text

DESCRIPTION
===========

   QLabel has been completely interfaced.

EXPORTED
========

   The following variables are exported into the user's namespace:

   %Align $SingleLine $DontClip $ExpandTabs $ShowPrefix $WordBreak
$GrayText $DontPrint

   The `%Align' hash contains all the Align* constants without the Align.
All of these constants are defined in `qwindefs.h'.

CAVEATS
=======

   I might create `%Align' for the hell of it. You never know.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QLayout,  Next: QLineEdit,  Prev: QLabel,  Up: Module List

Interface to the Qt QLayout, QBoxLayout and QGridLayout classes
***************************************************************

NAME
====

   QLayout - Interface to the Qt QLayout, QBoxLayout and QGridLayout
classes

SYNOPSIS
========

QLayout
-------

   `use QLayout;'

   Inherits QObject.

   Requires QMenuBar.

Member functions
----------------

   activate, defaultBorder, freeze, setMenuBar

QBoxLayout
----------

   Inherits QLayout.

Member functions
----------------

   new, addLayout, addSpacing, addStretch, addStrut, addWidget, direction

QGridLayout
-----------

   Inherits QLayout.

Member functions
----------------

   new, addLayout, addMultiCellWidget, addWidget, setColStretch,
setRowStretch

DESCRIPTION
===========

   What you see is what you get.

EXPORTED
========

   The `%Direction' hash is exported on behalf of QBoxLayout. It contains
all of the constants within QBoxLayout.

   The %Align $SingleLine $DontClip $ExpandTabs $ShowPrefix $WordBreak
$GrayText $DontPrint constants are exported. See `QPainter(3)' in this node
for info.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QLineEdit,  Next: QListBox,  Prev: QLayout,  Up: Module List

Interface to the Qt QLineEdit class
***********************************

NAME
====

   QLineEdit - Interface to the Qt QLineEdit class

SYNOPSIS
========

   `use QLineEdit;'

   Inherits QWidget.

Member functions
----------------

   new, deselect, maxLength, selectAll, setMaxLength, setText, text

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QListBox,  Next: QMenuBar,  Prev: QLineEdit,  Up: Module List

Interface to the Qt QListBox, QListBoxItem, QListBoxPixmap and QListBoxText classes
***********************************************************************************

NAME
====

   QListBox - Interface to the Qt QListBox, QListBoxItem, QListBoxPixmap
and QListBoxText classes

SYNOPSIS
========

QListBox
--------

   `use QListBox;'

   Inherits QTableView.

Member functions
----------------

   new, autoBottomScrollBar, autoScroll, autoScrollBar, autoUpdate,
bottomScrollBar, centerCurrentItem, changeItem, clear, count, currentItem,
dragSelect, insertItem, insertStrList, inSort, itemHeight, maxItemWidth,
numItemsVisible, pixmap, removeItem, scrollBar, setAutoBottomScrollBar,
setAutoScroll, setAutoScrollBar, setAutoUpdate, setBottomScrollBar,
setCurrentItem, setDragSelect, setScrollBar, setSmoothScrolling,
setTopItem, smoothScrolling, text, topItem

QListBoxItem
------------

   Requires QPixmap.

Member functions
----------------

   height, pixmap, text, width

QListBoxPixmap
--------------

   Inherits QListBoxItem

Member functions
----------------

   new

QListBoxText
------------

   Inherits QListBoxItem

Member functions
----------------

   new

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QMenuBar,  Next: QMenuData,  Prev: QListBox,  Up: Module List

Interface to the Qt QMenuBar class
**********************************

NAME
====

   QMenuBar - Interface to the Qt QMenuBar class

SYNOPSIS
========

   `use QMenuBar;'

   Inherits QFrame and QMenuData.

Member functions
----------------

   new

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QMenuData,  Next: QMessageBox,  Prev: QMenuBar,  Up: Module List

Interface to the Qt QMenuData class
***********************************

NAME
====

   QMenuData - Interface to the Qt QMenuData class

SYNOPSIS
========

   `use QMenuData;'

   Requires QObject, QPixmap and QPopupMenu.

Member functions
----------------

   new, accel, changeItem, clear, connectItem, count, disconnectItem, idAt,
indexOf, insertItem, insertSeparator, isItemChecked, isItemEnabled, pixmap,
removeItem, removeItemAt, setAccel, setId, setItemChecked, setItemEnabled,
text, updateItem

DESCRIPTION
===========

   What you see is what you get.

NOTES
=====

   findItem() is not, and will not be, interfaced. The 'member' argument of
insertItem() should not have a SLOT() or SIGNAL() around it. That's a
PerlQt no-no. Be sure to see `QObject(3)' in this node for info.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QMessageBox,  Next: QMultiLineEdit,  Prev: QMenuData,  Up: Module List

Interface to the Qt QMessageBox class
*************************************

NAME
====

   QMessageBox - Interface to the Qt QMessageBox class

SYNOPSIS
========

   `use QMessageBox;'

   Inherits QDialog.

Member functions
----------------

   new, adjustSize, buttonText, message, query, setButtonText, setText,
text

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QMultiLineEdit,  Next: QObject,  Prev: QMessageBox,  Up: Module List

Interface to the Qt QMultiLineEdit class
****************************************

NAME
====

   QMultiLineEdit - Interface to the Qt QMultiLineEdit class

SYNOPSIS
========

   `use QMultiLineEdit;'

   Inherits QTableView.

   Requires QFont.

Member functions
----------------

   new, append, atBeginning, atEnd, autoUpdate, clear, copyText, cut,
deselect, getCursorPosition, insertAt, insertLine, isOverwriteMode,
isReadOnly, numLines, paste, removeLine, selectAll, setAutoUpdate,
setCursorPosition, setOverwriteMode, setReadOnly, setText, text, textLine

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QObject,  Next: QPaintDevice,  Prev: QMultiLineEdit,  Up: Module List

Interface to the Qt QObject class
*********************************

NAME
====

   QObject - Interface to the Qt QObject class

SYNOPSIS
========

   `use QObject;'

   `use signals 'sig1()', ..., 'sigx(int)';'

   `use slots 'slot1()', ..., 'sigx(int,int)';'

Member functions
----------------

   new, blockSignals, className, connect, disconnect, dumpObjectInfo,
dumpObjectTree, event, eventFilter, highPriority, inherits, insertChild,
installEventFilter, isA, isWidgetType, killTimer, killTimers, name,
removeChild, removeEventFilter, setName, signalsBlocked, startTimer

Virtual functions
-----------------

   timerEvent

DESCRIPTION
===========

   Except for children() and queryList(), every public QObject
member-function is fully-implemented. Unless noted below, all of those
functions are completely direct interfaces.

$connected = $reciever->connect(sender, signal, member)
     Do *NOT* attempt to use SIGNAL() or SLOT() on the signal and member
     arguments. They are not needed by PerlQt, because the connect()
     function can automatically determine whether the member argument is a
     signal or a slot, and the signal will always be a signal. The signal
     and member arguments must be strings. And at the moment, there isn't
     much room for error.

$connected = QObject::connect(sender, signal, reciever, member)
     Same as above listing, just as a normal function with a different
     argument-list.

$disconnected = $sender->disconnect(signal = undef, reciever = undef, member = undef)
     Remember *NOT* to use SIGNAL() and SLOT() with disconnect(). This
     function takes over for both the static disconnect() and the 3-arg
     member disconnect() in Qt.

$disconnected = $sender->disconnect(reciever, member = undef)
     Same warning about SIGNAL() and SLOT() as above.

timerEvent(event)
     This is a virtual function, meant to be reimplemented in your own
     classes. It is currently available through QObject and QWidget.

Signals and slots
-----------------

   Signals and slots are implemented in a limited way at the moment. You
may use no-arg signals and slots freely, as well as 1 and 2 integer
argument signals and slots.

   The declaration of signals and slots is done through the usage of 'use
signals' and 'use slots'. Any classes which have QObject in their
inheritance tree are free to use signals/slots after their superclass has
been included via require/use.

use signals 'sig1()', ..., 'sigx(int,int)'
     The arguments to `use signals' must be strings representing the signal
     prototypes *excluding* the object parameter. You may use `qw()' to
     quote the function prototypes, but it warns about commas when -w is
     in use.

     Add spaces at your own risk. Misspell at your own risk. PerlQt doesn't
     do any error-checking yet. All error-checking that is done is done by
     Qt. You may run `use signals' as many times as you want. I'm pretty
     sure that if you define the same signal-name twice, the latter
     prototype is used. But you should get a redefined function warning.
     Also, the argument-types are not checked yet.

     Running `use signals' exports a function named `emit' into your
     namespace.  It does nothing, and is just there for clarity and
     consistency with Qt where the emit keyword is just as void. When you
     emit a signal, you must call it as a method-call `$self->signal()',
     and not as `'signal()'' or `signal()' because it is not a string and
     it is not a normal function.

use slots 'slot1()', ..., 'slotx(int)'
     The arguments to `use slots' must be strings representing the
     prototypes of the slots you want to declare *excluding* the object
     parameter. The slot functions aren't cached by PerlQt, and are always
     called as full method-calls.

     Once you declare a function as being a slot, you may use connect() to
     connect any signal, Perl or C++, to it.

BUGS
====

   Signals and slots are seriously crippled. They do not check their
arguments, they only allow a couple of *integer only* arguments, and
there's a serious memory-leak which I can only attribute to signals and
slots or to virtual member-function overrides. At the moment, PerlQt
signals and slots are little more than proof-of-concept and it will take
significant effort to get it working right. Any suggestions are welcome.

SEE ALSO
========

   QObject(3qt), QGlobal(3)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPaintDevice,  Next: QPainter,  Prev: QObject,  Up: Module List

Interface to the Qt QPaintDevice class
**************************************

NAME
====

   QPaintDevice - Interface to the Qt QPaintDevice class

SYNOPSIS
========

   `use QPaintDevice;'

Member functions
----------------

   devType, isExtDev, paintingActive

DESCRIPTION
===========

   A very strange class.

EXPORTED
========

   The `%PDT' and `%PDF' hashes are exported into the user's namespace.
They contain the values of the PD[FT]_* constants.

   bitBlt() is also exported, but in a strange twist of Perlian fate, it
can be called as a member-function.

     $widget->bitBlt(dx, dy, pixmap, sx, sy, sw, sh);

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPainter,  Next: QPalette,  Prev: QPaintDevice,  Up: Module List

Interface to the Qt QPainter class
**********************************

NAME
====

   QPainter - Interface to the Qt QPainter class

SYNOPSIS
========

   `use QPainter;'

   Requires QColor, QBrush, QFont, QFontInfo, QFontMetrics, QPaintDevice,
QPen, QPicture, QPixmap, QPoint, QPointArray, QRect, QRegion, QWMatrix

Member functions
----------------

   new, backgroundColor, backgroundMode, begin, boundingRect, brushOrigin,
clipRegion, device, drawArc, drawChord, drawEllipse, drawLine,
drawLineSegments, drawPie, drawPixmap, drawPoint, drawPolygon,
drawPolyline, drawQuadBezier, drawRect, drawRoundRect, drawText,
drawWinFocusRect, end, eraseRect, fillRect, font, fontInfo, fontMetrics,
hasClipping, hasViewXForm, hasWorldXForm, isActive, lineTo, moveTo, pen,
rasterOp, resetXForm, restore, rotate, save, scale, setBackgroundColor,
setBackgroundMode, setBrush, setBrushOrigin, setClipping, setClipRect,
setClipRegion, setFont, setPen, setRasterOp, setViewXForm, setViewport,
setWindow, setWorldMatrix, setWorldXForm, shear, translate, viewport,
window, worldMatrix, xForm, xFormDev

DESCRIPTION
===========

   All functions listed have every prototype version supported, mostly.
Any internal arguments are unavailable to PerlQt programmers.

EXPORTED
========

   The following variables are exported into the user's namespace on
behalf of `QPainter::drawText()' from `qwindefs.h'

   %Align $SingleLine $DontClip $ExpandTabs $ShowPrefix $WordBreak
$GrayText $DontPrint

   The `%BGMode' and `%RasterOp' hashes are also exported. `%BGMode'
contains the values in the BGMode enum in `qpainter.h' without the
trailing Mode, and `%RasterOp' contains the values in the RasterOp enum in
`qwindefs.h' without the trailing ROP.

SEE ALSO
========

   qpainter(3qt), QColor(3), QBrush(3), QFont(3), QPen(3)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPalette,  Next: QPen,  Prev: QPainter,  Up: Module List

Interface to the Qt QPalette and QColorGroup classes
****************************************************

NAME
====

   QPalette - Interface to the Qt QPalette and QColorGroup classes

SYNOPSIS
========

   `use QPalette;'

QColorGroup
-----------

   Requires QColor.

Member functions
----------------

   new, background, base, dark, foreground, light, mid, text

QPalette
--------

Member functions
----------------

   new, active, copy, disabled, normal, setActive, setDisabled, setNormal,
serialNumber

DESCRIPTION
===========

   What you see is what you get.

SEE ALSO
========

   QPalette(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPen,  Next: QPicture,  Prev: QPalette,  Up: Module List

Interface to the Qt QPen class
******************************

NAME
====

   QPen - Interface to the Qt QPen class

SYNOPSIS
========

   `use QPen;'

   Requires QColor.

Member functions
----------------

   new, color, setColor, setStyle, setWidth, style, width

DESCRIPTION
===========

   Except for the operators, this class is fully implemented.

EXPORTED
========

   The `%PenStyle' hash is exported into the user's namespace, and contains
all of the elements from the PenStyle enum defined in `qpen.h'.

SEE ALSO
========

   QPen(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPicture,  Next: QPixmap,  Prev: QPen,  Up: Module List

Interface to the Qt QPicture class
**********************************

NAME
====

   QPicture - Interface to the Qt QPicture class

SYNOPSIS
========

   `use QPicture;'

   Inherits QPaintDevice.

Member functions
----------------

DESCRIPTION
===========

   What you see is what you get.

SEE ALSO
========

   QPicture(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPixmap,  Next: QPoint,  Prev: QPicture,  Up: Module List

Interface to the Qt QPixmap class
*********************************

NAME
====

   QPixmap - Interface to the Qt QPixmap class

SYNOPSIS
========

   `use QPixmap;'

   Inherits QPaintDevice.

   Requires QBitmap, QColor, QImage, and QWMatrix.

Member functions
----------------

   new, defaultDepth, depth, detach, fill, height, imageFormat,
isOptimized, isQBitmap, load, loadFromData, isGloballyOptimized, isNull,
optimize, optimizeGlobally, rect, resize, save, size, trueMatrix, width,
xForm

DESCRIPTION
===========

   Whatever has been interfaced is fully interfaced.

   The loadFromData function does not take a 'len' argument. All the other
arguments are normal and in the original order.

EXPORTED
========

   The `%ColorMode' hash is exported into the user's namespace. The
elements of `%ColorMode' contain all the constants in QPainter, which come
from the QPainter::ColorMode enum.

SEE ALSO
========

   QPixmap(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPoint,  Next: QPointArray,  Prev: QPixmap,  Up: Module List

Interface to the Qt QPoint class
********************************

NAME
====

   QPoint - Interface to the Qt QPoint class

SYNOPSIS
========

   `use QPoint;'

Member functions
----------------

   new, setX, setY, x, y

DESCRIPTION
===========

   Most of QPoint is operators, and I haven't interfaced the operators yet.
Everything else, what little there is of it, is interfaced.

RESTRICTIONS
============

   The functions rx() and ry() will not be interfaced to PerlQt unless
there is sufficient demand for it, or lvalue Perl XSUBs become a reality.

SEE ALSO
========

   QPoint(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPointArray,  Next: QPopupMenu,  Prev: QPoint,  Up: Module List

Interface to the Qt QPointArray class
*************************************

NAME
====

   QPointArray - Interface to the Qt QPointArray class

SYNOPSIS
========

   `use QPointArray;'

Member functions
----------------

   new, at, boundingRect, copy, fill, makeArc, makeEllipse, point,
putPoints, quadBezier, setPoint, setPoints, translate

DESCRIPTION
===========

   Many of the functions in the original QPointArray used nPoints to
specify the number of arguments or elements in *points. Perl is fortunatly
better than that, so just ditch nPoints and arrays of QCOORD's. Just type
the arguments in a list starting from where the nPoints would be.

SEE ALSO
========

   QPointArray(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPopupMenu,  Next: QPrinter,  Prev: QPointArray,  Up: Module List

Interface to the Qt QPopupMenu class
************************************

NAME
====

   QPopupMenu - Interface to the Qt QPopupMenu class

SYNOPSIS
========

   `use QPopupMenu;'

   Inherits QTableView and QMenuData.

   Requires QPoint.

Member functions
----------------

   new, popup

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPrinter,  Next: QPushButton,  Prev: QPopupMenu,  Up: Module List

Interface to the Qt QPrinter class
**********************************

NAME
====

   QPrinter - Interface to the Qt QPrinter class

SYNOPSIS
========

   `use QPrinter;'

Member functions
----------------

   new, abort, aborted, creator, docName, fromPage, maxPage, minPage,
numCopies, newPage, orientation, outputFileName, outputToFile, pageSize,
printerName, printProgram, setup, setCreator, setDocName, setFromTo,
setMinMax, setNumCopies, setOrientation, setOutputFileName,
setOutputToFile, setPageSize, setPrinterName, setPrintProgram, toPage

DESCRIPTION
===========

   What you see is what you get.

EXPORTED
========

   The `%Orientation' and `%PageSize' hashes are exported to the user's
namespace. Their keys correspond to the matching enums in QPainter.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QPushButton,  Next: QRadioButton,  Prev: QPrinter,  Up: Module List

Interface to the Qt QPushButton class
*************************************

NAME
====

   QPushButton - Interface to the Qt QPushButton class

SYNOPSIS
========

   `use QPushButton;'

   Inherits QButton.

Member functions
----------------

   new, autoDefault, isDefault, setAutoDefault, setDefault

DESCRIPTION
===========

   Fully interfaced.

SEE ALSO
========

   QPushButton(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QRadioButton,  Next: QRangeControl,  Prev: QPushButton,  Up: Module List

Interface to the Qt QRadioButton class
**************************************

NAME
====

   QRadioButton - Interface to the Qt QRadioButton class

SYNOPSIS
========

   `use QRadioButton;'

   Inherits QButton.

Member functions
----------------

   new, isChecked, setChecked

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QRangeControl,  Next: QRect,  Prev: QRadioButton,  Up: Module List

Interface to the Qt QRangeControl class
***************************************

NAME
====

   QRangeControl - Interface to the Qt QRangeControl class

SYNOPSIS
========

   `use QRangeControl;'

Member functions
----------------

   new, addLine, addPage, lineStep, maxValue, minValue, pageStep, setRange,
setSteps, setValue, subtractLine, subtractPage, value

DESCRIPTION
===========

   What you see is what you get

SEE ALSO
========

   qrangecontrol(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QRect,  Next: QRegion,  Prev: QRangeControl,  Up: Module List

Interface to the Qt QRect class
*******************************

NAME
====

   QRect - Interface to the Qt QRect class

SYNOPSIS
========

   `use QRect;'

   Requires QPoint and QSize.

Member functions
----------------

   new, bottom, bottomLeft, bottomRight, center, contains, coords, height,
intersect, intersects, isEmpty, isNull, isValid, left, moveBottomLeft,
moveBottomRight, moveBy, moveCenter, moveTopLeft, moveTopRight, normalize,
rect, right, setBottom, setCoords, setHeight, setLeft, setRect, setRight,
setSize, setTop, setWidth, setX, setY, size, top, topLeft, topRight, unite,
width, x, y

DESCRIPTION
===========

   Everything but the operators is fully interfaced.

SEE ALSO
========

   QRect(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QRegion,  Next: QScrollBar,  Prev: QRect,  Up: Module List

Interface to the Qt QRegion class
*********************************

NAME
====

   QRegion - Interface to the Qt QRegion class

SYNOPSIS
========

   `use QRegion;'

   Requires QPoint, QPointArray, and QRect.

Member functions
----------------

   new, contains, intersect, isEmpty, isNull, subtract, translate, unite,
xor

DESCRIPTION
===========

   Everything but the operators has been successfully interfaced.

SEE ALSO
========

   QRegion(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QScrollBar,  Next: QSize,  Prev: QRegion,  Up: Module List

Interface to the Qt QScrollBar class
************************************

NAME
====

   QScrollBar - Interface to the Qt QScrollBar class

SYNOPSIS
========

   `use QScrollBar;'

   Inherits QWidget and QRangeControl.

Member functions
----------------

   new, orientation, setOrientation, setRange, setTracking, setValue,
tracking

DESCRIPTION
===========

   Nothing unusual, everything listed is interfaced.

EXPORTED
========

   The `%Orientation' hash is exported into the user's namespace. The
elements of `%Orientation' are `Horizontal' and `Vertical', and they
represent the possible orientations of the scrollbar.

SEE ALSO
========

   QScrollBar(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QSize,  Next: QSlider,  Prev: QScrollBar,  Up: Module List

Interface to the Qt QSize class
*******************************

NAME
====

   QSize - Interface to the Qt QSize class

SYNOPSIS
========

   Requires QPoint.

Member functions
----------------

   new, height, isEmpty, isNull, isValid, setHeight, setWidth, width

DESCRIPTION
===========

   Rumors about the lack of operators in PerlQt's QSize are true!

SEE ALSO
========

   QSize(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QSlider,  Next: QTabBar,  Prev: QSize,  Up: Module List

Interface to the Qt QSlider class
*********************************

NAME
====

   QSlider - Interface to the Qt QSlider class

SYNOPSIS
========

   `use QSlider;'

   Inherits QWidget and QRangeControl.

Member functions
----------------

   new, addStep, orientation, setOrientation, setTickmarks, setTracking,
setValue, sliderRect, subtractSteps, tickInterval, tickmarks, tracking

DESCRIPTION
===========

   What you see is what you get.

EXPORTED
========

   The `%Orientation' and `%TickSetting' hashes are exported into the
user's namespace. The elements of `%Orientation' are `Horizontal' and
`Vertical', and they represent the possible orientations of the slider. The
`%TickSetting' hash has all the tick setting constants.

SEE ALSO
========

   qslider(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QTabBar,  Next: QTabDialog,  Prev: QSlider,  Up: Module List

Interface to the Qt QTabBar class
*********************************

NAME
====

   QTabBar - Interface to the Qt QTabBar class

SYNOPSIS
========

   `use QTabBar;'

   Inherits QWidget.

Member functions
----------------

   new, addTab, isTabEnabled, setTabEnabled

QTab
----

     $tab = new QTab;
     $$tab{label} = "Hello World";
     $$tab{r} = new QRect(1, 2, 3, 4);
     $$tab{enabled} = 1;
     $$tab{id} = 10;

DESCRIPTION
===========

   What you see is what you get.

NOTES
=====

   QTab is a tied hash reference which accesses a real QTab.  keys() does
not work on a QTab.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QTabDialog,  Next: QTableView,  Prev: QTabBar,  Up: Module List

Interface to the Qt QTabDialog class
************************************

NAME
====

   QTabDialog - Interface to the Qt QTabDialog class

SYNOPSIS
========

   `use QTabDialog;'

   Inherits QDialog.

Member functions
----------------

   new, addTab, hasApplyButton, hasCancelButton, hasDefaultButton,
isTabEnabled, setApplyButton, setCancelButton, setDefaultButton,
setTabEnabled

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QTableView,  Next: QTimer,  Prev: QTabDialog,  Up: Module List

Interface to the Qt QTableView class
************************************

NAME
====

   QTableView - Interface to the Qt QTableView class

SYNOPSIS
========

   `use QTableView;'

   Inherits QFrame.

DESCRIPTION
===========

   Empty.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QTimer,  Next: QToolTip,  Prev: QTableView,  Up: Module List

Interface to the Qt QTimer class
********************************

NAME
====

   QTimer - Interface to the Qt QTimer class

SYNOPSIS
========

   `use QTimer;'

   Inherits QObject.

Member functions
----------------

   new, changeInterval, isActive, singleShot, start, stop

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QToolTip,  Next: QWMatrix,  Prev: QTimer,  Up: Module List

Interface to the Qt QToolTip and QToolTipGroup classes
******************************************************

NAME
====

   QToolTip - Interface to the Qt QToolTip and QToolTipGroup classes

Member functions
----------------

SYNOPSIS
========

   `use QToolTip;'

DESCRIPTION
===========

   What you see is what you get.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QWMatrix,  Next: QWidget,  Prev: QToolTip,  Up: Module List

Interface to the Qt QWMatrix class
**********************************

NAME
====

   QWMatrix - Interface to the Qt QWMatrix class

SYNOPSIS
========

   `use QWMatrix;'

   Requires QPoint, QPointArray, and QRect.

Member functions
----------------

   new, dx, dy, invert, m11, m12, m21, m22, map, reset, rotate, scale,
shear, setMatrix, translate

DESCRIPTION
===========

   Except for the operators, fully interfaced.

SEE ALSO
========

   QWMatrix(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QWidget,  Next: QWindow,  Prev: QWMatrix,  Up: Module List

Interface to the Qt QWidget class
*********************************

NAME
====

   QWidget - Interface to the Qt QWidget class

SYNOPSIS
========

   `use QWidget;'

   Inherits QObject and QPaintDevice.

   Requires QEvent, QFont, QPixmap, QPoint, QRect, and QSize.

Member functions
----------------

   new, adjustSize, backgroundColor, backgroundPixmap, caption,
childrenRect, clearFocus, close, drawText, erase, focusPolicy, font,
foregroundColor, frameGeometry, geometry, grabKeyboard, grabMouse,
hasFocus, hasMouseTracking, height, hide, icon, iconText, iconify,
isActiveWindow, isDesktop, isEnabled, isFocusEnabled, isModal, isPopup,
isTopLevel, isUpdatesEnabled, isVisible, keyboardGrabber, lower,
mapFromGlobal, mapFromParent, mapToGlobal, mapToParent, maximumSize,
minimumSize, mouseGrabber, move, pos, raise, recreate, rect,
releaseKeyboard, releaseMouse, repaint, resize, scroll, setActiveWindow,
setBackgroundColor, setBackgroundPixmap, setCaption, setEnabled,
setFixedSize, setFocus, setFocusPolicy, setFont, setGeometry, setIcon,
setIconText, setMaximumSize, setMinimumSize, setMouseTracking,
setSizeIncrement, setStyle, setUpdatesEnabled, show, size, sizeHint,
sizeIncrement, style, topLevelWidget, update, width, winId, x, y

Virtual functions
-----------------

   mouseMoveEvent, mousePressEvent, mouseReleaseEvent, paintEvent,
resizeEvent

DESCRIPTION
===========

   Every function made available to Perl is meant to be interfaced
identically to C++ Qt.

EXPORTED
========

   The `%FocusPolicy' and `%WFlags' hashes are exported into the user's
namespace.

   `%FocusPolicy' contains all of the constants in QWidget that end in
Focus.  That trailing *Focus* is removed from the end of the keys for
brevity.

   The `%WFlags' hash is much more involved. It contains all of the
`WState_*', `WType_*', and `WStyle_*' flags, as well as quite a few others
that begin with W. You can get a full list of them from `qwindefs.h'.

   But you won't find these constants exactly as they're spelled out in
there.  I've stripped all the leading W's, for example. And all of the
constants which have an underscore in them have been split up into two
components based on the underscore. I think a few examples are in order.

     Was: WStyle_NormalBorder
     Now: $WFlags{Style}{NormalBorder}
     Was: WState_TrackMouse
     Now: $WFlags{State}{TrackMouse}
     Was: WPaintDesktop
     Now: $WFlags{PaintDesktop}

   You can hopefully figure out the rest yourself.

SEE ALSO
========

   QWidget(3qt)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: QWindow,  Next: Qt,  Prev: QWidget,  Up: Module List

Interface to the Qt QWindow class
*********************************

NAME
====

   QWindow - Interface to the Qt QWindow class

SYNOPSIS
========

   `use QWindow;'

   Inherits QWidget.

Member functions
----------------

   new

DESCRIPTION
===========

   Not much here.

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: Qt,  Next: Qtk/QuickTk,  Prev: QWindow,  Up: Module List

A Perl module interface to Qt
*****************************

NAME
====

   Qt - A Perl module interface to Qt

SYNOPSIS
========

   `use Qt;'

   Requires QApplication and QGlobal.

DESCRIPTION
===========

   The Qt module itself only creates a $qApp and exports some QGlobal
imports.

   This module is not the whole of the Qt interface, though. Each header in
Qt which holds a class is represented by a module with the name of that
class. Classes like QWidget and QApplication are represented by modules of
the same name. QResizeEvent is not a module, but rather is part of the
QEvent module, just as the QResizeEvent class is a part of `qevent.h'.

   Each class header that has been interfaced to Perl has a pod attached
which describes the function interface from Qt.

EXPORTED
========

   The Qt module exports $qApp and `&qRound'.

SEE ALSO
========

   QApplication(3qt), QApplication(3), QGlobal(3)

AUTHOR
======

   Ashley Winters <jql@accessone.com>


File: pm.info,  Node: Qtk/QuickTk,  Next: Qtk/QuickTk/details,  Prev: Qt,  Up: Module List

A Simpler Syntax for Perl-Tk GUI Building
*****************************************

NAME
====

   Qtk::QuickTk - A Simpler Syntax for Perl-Tk GUI Building

SYNOPSIS
========

     use Tk;
     use Qtk::QuickTk

     # need to set $filename, e.g.:  my $filename='miniapp.qtk';

     my $app=Qtk::Quicktk->new($filename);
     die "QuickTk constructor unable to read GUI spec: $filename\n"
       unless defined $app;

     MainLoop;die "QuickTk fell through past MainLoop\n";

   or, alternatively, make a QuickTk script directly executable, with the
following first line (see full demo script in EXAMPLES, below:

     exec /usr/bin/perl -M'Qtk::QuickTk=app' -e app $0;exit

REQUIRES
========

   *QuickTk* uses modules:   *Text::TreeFile* (optionally), Tk,
FileHandle, Carp, English, Exporter and *Autoloader*.

DESCRIPTION
===========

   *QuickTk* supports a simplified syntax for specifying GUI-based
applications using *perl-tk* (module `Tk.pm' and friends).  A companion
module, `Text::TreeFile', supports comments, include files, continuation
lines and special interpretation of a strict indentation convention to
indicate tree-like hierarchical nesting.  Each node of a QuickTk GUI
specification is a character string which succinctly and clearly specifies
the properties of a GUI widget or event binding.  Such specification
documents are quick and easy to write, read and maintain.

OPTIONS
=======

   The GUI specification can be provided to *QuickTk* in any of several
forms, the generated code can be logged to a file, and execution of the
code can be avoided, to allow code-generation only.

EXAMPLE
=======

     -------------- executable as a shell script -------------------------------
     exec /usr/bin/perl -M'Qtk::QuickTk=app' -e app $0;exit
     #   file:  miniapp

     m MainWindow      title:'QuickTk Minimal Demo'
       mb Frame        side:top fill:x :
         f Menubutton  side:left       : text:File
           o c         label:Open sub:my($wid)=@_;
                         ...my $out=$$w{mts};my $tf=$$w{tf};
                         ...$$gl{efile}=$tf->Show;$$gl{eww}=0;
                         ...my $fh=new FileHandle "<$$gl{efile}";
                         ...while(<$fh>) { $out->insert('end',$_); }
                         ...close $fh;$out->yview('1.0');print "ok 2\n";
           q c         label:Quit sub:print "ok 8\n";exit;
         t Menubutton  side:left       : text:Tool
           d c         label:'Directory Listing'
                         ... sub:$$gl{widgets}{mts}->insert('end',
                         ...  `pwd`);$$gl{widgets}{mts}->insert('end',
                         ...  `ls -alF`);print "ok 3\n";
           s c         label:Satisfaction sub:print "ok 4\n";
         h Menubutton  side:right      : text:Help
           a c         label:About sub:$$gl{widgets}{mts}->insert('end',
                         ... 'this is a demo of perl module Qtk::QuickTk');
                         ... print "ok 5\n";
       tb Frame        side:top fill:x :
         d Button      side:left       : text:Dir
                         ... sub:$$w{mts}->insert('end',`ls -alF`);
                         ... print "ok 6\n";
         q Button      side:left       : text:Geom sub:$$w{mts}->insert('end',
                         ... "geom: ".$$w{m}->geometry."\n");
                         ... print "ok 7\n";
       ts Scrolled     side:top fill:both expand:1 : Text: scrollbars:osoe
       tf FileSelect   nopack                           : directory:.
     -------------- end of executable shell script example ---------------------

FILE FORMAT
===========

   By default, `Qtk::QuickTk' uses the `Text::TreeFile' module to read a
file containing a GUI specification, in the *QuickTk* mini-language.  The
low-level format of this file is as follows.  Each widget is specified in
a node of the tree in such a file.  The language for widget specifications
is described further below.

   The file format supported relies upon indentation of text strings, to
indicate hierarchical nesting for the tree structure.  Strict indentation
(of two space characters per nesting level) is used to represent
parent-child structure.

Comments
--------

   A line consisting exclusively of whitespace, or a line beginning with
either the pound-sign ("#"), the semicolon (";"), or the forward slash
("/") character will be ignored as a comment.    In the very first line of
a file, the initial characters, "exec ", will indicate a comment line.

Continuation Lines
------------------

   A line beginning with whitespace followed by three period (".")
characters, will be concatenated to the previous line, as a continuation.
The preceding end-of-line, the initial whitespace and the ellipsis ("...")
will be removed and otherwise ignored, to allow long strings to be
represented within line-length constraints.

Include Files
-------------

   In addition, any line consisting of indentation followed by "include"
will be interpreted as a file-include request.  In this case, succeeding
whitespace followed by a file specification will cause the contents of the
named file to be substituted at that point in the tree.  The included file
will be sought in the same directory as the file including it.

WIDGET SPECIFICATIONS
=====================

   The basic format for GUI widget specifications is a text string that
has two parts.  The first is an ID section which identifies the widget,
and the second is an arguments section which provides the specifics of how
the widget is to be configured.

Widget ID
---------

   There are four kinds of specifications, each with a variation in the
details of these two parts.  In the most common case (that for *MainWindow*
and most other widgets), the ID section is made of two subparts.  First is
the name your script can use to reference the widget later, and second is
the widget type name, chosen from the many available in the Tk widget
library (e.g. Button, *MainWindow*, Menubutton).  In the special case of a
menu item, the second part of the ID section can be a single letter
identifying one of five types of available menu items, for short, or the
name of the type itself.  The name subpart must be unique only within the
same level of indentation under a parent widget, because the name you will
use to refer to the widget will usually (automatically) be the
concatenation of its name with all its ancestors' names.

     For specifications of bindings of events to actions, the ID part is a
     single event identifier enclosed in angle brackets ("Less_Than_Special_Sequence" and "Greater_Than_Special_Sequence").

   See `"EXAMPLES"' in this node, or `Qtk::QuickTk::scripts(3pm)' in this
node, for clarification.

   Here are samples of each of the four kinds of specifications:

     m    MainWindow                title:'QuickTk Demo'
     f    Menubutton    side:left : text:File
     o    c                         label:Open sub:exit;
     <CR>                           sub:$$gl{command}=$$gl{inputline};

Widget Arguments
----------------

   Each of the four kinds of specifications can have arguments provided.
There are two categories of arguments, and these are separated by a colon
(":") character which, itself, is surrounded by spaces.  The first type of
arguments is the "packing options" and the second is the "configuration
options".  The packing options (and the colon delimiter) are not specified
for three of the four kinds of specifications.  These are the MainWindow,
the menu items, and the event bindings.  The packing options are used for
the most common widget specifications - the ones for generic widgets - so
these specifications will always have the space-surrounded colon delimiter
unless no configuration option arguments need to be specified.

   To write these specifications you must be acquainted with the perl-tk
(module `Tk.pm') library of widgets and how to use it.  The QuickTk module
provides a good many simplifications of syntax, though, and details of
these are described in `Qtk::QuickTk::details(3pm)' in this node, *Note
Qtk/QuickTk/scripts: Qtk/QuickTk/scripts,, and demonstrated in the example
scripts.

CAVEATS
=======

   *QuickTk* provides none of the GUI-building widgets, functions or other
facilities.  It provides only for simplified syntax for accessing the
capabilities and features of `perl-tk' (the perl module, *Tk(3pm)* and
friends), so familiarity with those materials is prerequisite to using
*QuickTk*.

AUTHOR
======

   John Kirk <`johnkirk@dystanhays.com'>

COPYRIGHT
=========

   Copyright (c) 2000 John Kirk. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

SEE ALSO
========

   `Text::TreeFile(3pm)' in this node - for the low-level file format it
supports,

   `Qtk::QuickTk::scripts(3pm)' in this node - for exhaustive description
of the syntax,

   `Qtk::QuickTk::details(3pm)' in this node - for precise definition of
usage details,

   `Qtk::QuickTk::internals(3pm)' in this node - for implementation
details,

   `Tk::UserGuide(3pm)' in this node - for an introduction to perl-tk,

   `widget(1)' in this node - for examples of most of the perl-tk widgets,
etc.,

   and `http://perl.dystanhays.com/jnk' - for related material on this
module.

BUGS
====

   Uses (deprecated for libraries) `English(3pm)', which should be removed.

   Also, exceptions are handled poorly, inconsistently and unclearly.  The
`Carp(3pm)' module should be used, the behavior should be made more clear,
and the exceptions should be handled in a consistent manner.

   Documentation is incomplete (although the module code is very short,
thus somewhat accessible) and examples are not very thorough.

   The code is ready for an overhaul to reduce near-duplication and improve
modularity.


File: pm.info,  Node: Qtk/QuickTk/details,  Next: Qtk/QuickTk/internals,  Prev: Qtk/QuickTk,  Up: Module List

precise definition of usage details
***********************************

NAME
====

   Qtk::QuickTk::details - precise definition of usage details

SYNOPSIS
========

     use Tk;
     use Qtk::QuickTk

     # need to set $filename, e.g.:  my $filename='miniapp.qtk';

     my $app=Qtk::Quicktk->new($filename);
     die "QuickTk constructor unable to read GUI spec: $filename\n"
       unless defined $app;

     MainLoop;die "QuickTk fell through past MainLoop\n";

   or, alternatively, make a QuickTk script directly executable, with the
following first line (see full demo script in EXAMPLES, below:

     exec /usr/bin/perl -M'Qtk::QuickTk=app' -e app $0;exit

DESCRIPTION
===========

   (Introduction not written yet.)

FUNCTION: new [ spec, [ *codeout*, [ *genonly* ] ] ]
====================================================

   The constructor (function "new") for module *Qtk::QuickTk* can be
invoked with zero, one, two or three parameters.  The first is a GUI
specification, which can take several forms, as below, under `"spec"' in
this node; the second, a filename for logging generated code; and the
third, a generate-only flag.  If no parameters are specified, an object (a
blessed reference to a hash) will be returned with only the prototype
entries present.  In this case one might create a GUI spec by other
external means and put it into the hash.

Parameter: spec
---------------

   If at least one parameter is specified, the first will be taken to be
the specification for a GUI based application.  This spec may be in one of
three forms:  (1) a filename, (2) a reference blessed into the
*Text::TreeFile* class, or (3) a reference to a tree of text strings.

spec parameter: as filename
     If the spec parameter is a scalar, but not a reference, it will be
     interpreted as a filename and passed to module *Text::TreeFile* to
     create a tree of strings.  This tree will be used as the GUI
     specification for further processing.

spec parameter: as *Text:TreeFile* ref
     If the spec parameter is a reference that has been blessed into the
     *Text::TreeFile* class, the resulting tree of strings will be used as
     the GUI specification for further processing.

spec parameter: as tree of strings
     If the spec parameter is a reference to an array of the correct form
     to be a string tree node, it will be interpreted as the GUI
     specification for further processing.

Parameter: *codeout*
--------------------

   If at least two parameters are specified in the call to new(), the
second will be interpreted as a filename for output logging of the
generated *perl-tk* code.  If the undef value is specified, then logging
will not occur.  If this parameter is not specified, the default is not to
log generated code to a file at all.

Parameter: *genonly*
--------------------

   If three parameters are specified in the call to new(), the third will
be interpreted as a flag indicating whether to execute the *perl-tk* code
generated.  If the undef value is specified or this parameter is not
specified, the default is to execute the code generated.  If a value is
specified, then no generated *perl-tk* code will be executed.

FUNCTION: app [ [ *genonly* ] *gfilename* ]
===========================================

   *app()* will expect the first argument to contain the name of the
*QuickTk* script to execute (often, the script that invoked it).

FUNCTION: *createwidget* args *specname*
========================================

   *createwidget()* will expect the first argument to be a reference to an
array containing values to which the *QuickTk* script widget spec refers
by names $0, $1, ..., and the second argument to be a string which is the
name of the widget specified in the script with the 'nocreate' packing
option set.  This would normally be called by a callback specified
somewhere in the script.

FUNCTION: *showglobals*
=======================

   (Not written yet.)

FUNCTION: *logit*
=================

   (Not written yet.)

FUNCTION: logg
==============

   (Not written yet.)

TEST SCRIPT: test.pl
====================

   (Not written yet.)

EXPORTS
=======

   Nothing is exported by default.  Functions *app()*, *createwidget()*,
*showglobals()*, *logit()*, and *logg()* may be imported on request.  The
module's new() function returns a blessed reference to a hash which
contains a number of data items. (Refer to *Note Qtk/QuickTk/internals:
Qtk/QuickTk/internals, for details, if you want them.)  This hash acts as
a global repository for variables accessible to the application.  See
*Note Qtk/QuickTk/scripts: Qtk/QuickTk/scripts, for instruction and sample
uses of this facility.

EXCEPTIONS
==========

   (Not written yet.)

BUGS
====

   (Not written yet.)


File: pm.info,  Node: Qtk/QuickTk/internals,  Next: Qtk/QuickTk/scripts,  Prev: Qtk/QuickTk/details,  Up: Module List

implementation details
**********************

NAME
====

   Qtk::QuickTk::internals - implementation details

SYNOPSIS
========

     use Qtk::QuickTk;

     sub _loadwidget;
     sub _loadmenitm;
     sub _bindevent;
     sub _getargs;
     sub _gettitle;
     sub _getcommand;
     sub _getsub;
     sub _getini;

DESCRIPTION
===========

     (Nothing written, yet.)


File: pm.info,  Node: Qtk/QuickTk/scripts,  Next: Quantum/Entanglement,  Prev: Qtk/QuickTk/internals,  Up: Module List

exhaustive description of the syntax
************************************

NAME
====

   Qtk::QuickTk::scripts - exhaustive description of the syntax

SYNOPSIS
========

   (example script, actually)

     exec /usr/bin/perl -M'Qtk::QuickTk=app' -e app $0;exit
     m MainWindow         title:'QuickTk Minimal Demo'
       mb Frame           side:top fill:x :
         f Menubutton     side:left       : text:File
           o command      label:Open sub:my($wid)=@_;
                            ...my $out=$$w{mts};my $tf=$$w{tf};
                            ...$$gl{efile}=$tf->Show;$$gl{eww}=0;
                            ...my $fh=new FileHandle "<$$gl{efile}";
                            ...while(<$fh>) { $out->insert('end',$_); }
                            ...close $fh;$out->yview('1.0');print "ok 2\n";
           q command      label:Quit sub:print "ok 8\n";exit;
         t Menubutton     side:left       : text:Tool
           d command      label:'Directory Listing'
                            ... sub:$$gl{widgets}{mts}->insert('end',
                            ...  `pwd`);$$gl{widgets}{mts}->insert('end',
                            ...  `ls -alF`);print "ok 3\n";
           s command      label: Satisfaction sub:print "ok 4\n";
         h Menubutton     side:right      : text:Help
           a command      label:About sub:$$gl{widgets}{mts}->insert('end',
                            ... 'this is a demo of perl module Qtk::QuickTk');
                            ... print "ok 5\n";
       tb Frame           side:top fill:x :
         d Button         side:left       : text:Dir
                          ... sub:$$w{mts}->insert('end',`ls -alF`);
                          ... print "ok 6\n";
         q Button         side:left       : text:Geom sub:$$w{mts}->insert('end',
                          ... "geom: ".$$w{m}->geometry."\n");
                          ... print "ok 7\n";
       ts Scrolled        side:top fill:both expand:1 : Text: scrollbars:osoe
       tf FileSelect      nopack                      : directory:.

DESCRIPTION
===========

   This document attempts to completely specify the *QuickTk*
mini-language.  Everything you need to know to write GUI applications with
this module should appear here, assuming you are familiar with the
*perl-tk* (the `Tk.pm' module, and friends) library to which *QuickTk*
provides simpler access.

   *Note 1:* The best way to get acquainted with how to write scripts is,
of course, to look at examples.  Several of them are provided, chosen to
be representative of a wide range of features exercised.  A plan is afoot
to reference them directly in documentation, where features are described
and, perhaps, vice-versa.

   *Note 2:* Current documentation describes a number of unix-specific
features and ways of operating, without identifying them as non-portable.
(witness the next couple of paragraphs, for instance) *QuickTk* works well
in other contexts, but we've been slow about properly flagging the
caveats.  The plan is to correct the documentation soon.

   The most common way to use *QuickTk* is to make a script in a file whose
first line is the following (Make sure the absolute path reference to your
perl binary executable is correct, though.):

     exec /usr/bin/perl -M'Qtk::QuickTk=app' -e app $0;exit

   When the script is executed by your shell, this should cause perl to be
started (without creating a new process), bringing in the *QuickTk* module
and asking it to import the *app()* function into the *main::* namespace.
Then it executes *app()* and makes the name of your script ($0, above) the
first (the only) command-line argument to the executing perl program.  The
*app()* function will request module *Text::TreeFile* to come back and
read your script into a tree-of-text-strings data structure (respecting
comments, continuation lines, include-file requests, and strict
two-space-per-level indentation to indicate parent-child nesting of tree
nodes) which will then be interpreted and executed by *QuickTk* as a GUI
application specification, where each text string is taken to specify a
widget or event binding.  See `Text::TreeFile(3pm)' in this node for more
details of that format, and `Tk(3pm)' in this node and manpages for the
other `Tk::*(3pm)' modules, for information about the functionality
available to your application.

APPLICATION VARIABLES
=====================

   *QuickTk* provides a hash, returned by the new() constructor, which is
blessed into the *Qtk::QuickTk* class as a namespace for variables which
are "global" to the application.  Perl code included in the script will be
evaluated in a context which provides both a reference to this hash (as
variable, `$gl'), and a reference to another hash within it (as variable,
`$w', which is short for, and synonymous with, `$$gl{widgets}') for
convenience.

   The upshot of this is that the following conventions are enabled, for
referring to variables (objects) in *QuickTk*.  First, to use a global
variable named "var", you specify the syntax, `"$$gl{var}"'.  Second, to
indicate a variable by reference (used in "-textvariable" options, for
instance) you specify the syntax, `"\$$gl{var}"', for the example variable
mentioned above.  Third, to refer to a widget previously created, you use
the name you specified as the very first field in the spec for that widget
("m", in the first example line, below) as the key to either the
`"$gl->{widgets}"' hash (e.g. `$$gl{widgets}{m}', or
`$gl->{widgets}->{m}') or for short, to the `"$w"' hash (e.g.  `$$w{m}',
or `$w->{m}'), for the *MainWindow* widget specified in the first example
line, below.  This is commonly done for the purpose of accessing object
methods of a widget.

   Here are several examples of using application variables:

Example of referencing an already-created widget
------------------------------------------------

   First, a *QuickTk* spec makes a main window, with a title:

     m MainWindow title:'QuickTk Demonstration Application'

   then, later, some code (in a callback, perhaps) gets executed:

     $$w{m}->configure(-title=>'QuickTk (updated) Demo App');
     print "The MainWindow title is now: ",
           $$gl{widgets}{m}->cget(-title),"\n";

   Note that, above, the "m" in `$$w{m}' and in `$$gl{widgets}{m}' is a
direct reference to the "m" which is the first field in the *QuickTk*
widget spec shown just previously.

   Also note that the *MainWindow* is referred-to both via the short
`$$w{m}' form and the longer, more explicit, `$$gl{widgets}{m}' form, in
different places.

   The name by which you refer to a widget in your code ("m", in the
example above) will be the concatenation of all the ancestors' names, and
the one for the current widget, as specified in the name field of your
script's widget spec.  Thus, note in the example in `"SYNOPSIS"' in this
node, a widget is accessed using the name, *"mts"*, as:
`"$$gl{widgets}{mts}"' while the widget is identified with only *"ts"* in
the script.  This is because the *"ts"* widget is a child of parent *"m"*,
yielding *"mts"* as the fully qualified, complete name.

Example of keeping a label updated, directly from an entry field
----------------------------------------------------------------

   These two *QuickTk* widget specs may occur in widely separated parts of
the user interface for an application:

     mce Entry pack:left : textvariable:\$$gl{inp}
     mcp Label pack:left : textvariable:\$$gl{inp}

   As text is typed into the Entry widget, it will show immediately
(simultaneously) in the Label widget.

Example of updating a label on demand, from an entry field
----------------------------------------------------------

   Text entered into the Entry widget will be kept in the variable named
"input", and the Label widget will show text from the variable named
"display".  Only when the Button is pressed will the text in the variable
named "input" get copied into the variable named "display" and, thus, be
displayed by the Label.

     mce Entry pack:left : textvariable:\$$gl{input}
     mcp Label pack:left : textvariable:\$$gl{display}
     mcb Button pack:left : text:Update sub:$$gl{display}=$$gl{input};

SCRIPT SYNTAX
=============

   The remainder of this document is devoted to enumerating and describing
use of the (mostly syntactic) features that the *QuickTk* language
provides.  We will call each node of the tree representing your GUI
specification either a "node", a "widget spec", or a "spec" (for short).
There are some commonalities among all specs, but differences are
important among the formats of the four basic spec types:

(1) the 'toplevel' spec type
----------------------------

   Either a *MainWindow* or a *TopLevel* widget spec.

(2) the 'menu item' spec type
-----------------------------

   This type refers to widgets that are children of a Menubutton or Menu
widget.  The Tk library provides five of these, as described subsequently
in this document.

(3) the 'event binding' spec type
---------------------------------

   This is sometimes referred to as an event or binding, for short.  This
type is a spec that's not a widget but, rather, a binding of an action to
a particular event that may occur in the parent widget's window.

(4) the 'generic widget' spec type
----------------------------------

   This type of spec is sometimes called just widget, for short.  This is
the most common spec, referring to any other widget in the Tk library's
repertoire not mentioned in the first three categories.

Spec Forms
----------

   All specs are of the form:

     <ID section> <arguments section>

   and the arguments section can have either or both of:

     <packing options> : <configuration options>

   although the composition of each (ID or arguments) section will be
somewhat different among the four main spec types.  Options are all
specified as:

     <option name>:<option value>

   but note that the colon (":") character, above, *must not* have any
surrounding spaces while the one separating the configuration options from
the packing options (shown previously) must be surrounded by spaces.

   Looking at the examples provided will give the best introduction to
writing specifications, but this document offers precise definition of the
conventions for reference use.  Of course, the module code is relatively
brief, so reading that can be a practical arbiter in case of failure to
communicate on the part of this document.

   We'll describe the differences among the four main spec types first for
the ID section, and next for the arguments section.  Then, we will
enumerate the details (held in common among all the spec types) of
specifying option arguments.

ID SECTION
==========

   The ID section always follows the indentation and is delimited from any
following arguments by spaces.  The differences, for each main spec type
are as follows:

Toplevel and Generic Widget Specs
---------------------------------

   The ID section for these specs has two parts, delimited by spaces.  The
first part is a name that will be used as a hash key to allow the
application to refer directly to the widget subsequently to its creation.
The second part is the name of the widget type (chosen from the *perl-tk*
library documentation) for the widget to be created.  e.g.  Button,
Menubutton, *MainWindow*, or *TopLevel*.

Menu Item Widget Specs
----------------------

   The ID section for these specs has two parts, delimited by spaces.  The
first part is a name that will be used to construct a hash key to allow
the application to refer directly to the widget subsequently to its
creation.  The second part can be either a single character indicating one
of the five widget types provided by Tk, or the name that Tk uses, itself,
as shown in the chart below.  The widget types allowed are:

     letter  Tk name         description of effect when menu item is chosen
     ------  -----------     -----------------------------------------------
         c   command      -- an action to perform

     m   cascade      -- a submenu to post

     -   separator    -- no action (separates groups of menu items)

     k   checkbutton  -- sets values of any of several boolean variables

     r   radiobutton  -- sets one of several values for a variable

Event Binding Specs
-------------------

   The ID section for these specs has only a single part, recognized by
surrounding angle brackets ("<" and ">").  This part identifies the event
(which may occur in the parent widget's window) that is to be bound to the
action specified in the arguments section.  Examples of events are:
"<Tab>", "<CR>", "<Button>", "<Double-Click>", "<Right-Click>", "<A>" and
"<Ctrl-A>".

ARGUMENTS SECTION
=================

   The ID section always follows the indentation and is delimited from any
following arguments by spaces.  The differences, for each main spec type
are as follows:

Generic Widget Specs
--------------------

   There are three formats, depending on whether you have options in both,
or just one category:

     <packing options> : <configuration options>
     : <configuration options>
     <packing options>

Toplevel and Menu Item Widget Specs
-----------------------------------

   These widget types take no <packing options>, so the format is simple:

     <configuration options>

Event Binding Specs
-------------------

   This kind of spec only needs the action to be bound to the event:

     <action bound to event>

OPTION SPECS
============

   There are six variations of the form of a single item in the list of
<packing options> or <configuration options> in the <arguments section>,
as follows.  The <option name> and <option value>, except where noted as
otherwise, are always chosen from available possibilities documented in
the *perl-tk* documentation.  The six syntax variations are:

(1) The generic case, for an option spec
----------------------------------------

   The most generic case, if none of the other cases applies, has an
<option name> and an <option value>, neither of which contains embedded
space characters.  These are separated by a colon (":") character which
has no space characters adjacent to it.  The format is:

     <option name>:<option value>

(2) The option value contains embedded spaces
---------------------------------------------

   The <option value> may be single-quoted, to allow embedded space
characters within it.  The format is:

     <option name>:'<option value>'

   <option value> may be null or not.  This is handled differently,
depending on whether it occurs as a packing or configuration option.

(3) The option value is absent, but the colon is specified
----------------------------------------------------------

   The <option value> may be absent.  This is used for lone (not of the
<name>=><value> form) leading arguments to the configuration or geometry
manager functions in *perl-tk*.  The format is:

     <option name>:

   This is handled differently, depending on whether it occurs as a
packing or configuration option.

(4) The option value is absent, and the colon is omitted
--------------------------------------------------------

   The <option value> may be absent, and the colon delimiter omitted, in
certain cases (for the ones not specially introduced by *QuickTk*).  The
format for these option items is, simply:

     <option name>

   This applies to any option name that's not a <special option>

(5) Special options; there is no colon, nor an option value
-----------------------------------------------------------

   *QuickTk* introduces some special-function <option name> choices, to
enable a way for a script to invoke functionality the generic form of the
syntax doesn't provide.  These occur only in a list of <packing options>.
The format for these option items is, simply:

     <special option>

   There are five of these special-function <option name> choices.  Their
names and meanings are:

(1) 'nocreate'
     This widget spec should be remembered for use later, but should not
     be created on startup.  A callback specified as the action for some
     widget or event may call the *createwidget* function to create
     instances of this widget when it is needed.

(2) 'nopack'
     This widget should be created, but not mapped to the screen to become
     visible on startup.  It may be made visible on demand, later.

(3) 'pack'
     This is the default case, and is usually omitted.  The possibility
     for specifying it explicitly is included only for consistency.

(4) 'place'
     The *place()* geometry management function should be used instead of
     pack().  The other <packing options> are passed to the placer, rather
     than the packer.

(5) 'grid'
     The *grid()* geometry management function should be used instead of
     pack().  The other <packing options> are passed to the gridder,
     rather than the packer.

(6) Special 'last' options; simplify syntax for longer values
-------------------------------------------------------------

   *QuickTk* introduces a some additional special-function <option name>
choices, that may occur *only* as the very last option in a spec node.
These, thus, allow embedded spaces, and are processed specially for extra
convenience.  As it turns out, these occur only in the <configuration
options> list of the <arguments section>.  The format is:

     <last option>:<everything to the end of the spec>

   There are four of these special <option name> choices, each of which
applies only to certain widget types, as indicated:

'ini' (MainWindow widget)
     The entire string after the colon will be executed as perl code,
     immediately.  This allows a script to initialize variables, etc.

'ttl' (MainWindow or TopLevel widget)
     The entire string after the colon will become the "-title"
     configuration option for the widget.  This allows long titles to
     contain embedded space characters, without having to be explicitly
     quoted.

'cmd' (generic or menuitem widget)
     The entire string after the colon will be parsed as of either of the
     following forms:

          <function> ( <args> )
            or:   <function>

     where <function> must not contain embedded space or parenthesis ("(")
     characters and may be followed by space characters, and a character
     string surrounded by parentheses ("(" and ")") may optionally be
     present.  This will be reformatted to become a "-command"
     configuration option to the widget which specifies a callback in the
     form:

          "-command"=>[main::<function>,$gl,<args>]

     This makes the callback refer to a function defined in the *main::*
     namespace, which is called with an implicit reference to the
     *QuickTk* blessed hash as its first argument (somewhat like an object
     method), to allow the function code to access effectively "global"
     variables for the application.  (See `"APPLICATION VARIABLES"' in
     this node, above.)

'sub' (generic or menuitem widget)
     The entire string after the colon will be surrounded with "sub { "
     and " }", and thus evaluated as an anonymous function callback as the
     value of a "-command=>" configuration option to the widget.

GENERATED CODE
==============

   The generated *perl-tk* code, for arguments to the widget configuration
function or the geometry management function will be as:

option name usually gets initial hyphen, and is quoted
------------------------------------------------------

   <option name> becomes "-<option name>"=> if it has a value specified.
Otherwise, it (a stand-alone option) is simply surrounded by double-quote
characters.

packing option values are quoted
--------------------------------

   All values specified for packing options are surrounded with
double-quote characters.

most configuration option values get quoted
-------------------------------------------

   Generally, values for configuration options will be surrounded with
double-quote characters.  The exceptions are:

values starting with a dollar-sign character
     A value which has "$" as its first character is taken to indicate a
     variable in *QuickTk*'s hash whose key is what follows the "$", so it
     is modified to: $$gl{<option value without "$">}.

values starting with the back-slant character
     A value which has "\" as its first character is taken to indicate a
     variable in *QuickTk*'s hash whose key is what follows the "\", so it
     is modified to: \$$gl{<option value without "\">}.

values surrounded with square brackets
     A value which is surrounded with "[" and "]" is taken to be a
     reference to an anonymous array specifying a callback and its
     arguments, and is used as-is.

a null string value specified with single-quotes
     A value which is a null string specified as """ will be used as-is.
     This is a way of making sure the option name is not interpreted
     specially as a lone option even when the value should be empty.


