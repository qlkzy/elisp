This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Math/LP/Constraint,  Next: Math/LP/LinearCombination,  Prev: Math/LP,  Up: Module List

representation of constraints in Math::LP objects
*************************************************

NAME
====

   Math::LP::Constraint - representation of constraints in Math::LP objects

SYNOPSIS
========

     use Math::LP::Constraints qw(:types); # imports constraint types

     # make the constraint x1 + 2 x2 <= 3
     $x1 = new Math::LP::Variable(name => 'x1');
     $x2 = new Math::LP::Variable(name => 'x2');
     $constraint = new Math::LP::Constraint(
     	lhs  => make Math::LP::LinearCombination($x1,1.0,$x2,2.0),
         rhs  => 3.0,
         type => $LE,
     );

DESCRIPTION
===========

   A Math::LP::Constraint object has the following fields:

lhs
     a Math::LP::LinearCombination object forming the left hand side of the
     (in)equality (Required)

rhs
     a constant number for the right hand side of the (in)equality
     (Defaults to 0)

type
     the (in)equality type, either $LE (<=), $GE (>=) or $EQ (=) (Required)

name
     a string with a name for the constraint (Optional, set by
     Math::LP::add_constraint if not specified)

index
     the index of the constraint in the LP (Set by
     Math::LP::add_constraint)

slack
     the slack of the row in the LP (Set after solving the LP)

dual_value
     the dual value of the row in the LP (Set after solving the LP)

SEE ALSO
========

   *Note Math/LP: Math/LP,, *Note Math/LP/Variable: Math/LP/Variable,,
*Note Math/LP/LinearCombination: Math/LP/LinearCombination, and *Note
Math/LP/Object: Math/LP/Object,

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright(c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: Math/LP/LinearCombination,  Next: Math/LP/Object,  Prev: Math/LP/Constraint,  Up: Module List

linear combination of Math::LP::Variable objects
************************************************

NAME
====

   Math::LP::LinearCombination - linear combination of Math::LP::Variable
objects

SYNOPSIS
========

     use Math::LP::LinearCombination;

     # first construct some variables
     $x1 = new Math::LP::Variable(name => 'x1');
     $x2 = new Math::LP::Variable(name => 'x2');

     # build x1 + 2 x2 from an empty linear combination
     $lc1 = new Math::LP::LinearCombination;
     $lc1->add_var_with_coeff($x1,1.0);
     $lc1->add_var_with_coeff($x2,2.0);

     # alternatively, make x1 + 2 x2 in one go
     $lc2 = make Math::LP::LinearCombination($x1, 1.0,
                                             $x2, 2.0 );

DESCRIPTION
===========

   Any client should not access any other field than the value field.
This field contains the value of the linear combination, typically
obtained in calculate_value(), but it may be set elsewhere (e.g. by the
solve() function in Math::LP).

   The following methods are available:

new()
     returns a new, empty linear combination

make($var1,$coeff1,$var2,$coeff2,...)
     returns a new linear combination initialized with the given variables
     and coefficients. A ref to an array of variables and coefficients is
     also accepted as a legal argument.

add_var_with_coeff($var,$coeff)
     adds a variable to the linear combination with the given coefficient

calculate_value()
     calculates the value of the linear combination. The value is also
     stored in the value field. Requires that the values of all variables
     are defined.

SEE ALSO
========

   *Note Math/LP/Object: Math/LP/Object, and *Note Math/LP/Variable:
Math/LP/Variable,

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright(c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: Math/LP/Object,  Next: Math/LP/Variable,  Prev: Math/LP/LinearCombination,  Up: Module List

base class for objects in the Math::LP family
*********************************************

NAME
====

   Math::LP::Object - base class for objects in the Math::LP family

SYNOPSIS
========

     package Math::LP::XXX; # a new member XXX in the family

     # derive XXX from Object
     use Math::LP::Object;
     use base qw(Math::LP::Object);
     use fields qw(foo bar);

     sub initialize {
         my Math::LP::XXX $this = shift;
         # put XXX specific initialization code here
     }

DESCRIPTION
===========

   Math::LP::Object provides the following methods to classes derived from
it:

new()
     Returns a new object, blessed in the package which it was called for.
     The returned object is a pseudo-hash, with fields specified using the
     fields pragma.

     new() optionally accepts a hash of initial values of the data fields.
     After these values have been set, initialize() is called on the
     object.  Specific initialization code for the derived class is thus
     to be put in the initialize() function of the derived class.

croak($msg)
     Dies with an error message, adding info on the last caller outside
     the Math::LP family.

     croak() can be invoked both as a method and a package function.

SEE ALSO
========

   *Note Base: base,, *Note Fields: fields,

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright(c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: Math/LP/Variable,  Next: Math/Libm,  Prev: Math/LP/Object,  Up: Module List

variables used in linear programs
*********************************

NAME
====

   Math::LP::Variable - variables used in linear programs

SYNOPSIS
========

     use Math::LP::Variable;

     # make a variable named x1
     my $x1 = new Math::LP::Variable(name => 'x1');

     # make an integer variable named x2
     my $x2 = new Math::LP::Variable(name => 'x2', is_int => 1);

     # make a variable named x3 initialized to 3.1415
     my $x3 = new Math::LP::Variable(name => 'x3', value => '3.1415');

DESCRIPTION
===========

DATA FIELDS
-----------

name
     a string with the name of the variable (required)

is_int
     a flag indicating whether the variable can only have integer values
     (optional, defaults to false)

value
     a number representing the value of the variable (optional)

index
     an integer number holding the index of the variable in the matrix of
     the LP the variable is used in (optional)

METHODS
-------

   No methods available.

SEE ALSO
========

   *Note Math/LP: Math/LP, and *Note Math/LP/Object: Math/LP/Object,

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright(c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: Math/Libm,  Next: Math/Logic,  Prev: Math/LP/Variable,  Up: Module List

Perl extension for the C math library, libm
*******************************************

NAME
====

   Math::Libm - Perl extension for the C math library, libm

SYNOPSIS
========

     use Math::Libm ':all';

     print "e = ", M_E, "\n";
     print "pi/2 = ", M_PI_2, "\n";
     print "erf(1) = ", erf(1), "\n";
     print "hypot(3,4) = ", hypot(3,4), "\n";

     my $signgam = 0;
     my $y = lgamma_r(-0.5, $signgam);
     print "signgam=$signgam lgamma=$y\n";

DESCRIPTION
===========

   This module is a translation of the C `math.h' file.  It exports the
following selected constants and functions.

EXPORT
------

   None by default.

Exportable constants
--------------------

     M_1_PI
     M_2_PI
     M_2_SQRTPI
     M_E
     M_LN10
     M_LN2
     M_LOG10E
     M_LOG2E
     M_PI
     M_PI_2
     M_PI_4
     M_SQRT1_2
     M_SQRT2

Exportable functions
--------------------

     double acos(double x)
     double acosh(double x)
     double asin(double x)
     double asinh(double x)
     double atan(double x)
     double atanh(double x)
     double cbrt(double x)
     double ceil(double x)
     double cosh(double x)
     double erf(double x)
     double erfc(double x)
     double expm1(double x)
     double floor(double x)
     double hypot(double x, double y)
     double j0(double x)
     double j1(double x)
     double jn(int n, double x)
     double lgamma_r(double x, int signgam)
     double log10(double x)
     double log1p(double x)
     double pow(double x, double y)
     double rint(double x)
     double sinh(double x)
     double tan(double x)
     double tanh(double x)
     double y0(double x)
     double y1(double x)
     double yn(int n, double x)

AUTHOR
======

   Daniel S. Lewart, <d-lewart@uiuc.edu>

SEE ALSO
========

   *Note Perlfunc: (perl.info)perlfunc,, *Note Math/Complex:
Math/Complex,, *Note POSIX: POSIX,.

BUGS
====

   Only tested on AIX 4.2, FreeBSD 4.0, Linux 2.2.16, and Solaris 2.5.1.
May need some more functions.


File: pm.info,  Node: Math/Logic,  Next: Math/MagicSquare,  Prev: Math/Libm,  Up: Module List

Provides pure 2, 3 or multi-value logic.
****************************************

NAME
====

   Math::Logic - Provides pure 2, 3 or multi-value logic.

SYNOPSIS
========

     use Math::Logic qw( $TRUE $FALSE $UNDEF $STR_TRUE $STR_FALSE $STR_UNDEF ) ;
                     #       1      0     -1     'TRUE'    'FALSE'    'UNDEF'

     use Math::Logic ':NUM' ; # $TRUE $FALSE $UNDEF -- what you normally want

     use Math::Logic ':ALL' ; # All the constants

     use Math::Logic ':STR' ; # $STR_TRUE $STR_FALSE $STR_UNDEF

     # 2-degree logic
     my $true  = Math::Logic->new( -value => $TRUE,  -degree => 2 ) ;
     my $false = Math::Logic->new( -value => $FALSE, -degree => 2 ) ;
     my $x     = Math::Logic->new_from_string( 'TRUE,2' ) ;

     print "true" if $true ;

     # 3-degree logic (non-propagating)
     my $true  = Math::Logic->new( -value => $TRUE,  -degree => 3 ) ;
     my $false = Math::Logic->new( -value => $FALSE, -degree => 3 ) ;
     my $undef = Math::Logic->new( -value => $UNDEF, -degree => 3 ) ;
     my $x     = Math::Logic->new_from_string( 'FALSE,3' ) ;

     print "true" if ( $true | $undef ) == $TRUE ;

     # 3-degree logic (propagating)
     my $true  = Math::Logic->new( -value => $TRUE,  -degree => 3, -propagate => 1 ) ;
     my $false = Math::Logic->new( -value => $FALSE, -degree => 3, -propagate => 1 ) ;
     my $undef = Math::Logic->new( -value => $UNDEF, -degree => 3, -propagate => 1 ) ;
     my $x     = Math::Logic->new_from_string( '( UNDEF, 3, -propagate )' ) ;

     print "undef" if ( $true | $undef ) == $UNDEF ;

     # multi-degree logic
     my $True   = 100 ; # Define our own true
     my $False  = $FALSE ;
     my $true   = Math::Logic->new( -value => $True,  -degree => $True ) ;
     my $very   = Math::Logic->new( -value => 67,     -degree => $True ) ;
     my $fairly = Math::Logic->new( -value => 33,     -degree => $True ) ;
     my $false  = Math::Logic->new( -value => $False, -degree => $True ) ;
     my $x      = Math::Logic->new_from_string( "25,$True" ) ;

     print "maybe" if ( $very | $fairly ) > 50 ;

     # We can have arbitrarily complex expressions; the result is a Math::Logic
     # object; all arguments must be Math::Logic objects or things which can be
     # promoted into such and must all be compatible. The outcome depends on
     # which kind of logic is being used.
     my $xor = ( $x | $y ) & ( ! ( $x & $y ) ) ;
     # This is identical to:
     my $xor = $x ^ $y ;

DESCRIPTION
===========

   Perl's built-in logical operators, and, or, xor and not support 2-value
logic. This means that they always produce a result which is either true
or false. In fact perl sometimes returns 0 and sometimes returns undef for
false depending on the operator and the order of the arguments. For "true"
Perl generally returns the first value that evaluated to true which turns
out to be extremely useful in practice. Given the choice Perl's built-in
logical operators are to be preferred - but when you really want pure
2-degree logic or 3-degree logic or multi-degree logic they are available
through this module.

   The only 2-degree logic values are 1 (TRUE) and 0 (FALSE).

   The only 3-degree logic values are 1 (TRUE), 0 (FALSE) and -1 (UNDEF).
Note that UNDEF is -1 not undef!

   The only multi-degree logic values are 0 (FALSE)..`-degree' - the value
of TRUE is equal to the degree, usually 100.

   The `-degree' is the maximum value (except for 2 and 3-degree logic);
i.e.  logic of n-degree is *n+1*-value logic, e.g. 100-degree logic has 101
values, 0..100.

   Although some useful constants may be exported, this is an object
module and the results of logical comparisons are Math::Logic objects.

2-degree logic
--------------

   2-degree logic has one simple truth table for each logical operator.

     Perl Logic      Perl Logic     Perl Logic
         A B and  and    A B or   or    A B xor  xor
         - - ---  ---    - - --   --    - - ---  ---
         F F  F    F     F F  F    F    F F  F    F
         T T  T    T     T T  T    T    T T  F    F
         T F  F    F     T F  T    T    T F  T    T
         F T  F    F     F T  T    T    F T  T    T

     Perl Logic
         A not  not
         - ---  ---
         F  T    T
         T  F    F

   In the above tables when dealing with Perl's built-in logic T and F are
any true and any false value respectively; with Math::Logic they are
objects whose values are 1 and 0 respectively. Note that whilst Perl may
return 0 or undef for false and any other value for true, Math::Logic
returns an object whose value is either 0 (FALSE) or 1 (TRUE) only.

     my $true   = Math::Logic->new( -value => $TRUE,  -degree => 2 ) ;
     my $false  = Math::Logic->new( -value => $FALSE, -degree => 2 ) ;
     
     my $result = $true & $false ; # my $result = $true->and( $false ) ;

     print $result if $result == $FALSE ;

3-degree logic
--------------

   3-degree logic has two different truth tables for "and" and "or"; this
module supports both. In the Perl column F means false or undefined; and
T, F and U under Math::Logic are objects with values 1 (TRUE), 0 (FALSE)
and -1 (UNDEF) respectively. The + signifies propagating nulls (UNDEFs).

     Perl  Logic        Perl  Logic         Perl  Logic
         A B and  and+ and    A B or or+  or    A B xor  xor+ xor(same)
         - - ---  ---  ---    - - -- --   --    - - ---  ---  ---
         U U  F    U    U     U U  F  U    U    U U  F    U    U
         U F  F    U    F     U F  F  U    U    U F  F    U    U
         F U  F    U    F     F U  F  U    U    F U  F    U    U
         F F  F    F    F     F F  F  F    F    F F  F    F    F
         U T  F    U    U     U T  T  U    T    U T  T    U    U
         T U  F    U    U     T U  T  U    T    T U  T    U    U
         T T  T    T    T     T T  T  T    T    T T  F    F    F
         T F  F    F    F     T F  T  T    T    T F  T    T    T
         F T  F    F    F     F T  T  T    T    F T  T    T    T

     Perl  Logic
         A not  not+ not(same)
         - ---  ---  ---
         U  T    U    U
         U  T    U    U
         F  T    T    T
         T  F    F    F

     # 3-degree logic (non-propagating)
     my $true   = Math::Logic->new( -value => $TRUE,  -degree => 3 ) ;
     my $false  = Math::Logic->new( -value => $FALSE, -degree => 3 ) ;
     my $undef  = Math::Logic->new( -value => $UNDEF, -degree => 3 ) ;

     my $result = $undef & $false ; # my $result = $undef->and( $false ) ;

     print $result if $result == $FALSE ;

     # 3-degree logic (propagating)
     my $true   = Math::Logic->new( -value => $TRUE,  -degree => 3, -propagate => 1 ) ;
     my $false  = Math::Logic->new( -value => $FALSE, -degree => 3, -propagate => 1 ) ;
     my $undef  = Math::Logic->new( -value => $UNDEF, -degree => 3, -propagate => 1 ) ;

     my $result = $undef & $false ; # my $result = $undef->and( $false ) ;

     print $result if $result == $UNDEF ;

multi-degree logic
------------------

   This is used in `fuzzy' logic. Typically we set the `-degree' to 100
representing 100% likely, i.e. true; 0 represents 0% likely, i.e. false,
and any integer in-between is a probability.

   The truth tables for multi-degree logic work like this:

     and     lowest  value is the result;
     or      highest value is the result;
     xor     by truth table xor(a,b) == and(or(a,b),not(and(a,b)))
     not     degree minus the value is the result.

     Logic
          A   B  and  or xor
         --- --- --- --- ---
           0   0   0   0   0
           0 100   0 100 100
         100   0   0 100 100
         100 100 100 100   0
           0  33   0  33  33
          33   0   0  33  33
          33 100  33 100  67
          33  33  33  33  33
         100  33  33 100  67
           0  67   0  67  67
          67   0   0  67  67
          67 100  67 100  33
          67  67  67  67  33
         100  67  67 100  33
          33  67  33  67  67
          67  33  33  67  67

     A  not
         --- ---
      0 100
     33  67
     67  33
         100   0
     
         # multi-degree logic
         my $True   = 100 ; # Define our own TRUE and FALSE
         my $False  = $FALSE ;
         $true      = Math::Logic->new( -value => $True,  -degree => $True ) ;
         $very      = Math::Logic->new( -value => 67,     -degree => $True ) ;
         $fairly    = Math::Logic->new( -value => 33,     -degree => $True ) ;
         $false     = Math::Logic->new( -value => $False, -degree => $True ) ;

     my $result = $fairly & $very ; # my $result = $fairly->and( $very ) ;

     print $result if $result == $fairly ;

Public methods
--------------

     new             class   object (also used for assignment)
     new_from_string class   object
     value                   object
     degree                  object
     propagate               object
     incompatible            object
     compatible              object (deprecated)
     as_string               object
     and                     object (same as &)
     or                      object (same as |)
     xor                     object (same as ^)
     not                     object (same as !)
     ""                      object (see as_string)
     0+                      object (automatically handled)
     <=>                     object (comparisons)
     &                       object (logical and)
     |                       object (logical or)
     ^                       object (logical xor)
     !                       object (logical not)

new (class and object method)
-----------------------------

     my $x = Math::Logic->new ;

     my $y = Math::Logic->new( -value => $FALSE, -degree => 3, -propagate => 0 );

     my $a = $x->new ;

     my $b = $y->new( -value => $TRUE ) ;

   This creates new Math::Logic objects. new should never fail because it
will munge any arguments into something `sensible'; in particular if the
value is set to -1 (UNDEF) for 2 or multi-degree logic it is silently
converted to 0 (FALSE). In all other cases anything that is true in Perl
is converted to 1 (TRUE) and everything else to 0 (FALSE).

   If used as an object method, e.g. for assignment then the settings are
those of the original object unless overridden. If used as a class method
with no arguments then default values are used.

   `-degree' an integer indicating the number of possible truth values;
typically set to 2, 3 or 100 (to represent percentages). Minimum value is
2.

   `-propagate' a true/false integer indicating whether NULLs (UNDEF)
should propagate; only applicable for 3-degree logic where it influences
which truth table is used.

   `-value' an integer representing the truth value. For 2-degree logic
only 1 and 0 are valid (TRUE and FALSE); for 3-degree logic 1, 0, and -1
are valid (TRUE, FALSE and UNDEF); for multi-degree logic any positive
integer less than or equal to the `-degree' is valid.

new_from_string (class and object method)
-----------------------------------------

     my $x = Math::Logic->new_from_string( '1,2' ) ;
     my $y = Math::Logic->new_from_string( 'TRUE,3,-propagate' ) ;
     my $z = Math::Logic->new_from_string( '( FALSE, 3, -propagate )' ) ;
     my $m = Math::Logic->new_from_string( '33,100' ) ;
     my $n = Math::Logic->new_from_string( '67%,100' ) ;

   This creates new Math::Logic objects. The string must include the first
two values, which are `-value' and `-degree' respectively.

   True  values can be expressed as  1, T or any word beginning with T,
e.g.  TRUE or -true; the pattern is /^-?[tT]/.  False values can be
expressed as  0, F or any word beginning with F, e.g.  FALSE or -false;
the pattern is /^-?[fF]/.  Undef values can be expressed as -1, U or any
word beginning with U, e.g.  UNDEF or -undef; the pattern is /^-?[uU]/.
Propagate is set to true by adding a third parameter matching /^-?[tTpP1]/,
e.g. -propagate. To set propagate to false either don't include a third
parameter or include it as 0 (zero).

value (object method)
---------------------

     print $x->value ;
     print $x ;

   This returns the numeric value of the object. For 2-degree logic this
will always be 1 or 0; for 3-degree logic the value will be 1, 0 or -1; for
multi-degree logic the value will be a positive integer <= `-degree'.

degree (object method)
----------------------

     print $x->degree ;

   This returns the degree of the object, i.e. the number of possible truth
values the object may hold; it is always 2 or more.

propagate (object method)
-------------------------

     print $x->propagate ;

   This returns whether or not the object propagates NULLs (UNDEF).
Objects using 2 or multi-degree logic always return FALSE; 3-degree logic
objects may return TRUE or FALSE.

incompatible (object method)
----------------------------

     print $x & $y unless $x->incompatible( $y ) ;

   Returns FALSE if the objects are compatible; returns an error string if
incompatible (which Perl treats as TRUE), e.g.:

     $x = Math::Logic->new_from_string('1,2') ;
     $y = Math::Logic->new_from_string('0,3') ;
     # The above are incompatible because the first uses 2-degree logic and the
     # second uses 3-degree logic.
     print $x->incompatible( $y ) if $x->incompatible( $y ) ;
     # This will print something like:
     Math::Logic(2,0) and Math::Logic(3,0) are incompatible at ./logic.t line 2102
     # The first number given is the degree and the second the propagate setting

   Objects are compatible if they have the same `-degree' and in the case
of 3-degree logic the same `-propagate'. Logical operators will only work
on compatible objects, there is no type-coersion (but see typecasting
later).

compatible DEPRECATED (object method)
-------------------------------------

     print $x->compatible( $y ) ;

   Returns TRUE or FALSE depending on whether the two objects are
compatible.  Objects are compatible if they have the same `-degree' and in
the case of 3-degree logic the same `-propagate'. Logical operators will
only work on compatible objects, there is no type-coersion (but see
typecasting later).

as_string and "" (object method)                                     # output:     print $x->as_string ;           # TRUE     print $x->as_string( 1 ) ;      # (TRUE,2)     print $x->as_string( -full ) ;  # (TRUE,2)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

     print $x ;                      # TRUE
     print $x->value ;               # 1

     print $m ;                      # 33
     print $m->value ;               # 33
     print $m->as_string( 1 ) ;      # (33%,100)

   Usually you won't have to bother using as_string since Perl will invoke
it for you as necessary; however if you want a string that can be saved,
(perhaps to be read in using `new_from_string' later), you can pass an
argument to as_string.

and and & (object method)
-------------------------

     print "true" if ( $y & $z ) == $TRUE ;
     print "yes"  if $y & 1 ;
     print "yes"  if $TRUE & $y ;
     
     $r = $y & $z ; # Creates a new Math::Logic object with the resultant truth value

     print "true" if $y->and( $z ) == $TRUE ;

   Applies logical and to two objects. The truth table used depends on the
object's `-degree' (and in the case of 3-degree logic on the `-propagate').
(See the truth tables above.)

or and | (object method)
------------------------

     print "true" if ( $y | $z ) == $TRUE ;
     print "yes"  if $y | 1 ;
     print "yes"  if $TRUE | $y ;
     
     $r = $y | $z ; # Creates a new Math::Logic object with the resultant truth value

     print "true" if $y->or( $z ) == $TRUE ;

   Applies logical or to two objects. The truth table used depends on the
object's `-degree' (and in the case of 3-degree logic on the `-propagate').
(See the truth tables above.)

xor and ^ (object method)
-------------------------

     print "true" if ( $y ^ $z ) == $TRUE ;
     print "yes"  if $y ^ 0 ;
     print "yes"  if $TRUE ^ $y ;
     
     $r = $y ^ $z ; # Creates a new Math::Logic object with the resultant truth value

     print "true" if $y->xor( $z ) == $TRUE ;

   Applies logical xor to two objects. The truth table used depends on the
object's `-degree'. (See the truth tables above.)

not and ! (object method)
-------------------------

     print "true" if ! $y == $TRUE ;
     
     $r = ! $y ; # Creates a new Math::Logic object with the resultant truth value

     print "true" if $y->not == $TRUE ;

   Applies logical not to the object. The truth table used depends on the
object's `-degree'. (See the truth tables above.)

comparisons and <=> (object method)
-----------------------------------

   All the standard (numeric) comparison operators may be applied to
Math::Logic objects, i.e. <, <=, >, =>, ==, != and <=>.

typecasting
-----------

   The only typecasting that appears to make sense is between 2 and
3-degree logic. There is no direct support for it but it can be achieved
thus:

     my $x = Math::Logic->new_from_string( '1,2' ) ;  # TRUE  2-degree
     my $y = Math::Logic->new_from_string( '0,3' ) ;  # FALSE 3-degree
     my $z = Math::Logic->new_from_string( '-1,3' ) ; # UNDEF 3-degree

     $x3 = $x->new( -degree => 3 ) ;
     $y2 = $y->new( -degree => 2 ) ;
     $z2 = $y->new( -degree => 2 ) ; # UNDEF converted silently to FALSE

BUGS
====

   Multi-degree logic has a minimum degree of 4, i.e. 5-value, 0..4.

   If you use & on two incompatible Math::Logic objects perl dies; I
believe that this is due to a problem with overload: it does not occur
with perl 5.6.0.

CHANGES
=======

   2000/05/25

   No changes; just corrected an error in the tarball that meant the test
would fail in some cases due to permissions problem.

   2000/05/22

   Dropped use of readonly pragma.

   2000/04/26

   Deleted quite a lot of internal error checks to improve speed.

   Class is now inheritable.

   2000/04/15

   Have switched constants to readonly scalars, i.e. $TRUE instead of TRUE
etc.  This makes them easier to use for certain things, e.g. string
interpolation and as array indexes or hash keys. The (now deprecated)
constants still work but you are recommended to use the constant scalars
instead. You will need to install `readonly.pm' which should be available
from wherever you got Math::Logic.

   The bugs with overload do not occur with perl 5.6.0. Added two tests
which are run if perl's version is > 5.005.

   2000/02/27

   Numerous minor documentation changes to clarify terminology.

   Two bugs noted.

   More tests added.

   2000/02/23

   Corrected multi-degree xor to match the truth table equivalence, i.e.

     xor(a,b) == and(or(a,b),not(and(a,b)))

   which can be expressed in Math::Logic as

     $a->xor( $b ) == $a->or( $b )->and( $a->and( $b )->not )

   or as

     $a ^ $b == ( $a | $b ) & ( ! ( $a & $b ) )

   2000/02/22

   Minor correction to _croak so that error messages don't list filename
and line twice; plus other minor cleanups to improve error output.

   Changed the way new_from_string handles string truth values; numeric
truth values operate as before.

   2000/02/21

   Added incompatible method and now deprecate compatible method; this
provides better error messages; updated test script.

   2000/02/20

   Minor documentation fixes. Also eliminated a warning that occurred under
5.005.

   2000/02/19

   First version. Ideas taken from my Math::Logic3 and (unpublished)
Math::Fuzzy; this module is intended to supercede both.

AUTHOR
======

   Mark Summerfield. I can be contacted as <summer@perlpress.com> - please
include the word 'logic' in the subject line.

COPYRIGHT
=========

   Copyright (c) Mark Summerfield 2000. All Rights Reserved.

   This module may be used/distributed/modified under the LGPL.


File: pm.info,  Node: Math/MagicSquare,  Next: Math/Matrix,  Prev: Math/Logic,  Up: Module List

Magic Square Checker
********************

NAME
====

   Math::MagicSquare - Magic Square Checker

SYNOPSIS
========

     use Math::MagicSquare;

     $a= Math::MagicSquare -> new ([num,...,num],
                                    ...,
                                   [num,...,num]);
     $a->print("string");
     $a->printhtml();
     $a->check();
     $a->rotation();
     $a->reflection();

DESCRIPTION
===========

   The following methods are available:

new
---

   Constructor arguments are a list of references to arrays of the same
length.

     $a = Math::MagicSquare -> new ([num,...,num],
                                     ...,
                                    [num,...,num]);

check
-----

   This function can return 4 value

   * *0:* the Square is not Magic

   * *1:* the Square is a *Semimagic Square* (the sum of the rows and the
     columns is equal)

   * *2:* the Square is a *Magic Square* (the sum of the rows, the columns
     and the diagonals is equal)

   * *3:* the Square ia *Panmagic Square* (the sum of the rows, the
     columns, the diagonals and the broken diagonals is equal)

print
-----

   Prints the Square on STDOUT. If the method has additional parameters,
these are printed before the Magic Square is printed.

printhtml
---------

   Prints the Square on STDOUT in an HTML format (exactly a inside a TABLE)

rotation
--------

   Rotates the Magic Square of 90 degree clockwise

reflection
----------

   Reflect the Magic Square

EXAMPLE
=======

     use Math::MagicSquare;

     $A = Math::MagicSquare -> new ([8,1,6],
                                    [3,5,7],
                                    [4,9,2]);
     $A->print("Magic Square A:\n");
     $A->printhtml;
     $i=$A->check;
     if($i == 2) {print "This is a Magic Square.\n";}
     $A->rotation();
     $A->print("Rotation:\n");
     $A->reflection();
     $A->print("Reflection:\n");

     This is the output:
        Magic Square A:
            8     1     6
            3     5     7
            4     9     2
        <TABLE border=3 width="2" height="2" cellpadding=1 cellspacing=1>
        <TR>
        <TD align=right><FONT size=+2><B>8</B></font></TD>
        <TD align=right><FONT size=+2><B>1</B></font></TD>
        <TD align=right><FONT size=+2><B>6</B></font></TD>
        </TR>
        <TR>
        <TD align=right><FONT size=+2><B>3</B></font></TD>
        <TD align=right><FONT size=+2><B>5</B></font></TD>
        <TD align=right><FONT size=+2><B>7</B></font></TD>
        </TR>
        <TR>
        <TD align=right><FONT size=+2><B>4</B></font></TD>
        <TD align=right><FONT size=+2><B>9</B></font></TD>
        <TD align=right><FONT size=+2><B>2</B></font></TD>
        </TR>
        </TABLE>
        This is a Magic Square.
        Rotation:
            4     3     8
            9     5     1
            2     7     6
        Reflection:
            8     3     4
            1     5     9
            6     7     2

AUTHOR
======

     Fabrizio Pivari pivari@geocities.com
     member of ANFACE Software http://www.geocities.com/CapeCanaveral/Hangar/4794/

Copyright
=========

     Copyright 1998, Fabrizio Pivari pivari@geocities.com
     This library is free software; you can redistribute it and/or modify it under
     the same terms as Perl itself.

Availability
============

     The latest version of this library is likely to be available from:
     http://www.geocities.com/CapeCanaveral/Lab/3469/
     and at any CPAN mirror

Information about Magic Square
==============================

     Do you like Magic Square?
     Do you want to know more information about Magic Square?
     Try to visit

A very good introduction on Magic Square
     http://www.astro.virginia.edu/~eww6n/math/MagicSquare.html

A whole collection of links and documents in Internet
     http://www.pse.che.tohoku.ac.jp/~msuzuki/MagicSquare.html

A good collection of strange Magic Square
     http://www.geocities.com/CapeCanaveral/Lab/3469/examples.html

The only Magic Square checker and gif maker in Internet (I think)
     http://www.geocities.com/CapeCanaveral/Lab/3469/squaremaker.html


File: pm.info,  Node: Math/Matrix,  Next: Math/MatrixBool,  Prev: Math/MagicSquare,  Up: Module List

Multiply and invert Matrices
****************************

NAME
====

   Math::Matrix - Multiply and invert Matrices

DESCRIPTION
===========

   The following methods are available:

new
---

   Constructor arguments are a list of references to arrays of the same
length.  The arrays are copied. The method returns undef in case of error.

     $a = new Math::Matrix ([rand,rand,rand],
                            [rand,rand,rand],
                            [rand,rand,rand]);

concat
------

   Concatenates two matrices of same row count. The result is a new matrix
or undef in case of error.

     $b = new Math::Matrix ([rand],[rand],[rand]);
     $c = $a->concat($b);

transpose
---------

   Returns the transposed matrix. This is the matrix where colums and rows
of the argument matrix are swaped.

multiply
--------

   Multiplies two matrices where the length of the rows in the first
matrix is the same as the length of the columns in the second matrix.
Returns the product or undef in case of error.

solve
-----

   Solves a equation system given by the matrix. The number of colums must
be greater than the number of rows. If variables are dependent from each
other, the second and all further of the dependent coefficients are 0.
This means the method can handle such systems. The method returns a matrix
containing the solutions in its columns or undef in case of error.

print
-----

   Prints the matrix on STDOUT. If the method has additional parameters,
these are printed before the matrix is printed.

EXAMPLE
=======

     use Math::Matrix;

     srand(time);
     $a = new Math::Matrix ([rand,rand,rand],
                      [rand,rand,rand],
                      [rand,rand,rand]);
     $x = new Math::Matrix ([rand,rand,rand]);
     $a->print("A\n");
     $E = $a->concat($x->transpose);
     $E->print("Equation system\n");
     $s = $E->solve;
     $s->print("Solutions s\n");
     $a->multiply($s)->print("A*s\n");

AUTHOR
======

   Ulrich Pfeifer <pfeifer@ls6.informatik.uni-dortmund.de>


File: pm.info,  Node: Math/MatrixBool,  Next: Math/MatrixReal,  Prev: Math/Matrix,  Up: Module List

Matrix of Booleans
******************

NAME
====

   Math::MatrixBool - Matrix of Booleans

   Easy manipulation of matrices of booleans (Boolean Algebra)

SYNOPSIS
========

   * `use Math::MatrixBool;'

   * `$new_matrix = new Math::MatrixBool($rows,$columns);'

     the matrix object constructor method

     An exception is raised if the necessary memory cannot be allocated.

   * `$new_matrix = Math::MatrixBool->new($rows,$columns);'

     alternate way of calling the matrix object constructor method

   * `$new_matrix = $some_matrix->'`new($rows,$columns);'

     still another way of calling the matrix object constructor method
     ($some_matrix is not affected by this)

   * `$new_matrix = Math::MatrixBool->'`new_from_string($string);'

     This method allows you to read in a matrix from a string (for
     instance, from the keyboard, from a file or from your code).

     The syntax is simple: each row must start with "`[ '" and end with "`
     ]\n'" ("\n" being the newline character and "` '" a space or tab) and
     contain one or more numbers, all separated from each other by spaces
     or tabs.

     Additional spaces or tabs can be added at will, but no comments.

     Numbers are either "0" or "1".

     Examples:

          $string = "[ 1 0 0 ]\n[ 1 1 0 ]\n[ 1 1 1 ]\n";
          $matrix = Math::MatrixBool->new_from_string($string);
          print "$matrix";

     By the way, this prints

          [ 1 0 0 ]
          [ 1 1 0 ]
          [ 1 1 1 ]

     But you can also do this in a much more comfortable way using the
     shell-like "here-document" syntax:

          $matrix = Math::MatrixBool->new_from_string(<<'MATRIX');
          [  1  0  0  0  0  0  1  ]
          [  0  1  0  0  0  0  0  ]
          [  0  0  1  0  0  0  0  ]
          [  0  0  0  1  0  0  0  ]
          [  0  0  0  0  1  0  0  ]
          [  0  0  0  0  0  1  0  ]
          [  1  0  0  0  0  0  1  ]
          MATRIX

     You can even use variables in the matrix:

          $c1  =  $A1 * $x1 - $b1 >= 0  ?"1":"0";
          $c1  =  $A2 * $x2 - $b2 >= 0  ?"1":"0";
          $c1  =  $A3 * $x3 - $b3 >= 0  ?"1":"0";

          $matrix = Math::MatrixBool->new_from_string(<<"MATRIX");

          [   1    0    0   ]
          [   0    1    0   ]
          [  $c1  $c2  $c3  ]

          MATRIX

     (Remember that you may use spaces and tabs to format the matrix to
     your taste)

     Note that this method uses exactly the same representation for a
     matrix as the "stringify" operator "": this means that you can convert
     any matrix into a string with `$string = "$matrix";' and read it back
     in later (for instance from a file!).

     If the string you supply (or someone else supplies) does not obey the
     syntax mentioned above, an exception is raised, which can be caught
     by "eval" as follows:

          print "Please enter your matrix (in one line): ";
          $string = <STDIN>;
          $string =~ s/\\n/\n/g;
          eval { $matrix = Math::MatrixBool->new_from_string($string); };
          if ($@)
          {
              print "$@";
              # ...
              # (error handling)
          }
          else
          {
              # continue...
          }

     or as follows:

          eval { $matrix = Math::MatrixBool->new_from_string(<<"MATRIX"); };
          [   1    0    0   ]
          [   0    1    0   ]
          [  $c1  $c2  $c3  ]
          MATRIX
          if ($@)
          # ...

     Actually, the method shown above for reading a matrix from the
     keyboard is a little awkward, since you have to enter a lot of "\n"'s
     for the newlines.

     A better way is shown in this piece of code:

          while (1)
          {
              print "\nPlease enter your matrix ";
              print "(multiple lines, <ctrl-D> = done):\n";
              eval { $new_matrix =
                  Math::MatrixBool->new_from_string(join('',<STDIN>)); };
              if ($@)
              {
                  $@ =~ s/\s+at\b.*?$//;
                  print "${@}Please try again.\n";
              }
              else { last; }
          }

     Possible error messages of the "new_from_string()" method are:

          Math::MatrixBool::new_from_string(): syntax error in input string
          Math::MatrixBool::new_from_string(): empty input string

     If the input string has rows with varying numbers of columns, the
     following warning will be printed to STDERR:

          Math::MatrixBool::new_from_string(): missing elements will be set to zero!

     If everything is okay, the method returns an object reference to the
     (newly allocated) matrix containing the elements you specified.

   * `($rows,$columns) = $matrix->Dim();'

     returns the dimensions (= number of rows and columns) of the given
     matrix

   * `$matrix->Empty();'

     sets all elements in the matrix to "0"

   * `$matrix->Fill();'

     sets all elements in the matrix to "1"

   * `$matrix->Flip();'

     flips (i.e., complements) all elements in the given matrix

   * `$matrix->Zero();'

     sets all elements in the matrix to "0"

   * `$matrix->One();'

     fills the matrix with one's in the main diagonal and zero's elsewhere

     Note that multiplying this matrix with itself yields the same matrix
     again (provided it is a square matrix)!

   * `$matrix->Bit_On($row,$column);'

     sets a given element to "1"

   * `$matrix->Insert($row,$column);'

     alias for "Bit_On()", deprecated

   * `$matrix->Bit_Off($row,$column);'

     sets a given element to "0"

   * `$matrix->Delete($row,$column);'

     alias for "Bit_Off()", deprecated

   * `$boolean = $matrix->'`bit_flip($row,$column);'

     flips (i.e., complements) a given element and returns its new value

   * `$boolean = $matrix->'`flip($row,$column);'

     alias for "bit_flip()", deprecated

   * `$boolean = $matrix->'`bit_test($row,$column);'

     tests wether a given element is set

   * `$boolean = $matrix->'`contains($row,$column);'

     tests wether a given element is set (alias for "bit_test()")

   * `$boolean = $matrix->'`in($row,$column);'

     alias for "bit_test()", deprecated

   * `$elements = $matrix->Number_of_elements();'

     calculates the number of elements contained in the given matrix

   * `$norm_max = $matrix->Norm_max();'

     calculates the "maximum"-norm of the given matrix

   * `$norm_one = $matrix->Norm_one();'

     calculates the "1"-norm of the given matrix

   * `$matrix1->Addition($matrix2,$matrix3);'

     calculates the sum of matrix2 and matrix3 and stores the result in
     matrix1 (in-place is also possible)

   * `$product_matrix = $matrix1->Multiplication($matrix2);'

     calculates the product of matrix1 and matrix2 and returns an object
     reference to a new matrix where the result is stored; uses "^" as
     boolean addition operator internally

   * `$product_matrix = $matrix1->Product($matrix2);'

     calculates the product of matrix1 and matrix2 and returns an object
     reference to a new matrix where the result is stored; uses "|" as
     boolean addition operator internally

   * `$closure = $matrix->Kleene();'

     computes the reflexive transitive closure of the given matrix and
     returns a new matrix containing the result. (The original matrix is
     not changed by this in any way!)

     Uses a variant of Kleene's algorithm. See `Math::Kleene(3)' in this
     node for more details about this algorithm!

     This algorithm is mainly used in graph theory: Each position in the
     matrix corresponds to a (directed!) possible connection ("edge")
     between two points ("vortices") of a graph. Each position in the
     matrix contains a "1" if the corresponding edge is part of the graph
     and a "0" if not.

     Computing the closure of this matrix means to find out if there is a
     path from any vortice of the graph to any other (a path consisting of
     one or more edges).

     Note that there are more applications of Kleene's algorithm in other
     fields as well (see also Math::MatrixReal(3), DFA::Kleene(3),
     Math::Kleene(3)).

   * `$matrix1->Union($matrix2,$matrix3);'

     calculates the union of matrix2 and matrix3 and stores the result in
     matrix1 (in-place is also possible)

   * `$matrix1->Intersection($matrix2,$matrix3);'

     calculates the intersection of matrix2 and matrix3 and stores the
     result in matrix1 (in-place is also possible)

   * `$matrix1->Difference($matrix2,$matrix3);'

     calculates matrix2 "minus" matrix3 ( = matrix2 \ matrix3 ) and stores
     the result in matrix1 (in-place is also possible)

     Note that this is set difference, not matrix difference! Matrix
     difference degenerates to (= is the same as) matrix addition in a
     Boolean Algebra!!

   * `$matrix1->ExclusiveOr($matrix2,$matrix3);'

     calculates the exclusive-or (which in the case of a Boolean Algebra
     happens to be the same as the addition) of matrix2 and matrix3 and
     stores the result in matrix1 (in-place is also possible)

   * `$matrix1->Complement($matrix2);'

     calculates the complement of matrix2 and stores the result in matrix1
     (in-place is also possible)

   * `$matrix1->Transpose($matrix2);'

     calculates the transpose of matrix2 and stores the result in matrix1
     (in-place is also possible if and only if the matrix is a square
     matrix!); in general, matrix1 must have reversed numbers of rows and
     columns in relation to matrix2

   * `$boolean = $matrix1->equal($matrix2);'

     tests if matrix1 is the same as matrix2

   * `$boolean = $matrix1->subset($matrix2);'

     tests if matrix1 is a subset of matrix2

   * `$boolean = $matrix1->inclusion($matrix2);'

     alias for "subset()", deprecated

   * `$boolean = $matrix1->lexorder($matrix2);'

     tests if matrix1 comes lexically before matrix2, i.e., if (matrix1 <=
     matrix2) holds, as though the two bit vectors used to represent the
     two matrices were two large numbers in binary representation

     (Note that this is an *arbitrary* order relationship!)

   * `$result = $matrix1->Compare($matrix2);'

     lexically compares matrix1 and matrix2 and returns -1, 0 or 1 if
     (matrix1 < matrix2), (matrix1 == matrix2) or (matrix1 > matrix2)
     holds, respectively

     (Again, the two bit vectors representing the two matrices are
     compared as though they were two large numbers in binary
     representation)

   * `$matrix1->Copy($matrix2);'

     copies the contents of matrix2 to an *ALREADY EXISTING* matrix1

   * `$new_matrix = $some_matrix->Shadow();'

     returns an object reference to a NEW but EMPTY matrix of the *SAME
     SIZE* as some_matrix

   * `$twin_matrix = $some_matrix->Clone();'

     returns an object reference to a NEW matrix of the *SAME SIZE* as
     some_matrix; the contents of some_matrix have *ALREADY BEEN COPIED*
     to the new matrix

   * *Hint: method names all in lower case indicate a boolean return
     value!*

     (Except for "new()" and "new_from_string()", of course!)

   Please refer to `"OVERLOADED OPERATORS"' in this node below for ways of
using overloaded operators instead of explicit method calls in order to
facilitate calculations with matrices!

DESCRIPTION
===========

   This class lets you dynamically create boolean matrices of arbitrary
size and perform all the basic operations for matrices on them, like

-
     setting or deleting elements,

-
     testing wether a certain element is set,

-
     computing the sum, difference, product, closure and complement of
     matrices,

     (you can also compute the union, intersection, difference and
     exclusive-or of the underlying bit vector)

-
     copying matrices,

-
     testing two matrices for equality or inclusion (subset relationship),
     and

-
     computing the number of elements and the norm of a matrix.

   Please refer to `"OVERLOADED OPERATORS"' in this node below for ways of
using overloaded operators instead of explicit method calls in order to
facilitate calculations with matrices!

OVERLOADED OPERATORS
====================

   Calculations with matrices can not only be performed with explicit
method calls using this module, but also through "magical" overloaded
arithmetic and relational operators.

   For instance, instead of writing

     $matrix1 = Math::MatrixBool->new($rows,$columns);
     $matrix2 = Math::MatrixBool->new($rows,$columns);
     $matrix3 = Math::MatrixBool->new($rows,$columns);

     [...]

     $matrix3->Multiplication($matrix1,$matrix2);

   you can just say

     $matrix1 = Math::MatrixBool->new($rows,$columns);
     $matrix2 = Math::MatrixBool->new($rows,$columns);

     [...]

     $matrix3 = $matrix1 * $matrix2;

   That's all!

   Here is the list of all "magical" overloaded operators and their
semantics (meaning):

   Unary operators: '-', '~', 'abs', testing, '!', '""'

   Binary (arithmetic) operators: '+', '*', '|', '-', '&', '^'

   Binary (relational) operators: '==', '!=', '<', '<=', '>', '>='

   Binary (relational) operators: 'cmp', 'eq', 'ne', 'lt', 'le', 'gt', 'ge'

   Note that both arguments to a binary operator from the list above must
be matrices; numbers or other types of data are not permitted as arguments
and will produce an error message.

'-'
     Unary Minus / Complement ( `$matrix2 = -$matrix1;' )

     The unary operator '-' computes the complement of the given matrix.

'~'
     Transpose ( `$matrix2 = ~$matrix1;' )

     The operator '~' computes the transpose of the given matrix.

abs
     Absolute Value ( `$no_of_elem = abs($matrix);' )

     Here, the absolute value of a matrix has been defined as the number
     of elements the given matrix contains. This is *NOT* the same as the
     "norm" of a matrix!

test
     Boolean Test ( `if ($matrix) { ... }' )

     You can actually test a matrix as though it were a boolean value.

     No special operator is needed for this; Perl automatically calls the
     appropriate method in this package if "$matrix" is a blessed reference
     to an object of the "Math::MatrixBool" class or one of its derived
     classes.

     This operation returns "true" (1) if the given matrix is not empty and
     "false" (") otherwise.

'!'
     Negated Boolean Test ( `if (! $matrix) { ... }' )

     You can also perform a negated test on a matrix as though it were a
     boolean value. For example:

          if (! $matrix) { ... }

          unless ($matrix) { ... }     #  internally, same as above!

     This operation returns "true" (1) if the given matrix is empty and
     "false" (") otherwise.

'""""'
     "Stringification" ( `print "$matrix";' )

     It is possible to get a string representation of a given matrix by
     just putting the matrix object reference between double quotes.

     Note that in general the string representation of a matrix will span
     over multiple lines (i.e., the string which is generated contains
     "\n" characters, one at the end of each row of the matrix).

     Example:

          $matrix = new Math::MatrixBool(5,6);
          $matrix->One();
          print "$matrix";

     This will print:

          [ 1 0 0 0 0 0 ]
          [ 0 1 0 0 0 0 ]
          [ 0 0 1 0 0 0 ]
          [ 0 0 0 1 0 0 ]
          [ 0 0 0 0 1 0 ]

'+'
     Addition ( `$matrix3 = $matrix1 + $matrix2;' )

     The '+' operator calculates the sum of two matrices.

     Examples:

          $all   =  $odd + $even;

          $all  +=  $odd;
          $all  +=  $even;

     Note that the '++' operator will produce an error message if applied
     to an object of this class because adding a number to a matrix makes
     no sense.


     Multiplication ( `$matrix3 = $matrix1 * $matrix2;' )

     The '*' operator calculates the matrix product of two matrices.

     Examples:

          $test   =  $one * $one;

          $test  *=  $one;
          $test  *=  $test;

     Note that you can use matrices of any size as long as their numbers of
     rows and columns correspond in the following way (example):

          $matrix_3 = $matrix_1 * $matrix_2;

          [ 2 2 ]
          [ 2 2 ]
          [ 2 2 ]

          [ 1 1 1 ]   [ 3 3 ]
          [ 1 1 1 ]   [ 3 3 ]
          [ 1 1 1 ]   [ 3 3 ]
          [ 1 1 1 ]   [ 3 3 ]

     I.e., the number of columns of matrix #1 is the same as the number of
     rows of matrix #2, and the number of rows and columns of the resulting
     matrix #3 is determined by the number of rows of matrix #1 and the
     number of columns of matrix #2, respectively.

     This way you can also perform the multiplication of a matrix with a
     vector, since a vector is just a degenerated matrix with several rows
     but only one column, or just one row and several columns.

'|'
     Union ( `$matrix3 = $matrix1 | $matrix2;' )

     The '|' operator is used to calculate the union of two matrices (of
     corresponding elements).

     Examples:

          $all   =  $odd | $even;

          $all  |=  $odd;
          $all  |=  $even;

'-'
     Difference ( `$matrix3 = $matrix1 - $matrix2;' )

     The operator '-' calculates the (dotted) difference of two matrices,
     i.e.,

          0 - 0 == 0
          0 - 1 == 0
          1 - 0 == 1
          1 - 1 == 0

     for each corresponding element.

     Examples:

          $odd   =  $all  - $even;

          $all  -=  $even;

     Note that the '-' operator will produce an error message if applied
     to an object of this class because subtracting a number from a matrix
     makes no sense.

'&'
     Intersection ( `$matrix3 = $matrix1 & $matrix2;' )

     The '&' operator is used to calculate the intersection of two matrices
     (of the corresponding elements).

     Examples:

          $rest  =  $all & $even;

          $all  &=  $even;

'^'
     ExclusiveOr ( `$matrix3 = $matrix1 ^ $matrix2;' )

     The '^' operator is used to calculate the exclusive-or of two matrices
     (of their corresponding elements).

     In fact this operation is identical with the addition of two matrices
     in this case of a Boolean Algebra.

     Examples:

          $odd   =  $all  ^ $even;

          $all  ^=  $even;

'=='
     Test For Equality ( `if ($matrix1 == $matrix2) { ... }' )

     This operator tests two matrices for equality.

     Note that *without* operator overloading, `( $matrix1 == $matrix2 )'
     would test wether the two references *pointed to* the *same object*!
     (!)

     With operator overloading in effect, `( $matrix1 == $matrix2 )' tests
     wether the two matrix objects *contain* exactly the *same elements*!

'!='
     Test For Non-Equality ( `if ($matrix1 != $matrix2) { ... }' )

     This operator tests wether two matrices are different.

     Note again that this tests wether the *contents* of the two matrices
     are not the same, and not wether the two references are different!

'<'
     Test For True Subset ( `if ($matrix1 < $matrix2) { ... }' )

     This operator tests wether $matrix1 is a true subset of $matrix2, i.e.
     wether the elements contained in $matrix1 are also contained in
     $matrix2, but not all elements contained in $matrix2 are contained in
     $matrix1.

     Example:

          [ 1 0 0 0 0 ]                       [ 1 0 0 0 1 ]
          [ 0 1 0 0 0 ]                       [ 0 1 0 0 0 ]
          [ 0 0 1 0 0 ]  is a true subset of  [ 0 0 1 0 0 ]
          [ 0 0 0 1 0 ]                       [ 0 0 0 1 0 ]
          [ 1 0 0 0 1 ]                       [ 1 0 0 0 1 ]

          [ 1 0 0 0 0 ]                       [ 1 0 0 0 1 ]
          [ 0 1 0 0 0 ]                       [ 0 1 0 0 0 ]
             but  [ 0 0 1 0 0 ]   is not a subset of  [ 0 0 1 0 0 ]
          [ 0 0 0 1 0 ]                       [ 0 0 0 1 0 ]
          [ 1 0 0 0 1 ]                       [ 0 0 0 0 1 ]

     (nor vice-versa!)

          [ 1 0 0 0 1 ]                       [ 1 0 0 0 1 ]
          [ 0 1 0 0 0 ]                       [ 0 1 0 0 0 ]
             and  [ 0 0 1 0 0 ]     is a subset of    [ 0 0 1 0 0 ]
          [ 0 0 0 1 0 ]                       [ 0 0 0 1 0 ]
          [ 1 0 0 0 1 ]                       [ 1 0 0 0 1 ]

     but not a true subset because the two matrices are identical.

'<='
     Test For Subset ( `if ($matrix1 <= $matrix2) { ... }' )

     This operator tests wether $matrix1 is a subset of $matrix2, i.e.
     wether all elements contained in $matrix1 are also contained in
     $matrix2.

     This also evaluates to "true" when the two matrices are the same.

'>'
     Test For True Superset ( `if ($matrix1 > $matrix2) { ... }' )

     This operator tests wether $matrix1 is a true superset of $matrix2,
     i.e.  wether all elements contained in $matrix2 are also contained in
     $matrix1, but not all elements contained in $matrix1 are contained in
     $matrix2.

     Note that `($matrix1 > $matrix2)' is exactly the same as `($matrix2 <
     $matrix1)'.

'>='
     Test For Superset ( `if ($matrix1 >= $matrix2) { ... }' )

     This operator tests wether $matrix1 is a superset of $matrix2, i.e.
     wether all elements contained in $matrix2 are also contained in
     $matrix1.

     This also evaluates to "true" when the two matrices are equal.

     Note that `($matrix1 >= $matrix2)' is exactly the same as `($matrix2
     <= $matrix1)'.

cmp
     Compare ( `$result = $matrix1 cmp $matrix2;' )

     This operator compares the two matrices lexically, i.e. it regards the
     two bit vectors representing the two matrices as two large (unsigned)
     numbers in binary representation and returns "-1" if the number for
     $matrix1 is smaller than that for $matrix2, "0" if the two numbers are
     the same (i.e., when the two matrices are equal!) or "1" if the number
     representing $matrix1 is larger than the number representing $matrix2.

     Note that this comparison has nothing to do whatsoever with algebra,
     it is just an *arbitrary* order relationship!

     It is only intended to provide an (arbitrary) order by which (for
     example) an array of matrices can be sorted, for instance to find out
     quickly (using binary search) if a specific matrix has already been
     produced before in some matrix-producing process or not.

eq
     "equal"

ne
     "not equal"

lt
     "less than"

le
     "less than or equal"

gt
     "greater than"

ge
     "greater than or equal"

     These are all operators derived from the "cmp" operator (see above).

     They can be used instead of the "cmp" operator to make the intended
     type of comparison more obvious in your code.

     For instance, `($matrix1 le $matrix2)' is much more readable and
     clearer than `(($matrix1 cmp $matrix2) <= 0)'!

SEE ALSO
========

   Bit::Vector(3), Math::MatrixReal(3), DFA::Kleene(3), Math::Kleene(3),
Set::IntegerFast(3), Set::IntegerRange(3).

VERSION
=======

   This man page documents "Math::MatrixBool" version 5.7.

AUTHOR
======

   Steffen Beyer <sb@sdm.de>.

COPYRIGHT
=========

   Copyright (c) 1995, 1996, 1997, 1998, 1999 by Steffen Beyer.  All
rights reserved.

LICENSE AGREEMENT
=================

   This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


