This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Bio/Index/AbstractSeq,  Next: Bio/Index/EMBL,  Prev: Bio/Index/Abstract,  Up: Module List

Base class for AbstractSeq s
****************************

NAME
====

   Bio::Index::AbstractSeq - Base class for AbstractSeq s

SYNOPSIS
========

     # Make a new sequence file indexing package

     package MyShinyNewIndexer;
     use Bio::Index::AbstractSeq;

     @ISA = ('Bio::Index::AbstractSeq');

     # Now provide the necessary methods...

DESCRIPTION
===========

   Provides a common base class for multiple sequence files built using the
Bio::Index::Abstract system, and provides a Bio::DB::SeqI interface.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email birney@ebi.ac.uk

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

SEE ALSO
========

   Bio::Index::Abstract - Module which Bio::Index::AbstractSeq inherits
off, which provides dbm indexing for flat files (which are not necessarily
sequence files).

_file_format
------------

     Title   : _file_format
     Usage   : $self->_file_format
     Function: Derived classes should override this
               method (it throws an exception here)
               to give the file format of the files used
     Example :
     Returns :
     Args    :

fetch
-----

     Title   : fetch
     Usage   : $index->fetch( $id )
     Function: Returns a Bio::Seq object from the index
     Example : $seq = $index->fetch( 'dJ67B12' )
     Returns : Bio::Seq object
     Args    : ID

_get_SeqIO_object
-----------------

     Title   : _get_SeqIO_object
     Usage   : $index->_get_SeqIO_object( $file )
     Function: Returns a Bio::SeqIO object for the file
     Example : $seq = $index->_get_SeqIO_object( 0 )
     Returns : Bio::SeqIO object
     Args    : File number (an integer)

get_Seq_by_id
-------------

     Title   : get_Seq_by_id
     Usage   : $seq = $db->get_Seq_by_id()
     Function: retrieves a sequence object, identically to
               ->fetch, but here behaving as a Bio::DB::BioSeqI
     Returns : new Bio::Seq object
     Args    : string represents the id

get_Seq_by_acc
--------------

     Title   : get_Seq_by_acc
     Usage   : $seq = $db->get_Seq_by_acc()
     Function: retrieves a sequence object, identically to
               ->fetch, but here behaving as a Bio::DB::BioSeqI
     Returns : new Bio::Seq object
     Args    : string represents the accession number

get_PrimarySeq_stream
---------------------

     Title   : get_PrimarySeq_stream
     Usage   : $stream = get_PrimarySeq_stream
     Function: Makes a Bio::DB::SeqStreamI compliant object
               which provides a single method, next_primary_seq
     Returns : Bio::DB::SeqStreamI
     Args    : none

get_all_primary_ids
-------------------

     Title   : get_all_primary_ids
     Usage   : @ids = $seqdb->get_all_primary_ids()
     Function: gives an array of all the primary_ids of the
               sequence objects in the database. These
               maybe ids (display style) or accession numbers
               or something else completely different - they
               *are not* meaningful outside of this database
               implementation.
     Example :
     Returns : an array of strings
     Args    : none

get_Seq_by_primary_id
---------------------

     Title   : get_Seq_by_primary_id
     Usage   : $seq = $db->get_Seq_by_primary_id($primary_id_string);
     Function: Gets a Bio::Seq object by the primary id. The primary
               id in these cases has to come from $db->get_all_primary_ids.
               There is no other way to get (or guess) the primary_ids
               in a database.

     The other possibility is to get Bio::PrimarySeqI objects
     via the get_PrimarySeq_stream and the primary_id field
     on these objects are specified as the ids to use here.
      Returns : A Bio::Seq object
      Args    : primary id (as a string)
      Throws  : "acc does not exist" exception


File: pm.info,  Node: Bio/Index/EMBL,  Next: Bio/Index/Fasta,  Prev: Bio/Index/AbstractSeq,  Up: Module List

Interface for indexing (multiple) EMBL/Swissprot .dat files (ie flat file embl/swissprot format).
*************************************************************************************************

NAME
====

   Bio::Index::EMBL - Interface for indexing (multiple) EMBL/Swissprot
.dat files (ie flat file embl/swissprot format).

SYNOPSIS
========

     # Complete code for making an index for several
     # EMBL files
     use Bio::Index::EMBL;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::EMBL->new($Index_File_Name, 'WRITE');
     $inx->make_index(@ARGV);

     # Print out several sequences present in the index
     # in Fasta format
     use Bio::Index::EMBL;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::EMBL->new($Index_File_Name);
     my $out = Bio::SeqIO->new('-format' => 'Fasta','-fh' => \*STDOUT);

     foreach my $id (@ARGV) {
         my $seq = $inx->fetch($id); # Returns Bio::Seq object
     	$out->write_seq($seq);
     }

     # alternatively

     my $seq1 = $inx->get_Seq_by_id($id);
     my $seq2 = $inx->get_Seq_by_acc($acc);

DESCRIPTION
===========

   Inherits functions for managing dbm files from Bio::Index::Abstract.pm,
and provides the basic funtionallity for indexing EMBL files, and
retrieving the sequence from them. Heavily snaffled from James Gilbert's
Fasta system.

FEED_BACK
=========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email - birney@sanger.ac.uk

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

_index_file
-----------

     Title   : _index_file
     Usage   : $index->_index_file( $file_name, $i )
     Function: Specialist function to index EMBL format files.
               Is provided with a filename and an integer
               by make_index in its SUPER class.
     Example :
     Returns :
     Args    :

_file_format
------------

     Title   : _file_format
     Usage   : Internal function for indexing system
     Function: Provides file format for this database
     Example :
     Returns :
     Args    :


File: pm.info,  Node: Bio/Index/Fasta,  Next: Bio/Index/GenBank,  Prev: Bio/Index/EMBL,  Up: Module List

Interface for indexing (multiple) fasta files
*********************************************

NAME
====

   Bio::Index::Fasta - Interface for indexing (multiple) fasta files

SYNOPSIS
========

     # Complete code for making an index for several
     # fasta files
     use Bio::Index::Fasta;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::Fasta->new(
         -filename => $Index_File_Name,
         -write_flag => 1);
     $inx->make_index(@ARGV);

     # Print out several sequences present in the index
     # in Fasta format
     use Bio::Index::Fasta;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::Fasta->new($Index_File_Name);
     my $out = Bio::SeqIO->new('-format' => 'Fasta','-fh' => \*STDOUT);

     foreach my $id (@ARGV) {
         my $seq = $inx->fetch($id); # Returns Bio::Seq object
     	$out->write_seq($seq);
     }

     # or, alternatively

     my $seq = $inx->get_Seq_by_id($id); #identical to fetch

DESCRIPTION
===========

   Inherits functions for managing dbm files from Bio::Index::Abstract.pm,
and provides the basic funtionallity for indexing fasta files, and
retrieving the sequence from them.

   Bio::Index::Fasta supports the Bio::DB::BioSeqI interface, meaning it
can be used a a Sequence database for other parts of bioperl

FEED_BACK
=========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - James Gilbert
======================

   Email - jgrg@sanger.ac.uk

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

_file_format
------------

     Title   : _file_format
     Function: The file format for this package, which is needed
               by the SeqIO system when reading the sequence.
     Returns : 'Fasta'

_index_file
-----------

     Title   : _index_file
     Usage   : $index->_index_file( $file_name, $i )
     Function: Specialist function to index FASTA format files.
               Is provided with a filename and an integer
               by make_index in its SUPER class.
     Example :
     Returns :
     Args    :

id_parser
---------

     Title   : id_parser
     Usage   : $index->id_parser( CODE )
     Function: Stores or returns the code used by record_id to
               parse the ID for record from a string.  Useful
               for (for instance) specifying a different
               parser for different flavours of FASTA file.
               Returns \&default_id_parser (see below) if not
               set. If you supply your own id_parser
               subroutine, then it should expect a fasta
               description line.  An entry will be added to
               the index for each string in the list returned.
     Example : $index->id_parser( \&my_id_parser )
     Returns : ref to CODE if called without arguments
     Args    : CODE

default_id_parser
-----------------

     Title   : default_id_parser
     Usage   : $id = default_id_parser( $header )
     Function: The default Fasta ID parser for Fasta.pm
               Returns $1 from applying the regexp /^>\s*(\S+)/
               to $header.
     Returns : ID string
     Args    : a fasta header line string


File: pm.info,  Node: Bio/Index/GenBank,  Next: Bio/Index/SwissPfam,  Prev: Bio/Index/Fasta,  Up: Module List

Interface for indexing (multiple) GenBank .seq files (ie flat file GenBank format).
***********************************************************************************

NAME
====

   Bio::Index::GenBank - Interface for indexing (multiple) GenBank .seq
files (ie flat file GenBank format).

SYNOPSIS
========

     # Complete code for making an index for several
     # GenBank files
     use Bio::Index::GenBank;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::GenBank->new($Index_File_Name, 'WRITE');
     $inx->make_index(@ARGV);

     # Print out several sequences present in the index
     # in gcg format
     use Bio::Index::GenBank;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::GenBank->new($Index_File_Name);

     foreach my $id (@ARGV) {
         my $seq = $inx->fetch($id); # Returns Bio::Seq object
         print $seq->layout('GCG');
     }

     # alternatively

     my $seq1 = $inx->get_Seq_by_id($id);
     my $seq2 = $inx->get_Seq_by_acc($acc);

DESCRIPTION
===========

   Inherits functions for managing dbm files from Bio::Index::Abstract.pm,
and provides the basic funtionallity for indexing GenBank files, and
retrieving the sequence from them. Heavily snaffled from James Gilbert's
Fasta system.

FEED_BACK
=========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email - birney@sanger.ac.uk

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

_index_file
-----------

     Title   : _index_file
     Usage   : $index->_index_file( $file_name, $i )
     Function: Specialist function to index GenBank format files.
               Is provided with a filename and an integer
               by make_index in its SUPER class.
     Example :
     Returns :
     Args    :

_file_format
------------

     Title   : _file_format
     Usage   : Internal function for indexing system
     Function: Provides file format for this database
     Example :
     Returns :
     Args    :


File: pm.info,  Node: Bio/Index/SwissPfam,  Next: Bio/Index/Swissprot,  Prev: Bio/Index/GenBank,  Up: Module List

Interface for indexing swisspfam files
**************************************

NAME
====

   Bio::Index::SwissPfam - Interface for indexing swisspfam files

SYNOPSIS
========

     use Bio::Index::SwissPfam;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::SwissPfam->new($Index_File_Name, 'WRITE');
     $inx->make_index(@ARGV);

     use Bio::Index::SwissPfam;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::SwissPfam->new($Index_File_Name);

     foreach my $id (@ARGV) {
         my $seq = $inx->fetch($id); # Returns stream
     	while( <$seq> ) {
     	    if(/^>/) {
     	    	print;
     		last;
     	    }
     	}
     }

DESCRIPTION
===========

   SwissPfam is one of the flat files released with Pfam. This modules
provides a way of indexing this module.

   Inherits functions for managing dbm files from Bio::Index::Abstract.pm,
and provides the basic funtionallity for indexing SwissPfam files.  Only
retrieves FileStreams at the moment. Once we have something better (ie, an
object!), will use that. Heavily snaffled from James Gilbert's Fasta
system.

FEED_BACK
=========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email - birney@sanger.ac.uk

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

_index_file
-----------

     Title   : _index_file
     Usage   : $index->_index_file( $file_name, $i )
     Function: Specialist function to index swisspfam format files.
               Is provided with a filename and an integer
               by make_index in its SUPER class.
     Example :
     Returns :
     Args    :

fetch
-----

     Title   : fetch
     Usage   : $index->fetch( $id )
     Function: Returns a Bio::Seq object from the index
     Example : $seq = $index->fetch( 'dJ67B12' )
     Returns : Bio::Seq object
     Args    : ID


File: pm.info,  Node: Bio/Index/Swissprot,  Next: Bio/LiveSeq/AARange,  Prev: Bio/Index/SwissPfam,  Up: Module List

Interface for indexing (multiple) Swissprot .dat files (ie flat file swissprot format).
***************************************************************************************

NAME
====

   Bio::Index::Swissprot - Interface for indexing (multiple) Swissprot
.dat files (ie flat file swissprot format).

SYNOPSIS
========

     # Complete code for making an index for several
     # Swissprot files
     use Bio::Index::Swissprot;

     my $Index_File_Name = shift;
     my $inx = Bio::Index::Swissprot->new($Index_File_Name, 'WRITE');
     $inx->make_index(@ARGV);

     # Print out several sequences present in the index
     # in gcg format
     use Bio::Index::Swissprot;
     use Bio::SeqIO;

     my $out = Bio::SeqIO->new( '-format' => 'gcg', -fh => \*STDOUT );
     my $Index_File_Name = shift;
     my $inx = Bio::Index::Swissprot->new($Index_File_Name);

     foreach my $id (@ARGV) {
         my $seq = $inx->fetch($id); # Returns Bio::Seq object
         $out->write_seq($seq);
     }

     # alternatively

     my $seq1 = $inx->get_Seq_by_id($id);
     my $seq2 = $inx->get_Seq_by_acc($acc);

DESCRIPTION
===========

   Inherits functions for managing dbm files from Bio::Index::Abstract.pm,
and provides the basic funtionallity for indexing Swissprot files, and
retrieving the sequence from them. Heavily snaffled from James Gilbert's
Fasta system.

FEED_BACK
=========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                - General discussion
     http://bio.perl.org/MailList.html    - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email - birney@sanger.ac.uk (Swissprot adaption: lorenz@ist.org)

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

_index_file
-----------

     Title   : _index_file
     Usage   : $index->_index_file( $file_name, $i )
     Function: Specialist function to index Swissprot format files.
               Is provided with a filename and an integer
               by make_index in its SUPER class.
     Example :
     Returns :
     Args    :

_file_format
------------

     Title   : _file_format
     Usage   : Internal function for indexing system
     Function: Provides file format for this database
     Example :
     Returns :
     Args    :


File: pm.info,  Node: Bio/LiveSeq/AARange,  Next: Bio/LiveSeq/Chain,  Prev: Bio/Index/Swissprot,  Up: Module List

AARange abstract class for LiveSeq
**********************************

NAME
====

   Bio::LiveSeq::AARange - AARange abstract class for LiveSeq

SYNOPSIS
========

     #documentation needed

DESCRIPTION
===========

   This is used as possible parent for aminoacid range object classes.  Or
it can be used straight away to define aminoacid ranges.  The idea is that
the ranges defined are attached to a Translation object and they refer to
its coordinate-system when they are first created (via the new() method).
When they are created they are anyway linked to the underlying DNA LiveSeq
by way of the LiveSeq labels. This allows to preserve the ranges even if
the numbering changes in the Translation due to deletions or insertions.

   The protein sequence associated with the AARange can be accessed via
the usual seq() or subseq() methods.

   The start and end of the AARange in protein coordinate system can be
fetched with aa_start() and aa_end() methods. Note: the behaviour of these
methods would be influenced by the coordinate_start set in the
corresponding Translation object. This can be desirable but can also lead
to confusion if the coordinate_start had been changed and the original
position of the AARange was to be retrieved.

   start() and end() methods of the AARange will point to the labels
identifying the first nucleotide of the first and last triplet coding for
the start and end of the AminoAcidRange.

   The underlying nucleotide sequence of the AARange can be retrieved with
the labelsubseq() method. This would retrieve the whole DNA sequence,
including possible introns. This is called "DNA_sequence".

   To fetch the nucleotide sequence of the Transcript, without introns,
the labelsubseq() of the attached Transcript (the Transcript the
Translation comes from) has to be accessed. This is called "cDNA_sequence".

   Here are the operations to retrieve these latter two kinds of sequences:

     $startlabel=$AARange->start;
     $endtripletlabel=$AARange->end;
     $endlabel=$AARange->{'seq'}->label(3,$endtripletlabel,$AARange->strand);

     $dnaseq=$AARange->labelsubseq($startlabel,undef,$endlabel));

     $cdnaseq=$AARange->get_Transcript->labelsubseq($startlabel,undef,$endlabel);

   To simplify, these operations have been included in two additional
methods: dna_seq() and cdna_seq().

   These would return the whole sequence, as in the examples above.  But
the above general scheme can be used by specifying different labels, to
retrieve hypothetical subsequences of interest.

AUTHOR - Joseph A.L. Insana
===========================

   Email:  Insana@ebi.ac.uk, jinsana@gmx.net

   Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
===

     Title   : new
     Usage   : $aarange = Bio::LiveSeq::AARange->new(-translation => $obj_ref,
                                                  -start => $beginaa,
                                                  -end => $endaa,
                                                  -name => "ABCD",
                                                  -description => "DCBA",
                                                  -translength => $length);

     Function: generates a new AminoAcidRange LiveSeq object
     Returns : reference to a new object of class AARange
     Errorcode -1
     Args    : two positions in AminoAcid coordinate numbering
               an object reference specifying to which translation the aminoacid
               ranges refer to
               a name and a description (optional)
               an optional "translength" argument: this can be given when
               a lot of AARanges are to be created at the same time for the same
               Translation object, calculating it with $translation->length
               This would increase the speed, avoiding the new() function to
               calculate everytime the same length again and again for every obj.

get_Transcript
--------------

     Title   : valid
     Usage   : $transcript = $obj->get_Transcript()
     Function: retrieves the reference to the object of class Transcript (if any)
               attached to a LiveSeq object
     Returns : object reference
     Args    : none

get_Translation
---------------

     Title   : valid
     Usage   : $translation = $obj->get_Translation()
     Function: retrieves the reference to the object of class Translation (if any)
               attached to a LiveSeq object
     Returns : object reference
     Args    : none

aa_start
--------

     Title   : aa_start
     Usage   : $end = $aarange->aa_start()
     Returns : integer (position, according to Translation coordinate system) of
               the start of an AminoAcidRange object
     Args    : none

aa_end
------

     Title   : aa_end
     Usage   : $end = $aarange->aa_end()
     Returns : integer (position, according to Translation coordinate system) of
               the end of an AminoAcidRange object
     Args    : none

dna_seq
-------

     Title   : dna_seq
     Usage   : $end = $aarange->dna_seq()
     Returns : the sequence at DNA level of the entire AminoAcidRange
               this would include introns (if present)
     Args    : none

cdna_seq
--------

     Title   : cdna_seq
     Usage   : $end = $aarange->cdna_seq()
     Returns : the sequence at cDNA level of the entire AminoAcidRange
               i.e. this is the part of the Transcript that codes for the
               AminoAcidRange. It would be composed just of exonic DNA.
     Args    : none


File: pm.info,  Node: Bio/LiveSeq/Chain,  Next: Bio/LiveSeq/ChainI,  Prev: Bio/LiveSeq/AARange,  Up: Module List

DoubleChain DataStructure for Perl
**********************************

NAME
====

   Bio::LiveSeq::Chain - DoubleChain DataStructure for Perl

SYNOPSIS
========

     #documentation needed

DESCRIPTION
===========

   This is a general purpose module (that's why it's not in object-oriented
form) that introduces a novel datastructure in PERL. It implements the
"double linked chain". The elements of the chain can contain basically
everything. From chars to strings, from object references to arrays or
hashes.  It is used in the LiveSequence project to create a dynamical DNA
sequence, easier to manipulate and change. It's use is mainly for sequence
variation analysis but it could be used - for example - in e-cell projects.
The Chain module in itself doesn't have any biological bias, so can be
used for any programming purpose.

   Each element of the chain (with the exclusion of the first and the last
of the chain) is connected to other two elements (the PREVious and the
NEXT one).  There is no absolute position (like in an array), hence if
positions are important, they need to be computed (methods are provided).
Otherwise it's easy to keep track of the elements with their "LABELs".
There is one LABEL (think of it as a pointer) to each ELEMENT. The labels
won't change after insertions or deletions of the chain. So it's always
possible to retrieve an element even if the chain has been modified by
successive insertions or deletions.  From this the high potential profit
for bioinformatics: dealing with sequences in a way that doesn't have to
rely on positions, without the need of constantly updating them if the
sequence changes, even dramatically.

AUTHOR - Joseph A.L. Insana
===========================

   Email:  Insana@ebi.ac.uk, jinsana@gmx.net

   Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

_updown_chain2string        Title   : chain2string   Usage   : $string = Bio::LiveSeq::Chain::chain2string("down",$chain,6,9)   Function: reads the contents of the chain, outputting a string   Returns : a string   Examples:           : down_chain2string($chain) -> all the chain from begin to end           : down_chain2string($chain,6) -> from 6 to the end           : down_chain2string($chain,6,4) -> from 6, going on 4 elements           : down_chain2string($chain,6,"",10) -> from 6 to 10           : up_chain2string($chain,10,"",6) -> from 10 to 6 upstream   Defaults: start=first element; if len undef, goes to last             if last undef, goes to end             if last defined, it overrides len (undefining it)   Error code: -1   Args    : "up"||"down" as first argument to specify the reading direction              reference (to the chain)             [first] [len] [last] optional integer arguments to specify how             much and from (and to) where to read
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_updown_labels
--------------

     Title   : labels
     Usage   : @labels = Bio::LiveSeq::Chain::_updown_labels("down",$chain,4,16)
     Function: returns all the labels in a chain or those between two
               specified ones (termed "first" and "last")
     Returns : a reference to an array containing the labels
     Args    : "up"||"down" as first argument to specify the reading direction
               reference (to the chain)
               [first] [last] (integer for the starting and eneding labels)

start
-----

     Title   : start
     Usage   : $start = Bio::LiveSeq::Chain::start()
     Returns : the label marking the start of the chain
     Errorcode: -1
     Args    : none

end
---

     Title   : end
     Usage   : $end = Bio::LiveSeq::Chain::end()
     Returns : the label marking the end of the chain
     Errorcode: -1
     Args    : none

label_exists
------------

     Title   : label_exists
     Usage   : $check = Bio::LiveSeq::Chain::label_exists($chain,$label)
     Function: It checks if a label is defined, i.e. if an element is there or
               is not there anymore
     Returns : 1 if the label exists, 0 if it is not there, -1 error
     Errorcode: -1
     Args    : reference to the chain, integer

down_get_pos_of_label
---------------------

     Title   : down_get_pos_of_label
     Usage   : $position = Bio::LiveSeq::Chain::down_get_pos_of_label($chain,$label,$first)
     Function: returns the position of $label counting from $first, i.e. taking
               $first as 1 of coordinate system. If $first is not specified it will
               count from the start of the chain.
     Returns :
     Errorcode: 0
     Args    : reference to the chain, integer (the label of interest)
               optional: integer (a different label that will be taken as the
               first one, i.e. the one to count from)
     Note:     It counts "downstream". To proceed backward use up_get_pos_of_label

down_subchain_length
--------------------

     Title   : down_subchain_length
     Usage   : $length = Bio::LiveSeq::Chain::down_subchain_length($chain,$first,$last)
     Function: returns the length of the chain between the labels "first" and "last", included
     Returns : integer
     Errorcode: 0
     Args    : reference to the chain, integer, integer
     Note:     It counts "downstream". To proceed backward use up_subchain_length

invert_chain
------------

     Title   : invert_chain
     Usage   : $errorcode=Bio::LiveSeq::Chain::invert_chain($chain)
     Function: completely inverts the order of the chain elements; begin is swapped with end and all links updated (PREV&NEXT fields swapped)
     Returns : 1 if all OK, 0 if errors
     Errorcode: 0
     Args    : reference to the chain

down_get_value_at_pos
---------------------

     Title   : down_get_value_at_pos
     Usage   : $value = Bio::LiveSeq::Chain::down_get_value_at_pos($chain,$position,$first)
     Function: used to access the value of the chain at a particular position instead than directly with a label pointer. It will count the position from the start of the chain or from the label $first, if $first is specified
     Returns : whatever is stored in the element of the chain
     Errorcode: 0
     Args    : reference to the chain, integer, [integer]
     Note:     It works "downstream". To proceed backward use up_get_value_at_pos

down_set_value_at_pos
---------------------

     Title   : down_set_value_at_pos
     Usage   : $errorcode = Bio::LiveSeq::Chain::down_set_value_at_pos($chain,$newvalue,$position,$first)
     Function: used to store a new value inside an element of the chain at a particular position instead than directly with a label pointer. It will count the position from the start of the chain or from the label $first, if $first is specified
     Returns : 1
     Errorcode: 0
     Args    : reference to the chain, newvalue, integer, [integer]
               (newvalue can be: integer, string, object reference, hash ref)
     Note:     It works "downstream". To proceed backward use up_set_value_at_pos
     Note2:    If the $newvalue is undef, it will delete the contents of the
               element but it won't remove the element from the chain.

down_set_value_at_label
-----------------------

     Title   : down_set_value_at_label
     Usage   : $errorcode = Bio::LiveSeq::Chain::down_set_value_at_label($chain,$newvalue,$label)
     Function: used to store a new value inside an element of the chain defined by its label.
     Returns : 1
     Errorcode: 0
     Args    : reference to the chain, newvalue, integer
               (newvalue can be: integer, string, object reference, hash ref)
     Note:     It works "downstream". To proceed backward use up_set_value_at_label
     Note2:    If the $newvalue is undef, it will delete the contents of the
               element but it won't remove the element from the chain.

down_get_value_at_label
-----------------------

     Title   : down_get_value_at_label
     Usage   : $value = Bio::LiveSeq::Chain::down_get_value_at_label($chain,$label)
     Function: used to access the value of the chain from one element defined by its label.
     Returns : whatever is stored in the element of the chain
     Errorcode: 0
     Args    : reference to the chain, integer
     Note:     It works "downstream". To proceed backward use up_get_value_at_label

down_get_label_at_pos
---------------------

     Title   : down_get_label_at_pos
     Usage   : $label = Bio::LiveSeq::Chain::down_get_label_at_pos($chain,$position,$first)
     Function: used to retrieve the label of an an element of the chain at a particular position. It will count the position from the start of the chain or from the label $first, if $first is specified
     Returns : integer
     Errorcode: 0
     Args    : reference to the chain, integer, [integer]
     Note:     It works "downstream". To proceed backward use up_get_label_at_pos

_praepostinsert_array
---------------------

     Title   : _praepostinsert_array
     Usage   : ($insbegin,$insend) = Bio::LiveSeq::Chain::_praepostinsert_array($chainref,"post",$arrayref,$position)
     Function: the elements of the array specified by $arrayref are inserted (creating a new subchain) in the chain specified by $chainref, before or after (depending on the "prae"||"post" keyword passed as second argument) the specified position.
     Returns : two labels: the first and the last of the inserted subchain
     Defaults: if no position is specified, the new chain will be inserted after
     (post) the first element of the chain
     Errorcode: 0
     Args    : chainref, "prae"||"post", arrayref, integer (position)

is_downstream
=============

     Title   : is_downstream
     Usage   : Bio::LiveSeq::Chain::is_downstream($chainref,$firstlabel,$secondlabel)
     Function: checks if SECONDlabel follows FIRSTlabel
               It runs downstream the elements of the chain from FIRST searching
               for SECOND.
     Returns : 1 if SECOND is found /after/ FIRST; 0 otherwise (i.e. if it
               reaches the end of the chain without having found it)
     Errorcode -1
     Args    : two labels (integer)

is_upstream
===========

     Title   : is_upstream
     Usage   : Bio::LiveSeq::Chain::is_upstream($chainref,$firstlabel,$secondlabel)
     Function: checks if SECONDlabel follows FIRSTlabel
               It runs upstream the elements of the chain from FIRST searching
               for SECOND.
     Returns : 1 if SECOND is found /after/ FIRST; 0 otherwise (i.e. if it
               reaches the end of the chain without having found it)
     Errorcode -1
     Args    : two labels (integer)

check_chain
-----------

     Title   : check_chain
     Usage   : @errorcodes = Bio::LiveSeq::Chain::check_chain()
     Function: a wraparound to a series of check for consistency of the chain
               It will check for boundaries, size, backlinking and forwardlinking
     Returns : array of 4 warn codes, each can be 1 (all ok) or 0 (something wrong)
     Errorcode: 0
     Args    : none
     Note    : this is slow and through. It is not really needed. It is mostly
               a code-developer tool.

splice_chain
------------

     Title   : splice_chain
     Usage   : @errorcodes = Bio::LiveSeq::Chain::splice_chain($chainref,$first,$length,$last)
     Function: removes the elements designated by FIRST and LENGTH from a chain.
               The chain shrinks accordingly. If LENGTH is omitted, removes
               everything from FIRST onward.
               If END is specified, LENGTH is ignored and instead the removal
               occurs from FIRST to LAST.
     Returns : the elements removed as a string
     Errorcode: -1
     Args    : chainref, integer, integer, integer

array2chain
-----------

     Title   : array2chain
     Usage   : $chainref = Bio::LiveSeq::Chain::array2chain($arrayref,$offset)
     Function: creation of a double linked chain from an array
     Returns : reference to a hash containing the chain
     Defaults: OFFSET defaults to 1 if undef
     Error code: 0
     Args    : a reference to an array containing the elements to be chainlinked
               an optional integer > 0 (this will be the starting count for
               the chain labels instead than having them begin from "1")


File: pm.info,  Node: Bio/LiveSeq/ChainI,  Next: Bio/LiveSeq/DNA,  Prev: Bio/LiveSeq/Chain,  Up: Module List

Double linked chain data structure
**********************************

NAME
====

   Bio::LiveSeq::ChainI - Double linked chain data structure

SYNOPSIS
========

     #documentation needed

DESCRIPTION
===========

   This class generates and manipulates generic double linked list, chain,
that can be used to manage biological sequences.

   The advantages over strings or plain arrays is the ease of tracking
changes (mutations) in the elements (sequence). The other side of the coin
is that these structures need consideraly more memory, but that is cheap
and constantly inceasing resource in computers.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     vsns-bcd-perl@lists.uni-bielefeld.de          - General discussion
     vsns-bcd-perl-guts@lists.uni-bielefeld.de     - Technically-oriented discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via  email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Joseph A.L. Insana
===========================

   Email:  Insana@ebi.ac.uk, jinsana@gmx.net Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new        Title   : new   Usage   : $chain = Bio::LiveSeq::ChainI->new(-string => "thequickbrownfoxjumpsoverthelazydog", 					     -offset => 3 );          OR $chain = Bio::LiveSeq::ChainI->new(-array => \@array, 					     -offset => 3 );   Function: generates a new Bio::LiveSeq:ChainI   Returns : a new Chain   Args    : string          OR arrayreference         AND optional offset to create element labels =cut
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

   sub new {   my ($thing, %args) = @_;   my $class = ref($thing) ||
$thing;   my $obj;

     if ($args{-string}) {
       $obj = $thing->string2chain($args{-string}, $args{-offset});
     } elsif ($args{-array}) {
       $obj = $thing->array2chain($args{-array}, $args{-offset});
     } else {
       croak "$class not initialized properly";
     }

     $obj = bless $obj, $class;
     return $obj;
     }

   # added as of 1.9 sub string2chain {   shift @_; # so that it doesn't
pass the object reference   return Bio::LiveSeq::Chain::string2chain(@_); }
sub array2chain {   shift @_; # so that it doesn't pass the object
reference   return Bio::LiveSeq::Chain::array2chain(@_); } # sub
chain2string {   croak "ambiguous method call. Explicit down_ or up_"; }
sub down_chain2string {   return
Bio::LiveSeq::Chain::down_chain2string(@_); } sub up_chain2string {
return Bio::LiveSeq::Chain::up_chain2string(@_); } sub
chain2string_verbose {   croak "ambiguous method call. Explicit down_ or
up_"; } sub down_chain2string_verbose {   return
Bio::LiveSeq::Chain::down_chain2string_verbose(@_); } sub
up_chain2string_verbose {   return
Bio::LiveSeq::Chain::up_chain2string_verbose(@_); } sub invert_chain {
return Bio::LiveSeq::Chain::invert_chain(@_); } sub mutate_element {
croak "Old method name, please update code to: set_value_at_label"; }

   # new as of version 2.33 of Chain.pm sub down_labels {   return
Bio::LiveSeq::Chain::down_labels(@_); } sub up_labels {   return
Bio::LiveSeq::Chain::up_labels(@_); }

   sub start {   return Bio::LiveSeq::Chain::start(@_); } sub end {
return Bio::LiveSeq::Chain::end(@_); } sub label_exists {   return
Bio::LiveSeq::Chain::label_exists(@_); }

   sub get_value_at_pos {   croak "ambiguous method call. Explicit down_
or up_"; } sub down_get_value_at_pos {   return
Bio::LiveSeq::Chain::down_get_value_at_pos(@_); } sub up_get_value_at_pos {
 return Bio::LiveSeq::Chain::up_get_value_at_pos(@_); } sub
set_value_at_pos {   croak "ambiguous method call. Explicit down_ or up_";
} sub down_set_value_at_pos {   return
Bio::LiveSeq::Chain::down_set_value_at_pos(@_); } sub up_set_value_at_pos {
 return Bio::LiveSeq::Chain::up_set_value_at_pos(@_); } sub
get_value_at_label {   return Bio::LiveSeq::Chain::get_value_at_label(@_);
} sub set_value_at_label {   return
Bio::LiveSeq::Chain::set_value_at_label(@_); } sub get_label_at_pos {
croak "ambiguous method call. Explicit down_ or up_"; } sub
up_get_label_at_pos {   return
Bio::LiveSeq::Chain::up_get_label_at_pos(@_); } sub down_get_label_at_pos {
 return Bio::LiveSeq::Chain::down_get_label_at_pos(@_); } sub
get_pos_of_label {   croak "ambiguous method call. Explicit down_ or up_";
} sub up_get_pos_of_label {   return
Bio::LiveSeq::Chain::up_get_pos_of_label(@_); } sub down_get_pos_of_label {
 return Bio::LiveSeq::Chain::down_get_pos_of_label(@_); } #

   sub preinsert_string {   return
Bio::LiveSeq::Chain::praeinsert_string(@_); } sub preinsert_array {
return Bio::LiveSeq::Chain::praeinsert_array(@_); } sub praeinsert_string {
 return Bio::LiveSeq::Chain::praeinsert_string(@_); } sub
postinsert_string {   return Bio::LiveSeq::Chain::postinsert_string(@_); }
sub praeinsert_array {   return Bio::LiveSeq::Chain::praeinsert_array(@_);
} sub postinsert_array {   return
Bio::LiveSeq::Chain::postinsert_array(@_); } sub down_element{   return
Bio::LiveSeq::Chain::down_element(@_); } sub up_element {   return
Bio::LiveSeq::Chain::up_element(@_); } sub is_downstream {   return
Bio::LiveSeq::Chain::is_downstream(@_); } sub is_upstream {   return
Bio::LiveSeq::Chain::is_upstream(@_); } sub check_chain {   return
Bio::LiveSeq::Chain::check_chain(@_); } sub chain_length {   return
Bio::LiveSeq::Chain::chain_length(@_); } sub splice_chain {   return
Bio::LiveSeq::Chain::splice_chain(@_); } sub pos_of_element {   croak
"ambiguous and old method name. use: down_pos_of_label"; } sub
up_pos_of_element {   croak "old method name. use: down_pos_of_label";
return Bio::LiveSeq::Chain::up_pos_of_element(@_); } sub
down_pos_of_element {   croak "old method name. use: up_pos_of_label";
return Bio::LiveSeq::Chain::down_pos_of_element(@_); } sub subchain_length
{   croak "ambiguous method call. Explicit down_ or up_"; } sub
down_subchain_length {   return
Bio::LiveSeq::Chain::down_subchain_length(@_); } sub up_subchain_length {
return Bio::LiveSeq::Chain::up_subchain_length(@_); }

   # these have to be deleted and changed names to conform to terminology
sub elements {   return Bio::LiveSeq::Chain::down_elements(@_); } sub
up_elements {   return Bio::LiveSeq::Chain::up_elements(@_); } sub
down_elements {   return Bio::LiveSeq::Chain::down_elements(@_); }

   1;


File: pm.info,  Node: Bio/LiveSeq/DNA,  Next: Bio/LiveSeq/Exon,  Prev: Bio/LiveSeq/ChainI,  Up: Module List

DNA object for LiveSeq
**********************

NAME
====

   Bio::LiveSeq::DNA - DNA object for LiveSeq

SYNOPSIS
========

     # documentation needed

DESCRIPTION
===========

   This holds the DNA sequence (or the RNA in the case of cDNA entries)
and is accessed by exons, genes, transcripts... objects

AUTHOR - Joseph A.L. Insana
===========================

   Email:  Insana@ebi.ac.uk, jinsana@gmx.net

   Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
===

     Title   : new
     Usage   : $dna = Bio::LiveSeq::DNA->new(-seq => "atcgaccaatggacctca",
     					  -offset => 3 );

     Function: generates a new Bio::LiveSeq::DNA
     Returns : reference to a new object of class DNA
     Errorcode -1
     Args    : a string
           AND an optional offset to create nucleotide labels (default is 1, i.e.
               starting the count of labels from "1") -> do not bother using it ->
               it could be used by alternative loaders !EMBL format
     NOTE    : strand of DNA is set to 1 by default


File: pm.info,  Node: Bio/LiveSeq/Exon,  Next: Bio/LiveSeq/Gene,  Prev: Bio/LiveSeq/DNA,  Up: Module List

Range abstract class for LiveSeq
********************************

NAME
====

   Bio::LiveSeq::Exon - Range abstract class for LiveSeq

SYNOPSIS
========

     # documentation needed

DESCRIPTION
===========

   Class for EXON objects. They consist of a beginlabel, an endlabel (both
referring to a LiveSeq DNA object) and a strand.  The strand could be 1
(forward strand, default), -1 (reverse strand).

AUTHOR - Joseph A.L. Insana
===========================

   Email:  Insana@ebi.ac.uk, jinsana@gmx.net

   Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
===

     Title   : new
     Usage   : $exon1 = Bio::LiveSeq::Exon-> new(-seq => $objref,
     					      -start => $startlabel,
     					      -end => $endlabel, -strand => 1);

     Function: generates a new Bio::LiveSeq::Exon
     Returns : reference to a new object of class Exon
     Errorcode -1
     Args    : two labels and an integer

get_Transcript
--------------

     Title   : get_Transcript
     Usage   : $transcript = $obj->get_Transcript()
     Function: retrieves the reference to the object of class Transcript (if any)
               attached to a LiveSeq object
     Returns : object reference
     Args    : none
     Note    : only Exons that compose a Transcript (i.e. those created out of
               a CDS Entry-Feature) will have an attached Transcript


File: pm.info,  Node: Bio/LiveSeq/Gene,  Next: Bio/LiveSeq/IO/BioPerl,  Prev: Bio/LiveSeq/Exon,  Up: Module List

Range abstract class for LiveSeq
********************************

NAME
====

   Bio::LiveSeq::Gene - Range abstract class for LiveSeq

SYNOPSIS
========

     # documentation needed

DESCRIPTION
===========

   This is used as storage for all object references concerning a
particular gene.

AUTHOR - Joseph A.L. Insana
===========================

   Email:  Insana@ebi.ac.uk, jinsana@gmx.net

   Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
===

     Title   : new
     Usage   : $gene = Bio::LiveSeq::Gene->new(-name => "name",
                                               -features => $hashref
                                               -upbound => $min
                                               -downbound => $max);

     Function: generates a new Bio::LiveSeq::Gene
     Returns : reference to a new object of class Gene
     Errorcode -1
     Args    : one string and one hashreference containing all features defined
               for the Gene and the references to the LiveSeq objects for those
               features.
               Two labels for defining boundaries of the gene. Usually the
               boundaries will reflect max span of transcript, exon... features,
               while the DNA sequence will be created with some flanking regions
               (e.g. with the EMBL_SRS::gene2liveseq routine).
               If these two labels are not given, they will default to the start
               and end of the DNA object.
     Note    : the format of the hash has to be like
                  DNA => reference to LiveSeq::DNA object
                  Transcripts => reference to array of transcripts objrefs
                  Transclations => reference to array of transcripts objrefs
                  Exons => ....
                  Introns => ....
                  Prim_Transcripts => ....
                  Repeat_Units => ....
                  Repeat_Regions => ....
               Only DNA and Transcripts are mandatory


