This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Win32/Semaphore,  Next: Win32/Service,  Prev: Win32/RASE,  Up: Module List

Use Win32 semaphore objects from Perl
*************************************

NAME
====

   Win32::Semaphore - Use Win32 semaphore objects from Perl

SYNOPSIS 	require Win32::Semaphore;
===================================

     $sem = Win32::Semaphore->new($initial,$maximum,$name);
     $sem->wait;

DESCRIPTION
===========

   This module allows access to Win32 semaphore objects.  The wait method
and `wait_all' & `wait_any' functions are inherited from the
`"Win32::IPC"' in this node module.

Methods
-------

$semaphore = Win32::Semaphore->new($initial, $maximum, [$name])
     Constructor for a new semaphore object.  `$initial' is the initial
     count, and `$maximum' is the maximum count for the semaphore.  If
     $name is omitted, creates an unnamed semaphore object.

     If $name signifies an existing semaphore object, then `$initial' and
     `$maximum' are ignored and the object is opened.

$semaphore = Win32::Semaphore->open($name)
     Constructor for opening an existing semaphore object.

$semaphore->release([$increment, [$previous]])
     Increment the count of $semaphore by `$increment' (default 1).  If
     `$increment' plus the semaphore's current count is more than its
     maximum count, the count is not changed.  Returns true if the
     increment is successful.

     The semaphore's count (before incrementing) is stored in the second
     argument (if any).

     It is not necessary to wait on a semaphore before calling release,
     but you'd better know what you're doing.

$semaphore->wait([$timeout])
     Wait for $semaphore's count to be nonzero, then decrement it by 1.
     See `"Win32::IPC"' in this node.

Deprecated Functions and Methods
--------------------------------

   *Win32::Semaphore* still supports the ActiveWare syntax, but its use is
deprecated.

Win32::Semaphore::Create($SemObject,$Initial,$Max,$Name)
     Use `$SemObject = Win32::Semaphore->new($Initial,$Max,$Name)' instead.

Win32::Semaphore::Open($SemObject, $Name)
     Use `$SemObject = Win32::Semaphore->open($Name)' instead.

$SemObj->Release($Count,$LastVal)
     Use `$SemObj->release($Count,$LastVal)' instead.

AUTHOR
======

   Christopher J. Madsen <`chris_madsen@geocities.com'>

   Loosely based on the original module by ActiveWare Internet Corp.,
`http://www.ActiveWare.com'


File: pm.info,  Node: Win32/Service,  Next: Win32/Sound,  Prev: Win32/Semaphore,  Up: Module List

manage system services in perl
******************************

NAME
====

   Win32::Service - manage system services in perl

SYNOPSIS
========

     use Win32::Service;

DESCRIPTION
===========

   This module offers control over the administration of system services.

FUNCTIONS
=========

NOTE:
-----

   All of the functions return FALSE (0) if they fail, unless otherwise
noted.  If hostName is an empty string, the local machine is assumed.

StartService(hostName, serviceName)
     Start the service serviceName on machine hostName.

StopService(hostName, serviceName)
     Stop the service serviceName on the machine hostName.

GetStatus(hostName, serviceName, status)
     Get the status of a service.  The third argument must be a hash
     reference that will be populated with entries corresponding to the
     SERVICE_STATUS structure of the Win32 API.  See the Win32 Platform
     SDK documentation for details of this structure.

PauseService(hostName, serviceName)
ResumeService(hostName, serviceName)
GetServices(hostName, hashref)
     Enumerates both active and inactive Win32 services at the specified
     host.  The hashref is populated with the descriptive service names as
     keys and the short names as the values.


File: pm.info,  Node: Win32/Sound,  Next: Win32/SystemInfo,  Prev: Win32/Service,  Up: Module List

An extension to play with Windows sounds
****************************************

NAME
====

   Win32::Sound - An extension to play with Windows sounds

SYNOPSIS
========

     use Win32::Sound;
     Win32::Sound::Volume('100%');
     Win32::Sound::Play("file.wav");
     Win32::Sound::Stop();
     
     # ...and read on for more fun ;-)

FUNCTIONS
=========

*Win32::Sound::Play(SOUND, [FLAGS])*
     Plays the specified sound: SOUND can the be name of a WAV file or one
     of the following predefined sound names:

          SystemDefault
          SystemAsterisk
          SystemExclamation
          SystemExit
          SystemHand
          SystemQuestion
          SystemStart

     Additionally, if the named sound could not be found, the function
     plays the system default sound (unless you specify the
     `SND_NODEFAULT' flag). If no parameters are given, this function
     stops the sound actually playing (see also Win32::Sound::Stop).

     FLAGS can be a combination of the following constants:

    `SND_ASYNC'
          The sound is played asynchronously and the function returns
          immediately after beginning the sound (if this flag is not
          specified, the sound is played synchronously and the function
          returns when the sound ends).

    `SND_LOOP'
          The sound plays repeatedly until it is stopped.  You must also
          specify `SND_ASYNC' flag.

    `SND_NODEFAULT'
          No default sound is used. If the specified sound cannot be
          found, the function returns without playing anything.

    `SND_NOSTOP'
          If a sound is already playing, the function fails.  By default,
          any new call to the function will stop previously playing sounds.

Win32::Sound::Stop()
     Stops the sound currently playing.

Win32::Sound::Volume()
     Returns the wave device volume; if called in an array context,
     returns left and right values. Otherwise, returns a single 32 bit
     value (left in the low word, right in the high word).  In case of
     error, returns undef and sets $!.

     Examples:

          ($L, $R) = Win32::Sound::Volume();
          if( not defined Win32::Sound::Volume() ) {
              die "Can't get volume: $!";
          }

*Win32::Sound::Volume(LEFT, [RIGHT])*
     Sets the wave device volume; if two arguments are given, sets left
     and right channels independently, otherwise sets them both to LEFT
     (eg. RIGHT=LEFT). Values range from 0 to 65535 (0xFFFF), but they can
     also be given as percentage (use a string containing a number
     followed by a percent sign).

     Returns undef and sets $! in case of error, a true value if
     successful.

     Examples:

          Win32::Sound::Volume('50%');
          Win32::Sound::Volume(0xFFFF, 0x7FFF);
          Win32::Sound::Volume('100%', '50%');
          Win32::Sound::Volume(0);

Win32::Sound::Format(filename)
     Returns information about the specified WAV file format; the array
     contains:

        * sample rate (in Hz)

        * bits per sample (8 or 16)

        * channels (1 for mono, 2 for stereo)

     Example:

          ($hz, $bits, $channels)
              = Win32::Sound::Format("file.wav");

Win32::Sound::Devices()
     Returns all the available sound devices; their names contain the type
     of the device (WAVEOUT, WAVEIN, MIDIOUT, MIDIIN, AUX or MIXER) and a
     zero-based ID number: valid devices names are for example:

          WAVEOUT0
          WAVEOUT1
          WAVEIN0
          MIDIOUT0
          MIDIIN0
          AUX0
          AUX1
          AUX2

     There are also two special device names, `WAVE_MAPPER' and
     `MIDI_MAPPER' (the default devices for wave output and midi output).

     Example:

          @devices = Win32::Sound::Devices();

Win32::Sound::DeviceInfo(DEVICE)
     Returns an associative array of information about the sound device
     named DEVICE (the same format of Win32::Sound::Devices).

     The content of the array depends on the device type queried. Each
     device type returns *at least* the following information:

          manufacturer_id
          product_id
          name
          driver_version

     For additional data refer to the following table:

          WAVEIN..... formats
                      channels
          
          WAVEOUT.... formats
                      channels
                      support
          
          MIDIOUT.... technology
                      voices
                      notes
                      channels
                      support
          
          AUX........ technology
                      support
          
          MIXER...... destinations
                      support

     The meaning of the fields, where not obvious, can be evinced from the
     Microsoft SDK documentation (too long to report here, maybe one
     day... :-).

     Example:

          %info = Win32::Sound::DeviceInfo('WAVE_MAPPER');
          print "$info{name} version $info{driver_version}\n";

THE WaveOut PACKAGE
===================

   Win32::Sound also provides a different, more powerful approach to wave
audio data with its `WaveOut' package. It has methods to load and then
play WAV files, with the additional feature of specifying the start and
end range, so you can play only a portion of an audio file.

   Furthermore, it is possible to load arbitrary binary data to the
soundcard to let it play and save them back into WAV files; in a few words,
you can do some sound synthesis work.

FUNCTIONS
---------

new Win32::Sound::WaveOut(FILENAME)
new Win32::Sound::WaveOut(SAMPLERATE, BITS, CHANNELS)
new Win32::Sound::WaveOut()
     This function creates a `WaveOut' object; the first form opens the
     specified wave file (see also `Open()' ), so you can directly
     `Play()' it.

     The second (and third) form opens the wave output device with the
     format given (or if none given, defaults to 44.1kHz, 16 bits,
     stereo); to produce something audible you can either `Open()' a wave
     file or `Load()' binary data to the soundcard and then Write() it.

Close()
     Closes the wave file currently opened.

CloseDevice()
     Closes the wave output device; you can change format and reopen it
     with OpenDevice().

GetErrorText(ERROR)
     Returns the error text associated with the specified ERROR number;
     note it only works for wave-output-specific errors.

Load(DATA)
     Loads the DATA buffer in the soundcard.  The format of the data
     buffer depends on the format used; for example, with 8 bit mono each
     sample is one character, while with 16 bit stereo each sample is four
     characters long (two 16 bit values for left and right channels). The
     sample rate defines how much samples are in one second of sound. For
     example, to fit one second at 44.1kHz 16 bit stereo your buffer must
     contain 176400 bytes (44100 * 4).

Open(FILE)
     Opens the specified wave FILE.

OpenDevice()
     Opens the wave output device with the current sound format (not
     needed unless you used CloseDevice()).

Pause()
     Pauses the sound currently playing; use Restart() to continue playing.

Play( [FROM, TO] )
     Plays the opened wave file. You can optionally specify a FROM - TO
     range, where FROM and TO are expressed in samples (or use FROM=0 for
     the first sample and TO=-1 for the last sample).  Playback happens
     always asynchronously, eg. in the background.

Position()
     Returns the sample number currently playing; note that the play
     position is not zeroed when the sound ends, so you have to call a
     Reset() between plays to receive the correct position in the current
     sound.

Reset()
     Stops playing and resets the play position (see Position()).

Restart()
     Continues playing the sound paused by Pause().

Save(FILE, [DATA])
     Writes the DATA buffer (if not given, uses the buffer currently
     loaded in the soundcard) to the specified wave FILE.

Status()
     Returns 0 if the soundcard is currently playing, 1 if it's free, or
     undef on errors.

Unload()
     Frees the soundcard from the loaded data.

Volume( [LEFT, RIGHT] )
     Gets or sets the volume for the wave output device.  It works the
     same way as Win32::Sound::Volume.

Write()
     Plays the data currently loaded in the soundcard; playback happens
     always asynchronously, eg. in the background.

THE SOUND FORMAT
----------------

   The sound format is stored in three properties of the `WaveOut' object:
`samplerate', bits and channels.  If you need to change them without
creating a new object, you should close before and reopen afterwards the
device.

     $WAV->CloseDevice();
     $WAV->{samplerate} = 44100; # 44.1kHz
     $WAV->{bits}       = 8;     # 8 bit
     $WAV->{channels}   = 1;     # mono
     $WAV->OpenDevice();

   You can also use the properties to query the sound format currently
used.

EXAMPLE
-------

   This small example produces a 1 second sinusoidal wave at 440Hz and
saves it in `sinus.wav':

     use Win32::Sound;
     
     # Create the object
     $WAV = new Win32::Sound::WaveOut(44100, 8, 2);
     
     $data = "";
     $counter = 0;
     $increment = 440/44100;
     
     # Generate 44100 samples ( = 1 second)
     for $i (1..44100) {

     # Calculate the pitch
     # (range 0..255 for 8 bits)
     $v = sin($counter/2*3.14) * 128 + 128;

     # "pack" it twice for left and right
     $data .= pack("cc", $v, $v);

     $counter += $increment;
         }
     
         $WAV->Load($data);       # get it
         $WAV->Write();           # hear it
         1 until $WAV->Status();  # wait for completion
         $WAV->Save("sinus.wav"); # write to disk
         $WAV->Unload();          # drop it

VERSION
=======

   Win32::Sound version 0.45, 09 Apr 1999.

AUTHOR
======

   Aldo Calpini, `dada@divinf.it'

   Parts of the code provided and/or suggested by Dave Roth.


File: pm.info,  Node: Win32/SystemInfo,  Next: Win32/TieRegistry,  Prev: Win32/Sound,  Up: Module List

Memory and Processor information on Win32 systems
*************************************************

NAME
====

   Win32::SystemInfo - Memory and Processor information on Win32 systems

SYNOPSIS
========

     use Win32::SystemInfo;

   # Get Memory Information

   my %mHash; 	if (Win32::SystemInfo::MemoryStatus(%mHash)) 	{
...process results...  	}

   	To get specific values:     my %mHash = (TotalPhys => 0, AvailPhys =>
0); 	if (Win32::SystemInfo::MemoryStatus(%mHash)) 	{ 	 ...mHash contains only
TotalPhys and AvailPhys values...  	}

   Change the default return value:
Win32::SystemInfo::MemoryStatus(%mHash,"MB");

   # Get Processor Information

     my $proc = Win32::SystemInfo::ProcessorInfo();
     	if ($proc >= 586) { ... }
     
     	my %phash;
     	Win32::SystemInfo::ProcessorInfo(%phash);
     	for (my $i = 0; $i < $phash{NumProcessors}; $i++) {
     	 print "Speed of processor $i: " . $phash{"Processor$i"}{MHZ} . "MHz\n";
     	}

ABSTRACT
========

   With this module you can get total/free memory on Win32 systems,
including installed RAM (physical memory) and page file. This module will
also let you access processor information, including processor family
(386,486,etc), speed, vendor, and revision information.

DESCRIPTION
===========

   Module provides two functions:

MemoryStatus
     *Win32::SystemInfo::MemoryStatus*(%mHash,[$format]);

          %mHash                      - The hash that will receive the results.
                                        Certain values can be set prior to the
                                        call to retrieve a subset. (See below)
          $format                     - Optional parameter. Used to set the order
                                        of magnitude of the results. (See below)

          Determines the current memory status of a Win32 machine. Populates
          %mHash with the results. Function returns undef on failure.
          
          Values returned through the hash:
          MemLoad                     - Windows NT 3.1 to 4.0: The percentage of
                                        approximately the last 1000 pages of physical
                                        memory that is in use.
                                      - Windows 2000: The approximate percentage of
                                        total physical memory that is in use.
          TotalPhys                   - Total amount of physical memory (RAM).
          AvailPhys                   - Available physical memory (RAM).
          TotalPage                   - Allocated size of page (swap) file.
          AvailPage                   - Available page file memory.
          TotalVirtual                - Total physical + maximum page file.
          AvailVirtual                - Total amount of available memory.
          
          Values returned through the hash can also be specified by setting
          them before the function is called.
              my %mHash = (TotalPhys => 0);
              Win32::MemoryInfo::MemoryStatus(%mHash);
          
          Will return only the total physical memory.
          
          MemoryStatus return values in bytes by default. This can be changed with
          the $format parameter. Valid values for $format are:
              B        -  Bytes (default)
              KB       -  Kilobytes
              MB       -  Megabytes
              GB       -  Gigabytes

ProcessorInfo
     $proc = *Win32::SystemInfo::ProcessorInfo*([%pHash]);

          Determines the processor information of a Win32 computer. Returns a "quick"
          value or undef on failure. Can also populate %pHash with detailed information
          on all processors present in the system.
          
          $proc                        - Contains a numerical representation of the
                                       - processor level for Intel machines. For
                                       - example, a Pentium will return 586.
                                       - For non-Intel Windows NT systems, the
                                       - possible return values are:
                                       - PPC: PowerPC
                                       - MIPS: MIPS architecture
                                       - ALPHA: Alpha architecture
                                       - UNKNOWN: Unknown architecture
          
          %pHash                       - Optional parameter. Will be filled with
                                       - information about all processors.
          
          Values returned through hash:
          NumProcessors                - The number of processors installed
          ProcessorN                   - A hash containing all info for processor N
          
          Each ProcessorN hash contains the values:
          Identifier                   - The identifier string for the processor
                                       - as found in the registry. The computer I'm
                                       - currently using returns the string
                                       - "x86 Family 6 Model 7 Stepping 3"
          VendorIdentifier             - The vendor name of the processor
          MHZ                          - The speed in MHz of the processor
                                       - Returns -1 if unable to determine.
          
          PLEASE read the note about the MHz value in Caveats, below.

   No functions are exported.

INSTALLATION
============

   Installation is simple. Follow these steps:

   perl makefile.pl nmake nmake test nmake install

   Copy the SystemInfo.html file into whatever directory you keep your
documentation in. I haven't figured out yet how to automatically copy it
over, sorry.

   I've noticed that ActiveState can give an error about not being able to
find perl when processing the makefile.pl file on Win9x.  To get around
this, open makefile.pl and add another key/value pair into WriteMakefile()
that looks like this: 'PERL'	=> 'full/path/to/your/perl.exe', That
should do the trick!

   This module can also be used by simply placing it and the included DLL
in your /Win32 directory somewhere in @INC.

   This module requires Win32::API module by Aldo Calpini
Win32::TieRegistry by Tye McQueen

CAVEATS
=======

   The information returned by the MemoryStatus function is volatile.
There is no guarantee that two sequential calls to this function will
return the same information.

   On computers with more than 4 GB of memory, the MemoryStatus function
can return incorrect information. Windows 2000 reports a value of -1 to
indicate an overflow. Earlier versions of Windows NT report a value that
is the real amount of memory, modulo 4 GB.

   On Intel x86 computers with more than 2 GB and less than 4 GB of memory,
the MemoryStatus function will always return 2 GB for TotalPhys.
Similarly, if the total available memory is between 2 and 4 GB, AvailPhys
will be rounded down to 2 GB.

   ProcessorInfo will only reliably return CPU speed for Intel chips, and
AMD chips that support the time stamp counter. (This appears to be K6-2,
K6-III, all Athlons, and Duron.) The return value for MHz should always be
checked in a Win9x environment to verify that it is valid. (Invalid
processors, or other errors will return a -1.)

   The ProcessorInfo function has been only tested in these environments:
Windows 98, Single Pentium II processor Windows NT 4.0, Single Pentium III
processor

   All feedback on other configurations is greatly welcomed.

   This module has been created and tested on Windows 98 and WinNT 4.0 on
ActiveState port of Perl 5.6. It has not been tested on Windows 2000 yet.

CHANGES
=======

     0.01 - Initial Release
     0.02 - Fixed CPU speed reporting for Win9x. Module now includes a DLL that
            performs the Win9x CPU speed determination.
     0.03 - Fixed warning "use of uninitialized value" when calling MemoryStatus
            with no size argument.
     0.04 - Fixed "GetValue" error when calling ProcessorInfo as non-admin user
            on Windows NT
          - Fixed documentation bug: "AvailableVirtual" to "AvailVirtual"
     0.05 - Fixed bug introduced in 0.03 where $format was ignored in
            MemoryStatus. All results were returned in bytes regardless of
            $format parameter.

BUGS
====

   Please report.

VERSION
=======

   This man page documents Win32::SystemInfo version 0.05

   February 6, 2001.

AUTHOR
======

   Chad Johnston <cjohnston@rockstardevelopment.com>

COPYRIGHT
=========

   Copyright (C) 2001 by Chad Johnston. All rights reserved.

LICENSE
=======

   This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   perl(1).

   Win32 Win32/Utilities


File: pm.info,  Node: Win32/TieRegistry,  Next: Win32API/Const,  Prev: Win32/SystemInfo,  Up: Module List

Powerful and easy ways to manipulate a registry [on Win32 for now].
*******************************************************************

NAME
====

   Win32::TieRegistry - Powerful and easy ways to manipulate a registry
[on Win32 for now].

SYNOPSIS
========

     use Win32::TieRegistry 0.20 ( UseOptionName=>UseOptionValue[,...] );

     $Registry->SomeMethodCall(arg1,...);

     $subKey= $Registry->{"Key\\SubKey\\"};
     $valueData= $Registry->{"Key\\SubKey\\\\ValueName"};
     $Registry->{"Key\\SubKey\\"}= { "NewSubKey" => {...} };
     $Registry->{"Key\\SubKey\\\\ValueName"}= "NewValueData";
     $Registry->{"\\ValueName"}= [ pack("fmt",$data), REG_DATATYPE ];

EXAMPLES
========

     use Win32::TieRegistry( Delimiter=>"#", ArrayValues=>0 );
     $pound= $Registry->Delimiter("/");
     $diskKey= $Registry->{"LMachine/System/Disk/"}
       or  die "Can't read LMachine/System/Disk key: $^E\n";
     $data= $key->{"/Information"}
       or  die "Can't read LMachine/System/Disk//Information value: $^E\n";
     $remoteKey= $Registry->{"//ServerA/LMachine/System/"}
       or  die "Can't read //ServerA/LMachine/System/ key: $^E\n";
     $remoteData= $remoteKey->{"Disk//Information"}
       or  die "Can't read ServerA's System/Disk//Information value: $^E\n";
     foreach $entry (  keys(%$diskKey)  ) {
         ...
     }
     foreach $subKey (  $diskKey->SubKeyNames  ) {
         ...
     }
     $diskKey->AllowSave( 1 );
     $diskKey->RegSaveKey( "C:/TEMP/DiskReg", [] );

DESCRIPTION
===========

   The *Win32::TieRegistry* module lets you manipulate the Registry via
objects [as in "object oriented"] or via tied hashes.  But you will
probably mostly use a combination reference, that is, a reference to a
tied hash that has also been made an object so that you can mix both
access methods [as shown above].

   If you did not get this module as part of `libwin32' in this node, you
might want to get a recent version of `libwin32' in this node from CPAN
which should include this module and the *Win32API::Registry* module that
it uses.

   Skip to the `SUMMARY' in this node section if you just want to dive in
and start using the Registry from Perl.

   Accessing and manipulating the registry is extremely simple using
*Win32::TieRegistry*.  A single, simple expression can return you almost
any bit of information stored in the Registry.  *Win32::TieRegistry* also
gives you full access to the "raw" underlying API calls so that you can do
anything with the Registry in Perl that you could do in C.  But the
"simple" interface has been carefully designed to handle almost all
operations itself without imposing arbitrary limits while providing
sensible defaults so you can list only the parameters you care about.

   But first, an overview of the Registry itself.

The Registry
------------

   The Registry is a forest:  a collection of several tree structures.
The root of each tree is a key.  These root keys are identified by
predefined constants whose names start with "HKEY_".  Although all keys
have a few attributes associated with each [a class, a time stamp, and
security information], the most important aspect of keys is that each can
contain subkeys and can contain values.

   Each subkey has a name:  a string which cannot be blank and cannot
contain the delimiter character [backslash: `'\\''] nor nul [`'\0''].
Each subkey is also a key and so can contain subkeys and values [and has a
class, time stamp, and security information].

   Each value has a name:  a string which E<can> be blank and E<can>
contain the delimiter character [backslash: `'\\''] and any character
except for null, `'\0''.  Each value also has data associated with it.
Each value's data is a contiguous chunk of bytes, which is exactly what a
Perl string value is so Perl strings will usually be used to represent
value data.

   Each value also has a data type which says how to interpret the value
data.  The primary data types are:

REG_SZ
     A null-terminated string.

REG_EXPAND_SZ
     A null-terminated string which contains substrings consisting of a
     percent sign [`'%''], an environment variable name, then a percent
     sign, that should be replaced with the value associate with that
     environment variable.  The system does not automatically do this
     substitution.

REG_BINARY
     Some arbitrary binary value.  You can think of these as being
     "packed" into a string.

     If your system has the `SetDualVar' in this node module installed,
     the `DualBinVals()' option wasn't turned off, and you fetch a
     REG_BINARY value of 4 bytes or fewer, then you can use the returned
     value in a numeric context to get at the "unpacked" numeric value.
     See `GetValue()' for more information.

REG_MULTI_SZ
     Several null-terminated strings concatenated together with an extra
     trailing `'\0'' at the end of the list.  Note that the list can
     include empty strings so use the value's length to determine the end
     of the list, not the first occurrence of `'\0\0''.  It is best to set
     the `SplitMultis()' option so *Win32::TieRegistry* will split these
     values into an array of strings for you.

REG_DWORD
     A long [4-byte] integer value.  These values are expected either
     packed into a 4-character string or as a hex string of E<more than> 4
     characters [but not as a numeric value, unfortunately, as there is no
     sure way to tell a numeric value from a packed 4-byte string that
     just happens to be a string containing a valid numeric value].

     How such values are returned depends on the `DualBinVals()' and
     `DWordsToHex()' options.  See `GetValue()' for details.

   In the underlying Registry calls, most places which take a subkey name
also allow you to pass in a subkey "path" - a string of several subkey
names separated by the delimiter character, backslash [`'\\''].  For
example, doing `RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SYSTEM\\DISK",...)' is
much like opening the `"SYSTEM"' subkey of `HKEY_LOCAL_MACHINE', then
opening its `"DISK"' subkey, then closing the `"SYSTEM"' subkey.

   All of the *Win32::TieRegistry* features allow you to use your own
delimiter in place of the system's delimiter, [`'\\''].  In most of our
examples we will use a forward slash [`'/''] as our delimiter as it is
easier to read and less error prone to use when writing Perl code since
you have to type two backslashes for each backslash you want in a string.
Note that this is true even when using single quotes -
`'\\HostName\LMachine\'' is an invalid string and must be written as
`'\\\\HostName\\LMachine\\''.

   You can also connect to the registry of other computers on your
network.  This will be discussed more later.

   Although the Registry does not have a single root key, the
*Win32::TieRegistry* module creates a virtual root key for you which has
all of the *HKEY_** keys as subkeys.

Tied Hashes Documentation
-------------------------

   Before you can use a tied hash, you must create one.  One way to do
that is via:

     use Win32::TieRegistry ( TiedHash => '%RegHash' );

   which exports a `%RegHash' variable into your package and ties it to
the virtual root key of the Registry.  An alternate method is:

     my %RegHash;
     use Win32::TieRegistry ( TiedHash => \%RegHash );

   There are also several ways you can tie a hash variable to any other
key of the Registry, which are discussed later.

   Note that you will most likely use `$Registry' instead of using a tied
hash.  `$Registry' is a reference to a hash that has been tied to the
virtual root of your computer's Registry [as if, `$Registry= \%RegHash'].
So you would use `$Registry->{Key}' rather than `$RegHash{Key}' and use
`keys %{$Registry}' rather than `keys %RegHash', for example.

   For each hash which has been tied to a Registry key, the Perl keys
function will return a list containing the name of each of the key's
subkeys with a delimiter character appended to it and containing the name
of each of the key's values with a delimiter prepended to it.  For example:

     keys( %{ $Registry->{"HKEY_CLASSES_ROOT\\batfile\\"} } )

   might yield the following list value:

     ( "DefaultIcon\\",  # The subkey named "DefaultIcon"
       "shell\\",        # The subkey named "shell"
       "shellex\\",      # The subkey named "shellex"
       "\\",             # The default value [named ""]
       "\\EditFlags" )   # The value named "EditFlags"

   For the virtual root key, short-hand subkey names are used as shown
below.  You can use the short-hand name, the regular *HKEY_** name, or any
numeric value to access these keys, but the short-hand names are all that
will be returned by the keys function.

"Classes" for HKEY_CLASSES_ROOT
     Contains mappings between file name extensions and the uses for such
     files along with configuration information for COM [MicroSoft's
     Common Object Model] objects.  Usually a link to the
     `"SOFTWARE\\Classes"' subkey of the `HKEY_LOCAL_MACHINE' key.

"CUser" for HKEY_CURRENT_USER
     Contains information specific to the currently logged-in user.
     Mostly software configuration information.  Usually a link to a
     subkey of the `HKEY_USERS' key.

"LMachine" for HKEY_LOCAL_MACHINE
     Contains all manner of information about the computer.

"Users" for HKEY_USERS
     Contains one subkey, `".DEFAULT"', which gets copied to a new subkey
     whenever a new user is added.  Also contains a subkey for each user
     of the system, though only those for active users [usually only one]
     are loaded at any given time.

"PerfData" for HKEY_PERFORMANCE_DATA
     Used to access data about system performance.  Access via this key is
     "special" and all but the most carefully constructed calls will fail,
     usually with `ERROR_INSUFFICIENT_BUFFER'.  For example, you can't
     enumerate key names without also enumerating values which require
     huge buffers but the exact buffer size required cannot be determined
     beforehand because `RegQueryInfoKey()' E<always> fails with
     `ERROR_INSUFFICIENT_BUFFER' for `HKEY_PERFORMANCE_DATA' no matter how
     it is called.  So it is currently not very useful to tie a hash to
     this key.  You can use it to create an object to use for making
     carefully constructed calls to the underlying Reg*() routines.

"CConfig" for HKEY_CURRENT_CONFIG
     Contains minimal information about the computer's current
     configuration that is required very early in the boot process.  For
     example, setting for the display adapter such as screen resolution
     and refresh rate are found in here.

"DynData" for HKEY_DYN_DATA
     Dynamic data.  We have found no documentation for this key.

   A tied hash is much like a regular hash variable in Perl - you give it
a key string inside braces, [`{' and `}'], and it gives you back a value
[or lets you set a value].  For *Win32::TieRegistry* hashes, there are two
types of values that will be returned.

SubKeys
     If you give it a string which represents a subkey, then it will give
     you back a reference to a hash which has been tied to that subkey.
     It can't return the hash itself, so it returns a reference to it.  It
     also blesses that reference so that it is also an object so you can
     use it to call method functions.

Values
     If you give it a string which is a value name, then it will give you
     back a string which is the data for that value.  Alternately, you can
     request that it give you both the data value string and the data
     value type [we discuss how to request this later].  In this case, it
     would return a reference to an array where the value data string is
     element [0] and the value data type is element [1].

   The key string which you use in the tied hash must be interpreted to
determine whether it is a value name or a key name or a path that combines
several of these or even other things.  There are two simple rules that
make this interpretation easy and unambiguous:

     Put a delimiter after each key name.
     Put a delimiter in front of each value name.

   Exactly how the key string will be intepreted is governed by the
following cases, in the order listed.  These cases are designed to "do
what you mean".  Most of the time you won't have to think about them,
especially if you follow the two simple rules above.  After the list of
cases we give several examples which should be clear enough so feel free
to skip to them unless you are worried about the details.

Remote machines
     If the hash is tied to the virtual root of the registry [or the
     virtual root of a remote machine's registry], then we treat hash key
     strings which start with the delimiter character specially.

     If the hash key string starts with two delimiters in a row, then
     those should be immediately followed by the name of a remote machine
     whose registry we wish to connect to.  That can be followed by a
     delimiter and more subkey names, etc.  If the machine name is not
     following by anything, then a virtual root for the remote machine's
     registry is created, a hash is tied to it, and a reference to that
     hash it is returned.

Hash key string starts with the delimiter
     If the hash is tied to a virtual root key, then the leading delimiter
     is ignored.  It should be followed by a valid Registry root key name
     [either a short-hand name like "LMachine", an *HKEY_** value, or a
     numeric value].   This alternate notation is allowed in order to be
     more consistant with the `Open()' method function.

     For all other Registry keys, the leading delimiter indicates that the
     rest of the string is a value name.  The leading delimiter is
     stripped and the rest of the string [which can be empty and can
     contain more delimiters] is used as a value name with no further
     parsing.

Exact match with direct subkey name followed by delimiter
     If you have already called the Perl keys function on the tied hash
     [or have already called MemberNames on the object] and the hash key
     string exactly matches one of the strings returned, then no further
     parsing is done.  In other words, if the key string exactly matches
     the name of a direct subkey with a delimiter appended, then a
     reference to a hash tied to that subkey is returned [but only if keys
     or MemberNames has already been called for that tied hash].

     This is only important if you have selected a delimiter other than
     the system default delimiter and one of the subkey names contains the
     delimiter you have chosen.  This rule allows you to deal with subkeys
     which contain your chosen delimiter in their name as long as you only
     traverse subkeys one level at a time and always enumerate the list of
     members before doing so.

     The main advantage of this is that Perl code which recursively
     traverses a hash will work on hashes tied to Registry keys even if a
     non-default delimiter has been selected.

Hash key string contains two delimiters in a row
     If the hash key string contains two [or more] delimiters in a row,
     then the string is split between the first pair of delimiters.  The
     first part is interpreted as a subkey name or a path of subkey names
     separated by delimiters and with a trailing delimiter.  The second
     part is interpreted as a value name with one leading delimiter [any
     extra delimiters are considered part of the value name].

Hash key string ends with a delimiter
     If the key string ends with a delimiter, then it is treated as a
     subkey name or path of subkey names separated by delimiters.

Hash key string contains a delimiter
     If the key string contains a delimiter, then it is split after the
     last delimiter.  The first part is treated as a subkey name or path
     of subkey names separated by delimiters.  The second part is
     ambiguous and is treated as outlined in the next item.

Hash key string contains no delimiters
     If the hash key string contains no delimiters, then it is ambiguous.

     If you are reading from the hash [fetching], then we first use the
     key string as a value name.  If there is a value with a matching name
     in the Registry key which the hash is tied to, then the value data
     string [and possibly the value data type] is returned.  Otherwise, we
     retry by using the hash key string as a subkey name.  If there is a
     subkey with a matching name, then we return a reference to a hash
     tied to that subkey.  Otherwise we return undef.

     If you are writing to the hash [storing], then we use the key string
     as a subkey name only if the value you are storing is a reference to
     a hash value.  Otherwise we use the key string as a value name.

Examples
........

   Here are some examples showing different ways of accessing Registry
information using references to tied hashes:

Canonical value fetch
          $tip18= $Registry->{"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\"
                     . 'Windows\\CurrentVersion\\Explorer\\Tips\\\\18'};

     Should return the text of important tip number 18.  Note that two
     backslashes, `"\\"', are required to get a single backslash into a
     Perl double-quoted or single-qouted string.  Note that `"\\"' is
     appended to each key name [`"HKEY_LOCAL_MACHINE"' through `"Tips"']
     and `"\\"' is prepended to the value name, `"18"'.

Changing your delimiter
          $Registry->Delimiter("/");
          $tip18= $Registry->{"HKEY_LOCAL_MACHINE/Software/Microsoft/"
                     . 'Windows/CurrentVersion/Explorer/Tips//18'};

     This usually makes things easier to read when working in Perl.  All
     remaining examples will assume the delimiter has been changed as
     above.

Using intermediate keys
          $ms= $Registry->{"LMachine/Software/Microsoft/"};
          $tips= $ms->{"Windows/CurrentVersion/Explorer/Tips/"};
          $tip18= $winlogon->{"/18"};

     Same as above but opens more keys into the Registry which lets you
     efficiently re-access those intermediate keys.  This is slightly less
     efficient if you never reuse those intermediate keys.

Chaining in a single statement
          $tip18= $Registry->{"LMachine/Software/Microsoft/"}->
                    {"Windows/CurrentVersion/Explorer/Tips/"}->{"/18"};

     Like above, this creates intermediate key objects then uses them to
     access other data.  Once this statement finishes, the intermediate
     key objects are destroyed.  Several handles into the Registry are
     opened and closed by this statement so it is less efficient but there
     are times when this will be useful.

Even less efficient example of chaining
          $tip18= $Registry->{"LMachine/Software/Microsoft"}->
                    {"Windows/CurrentVersion/Explorer/Tips"}->{"/18"};

     Because we left off the trailing delimiters, *Win32::TieRegistry*
     doesn't know whether final names, `"Microsoft"' and `"Tips"', are
     subkey names or value names.  So this statement ends up executing the
     same code as the next one.

What the above really does
          $tip18= $Registry->{"LMachine/Software/"}->{"Microsoft"}->
                    {"Windows/CurrentVersion/Explorer/"}->{"Tips"}->{"/18"};

     With more chains to go through, more temporary objects are created
     and later destroyed than in our first chaining example.  Also, when
     `"Microsoft"' is looked up, *Win32::TieRegistry* first tries to open
     it as a value and fails then tries it as a subkey.  The same is true
     for when it looks up `"Tips"'.

Getting all of the tips
          $tips= $Registry->{"LMachine/Software/Microsoft/"}->
                    {"Windows/CurrentVersion/Explorer/Tips/"}
            or  die "Can't find the Windows tips: $^E\n";
          foreach(  keys %$tips  ) {
              print "$_: ", $tips->{$_}, "\n";
          }

     First notice that we actually check for failure for the first time.
     We are assuming that the `"Tips"' key contains no subkeys.  Otherwise
     the print statement would show something like
     `"Win32::TieRegistry=HASH(0xc03ebc)"' for each subkey.

     The output from the above code will start something like:

          /0: If you don't know how to do something,[...]

Deleting items
..............

   You can use the Perl delete function to delete a value from a Registry
key or to delete a subkey as long that subkey contains no subkeys of its
own.  See `More Examples' in this node, below, for more information.

Storing items
.............

   You can use the Perl assignment operator [=] to create new keys, create
new values, or replace values.  The values you store should be in the same
format as the values you would fetch from a tied hash.  For example, you
can use a single assignment statement to copy an entire Registry tree.
The following statement:

     $Registry->{"LMachine/Software/Classes/Tie_Registry/"}=
       $Registry->{"LMachine/Software/Classes/batfile/"};

   creates a `"Tie_Registry"' subkey under the `"Software\\Classes"'
subkey of the `HKEY_LOCAL_MACHINE' key.  Then it populates it with copies
of all of the subkeys and values in the `"batfile"' subkey and all of its
subkeys.  Note that you need to have called `$Registry->ArrayValues(1)'
for the proper value data type information to be copied.  Note also that
this release of *Win32::TieRegistry* does not copy key attributes such as
class name and security information [this is planned for a future release].

   The following statement creates a whole subtree in the Registry:

     $Registry->{"LMachine/Software/FooCorp/"}= {
         "FooWriter/" => {
             "/Version" => "4.032",
             "Startup/" => {
                 "/Title" => "Foo Writer Deluxe ][",
                 "/WindowSize" => [ pack("LL",$wid,$ht), "REG_BINARY" ],
                 "/TaskBarIcon" => [ "0x0001", "REG_DWORD" ],
             },
             "Compatibility/" => {
                 "/AutoConvert" => "Always",
                 "/Default Palette" => "Windows Colors",
             },
         },
         "/License", => "0123-9C8EF1-09-FC",
     };

   Note that all but the last Registry key used on the left-hand side of
the assignment [that is, "LMachine/Software/" but not "FooCorp/"] must
already exist for this statement to succeed.

   By using the leading a trailing delimiters on each subkey name and
value name, *Win32::TieRegistry* will tell you if you try to assign subkey
information to a value or visa-versa.

More examples
.............

Adding a new tip
          $tips= $Registry->{"LMachine/Software/Microsoft/"}->
                    {"Windows/CurrentVersion/Explorer/Tips/"}
            or  die "Can't find the Windows tips: $^E\n";
          $tips{'/186'}= "Be very careful when making changes to the Registry!";

Deleting our new tip
          $tips= $Registry->{"LMachine/Software/Microsoft/"}->
                    {"Windows/CurrentVersion/Explorer/Tips/"}
            or  die "Can't find the Windows tips: $^E\n";
          $tip186= delete $tips{'/186'};

     Note that Perl's delete function returns the value that was deleted.

Adding a new tip differently
          $Registry->{"LMachine/Software/Microsoft/" .
                      "Windows/CurrentVersion/Explorer/Tips//186"}=
            "Be very careful when making changes to the Registry!";

Deleting differently
          $tip186= delete $Registry->{"LMachine/Software/Microsoft/Windows/" .
                                      "CurrentVersion/Explorer/Tips//186"};

     Note that this only deletes the tail of what we looked up, the
     `"186"' value, not any of the keys listed.

Deleting a key
     WARNING:  The following code will delete all information about the
     current user's tip preferences.  Actually executing this command
     would probably cause the user to see the Welcome screen the next time
     they log in and may cause more serious problems.  This statement is
     shown as an example only and should not be used when experimenting.

          $tips= delete $Registry->{"CUser/Software/Microsoft/Windows/" .
                                    "CurrentVersion/Explorer/Tips/"};

     This deletes the `"Tips"' key and the values it contains.  The delete
     function will return a reference to a hash [not a tied hash]
     containing the value names and value data that were deleted.

     The information to be returned is copied from the Registry into a
     regular Perl hash before the key is deleted.  If the key has many
     subkeys, this copying could take a significant amount of memory
     and/or processor time.  So you can disable this process by calling
     the FastDelete member function:

          $prevSetting= $regKey->FastDelete(1);

     which will cause all subsequent delete operations via `$regKey' to
     simply return a true value if they succeed.  This optimization is
     automatically done if you use delete in a void context.

Technical notes on deleting
     If you use delete to delete a Registry key or value and use the
     return value, then *Win32::TieRegistry* usually looks up the current
     contents of that key or value so they can be returned if the deletion
     is successful.  If the deletion succeeds but the attempt to lookup
     the old contents failed, then the return value of delete will be $^E
     from the failed part of the operation.

Undeleting a key
          $Registry->{"LMachine/Software/Microsoft/Windows/" .
                      "CurrentVersion/Explorer/Tips/"}= $tips;

     This adds back what we just deleted.  Note that this version of
     *Win32::TieRegistry* will use defaults for the key attributes [such
     as class name and security] and will not restore the previous
     attributes.

Not deleting a key
     WARNING:  Actually executing the following code could cause serious
     problems.  This statement is shown as an example only and should not
     be used when experimenting.

          $res= delete $Registry->{"CUser/Software/Microsoft/Windows/"}
          defined($res)  ||  die "Can't delete URL key: $^E\n";

     Since the "Windows" key should contain subkeys, that delete statement
     should make no changes to the Registry, return undef, and set $^E to
     "Access is denied".

Not deleting again
          $tips= $Registry->{"CUser/Software/Microsoft/Windows/" .
                             "CurrentVersion/Explorer/Tips/"};
          delete $tips;

     The Perl delete function requires that its argument be an expression
     that ends in a hash element lookup [or hash slice], which is not the
     case here.  The delete function doesn't know which hash $tips came
     from and so can't delete it.

Objects Documentation
---------------------

   The following member functions are defined for use on
*Win32::TieRegistry* objects:

new
     The new method creates a new *Win32::TieRegistry* object.  new is
     mostly a synonym for `Open()' so see `Open()' below for information
     on what arguments to pass in.  Examples:

          $machKey= new Win32::TieRegistry "LMachine"
            or  die "Can't access HKEY_LOCAL_MACHINE key: $^E\n";
          $userKey= Win32::TieRegistry->new("CUser")
            or  die "Can't access HKEY_CURRENT_USER key: $^E\n";

     Note that calling new via a reference to a tied hash returns a simple
     object, not a reference to a tied hash.

Open
$subKey= $key->Open( $sSubKey, $rhOptions )
     The Open method opens a Registry key and returns a new
     *Win32::TieRegistry* object associated with that Registry key.  If
     Open is called via a reference to a tied hash, then Open returns
     another reference to a tied hash.  Otherwise Open returns a simple
     object and you should then use TiedRef to get a reference to a tied
     hash.

     `$sSubKey' is a string specifying a subkey to be opened.  Alternately
     `$sSubKey' can be a reference to an array value containing the list
     of increasingly deep subkeys specifying the path to the subkey to be
     opened.

     `$rhOptions' is an optional reference to a hash containing extra
     options.  The Open method supports two options, `"Delimiter"' and
     `"Access"', and `$rhOptions' should have only have zero or more of
     these strings as keys.  See the "Examples" section below for more
     information.

     The `"Delimiter"' option specifies what string [usually a single
     character] will be used as the delimiter to be appended to subkey
     names and prepended to value names.  If this option is not specified,
     the new key [`$subKey'] inherits the delimiter of the old key [$key].

     The `"Access"' option specifies what level of access to the Registry
     key you wish to have once it has been opened.  If this option is not
     specified, the new key [`$subKey'] is opened with the same access
     level used when the old key [$key] was opened.  The virtual root of
     the Registry pretends it was opened with access
     `KEY_READ()|KEY_WRITE()' so this is the default access when opening
     keys directory via `$Registry'.  If you don't plan on modifying a
     key, you should open it with `KEY_READ' access as you may not have
     `KEY_WRITE' access to it or some of its subkeys.

     If the `"Access"' option value is a string that starts with `"KEY_"',
     then it should match E<one> of the predefined access levels [probably
     `"KEY_READ"', `"KEY_WRITE"', or `"KEY_ALL_ACCESS"'] exported by the
     *Win32API::Registry* module.  Otherwise, a numeric value is expected.
     For maximum flexibility, include `use Win32::TieRegistry
     qw(:KEY_);', for example, near the top of your script so you can
     specify more complicated access levels such as
     `KEY_READ()|KEY_WRITE()'.

     If `$sSubKey' does not begin with the delimiter [or `$sSubKey' is an
     array reference], then the path to the subkey to be opened will be
     relative to the path of the original key [$key].  If `$sSubKey'
     begins with a single delimiter, then the path to the subkey to be
     opened will be relative to the virtual root of the Registry on
     whichever machine the original key resides.  If `$sSubKey' begins
     with two consectutive delimiters, then those must be followed by a
     machine name which causes the `Connect()' method function to be
     called.

     Examples:

          $machKey= $Registry->Open( "LMachine", {Access=>KEY_READ(),Delimiter=>"/"} )
            or  die "Can't open HKEY_LOCAL_MACHINE key: $^E\n";
          $swKey= $machKey->Open( "Software" );
          $logonKey= $swKey->Open( "Microsoft/Windows NT/CurrentVersion/Winlogon/" );
          $NTversKey= $swKey->Open( ["Microsoft","Windows NT","CurrentVersion"] );
          $versKey= $swKey->Open( qw(Microsoft Windows CurrentVersion) );

          $remoteKey= $Registry->Open( "//HostA/LMachine/System/", {Delimiter=>"/"} )
            or  die "Can't connect to HostA or can't open subkey: $^E\n";

Clone
$copy= $key->Clone
     Creates a new object that is associated with the same Registry key as
     the invoking object.

Connect
$remoteKey= $Registry->Connect( $sMachineName, $sKeyPath, $rhOptions )
     The Connect method connects to the Registry of a remote machine, and
     opens a key within it, then returns a new *Win32::TieRegistry* object
     associated with that remote Registry key.  If Connect was called
     using a reference to a tied hash, then the return value will also be
     a reference to a tied hash [or undef].  Otherwise, if you wish to use
     the returned object as a tied hash [not just as an object], then use
     the TiedRef method function after Connect.

     `$sMachineName' is the name of the remote machine.  You don't have to
     preceed the machine name with two delimiter characters.

     `$sKeyPath' is a string specifying the remote key to be opened.
     Alternately `$sKeyPath' can be a reference to an array value
     containing the list of increasingly deep keys specifying the path to
     the key to be opened.

     `$rhOptions' is an optional reference to a hash containing extra
     options.  The Connect method supports two options, `"Delimiter"' and
     `"Access"'.  See the Open method documentation for more information
     on these options.

     `$sKeyPath' is already relative to the virtual root of the Registry
     of the remote machine.  A single leading delimiter on `sKeyPath' will
     be ignored and is not required.

     `$sKeyPath' can be empty in which case Connect will return an object
     representing the virtual root key of the remote Registry.  Each
     subsequent use of Open on this virtual root key will call the system
     RegConnectRegistry function.

     The Connect method can be called via any *Win32::TieRegistry* object,
     not just `$Registry'.  Attributes such as the desired level of access
     and the delimiter will be inherited from the object used but the
     `$sKeyPath' will always be relative to the virtual root of the remote
     machine's registry.

     Examples:

          $remMachKey= $Registry->Connect( "HostA", "LMachine", {Delimiter->"/"} )
            or  die "Can't connect to HostA's HKEY_LOCAL_MACHINE key: $^E\n";

          $remVersKey= $remMachKey->Connect( "www.microsoft.com",
                         "LMachine/Software/Microsoft/Inetsrv/CurrentVersion/",
                         { Access=>KEY_READ, Delimiter=>"/" } )
            or  die "Can't check what version of IIS Microsoft is running: $^E\n";

          $remVersKey= $remMachKey->Connect( "www",
                         qw(LMachine Software Microsoft Inetsrv CurrentVersion) )
            or  die "Can't check what version of IIS we are running: $^E\n";

ObjectRef
$object_ref= $obj_or_hash_ref->ObjectRef
     For a simple object, just returns itself [`$obj == $obj-'ObjectRef>].

     For a reference to a tied hash [if it is also an object], ObjectRef
     returns the simple object that the hash is tied to.

     This is primarilly useful when debugging since typing `x $Registry'
     will try to display your *entire* registry contents to your screen.
     But the debugger command `x $Registry-'ObjectRef> will just dump the
     implementation details of the underlying object to your screen.

Flush( $bFlush )
     Flushes all cached information about the Registry key so that future
     uses will get fresh data from the Registry.

     If the optional `$bFlush' is specified and a true value, then
     `RegFlushKey()' will be called, which is almost never necessary.

GetValue
$ValueData= $key->GetValue( $sValueName )
($ValueData,$ValueType)= $key->GetValue( $sValueName )
     Gets a Registry value's data and data type.

     `$ValueData' is usually just a Perl string that contains the value
     data [packed into it].  For certain types of data, however,
     `$ValueData' may be processed as described below.

     `$ValueType' is the `REG_*' constant describing the type of value
     data stored in `$ValueData'.  If the `DualTypes()' option is on, then
     `$ValueType' will be a dual value.  That is, when used in a numeric
     context, `$ValueType' will give the numeric value of a `REG_*'
     constant.  However, when used in a non-numeric context, `$ValueType'
     will return the name of the `REG_*' constant, for example `"REG_SZ"'
     [note the quotes].  So both of the following can be true at the same
     time:

          $ValueType == REG_SZ()
          $ValueType eq "REG_SZ"

    REG_SZ and REG_EXPAND_SZ
          If the `FixSzNulls()' option is on, then the trailing `'\0''
          will be stripped [unless there isn't one] before values of type
          REG_SZ and REG_EXPAND_SZ are returned.  Note that `SetValue()'
          will add a trailing `'\0'' under similar circumstances.

    REG_MULTI_SZ
          If the `SplitMultis()' option is on, then values of this type are
          returned as a reference to an array containing the strings.  For
          example, a value that, with `SplitMultis()' off, would be
          returned as:

               "Value1\000Value2\000\000"

          would be returned, with `SplitMultis()' on, as:

               [ "Value1", "Value2" ]

    REG_DWORD
          If the `DualBinVals()' option is on, then the value is returned
          as a scalar containing both a string and a number [much like the
          $! variable - see the `SetDualVar' in this node module for more
          information] where the number part is the "unpacked" value.  Use
          the returned value in a numeric context to access this part of
          the value.  For example:

               $num= 0 + $Registry->{"CUser/Console//ColorTable01"};

          If the `DWordsToHex()' option is off, the string part of the
          returned value is a packed, 4-byte string [use
          `unpack("L",$value)' to get the numeric value.

          If `DWordsToHex()' is on, the string part of the returned value
          is a 10-character hex strings [with leading "0x"].  You can use
          `hex($value)' to get the numeric value.

          Note that `SetValue()' will properly understand each of these
          returned value formats no matter how `DualBinVals()' is set.

ValueNames
@names= $key->ValueNames
     Returns the list of value names stored directly in a Registry key.
     Note that the names returned do not have a delimiter prepended to
     them like with `MemberNames()' and tied hashes.

     Once you request this information, it is cached in the object and
     future requests will always return the same list unless `Flush()' has
     been called.

SubKeyNames
@key_names= $key->SubKeyNames
     Returns the list of subkey names stored directly in a Registry key.
     Note that the names returned do not have a delimiter appended to them
     like with `MemberNames()' and tied hashes.

     Once you request this information, it is cached in the object and
     future requests will always return the same list unless `Flush()' has
     been called.

SubKeyClasses
@classes= $key->SubKeyClasses
     Returns the list of classes for subkeys stored directly in a Registry
     key.  The classes are returned in the same order as the subkey names
     returned by `SubKeyNames()'.

SubKeyTimes
@times= $key->SubKeyTimes
     Returns the list of last-modified times for subkeys stored directly
     in a Registry key.  The times are returned in the same order as the
     subkey names returned by `SubKeyNames()'.  Each time is a `FILETIME'
     structure packed into a Perl string.

     Once you request this information, it is cached in the object and
     future requests will always return the same list unless `Flush()' has
     been called.

MemberNames
@members= $key->MemberNames
     Returns the list of subkey names and value names stored directly in a
     Registry key.  Subkey names have a delimiter appended to the end and
     value names have a delimiter prepended to the front.

     Note that a value name could end in a delimiter [or could be "" so
     that the member name returned is just a delimiter] so the presence or
     absence of the leading delimiter is what should be used to determine
     whether a particular name is for a subkey or a value, not the
     presence or absence of a trailing delimiter.

     Once you request this information, it is cached in the object and
     future requests will always return the same list unless `Flush()' has
     been called.

Information
%info= $key->Information
@items= $key->Information( @itemNames );
     Returns the following information about a Registry key:

    LastWrite
          A `FILETIME' structure indicating when the key was last modified
          and packed into a Perl string.

    CntSubKeys
          The number of subkeys stored directly in this key.

    CntValues
          The number of values stored directly in this key.

    SecurityLen
          The length [in bytes] of the largest[?] `SECURITY_DESCRIPTOR'
          associated with the Registry key.

    MaxValDataLen
          The length [in bytes] of the longest value data associated with
          a value stored in this key.

    MaxSubKeyLen
          The length [in chars] of the longest subkey name associated with
          a subkey stored in this key.

    MaxSubClassLen
          The length [in chars] of the longest class name associated with
          a subkey stored directly in this key.

    MaxValNameLen
          The length [in chars] of the longest value name associated with
          a value stored in this key.

     With no arguments, returns a hash [not a reference to a hash] where
     the keys are the names for the items given above and the values are
     the information describe above.  For example:

          %info= ( "CntValues" => 25,         # Key contains 25 values.
                   "MaxValNameLen" => 20,     # One of which has a 20-char name.
                   "MaxValDataLen" => 42,     # One of which has a 42-byte value.
                   "CntSubKeys" => 1,         # Key has 1 immediate subkey.
                   "MaxSubKeyLen" => 13,      # One of which has a 12-char name.
                   "MaxSubClassLen" => 0,     # All of which have class names of "".
                   "SecurityLen" => 232,      # One SECURITY_DESCRIPTOR is 232 bytes.
                   "LastWrite" => "\x90mZ\cX{\xA3\xBD\cA\c@\cA"
                                 # Key was last modifed 1998/06/01 16:29:32 GMT
                 );

     With arguments, each one must be the name of a item given above.  The
     return value is the information associated with the listed names.  In
     other words:

          return $key->Information( @names );

     returns the same list as:

          %info= $key->Information;
          return @info{@names};

Delimiter
$oldDelim= $key->Delimiter
$oldDelim= $key->Delimiter( $newDelim )
     Gets and possibly changes the delimiter used for this object.  The
     delimiter is appended to subkey names and prepended to value names in
     many return values.  It is also used when parsing keys passed to tied
     hashes.

     The delimiter defaults to backslash (`'\\'') but is inherited from
     the object used to create a new object and can be specified by an
     option when a new object is created.

Handle
$handle= $key->Handle
     Returns the raw `HKEY' handle for the associated Registry key as an
     integer value.  This value can then be used to Reg*() calls from
     *Win32API::Registry*.  However, it is usually easier to just call the
     *Win32API::Registry* calls directly via:

          $key->RegNotifyChangeKeyValue( ... );

     For the virtual root of the local or a remote Registry, `Handle()'
     return `"NONE"'.

Path
$path= $key->Path
     Returns a string describing the path of key names to this Registry
     key.  The string is built so that if it were passed to
     `$Registry-'Open()>, it would reopen the same Registry key [except in
     the rare case where one of the key names contains `$key-'Delimiter>].

Machine
$computerName= $key->Machine
     Returns the name of the computer [or "machine"] on which this Registry
     key resides.  Returns "" for local Registry keys.

Access
     Returns the numeric value of the bit mask used to specify the types
     of access requested when this Registry key was opened.  Can be
     compared to `KEY_*' values.

OS_Delimiter
     Returns the delimiter used by the operating system's RegOpenKeyEx()
     call.  For Win32, this is always backslash (`"\\"').

Roots
     Returns the mapping from root key names like "LMachine" to their
     associated `HKEY_*' constants.  Primarily for internal use and
     subject to change.

Tie
$key->Tie( \%hash );
     Ties the referenced hash to that Registry key.  Pretty much the same
     as

          tie %hash, ref($key), $key;

     Since `ref($key)' is the class [package] to tie the hash to and
     `TIEHASH()' just returns its argument, $key, [without calling new()]
     when it sees that it is already a blessed object.

TiedRef
$TiedHashRef= $hash_or_obj_ref->TiedRef
     For a simple object, returns a reference to a hash tied to the
     object.  Used to promote a simple object into a combined object and
     hash ref.

     If already a reference to a tied hash [that is also an object], it
     just returns itself [`$ref == $ref-'TiedRef>].

     Mostly used internally.

ArrayValues
$oldBool= $key->ArrayValues
$oldBool= $key->ArrayValues( $newBool )
     Gets the current setting of the ArrayValues option and possibly turns
     it on or off.

     When off, Registry values fetched via a tied hash are returned as
     just a value scalar [the same as `GetValue()' in a scalar context].
     When on, they are returned as a reference to an array containing the
     value data as the [0] element and the data type as the [1] element.

TieValues
$oldBool= TieValues
$oldBool= TieValues( $newBool )
     Gets the current setting of the TieValues option and possibly turns
     it on or off.

     Turning this option on is not yet supported in this release of
     *Win32::TieRegistry*.  In a future release, turning this option on
     will cause Registry values returned from a tied hash to be a tied
     array that you can use to modify the value in the Registry.

FastDelete
$oldBool= $key->FastDelete
$oldBool= $key->FastDelete( $newBool )
     Gets the current setting of the FastDelete option and possibly turns
     it on or off.

     When on, successfully deleting a Registry key [via a tied hash]
     simply returns 1.

     When off, successfully deleting a Registry key [via a tied hash and
     not in a void context] returns a reference to a hash that contains
     the values present in the key when it was deleted.  This hash is just
     like that returned when referencing the key before it was deleted
     except that it is an ordinary hash, not one tied to the
     *Win32::TieRegistry* package.

     Note that deleting either a Registry key or value via a tied hash *in
     a void context* prevents any overhead in trying to build an
     appropriate return value.

     Note that deleting a Registry value via a tied hash [not in a void
     context] returns the value data even if <FastDelete> is on.

SplitMultis
$oldBool= $key->SplitMultis
$oldBool= $key->SplitMultis( $newBool )
     Gets the current setting of the SplitMultis option and possibly turns
     it on or off.

     If on, Registry values of type REG_MULTI_SZ are returned as a
     reference to an array of strings.  See `GetValue()' for more
     information.

DWordsToHex
$oldBool= $key->DWordsToHex
$oldBool= $key->DWordsToHex( $newBool )
     Gets the current setting of the DWordsToHex option and possibly turns
     it on or off.

     If on, Registry values of type REG_DWORD are returned as a hex string
     with leading `"0x"' and longer than 4 characters.  See `GetValue()'
     for more information.

FixSzNulls
$oldBool= $key->FixSzNulls
$oldBool= $key->FixSzNulls( $newBool )
     Gets the current setting of the FixSzNulls option and possibly turns
     it on or off.

     If on, Registry values of type REG_SZ and REG_EXPAND_SZ have trailing
     `'\0''s added before they are set and stripped before they are
     returned.  See `GetValue()' and `SetValue()' for more information.

DualTypes
$oldBool= $key->DualTypes
$oldBool= $key->DualTypes( $newBool )
     Gets the current setting of the DualTypes option and possibly turns
     it on or off.

     If on, data types are returned as a combined numeric/string value
     holding both the numeric value of a `REG_*' constant and the string
     value of the constant's name.  See `GetValue()' for more information.

DualBinVals
$oldBool= $key->DualBinVals
$oldBool= $key->DualBinVals( $newBool )
     Gets the current setting of the DualBinVals option and possibly turns
     it on or off.

     If on, Registry value data of type REG_BINARY and no more than 4
     bytes long and Registry values of type REG_DWORD are returned as a
     combined numeric/string value where the numeric value is the
     "unpacked" binary value as returned by:

          hex reverse unpack( "h*", $valData )

     on a "little-endian" computer.  [Would be `hex unpack("H*",$valData)'
     on a "big-endian" computer if this module is ever ported to one.]

     See `GetValue()' for more information.

GetOptions
@oldOptValues= $key->GetOptions( @optionNames )
$refHashOfOldOpts= $key->GetOptions()
$key->GetOptions( \%hashForOldOpts )
     Returns the current setting of any of the following options:

          Delimiter     FixSzNulls    DWordsToHex
          ArrayValues   SplitMultis   DualBinVals
          TieValues     FastDelete    DualTypes

     Pass in one or more of the above names (as strings) to get back an
     array of the corresponding current settings in the same order:

          my( $fastDel, $delim )= $key->GetOptions("FastDelete","Delimiter");

     Pass in no arguments to get back a reference to a hash where the
     above option names are the keys and the values are the corresponding
     current settings for each option:

          my $href= $key->GetOptions();
          my $delim= $href->{Delimiter};

     Pass in a single reference to a hash to have the above key/value
     pairs added to the referenced hash.  For this case, the return value
     is the original object so further methods can be chained after the
     call to GetOptions:

          my %oldOpts;
          $key->GetOptions( \%oldOpts )->SetOptions( Delimiter => "/" );

SetOptions
@oldOpts= $key->SetOptions( optNames=>$optValue,... )
     Changes the current setting of any of the following options,
     returning the previous setting(s):

          Delimiter     FixSzNulls    DWordsToHex   AllowLoad
          ArrayValues   SplitMultis   DualBinVals   AllowSave
          TieValues     FastDelete    DualTypes

     For AllowLoad and AllowSave, instead of the previous setting,
     SetOptions returns whether or not the change was successful.

     In a scalar context, returns only the last item.  The last option can
     also be specified as `"ref"' or `"r"' [which doesn't need to be
     followed by a value] to allow chaining:

          $key->SetOptions(AllowSave=>1,"ref")->RegSaveKey(...)

SetValue
$okay= $key->SetValue( $ValueName, $ValueData );
$okay= $key->SetValue( $ValueName, $ValueData, $ValueType );
     Adds or replaces a Registry value.  Returns a true value if
     successfully, false otherwise.

     `$ValueName' is the name of the value to add or replace and should
     not have a delimiter prepended to it.  Case is ignored.

     `$ValueType' is assumed to be REG_SZ if it is omitted.  Otherwise, it
     should be one the `REG_*' constants.

     `$ValueData' is the data to be stored in the value, probably packed
     into a Perl string.  Other supported formats for value data are
     listed below for each posible `$ValueType'.

    REG_SZ or REG_EXPAND_SZ
          The only special processing for these values is the addition of
          the required trailing `'\0'' if it is missing.  This can be
          turned off by disabling the FixSzNulls option.

    REG_MULTI_SZ
          These values can also be specified as a reference to a list of
          strings.  For example, the following two lines are equivalent:

               $key->SetValue( "Val1\000Value2\000LastVal\000\000", "REG_MULTI_SZ" );
               $key->SetValue( ["Val1","Value2","LastVal"], "REG_MULTI_SZ" );

          Note that if the required two trailing nulls (`"\000\000"') are
          missing, then this release of `SetValue()' will not add them.

    REG_DWORD
          These values can also be specified as a hex value with the
          leading `"0x"' included and totaling *more than* 4 bytes.  These
          will be packed into a 4-byte string via:

               $data= pack( "L", hex($data) );

    REG_BINARY
          This value type is listed just to emphasize that no alternate
          format is supported for it.  In particular, you should not pass
          in a numeric value for this type of data.  `SetValue()' cannot
          distinguish such from a packed string that just happens to match
          a numeric value and so will treat it as a packed string.

     An alternate calling format:

          $okay= $key->SetValue( $ValueName, [ $ValueData, $ValueType ] );

     [two arguments, the second of which is a reference to an array
     containing the value data and value type] is supported to ease using
     tied hashes with `SetValue()'.

CreateKey
$newKey= $key->CreateKey( $subKey );
$newKey= $key->CreateKey( $subKey, { Option=>OptVal,... } );
     Creates a Registry key or just updates attributes of one.  Calls
     `RegCreateKeyEx()' then, if it succeeded, creates an object
     associated with the [possibly new] subkey.

     `$subKey' is the name of a subkey [or a path to one] to be created or
     updated.  It can also be a reference to an array containing a list of
     subkey names.

     The second argument, if it exists, should be a reference to a hash
     specifying options either to be passed to `RegCreateKeyEx()' or to be
     used when creating the associated object.  The following items are
     the supported keys for this options hash:

    Delimiter
          Specifies the delimiter to be used to parse `$subKey' and to be
          used in the new object.  Defaults to `$key-'Delimiter>.

    Access
          Specifies the types of access requested when the subkey is
          opened.  Should be a numeric bit mask that combines one or more
          `KEY_*' constant values.

    Class
          The name to assign as the class of the new or updated subkey.
          Defaults to "" as we have never seen a use for this information.

    Disposition
          Lets you specify a reference to a scalar where, upon success,
          will be stored either `REG_CREATED_NEW_KEY()' or
          `REG_OPENED_EXISTING_KEY()' depending on whether a new key was
          created or an existing key was opened.

          If you, for example, did `use Win32::TieRegistry
          qw(REG_CREATED_NEW_KEY)' then you can use
          `REG_CREATED_NEW_KEY()' to compare against the numeric value
          stored in the referenced scalar.

          If the DualTypes option is enabled, then in addition to the
          numeric value described above, the referenced scalar will also
          have a string value equal to either `"REG_CREATED_NEW_KEY"' or
          `"REG_OPENED_EXISTING_KEY"', as appropriate.

    Security
          Lets you specify a `SECURITY_ATTRIBUTES' structure packed into a
          Perl string.  See `Win32API::Registry::RegCreateKeyEx()' for more
          information.

    Volatile
          If true, specifies that the new key should be volatile, that is,
          stored only in memory and not backed by a hive file [and not
          saved if the computer is rebooted].  This option is ignored under
          Windows 95.  Specifying `Volatile=E<GT'1>  is the same as
          specifying `Options=E<GT'REG_OPTION_VOLATILE>.

    Backup
          If true, specifies that the new key should be opened for
          backup/restore access.  The Access option is ignored.  If the
          calling process has enabled `"SeBackupPrivilege"', then the
          subkey is opened with `KEY_READ' access as the `"LocalSystem"'
          user which should have access to all subkeys.  If the calling
          process has enabled `"SeRestorePrivilege"', then the subkey is
          opened with `KEY_WRITE' access as the `"LocalSystem"' user which
          should have access to all subkeys.

          This option is ignored under Windows 95.  Specifying
          `Backup=E<GT'1> is the same as specifying
          `Options=E<GT'REG_OPTION_BACKUP_RESTORE>.

    Options
          Lets you specify options to the `RegOpenKeyEx()' call.  The value
          for this option should be a numeric value combining zero or more
          of the `REG_OPTION_*' bit masks.  You may with to used the
          Volatile and/or Backup options instead of this one.

StoreKey
$newKey= $key->StoreKey( $subKey, \%Contents );
     Primarily for internal use.

     Used to create or update a Registry key and any number of subkeys or
     values under it or its subkeys.

     `$subKey' is the name of a subkey to be created [or a path of subkey
     names separated by delimiters].  If that subkey already exists, then
     it is updated.

     `\%Contents' is a reference to a hash containing pairs of value names
     with value data and/or subkey names with hash references similar to
     `\%Contents'.  Each of these cause a value or subkey of `$subKey' to
     be created or updated.

     If `$Contents{""}' exists and is a reference to a hash, then it used
     as the options argument when `CreateKey()' is called for `$subKey'.
     This allows you to specify ...

          if(  defined( $$data{""} )  &&  "HASH" eq ref($$data{""})  ) {
              $self= $this->CreateKey( $subKey, delete $$data{""} );

Load
$newKey= $key->Load( $file )
$newKey= $key->Load( $file, $newSubKey )
$newKey= $key->Load( $file, $newSubKey, { Option=>OptVal... } )
$newKey= $key->Load( $file, { Option=>OptVal... } )
     Loads a hive file into a Registry.  That is, creates a new subkey and
     associates a hive file with it.

     $file is a hive file, that is a file created by calling
     `RegSaveKey()'.  The $file path is interpreted relative to
     `%SystemRoot%/System32/config' on the machine where $key resides.

     `$newSubKey' is the name to be given to the new subkey.  If
     `$newSubKey' is specified, then $key must be `HKEY_LOCAL_MACHINE' or
     `HKEY_USERS' of the local computer or a remote computer and
     `$newSubKey' should not contain any occurrences of either the
     delimiter or the OS delimiter.

     If `$newSubKey' is not specified, then it is as if $key was
     `$Registry-E<GT'{LMachine}> and `$newSubKey' is `"PerlTie:999"' where
     `"999"' is actually a sequence number incremented each time this
     process calls `Load()'.

     You can specify as the last argument a reference to a hash containing
     options.  You can specify the same options that you can specify to
     `Open()'.  See `Open()' for more information on those.  In addition,
     you can specify the option `"NewSubKey"'.  The value of this option
     is interpretted exactly as if it was specified as the `$newSubKey'
     parameter and overrides the `$newSubKey' if one was specified.

     The hive is automatically unloaded when the returned object
     [`$newKey'] is destroyed.  Registry key objects opened within the
     hive will keep a reference to the `$newKey' object so that it will
     not be destroyed before these keys are closed.

UnLoad
$okay= $key->UnLoad
     Unloads a hive that was loaded via `Load()'.  Cannot unload other
     hives.  $key must be the return from a previous call to `Load()'.
     $key is closed and then the hive is unloaded.

AllowSave
$okay= AllowSave( $bool )
     Enables or disables the `"ReBackupPrivilege"' privilege for the
     current process.  You will probably have to enable this privilege
     before you can use `RegSaveKey()'.

     The return value indicates whether the operation succeeded, not
     whether the privilege was previously enabled.

AllowLoad
$okay= AllowLoad( $bool )
     Enables or disables the `"ReRestorePrivilege"' privilege for the
     current process.  You will probably have to enable this privilege
     before you can use `RegLoadKey()', `RegUnLoadKey()',
     `RegReplaceKey()', or RegRestoreKey and thus `Load()' and `UnLoad()'.

     The return value indicates whether the operation succeeded, not
     whether the privilege was previously enabled.

Exports [use and import()]
--------------------------

   To have nothing imported into your package, use something like:

     use Win32::TieRegistry 0.20 ();

   which would verify that you have at least version 0.20 but wouldn't
call import().  The Changes file can be useful in figuring out which, if
any, prior versions of *Win32::TieRegistry* you want to support in your
script.

   The code

     use Win32::TieRegistry;

   imports the variable `$Registry' into your package and sets it to be a
reference to a hash tied to a copy of the master Registry virtual root
object with the default options.  One disadvantage to this "default" usage
is that Perl does not support checking the module version when you use it.

   Alternately, you can specify a list of arguments on the use line that
will be passed to the `Win32::TieRegistry-'import()> method to control
what items to import into your package.  These arguments fall into the
following broad categories:

Import a reference to a hash tied to a Registry virtual root
     You can request that a scalar variable be imported (possibly) and set
     to be a reference to a hash tied to a Registry virtual root using any
     of the following types of arguments or argument pairs:

    "TiedRef", '$scalar'
    "TiedRef", '$pack::scalar'
    "TiedRef", 'scalar'
    "TiedRef", 'pack::scalar'
          All of the above import a scalar named $scalar into your package
          (or the package named "pack") and then sets it.

    '$scalar'
    '$pack::scalar'
          These are equivalent to the previous items to support a more
          traditional appearance to the list of exports.  Note that the
          scalar name cannot be "RegObj" here.

    "TiedRef", \$scalar
    \$scalar
          These versions don't import anything but set the referenced
          $scalar.

Import a hash tied to the Registry virtual root
     You can request that a hash variable be imported (possibly) and tied
     to a Registry virtual root using any of the following types of
     arguments or argument pairs:

    "TiedHash", '%hash'
    "TiedHash", '%pack::hash'
    "TiedHash", 'hash'
    "TiedHash", 'pack::hash'
          All of the above import a hash named `%hash' into your package
          (or the package named "pack") and then sets it.

    '%hash'
    '%pack::hash'
          These are equivalent to the previous items to support a more
          traditional appearance to the list of exports.

    "TiedHash", \%hash
    \%hash
          These versions don't import anything but set the referenced
          `%hash'.

Import a Registry virtual root object
     You can request that a scalar variable be imported (possibly) and set
     to be a Registry virtual root object using any of the following types
     of arguments or argument pairs:

    "ObjectRef", '$scalar'
    "ObjectRef", '$pack::scalar'
    "ObjectRef", 'scalar'
    "ObjectRef", 'pack::scalar'
          All of the above import a scalar named $scalar into your package
          (or the package named "pack") and then sets it.

    '$RegObj'
          This is equivalent to the previous items for backward
          compatibility.

    "ObjectRef", \$scalar
          This version doesn't import anything but sets the referenced
          $scalar.

Import constant(s) exported by *Win32API::Registry*
     You can list any constants that are exported by *Win32API::Registry*
     to have them imported into your package.  These constants have names
     starting with "KEY_" or "REG_" (or even "HKEY_").

     You can also specify `":KEY_"', `":REG_"', and even `":HKEY_"' to
     import a whole set of constants.

     See *Win32API::Registry* documentation for more information.

Options
     You can list any option names that can be listed in the `SetOptions()'
     method call, each folowed by the value to use for that option.  A
     Registry virtual root object is created, all of these options are set
     for it, then each variable to be imported/set is associated with this
     object.

     In addition, the following special options are supported:

    ExportLevel
          Whether to import variables into your package or some package
          that uses your package.  Defaults to the value of
          `$Exporter::ExportLevel' and has the same meaning.  See the
          *Note Exporter: Exporter, module for more information.

    ExportTo
          The name of the package to import variables and constants into.
          Overrides ExportLevel.

Specifying constants in your Perl code
......................................

   This module was written with a strong emphasis on the convenience of
the module user.  Therefore, most places where you can specify a constant
like `REG_SZ()' also allow you to specify a string containing the name of
the constant, `"REG_SZ"'.  This is convenient because you may not have
imported that symbolic constant.

   Perl also emphasizes programmer convenience so the code REG_SZ can be
used to mean `REG_SZ()' or `"REG_SZ"' or be illegal.  Note that using
`&REG_SZ' (as we've seen in much Win32 Perl code) is not a good idea since
it passes the current `@_' to the `constant()' routine of the module
which, at the least, can give you a warning under -w.

   Although greatly a matter of style, the "safest" practice is probably
to specifically list all constants in the `use Win32::TieRegistry'
statement, specify `use strict' [or at least `use strict qw(subs)'], and
use bare constant names when you want the numeric value.  This will detect
mispelled constant names at compile time.

     use strict;
     my $Registry;
     use Win32::TieRegistry 0.20 (
         TiedRef => \$Registry,  Delimiter => "/",  ArrayValues => 1,
     	SplitMultis => 1,  AllowLoad => 1,
         qw( REG_SZ REG_EXPAND_SZ REG_DWORD REG_BINARY REG_MULTI_SZ
     	    KEY_READ KEY_WRITE KEY_ALL_ACCESS ),
     );
     $Registry->{"LMachine/Software/FooCorp/"}= {
         "FooWriter/" => {
             "/Fonts" => [ ["Times","Courier","Lucinda"], REG_MULTI_SZ ],
     	    "/WindowSize" => [ pack("LL",24,80), REG_BINARY ],
     	    "/TaskBarIcon" => [ "0x0001", REG_DWORD ],
     	},
     }  or  die "Can't create Software/FooCorp/: $^E\n";

   If you don't want to `use strict qw(subs)', the second safest practice
is similar to the above but use the `REG_SZ()' form for constants when
possible and quoted constant names when required.  Note that `qw()' is a
form of quoting.

     use Win32::TieRegistry 0.20 qw(
         TiedRef $Registry
         Delimiter /  ArrayValues 1  SplitMultis 1  AllowLoad 1
         REG_SZ REG_EXPAND_SZ REG_DWORD REG_BINARY REG_MULTI_SZ
         KEY_READ KEY_WRITE KEY_ALL_ACCESS
     );
     $Registry->{"LMachine/Software/FooCorp/"}= {
         "FooWriter/" => {
             "/Fonts" => [ ["Times","Courier","Lucinda"], REG_MULTI_SZ() ],
     	    "/WindowSize" => [ pack("LL",24,80), REG_BINARY() ],
     	    "/TaskBarIcon" => [ "0x0001", REG_DWORD() ],
     	},
     }  or  die "Can't create Software/FooCorp/: $^E\n";

   The examples in this document mostly use quoted constant names
(`"REG_SZ"') since that works regardless of which constants you imported
and whether or not you have `use strict' in your script.  It is not the
best choice for you to use for real scripts (vs. examples) because it is
less efficient and is not supported by most other similar modules.

SUMMARY
=======

   Most things can be done most easily via tied hashes.  Skip down to the
the `Tied Hashes Summary' in this node to get started quickly.

Objects Summary
---------------

   Here are quick examples that document the most common functionality of
all of the method functions [except for a few almost useless ones].

     # Just another way of saying Open():
     $key= new Win32::TieRegistry "LMachine\\Software\\",
       { Access=>KEY_READ()|KEY_WRITE(), Delimiter=>"\\" };

     # Open a Registry key:
     $subKey= $key->Open( "SubKey/SubSubKey/",
       { Access=>KEY_ALL_ACCESS, Delimiter=>"/" } );

     # Connect to a remote Registry key:
     $remKey= $Registry->Connect( "MachineName", "LMachine/",
       { Access=>KEY_READ, Delimiter=>"/" } );

     # Get value data:
     $valueString= $key->GetValue("ValueName");
     ( $valueString, $valueType )= $key->GetValue("ValueName");

     # Get list of value names:
     @valueNames= $key->ValueNames;

     # Get list of subkey names:
     @subKeyNames= $key->SubKeyNames;

     # Get combined list of value names (with leading delimiters)
     # and subkey names (with trailing delimiters):
     @memberNames= $key->MemberNames;

     # Get all information about a key:
     %keyInfo= $key->Information;
     # keys(%keyInfo)= qw( Class LastWrite SecurityLen
     #   CntSubKeys MaxSubKeyLen MaxSubClassLen
     #   CntValues MaxValNameLen MaxValDataLen );

     # Get selected information about a key:
     ( $class, $cntSubKeys )= $key->Information( "Class", "CntSubKeys" );

     # Get and/or set delimiter:
     $delim= $key->Delimiter;
     $oldDelim= $key->Delimiter( $newDelim );

     # Get "path" for an open key:
     $path= $key->Path;
     # For example, "/CUser/Control Panel/Mouse/"
     # or "//HostName/LMachine/System/DISK/".

     # Get name of machine where key is from:
     $mach= $key->Machine;
     # Will usually be "" indicating key is on local machine.

     # Control different options (see main documentation for descriptions):
     $oldBool= $key->ArrayValues( $newBool );
     $oldBool= $key->FastDelete( $newBool );
     $oldBool= $key->FixSzNulls( $newBool );
     $oldBool= $key->SplitMultis( $newBool );
     $oldBool= $key->DWordsToHex( $newBool );
     $oldBool= $key->DualBinVals( $newBool );
     $oldBool= $key->DualTypes( $newBool );
     @oldBools= $key->SetOptions( ArrayValues=>1, FastDelete=>1, FixSzNulls=>0,
       Delimiter=>"/", AllowLoad=>1, AllowSave=>1 );
     @oldBools= $key->GetOptions( ArrayValues, FastDelete, FixSzNulls );

     # Add or set a value:
     $key->SetValue( "ValueName", $valueDataString );
     $key->SetValue( "ValueName", pack($format,$valueData), "REG_BINARY" );

     # Add or set a key:
     $key->CreateKey( "SubKeyName" );
     $key->CreateKey( "SubKeyName",
       { Access=>"KEY_ALL_ACCESS", Class=>"ClassName",
         Delimiter=>"/", Volatile=>1, Backup=>1 } );

     # Load an off-line Registry hive file into the on-line Registry:
     $newKey= $Registry->Load( "C:/Path/To/Hive/FileName" );
     $newKey= $key->Load( "C:/Path/To/Hive/FileName", "NewSubKeyName",
                      { Access=>"KEY_READ" } );
     # Unload a Registry hive file loaded via the Load() method:
     $newKey->UnLoad;

     # (Dis)Allow yourself to load Registry hive files:
     $success= $Registry->AllowLoad( $bool );

     # (Dis)Allow yourself to save a Registry key to a hive file:
     $success= $Registry->AllowSave( $bool );

     # Save a Registry key to a new hive file:
     $key->RegSaveKey( "C:/Path/To/Hive/FileName", [] );

Other Useful Methods
....................

   See *Win32API::Registry* for more information on these methods.  These
methods are provided for coding convenience and are identical to the
*Win32API::Registry* functions except that these don't take a handle to a
Registry key, instead getting the handle from the invoking object [$key].

     $key->RegGetKeySecurity( $iSecInfo, $sSecDesc, $lenSecDesc );
     $key->RegLoadKey( $sSubKeyName, $sPathToFile );
     $key->RegNotifyChangeKeyValue(
       $bWatchSubtree, $iNotifyFilter, $hEvent, $bAsync );
     $key->RegQueryMultipleValues(
       $structValueEnts, $cntValueEnts, $Buffer, $lenBuffer );
     $key->RegReplaceKey( $sSubKeyName, $sPathToNewFile, $sPathToBackupFile );
     $key->RegRestoreKey( $sPathToFile, $iFlags );
     $key->RegSetKeySecurity( $iSecInfo, $sSecDesc );
     $key->RegUnLoadKey( $sSubKeyName );

Tied Hashes Summary
-------------------

   For fast learners, this may be the only section you need to read.
Always append one delimiter to the end of each Registry key name and
prepend one delimiter to the front of each Registry value name.

Opening keys
............

     use Win32::TieRegistry ( Delimiter=>"/", ArrayValues=>1 );
     $Registry->Delimiter("/");                  # Set delimiter to "/".
     $swKey= $Registry->{"LMachine/Software/"};
     $winKey= $swKey->{"Microsoft/Windows/CurrentVersion/"};
     $userKey= $Registry->
       {"CUser/Software/Microsoft/Windows/CurrentVersion/"};
     $remoteKey= $Registry->{"//HostName/LMachine/"};

Reading values
..............

     $progDir= $winKey->{"/ProgramFilesDir"};    # "C:\\Program Files"
     $tip21= $winKey->{"Explorer/Tips//21"};     # Text of tip #21.

     $winKey->ArrayValues(1);
     ( $devPath, $type )= $winKey->{"/DevicePath"};
     # $devPath eq "%SystemRoot%\\inf"
     # $type eq "REG_EXPAND_SZ"  [if you have SetDualVar.pm installed]
     # $type == REG_EXPAND_SZ()  [if did C<use Win32::TieRegistry qw(:REG_)>]

Setting values
..............

     $winKey->{"Setup//SourcePath"}= "\\\\SwServer\\SwShare\\Windows";
     # Simple.  Assumes data type of REG_SZ.

     $winKey->{"Setup//Installation Sources"}=
       [ "D:\x00\\\\SwServer\\SwShare\\Windows\0\0", "REG_MULTI_SZ" ];
     # "\x00" and "\0" used to mark ends of each string and end of list.

     $winKey->{"Setup//Installation Sources"}=
       [ ["D:","\\\\SwServer\\SwShare\\Windows"], "REG_MULTI_SZ" ];
     # Alternate method that is easier to read.

     $userKey->{"Explorer/Tips//DisplayInitialTipWindow"}=
       [ pack("L",0), "REG_DWORD" ];
     $userKey->{"Explorer/Tips//Next"}= [ pack("S",3), "REG_BINARY" ];
     $userKey->{"Explorer/Tips//Show"}= [ pack("L",0), "REG_BINARY" ];

Adding keys
...........

     $swKey->{"FooCorp/"}= {
         "FooWriter/" => {
             "/Version" => "4.032",
             "Startup/" => {
                 "/Title" => "Foo Writer Deluxe ][",
                 "/WindowSize" => [ pack("LL",$wid,$ht), "REG_BINARY" ],
                 "/TaskBarIcon" => [ "0x0001", "REG_DWORD" ],
             },
             "Compatibility/" => {
                 "/AutoConvert" => "Always",
                 "/Default Palette" => "Windows Colors",
             },
         },
         "/License", => "0123-9C8EF1-09-FC",
     };

Listing all subkeys and values
..............................

     @members= keys( %{$swKey} );
     @subKeys= grep(  m#^/#,  keys( %{$swKey->{"Classes/batfile/"}} )  );
     # @subKeys= ( "/", "/EditFlags" );
     @valueNames= grep(  ! m#^/#,  keys( %{$swKey->{"Classes/batfile/"}} )  );
     # @valueNames= ( "DefaultIcon/", "shell/", "shellex/" );

Deleting values or keys with no subkeys
.......................................

     $oldValue= delete $userKey->{"Explorer/Tips//Next"};

     $oldValues= delete $userKey->{"Explorer/Tips/"};
     # $oldValues will be reference to hash containing deleted keys values.

Closing keys
............

     undef $swKey;               # Explicit way to close a key.
     $winKey= "Anything else";   # Implicitly closes a key.
     exit 0;                     # Implicitly closes all keys.

Tie::Registry
-------------

   This module was originally called Tie::Registry.  Changing code that
used Tie::Registry over to *Win32::TieRegistry* is trivial as the module
name should only be mentioned once, in the use line.  However, finding all
of the places that used Tie::Registry may not be completely trivial so we
have included `Tie/Registry.pm' which you can install to provide backward
compatibility.

AUTHOR
======

   Tye McQueen.  See http://www.metronet.com/~tye/ or e-mail
tye@metronet.com with bug reports.

SEE ALSO
========

   *Win32API::Registry* - Provides access to `Reg*()', `HKEY_*', `KEY_*',
`REG_*' [required].

   *Win32::WinError* - Defines `ERROR_*' values [optional].

   `SetDualVar' in this node - For returning `REG_*' values as combined
string/integer values [optional].

BUGS
====

   Perl5.004_02 has bugs that make *Win32::TieRegistry* fail in strange
and subtle ways.

   Using *Win32::TieRegistry* with versions of Perl prior to 5.005 can be
tricky or impossible.  Most notes about this have been removed from the
documentation (they get rather complicated and confusing).  This includes
references to $^E perhaps not being meaningful.

   Because Perl hashes are case sensitive, certain lookups are also case
sensistive.  In particular, the root keys ("Classes", "CUser", "LMachine",
"Users", "PerfData", "CConfig", "DynData", and HKEY_*) must always be
entered without changing between upper and lower case letters.  Also, the
special rule for matching subkey names that contain the user-selected
delimiter only works if case is matched.  All other key name and value
name lookups should be case insensitive because the underlying Reg*()
calls ignore case.

   Information about each key is cached when using a tied hash.  This
cache is not flushed nor updated when changes are made, *even when the
same tied hash is used* to make the changes.

   Current implementations of Perl's "global destruction" phase can cause
objects returned by `Load()' to be destroyed while keys within the hive
are still open, if the objects still exist when the script starts to exit.
When this happens, the automatic `UnLoad()' will report a failure and the
hive will remain loaded in the Registry.

   Trying to `Load()' a hive file that is located on a remote network
share may silently delete all data from the hive.  This is a bug in the
Win32 APIs, not any Perl code or modules.  This module does not try to
protect you from this bug.

   There is no test suite.

FUTURE DIRECTIONS
=================

   The following items are desired by the author and may appear in a
future release of this module.

TieValues option
     Currently described in main documentation but no yet implemented.

AutoRefresh option
     Trigger use of `RegNotifyChangeKeyValue()' to keep tied hash caches
     up-to-date even when other programs make changes.

Error options
     Allow the user to have unchecked calls (calls in a "void context") to
     automatically report errors via warn or die.

     For complex operations, such a copying an entire subtree, provide
     access to detailed information about errors (and perhaps some
     warnings) that were encountered.  Let the user control whether the
     complex operation continues in spite of errors.


