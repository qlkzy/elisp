This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: HTML/Features,  Next: HTML/FeaturesD,  Prev: HTML/Faq,  Up: Module List

Main features of HTML::Embperl 1.3
==================================

   * Lets you embed Perl code into HTML documents. Perl code is evaluated
     at the server side and the result is sent to the browser.

   * Offers various meta-commands for conditional and loop processing of
     the HTML documents.

   * Automatically generates dynamic HTML tables/lists from Perl arrays or
     function calls (e.g. DBI fetch)

   * Form data send to your document is placed in a hash

   * Automatically inserts data from the form hash into HTML input,
     textarea and select tags

   * Understands HTML and URL escaping and unescaping

   * Handles per-user and per-module persistent session data for you.  All
     you need to do is store and retrieve them to and from a special hash.

   * Allows you to build your web-site out of components. Frequently used
     elements can be defined once and included in every page.

   * EmbperlObject allows you to define the standard layout of your site
     just once and includes the neccessary components based on the uri.
     Your HTML documents just have to contain the unique stuff and not the
     common stuff like headers/footers or navigation bars. Also these
     common elements can be overwritten in each subdirectory.

   * Gives you the possibility to build libraries with a set of frequently
     used Elements or components, and make them available to the whole
     web-site in the same way as Perl modules are - well, modularized.

   * Supports debugging of pages by generating a very detailed log file
     and making it accessible via the browser with a single click.

   * Generates verbose error pages in which every error can link to the
     log file. This is ideal for debugging.

   * Offers a lot of options for maximum configurability according to your
     personal tastes and needs.

   * Fully integrated into Apache and mod_perl to acheive the best
     performance. Can also run as a CGI-script, offline or called from
     another Perl program.

   * The Perl module DBIx::Recordset offers high level, easy to handle
     database access for Embperl.

   * If you are concerned about security you can configure Embperl to use
     Safe.pm. This way, your documents can run in a safe namespace which
     can allow or disallow certain Perl opcodes.

   * *HTML::Embperl::Mail* gives you the possibility to send the result
     directly to a email address


File: pm.info,  Node: HTML/FeaturesD,  Next: HTML/FillInForm,  Prev: HTML/Features,  Up: Module List

Wesentliche Features von HTML::Embperl 1.3
==========================================

   * Erlaubt das Einbetten von Perlcode in HTML Dokumente. Der Perlcode
     wird im Server ausgeführt und das Ergebnis zum Browser geschickt.

   * Stellt verschiedene Meta Commands zur bedingten und iterativen
     Verarbeitung von HTML Dokumenten zur Verfügung.

   * Erzeugt automatisch dynamische Tabellen/Listen aus Perl Arrays oder
     Funktionsaufrufen (z.B. DBI fetch)

   * Formulardaten die an ein Embperl Dokument gesandt werden sind einfach
     über einen Hash zugreifbar.

   * Fügt automatisch Daten aus dem Formularhash in HTML Input, Textarea
     und Select Tags ein.

   * Versteht HTML und URL Kodierung/Dekodierung.

   * Stellt Pro-Benutzer und Pro-Seite persitente Sessiondaten zur
     Verfügung.  Dafür ist es lediglich nötig die Daten in einem spezielle
     Hash abzulegen.

   * Ermöglicht das Erstellen von Websites aus Komponenten. Oft benutzte
     Elemente können einmal definiert und in jede Seite eingefügt werden.

   * EmbperlObject erlaubt es das standart Layout einer Website lediglich
     einmal zu definieren und EmbperlObject sorgt dafür das die passenden
     Komoponeten an die entsprechenden Stellen eingefügt werden. Die
     eigentlichen Seiten enthalten nur noch den tatsächlichen Inhalt und
     nicht gemeinsamme Elemente wie Kopf- und Fußbereich oder
     Navigationsleisten. Diese gemeinsammen Bereiche können weiterhin je
     Unterverzeichnis überschrieben werden.

   * Erlaubt Bibliotheken mit oft benutzten Elementen zu erstellen und
     diese der ganzen Website, wie normale Perlmodule, zur Verfügung zu
     stellen .

   * Unterstüzt das Debuggen von Seiten durch Erzeugen einer detaillierten
     Logdatei, die mittels eines einzigen Klicks vom Browser aus betrachtet
     werden kann.

   * Erzeugt ausführliche Fehlerseiten, wobei jeder Fehler ein Link an die
     richtige Stelle in die Logdatei sein kann.

   * Bietet eine ganze Reihe Optionen zur Konfigurierung entsprechend den
     persönlichen Vorlieben.

   * Vollständig integriert in Apache und mod_perl, um die beste
     Performance zu erreichen. Kann auch als CGI Skript laufen, Offline
     ausgeführt werden oder von anderem Perlprogrammen/-modulen aufgerufen
     werden.

   * Das Perlmodule DBIx::Recordset bietet einen hochwertigen, einfach zu
     handhabenden, Datenbankzugriff für Embperl.

   * Wenn Sicherheit ein Problem darstellt, ist es möglich Embperl so zu
     konfigurieren, daß es Safe.pm nutzt. Dadurch entstehen sichere
     Namensräume und einzelne Perl Opcode können gesperrt werden.

   * *HTML::Embperl::Mail* ermöglicht es das Ergebnis direkt an eine E-Mail
     Adresse zu versenden.


File: pm.info,  Node: HTML/FillInForm,  Next: HTML/Filter,  Prev: HTML/FeaturesD,  Up: Module List

Populates HTML Forms with CGI data.
***********************************

NAME
====

   HTML::FillInForm - Populates HTML Forms with CGI data.

DESCRIPTION
===========

   This module automatically inserts data from a previous HTML form into
the HTML input, textarea and select tags.  It is a subclass of *Note
HTML/Parser: HTML/Parser, and uses it to parse the HTML and insert the
values into the form tags.

   One useful application is after a user submits an HTML form without
filling out a required field.  HTML::FillInForm can be used to redisplay
the HTML form with all the form elements containing the submitted info.

SYNOPSIS
========

   This examples fills data into a HTML form stored in `$htmlForm' from
CGI parameters that are stored in $q.  For example, it will set the value
of any "name" textfield to "John Smith".

     my $q = new CGI;

     $q->param("name","John Smith");

     my $fif = new HTML::FillInForm;
     my $output = $fif->fill(scalarref => \$html,
     			  fobject => $q);

METHODS
=======

new
     Call new() to create a new FillInForm object:

          $fif = new HTML::FillInForm;

fill
     To fill in a HTML form contained in a scalar $html:

          $output = $fif->fill(scalarref => \$html,
                     fobject => $q);

     Returns filled in HTML form contained in $html with data from $q.  $q
     is required to have a param() method that works like CGI's param().

          $output = $fif->fill(scalarref => \$html,
                     fdat => \%fdat);

     Returns filled in HTML form contained in $html with data from `%fdat'.
     To pass multiple values using `%fdat' use an array reference.

     Alternately you can use

          $output = $fif->fill(arrayref => \@array_of_lines,
                     fobject => $q);

     and

          $output = $fif->fill(file => 'form.tmpl',
                     fobject => $q);

CALLING FROM OTHER MODULES
==========================

Apache::PageKit
---------------

   To use HTML::FillInForm in *Note Apache/PageKit: Apache/PageKit, is
easy.  It is automatically called for any page that includes a <form> tag.

Apache::ASP v2.09 and above
---------------------------

   HTML::FillInForm is now integrated with Apache::ASP.  To activate, use

     PerlSetVar FormFill 1
     $Response->{FormFill} = 1

Apache::ASP v2.08 and below
---------------------------

   To use HTML::FillInForm, put the following in global.asa

     sub fillin {
       my $args = shift;
       my $html = shift;
       my $fif = new HTML::FillInForm;
       my $output = $fif->fill(
                              scalarref => \$html,
                              fdat      => $Apps::Param,
                              );
       $Response->Write($output);
     }

   Note $Apps::Param is set to either the querystring or form data.
Replace with $Request->QueryString or $Request->Form if you wish.

   Then put something like this in your apache configuration:

     XMLSubsMatch fillin

   Finally, surround your forms like this:

     <fillin>
       <form>
         <input name="myfield">
       </form>
     </fillin>

   See http://forum.swarthmore.edu/epigone/modperl/malskalko for more
details.

SEE ALSO
========

   *Note HTML/Parser: HTML/Parser,

VERSION
=======

   This documentation describes HTML::FillInForm module version 0.10.

BUGS
====

   This module has not been tested extensively.  Please submit any bug
reports to tjmather@anidea.com.

NOTES
=====

   Requires Perl 5.005 and *Note HTML/Parser: HTML/Parser, version 3.08.

   I wrote this module because I wanted to be able to insert CGI data into
HTML forms, but without combining the HTML and Perl code.  CGI.pm and
Embperl allow you so insert CGI data into forms, but require that you mix
HTML with Perl.

AUTHOR
======

   (c) 2000 Thomas J. Mather, tjmather@alumni.princeton.edu

   All rights reserved. This package is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

CREDITS
=======

   Fixes, Bug Reports, Docs have been generously provided by:

     Patrick Michael Kane
     Tom Lancaster
     Ade Olonoh
     Tatsuhiko Miyagawa
     Paul Lindner

   Thanks!


File: pm.info,  Node: HTML/Filter,  Next: HTML/Form,  Prev: HTML/FillInForm,  Up: Module List

Filter HTML text through the parser
***********************************

NAME
====

   HTML::Filter - Filter HTML text through the parser

NOTE
====

   This module is deprecated. HTML::Parser now provides the functionally
of `HTML::Filter' much more efficiently with the the default handler.

SYNOPSIS
========

     require HTML::Filter;
     $p = HTML::Filter->new->parse_file("index.html");

DESCRIPTION
===========

   `HTML::Filter' is an HTML parser that by default prints the original
text of each HTML element (a slow version of cat(1) basically).  The
callback methods may be overridden to modify the filtering for some HTML
elements and you can override output() method which is called to print the
HTML text.

   `HTML::Filter' is a subclass of HTML::Parser. This means that the
document should be given to the parser by calling the $p->parse() or
$p->parse_file() methods.

EXAMPLES
========

   The first example is a filter that will remove all comments from an
HTML file.  This is achieved by simply overriding the comment method to do
nothing.

     package CommentStripper;
     require HTML::Filter;
     @ISA=qw(HTML::Filter);
     sub comment { }  # ignore comments

   The second example shows a filter that will remove any <TABLE>s found
in the HTML file.  We specialize the start() and end() methods to count
table tags and then make output not happen when inside a table.

     package TableStripper;
     require HTML::Filter;
     @ISA=qw(HTML::Filter);
     sub start
     {
        my $self = shift;
        $self->{table_seen}++ if $_[0] eq "table";
        $self->SUPER::start(@_);
     }

     sub end
     {
        my $self = shift;
        $self->SUPER::end(@_);
        $self->{table_seen}-- if $_[0] eq "table";
     }

     sub output
     {
         my $self = shift;
         unless ($self->{table_seen}) {
     	  $self->SUPER::output(@_);
         }
     }

   If you want to collect the parsed text internally you might want to do
something like this:

     package FilterIntoString;
     require HTML::Filter;
     @ISA=qw(HTML::Filter);
     sub output { push(@{$_[0]->{fhtml}}, $_[1]) }
     sub filtered_html { join("", @{$_[0]->{fhtml}}) }

SEE ALSO
========

   *Note HTML/Parser: HTML/Parser,

COPYRIGHT
=========

   Copyright 1997-1999 Gisle Aas.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTML/Form,  Next: HTML/FormHighlight,  Prev: HTML/Filter,  Up: Module List

Class that represents HTML forms
********************************

NAME
====

   HTML::Form - Class that represents HTML forms

SYNOPSIS
========

     use HTML::Form;
     $form = HTML::Form->parse($html, $base_uri);
     $form->value(query => "Perl");

     use LWP;
     LWP::UserAgent->new->request($form->click);

DESCRIPTION
===========

   Objects of the `HTML::Form' class represents a single HTML <form> ...
</form> instance.  A form consist of a sequence of inputs that usually
have names, and which can take on various values.

   The following methods are available:

$form = HTML::Form->new($method, $action_uri, [[$enctype], $input,...])
     The constructor takes a $method and a $uri as argument.  The $enctype
     and and initial inputs are optional.  You will normally use
     HTML::Form->parse() to create new HTML::Form objects.

@forms = HTML::Form->parse($html_document, $base_uri)
     The parse() class method will parse an HTML document and build up
     `HTML::Form' objects for each <form> found.  If called in scalar
     context only returns the first <form>.  Returns an empty list if there
     are no forms to be found.

     The $base_uri is (usually) the URI used to access the $html_document.
     It is needed to resolve relative action URIs.  For LWP this parameter
     is obtained from the $response->base() method.

$form->push_input($type, \%attr)
     Adds a new input to the form.

$form->method( [$new] )
$form->action( [$new] )
$form->enctype( [$new] )
     These method can be used to get/set the corresponding attribute of the
     form.

$form->inputs
     This method returns the list of inputs in the form.

$form->find_input($name, $type, $no)
     This method is used to locate some specific input within the form.  At
     least one of the arguments must be defined.  If no matching input is
     found, undef is returned.

     If $name is specified, then the input must have the indicated name.
     If $type is specified then the input must have the specified type.  In
     addition to the types possible for <input> HTML tags, we also have
     "textarea" and "option".  The $no is the sequence number of the input
     with the indicated $name and/or $type (where 1 is the first).

$form->value($name, [$value])
     The value() method can be used to get/set the value of some input.  If
     no input have the indicated name, then this method will croak.

$form->try_others(\&callback)
     This method will iterate over all permutations of unvisited enumerated
     values (<select>, <radio>, <checkbox>) and invoke the callback for
     each.  The callback is passed the $form as argument.

$form->make_request
     Will return a HTTP::Request object that reflects the current setting
     of the form.  You might want to use the click method instead.

$form->click([$name], [$x, $y])
     Will click on the first clickable input (`input/submit' or
     `input/image'), with the indicated $name, if specified.  You can
     optinally specify a coordinate clicked, which only makes a difference
     if you clicked on an image.  The default coordinate is (1,1).

$form->form
     Returns the current setting as a sequence of key/value pairs.

$form->dump
     Returns a textual representation of the form.  Mainly useful for
     debugging.  If called in void context, then the dump is printed on
     STDERR.

INPUTS
======

   An `HTML::Form' contains a sequence of inputs.  References to the
inputs can be obtained with the $form->inputs or $form->find_input
methods.  Once you have such a reference, then one of the following
methods can be used on it:

$input->type
     Returns the type of this input.  Types are stuff like "text",
     "password", "hidden", "textarea", "image", "submit", "radio",
     "checkbox", "option"...

$input->name([$new])
$input->value([$new])
     These methods can be used to set/get the current name or value of an
     input.  If the input only can take an enumerated list of values, then
     it is an error to try to set it to something else and the method will
     croak if you try.

$input->possible_values
     Returns a list of all values that and input can take.  For inputs that
     does not have discrete values this returns an empty list.

$input->other_possible_values
     Returns a list of all values not tried yet.

$input->form_name_value
     Returns a (possible empty) list of key/value pairs that should be
     incorporated in the form value from this input.

$input->click($form, $x, $y)
     Some input types (currently "sumbit" buttons and "images") can be
     clicked to submit the form.  The click() method returns the
     corrsponding HTTP::Request object.

SEE ALSO
========

   *Note LWP: LWP,, *Note HTML/Parser: HTML/Parser,, `webchatpp' in this
node

COPYRIGHT
=========

   Copyright 1998-2000 Gisle Aas.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTML/FormHighlight,  Next: HTML/FormValidator,  Prev: HTML/Form,  Up: Module List

Highlights fields in an HTML form.
**********************************

NAME
====

   HTML::FormHighlight - Highlights fields in an HTML form.

SYNOPSIS
========

     use HTML::FormHighlight;

     my $h = new HTML::FormHighlight;
     
     print $h->highlight( scalarref => \$form, fields => [ 'A', 'B', 'C' ] );

DESCRIPTION
===========

   HTML::FormHighlight can be used to highlight fields in an HTML form.
It uses HTML::Parser to parse the HTML form, and then places an indicator
before each field.  You can specify which fields to highlight, and
optionally supply a CGI object for it to check whether or not an input
value exists before highlighting the field.

   It can be used when displaying forms where a user hasn't filled out a
required field.  The indicator can make it easier for a user to locate the
fields that they've missed.  If you're interested in more advanced form
validation, see *Note HTML/FormValidator: HTML/FormValidator,.  *Note
HTML/FillInForm: HTML/FillInForm, can also be used to fill form fields
with values that have already been submitted.

METHODS
=======

new()
-----

     Create a new HTML::FormHighlight object.  Example:
     
         $h = new HTML::FormHighlight;

     =head2 highlight()

   Parse through the HTML form and highlight fields.  The method returns a
scalar containing the parsed form.  Here are a few examples:

     To highlight the fields 'A', 'B' and 'C' (form on disk):
     
         $h->highlight(
             file   => 'form.html',
             fields => [ 'A', 'B', 'C' ],
         );
     
     To highlight the fields 'A' and 'B' with a smiley face
     (form as a scalar):
     
         $h->highlight(
             scalarref => \$form,
             fields    => [ 'A', 'B' ],
             highlight => '<img src="smiley.jpg">',
         );
     
     To highlight the fields 'A' and 'B' if they haven't been supplied
     by form input (form as an array of lines):
     
         $q = new CGI;
     
         $h->highlight(
             arrayref => \@form,
             fields  => [ 'A', 'B' ],
             fobject => $q,
         );
     
     Note: highlight() will only highlight the first option in a radio or select group.
     
     Here's a list of possible parameters for highlight() and their descriptions:

   * scalarref - a reference to a scalar that contains the text of the
     form.

   * arrayref - a reference to an array of lines that contain the text of
     the form.

   * file - a scalar that contains the file name where the form is kept.

   * fields - a reference to an array that lists the fields to be
     highlighted.  If used in conjunction with "fobject" or "fdat", only
     the fields listed that are empty will be highlighted.

   * highlight - a scalar that contains the highlight indicator.  Defaults
     to a red asterisk (<font color="#FF0000" size="+1"><b>*</b></font>).

   * fobject - a CGI.pm object, or another object which has a param()
     method that works like CGI.pm's.  HTML::FormHighlight will check to
     see if a parameter does not have a value before highlighting the
     field.

   * fdat - a hash reference, with the field names as keys.
     HTML::FormHighlight will check to see if a parameter does not have a
     value before highlighting the field.

VERSION
=======

   0.01

AUTHOR
======

   Adekunle Olonoh, ade@bottledsoftware.com

CREDITS
=======

   Hiroki Chalfant

COPYRIGHT
=========

   Copyright (c) 2000 Adekunle Olonoh. All rights reserved. This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

SEE ALSO
========

   *Note HTML/Parser: HTML/Parser,, *Note CGI: CGI,, *Note
HTML/FormValidator: HTML/FormValidator,, *Note HTML/FillInForm:
HTML/FillInForm,


File: pm.info,  Node: HTML/FormValidator,  Next: HTML/FormatNroff,  Prev: HTML/FormHighlight,  Up: Module List

Validates user input (usually from an HTML form) based on input profile.
************************************************************************

NAME
====

   HTML::FormValidator - Validates user input (usually from an HTML form)
based on input profile.

SYNOPSIS
========

   In an HTML::Empberl page:

     use HTML::FormValidator;

     my $validator = new HTML::FormValidator( "/home/user/input_profiles.pl" );
     my ( $valid, $missing, $invalid, $unknown ) = $validator->validate(  \%fdat, "customer_infos" );

DESCRIPTION
===========

   HTML::FormValidator's main aim is to make the tedious coding of input
validation expressible in a simple format and to let the programmer focus
on more interesting task.

   When you are coding web application one of the most tedious though
crucial task is to validate user's input (usually submitted by way of an
HTML form). You have to check that each required fields is present and
that some feed have valid data. (Does the phone input looks like a phone
number ? Is that a plausible email address ? Is the YY state valid ? etc.)
For simple form, this is not really a problem but as forms get more
complex and you code more of them this task became really boring and
tedious.

   HTML::FormValidator lets you defines profiles which defines the
required fields and their format. When you are ready to validate the
user's input, you tell HTML::FormValidator the profile to apply to the
user data and you get the valid fields, the name of the fields which are
missing, the name of the fields that contains invalid input and the name
of the fields that are unknown to this profile.

   You are then free to use this information to build a nice display to
the user telling which fields that he forgot to fill.

INPUT PROFILE SPECIFICATION
===========================

   To create a HTML::FormValidator, use the following :

     my $validator = new HTML::FormValidator( $input_profile );

   Where $input_profile may either be an hash reference to an input
profiles specification or a file that will be evaluated at runtime to get
a hash reference to an input profiles specification.

   The input profiles specification is an hash reference where each key is
the name of the input profile and each value is another hash reference
which contains the actual profile elements. If the input profile is
specified as a file name, the profiles will be reread each time that the
disk copy is modified.

   Here is an example of a valid input profiles specification :

     {
     	customer_infos => {
     	    optional     =>
     		[ qw( company fax country ) ],
     	    required     =>
     		[ qw( fullname phone email address city state zipcode ) ],
     	    constraints  =>
     		{
     		    email	=> "email",
     		    fax		=> "american_phone",
     		    phone	=> "american_phone",
     		    zipcode	=> '/^\s*\d{5}(?:[-]\d{4})?\s*$/',
     		    state	=> "state",
     		},
     	    defaults => {
     		country => "USA",
     	    },
     	},
     	customer_billing_infos => {
     	     optional	    => [ "cc_no" ],
     	     dependencies   => {
     		"cc_no" => [ qw( cc_type cc_exp ) ],
     	     },
     	     constraints => {
     		cc_no      => {  constraint  => "cc_number",
     				 params	     => [ qw( cc_no cc_type ) ],
     				},
     		cc_type	=> "cc_type",
     		cc_exp	=> "cc_exp",
     	      }
     	    filters       => [ "trim" ],
     	    field_filters => { cc_no => "digit" },
     	},
     }

   The following are the valid fields for an input specification :

required
     This is an array reference which contains the name of the fields which
     are required. Any fields in this list which are not present in the
     user input will be reported as missing.

optional
     This is an array reference which contains the name of optional fields.
     These are fields which MAY be present and if they are, they will be
     check for valid input. Any fields not in optional or required list
     will be reported as unknown.

dependencies
     This is an hash reference which contains dependencies information.
     This is for the case where one optional fields has other requirements.
     For example, if you enter your credit card number, the field cc_exp
     and cc_type should also be present. Any fields in the dependencies
     list that is missing when the target is present will be reported as
     missing.

defaults
     This is an hash reference which contains defaults which should be
     substituted if the user hasn't filled the fields. Key is field name
     and value is default value which will be returned in the list of valid
     fields.

filters
     This is a reference to an array of filters that will be applied to ALL
     optional or required fields. This can be the name of a builting filter
     (trim,digit,etc) or an anonymous subroutine which should take one
     parameter, the field value and return the (possibly) modified value.

field_filters
     This is a reference to an hash which contains reference to array of
     filters which will be apply to specific input fields. The key of the
     hash is the name of the input field and the valud is a reference to an
     array of filters like for the filters parameter.

constraints
     This is a reference to an hash which contains the constraints that
     will be used to check wheter or not the field contains valid data.
     Constraint can be either the name of a builtin constraint function
     (see below), a perl regexp or an anonymous subroutine which will check
     the input and return true or false depending on the input's validity.

     The constraint function takes one parameter, the input to be validated
     and returns true or false. It is possible to specify the parameters
     that will be passed to the subroutine. For that use an hash reference
     which contains in the constraint element, the anonymous subroutine or
     the name of the builtin and in the params element the name of the
     fields to pass a parameter to the function. (Don't forget to include
     the name of the field to check in that list!) For an example, look at
     the *cc_no* constraint example.

VALIDATING INPUT
================

     my( $valids, $missings, $invalids, $unknowns ) =
     	$validator->validate( \%fdat, "customer_infos" );

   To validate input you use the validate() method. This method takes two
parameters :

data
     Contains an hash which should correspond to the form input as
     submitted by the user. This hash is not modified by the call to
     validate.

profile
     Can be either a name which will be used to lookup the corresponding
     profile in the input profiles specification, or it can be an hash
     reference to the input profile which should be used.

   This method returns a 4 elements array.

valids
     This is an hash reference to the valid fields which were submitted in
     the data. The data may have been modified by the various filters
     specified.

missings
     This is a reference to an array which contains the name of the missing
     fields. Those are the fields that the user forget to fill or filled
     with space. These fields may comes from the required list or the
     dependencies list.

invalids
     This is a reference to an array which contains the name of the fields
     which failed their constraint check.

unknowns
     This is a list of fields which are unknown to the profile. Whether or
     not this indicates an error in the user input is application
     dependant.

INPUT FILTERS
=============

   These are the builtin filters which may be specified as name in the
filters and field_filters parameters of the input profile.

trim
     Remove white space at the front and end of the fields.

strip
     Runs of white space are replaced by a single space.

digit
     Remove non digits characters from the input.

alphanum
     Remove non alphanumerical characters from the input.

integer
     Extract from its input a valid integer number.

pos_integer
     Extract from its input a valid positive integer number.

pos_integer
     Extract from its input a valid negative integer number.

decimal
     Extract from its input a valid decimal number.

pos_decimal
     Extract from its input a valid positive decimal number.

neg_decimal
     Extract from its input a valid negative decimal number.

dollars
     Extract from its input a valid number to express dollars like
     currency.

phone
     Filters out characters which aren't valid for an phone number. (Only
     accept digits [0-9], space, comma, minus, parenthesis, period and
     pound [#].)

sql_wildcard
     Transforms shell glob wildcard (*) to the SQL like wildcard (%).

quotemeta
     Calls the quotemeta (quote non alphanumeric character) builtin on its
     input.

lc
     Calls the lc (convert to lowercase) builtin on its input.

uc
     Calls the uc (convert to uppercase) builtin on its input.

ucfirst
     Calls the ucfirst (Uppercase first letter) builtin on its input.

BUILTIN VALIDATOR
=================

   Those are the builtin constraint that can be specified by name in the
input profiles.

email
     Checks if the email LOOKS LIKE an email address. This checks if the
     input contains one @, and a two level domain name. The address portion
     is checked quite liberally. For example, all those probably invalid
     address would pass the test :

          nobody@top.domain
          %?&/$()@nowhere.net
          guessme@guess.m

state_or_province
     This one checks if the input correspond to an american state or a
     canadian province.

state
     This one checks if the input is a valid two letter abbreviation of an
     american state.

province
     This checks if the input is a two letter canadian province
     abbreviation.

zip_or_postcode
     This constraints checks if the input is an american zipcode or a
     canadian postal code.

postcode
     This constraints checks if the input is a valid Canadian postal code.

zip
     This input validator checks if the input is a valid american zipcode :
     5 digits followed by an optional mailbox number.

phone
     This one checks if the input looks like a phone number, (if it
     contains at least 6 digits.)

american_phone
     This constraints checks if the number is a possible North American
     style of phone number : (XXX) XXX-XXXX. It has to contains more than
     7 digits.

cc_number
     This is takes two parameters, the credit card number and the credit
     cart type. You should take the hash reference option for using that
     constraint.

     The number is checked only for plausibility, it checks if the number
     could be valid for a type of card by checking the checksum and
     looking at the number of digits and the number of digits of the
     number.

     This functions is only good at weeding typos and such. IT DOESN'T
     CHECK IF THERE IS AN ACCOUNT ASSOCIATED WITH THE NUMBER.

cc_exp
     This one checks if the input is in the format MM/YY or MM/YYYY and if
     the MM part is a valid month (1-12) and if that date is not in the
     past.

cc_type
     This one checks if the input field starts by M(asterCard), V(isa),
     A(merican express) or D(iscovery).

CREDITS
=======

   Some of those input validation functions have been taken from MiniVend
by Michael J. Heins <mike@heins.net>

   The credit card checksum validation was taken from contribution by
Bruce Albrecht <bruce.albrecht@seag.fingerhut.com> to the MiniVend program.

AUTHOR
======

   Copyright (c) 1999 Francis J. Lacoste and iNsu Innovations Inc.  All
rights reserved.

   Parts Copyright 1996-1999 by Michael J. Heins <mike@heins.net> Parts
Copyright 1996-1999 by Bruce Albrecht  <bruce.albrecht@seag.fingerhut.com>

   This program is free software; you can redistribute it and/or modify it
under the terms as perl itself.


File: pm.info,  Node: HTML/FormatNroff,  Next: HTML/FormatNroffSub,  Prev: HTML/FormValidator,  Up: Module List

Format HTML as nroff man page
*****************************

NAME
====

   HTML::FormatNroff - Format HTML as nroff man page

SYNOPSIS
========

     require HTML::FormatNroff;
     $html = parse_htmlfile("test.html");
     $format_nroff = new HTML::FormatNroff(name => 'trial',
                                           project => 'MyProject');
     print $formatter->format($html);

DESCRIPTION
===========

   The HTML::FormatNroff is a formatter that outputs nroff source for the
nroff text processor, using man macros, and tbl commands for table
processing.

   The result of using the formatter must be processed as follows, when
directing output to the screen (assume output is in the file "text.nroff"):

     tbl -TX text.nroff | nroff -man | col

   If the output is to be printed, on an laser printer for example, a
command similar to the following must be used:

     tbl -TX text.nroff | nroff -man -Tlj | lpr

   Meta tags may be placed in the HTML so that portions of the HTML will
be ignored and not processed. Content between the tags

     <META NAME="nroff-control" CONTENT="ignore_start">
     <META NAME="nroff-control" CONTENT="ignore_end">

   will be ignored. In the BODY META is not supported, but DIV may be used
as follows:

     <DIV TYPE="NROFF_IGNORE">
     </DIV>

   In both the META and DIV uses, case is ignored.

METHODS
=======

$format_nroff->dt_start();
--------------------------

   Start a definition term <DT>, using a temporary indent and vertical
space.

$format_nroff->dd_start();
--------------------------

   Start a data definition, <DD>, using a temporary indent.

$format_nroff->configure($arg);
-------------------------------

   Configure the nroff formatter, setting the attributes passed in the
$arg attribute (hash reference)

$format_nroff->begin();
-----------------------

   Begin HTML formatting.

$format_nroff->end();
---------------------

   End HTML formatting.

$format_nroff->html_start();
----------------------------

   Process <HTML> start tag. Create the man page header based on saved
attributes, unless the attribute $format_nroff->{'man_header'} is not set.
This generates the following header:

     .TH "name" section "date" "project"

$format_nroff->font_start($font);
---------------------------------

   Start the font specified by the $font character (e.g. B, or I).  The
font is remembered so nested fonts are handled correctly.

$format_nroff->font_end();
--------------------------

   End the current font, returning to the previous one.

$format_nroff->i_start();
-------------------------

   Process <I> tag.

$format_nroff->i_end();
-----------------------

   Process </I> tag.

$format_nroff->b_start();
-------------------------

   Process <B> tag.

$format_nroff->b_end();
-----------------------

   Process </B> tag.

$format_nroff->table_start($node);
----------------------------------

   Process <TABLE>, start table processing. $node is the current
html_parser node.

     Pass on the $format_nroff->{'page_width'} to FormatTableNroff

$format_nroff->tr_start($node);
-------------------------------

   Process <TR>, add table row.

$format_nroff->tr_end();
------------------------

   End the table row </TR>

$format_nroff->a_start();
-------------------------

   <A> is ignored.

$format_nroff->a_end();
-----------------------

   </A> is ignored.

$format_nroff->td_start($node);
-------------------------------

   Process <TD>, add table cell

$format_nroff->td_end();
------------------------

   Process </TD>, end table cell

$format_nroff->th_start($node);
-------------------------------

   Process <TH>, add table header cell

$format_nroff->table_end();
---------------------------

   Process </TABLE>. Actually output entire table.

$format_nroff->p_start();
-------------------------

   Process <P>.

$format_nroff->p_end();
-----------------------

   Process </P> by doing nothing.

$format_nroff->goto_lm()
------------------------

   goto_lm does nothing.

$format_nroff->br_start();
--------------------------

   Process <BR>.

$format_nroff->hr_start();
--------------------------

   Process <HR>

$format_nroff->header_start();
------------------------------

   Process <H?> simply using .SH

$format_nroff->header_end();
----------------------------

   Process </H?> simply outputing newline

$format_nroff->out($text);
--------------------------

   Output text.

$format_nroff->pre_out($pre);
-----------------------------

   Output <PRE> text.

$format_nroff->nl($cnt);
------------------------

   Output newline.

$format_nroff->adjust_lm($indent);
----------------------------------

   adjust indent (left margin)

$format_nroff->adjust_rm();
---------------------------

   not used.

$format_nroff->bullet($tag);
----------------------------

   output the bullet, using a temporary indent and the $tag

$format_nroff->textflow($node);
-------------------------------

   Output text or add it to table if currently inside a table If centered
add .ce unless inside a table, if underlined add .ul, if the left margin
is adjusted use a .ti for every new line.

$format_nroff->blockquote_start($node);
---------------------------------------

   Start <BLOCKQUOTE>, by making a new paragraph, and indenting.

$format_nroff->blockquote_end($node);
-------------------------------------

   </BLOCKQUOTE>, by ending indent, and making a new paragraph

$format_nroff->div_start($node);
--------------------------------

   Process DIV

     <DIV TYPE="NROFF_IGNORE">
        is used to ignore all subsequent content until the next
     </DIV>

     This allows HTML to be used which is not to be converted to HTML
     (such as navigation controls). Case is ignored in the type.

   In the header you probably should use  <META NAME="nroff-control"
CONTENT="ignore_start">     is used to ignore all subsequent content until
the next  <META NAME="nroff-control" CONTENT="ignore_end">

SEE ALSO
========

   *Note HTML/Formatter: HTML/Formatter,, *Note HTML/FormatTableCell:
HTML/FormatTableCell,, *Note HTML/FormatTableCellNroff:
HTML/FormatTableCellNroff,, *Note HTML/FormatTableNroff:
HTML/FormatTableNroff,, *Note HTML/FormatTableRow: HTML/FormatTableRow,,
*Note HTML/FormatTableRowNroff: HTML/FormatTableRowNroff,

COPYRIGHT
=========

   Copyright (c) 1997 Frederick Hirsch. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Frederick Hirsch <f.hirsch@opengroup.org>


File: pm.info,  Node: HTML/FormatNroffSub,  Next: HTML/FormatPS,  Prev: HTML/FormatNroff,  Up: Module List

Test package for testing subclassing of HTML::FormatNroff
*********************************************************

NAME
====

   HTML::FormatNroffSub - Test package for testing subclassing of
HTML::FormatNroff

SYNOPSIS
========

     require HTML::FormatNroffSub;
     use HTML::Parse;
     $html = parse_html("<P><TABLE><TR><TD>1</TD></TR></TABLE>");
     $formatter = new HTML::FormatNroffSub(name => 'test',
                                           project => 'proj') ;
     print $formatter->format($html);

DESCRIPTION
===========

   This is simply a test that HTML::FormatNroff may be subclassed and will
still work.

COPYRIGHT
=========

   Copyright (c) 1997 Frederick Hirsch. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Frederick Hirsch <f.hirsch@opengroup.org>


File: pm.info,  Node: HTML/FormatPS,  Next: HTML/FormatTable,  Prev: HTML/FormatNroffSub,  Up: Module List

Format HTML as postscript
*************************

NAME
====

   HTML::FormatPS - Format HTML as postscript

SYNOPSIS
========

     require HTML::TreeBuilder;
     $tree = HTML::TreeBuilder->new->parse_file("test.html");

     require HTML::FormatPS;
     $formatter = new HTML::FormatPS
     		   FontFamily => 'Helvetica',
     		   PaperSize  => 'Letter';
     print $formatter->format($tree);

DESCRIPTION
===========

   The HTML::FormatPS is a formatter that outputs PostScript code.
Formatting of HTML tables and forms is not implemented.

   You might specify the following parameters when constructing the
formatter:

PaperSize
     What kind of paper should we format for.  The value can be one of
     these: A3, A4, A5, B4, B5, Letter, Legal, Executive, Tabloid,
     Statement, Folio, 10x14, Quarto.

     The default is "A4".

PaperWidth
     The width of the paper in points.  Setting PaperSize also defines this
     value.

PaperHeight
     The height of the paper in points.  Setting PaperSize also defines
     this value.

LeftMargin
     The left margin in points.

RightMargin
     The right margin in points.

HorizontalMargin
     Both left and right margin at the same time.  The default value is 4
     cm.

TopMargin
     The top margin in points.

BottomMargin
     The bottom margin in points.

VerticalMargin
     Both top and bottom margin at the same time.  The default value is 2
     cm.

PageNo
     The parameter determines if we should put page numbers on the pages.
     The default is yes, so you have to set this value to 0 in order to
     suppress page numbers.

FontFamily
     The parameter specifies which family of fonts to use for the
     formatting.  Legal values are "Courier", "Helvetica" and "Times".
     The default is "Times".

FontScale
     All fontsizes might be scaled by this factor.

Leading
     How much space between lines.  This is a factor of the fontsize used
     for that line.  Default is 0.1.

SEE ALSO
========

   *Note HTML/Formatter: HTML/Formatter,

COPYRIGHT
=========

   Copyright (c) 1995-1999 Gisle Aas. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Gisle Aas <gisle@aas.no>


File: pm.info,  Node: HTML/FormatTable,  Next: HTML/FormatTableCell,  Prev: HTML/FormatPS,  Up: Module List

base class for formatting HTML Tables
*************************************

NAME
====

   HTML::FormatTable - base class for formatting HTML Tables

SYNOPSIS
========

     require HTML::FormatTable;
     @ISA = qw(HTML::FormatTable);

DESCRIPTION
===========

   The HTML::FormatTable is a base class for formatting HTML tables.  It
is used by a class such as HTML::FormatTableNroff, which is called by the
formatter HTML::FormatNroff when tables are processed.

METHODS
=======

$table = new HTML::FormatTable($formatter, %attr);
--------------------------------------------------

   Create new table representation. Formatter is used to output table
(e.g. $formatter is `HTML::FormatNroff')

   Attributes include

     align: table alignment (default is 'left'),
     tab: the character used in tbl to separate table cells.
           (the default is '%', and should be a character not included
            in table text)
     page_width: the page width in inches (e.g. "6")
     width: width of table, string including the percent (eg "100%")

$table->end_row();
------------------

   End the current table row.

$table->start_data(%attr);
--------------------------

   Start new table cell.

$table->end_data();
-------------------

   End table cell.

$table->add_text($text);
------------------------

   Add text to table

$table->output();
-----------------

   Output the table - must be overridden by subclass.

SEE ALSO
========

   *Note HTML/Formatter: HTML/Formatter,, *Note HTML/FormatTableCell:
HTML/FormatTableCell,, *Note HTML/FormatTableCellNroff:
HTML/FormatTableCellNroff,, *Note HTML/FormatTableNroff:
HTML/FormatTableNroff,, *Note HTML/FormatTableRow: HTML/FormatTableRow,,
*Note HTML/FormatTableRowNroff: HTML/FormatTableRowNroff,

COPYRIGHT
=========

   Copyright (c) 1997 Frederick Hirsch. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Frederick Hirsch <f.hirsch@opengroup.org>


File: pm.info,  Node: HTML/FormatTableCell,  Next: HTML/FormatTableCellNroff,  Prev: HTML/FormatTable,  Up: Module List

Format HTML Table
*****************

NAME
====

   HTML::FormatTableCell - Format HTML Table

SYNOPSIS
========

     require HTML::FormatTableCell;
     @ISA=qw(HTML::FormatTableCell);

DESCRIPTION
===========

   The HTML::FormatTableCell is a base class used to record information
about a table entry as part of FormatTable processing. It is necessary to
record information for formatting into languages such as nroff tbl which
require formatting information ahead of the table data.

METHODS
=======

$cell = new HTML::FormatTableCellNroff(%attr);
----------------------------------------------

   Since FormatTableCell is a base class, a derived class constructor such
as `FormatTableCellNroff' in this node should be called.

   The following attributes are supported:

     header - is a header (default is '')
     	nowrap - do not wrap if defined
     	rowspan - number of rows cell spans (default is 1)
     	colspan - number of columns cell spans (default is 1)
     	align - alignment of cell contents (default is 'left')
     	valign - vertical alignment of cell (default is 'middle')
     	contents - contents of cell (default is '')

$cell->add_text($text);
-----------------------

   Add additional contents to cell.

$alignment = $cell->alignment();
--------------------------------

   Return cell alignment.

$colspan = $cell->colspan();
----------------------------

   Return cell colspan.

$text = $cell->text();
----------------------

   Return cell text.

$width = $cell->width();
------------------------

   Return cell width in characters.

SEE ALSO
========

   *Note HTML/FormatNroff: HTML/FormatNroff,, *Note
HTML/FormatTableCellNroff: HTML/FormatTableCellNroff,, *Note
HTML/FormatTableRow: HTML/FormatTableRow,, *Note HTML/FormatTableRowNroff:
HTML/FormatTableRowNroff,

COPYRIGHT
=========

   Copyright (c) 1997 Frederick Hirsch. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Frederick Hirsch <f.hirsch@opengroup.org>


File: pm.info,  Node: HTML/FormatTableCellNroff,  Next: HTML/FormatTableNroff,  Prev: HTML/FormatTableCell,  Up: Module List

Format HTML Table entry
***********************

NAME
====

   HTML::FormatTableCellNroff - Format HTML Table entry

SYNOPSIS
========

     require HTML::FormatTableCellNroff;
     $cell = new HTML::FormatTableCellNroff(%attr);

DESCRIPTION
===========

   The HTML::FormatTableCellNroff is used to record information about a
table entry and produce format information about the entry.  It is used by
FormatTableNroff to process HTML tables.

METHODS
=======

$nroff_cell->format_str($width);
--------------------------------

   Produce a tbl format specification for the current cell, consisting of
an alignment character, width (in inches), and any subsequent colspan
specifications. An example is "cw(2i)".

$nroff_cell->output($formatter);
--------------------------------

     Output a table cell entry using the formatter defined by $formatter.
     The nroff
     T{
     .ad 1
     .fi
         contents
     .nf
     }T
     construct is used to format text inside a cell. Bold is used for a table
     header.

SEE ALSO
========

   *Note HTML/FormatNroff: HTML/FormatNroff,, *Note HTML/FormatTableCell:
HTML/FormatTableCell,, *Note HTML/FormatTableRow: HTML/FormatTableRow,,
*Note HTML/FormatTableRowNroff: HTML/FormatTableRowNroff,

COPYRIGHT
=========

   Copyright (c) 1997 Frederick Hirsch. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Frederick Hirsch <f.hirsch@opengroup.org>


File: pm.info,  Node: HTML/FormatTableNroff,  Next: HTML/FormatTableRow,  Prev: HTML/FormatTableCellNroff,  Up: Module List

Format HTML Table as nroff
**************************

NAME
====

   HTML::FormatTableNroff - Format HTML Table as nroff

SYNOPSIS
========

     require HTML::FormatTableNroff;
     $table =  new HTML::FormatTableNroff($self, %attr);

DESCRIPTION
===========

   The HTML::FormatTableNroff is a formatter that outputs tbl, nroff and
man macro source for HTML tables. It is called by the HTML::FormatNroff
formatter to process HTML tables.

METHODS
=======

$width = $nroff_table->calculate_width($total, $num);
-----------------------------------------------------

   Calculate the width to use for the cell, using the following data:

     $nroff_table->{'page_width'} is the number of inches available
        on the page (6 if not set)

     $nroff_table->{'width'} specifies the percent of this available to
        the table (e.g. "75%")

     $total is calculated by determining the maximum width cell for each
     column and then adding these maximums for each column.

     $num is the maximum width cell for this column.

   The algorithm attempts to allocate the available table width (the
percentage of the page width) to the rows as the percentage the max width
of the column has with respect to the total.

   In order to make a small width column avoid unnecessary wrapping, if the
result width is less than an inch, a width corresponding to the max number
of characters is used ( aproximately the number/12 since 1em is about 12
points) (See "A TROFF tutorial", by Kernighan)

   The global HTML::FormatTableNroff::$_width_used is use to track the
amount of page width used by previous columns.

$nroff_table->attributes();
---------------------------

   Return tbl attributes associated with table itself as a string.  expand
will be specified if the table width is not explicitly specified or is not
100%. If centering is specified for the document region containing the
table, then the table will have the center attribute.

$nroff_table->output();
-----------------------

   Output the entire table, using the formatter associated with the table,
unless there is no table content - just put out a .sp in this case.

   A table is output as follows:

     .sp
     .TS
     table attributes;
     row specification
     row specification.
     row
     row
     .TE

$nroff_table->add_row(%attr);
-----------------------------

   Add a row to the table, with row attributes specified in %attr.

$nroff_table->row_iterator($method, @args);
-------------------------------------------

   Apply $method to each row of the table, passing @args, as follows:
$row->$method($last_row, @args);

   $last_row is set appropriately and used to signal to method whether
this is the last row in the table.

SEE ALSO
========

   *Note HTML/FormatNroff: HTML/FormatNroff, *Note HTML/FormatTable:
HTML/FormatTable, *Note HTML/FormatTableRow: HTML/FormatTableRow, *Note
HTML/FormatTableRowNroff: HTML/FormatTableRowNroff,

COPYRIGHT
=========

   Copyright (c) 1997 Frederick Hirsch. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Frederick Hirsch <f.hirsch@opengroup.org>


