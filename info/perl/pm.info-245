This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Module/Check_Args,  Next: Module/Reload,  Prev: Modem/Vgetty,  Up: Module List

a quick way to check argument counts for methods
************************************************

NAME
====

   Module::Check_Args - a quick way to check argument counts for methods

SYNOPSIS
========

   use Module::Check_Args;

   exact_argcount *$argcnt*;

   range_argcount *$minargs*, *$maxargs*;

   atleast_argcount *$minargs*;

   atmost_argcount *$maxargs*;

DESCRIPTION
===========

   When writing a complex program, some of the hardest problems to track
down are subroutines that aren't called with the right arguments.  Perl
provides a means to check this at compile time, but there is no way to do
this for subroutines that take a variable number of arguments or for
object methods.  `Module::Check_Args' provides routines that check the
number of arguments passed to their callers and raise an exception if the
number passed doesn't match the number expected.  It's possible to specify
that the number of arguments must be exactly n, at most n, at least n, or
between n and m.

   When using these routines from within a method, be sure to account for
the implicit first argument containing the object reference or class name!

   By default, the four _argcount routines are exported.

   By importing the following pseudo-symbols, you can request various
behaviors from `Module::Check_Args':

use Module::Check_Args qw(-die);
     Specifies that an argument count mismatch is a fatal error.  The
     message will give the file and line number of the call containing the
     bad number of arguments.  This is the default.

use Module::Check_Args qw(-warn);
     An argument mismatch is a warning only.

use Module::Check_Args qw(-off);
     No argument-count checking is performed.  The four checking routines
     are still exported, so that you don't need to change code that
     contains them, but they are dummy procedures.

   If you have multiple packages that use Module::Check_Args, each one can
have different behavior.

Routines
--------

exact_argcount *$argcnt*;
     Specifies that the caller must have exactly *$argcnt* arguments.

range_argcount *$minargs*, *$maxargs*;
     Specifies that the caller must have at least *$minargs* arguments but
     no more than *$maxargs*.

atleast_argcount *$minargs*;
     Specifies that the caller must have at least *$minargs* arguments,
     but can have any number more than that.

atmost_argcount *$maxargs*;
     Specifies that the caller must have at most *$maxargs* arguments, but
     can have any number up to that, including zero.

DIAGNOSTICS
===========

wrong argument count to Module::Check_Args::*routine*
     One of the argument count checking routines was itself called with an
     invalid argument count.  This is always a fatal error regardless of
     the behavior specified in the use declaration.

file(line): too many arguments to *routine* - was %d, should be no greater than %d
file(line): not enough arguments to *routine* - was %d, should be at least %d
file(line): wrong number of arguments to *routine* - was %d, should be between %d and %d
file(line): wrong number of arguments to *routine* - was %d, should be %d
     *routine* was called with an invalid number of arguments at the
     indicated location.  These messages are either fatal errors or
     warnings depending on the behavior specified in the use declaration.

no behavior set for Module::Check_Args - 'import' never called?
     One of the argument count check routines was called, but no behavior
     (-die, -warn) had ever been set.  This can only happen if you use
     something like the following combination of commands:

          use Module::Check_Args ();
          ...
          &Module::Check_Args::exact_argcount(3);

     Don't do that.

SEE ALSO
========

   perlfunc -f caller

AUTHOR
======

   Kevin Michael Vail <kevin@vailstar.com>


File: pm.info,  Node: Module/Reload,  Next: ModuleBundle,  Prev: Module/Check_Args,  Up: Module List

Reload %INC files when updated on disk
**************************************

NAME
====

   Module::Reload - Reload %INC files when updated on disk

SYNOPSIS
========

     Module::Reload->check;

DESCRIPTION
===========

   When Perl pulls a file via require, it stores the filename in the
global hash %INC.  The next time Perl tries to require the same file, it
sees the file in %INC and does not reload from disk.  This module's
handler iterates over %INC and reloads the file if it has changed on disk.

   Set $Module::Reload::Debug to enable debugging output.

BUGS
====

   A growing number of pragmas (base, fields, etc.) assume that they are
loaded once only.  When you reload the same file again, they tend to
become confused and break.  If you feel motivated to submit patches for
these problems, I would encourage that.

SEE ALSO
========

   Event

AUTHOR
======

   Copyright © 1997-1998 Doug MacEachern & Joshua Pritikin.  All rights
reserved.

   This package is free software and is provided "as is" without express
or implied warranty.  It may be used, redistributed and/or modified under
the terms of the Perl Artistic License (see
http://www.perl.com/perl/misc/Artistic.html)


File: pm.info,  Node: ModuleBundle,  Next: Mon/Client,  Prev: Module/Reload,  Up: Module List

Combine several other modules into one package   =head1  SYNOPSIS
*****************************************************************

NAME
====

   ModuleBundle - Combine several other modules into one package

   =head1 SYNOPSIS

   Create a package that looks like this:

     package XYZ;
     use X;
     use Y;
     use Z;
     use ModuleBundle;
     @ISA = 'ModuleBundle;
     1;

   Now if you say

     use XYZ;

   that is the same as saying

     use X;
     use Y;
     use Z;

DESCRIPTION
===========

   See the SYNOPSIS.

AUTHOR
======

   Mark-Jason Dominus (mjd-perl-bundle@plover.com)


File: pm.info,  Node: Mon/Client,  Next: Mon/Protocol,  Prev: ModuleBundle,  Up: Module List

Methods for interaction with Mon client
***************************************

NAME
====

   Mon::Client - Methods for interaction with Mon client

SYNOPSIS
========

     use Mon::Client;

DESCRIPTION
===========

     Mon::Client is used to interact with "mon" clients. It supports
     a protocol-independent API for retrieving the status of the mon
     server, and performing certain operations, such as disableing hosts
     and service checks.

METHODS
=======

new
     Creates a new object. A hash can be supplied which sets the default
     values. An example which contains all of the variables that you can
     initialize:

          $c = new Mon::Client (
          	host => "monhost",
          	port => 2583,
          	username => "foo",
          	password => "bar",
          );

password (pw)
     If *pw* is provided, sets the password. Otherwise, returns the
     currently set password.

host (host)
     If host is provided, sets the mon host. Otherwise, returns the
     currently set mon host.

port (portnum)
     If *portnum* is provided, sets the mon port number. Otherwise,
     returns the currently set port number.

username (user)
     If user is provided, sets the user login. Otherwise, returns the
     currently set user login.

prot
     If protocol is provided, sets the protocol, specified by a string
     which is of the form "1.2.3", where "1" is the major revision, "2" is
     the minor revision, and "3" is the sub-minor revision.  If protocol
     is not provided, the currently set protocol is returned.

protid ([protocol])
     Returns true if client and server protocol match, false otherwise.
     Implicitly called by connect. If protocol is specified as an integer,
     supplies that protocol version to the server for verification.

version
     Returns the protocol version of the remote server.

error
     Returns the error string from set by the last method, or undef if
     there was no error.

connected
     Returns 0 (not connected) or 1 (connected).

connect (%args)
     Connects to the server. If host and port have not been set, uses the
     defaults. Returns undef on error.  If $args{"skip_protid"} is true,
     skip protocol identification upon connect.

disconnect
     Disconnects from the server. Return undef on error.

login ( %hash )
     *%hash* is optional, but if specified, should contain two keys,
     username and password.

     Performs the "login" command to authenticate the user to the server.
     Uses username and password if specified, otherwise uses the username
     and password previously set by those methods, respectively.

checkauth ( command )
     Checks to see if the specified command, as executed by the current
     user, is authorized by the server, without actually executing the
     command.  Returns 1 (command is authorized) or 0 (command is not
     authorized).

disable_watch ( watch )
     Disables *watch*.

disable_service ( watch, service )
     Disables a service, as specified by *watch* and service.

disable_host ( host )
     Disables host.

enable_watch ( watch )
     Enables *watch*.

enable_service ( watch, service )
     Enables a service as specified by *watch* and service.

enable_host ( host )
     Enables host.

set ( group, service, var, val )
     Sets var in *group,service* to val. Returns undef on error.

get ( group, service, var )
     Gets variable var in *group,service* and returns it, or undef on
     error.

quit
     Logs out of the server. This method should be followed by a call to
     the disconnect method.

list_descriptions
     Returns a hash of service descriptions, indexed by watch and service.
     For example:

          %desc = $mon->list_descriptions;
          print "$desc{'watchname'}->{'servicename'}\n";

list_deps
     Lists dependency expressions and their components for all services.
     If there is no dependency for a particular service, then the value
     will be "NONE".

          %deps = $mon->list_deps;
          foreach $watch (keys %deps) {
          	foreach $service (keys %{$deps{$watch}}) {
          	    my $sref = \%{$deps{$watch}->{$service}};
          	    print "expr ($watch,$service) = $sref->{expression}\n";
          	    print "components ($watch,$service) = @{$sref->{components}}\n";
          	}
          }

list_group ( hostgroup )
     Lists members of *hostgroup*. Returns an array of each member.

list_watch
     Returns an array of all the defined watch groups and services.

          foreach $w ($mon->list_watch) {
          	print "group=$w->[0] service=$w->[1]\n";
          }

list_opstatus ( [group1, service1], ... )
     Returns a hash of per-service operational statuses, as indexed by
     watch and service. The list of anonymous arrays is optional, and if
     is not provided then the status of all groups and services will be
     queried.

          %s = $mon->list_opstatus;
          foreach $watch (keys %s) {
          	foreach $service (keys %{$s{$watch}}) {
          	    foreach $var (keys %{$s{$watch}{$service}}) {
          	    	print "$watch $service $var=$s{$watch}{$service}{$var}\n";
          	    }
          	}
          }

list_failures
     Returns a hash in the same manner as list_opstatus, but only the
     services which are in a failure state.

list_successes
     Returns a hash in the same manner as list_opstatus, but only the
     services which are in a success state.

list_disabled
     Returns a hash of disabled watches, services, and hosts.

          %d = $mon->list_disabled;

          foreach $group (keys %{$d{"hosts"}}) {
          	foreach $host (keys %{$d{"hosts"}{$group}}) {
          	    print "host $group/$host disabled\n";
          	}
          }

          foreach $watch (keys %{$d{"services"}}) {
          	foreach $service (keys %{$d{"services"}{$watch}}) {
          	    print "service $watch/$service disabled\n";
          	}
          }

          for (keys %{$d{"watches"}}) {
          	print "watch $_ disabled\n";
          }

list_alerthist
     Returns an array of hash references containing the alert history.

          @a = $mon->list_alerthist;

          for (@a) {
          	print join (" ",
          	    $_->{"type"},
          	    $_->{"watch"},
          	    $_->{"service"},
          	    $_->{"time"},
          	    $_->{"alert"},
          	    $_->{"args"},
          	    $_->{"summary"},
          	    "\n",
          	);
          }

list_dtlog
     Returns an array of hash references containing the downtime log.

     @a = $mon->list_dtlog

          for (@a) {
            print join (" ",
                $_->{"timeup"},
                $_->{"group"},
                $_->{"service"},
                $_->{"failtime"},
                $_->{"downtime"},
                $_->{"interval"},
                $_->{"summary"},
                "\n",
            );
          }

list_failurehist
     Returns an array of hash references containing the failure history.

          @f = $mon->list_failurehist;

          for (@f) {
          	print join (" ",
          	    $_->{"watch"},
          	    $_->{"service"},
          	    $_->{"time"},
          	    $_->{"summary"},
          	    "\n",
          	);
          }

list_pids
     Returns an array of hash references containing the list of process IDs
     of currently active monitors run by the server.

          @p = $mon->list_pids;

          $server = shift @p;

          for (@p) {
          	print join (" ",
          	    $_->{"watch"},
          	    $_->{"service"},
          	    $_->{"pid"},
          	    "\n",
          	);
          }

list_state
     Lists the state of the scheduler. Returns a two-element array. The
     first element of the array is 0 if the scheduler is stopped, and 1 if
     the scheduler is currently running. The second element of the array
     returned is the string "scheduler running" if the scheduler is
     currently running, and if the scheduler is stopped, the second
     element is the time(2) that the scheduler was stopped.

          @s = $mon->list_state;

          if ($s[0] == 0) {
          	print "scheduler stopped since " . localtime ($s[1]) . "\n";
          }

start
     Starts the scheduler.

stop
     Stops the scheduler.

reset
     Resets the server.

reload ( what )
     Causes the server to reload its configuration. *what* is an optional
     argument, and currently the only supported option is auth, which
     reloads the authorization file.

term
     Terminates the server.

set_maxkeep
     Sets the maximum number of history entries to store in memory.

get_maxkeep
     Returns the maximum number of history entries to store in memory.

test ( test, group, service [, exitval, period])
     Schedules a service test to run immediately, or tests an alert for a
     given period. test must be *monitor*, alert, *startupalert*, or
     *upalert*. To test alerts, the *exitval* and period must be supplied.
     Periods are identified by their label in the mon config file. If there
     are no period tags, then the actual period string must be used,
     exactly as it is listed in the config file.

test_config
     Tests the syntax of the configuration file. Returns a two-element
     array. The first element of the array is 0 if the syntax of the
     config file is invalid, and 1 if the syntax of the config file is OK.
     The second element of the array returned is the failure message, if
     the config file has invalid syntax, and the result code if the config
     file syntax is OK. This function returns undef if it cannot get a
     connection or a response from the mon server.

     Config file checking stops as soon as an error is found, so you will
     need to run this command more than once if you have multiple errors
     in your config file in order to find them all.

          @s = $mon->test_config;

          if ($s[0] == 0) {
              print "error in config file:\n" . $s[1] . "\n";
          }

ack ( group, service, text )
     When *group/service* is in a failure state, acknowledges this with
     text, and disables all further alerts during this failure period.

loadstate ( state )
     Loads state.

savestate ( state )
     Saves state.

servertime
     Returns the time on the server using the same output as the time(2)
     system call.

send_trap ( %vars )
     Sends a trap to a remote mon server. Here is an example:

          $mon->send_trap (
          	group		=> "remote-group",
          	service		=> "remote-service",
          	retval		=> 1,
          	opstatus	=> "operational status",
          	summary		=> "summary line",
          	detail		=> "multi-line detailed information",
          );

     *retval* must be a nonnegative integer.

     *opstatus* must be one of fail, ok, *coldstart*, *warmstart*,
     *linkdown*, *unknown*, timeout,  *untested*.

     Returns undef on error.


File: pm.info,  Node: Mon/Protocol,  Next: Mon/SNMP,  Prev: Mon/Client,  Up: Module List

Methods for parsing / dumping a protocol block
**********************************************

NAME
====

   Mon::Protocol - Methods for parsing / dumping a protocol block

SYNOPSIS
========

     use Mon::Protocol;

DESCRIPTION
===========

METHODS
=======

new
     Creates a new object. A hash can be supplied which sets the default
     values. An example which contains all of the variables that you can
     initialize:

          $c = new Mon::Protocol;

dump_data
     Returns the current internal structure as a string dump suitable for
     passing to parse_data.

parse_data
     Parses a command block (from begin_block to end_block), as generated
     by dump_data.

type(*new_type*)
     Sets or returns the type of the current command block. See @TYPES for
     valid type codes.

     In the future, it is possible that this module will perform additional
     checking based on the type, for now it is left to the application to
     interpret this.

`get_section_list'
     Returns an array containing all section names within the block.

`get_section'(*section_name*)
     Returns a hash containing the key/value pairs of the specific section.

`delete_section'(*section_name*)
     Completely removes the specified section from the block.

`add_to_section'(*section_name*,*$hash_ref*)
     Adds the key/value pairs in the hash to the specified section.

          $foo->add_to_section("_hostgroup", { "ns1.baz.com" -> "ok" });

`delete_from_section'(*section_name*,$key)
     Deletes the key/value pair from the section.

          $foo->delete_from_section("_hostgroup", "ns1.baz.com");

error
     Should any of the functions return an error (-1), this function can
     be used to retrieve a more elaborate error message and to reset the
     internal error state.


File: pm.info,  Node: Mon/SNMP,  Next: Morse,  Prev: Mon/Protocol,  Up: Module List

decode SNMP trap
****************

NAME
====

   Mon::SNMP - decode SNMP trap

SYNOPSIS
========

     use Mon::SNMP;

     $trap = new Mon::SNMP;

     $trap->buffer($snmptrap);

     %traphash = $trap->decode;

     $error = $trap->error;

DESCRIPTION
===========

   Mon::SNMP provides methods to decode SNMP trap PDUs. It is based on
Graham Barr's Convert::BER module, and its purpose is to provide SNMP trap
handling to "mon".

METHODS
=======

new
     creates a new Mon::SNMP object.

buffer ( buffer )
     Assigns a raw SNMP trap message to the object.

decode
     Decodes a SNMP trap message, and returns a hash of the variable
     assignments for the SNMP header and trap protocol data unit of the
     associated message. The hash consists of the following members:

          version         =>      SNMP version (1)
          community       =>      community string
          ent_OID         =>      enterprise OID of originating agent
          agentaddr       =>      IP address of originating agent
          generic_trap    =>      /COLDSTART|WARMSTART|LINKDOWN|LINKUP|AUTHFAIL|EGPNEIGHBORLOSS|ENTERPRISESPECIFIC/
          specific_trap   =>      specific trap type (integer)
          timeticks       =>      timeticks (integer)
          varbindlist     =>      { oid1 => value, oid2 => value, ... }

ERRORS
======

   All methods return a hash with no elements upon errors which they
detect, and the detail of the error is available from the

EXAMPLES
========

     use Mon::SNMP;

     $trap = new Mon::SNMP;

     $trap->buffer($snmptrap);

     %traphash = $trap->decode;

     foreach $oid (keys $traphash{"varbindlist"}) {
     	$val = $traphash{"varbindlist"}{$oid};
     	print "oid($oid) = val($val)\n";
     }

ENVIRONMENT
===========

   None.

SEE ALSO
========

   Graham Barr's Convert::BER module.

NOTES
=====

CAVEATS
=======

   Mon::SNMP depends upon Convert::BER to do the real work.


File: pm.info,  Node: Morse,  Next: Mortal/Kombat,  Prev: Mon/SNMP,  Up: Module List

SYNOPSIS
========

     use Morse;

     print "S-O-S\n";

DESCRIPTION
===========

   The first time you run a program under `use Morse', the module converts
your program to Morse code. The code continues to work exactly as it did
before, but now it looks like this:

     use Morse;
     	.--.-..--..---.-.--..--.-..--..---.-.--.
     	.-.-........---..-..---.-..-.--..---.--.
     	..-.---......-...-...-..--..-.-.-.--.-..
     	----..-.-.--.-..--..-.-...---.-..---.--.
     	.-...-..--.---...-.-....

DIAGNOSTICS
===========

`Can't encode '%s''
     Morse could not access the source file to modify it.

`Can't transmit '%s''
     Morse could not access the source file to execute it.

AUTHOR
======

   Damian Conway (as if you couldn't guess)

COPYRIGHT
=========

     Copyright (c) 2001, Damian Conway. All Rights Reserved.
      This module is free software. It may be used, redistributed
     and/or modified under the terms of the Perl Artistic License
       (see http://www.perl.com/perl/misc/Artistic.html)


File: pm.info,  Node: Mortal/Kombat,  Next: Msql,  Prev: Morse,  Up: Module List

Mortal Kombat program termination
*********************************

NAME
====

   Mortal::Kombat - Mortal Kombat program termination

SYNOPSIS
========

     use Mortal::Kombat;
     # ...
     # exit successfully
     flawless victory;

     use Mortal::Kombat;
     $screwedup and fatality "Scorpion has whomped you,";

DESCRIPTION
===========

   This is a gimmick module.  It merely gives you three functions,
flawless(), victory(), and fatality(), each of which can be used without
parentheses for a nice english look.

   The suggested uses are:

     flawless victory;  # same as 'exit 0'

   and

     fatality "some error message";  # same as die "some error message";

   That's it.  If you've got any suggestions, you can email me.  Don't be
ashamed.

AUTHOR
======

     Jeff "japhy" Pinyan
     CPAN ID: PINYAN
     japhy@pobox.com
     http://www.pobox.com/~japhy/


File: pm.info,  Node: Msql,  Next: Msql/RDBMS,  Prev: Mortal/Kombat,  Up: Module List

Perl interfaces to the mSQL and mysql databases
***********************************************

NAME
====

   Msql / Mysql - Perl interfaces to the mSQL and mysql databases

SYNOPSIS
========

     use Msql;
     
     $dbh = Msql->connect;
     $dbh = Msql->connect($host);
     $dbh = Msql->connect($host, $database);

     or

     use Mysql;

     $dbh = Mysql->connect(undef, $database, $user, $password);
     $dbh = Mysql->connect($host, $database, $user, $password);
     
     $dbh->selectdb($database);
     
     @arr = $dbh->listdbs;
     @arr = $dbh->listtables;
     
     $quoted_string = $dbh->quote($unquoted_string);
     $error_message = $dbh->errmsg;
     $error_number = $dbh->errno;   # MySQL only

     $sth = $dbh->listfields($table);
     $sth = $dbh->query($sql_statement);
     
     @arr = $sth->fetchrow;
     @arr = $sth->fetchcol($col_number);
     %hash = $sth->fetchhash;
     
     $sth->dataseek($row_number);

     $sth->as_string;

     @indices = $sth->listindices                   # only in mSQL 2.0
     @arr = $dbh->listindex($table,$index)          # only in mSQL 2.0
     ($step,$value) = $dbh->getsequenceinfo($table) # only in mSQL 2.0

     $rc = $dbh->shutdown();
     $rc = $dbh->createdb($database);
     $rc = $dbh->dropdb($database);

DESCRIPTION
===========

   This package is designed as close as possible to its C API counterpart.
The manual that comes with mSQL or MySQL describes most things you need.
Due to popular demand it was decided though, that this interface does not
use StudlyCaps (see below).

   The version you have selected is an adaption still under development,
please consult the file "Changes" in your distribution.

   Internally you are dealing with the two classes `Msql' and
`Msql::Statement' or `Mysql' and `Mysql::Statement', respectively.  You
will never see the latter, because you reach it through a statement handle
returned by a query or a listfields statement. The only class you name
explicitly is Msql or Mysql. They offer you the connect command:

     $dbh = Msql->connect;
     $dbh = Msql->connect($host);
     $dbh = Msql->connect($host, $database);

     or

     $dbh = Mysql->connect(undef, undef, $user, $password);
     $dbh = Mysql->connect($host, undef, $user, $password);
     $dbh = Mysql->connect($host, $database, $user, $password);

   This connects you with the desired host/database. With no argument or
with an empty string as the first argument it connects to the UNIX socket,
which has a much better performance than the TCP counterpart. A database
name as the second argument selects the chosen database within the
connection. The return value is a database handle if the connect succeeds,
otherwise the return value is undef.

   You will need this handle to gain further access to the database.

     $dbh->selectdb($database);

   If you have not chosen a database with the connect command, or if you
want to change the connection to a different database using a database
handle you have got from a previous connect, then use selectdb.

     $sth = $dbh->listfields($table);
     $sth = $dbh->query($sql_statement);

   These two work rather similar as descibed in the mSQL or MySQL manual.
They return a statement handle which lets you further explore what the
server has to tell you. On error the return value is undef. The object
returned by listfields will not know about the size of the table, so a
numrows() on it will return the string "N/A";

     @arr = $dbh->listdbs();
     @arr = $dbh->listtables;

   An array is returned that contains the requested names without any
further information.

     @arr = $sth->fetchrow;

   returns an array of the values of the next row fetched from the server.
Similar does

     %hash = $sth->fetchhash;

   return a complete hash. The keys in this hash are the column names of
the table, the values are the table values. Be aware, that when you have a
table with two identical column names, you will not be able to use this
method without trashing one column. In such a case, you should use the
fetchrow method.

     @arr = $sth->fetchcol($colnum);

   returns an array of the values of each row for column $colnum.  Note
that this reads the entire table and leaves the row offset at the end of
the table; be sure to use $sth->dataseek() to reset it if you want to
re-examine the table.

     $sth->dataseek($row_number);

   lets you specify a certain offset of the data associated with the
statement handle. The next fetchrow will then return the appropriate row
(first row being 0).

No close statement
------------------

   Whenever the scalar that holds a database or statement handle loses its
value, Msql chooses the appropriate action (frees the result or closes the
database connection). So if you want to free the result or close the
connection, choose to do one of the following:

undef the handle
use the handle for another purpose
let the handle run out of scope
exit the program.
Error messages
--------------

   Both drivers, Msql and Mysql implement a method ->errmsg(), which
returns a textual error message. Mysql additionally supports a method
->errno returning the corresponding error number. Note that Msql's errmsg
is a static method, thus it is legal to fetch

     Msql->errmsg();

   Mysql doesn't support this, fetching the error message is only valid via

     $dbh->errmsg();

   I recommend, that even Msql users restrict themselves to the latter for
portability reasons. There are also global variables $Msql::db_errstr and
$Mysql::db_errstr, which always hold the last error message. The former is
reset with the next executed command, the latter not. Usually there's no
need for accessing the global variables, with one exception: If the
connect method fails, you need them.

The -w switch
-------------

   With Msql and Mysql the -w switch is your friend! If you call your perl
program with the -w switch you get the warnings from ->errmsg on STDERR.
This is a handy method to get the error messages from the msql server
without coding it into your program.

   If you want to know in greater detail what's going on, set the
environment variables that are described in David's manual. David's
debugging aid is excellent, there's nothing to be added.

   If you want to use the -w switch but do not want to see the error
messages from the msql daemon, you can set the variables $Msql::QUIET or
$Mysql::QUIET to some true value, and they will be supressed.

->quote($str [, $length])
-------------------------

   returns the argument enclosed in single ticks (") with any special
character escaped according to the needs of the API.

   For mSQL this means, any single tick within the string is escaped with
a backslash and backslashes are doubled. Currently (as of msql-1.0.16) the
API does not allow to insert NUL's (ASCII 0) into tables. The quote method
does not fix this deficiency.

   MySQL allows NUL's or any other kind of binary data in strings. Thus
the quote method will additionally escape NUL's as \0.

   If you pass undefined values to the quote method, it returns the string
NULL.

   If a second parameter is passed to quote, the result is truncated to
that many characters.

NULL fields
-----------

   NULL fields in tables are returned to perl as undefined values.

Metadata
--------

   Now lets reconsider the above methods with regard to metadata.

Database Handle
---------------

   As said above you get a database handle with

     $dbh = Msql->connect($host, $database);

     or

     $dbh = Mysql->connect($host, $database);

   The database handle knows about the socket, the host, and the database
it is connected to.

   You get at the three values with the methods

     $scalar = $dbh->sock;
     $scalar = $dbh->host;
     $scalar = $dbh->database;

   Mysql additionally supports

     $scalar = $dbh->user;
     $scalar = $dbh->sockfd;

   where the latter is the file descriptor of the socket used by the
database connection. This is the same as $dbh->sock for mSQL.

Statement Handle
----------------

   Two constructor methods return a statement handle:

     $sth = $dbh->listfields($table);
     $sth = $dbh->query($sql_statement);

   $sth knows about all metadata that are provided by the API:

     $scalar = $sth->numrows;
     $scalar = $sth->numfields;

     @arr  = $sth->table;       the names of the tables of each column
     @arr  = $sth->name;        the names of the columns
     @arr  = $sth->type;        the type of each column, defined in msql.h
     	                     and accessible via Msql::CHAR_TYPE,
     	                     &Msql::INT_TYPE, &Msql::REAL_TYPE or
                                &Mysql::FIELD_TYPE_STRING,
                                &Mysql::FIELD_TYPE_LONG, ...
     @arr  = $sth->isnotnull;   array of boolean
     @arr  = $sth->isprikey;    array of boolean
     @arr  = $sth->isnum;       array of boolean
     @arr  = $sth->length;      array of the possibble maximum length of each
                                field in bytes
     @arr  = $sth->maxlength;   array of the actual maximum length of each field
                                in bytes. Be careful when using this attribute
                                under MsqlPerl: The server doesn't offer this
                                attribute, thus it is calculated by fetching
                                all rows. This might take a long time and you
                                might need to call $sth->dataseek.

   Mysql additionally supports

     $scalar  = $sth->affectedrows  number of rows in database affected by query
     $scalar  = $sth->insertid      the unique id given to a auto_increment field.
     $string  = $sth->info()        more info from some queries (ALTER TABLE...)
     $arrref  = $sth->isblob;       array of boolean

   The array methods (table, name, type, is_not_null, is_pri_key, length,
affected_rows, is_num and blob) return an array in array context and an
array reference (see *Note Perlref: (perl.info)perlref, and `perlldsc' in
this node for details) when called in a scalar context. The scalar context
is useful, if you need only the name of one column, e.g.

     $name_of_third_column = $sth->name->[2]

   which is equivalent to

     @all_column_names = $sth->name;
     $name_of_third_column = $all_column_names[2];

New in mSQL 2.0
---------------

   The query() function in the API returns the number of rows affected by
a query. To cite the mSQL API manual, this means...

     If the return code is greater than 0, not only does it imply
     success, it also indicates the number of rows "touched" by the query
     (i.e. the number of rows returned by a SELECT, the number of rows
     modified by an update, or the number of rows removed by a delete).

   As we are returning a statement handle on selects, we can easily check
the number of rows returned. For non-selects we behave just the same as
mSQL-2.

   To find all indices associated with a table you can call the
`listindices()' method on a statement handle. To find out the columns
included in an index, you can call the `listindex($table,$index)' method
on a database handle.

   There are a few new column types in mSQL 2. You can access their
numeric value with these functions defined in the Msql package:
IDENT_TYPE, NULL_TYPE, TEXT_TYPE, DATE_TYPE, UINT_TYPE, MONEY_TYPE,
TIME_TYPE, IDX_TYPE, SYSVAR_TYPE.

   You cannot talk to a 1.0 server with a 2.0 client.

   You cannot link to a 1.0 library and to a 2.0 library *at the same
time*. So you may want to build two different Msql modules at a time, one
for 1.0, another for 2.0, and load whichever you need. Check out what the
-I switch in perl is for.

   Everything else seems to remain backwards compatible.

@EXPORT
-------

   For historical reasons the constants CHAR_TYPE, INT_TYPE, and REAL_TYPE
are in @EXPORT instead of @EXPORT_OK. This means, that you always have
them imported into your namespace. I consider it a bug, but not such a
serious one, that I intend to break old programs by moving them into
EXPORT_OK.

Displaying whole tables in one go
---------------------------------

   A handy method to show the complete contents of a statement handle is
the as_string method. This works similar to the msql monitor with a few
exceptions:

the width of a column
     is calculated by examining the width of all entries in that column

control characters
     are mapped into their backslashed octal representation

backslashes
     are doubled (`\\ instead of \')

numeric values
     are adjusted right (both integer and floating point values)

   The differences are illustrated by the following table:

   Input to msql (a real carriage return here replaced with ^M):

     CREATE TABLE demo (
       first_field CHAR(10),
       second_field INT
     ) \g

     INSERT INTO demo VALUES ('new
     line',2)\g
     INSERT INTO demo VALUES ('back\\slash',1)\g
     INSERT INTO demo VALUES ('cr^Mcrnl
     nl',3)\g

   Output of msql:

     +-------------+--------------+
     | first_field | second_field |
     +-------------+--------------+
     | new
         line    | 2            |
     | back\slash  | 1            |
         crnlr
         nl  | 3            |
     +-------------+--------------+

   Output of pmsql:

     +----------------+------------+
     |first_field     |second_field|
     +----------------+------------+
     |new\012line     |           2|
     |back\\slash     |           1|
     |cr\015crnl\012nl|           3|
     +----------------+------------+

Version information
-------------------

   The version of Msql and Mysql is always stored in $Msql::VERSION or
$Mysql::VERSION as it is perl standard.

   The mSQL API implements methods to access some internal configuration
parameters: gethostinfo, getserverinfo, and getprotoinfo.  All three are
available both as class methods or via a database handle. But under no
circumstances they are associated with a database handle. All three return
global variables that reflect the last connect() command within the
current program. This means, that all three return empty strings or zero
before the first call to connect().

   This situation is better with MySQL: The methods are valid only in
connection with a database handle.

Administration
--------------

   shutdown, createdb, dropdb, reloadacls are all accessible via a
database handle and implement the corresponding methods to what msqladmin
does.

   The mSQL and MySQL engines do not permit that these commands are
invoked by users without sufficient privileges. So please make sure to
check the return and error code when you issue one of them.

     $rc = $dbh->shutdown();
     $rc = $dbh->createdb($database);
     $rc = $dbh->dropdb($database);

   It should be noted that database deletion is *not prompted for* in any
way. Nor is it undo-able from within Perl.

     B<Once you issue the dropdb() method, the database will be gone!>

   These methods should be used at your own risk.

StudlyCaps
----------

   Real Perl Programmers (C) usually don't like to type ListTables but
prefer list_tables or *listtables*. The mSQL API uses StudlyCaps
everywhere and so did early versions of MsqlPerl. Beginning with $VERSION
1.06 all methods are internally in lowercase, but may be written however
you please. Case is ignored and you may use the underline to improve
readability.

   The price for using different method names is neglectible. Any method
name you use that can be transformed into a known one, will only be
defined once within a program and will remain an alias until the program
terminates. So feel free to run fetch_row or connecT or ListDBs as in your
old programs. These, of course, will continue to work.

PREREQUISITES
=============

   mSQL is a database server and an API library written by David Hughes.
To use the adaptor you definitely have to install these first.

   MySQL is a libmysqlclient.a library written by Michael Widenius This
was originally inspired by MySQL.

AUTHOR
======

   andreas koenig `koenig@franz.ww.TU-Berlin.DE'

SEE ALSO
========

   Alligator Descartes wrote a database driver for Tim Bunce's DBI. I
recommend anybody to carefully watch the development of this module
(`DBD::mSQL'). Msql is a simple, stable, and fast module, and it will be
supported for a long time. But it's a dead end. I expect in the medium
term, that the DBI efforts result in a richer module family with better
support and more functionality. Alligator maintains an interesting page on
the DBI development: http://www.arcana.co.uk/technologia/perl/DBI


File: pm.info,  Node: Msql/RDBMS,  Next: MySQL/GUI,  Prev: Msql,  Up: Module List

Relational Database Management System for Msql
**********************************************

NAME
====

   *Msql::RDBMS* - Relational Database Management System for Msql

SYNOPSIS
========

     use Msql::RDBMS;

     $rdbms = new Msql::RDBMS;
     $rdbms->show;

DESCRIPTION
===========

   This is a fully catalog driven database management system for Perl 5
and mini-SQL. You should use it in conjunction with the sqldef.pl script
which will generate data definition language for your tables.

GENERATING DATA DEFINITION LANGUAGE
===================================

   You must pass the name of a schema definition file to sqldef.pl (an
example, *schema.def*, is included in the examples/ subdirectory of the
distribution).  See `sqldef.pl' in this node.

USAGE
=====

   You can call up the entire Relational Database Management System from
your browser with a URL like this:

     http://bozos.on.the.bus/sample.cgi?db=demo

   Where *sample.cgi* is a Perl script containing the three lines of code
shown in SYNOPSIS.

DEBUGGING
=========

   You can get some debugging information, which consists of a CGI::dump,
and an SQL statement, if relevant, by including debug=1 in the URL.

TODO
====

     Generate forms for interactive data definition.
     Enforce referential integrity (cascade/block deletes).
     * Enforce uniqueness for label columns.
     * Add fancy display options that support automagic hyperlinking of
        URLs and email addresses.

   * denotes feature present in the original PHP/FI version.

AUTHOR
======

   Brian Jepson <bjepson@conan.ids.net>

   Paul Sharpe <paul@miraclefish.com>

   You may distribute this under the same terms as Perl itself.

SEE ALSO
========

   `sqldef.pl' in this node

   CGI::CGI, CGI::Carp, Msql

error()
     The error handling method will handle errors in two ways.  The first
     is to pass it no values whatsoever; it will check the mini-SQL
     connection for errors, and register any error that is found with the
     list of errors for this form. The second way to use this is to pass
     in a user-defined error, which will be registered in the list of
     errors, but this will not check the mini-SQL connection for errors.
     This is a good method to invoke after any SQL call; it returns true
     if there was an error, and all errors will get displayed when you
     invoke display_page().

errors()
     This method displays all of the errors in the list of errors. Each
     error is displayed in a threatening red color. This is normally
     called by display_page(), but if you want to annoy your users, you
     should call it as often as possible.

printbuff()
     Adds some text to the HTML buffer.


File: pm.info,  Node: MySQL/GUI,  Next: MySQL/GUI/connection,  Prev: Msql/RDBMS,  Up: Module List

MySQL::GUI     makes windows for connecting to and interacting with databases.
******************************************************************************

NAME
====

   MySQL::GUI     makes windows for connecting to and interacting with
databases.

SYNOPSIS
========

     use MySQL::GUI;

     my $gui = new MySQL::GUI;

     $gui->go;

AUTHOR
======

   Jettero Heller jettero@cpan.org

   http://www.voltar.org

SEE ALSO
========

   perl(1), MySQL::GUI(3), MySQL::GUI::connector(3),
MySQL::GUI::connector::dbase(3), MySQL::GUI::connection(3).


File: pm.info,  Node: MySQL/GUI/connection,  Next: MySQL/GUI/connector,  Prev: MySQL/GUI,  Up: Module List

MySQL::GUI::connection   a window for interacting with the database.
********************************************************************

NAME
====

   MySQL::GUI::connection   a window for interacting with the database.

SYNOPSIS
========

     use strict;
     use MySQL::GUI::connector;
     use MySQL::GUI::connection;

     my $connector = new MySQL::GUI::connector;
     my $c;

     $connector->set_callback( \&connected_callback );

     show $connector;

     sub connected_callback {
         my $dbo = shift;

     if($dbo) {
         $connector->print("I got connected!", 2);
         $c = new MySQL::GUI::connection($dbo);
     }
       }

     sub submit_callback {
         my $dbqt = shift; # passed in by the callback
         # short for database query text

     if($dbqt =~ /^(select|show|desc)/i) {
         my $q  = $c->ready($dbqt); $q->execute or return;
         my $hr = $q->fetchrow_hashref;

     return if not $hr;

     $c->set_field_names( keys %$hr );
     $c->freeze;  # puts the CList on hold
                  # so it doesn't blink during the updates.

     my @row;
     my $max_rows = 50;
     {
         foreach(@row) {
             $_ = defined($_) ? $_ : "NULL";
             s/^\s*//;
             s/\s*$//;
         }
         $c->populate_table_row( values %$hr );
         $max_rows--;

     last if not $max_rows;
     redo if $hr = $q->fetchrow_hashref;
               }
               $c->thaw;
               $c->set_field_widths( (map 10*length($_), (keys %$hr)) );

     $c->store_query;
     $c->clear_query;

     my $paren="";
     if(not $max_rows) {
         $paren = " (truncated to $ROW_LIM rows)";
     }

     $c->print("found " . $q->rows . " rows$paren... " . (time - $t) , 10);
           } else {
     $c->print("unsupported query type", 4);
           }
       }

AUTHOR
======

     Jettero Heller <jettero@voltar.org>

SEE ALSO
========

   perl(1), MySQL::GUI(3), MySQL::GUI::connector(3),
MySQL::GUI::connector::dbase(3), MySQL::GUI::connection(3).


File: pm.info,  Node: MySQL/GUI/connector,  Next: MySQL/GUI/connector/dbase,  Prev: MySQL/GUI/connection,  Up: Module List

MySQL::GUI::connector   a window for connecting to databases.
*************************************************************

NAME
====

   MySQL::GUI::connector   a window for connecting to databases.

SYNOPSIS
========

     use strict;
     use MySQL::GUI::connector;

     my $connector = new MySQL::GUI::connector;

     $connector->set_callback( \&connected_callback );

     show $connector;

     sub connected_callback {
         my $dbo = shift;
         my $tsp = 2; # two second pause

     $connector->print("I got connected!", $tsp) if $dbo;
       }

     $connector->exit;

AUTHOR
======

     Jettero Heller <jettero@voltar.org>

SEE ALSO
========

   perl(1), MySQL::GUI(3), MySQL::GUI::connector(3),
MySQL::GUI::connector::dbase(3), MySQL::GUI::connection(3).


File: pm.info,  Node: MySQL/GUI/connector/dbase,  Next: Mysql,  Prev: MySQL/GUI/connector,  Up: Module List

Perl extension    to make the db stuff a little less painless.
**************************************************************

NAME
====

   MySQL::GUI::connector::dbase - Perl extension   to make the db stuff a
little less painless.

SYNOPSIS
========

     use strict;
     use MySQL::GUI::connector::dbase;

     # to do db transactions
     my $dbo = new MySQL::GUI::connector::dbase;
     my $dbh = $dbo->handle;
     my $sth = $dbh->prepare("select * from something");
     my $STH = $dbo->ready("select * from something"); # shortcut. ;)

     # the dbase.pm uses the .my.cnf to be able to connect pretty like that...
     # you can override it.  After the $dbo is connected this will
     # not do anything!  Note that there is no connect function.

     $dbo->disconnect;

     $dbo->set_db(   "cool_db"   );
     $dbo->set_host( "localhost" );
     $dbo->set_user( "jettero"   );
     $dbo->set_pass( "S3crET"    );

     my $sth =
         $dbo->ready("select * from cool_table");  # this connects automajikcally;
                                               # so does the $dbo->handle function.

     $dbo->trace( 1 ); # will do what you expect before/after connect,
                       # and will persist even after a $dbo->disconnect.

     # to read a .my.cnf
     my $temp = new MySQL::GUI::connector::dbase;
     my ($u, $p, $d, $h) = $temp->get_defaults;
     undef $temp;

AUTHOR
======

     Jettero Heller <jettero@voltar.org>

SEE ALSO
========

   perl(1), MySQL::GUI(3), MySQL::GUI::connector(3),
MySQL::GUI::connector::dbase(3), MySQL::GUI::connection(3).


File: pm.info,  Node: Mysql,  Next: NDBM_File,  Prev: MySQL/GUI/connector/dbase,  Up: Module List

Perl interfaces to the mSQL and mysql databases
***********************************************

NAME
====

   Msql / Mysql - Perl interfaces to the mSQL and mysql databases

SYNOPSIS
========

     use Msql;
     
     $dbh = Msql->connect;
     $dbh = Msql->connect($host);
     $dbh = Msql->connect($host, $database);

     or

     use Mysql;

     $dbh = Mysql->connect(undef, $database, $user, $password);
     $dbh = Mysql->connect($host, $database, $user, $password);
     
     $dbh->selectdb($database);
     
     @arr = $dbh->listdbs;
     @arr = $dbh->listtables;
     
     $quoted_string = $dbh->quote($unquoted_string);
     $error_message = $dbh->errmsg;
     $error_number = $dbh->errno;   # MySQL only

     $sth = $dbh->listfields($table);
     $sth = $dbh->query($sql_statement);
     
     @arr = $sth->fetchrow;
     @arr = $sth->fetchcol($col_number);
     %hash = $sth->fetchhash;
     
     $sth->dataseek($row_number);

     $sth->as_string;

     @indices = $sth->listindices                   # only in mSQL 2.0
     @arr = $dbh->listindex($table,$index)          # only in mSQL 2.0
     ($step,$value) = $dbh->getsequenceinfo($table) # only in mSQL 2.0

     $rc = $dbh->shutdown();
     $rc = $dbh->createdb($database);
     $rc = $dbh->dropdb($database);

DESCRIPTION
===========

   This package is designed as close as possible to its C API counterpart.
The manual that comes with mSQL or MySQL describes most things you need.
Due to popular demand it was decided though, that this interface does not
use StudlyCaps (see below).

   The version you have selected is an adaption still under development,
please consult the file "Changes" in your distribution.

   Internally you are dealing with the two classes `Msql' and
`Msql::Statement' or `Mysql' and `Mysql::Statement', respectively.  You
will never see the latter, because you reach it through a statement handle
returned by a query or a listfields statement. The only class you name
explicitly is Msql or Mysql. They offer you the connect command:

     $dbh = Msql->connect;
     $dbh = Msql->connect($host);
     $dbh = Msql->connect($host, $database);

     or

     $dbh = Mysql->connect(undef, undef, $user, $password);
     $dbh = Mysql->connect($host, undef, $user, $password);
     $dbh = Mysql->connect($host, $database, $user, $password);

   This connects you with the desired host/database. With no argument or
with an empty string as the first argument it connects to the UNIX socket,
which has a much better performance than the TCP counterpart. A database
name as the second argument selects the chosen database within the
connection. The return value is a database handle if the connect succeeds,
otherwise the return value is undef.

   You will need this handle to gain further access to the database.

     $dbh->selectdb($database);

   If you have not chosen a database with the connect command, or if you
want to change the connection to a different database using a database
handle you have got from a previous connect, then use selectdb.

     $sth = $dbh->listfields($table);
     $sth = $dbh->query($sql_statement);

   These two work rather similar as descibed in the mSQL or MySQL manual.
They return a statement handle which lets you further explore what the
server has to tell you. On error the return value is undef. The object
returned by listfields will not know about the size of the table, so a
numrows() on it will return the string "N/A";

     @arr = $dbh->listdbs();
     @arr = $dbh->listtables;

   An array is returned that contains the requested names without any
further information.

     @arr = $sth->fetchrow;

   returns an array of the values of the next row fetched from the server.
Similar does

     %hash = $sth->fetchhash;

   return a complete hash. The keys in this hash are the column names of
the table, the values are the table values. Be aware, that when you have a
table with two identical column names, you will not be able to use this
method without trashing one column. In such a case, you should use the
fetchrow method.

     @arr = $sth->fetchcol($colnum);

   returns an array of the values of each row for column $colnum.  Note
that this reads the entire table and leaves the row offset at the end of
the table; be sure to use $sth->dataseek() to reset it if you want to
re-examine the table.

     $sth->dataseek($row_number);

   lets you specify a certain offset of the data associated with the
statement handle. The next fetchrow will then return the appropriate row
(first row being 0).

No close statement
------------------

   Whenever the scalar that holds a database or statement handle loses its
value, Msql chooses the appropriate action (frees the result or closes the
database connection). So if you want to free the result or close the
connection, choose to do one of the following:

undef the handle
use the handle for another purpose
let the handle run out of scope
exit the program.
Error messages
--------------

   Both drivers, Msql and Mysql implement a method ->errmsg(), which
returns a textual error message. Mysql additionally supports a method
->errno returning the corresponding error number. Note that Msql's errmsg
is a static method, thus it is legal to fetch

     Msql->errmsg();

   Mysql doesn't support this, fetching the error message is only valid via

     $dbh->errmsg();

   I recommend, that even Msql users restrict themselves to the latter for
portability reasons. There are also global variables $Msql::db_errstr and
$Mysql::db_errstr, which always hold the last error message. The former is
reset with the next executed command, the latter not. Usually there's no
need for accessing the global variables, with one exception: If the
connect method fails, you need them.

The -w switch
-------------

   With Msql and Mysql the -w switch is your friend! If you call your perl
program with the -w switch you get the warnings from ->errmsg on STDERR.
This is a handy method to get the error messages from the msql server
without coding it into your program.

   If you want to know in greater detail what's going on, set the
environment variables that are described in David's manual. David's
debugging aid is excellent, there's nothing to be added.

   If you want to use the -w switch but do not want to see the error
messages from the msql daemon, you can set the variables $Msql::QUIET or
$Mysql::QUIET to some true value, and they will be supressed.

->quote($str [, $length])
-------------------------

   returns the argument enclosed in single ticks (") with any special
character escaped according to the needs of the API.

   For mSQL this means, any single tick within the string is escaped with
a backslash and backslashes are doubled. Currently (as of msql-1.0.16) the
API does not allow to insert NUL's (ASCII 0) into tables. The quote method
does not fix this deficiency.

   MySQL allows NUL's or any other kind of binary data in strings. Thus
the quote method will additionally escape NUL's as \0.

   If you pass undefined values to the quote method, it returns the string
NULL.

   If a second parameter is passed to quote, the result is truncated to
that many characters.

NULL fields
-----------

   NULL fields in tables are returned to perl as undefined values.

Metadata
--------

   Now lets reconsider the above methods with regard to metadata.

Database Handle
---------------

   As said above you get a database handle with

     $dbh = Msql->connect($host, $database);

     or

     $dbh = Mysql->connect($host, $database);

   The database handle knows about the socket, the host, and the database
it is connected to.

   You get at the three values with the methods

     $scalar = $dbh->sock;
     $scalar = $dbh->host;
     $scalar = $dbh->database;

   Mysql additionally supports

     $scalar = $dbh->user;
     $scalar = $dbh->sockfd;

   where the latter is the file descriptor of the socket used by the
database connection. This is the same as $dbh->sock for mSQL.

Statement Handle
----------------

   Two constructor methods return a statement handle:

     $sth = $dbh->listfields($table);
     $sth = $dbh->query($sql_statement);

   $sth knows about all metadata that are provided by the API:

     $scalar = $sth->numrows;
     $scalar = $sth->numfields;

     @arr  = $sth->table;       the names of the tables of each column
     @arr  = $sth->name;        the names of the columns
     @arr  = $sth->type;        the type of each column, defined in msql.h
     	                     and accessible via Msql::CHAR_TYPE,
     	                     &Msql::INT_TYPE, &Msql::REAL_TYPE or
                                &Mysql::FIELD_TYPE_STRING,
                                &Mysql::FIELD_TYPE_LONG, ...
     @arr  = $sth->isnotnull;   array of boolean
     @arr  = $sth->isprikey;    array of boolean
     @arr  = $sth->isnum;       array of boolean
     @arr  = $sth->length;      array of the possibble maximum length of each
                                field in bytes
     @arr  = $sth->maxlength;   array of the actual maximum length of each field
                                in bytes. Be careful when using this attribute
                                under MsqlPerl: The server doesn't offer this
                                attribute, thus it is calculated by fetching
                                all rows. This might take a long time and you
                                might need to call $sth->dataseek.

   Mysql additionally supports

     $scalar  = $sth->affectedrows  number of rows in database affected by query
     $scalar  = $sth->insertid      the unique id given to a auto_increment field.
     $string  = $sth->info()        more info from some queries (ALTER TABLE...)
     $arrref  = $sth->isblob;       array of boolean

   The array methods (table, name, type, is_not_null, is_pri_key, length,
affected_rows, is_num and blob) return an array in array context and an
array reference (see *Note Perlref: (perl.info)perlref, and `perlldsc' in
this node for details) when called in a scalar context. The scalar context
is useful, if you need only the name of one column, e.g.

     $name_of_third_column = $sth->name->[2]

   which is equivalent to

     @all_column_names = $sth->name;
     $name_of_third_column = $all_column_names[2];

New in mSQL 2.0
---------------

   The query() function in the API returns the number of rows affected by
a query. To cite the mSQL API manual, this means...

     If the return code is greater than 0, not only does it imply
     success, it also indicates the number of rows "touched" by the query
     (i.e. the number of rows returned by a SELECT, the number of rows
     modified by an update, or the number of rows removed by a delete).

   As we are returning a statement handle on selects, we can easily check
the number of rows returned. For non-selects we behave just the same as
mSQL-2.

   To find all indices associated with a table you can call the
`listindices()' method on a statement handle. To find out the columns
included in an index, you can call the `listindex($table,$index)' method
on a database handle.

   There are a few new column types in mSQL 2. You can access their
numeric value with these functions defined in the Msql package:
IDENT_TYPE, NULL_TYPE, TEXT_TYPE, DATE_TYPE, UINT_TYPE, MONEY_TYPE,
TIME_TYPE, IDX_TYPE, SYSVAR_TYPE.

   You cannot talk to a 1.0 server with a 2.0 client.

   You cannot link to a 1.0 library and to a 2.0 library *at the same
time*. So you may want to build two different Msql modules at a time, one
for 1.0, another for 2.0, and load whichever you need. Check out what the
-I switch in perl is for.

   Everything else seems to remain backwards compatible.

@EXPORT
-------

   For historical reasons the constants CHAR_TYPE, INT_TYPE, and REAL_TYPE
are in @EXPORT instead of @EXPORT_OK. This means, that you always have
them imported into your namespace. I consider it a bug, but not such a
serious one, that I intend to break old programs by moving them into
EXPORT_OK.

Displaying whole tables in one go
---------------------------------

   A handy method to show the complete contents of a statement handle is
the as_string method. This works similar to the msql monitor with a few
exceptions:

the width of a column
     is calculated by examining the width of all entries in that column

control characters
     are mapped into their backslashed octal representation

backslashes
     are doubled (`\\ instead of \')

numeric values
     are adjusted right (both integer and floating point values)

   The differences are illustrated by the following table:

   Input to msql (a real carriage return here replaced with ^M):

     CREATE TABLE demo (
       first_field CHAR(10),
       second_field INT
     ) \g

     INSERT INTO demo VALUES ('new
     line',2)\g
     INSERT INTO demo VALUES ('back\\slash',1)\g
     INSERT INTO demo VALUES ('cr^Mcrnl
     nl',3)\g

   Output of msql:

     +-------------+--------------+
     | first_field | second_field |
     +-------------+--------------+
     | new
         line    | 2            |
     | back\slash  | 1            |
         crnlr
         nl  | 3            |
     +-------------+--------------+

   Output of pmsql:

     +----------------+------------+
     |first_field     |second_field|
     +----------------+------------+
     |new\012line     |           2|
     |back\\slash     |           1|
     |cr\015crnl\012nl|           3|
     +----------------+------------+

Version information
-------------------

   The version of Msql and Mysql is always stored in $Msql::VERSION or
$Mysql::VERSION as it is perl standard.

   The mSQL API implements methods to access some internal configuration
parameters: gethostinfo, getserverinfo, and getprotoinfo.  All three are
available both as class methods or via a database handle. But under no
circumstances they are associated with a database handle. All three return
global variables that reflect the last connect() command within the
current program. This means, that all three return empty strings or zero
before the first call to connect().

   This situation is better with MySQL: The methods are valid only in
connection with a database handle.

Administration
--------------

   shutdown, createdb, dropdb, reloadacls are all accessible via a
database handle and implement the corresponding methods to what msqladmin
does.

   The mSQL and MySQL engines do not permit that these commands are
invoked by users without sufficient privileges. So please make sure to
check the return and error code when you issue one of them.

     $rc = $dbh->shutdown();
     $rc = $dbh->createdb($database);
     $rc = $dbh->dropdb($database);

   It should be noted that database deletion is *not prompted for* in any
way. Nor is it undo-able from within Perl.

     B<Once you issue the dropdb() method, the database will be gone!>

   These methods should be used at your own risk.

StudlyCaps
----------

   Real Perl Programmers (C) usually don't like to type ListTables but
prefer list_tables or *listtables*. The mSQL API uses StudlyCaps
everywhere and so did early versions of MsqlPerl. Beginning with $VERSION
1.06 all methods are internally in lowercase, but may be written however
you please. Case is ignored and you may use the underline to improve
readability.

   The price for using different method names is neglectible. Any method
name you use that can be transformed into a known one, will only be
defined once within a program and will remain an alias until the program
terminates. So feel free to run fetch_row or connecT or ListDBs as in your
old programs. These, of course, will continue to work.

PREREQUISITES
=============

   mSQL is a database server and an API library written by David Hughes.
To use the adaptor you definitely have to install these first.

   MySQL is a libmysqlclient.a library written by Michael Widenius This
was originally inspired by MySQL.

AUTHOR
======

   andreas koenig `koenig@franz.ww.TU-Berlin.DE'

SEE ALSO
========

   Alligator Descartes wrote a database driver for Tim Bunce's DBI. I
recommend anybody to carefully watch the development of this module
(`DBD::mSQL'). Msql is a simple, stable, and fast module, and it will be
supported for a long time. But it's a dead end. I expect in the medium
term, that the DBI efforts result in a richer module family with better
support and more functionality. Alligator maintains an interesting page on
the DBI development: http://www.arcana.co.uk/technologia/perl/DBI


