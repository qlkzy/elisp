This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: RDFStore,  Next: RDFStore/FindIndex,  Prev: RDBAL/Schema,  Up: Module List

This is a set of Perl modules that implement an object-oriented API to manipulate RDF models
********************************************************************************************

NAME
====

   RDFStore - This is a set of Perl modules that implement an
object-oriented API to manipulate RDF models

SYNOPSIS
========

     use RDFStore;

DESCRIPTION
===========

   RDFStore is a set of Perl modules to manage Resource Description
Framework (RDF) model databases in a easy and straightforward way. It is a
pure Perl implementation of the Draft Java API (see
http://www-db.stanford.edu/~melnik/rdf/api.html) from the Stanford
University DataBase Group by Sergey Melnik. Together with its companions
RDFStore::Parser::SiRPAC(3) and Data::MagicTie(3) modules RDFStore suite
allow a user to fetch, parse, process, store and query RDF models.

   Modules like RDFStore::Stanford::RDFNode, RDFStore::Stanford::Literal,
RDFStore::Stanford::Model and so on define a set of "O-O interfaces" to be
implemented by concrete counterparts such as RDFStore::RDFNode,
RDFStore::Model and others. The modules defined by RDFStore correspond to
the Java org.w3c.rdf.model, org.w3c.rdf.util,
org.w3c.rdf.implementation.model, org.w3c.tools.crypt,
edu.stanford.db.rdf.schema, edu.stanford.db.rdf.vocabulary,
org.w3c.rdf.vocabulary.rdf_syntax_19990222,
org.w3c.rdf.vocabulary.rdf_schema_19990303,
org.w3c.rdf.vocabulary.dublin_core_1999070 packages defined by Sergey
Melnik; the Perl code has been structured as follow:

     Perl packages 		   Java classes
     --------------------------------------------------------------
     RDFStore::Stanford::*				org.w3c.rdf.model
     --------------------------------------------------------------
     RDFStore::Stanford::Model			org.w3c.rdf.model.Model
     RDFStore::Stanford::Literal 			org.w3c.rdf.model.Literal
     RDFStore::Stanford::RDFNode 			org.w3c.rdf.model.RDFNode
     RDFStore::Stanford::Resource 			org.w3c.rdf.model.Resource
     RDFStore::Stanford::Statement 			org.w3c.rdf.model.Statement
     RDFStore::Stanford::NodeFactory 		org.w3c.rdf.model.NodeFactory
     RDFStore::Stanford::VirtualModel		org.w3c.rdf.model.VirtualModel
     RDFStore::Stanford::SetModel 			org.w3c.rdf.model.SetModel

   RDFStore::Stanford::Digest::*				org.w3c.rdf.util,org.w3c.tools.crypt
---------------------------------------------------------------------------
RDFStore::Stanford::Digest				org.w3c.rdf.tools.crypt.Digest
RDFStore::Stanford::Digest::Util			org.w3c.rdf.util.DigestUtil
RDFStore::Stanford::Digest::AbstractDigest	org.w3c.rdf.util.DigestUtil
RDFStore::Stanford::Digest::GenericDigest	org.w3c.rdf.util.DigestUtil
RDFStore::Stanford::Digest::MD5			org.w3c.rdf.util.DigestUtil
RDFStore::Stanford::Digest::SHA1			org.w3c.rdf.util.DigestUtil


RDFStore::*				org.w3c.rdf.implementation.model,edu.stanford.db.rdf.schema
--------------------------------------------------------------------------------------------------
RDFStore::Model			org.w3c.rdf.implementation.model.Model
RDFStore::Literal			org.w3c.rdf.implementation.model.Literal
RDFStore::RDFNode			org.w3c.rdf.implementation.model.RDFNode
RDFStore::Resource		org.w3c.rdf.implementation.model.Resource
RDFStore::Statement		org.w3c.rdf.implementation.model.Statement
RDFStore::NodeFactory		org.w3c.rdf.implementation.model.NodeFactory
RDFStore::VirtualModel		org.w3c.rdf.implementation.model.VirtualModel
RDFStore::SetModel		org.w3c.rdf.implementation.model.SetModel
RDFStore::SchemaModel		edu.stanford.db.rdf.schema.RDFSchemaModel

   RDFStore::Stanford::Vocabulary::*				edu.stanford.db.rdf.vocabulary
------------------------------------------------------------------------------------------
RDFStore::Stanford::Vocabulary::Generator		edu.stanford.db.rdf.vocabulary.Generator


RDFStore::Stanford::Vocabulary::RDF			org.w3c.rdf.vocabulary.rdf_syntax_19990222.RDF
RDFStore::Stanford::Vocabulary::RDFS			org.w3c.rdf.vocabulary.rdf_schema_19990303.RDFS
RDFStore::Stanford::Vocabulary::DC				org.w3c.rdf.vocabulary.dublin_core_19990702.DC

   The Perl RDF API implementation is almost aligned with the Java one
(some feauture were left out because for it difficulty or impossibility in
the implementation). E.g. Perl do not have Exceptions as built in
construcut, and altough they could be easily implemented with eval() and
$@ checking, RDFStore just uses the Carp module to warn, croak or confess
on errors. In the RDFStore branch the modules code has been extended and
modified to use the Data::MagicTie(3) interface and a different indexing
mechanism in RDFStore::FindIndex(3). Similarly the
RDFStore::Stanford::Vocabulary::Generator(3) now generates valid Perl5
modules containing constants definitions of input RDF Schema.

   For the whole API documentation you can temporarly refer to the JavaDoc
version at http://www-db.stanford.edu/~melnik/rdf/api-doc/

   In addition I invite you to look at the samples and utils directory
coming with the RDFStore distribution for a fruitful set of examples to
play with :-)

BUGS
====

   This module implements most of the classes and packages as its Java
counterpart from the Stanford University Database Group by Sergey Melnik
(see http://www-db.stanford.edu/~melnik/rdf/api.html), but some feature
have been missied on purposed or just forgotten ;-) This RDFsotre version
is up-to-date with the latest changes from current revision: 2000-12-05 of
Stanford Java API.

   Not supported:

     * NodeFactory::createOrdinal()
     * order/backorder experimental from Sergey Melnik

SEE ALSO
========

   RDFStore::Parser::SiRPAC(3), DBMS(3) and XML::Parser(3)
XML::Parser::Expat(3) RDFStore::Stanford::Model(3) RDFStore::NodeFactory(3)
Summary of Recent Discussions about an Application Programming Interface
for RDF - http://nestroy.wi-inf.uni-essen.de/rdf/sum_rdf_api/

   RDF Model and Syntax Specification - http://www.w3.org/TR/REC-rdf-syntax
RDF Schema Specification 1.0 -
http://www.w3.org/TR/2000/CR-rdf-schema-20000327 Statements/Statings -
http://ilrt.org/discovery/2000/11/statements/

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>

     Sergey Melnik <melnik@db.stanford.edu> is the original author of the Java RDF API - txs Sergey!


File: pm.info,  Node: RDFStore/FindIndex,  Next: RDFStore/Literal,  Prev: RDFStore,  Up: Module List

implementation of the FindIndex RDF API
***************************************

NAME
====

   RDFStore::FindIndex - implementation of the FindIndex RDF API

SYNOPSIS
========

     use RDFStore::FindIndex;
     my $myindex = new RDFStore::FindIndex({});

     use Data::MagicTie;
     tie %index,"Data::MagicTie",'index';
     my $mypresistentindex = new RDFStore::FindIndex(\%index);

DESCRIPTION
===========

   This modules implement a very simple and dirty indexing for
RDFStore::Stanford::Statement(s) using three hashes one indexing by
subject, one by predicate one by object. Each hash contain a copy of the
statement actually containing such a subject, predicate or object. It is
not really efficient due the fact that it requires to keep as value in
hashes a copy of the BLOBed statement - see Data::MagicTie(3)

   An instance of RDFStore::FindIndex can be passed to RDFStore::Model to
help it searching the RDF triplets store.

SEE ALSO
========

   Data::MagicTie(3) RDFStore::Model(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Literal,  Next: RDFStore/Model,  Prev: RDFStore/FindIndex,  Up: Module List

An implementation of the Literal RDF API
****************************************

NAME
====

   RDFStore::Literal - An implementation of the Literal RDF API

SYNOPSIS
========

     use RDFStore::Literal;
     my $literal = new RDFStore::Literal("Ciao neh!!");

DESCRIPTION
===========

   An RDFStore::Stanford::Literal implementation using Digested URIs.

SEE ALSO
========

   Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Model,  Next: RDFStore/NodeFactory,  Prev: RDFStore/Literal,  Up: Module List

An implementation of the Model RDF API
**************************************

NAME
====

   RDFStore::Model - An implementation of the Model RDF API

SYNOPSIS
========

     use RDFStore::Model;
     use RDFStore::NodeFactory;
     use RDFStore::FindIndex;
     use Data::MagicTie;

     my $factory= new RDFStore::NodeFactory();
     my $statement = $factory->createStatement(
                             	$factory->createResource('http://perl.org'),
                             	$factory->createResource('http://iscool.org/schema/1.0/#label'),
                             	$factory->createLiteral('Cool Web site')
                                     );
     my $statement1 = $factory->createStatement(
     			$factory->createResource("http://www.altavista.com"),
     			$factory->createResource("http://pen.jrc.it/schema/1.0/#author"),
     			$factory->createLiteral("Who? :-)")
     			);

     my $statement2 = $factory->createStatement(
     			$factory->createUniqueResource(),
     			$factory->createUniqueResource(),
     			$factory->createLiteral("")
     			);

     my $index_db={};
     tie %{$index_db},"Data::MagicTie",'index/triples',(Q => 20);
     my $index=new RDFStore::FindIndex($index_db);
     my $model = new RDFStore::Model($factory,undef,$index,undef);

     $model->add($statement);
     $model->add($statement1);
     $model->add($statement2);
     my $model1 = $model->duplicate();

     print $model1->getDigest->equals( $model1->getDigest );
     print $model1->getDigest->hashCode;

     my $found = $model->find($statement2->subject,undef,undef);
     foreach (keys %{$found->elements}) {
             	print $found->elements->{$_}->getLabel(),"\n";
     };

DESCRIPTION
===========

   An RDFStore::Stanford::Model implementation using Digested URIs and
Perl hashes to store triplets. The actual store could be tied to a
Data::MagicTie(3) hash/array and the RDFStore::FindIndex(3) module.

SEE ALSO
========

   Data::MagicTie(3) Digest(3) RDFStore::Stanford::Digest(3)
RDFStore::RDFNode RDFStore::Resource RDFStore::FindIndex(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/NodeFactory,  Next: RDFStore/Parser/OpenHealth,  Prev: RDFStore/Model,  Up: Module List

implementation of the NodeFactory RDF API
*****************************************

NAME
====

   RDFStore::NodeFactory - implementation of the NodeFactory RDF API

SYNOPSIS
========

     use RDFStore::NodeFactory;
     my $factory = new RDFStore::NodeFactory();
     my $statement = $factory->createStatement(
     			$factory->createResource("http://pen.jrc.it"),
       				$factory->createResource("http://purl.org/schema/1.0#author"),
       				$factory->createLiteral("Alberto Reggiori")
     			);

DESCRIPTION
===========

   An RDFStore::Stanford::NodeFactory implementation using
RDFStore::RDFNode, RDFStore::Resource and RDFStore::Literal

SEE ALSO
========

   RDFStore::RDFNode(3) RDFStore::Resource(3) RDFStore::Literal(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Parser/OpenHealth,  Next: RDFStore/Parser/SiRPAC,  Prev: RDFStore/NodeFactory,  Up: Module List

This module implements an RDF strawman parser for the syntax proposed by Jonathan Borden at http://www.openhealth.org/RDF/rdf_Syntax_and_Names.htm
**************************************************************************************************************************************************

NAME
====

   RDFStore::Parser::OpenHealth - This module implements an RDF strawman
parser for the syntax proposed by Jonathan Borden at
http://www.openhealth.org/RDF/rdf_Syntax_and_Names.htm

SYNOPSIS
========

     use RDFStore::Parser::OpenHealth;
             use RDFStore::NodeFactory;
             my $p=new RDFStore::Parser::OpenHealth(
     	ErrorContext => 2,
                     Handlers        => {
                             Init    => sub { print "INIT\n"; },
                             Final   => sub { print "FINAL\n"; },
                             Assert  => sub { print "STATEMENT - @_\n"; }
                     },
                     NodeFactory     => new RDFStore::NodeFactory() );

     $p->parsefile('http://www.openhealth.org/RDF/mns-fig13-result.xml');
             $p->parsefile('/some/where/my.xml');
             $p->parsefile('file:/some/where/my.xml');
     $p->parse(*STDIN);

     use RDFStore;
     my $pstore=new RDFStore::Parser::OpenHealth(
                     ErrorContext 	=> 2,
                     Style 		=> 'RDFStore::Parser::SiRPAC::RDFStore',
                     NodeFactory     => new RDFStore::NodeFactory(),
                     store   =>      {
                                     	persistent      =>      1,
                                     	directory       =>      '/tmp/',
                                     	seevalues       =>      1,
                                     	options         =>      { style => 'BerkeleyDB', Q => 20 }
                                     }
             );
     $pstore->parsefile('http://www.openhealth.org/RDF/mns-sect7.2-result.xml');

DESCRIPTION
===========

   This module implements a Resource Description Framework (RDF) strawman
parser compliant to the syntax proposed by Jonathan Borden at
http://www.openhealth.org/RDF/rdf_Syntax_and_Names.htm using the XSLT
style sheet at http://www.openhealth.org/RDF/extract/rdfExtractity.xsl.
Such a syntax is yet another extension/refinement of the original syntax
proposed by Dan Connoly at http://www.w3.org/XML/2000/04rdf-parse/rdfp.xsl
and already extended by Jason Diamond's at
http://www.injektilo.org/rdf/rdf.xsl. The parser has been completely
written in Perl using the XML::Parser::Expat(3) module. For the actual
explaination see the RDFStore::Parser::SiRPAC(3) man page.

METHODS
=======

   RDFStore::Parser::OpenHealth supports all the RDFStore::Parser::SiRPAC
options *but* Source. See the manual page for RDFStore::Parser::SiRPAC(3)

BUGS
====

   Although the syntax proposed by Jonathan Borden is quite complete, the
style-sheet is not unfortunately compatible with the Sablotron(3) great
XSLT engine, that does not support 'exclude-result-prefixes' and functions
overriding. A modified version working for Sablotron is available in the
samples directory in the file xml2rdf.xsl.

SEE ALSO
========

   RDFStore::Parser::SiRPAC(3), Sablotron(3) RDFStore::NodeFactory(3)


     Mapping namespace qualified element names to URIs -
     http://www.openhealth.org/RDF/QNameToURI.htm


     Jason Diamond's http://injektilo.org/rdf/examples.html


     Dan Connoly strawman sytax - http://www.w3.org/XML/2000/04rdf-parse/


     TimBL's semantic web toolbox - http://www.w3.org/DesignIssues/Toolbox


     RDF Model and Syntax Specification -
     http://www.w3.org/TR/REC-rdf-syntax


     RDF Schema Specification 1.0 -
     http://www.w3.org/TR/2000/CR-rdf-schema-20000327

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>
     Clark Cooper is the author of the XML::Parser(3) module together with Larry wall


File: pm.info,  Node: RDFStore/Parser/SiRPAC,  Next: RDFStore/Parser/Styles/MagicTie,  Prev: RDFStore/Parser/OpenHealth,  Up: Module List

This module implements a streaming RDF Parser as a direct implementation of XML::Parser::Expat(3)
*************************************************************************************************

NAME
====

   RDFStore::Parser::SiRPAC - This module implements a streaming RDF
Parser as a direct implementation of XML::Parser::Expat(3)

SYNOPSIS
========

     use RDFStore::Parser::SiRPAC;
             use RDFStore::NodeFactory;
             my $p=new RDFStore::Parser::SiRPAC(
     	ErrorContext => 2,
                     Handlers        => {
                             Init    => sub { print "INIT\n"; },
                             Final   => sub { print "FINAL\n"; },
                             Assert  => sub { print "STATEMENT - @_\n"; }
                     },
                     NodeFactory     => new RDFStore::NodeFactory() );

     $p->parsefile('http://www.gils.net/bsr-gils.rdfs');
             $p->parsefile('http://www.gils.net/rdf/bsr-gils.rdfs');
             $p->parsefile('/some/where/my.rdf');
             $p->parsefile('file:/some/where/my.rdf');
     $p->parse(*STDIN);

     use RDFStore;
     my $pstore=new RDFStore::Parser::SiRPAC(
                     ErrorContext 	=> 2,
                     Style 		=> 'RDFStore::Parser::SiRPAC::RDFStore',
                     NodeFactory     => new RDFStore::NodeFactory(),
                     Source  	=> 'http://www.gils.net/bsr-gils.rdfs',
                     store   =>      {
                                     	persistent      =>      1,
                                     	directory       =>      '/tmp/',
                                     	seevalues       =>      1,
                                     	options         =>      { style => 'BerkeleyDB', Q => 20 }
                                     }
             );
     $pstore->parsefile('http://www.gils.net/bsr-gils.rdfs');

     #using the Expat no-blocking feature
     my $nbpstore = $pstore->parse_start();
     while (<STDIN>) {
     	$nbpstore->parse_more($_);
     };
     $nbpstore->parse_done();

DESCRIPTION
===========

   This module implements a Resource Description Framework (RDF)
*streaming* parser completely in Perl using the XML::Parser::Expat(3)
module. The actual RDF parsing happens using an instance of
XML::Parser::Expat with Namespaces option enabled and start/stop and char
handlers set.  The RDF specific code is based on the modified version of
SiRPAC of Sergey Melnik in Java; a lot of changes and adaptations have
been done to actually run it under Perl.  Expat options may be provided
when the RDFStore::Parser::SiRPAC object is created. These options are
then passed on to the Expat object on each parse call.

   Exactly like XML::Parser(3) the behavior of the parser is controlled
either by the Style entry elsewhere in this document and/or the Handlers
entry elsewhere in this document options, or by the setHandlers entry
elsewhere in this document method. These all provide mechanisms for
RDFStore::Parser::SiRPAC to set the handlers needed by Expat.  If neither
Style nor Handlers are specified, then parsing just checks the RDF
document syntax against the W3C RDF Raccomandation . When underlying
handlers get called, they receive as their first parameter the Expat
object, not the Parser object.

   To see some examples about how to use it look at the sections below and
in the samples and utils directory coming with this software distribution.

   E.g.  	With RDFStore::Parser::SiRPAC you can easily write an
rdfingest.pl script to do something like this:

     fetch -o - -q http://dmoz.org/rdf/content.rdf.u8.gz | \
     	gunzip - | \
     	sed -f dmoz.content.sed | rdfingest.pl -

METHODS
=======

new
     This is a class method, the constructor for RDFStore::Parser::SiRPAC.
     Options are passed as keyword value pairs. Recognized options are:

        * NodeFactory

          This option is *mandatory* to run the RDFStore::Parser::SiRPAC
          parser correctly and must contain a reference to an object of
          type RDFStore::Stanford::NodeFactory(3). Such a reference is
          used during the RDF parsing to create resources, literal and
          statements to be passed to the registered handlers. A sample
          implementation is RDFStore::NodeFactory that is provided with
          the RDFStore package.

        * Source

          This option can be specified by the user to set a base URI to
          use for the generation of resource URIs during parsing. If this
          option is omitted the parser will try to generate a prefix for
          generated resources using the input filename or URL actually
          containing the input RDF. In a near future such an option could
          be obsoleted by use of XMLBase W3C raccomandation.

        * Style

          This option provides an easy way to set a given style of parser.
          There is one sample Sylte module provided with the
          RDFStore::Parser::SiRPAC distribution called
          RDFStore::Parser::SiRPAC::RDFStore. Such a module uses the
          RDFStore(3) modules together with the Data::MagicTie(3) to
          implement a simple RDF storage.  Custom styles can be provided
          by giving a full package name containing at least one '::'. This
          package should then have subs defined for each handler it wishes
          to have installed. See `"WRITE YOUR OWN PARSER"' in this node
          below for a discussion on how to build one.

        * Handlers

          When provided, this option should be an anonymous hash
          containing as keys the type of handler and as values a sub
          reference to handle that type of event. All the handlers get
          passed as their 1st parameter the instance of Expat that is
          parsing the document. Further details on handlers can be found
          in `"HANDLERS"' in this node. Any handler set here overrides the
          corresponding handler set with the Style option.

        * ErrorContext

          This is an XML::Parser option. When this option is defined,
          errors are reported in context. The value should be the number
          of lines to show on either side of the line in which the error
          occurred.

     All the other XML::Parser and XML::Parser::Expat options should work
     freely with RDFStore::Parser::SiRPAC see XML::Parser(3) and
     XML::Parser::Expat(3).

setHandlers(TYPE, HANDLER [, TYPE, HANDLER [...]])
     This method registers handlers for various parser events. It
     overrides any previous handlers registered through the Style or
     Handler options or through earlier calls to setHandlers. By providing
     a false or undefined value as the handler, the existing handler can
     be unset.

     This method returns a list of type, handler pairs corresponding to the
     input. The handlers returned are the ones that were in effect prior to
     the call.

     See a description of the handler types in `"HANDLERS"' in this node.

parse(SOURCE, URIBASE [, OPT => OPT_VALUE [...]])
     The SOURCE parameter should either be a string containing the whole
     RDF document, or it should be an open IO::Handle.  The URIBASE can be
     specified by the user to set a base URI to use for the generation of
     resource URIs during parsing. If this option is omitted the parser
     will try to generate a prefix for generated resources using either
     the `Source' in this node option of the constructor, the input
     filename or URL actually containing the input RDF. In a near future
     such an option could be obsoleted by use of XMLBase W3C
     raccomandation.  Constructor options to XML::Parser::Expat given as
     keyword-value pairs may follow the URIBASE parameter. These override,
     for this call, any options or attributes passed through from the
     RDFStore::Parser::SiRPAC instance.

     A die call is thrown if a parse error occurs. Otherwise it will
     return 1 or whatever is returned from the Final handler, if one is
     installed.  In other words, what parse may return depends on the
     style.

     e.g. the RDFStore::Parser::SiRPAC::RDFStore Style module returns an
     instance of RDFStore::Stanford::Model

parsestring(STRING, URIBASE [, OPT => OPT_VALUE [...]])
     This is just an alias for parse for backwards compatibility.

parsefile(URL_OR_FILE [, OPT => OPT_VALUE [...]])
     Open URL_OR_FILE for reading, then call parse with the open handle.
     If URL_OR_FILE is a full qualified URL this module uses Socket(3) to
     actually fetch the content.  The URIBASE `parse()' in this node
     parameter is set to URL_OR_FILE.

HANDLERS
========

   As Expat, SiRPAC is an event based parser. As the parser recognizes
parts of the RDF document then any handlers registered for that type of an
event are called with suitable parameters.  All handlers receive an
instance of XML::Parser::Expat as their first argument. See `"METHODS"',
*Note XML/Parser/Expat: XML/Parser/Expat, for a discussion of the methods
that can be called on this object.

Init             (Expat)
------------------------

   This is called just before the parsing of the document starts.

Final            (Expat)
------------------------

   This is called just after parsing has finished, but only if no errors
occurred during the parse. Parse returns what this returns.

Assert            (Expat, Statement)
------------------------------------

   This event is generated when a new RDF statement has been generated by
the parseer.start tag is recognized. Statement is of type
RDFStore::Stanford::Statement(3) as generated by the
RDFStore::Stanford::NodeFactory(3) passed as argument to the
RDFStore::Parser::SiRPAC constructor.

Start_XML_Literal            (Expat, Element [, Attr, Val [,...]])
------------------------------------------------------------------

   This event is generated when an XML start tag is recognized within an
RDF property with parseType="Literal". Element is the name of the XML
element type that is opened with the start tag. The Attr & Val pairs are
generated for each attribute in the start tag.

   This handler should return a string containing either the original XML
chunck or one f its transformations, perhaps using XSLT.

Stop_XML_Literal              (Expat, Element)
----------------------------------------------

   This event is generated when an XML end tag is recognized within an RDF
property with parseType="Literal". Note that an XML empty tag (<foo/>)
generates both a Start_XML_Literal and an Stop_XML_Literal event.

Char_XML_Literal             (Expat, String)
--------------------------------------------

   This event is generated when non-markup is recognized within an RDF
property with parseType="Literal". The non-markup sequence of characters
is in String. A single non-markup sequence of encoding of the string in
the original document, this is given to the handler in UTF-8.

   This handler should return the processed text as a string.

WRITE YOUR OWN PARSER
=====================

   Write an extension module for you needs it is as easy as write one for
XML::Parser :) Have a look at
http://www.xml.com/xml/pub/98/09/xml-perl.html and
http://wwwx.netheaven.com/~coopercc/xmlparser/intro.html.

   You can either make you Perl script a parser self by embedding the
needed function hooks or write a custom Style module for
RDFStore::Parser::SiRPAC.

*.pl scripts
------------

     use RDFStore::Parser::SiRPAC;
     use RDFStore::NodeFactory;
     my $p=new RDFStore::Parser::SiRPAC(
     	Handlers        => {
     		Init    => sub { print "INIT\n"; },
     		Final   => sub { print "FINAL\n"; },
     		Assert  => sub { print "STATEMENT - @_\n"; }
     	},
     	NodeFactory     => new RDFStore::NodeFactory() );

   or something like:

     use RDFStore::Parser::SiRPAC;
             use RDFStore::NodeFactory;
     my $p=new RDFStore::Parser::SiRPAC( NodeFactory     => new RDFStore::NodeFactory() );
     $p->setHandlers(        Init    => sub { print "INIT\n"; },
                             	Final   => sub { print "FINAL\n"; },
                             	Assert  => sub { print join(",",@_),"\n"; }     );

Style modules
-------------

   A more sophisticated solution is to write a complete Perl5 Sytle module
for RDFStore::Parser::SiRPAC that can be easily reused in your code. E.g.
a perl script could use this piece of code:

     use RDFStore::Parser::SiRPAC;
     use RDFStore::Parser::SiRPAC::MyStyle;
     use RDFStore::NodeFactory;

     my $p=new RDFStore::Parser::SiRPAC(	Style => 'RDFStore::Parser::SiRPAC::MyStyle',
                     			NodeFactory     => new RDFStore::NodeFactory() );
     $p->parsefile('http://www.gils.net/bsr-gils.rdfs');

   The Style module self could stored into a file like MyStyle.pm like
this:

     package RDFStore::Parser::SiRPAC::MyStyle;

     sub Init { print "INIT\n"; };
     sub Final { print "FINAL\n"; };
     sub Assert {
                     print "ASSERT: ",
                                     $_[1]->subject()->toString(),
                                     $_[1]->predicate()->toString(),
                                     $_[1]->object()->toString(), "\n";
     };
     sub Start_XML_Literal { print "STARTAG: ",$_[1],"\n"; };
     sub Stop_XML_Literal { print "ENDTAG: ",$_[1],"\n"; };
     sub Char_XML_Literal { print "UTF8 chrs: ",$_[1],"\n"; };

     1;

   For a more complete and useful example see
RDFStore::Parser::SiRPAC::RDFStore(3).

BUGS
====

   This module implements most of the W3C RDF Raccomandation as its Java
counterpart SiRPAC from the Stanford University Database Group by Sergey
Melnik (see http://www-db.stanford.edu/~melnik/rdf/api.html) This version
is conformant to the latest RDF API Draft on 2000-11-13. It does not
support yet:

     * aboutEach and aboutEachPrefix

SEE ALSO
========

   RDFStore::Parser::SiRPAC(3), DBMS(3) and XML::Parser(3)
XML::Parser::Expat(3) RDFStore::Stanford::Model(3) RDFStore::NodeFactory(3)

     RDF Model and Syntax Specification - http://www.w3.org/TR/REC-rdf-syntax
     RDF Schema Specification 1.0 - http://www.w3.org/TR/2000/CR-rdf-schema-20000327
     Benchmarking XML Parsers by Clark Cooper - http://www.xml.com/pub/Benchmark/article.html
     See also http://www.w3.org/RDF/Implementations/SiRPAC/SiRPAC-defects.html
     RDF::Parser(3) from http://www.pro-solutions.com

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>

     Sergey Melnik <melnik@db.stanford.edu> is the original author of the streaming version of SiRPAC in Java
     Clark Cooper is the author of the XML::Parser(3) module together with Larry Wall


File: pm.info,  Node: RDFStore/Parser/Styles/MagicTie,  Next: RDFStore/RDFNode,  Prev: RDFStore/Parser/SiRPAC,  Up: Module List

This module is an extension of RDFStore::Parser::SiRPAC(3) that actually use the RDFStore API modules to ingest records into an RDFStore database.
**************************************************************************************************************************************************

NAME
====

   RDFStore::Parser::Styles::MagicTie - This module is an extension of
RDFStore::Parser::SiRPAC(3) that actually use the RDFStore API modules to
ingest records into an RDFStore database.

SYNOPSIS
========

     use RDFStore::Parser::SiRPAC;
     use RDFStore::Parser::Styles::MagicTie;
     use RDFStore::NodeFactory;
     my $p=new RDFStore::Parser::SiRPAC(	ErrorContext => 2,
                                     Style => 'RDFStore::Parser::Styles::MagicTie',
                                     NodeFactory     => new RDFStore::DBMS::NodeFactory()
                                     );

   if(defined $ENV{GATEWAY_INTERFACE}) {         print "Content-type:
text/html

   ";         $p->parsefile($ENV{QUERY_STRING}); } else {         my
$input = shift;         if($input =~ /^-/) {
$p->parse(*STDIN);         } else {                 $p->parsefile($input);
       }; };

DESCRIPTION
===========

   In the samples directory of the distribution you can find a set of a
sample scripts to play with :)

METHODS
=======

new
     This is a class method, the constructor for RDFStore::Parser::SiRPAC.
     Options are passed as key/value pairs.
     RDFStore::Parser::Styles::MagicTie supports all the
     RDFStore::Parser::SiRPAC options plus the following:

        * store

          This option if present must point to an HASH reference.
          Recognized options are:

        * persistent

          This option specify if the RDFStore::Stanford::Statement objects
          generated during parsing must be stored in some kind of
          RDFStore. It is a SCALAR with possible values of 0 or 1.

        * seevalues

          This options is a SCALAR with possible values of 0/1 and flags
          whether the parsing is verbose or not (print triples)

        * directory

          This option specify the output directory where the actual DB
          files are generated when the *persistent* option is set.

        * options

          This option if present must point to an HASH reference and helps
          the user to specify the Data::MagicTie options about storage of
          the RDFStore::Stanford::Statement statements when the
          *persistent* option is set. See Data::MagicTie(3)

BUGS
====

   None known yet

SEE ALSO
========

   RDFStore::Parser::SiRPAC(3), Data::MagicTie(3) RDFStore(3) DBMS(3)

AUTHOR
======

   Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/RDFNode,  Next: RDFStore/Resource,  Prev: RDFStore/Parser/Styles/MagicTie,  Up: Module List

implementation of the RDFNode RDF API
*************************************

NAME
====

   RDFStore::RDFNode - implementation of the RDFNode RDF API

SYNOPSIS
========

     use RDFStore::RDFNode;
     my $node = new RDFStore::RDFNode();

DESCRIPTION
===========

   An RDFStore::Stanford::RDFNode implementation using Digested URIs.

SEE ALSO
========

   RDFStore::Stanford::RDFNode(3) Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Resource,  Next: RDFStore/SchemaModel,  Prev: RDFStore/RDFNode,  Up: Module List

implementation of the Resource RDF API
**************************************

NAME
====

   RDFStore::Resource - implementation of the Resource RDF API

SYNOPSIS
========

     use RDFStore::Resource;
     my $resource = new RDFStore::Resource("http://pen.jrc.it/idex.html");

DESCRIPTION
===========

   An RDFStore::Stanford::Resource implementation using Digested URIs.

SEE ALSO
========

   RDFStore::Stanford::Resource(3) Digest(3) RDFStore::RDFNode(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/SchemaModel,  Next: RDFStore/SetModel,  Prev: RDFStore/Resource,  Up: Module List

implementation of the SchemaModel RDF API
*****************************************

NAME
====

   RDFStore::SchemaModel - implementation of the SchemaModel RDF API

SYNOPSIS
========

     use RDFStore::SchemaModel;
     my $schema_validator = new RDFStore::SchemaModel();
     my $valid = $schema_validator->validateRawSchema($m,$rawSchema);

DESCRIPTION
===========

   This is an incomplete package and it provides basic RDF Schema support
accordingly to the Draft API of Sergey Melnik at
http://www-db.stanford.edu/~melnik/rdf/api.html.  Please use it as a
prototype and/or just to get the idea. It provide basic 'closure' support
and validation of a given RDF instance against an RDF Schema.

SEE ALSO
========

   RDFStore::Model(3) RDFStore::VirtualModel(3) RDF Schema Specification
1.0 - http://www.w3.org/TR/2000/CR-rdf-schema-20000327 DARPA Agent Markup
Language (DAML) - http://www.daml.org/

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/SetModel,  Next: RDFStore/Stanford/Digest,  Prev: RDFStore/SchemaModel,  Up: Module List

implementation of the SetModel RDF API
**************************************

NAME
====

   RDFStore::SetModel - implementation of the SetModel RDF API

SYNOPSIS
========

     use RDFStore::SetModel;
             use RDFStore::NodeFactory;
             use RDFStore::FindIndex;
             use Data::MagicTie;

     my $factory= new RDFStore::NodeFactory();
     my $index_db={};
     tie %{$index_db},"Data::MagicTie",'index/triples',(Q => 20);
     my $index=new RDFStore::FindIndex($index_db);
     	my $set = new RDFStore::SetModel($factory,undef,$index,undef);

DESCRIPTION
===========

   An RDFStore::Stanford::SetModel implementation using RDFStore::Model
and Digested URIs.

SEE ALSO
========

   RDFStore::Stanford::SetModel(3) RDFStore::Model(3) Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Digest,  Next: RDFStore/Stanford/Digest/Abstract,  Prev: RDFStore/SetModel,  Up: Module List

implementation of the Digest RDF API
************************************

NAME
====

   RDFStore::Stanford::Digest - implementation of the Digest RDF API

SYNOPSIS
========

DESCRIPTION
===========

SEE ALSO
========

   Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Digest/Abstract,  Next: RDFStore/Stanford/Digest/Generic,  Prev: RDFStore/Stanford/Digest,  Up: Module List

implementation of the AbstractDigest RDF API
********************************************

NAME
====

   RDFStore::Stanford::Digest::Abstract - implementation of the
AbstractDigest RDF API

SYNOPSIS
========

DESCRIPTION
===========

SEE ALSO
========

   Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Digest/Generic,  Next: RDFStore/Stanford/Digest/MD5,  Prev: RDFStore/Stanford/Digest/Abstract,  Up: Module List

implementation of the GenericDigest RDF API
*******************************************

NAME
====

   RDFStore::Stanford::Digest::Generic - implementation of the
GenericDigest RDF API

SYNOPSIS
========

DESCRIPTION
===========

SEE ALSO
========

   Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Digest/MD5,  Next: RDFStore/Stanford/Digest/SHA1,  Prev: RDFStore/Stanford/Digest/Generic,  Up: Module List

implementation of the MD5Digest RDF API
***************************************

NAME
====

   RDFStore::Stanford::Digest::MD5 - implementation of the MD5Digest RDF
API

SYNOPSIS
========

DESCRIPTION
===========

SEE ALSO
========

   Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Digest/SHA1,  Next: RDFStore/Stanford/Digest/Util,  Prev: RDFStore/Stanford/Digest/MD5,  Up: Module List

implementation of the SHA1Digest RDF API
****************************************

NAME
====

   RDFStore::Stanford::Digest::SHA1 - implementation of the SHA1Digest RDF
API

SYNOPSIS
========

DESCRIPTION
===========

SEE ALSO
========

   Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Digest/Util,  Next: RDFStore/Stanford/Literal,  Prev: RDFStore/Stanford/Digest/SHA1,  Up: Module List

implementation of the DigestUtil RDF API
****************************************

NAME
====

   RDFStore::Stanford::Digest::Util - implementation of the DigestUtil RDF
API

SYNOPSIS
========

DESCRIPTION
===========

SEE ALSO
========

   Digest(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Literal,  Next: RDFStore/Stanford/Model,  Prev: RDFStore/Stanford/Digest/Util,  Up: Module List

definiton of the Literal RDF API
********************************

NAME
====

   RDFStore::Stanford::Literal - definiton of the Literal RDF API

SYNOPSIS
========

     use RDFStore::Stanford::Literal;
     my $literal = new RDFStore::Stanford::Literal("Ciao neh!!");

DESCRIPTION
===========

   This is just the interface definition. If you are more interested to an
example implementation see RDFStore::Literal(3)

SEE ALSO
========

   RDFStore::Literal(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Model,  Next: RDFStore/Stanford/NodeFactory,  Prev: RDFStore/Stanford/Literal,  Up: Module List

definiton of the Model RDF API
******************************

NAME
====

   RDFStore::Stanford::Model - definiton of the Model RDF API

SYNOPSIS
========

     use RDFStore::Stanford::Model;
     use RDFStore::Stanford::Literal;
     use RDFStore::Stanford::Resource;
     use RDFStore::Stanford::Statement;
     my $model = new RDFStore::Stanford::Model();
     my $obj = new RDFStore::Stanford::Literal("foo");
     my $subj = new RDFStore::Stanford::Literal("http://www.foo.com");
     my $pred = new RDFStore::Stanford::Literal("http://rdf.dev.oclc.org/eor/2000/02/26-dcv#","creator");
     my $fact= new RDFStore::Stanford::Statement($subj, $pred, $obj);
     $model->add($fact);
     my $result_model = $model->find($fact);

DESCRIPTION
===========

   This is just the interface definition. If you are more interested to an
example implementation see RDFStore::Model(3)

SEE ALSO
========

   RDFStore::Model(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/NodeFactory,  Next: RDFStore/Stanford/RDFNode,  Prev: RDFStore/Stanford/Model,  Up: Module List

definiton of the NodeFactory RDF API
************************************

NAME
====

   RDFStore::Stanford::NodeFactory - definiton of the NodeFactory RDF API

SYNOPSIS
========

     use RDFStore::Stanford::NodeFactory;
     my $factory = new RDFStore::Stanford::NodeFactory();
     my $statement = $factory->createStatement(
     				$factory->createResource("http://pen.jrc.it/idex.html"),
     				$factory->createResource("http://rdf.dev.oclc.org/eor/2000/02/26-dcv#","creator"),
     				$factory->createLiteral("Alberto Reggiori")
     				);

DESCRIPTION
===========

   This is just the interface definition. If you are more interested to an
example implementation see RDFStore::NodeFactory(3)

SEE ALSO
========

   RDFStore::NodeFactory(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/RDFNode,  Next: RDFStore/Stanford/Resource,  Prev: RDFStore/Stanford/NodeFactory,  Up: Module List

definiton of the RDFNode RDF API
********************************

NAME
====

   RDFStore::Stanford::RDFNode - definiton of the RDFNode RDF API

SYNOPSIS
========

     use RDFStore::Stanford::RDFNode
     my $node = new RDFStore::Stanford::RDFNode();

DESCRIPTION
===========

   This is just the interface definition. If you are more interested to an
example implementation see RDFStore::RDFNode(3)

SEE ALSO
========

   RDFStore::RDFNode(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Resource,  Next: RDFStore/Stanford/SetModel,  Prev: RDFStore/Stanford/RDFNode,  Up: Module List

definiton of the Resource RDF API
*********************************

NAME
====

   RDFStore::Stanford::Resource - definiton of the Resource RDF API

SYNOPSIS
========

     use RDFStore::Stanford::Resource
     my $resource = new RDFStore::Stanford::Resource("http://pen.jrc.it/index.html");
     my $resource1 = new RDFStore::Stanford::Resource("http://pen.jrc.it","/index.html");

DESCRIPTION
===========

   This is just the interface definition. If you are more interested to an
example implementation see RDFStore::Resource(3)

   An RDF resource. Every RDF resource must have a URI.  Many RDF
resources are pieces of vocabulary. They typically have a namespace and a
local name. In this case, a URI is composed as a concatenation of the
namespace and the local name. For other kinds of identifiers (e.g.
autogenerated UUIDs), the namespace is undef.

SEE ALSO
========

   RDFStore::Resource(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/SetModel,  Next: RDFStore/Stanford/Statement,  Prev: RDFStore/Stanford/Resource,  Up: Module List

definiton of the SetModel RDF API
*********************************

NAME
====

   RDFStore::Stanford::SetModel - definiton of the SetModel RDF API

SYNOPSIS
========

     use RDFStore::Stanford::SetModel;
             use RDFStore::Stanford::Literal;
             use RDFStore::Stanford::Resource;
             use RDFStore::Stanford::Statement;
             my $set = new RDFStore::Stanford::Model();
             my $obj = new RDFStore::Stanford::Literal("foo");
             my $subj = new RDFStore::Stanford::Literal("http://www.foo.com");
             my $subj1 = new RDFStore::Stanford::Literal("http://www.bar.com");
             my $pred = new RDFStore::Stanford::Literal("http://rdf.dev.oclc.org/eor/2000/02/26-dcv#","creator");
             my $fact= new RDFStore::Stanford::Statement($subj, $pred, $obj);
             my $fact1= new RDFStore::Stanford::Statement($subj1, $pred, $obj);
             $set->add($fact);
             my $result_model = $set->find($fact);
     $set->subtract($fact1);

DESCRIPTION
===========

   This is just the interface definition. If you are more interested to an
example implementation see RDFStore::SetModel(3)

SEE ALSO
========

   RDFStore::SetModel(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Statement,  Next: RDFStore/Stanford/VirtualModel,  Prev: RDFStore/Stanford/SetModel,  Up: Module List

definiton of the Statement RDF API
**********************************

NAME
====

   RDFStore::Stanford::Statement - definiton of the Statement RDF API

SYNOPSIS
========

     use RDFStore::Stanford::Statement;
     use RDFStore::Stanford::Literal;
     use RDFStore::Stanford::Resource;
     my $statement = new RDFStore::Stanford::Statement(
     				new RDFStore::Stanford::Resource("http://pen.jrc.it/idex.html"),
     				new RDFStore::Stanford::Resource("http://rdf.dev.oclc.org/eor/2000/02/26-dcv#","creator"),
     				new RDFStore::Stanford::Literal("Alberto Reggiori")
     				);

DESCRIPTION
===========

   This is just the interface definition. If you are more interested to an
example implementation see RDFStore::Statement(3)

SEE ALSO
========

   RDFStore::Statement(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/VirtualModel,  Next: RDFStore/Stanford/Vocabulary/Generator,  Prev: RDFStore/Stanford/Statement,  Up: Module List

definiton of the VirtualModel RDF API
*************************************

NAME
====

   RDFStore::Stanford::VirtualModel - definiton of the VirtualModel RDF API

SYNOPSIS
========

     use RDFStore::Stanford::VirtualModel;
     my $virtual = new RDFStore::Stanford::VirtualModel();

DESCRIPTION
===========

   This is just the interface definition. If you are more interested to an
example implementation see RDFStore::VirtualModel(3) or
RDFStore::SchemaModel(3)

SEE ALSO
========

   RDFStore::VirtualModel(3) RDFStore::SchemaModel(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Stanford/Vocabulary/Generator,  Next: RDFStore/Statement,  Prev: RDFStore/Stanford/VirtualModel,  Up: Module List

implementation of the Vocabulary Generator RDF API
**************************************************

NAME
====

   RDFStore::Stanford::Vocabulary::Generator - implementation of the
Vocabulary Generator RDF API

SYNOPSIS
========

     use RDFStore::Stanford::Vocabulary::Generator;
     my $generator = new RDFStore::Stanford::Vocabulary::Generator();
     # see vocabulary-generator.pl
     $generator->createVocabulary($packageClass, $all, $namespace, $outputDirectory, $factoryStr);

DESCRIPTION
===========

   Generate Perl packages with constants for resources defined in an RDF
(Schema).

SEE ALSO
========

   RDFStore::Vocabulary::RDF(3) RDFStore::Vocabulary::RDFS(3)
RDFStore::Vocabulary::DC(3) RDFStore::Vocabulary::DAML(3)
RDFStore::SchemaModel(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Statement,  Next: RDFStore/VirtualModel,  Prev: RDFStore/Stanford/Vocabulary/Generator,  Up: Module List

implementation of the Statement RDF API from Sergey Melnik (see http://www-db.stanford.edu/~melnik/rdf/api.html)
****************************************************************************************************************

NAME
====

   RDFStore::Statement - implementation of the Statement RDF API from
Sergey Melnik (see http://www-db.stanford.edu/~melnik/rdf/api.html)

SYNOPSIS
========

     use RDFStore::Statement;
     use RDFStore::Literal;
     use RDFStore::Resource;
     my $statement = new RDFStore::Statement(
     				new RDFStore::Resource("http://pen.jrc.it/idex.html"),
     				new RDFStore::Resource("author","http://purl.org/schema/1.0#"),
     				new RDFStore::Literal("Alberto Reggiori")
     				);

DESCRIPTION
===========

   An RDFStore::Stanford::Statement implementation using Digested URIs.

SEE ALSO
========

   RDFStore::Stanford::Statement(3) Digest(3) RDFStore::RDFNode(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/VirtualModel,  Next: RDFStore/Vocabulary/DC,  Prev: RDFStore/Statement,  Up: Module List

implementation of the VirtualModel RDF API
******************************************

NAME
====

   RDFStore::VirtualModel - implementation of the VirtualModel RDF API

SYNOPSIS
========

     use RDFStore::VirtualModel;
             use RDFStore::NodeFactory;
             use RDFStore::FindIndex;
             use Data::MagicTie;

     my $factory= new RDFStore::NodeFactory();
     my $index_db={};
     tie %{$index_db},"Data::MagicTie",'index/triples',(Q => 20);
     my $index=new RDFStore::FindIndex($index_db);
     my $virtual = new RDFStore::VirtualModel($factory,undef,$index,undef);

DESCRIPTION
===========

   An RDFStore::Stanford::VirtualModel implementation using
RDFStore::Model and Digested URIs.

SEE ALSO
========

   RDFStore::Stanford::VirtualModel(3) RDFStore::Model(3) Digest(3) and
RDFStore::SchemaModel(3)

AUTHOR
======

     Alberto Reggiori <alberto.reggiori@jrc.it>


File: pm.info,  Node: RDFStore/Vocabulary/DC,  Next: RDFStore/Vocabulary/RDF,  Prev: RDFStore/VirtualModel,  Up: Module List

=head1 SYNOPSIS
***************

NAME  	RDFStore::Vocabulary::DC
===============================

SYNOPSIS
========

     use RDFStore::Vocabulary::DC;
     print $DC::Title->toString;

DESCRIPTION
===========

SEE ALSO
========

AUTHOR
======

   Alberto Reggiori <alberto.reggiori@jrc.it>


