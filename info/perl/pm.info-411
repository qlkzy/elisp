This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: VCS/Version,  Next: VMS/FlatFile,  Prev: VCS/PVCS/Project,  Up: Module List

module for access to a VCS version
**********************************

NAME
====

   VCS::Version - module for access to a VCS version

SYNOPSIS
========

     use VCS;
     die "Usage: $0 file version\n" unless @ARGV == 2;
     my $version = VCS::Version->new(@ARGV);
     print "Methods of \$version:\n",
         "name: ", $version->name, "\n",
         "author: ", $version->author, "\n",
         "version: ", $version->version, "\n",
         ;

DESCRIPTION
===========

   VCS::Version abstracts a single revision of a file under version
control.

METHODS
=======

   Methods marked with a "*" are not yet finalised/implemented.

VCS::Version->create_new(@version_args) *
-----------------------------------------

   `@version_args' is a list which will be treated as a hash, with
contents as follow:

     @version_args = (
         name    => 'a file name',
         version => 'an appropriate version identifier',
         tags    => [ 'A_TAG_NAME', 'SECOND_TAG' ],
         author  => 'the author name',
         reason  => 'the reason for the checkin',
         text    => 'either literal text, or a ref to the filename',
     );

   This is a pure virtual method, which must be over-ridden, and cannot be
called directly in this class (a die will result).

VCS::Version->new($file, $version)
----------------------------------

   $file is a filename, absolute or relative. `$version' is a version
number, or tag. Returns an object of class `VCS::Version', or undef if it
fails. Implementation classes must be careful not to return an object
unless they mean it.

$version->name
--------------

   Returns the $file argument to new.

$version->version
-----------------

   Returns the `$version' argument to new.

$version->tags
--------------

   Returns a list of tags applied to this version.

$version->text
--------------

   Returns the text of this version of the file.

$version->diff($other_version)
------------------------------

   Returns the differences (in `diff -u' format) between this version and
the other version. Currently, the other version must also be a
`VCS::Version' object.

$version->author
----------------

   Returns the name of the user who checked in this version.

$version->date
--------------

   Returns the date this version was checked in.

$version->reason
----------------

   Returns the reason given on checking in this version.

SEE ALSO
========

   *Note VCS: VCS,.

COPYRIGHT
=========

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: VMS/FlatFile,  Next: VRML,  Prev: VCS/Version,  Up: Module List

read and write hashes with VMS::IndexedFile.
********************************************

NAME
====

   VMS::FlatFile - read and write hashes with VMS::IndexedFile.

SYNOPSIS
========

Standalone
----------

     # Load the module
     use VMS::FlatFile;

     # Create an instance
     # args - file name, access (ro=0, rw=1), format, key number
     my $file = new VMS::FlatFile 'disk$user01:[user]file.dat', 0,
     			    [ 'field1:a10', 'field2:a16' ], 0;

     # Read a hash
     my $hashref = $file->get($key);
     # Write a hash
     my $sts = $file->put($hashref);
     # Delete a record
     $sts = $file->delete($key);

As a Base Class
---------------

     # name your derived class
     package MyFile;

     # Load the module and derive
     use VMS::FlatFile;
     use var qw(@ISA);
     @ISA = qw(VMS::FlatFile);
     1;

     # override new
     sub new {
         my $class = shift;
     	my $self = {};
     	bless $self,$class;
     	# default to read only
     	my $access = shift || 0;
     	# use key 0
     	my $krf = shift || 0;
     	$self->_initialize('disk:[dir]filename.type', $access,
     		[ 'field1:a10', 'field2:a16' ], $krf);
     	return $self;
     }

     package main;

     # create an instance
     my $file = new MyFile;
     my $hashref = $file->get('keyvalue');

DESCRIPTION
===========

   VMS::FlatFile combines VMS::IndexedFile and Data::FixedFormat to make
it possible to read and write hashes to VMS indexed files.

   First, load the module:

     use VMS::FlatFile;

   Next, create an instance:

     my $file = new VMS::FlatFile 'disk$user01:[user]file.dat', 0,
     			    [ 'field1:a10', 'field2:a16' ], 0;

   The new method accepts four arguments:

filename
     The filename argument is passed directly to VMS::IndexedFile.

access
     If access is true, the file is opened read/write.  If false the file
     is opened read only.

format
     The format argument is used to construct a Data::FixedFormat instance
     for the file.  This argument is passed directly to
     Data::FixedFormat::new.

key of reference
     This argument is passed to VMS::IndexedFile to select a key of
     reference.  If not specified or if specified as 0, the file's primary
     key is used.  Specify 1 for the first alternate key, etc.

   To read records, use the get method:

     my $hashref = $file->get($key);

   get returns a reference to a hash created by
Data::FixedFormat::unformat.

   get accepts one argument which is the key of the record to be read.  If
specified as the null string, the next sequential record is read from the
file.

   To write records, use the put method:

     my $sts = $file->put($hashref);

   The status returned by put comes from VMS::IndexedFile::store.  The
lone argument is a reference to a hash which is converted into a file
buffer with Data::FixedFormat::format and written to the file.

   To delete records, use the delete method:

     my $sts = $file->delete($key);

   The record with the specified key value will be deleted from the file.

   The easiest way to use VMS::FlatFile as a base class would be to write a
derived module that provides the filename and format arguments for each
file you need to access.  To do this, override the new method with a
routine like the following:

     package MyFile;
     use VMS::FlatFile;
     use vars qw(@ISA);
     @ISA = qw(VMS::FlatFile);

     sub new {
         my $class = shift;
     	my $self = {};
     	bless $self,$class;
     	# default to read only
     	my $access = shift || 0;
     	# use key 0
     	my $krf = shift || 0;
     	$self->_initialize('disk:[dir]filename.type', $access,
     		[ 'field1:a10', 'field2:a16' ], $krf);
     	return $self;
     }

   The _initialize routine takes the same arguments as new.  This new
constructor takes two arguments; the access mode (true for read/write) and
the key of reference.

   VMS::FlatFile instances contain the attributes:

File
     This is the hash bound to the file with tie.  Records are read from
     the file by reading attributes (i.e., file keys) from this hash.

Handle
     This attribute receives the result from the call to tie which
     connects the VMS file to the hash.

Formatter
     The Formatter attribute is an instance of a Data::FixedFormat which is
     used for converting between file records and hashes.

AUTHOR
======

   VMS::FlatFile was written by Thomas Pfau <pfau@eclipse.net>
http://www.eclipse.net/~pfau/.

COPYRIGHT
=========

   Copyright (C) 2000 Thomas Pfau.  All rights reserved.

   This module is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

   This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
License for more details.

   You should have received a copy of the GNU General Public License along
with this progam; if not, write to the Free Software Foundation, Inc., 59
Temple Place - Suite 330, Boston, MA 02111-1307, USA.


File: pm.info,  Node: VRML,  Next: VRML/Base,  Prev: VMS/FlatFile,  Up: Module List

Specification independent VRML methods (1.0, 2.0, 97)
*****************************************************

NAME
====

   VRML - Specification independent VRML methods (1.0, 2.0, 97)

SYNOPSIS
========

     use VRML;

     $vrml = new VRML(2);
     $vrml->browser('Cosmo Player 2.0','Netscape');
     $vrml->at('-15 0 20');
     $vrml->box('5 3 1','yellow');
     $vrml->back;
     $vrml->print;
     $vrml->save;

     OR with the same result

     use VRML;

     VRML->new(2)
     ->browser('Cosmo Player 2.0','Netscape')
     ->at('-15 0 20')->box('5 3 1','yellow')->back
     ->print->save;

DESCRIPTION
===========

   These modules were conceived for the production of VRML worlds on WWW
servers via GCI and/or for generating abstract worlds. They are the
clarity of Perl scripts with VRML code to increase and (hopefully) for
VRML beginners the entrance in VRML facilitate. In the following the
modules are described briefly.

VRML::Base
     contains base functionality such as a producing, an outputting and
     saving. It represents the base class for all other modules

VRML::VRML1
     combines several VRML 1.0 nodes into complex methods - e.g. geometric
     shapes inclusive there material. This module accepts angle data in
     degrees and as material color names. The methods have the same names
     as in the VRML specification (if meaningfully), are however in lower
     case.

VRML::VRML1::Standard
     implemented only the VRML 1.0 nodes. All method names are identical
     (in the way of writing) with those of the VRML specification. The
     parameters are arranged after the frequency of their use (subjective
     estimate). This module is possibly omitted in the next version. The
     production of the VRML nodes takes over then VRML::Base.

VRML::VRML2
     combines several VRML 2.0 nodes into complex methods - e.g. geometric
     shapes inclusive there material. This module accepts angle data in
     degrees and as material color names. The methods have the same names
     as in the VRML specification (if meaningfully), are however in lower
     case. The names are also as far as possible identical to those of the
     module VRML::VRML1. Thus the user between the VRML versions which can
     be produced can switch.

     Contains for example $in{VRML} '1' or '2' (e.g. via CGI), then only
     the following line at the start of the Perl script must be inserted.

          new VRML($in{'VRML'})

VRML::VRML2::Standard
     implemented only the VRML 2.0 nodes. All method names are identical
     (in the way of writing) with those the VRML specification. The
     parameters are arranged after the frequency of their use (subjective
     estimate) This module is possibly omitted in the next version. The
     production of the VRML nodes takes over then VRML::Base.

VRML::Color
     contains the color names and conversion functions.

   The VRML methods are at present identically in the modules
VRML::VRML1.pm and VRML::VRML2.pm implemented. The basic methods like new,
print or save are in the module VRML::Base described.

DESCRIPTION
===========

   The methods of this module are easier to use than the VRML::*::Standard
methods because the methods are on a higher level. For example you can use
X11 color names and it's simple to apply textures to an object. All angles
could be assigned in degrees.

   If a method does the same like its VRML pedant then it has the same
name but in lowercase (e.g. box). The open part of a group method ends
with a _begin (e.g. anchor_begin). The closing part ends with an _end (e.g.
anchor_end). For a detailed description how the generated node works, take
a look at the VRML 2.0 specification on VAG.

   Following methods are currently implemented. (Values in '...' must be
strings!)

Groups
------

begin
     `begin('comment')'

     Before you use an geometry or transform method please call this
     method.  It's necessary to calculate something at the end.

     Example:

          new VRML
          ->begin
            ->at('0 0.1 -0.3')
          	->sphere(1,'red')
            ->back
          ->end
          ->print;

end
     `end('comment')'

     After end there should no geometry or transformation. This method
     completes the calculations of viewpoints etc.

at('type=value','type=value', ...)
     is the short version of the method transform_begin. It has the same
     parameters as transform_begin.

     Example:

          $vrml
          ->at('0 2 0')
            ->sphere(0.5,'red')
          ->back

back
     is the short version of the method transform_end.

anchor_begin
     `anchor_begin('url', 'description', 'parameter', 'bboxSize',
     'bboxCenter')'

          url         MFString []
          description SFString ""
          parameter   MFString []
          bboxSize    SFVec3f  undef
          bboxCenter  SFVec3f  '0 0 0'

     Example:

          $vrml
          ->anchor_begin('http://www.gfz-potsdam.de/~palm/vrmlperl/',
            'VRML-Perl Moduls', 'target=_blank')
            ->sphere(1,'blue')
          ->anchor_end;

anchor_end
     close anchor_begin.

billboard_begin
     `billboard_begin('axisOfRotation', 'bboxSize', 'bboxCenter')'

          axisOfRotation  SFVec3f  '0 1 0'
          bboxSize        SFVec3f  undef
          bboxCenter      SFVec3f  '0 0 0'

billboard_end
     close billboard_begin.

collision_begin
     `collision_begin(collide, proxy, 'bboxSize', 'bboxCenter')'

          collide    SFBool  1
          proxy      SFNode  NULL
          bboxSize   SFVec3f undef
          bboxCenter SFVec3f '0 0 0'

     Example:

          $vrml
          ->collision_begin(1, sub{$vrml->box('5 1 0.01')})
            ->text('collide','yellow',1,'MIDDLE')
          ->collision_end

collision_end
     close collision_begin.

group_begin('comment')
     Example:

          $vrml
          ->group_begin
            ->sphere(1,'red')
          ->group_end

group_end
     close `group_begin'.

lod_begin
     `lod_begin('range', 'center')'

          range  MFFloat []
          center SFVec3f '0 0 0'

     Example:

          $vrml
          ->lod_begin('30')
            ->text('gut lesbar')
            ->group_begin->group_end # leere Gruppe
          ->lod_end

lod_end
     close lod_begin.

switch_begin
     `switch_begin(whichChoice)'

          whichChoice SFInt32 -1

switch_end
     close switch_begin.

transform_begin
     F<transform_begin('type=value','type=value', ...)

     *Where type can be:*

          t = translation
          r = rotation
          c = center
          s = scale
          so = scaleOrientation
          bbs = bboxSize
          bbc = bboxCenter

     Example:

          $vrml
          ->transform_begin('t=0 1 0','r=180')
            ->cone('0.5 2','red')
          ->transform_end

transform_end
     close transform_begin.

inline
     `inline('url', 'bboxSize', 'bboxCenter')'

          url        MFString []
          bboxSize   SFVec3f  undef
          bboxCenter SFVec3f  '0 0 0'

Independent Methods
-------------------

background
     `background( frontUrl => '...', leftUrl => '...', rightUrl => '...',
     backUrl => '...', bottomUrl => '...', topUrl => '...', skyColor =>
     '...', skyAngle => '...', groundColor => '...', groundAngle => '...'
     )'

          frontUrl    MFString []
          leftUrl     MFString []
          rightUrl    MFString []
          backUrl     MFString []
          bottomUrl   MFString []
          topUrl      MFString []
          skyColor    MFColor  ['0 0 0']
          skyAngle    MFFloat  []
          groundColor MFColor  []
          groundAngle MFFloat  []

     This is a parameter hash. Only use the parts you need.

     Example:

          $vrml->background(skyColor => 'lightblue',
                            frontUrl => 'http://www.yourdomain.de/bg/berge.gif');

backgroundcolor
     `backgroundcolor('skyColor', 'groundColor')'

          skyColor     SFColor  '0 0 0'
          groundColor  SFColor  '0 0 0'

     is the short version of background. It specifies only colors.

     Example:

          $vrml->backgroundcolor('lightblue');

backgroundimage
     `backgroundimage('url')'

          url SFString ""

     is the short version of background. It needs only one image. The
     given Url will assigned to all parts of the background cube.

     Example:

          $vrml->backgroundimage('http://www.yourdomain.de/bg/sterne.gif');

title
     `title('string')'

          string SFString ""

     Example:

          $vrml->title('Meine virtuelle Welt');

info
     `info('string')'

          string MFString []

     Example:

          $vrml->info('letzte Änderung: 8.05.1997');

worldinfo
     `worldinfo('title', 'info')'

          title  SFString ""
          info   MFString []

     combines title and info.

navigationinfo
     `navigationinfo('type', speed, headlight, visibilityLimit,
     avatarSize)'

          type         MFEnum     ['WALK', 'ANY'] # ANY, WALK, FLY, EXAMINE, NONE
          speed        SFFloat    1.0
          headlight    SFBool     1
          visibilityLimit SFFloat 0.0
          avatarSize   MFFloat    [0.25, 1.6, 0.75]

     Example:

          $vrml->navigationinfo('WALK', 1.5, 0, 1000);

viewpoint_begin
     starts the hidden calculation of viewpoint center and distance for the
     method `viewpoint_auto_set()'. It collects also the viepoints to place
     they in the first part of the VRML source.

viewpoint
     `viewpoint('description', 'position', 'orientation', fieldOfView,
     jump)'

          description SFString          ""
          position    SFVec3f           0 0 10
          orientation SFRotation/SFEnum 0 0 1 0 # FRONT, LEFT, BACK, RIGHT, TOP, BOTTOM
          fieldOfView SFFloat           45 # Grad
          jump        SFBool            1

     Example:

          $vrml->viewpoint('Start','0 0 0','0 0 -1 0',60);

     is the same like

          $vrml->viewpoint('Start',undef,'FRONT',60);

viewpoint_set
     `viewpoint_set('center', distance, fieldOfView, avatarSize)'

          center       SFVec3f '0 0 0'
          distance     SFFloat 10
          fieldOfView  SFFloat 45 # Grad
          avatarSize   MFFloat [0.25, 1.6, 0.75]

     places six viewpoints around the center.

viewpoint_auto_set
     sets all parameters of viewpoint_set automatically.

viewpoint_end
     close viewpoint_begin.

Shapes
------

box
     `box('size', 'appearance')'

          size       SFVec3f  '2 2 2' # width height depth
          appearance SFString ""      # see Appearance

cone
     `cone('bottomRadius height', 'appearance')'

          bottomRadius height SFVec2f '1 2'
          appearance          SFString "" # see Appearance

cylinder
     `cylinder('radius height', 'appearance')'

          radius height SFVec2f  '1 2'
          appearance    SFString "" # see Appearance

line
     `line('from', 'to', radius, 'appearance', 'path')'

          from        SFVec3f   ""
          to          SFVec3f   ""
          radius      SFFloat   0 # 0 = haarline
          appearance  SFString  ""
          path        SFEnum    "" # XYZ, XZY, YXZ, YZX, ZXY, ZYX

     draws a line (cylinder) between two points with a given radius. If
     radius is '0' only a hairline will be printed. The last parameter
     specifies the devolution along the axes. An empty stands for direct
     connection.

     Example:

          new VRML(2)
          ->begin
            ->line('1 -1 1', '-3 2 2', 0.03, 'red', 'XZY')
            ->line('1 -1 1', '-3 2 2', 0.03, 'white')
          ->end
          ->print;

pyramid
     `pyramid('size', 'appearance')'

          size       SFVec3f  '2 2 2' # width height depth
          appearance SFString ""      # see Appearance

     Example:

          $vrml->pyramid('1 1 1','blue,green,red,yellow,white');

sphere
     `sphere(radius, 'appearance')'

          radius     SFFloat  1
          appearance SFString "" # see Appearance

elevationgrid
     `elevationgrid(height, color, xDimension, zDimension, xSpacing,
     zSpacing, creaseAngle, colorPerVertex, solid)'

          height          MFFloat  []
          color           MFColor  [] # resp. material and color
          xDimension      SFInt32  0
          zDimension      SFInt32  0
          xSpacing        SFFloat  1.0
          zSpacing        SFFloat  1.0
          creaseAngle     SFFloat  0
          colorPerVertex	 SFBool   1
          solid           SFBool   0

     If color is not a reference of an ARRAY it would be assumed that color
     is the appearance.

     Example:

          open(FILE,"<height.txt");
          my @height = <FILE>;
          open(COL,"<color.txt");
          my @color = <COL>;
          $vrml->navigationinfo(["EXAMINE","FLY"],200)
               ->viewpoint("Top","1900 6000 1900","TOP")
               ->elevationgrid(\@height, \@color, undef, undef, 250, undef, 0)
          	 ->print;

text
     `text('string', 'appearance', 'font', 'align')'

          string     MFString []
          appearance SFString "" # see Appearance
          font       SFString '1 SERIF PLAIN'
          align      SFEnum   'BEGIN' # BEGIN, MIDDLE, END

billtext
     `billtext('string', 'appearance', 'font', 'align')'

          string     MFString []
          appearance SFString "" # see Appearance
          font       SFString '1 SERIF PLAIN'
          align      SFEnum   'BEGIN' # BEGIN, MIDDLE, END

     does the same like method text, but the text better readable.

Appearance
     `appearance('type=value1,value2 ; type=...')'

     The appearance method specifies the visual properties of geometry by
     defining the material and texture. If more than one type is needed
     separate the types by semicolon. The types can choosen from the
     following list.

     Note: one character mnemonic are colors       two characters mnemonic
     are values in range of [0..1]       more characters are strings like
     file names or labels

          d = diffuseColor
          e = emissiveColor
          s = specularColor
          ai = ambientIntensity
          sh = shininess
          tr = transparency
          tex = texture filename,wrapS,wrapT
          name = names the MovieTexture node (for a later route)

     The color values can be strings (X11 color names) or RGB-triples. It
     is possible to reduce the intensity of colors (names) by appending a
     two digit value (percent). This value must be separated by an
     underscore (_) or a percent symbol (%). Note: Do not use a percent
     symbol in URL's. It would be decoded in an ascii character.

     Sample (valid color values): 	'1 1 0' # VRML standard 	'FFFF00'
     or 'ffff00', '255 255 0', 'yellow'

     or reduced to 50% 	'.5 .5 .5' # VRML standard 	'808080', '128 128 0',
     'yellow%50' or 'yellow_50'

     For a list of *X11 color names* take a look at VRML::Color

Misc
----

directionallight
     `directionallight('direction', intensity, ambientIntensity, 'color',
     on)'

          direction         SFVec3f  '0 0 -1'
          intensity         SFFloat  1
          ambientIntensity  SFFloat  1
          color             SFColor  '1 1 1' #weiß
          on                SFBool   1

     Example:

          $vrml->directionallight("0 0 -1", 0.3);

sound
     `sound('url','description', 'location', 'direction', intensity, loop,
     pitch)'

          url         MFString []
          description SFString ""
          location    SFVec3f  '0 0 0'
          direction   SFVec3f  '0 0 1'
          intensity   SFFloat  1.0
          loop        SFBool   0
          pitch       SFFloat  1.0

def
     `def('name')'

          name SFString ""

     Example:

          $vrml->def('RedSphere')->sphere(1,'red')

use
     `use('name')'

          name SFString ""

     Example:

          $vrml->use('RedSphere')

route
     `route('from','to')'

          FROM.feldname SFString ""
          TO.feldname   SFString ""

Interpolators
-------------

interpolator
     `interpolator('name','type',[keys],[keyValues])'

          name      SFString ""
          type      SFEnum   "" # Color, Coordinate, Normal, Orientation,
                                # Position und Scalar
          keys      MFFloat  [] # [0,1]
          keyValues MF...    [] # Type of Interpolator

Sensors
-------

cylindersensor








     `cylindersensor('name',maxAngle,minAngle,diskAngle,offset,autoOffset,enabled)'

          name       SFString ""
          maxAngle   SFFloat  undef
          minAngle   SFFloat  0
          diskAngle  SFFloat  15
          offset     SFFloat  0
          autoOffset SFBool   1
          enabled    SFBool   1

planesensor

     `planesensor('name',maxPosition,minPosition,offset,autoOffset,enabled)'

          name         SFString  ""
          maxPosition  SFVec2f  undef
          minPosition  SFVec2f  '0 0'
          offset       SFVec3f  '0 0 0'
          autoOffset   SFBool  1
          enabled      SFBool  1

proximitysensor
     `proximitysensor('name',size,center,enabled)'

          name    SFString ""
          size    SFVec3f  '0 0 0'
          center  SFVec3f  '0 0 0'
          enabled SFBool   1

spheresensor
     `spheresensor('name',offset,autoOffset,enabled)'

          name       SFString   ""
          offset     SFRotation '0 1 0 0'
          autoOffset SFBool     1
          enabled    SFBool     1

timesensor
     `timesensor('name',cycleInterval,loop,startTime,stopTime,enabled)'

          name          SFString ""
          cycleInterval SFFloat  1
          loop          SFBool   0
          startTime     SFFloat  0
          stopTime      SFFloat  0
          enabled       SFBool   1

touchsensor
     `touchsensor('name',enabled)'

          name    SFString ""
          enabled SFBool   1

     Example:

          $vrml
          ->begin
          	->touchsensor('Switch')
          	->sphere(1,'white')
          	->def('Light')->directionallight("", 1, 0, 'red', 0)
          	->route('Switch.isActive', 'Light.on')
          ->end
          ->print->save;

visibitysensor
     `visibitysensor('name',size,center,enabled)'

          name    SFString ""
          size    SFVec3f  '0 0 0'
          center  SFVec3f  '0 0 0'
          enabled SFBool   1

SEE ALSO
========

   VRML

   VRML::VRML2::Standard

   VRML::Base

   http://www.gfz-potsdam.de/~palm/vrmlperl/ for a description of
`VRML-modules' and how to obtain it.

AUTHOR
======

   Hartmut Palm `<palm@gfz-potsdam.de>'

   Homepage http://www.gfz-potsdam.de/~palm/


File: pm.info,  Node: VRML/Base,  Next: VRML/Browser,  Prev: VRML,  Up: Module List

common basic methods for VRML in/output
***************************************

NAME
====

   VRML::Base.pm - common basic methods for VRML in/output

SYNOPSIS
========

     use VRML::Base;

DESCRIPTION
===========

   Following methods are implemented.

new
     new

     Creates a new VRML scene object.

comment
     `comment('string')'

     Inserts a single comment line at the current position.  You don't
     need to write the # in front. If no string is given, the method
     inserts only a #.

insert
     `insert('string')'

     Inserts the string at the current position in the VRML scene.

insert__DATA__
     `insert__DATA__()'

     Inserts the text block after __DATA__ of the current perl script in
     the VRML scene. Remember there are two underscores in front and at
     the end of the word DATA.

include
     `include('filename')'

     Inserts the VRML code of the specified file in the current scene.

print
     `print('mime', 'pipe')'

     Prints the VRML scene to STDOUT. If *mime* (bool) is given, this
     method prints the scene to STDOUT with the Content-type of the
     current scene. If pipe is given, then first the stream is send to the
     pipe and after that to STDOUT. This is usefull to compress the VRML
     code with GNU-ZIP.

     Example:

     1.  *$vrml->print*

     2.  *$vrml->print(1, 'gzip -f9')*

save
     `save('filename', 'pipe')'

     Saves the VRML code to the specified name in filename. If no filename
     is given, this method uses the name of the perl script and changes
     the extension against `.wrl'. If pipe is given, then first the stream
     is send to the pipe and after that to STDOUT. This is usefull to
     compress the VRML code with GNU-ZIP.

     Example:

     1.  *$vrml->save*

     2.  *$vrml->save(undef, 'gzip -f9')*

     3.  *$vrml->save('myScene.wrl')*

as_string
     as_string

     Returns the VRML scene as string. Possible it uses too much memory to
     build the string.

Internals
=========

   You don't need the following 'native' methods.  If yet, tell it me and
I'll describe it in the next version.

debug
     debug

_init
     `_init('VRML')'

_add
     _add

_trim
     _trim

_swap
     _swap

_put
     _put

_row
     _row

_pos
     _pos

_format
     _format

AUTHOR
======

   Hartmut Palm `<palm@gfz-potsdam.de>'


File: pm.info,  Node: VRML/Browser,  Next: VRML/Color,  Prev: VRML/Base,  Up: Module List

perl module to implement a VRML97 browser
*****************************************

NAME
====

   VRML::Browser - perl module to implement a VRML97 browser

SYNOPSIS
========

   Use the command-line interface (`freewrl' in this node), or inside Perl:

     use VRML::Browser;

     $b = VRML::Browser->new();

     $b->load_file($url);
     $b->load_file($url,$base_url);
     $b->load_string("Shape { geometry ....", $base_url);

     $b->eventloop();

     # VRML Browser API
     $name = 	$b->getName();
     $version = 	$b->getVersion();
     $speed =	$b->getCurrentSpeed();
     ...

     # The rest of the API may still change and is not documented
     # here. If you need to know, check the file Browser.pm

DESCRIPTION
===========

   This module implements a VRML browser. The actual module is of interest
only if you are planning to use the code from Perl.

   For information on the user interface, see *Note VRML/Viewer:
VRML/Viewer,.

AUTHOR
======

   See `freewrl' in this node.


File: pm.info,  Node: VRML/Color,  Next: VRML/VRML1,  Prev: VRML/Browser,  Up: Module List

color functions and X11 color names
***********************************

NAME
====

   Color.pm - color functions and X11 color names

SYNOPSIS
========

     use VRML::Color;

     my $color = rgb_color('red');

     or with the same result

     my $color = rgb_color('FF0000');

     or with the same result

     my $color = rgb_color('255 0 0');

     naturally works

     my $color = rgb_color('1 0 0');

DESCRIPTION
===========

   *X11 colornames are:*

     aliceblue
     antiquewhite
     aqua
     aquamarine
     azure
     beige
     bisque
     black
     blanchedalmond
     blue
     blueviolet
     brown
     burlywood
     cadetblue
     chartreuse
     chocolate
     coral
     cornflowerblue
     cornsilk
     crimson
     cyan
     darkblue
     darkcyan
     darkgoldenrod
     darkgray
     darkgreen
     darkkhaki
     darkmagenta
     darkolivegreen
     darkorange
     darkorchid
     darkred
     darksalmon
     darkseagreen
     darkslateblue
     darkslategray
     darkturquoise
     darkviolet
     deeppink
     deepskyblue
     dimgray
     dodgerblue
     firebrick
     floralwhite
     forestgreen
     fuchsia
     gainsboro
     ghostwhite
     gold
     goldenrod
     gray
     green
     greenyellow
     honeydew
     hotpink
     indianred
     indigo
     ivory
     khaki
     lavender
     lavenderblush
     lawngreen
     lemonchiffon
     lightblue
     lightcoral
     lightcyan
     lightgoldenrodyellow
     lightgreen
     lightgrey
     lightpink
     lightsalmon
     lightseagreen
     lightskyblue
     lightslategray
     lightsteelblue
     lightyellow
     lime
     limegreen
     linen
     magenta
     maroon
     mediumaquamarine
     mediumblue
     mediumorchid
     mediumpurple
     mediumseagreen
     mediumslateblue
     mediumspringgreen
     mediumturquoise
     mediumvioletred
     midnightblue
     mintcream
     mistyrose
     moccasin
     navajowhite
     navy
     oldlace
     olive
     olivedrab
     orange
     orangered
     orchid
     palegoldenrod
     palegreen
     paleturquoise
     palevioletred
     papayawhip
     peachpuff
     peru
     pink
     plum
     powderblue
     purple
     red
     rosybrown
     royalblue
     saddlebrown
     salmon
     sandybrown
     seagreen
     seashell
     sienna
     silver
     skyblue
     slateblue
     slategray
     snow
     springgreen
     steelblue
     tan
     teal
     thistle
     tomato
     turquoise
     violet
     wheat
     white
     whitesmoke
     yellow
     yellowgreen

   You can also use

     red_40 = '0.4 0 0'
     yellow%30 = '0.3 0.3 0'
     gray%30 = '0.7 0.7 0.7' !!!

BUGS
====

   X11-green is 0x008000. In VRML it should be 0x00FF00.  This module will
set 'green' to '0 1 0' instead of '0 0.5 0'.

SEE ALSO
========

   http://www.gfz-potsdam.de/~palm/vrmlperl/ for a description of
`VRML-modules' and how to obtain it.

AUTHOR
======

   Hartmut Palm `<palm@gfz-potsdam.de>'

   Homepage http://www.gfz-potsdam.de/~palm/


File: pm.info,  Node: VRML/VRML1,  Next: VRML/VRML1/Standard,  Prev: VRML/Color,  Up: Module List

VRML methods with the VRML 1.0 standard
***************************************

NAME
====

   VRML::VRML1.pm - VRML methods with the VRML 1.0 standard

SYNOPSIS
========

     use VRML::VRML1;

     $vrml = new VRML::VRML1;
     $vrml->browser('Cosmo Player 2.0','Netscape');
     $vrml->at('-15 0 20');
     $vrml->box('5 3 1','yellow');
     $vrml->back;
     $vrml->print;
     $vrml->save;

     OR with the same result

     use VRML::VRML1;

     VRML::VRML1->new
     ->browser('Cosmo Player 2.0','Netscape')
     ->at('-15 0 20')->box('5 3 1','yellow')->back
     ->print->save;

DESCRIPTION
===========

   The methods are identically implemented in VRML::VRML1 and VRML::VRML2.
They described in modul VRML.

SEE ALSO
========

   VRML

   VRML::Base

   VRML::Color

   http://www.gfz-potsdam.de/~palm/vrmlperl/ for a description of
`VRML-modules' and how to obtain it.

AUTHOR
======

   Hartmut Palm `<palm@gfz-potsdam.de>'

   Homepage http://www.gfz-potsdam.de/~palm/


File: pm.info,  Node: VRML/VRML1/Standard,  Next: VRML/VRML2,  Prev: VRML/VRML1,  Up: Module List

implements the VRML 1.x standard nodes
**************************************

NAME
====

   VRML::VRML1::Standard.pm - implements the VRML 1.x standard nodes

SYNOPSIS
========

     use VRML::VRML1::Standard;

DESCRIPTION
===========

   Following nodes are currently implemented.

   [Group Nodes] [Geometry Nodes] [Property Nodes]

   [Appearance Nodes] [Transform Nodes] [Common Nodes]

Group Nodes
-----------

   *These nodes NEED* End !

Group
     `Group()'

Separator
     `Separator()'

Switch
     `Switch($whichChild)'

WWWAnchor
     `WWWAnchor($url, $description, $target)'

     $target works only with some browsers

LOD
     `LOD($range, $center)'

     $range  = MFFloat

     $center = SFVec3f

     example: `LOD([1, 2, 5], '0 0 0')'

SpinGroup
     `SpinGroup($rotation, $local)' is supported only by some browsers

Geometry Nodes
--------------

AsciiText
     `AsciiText($string, $width, $justification, $spacing)'

     $justification is a string ('LEFT','CENTER','RIGHT')

Cone
     `Cone($radius, $height, @parts)'

     @parts is an array of strings ('SIDES', 'BOTTOM', 'ALL')

Cube
     `Cube($width, $height, $depth)'

Cylinder
     `Cylinder($radius, $height, @parts)'

     @parts is a list of strings ('SIDES', 'TOP', 'BOTTOM', 'ALL')

IndexedFaceSet
     `IndexedFaceSet($coordIndex_ref, $materialIndex_ref,
     $normalIndex_ref, $textureCoordIndex_ref)'

     $coordIndex_ref is a reference of a list of point index strings like
     `['0 1 3 2', '2 3 5 4', ...]'

     $materialIndex_ref is a reference of a list of materials

     $normalIndex_ref is a reference of a list of normals

     $textureCoordIndex_ref is a reference of a list of textures

IndexedLineSet
     `IndexedLineSet($coordIndex_ref, $materialIndex_ref,
     $normalIndex_ref, $textureCoordIndex_ref)'

     $coordIndex_ref is a reference of a list of point index strings like
     `['0 1 3 2', '2 3 5 4', ...]'

     $materialIndex_ref is a reference of a list of materials

     $normalIndex_ref is a reference of a list of normals

     $textureCoordIndex_ref is a reference of a list of textures

PointSet
     `PointSet($numPoints, $startIndex)'

Sphere
     `Sphere($radius)'

     $radius have to be > 0

Property Nodes
--------------

Coordinate3
     `Coordinate3(@points)'

     @points is a list of points with strings like `'1.0 0.0 0.0', '-1 2
     0''

Fontstyle
     `FontStyle($size, $family, $style)' defines the current font style
     for all subsequent AsciiText Nodes

     $familiy can be 'SERIF','SANS','TYPEWRITER'

     $style can be 'NONE','BOLD','ITALIC'

Appearance Nodes
----------------

Material
     `Material(%materials)'

MaterialBinding
     `MaterialBinding($value)'

     $value can be

          DEFAULT	Use default bindng
          OVERALL	Whole object has same material
          PER_PART	One material for each part of object
          PER_PART_INDEXED	One material for each part, indexed
          PER_FACE	One material for each face of object
          PER_FACE_INDEXED	One material for each face, indexed
          PER_VERTEX	One material for each vertex of object
          PER_VERTEX_INDEXED	One material for each vertex, indexed

Normal
     `Normal(@vector)'

     @vector is a list of vectors with strings like `'1.0 0.0 0.0', '.5 .2
     0''

NormalBinding
     `NormalBinding($value)'

     $value is the same as MaterialBinding

Texture2
     `Texture2($value)'

Transform Nodes
---------------

Transform
     `Transform($translation, $rotation, $scaleFactor, $scaleOrientation,
     $center)'

     $translation is a string like "0 1 -2"

     $rotation is a string like "0 0 1 1.57"

     $scaleFactor is a string like "1 1 1"

     $scaleOrientation is a string like "0 0 1 0"

     $center is a string like "0 0 0"

Rotation
     `Rotation($rotation)'

     $rotation is a string like "0 0 1 1.57"

     `This node is not supported under VRML 2.0. Use Transform'

Scale
     `Scale($scaleFactor)'

     $scaleFactor is a string like "1 1 1"

     `This node is not supported under VRML 2.0. Use Transform'

Translation
     `Translation($translation)'

     $translation is a string like "0 1 -2"

     `This node is not supported under VRML 2.0. Use Transform'

Common Nodes
------------

PerspectiveCamera
     `PerspectiveCamera($position, $orientation, $heightAngle,
     $focalDistance, $nearDistance, $farDistance)'

OrthographicCamera
     `OrthographicCamera($position, $orientation, $height, $focalDistance,
     $nearDistance, $farDistance)'

DirectionalLight
     `DirectionalLight($direction, $intensity, $color, $on)'

PointLight
     `PointLight($location, $intensity, $color, $on)'

SpotLight
     `SpotLight($location, $direction, $intensity, $color, $on)'

DirectedSound
     `DirectedSound($name, $description, $location, $direction,
     $intensity, $maxFrontRange, $maxBackRange, $minFrontRange,
     $minBackRange, $loop, $pause)'

other
-----

WWWInline
     `WWWInline($name, $bboxSize, $bboxCenter)'

Info
     `Info($string)'

NavigationInfo
     `NavigationInfo($type, $speed, $headlight)'

     Works only with Live3D and WebFX

USE
     `USE($name)'

DEF
     `DEF($name)'

SEE ALSO
========

   VRML::VRML1::Standard

   VRML::Base

   http://www.gfz-potsdam.de/~palm/vrmlperl/ for a description of
`VRML-modules' and how to obtain it.

AUTHOR
======

   Hartmut Palm `<palm@gfz-potsdam.de>'

   Homepage http://www.gfz-potsdam.de/~palm/


File: pm.info,  Node: VRML/VRML2,  Next: VRML/VRML2/Standard,  Prev: VRML/VRML1/Standard,  Up: Module List

VRML methods with the VRML 2.0/97 standard
******************************************

NAME
====

   VRML::VRML2 - VRML methods with the VRML 2.0/97 standard

SYNOPSIS
========

     use VRML::VRML2;

     $vrml = new VRML::VRML2;
     $vrml->browser('Cosmo Player 2.0','Netscape');
     $vrml->at('-15 0 20');
     $vrml->box('5 3 1','yellow');
     $vrml->back;
     $vrml->print;
     $vrml->save;

     OR with the same result

     use VRML::VRML2;

     VRML::VRML2->new
     ->browser('Cosmo Player 2.0','Netscape')
     ->at('-15 0 20')->box('5 3 1','yellow')->back
     ->print->save;

DESCRIPTION
===========

   The methods are identically implemented in VRML::VRML1 and VRML::VRML2.
They described in modul VRML.

SEE ALSO
========

   VRML

   VRML::Base

   VRML::Color

   http://www.gfz-potsdam.de/~palm/vrmlperl/ for a description of
`VRML-modules' and how to obtain it.

AUTHOR
======

   Hartmut Palm `<palm@gfz-potsdam.de>'

   Homepage http://www.gfz-potsdam.de/~palm/


File: pm.info,  Node: VRML/VRML2/Standard,  Next: VRML/Viewer,  Prev: VRML/VRML2,  Up: Module List

implements VRML 2.0/97 standard nodes
*************************************

NAME
====

   VRML::VRML2::Standard.pm - implements VRML 2.0/97 standard nodes

SYNOPSIS
========

     use VRML::VRML2::Standard;

DESCRIPTION
===========

   Following nodes are currently implemented.

   [Grouping Nodes] [Special Groups] [Common Nodes]

   [Geometry] [Geometric Properties] [Appearance]

   [Sensors] [Interpolators] [Bindable Nodes]

Grouping Nodes
--------------

   These nodes *NEED* End if the $children parameter is empty !

Anchor
     `Anchor($url, $description, $parameter, $bboxSize, $bboxCenter,
     $children)'

     Currently only the first part of *$parameter* is supported.

Billboard
     `Billboard($axisOfRotation, $children)'

Collision
     `Collision($collide, $proxy, $children)'

Group
     `Group($bboxSize, $bboxCenter)'

Transform
     `Transform($translation, $rotation, $scale, $scaleOrientation,
     $center, $bboxSize, $bboxCenter)'

     $translation is a SFVec3f

     $rotation is a SFRotation

     $scale is a SFVec3f

     $scaleOrientation is a SFRotation

     $center is a SFVec3f

Special Groups
--------------

Inline
     `Inline($url, $bboxSize, $bboxCenter)'

LOD
     `LOD($range, $center)'

     $range is a MFFloat

     $center is a SFVec3f

     Example: `LOD([1, 2, 5], '0 0 0')'

Switch
     `Switch($whichChoice)'

Common Nodes
------------

DirectionalLight
     `DirectionalLight($direction, $intensity, $ambientIntensity, $color,
     $on)'

PointLight
     `PointLight($location, $intensity, $ambientIntensity, $color, $on)'

SpotLight
     `SpotLight($location, $direction, $intensity, $color, $on)'

Sound
     `Sound($source, $location, $direction, $intensity, $maxFront,
     $maxBack, $minFront, $minBack, $priority, $spatialize)'

AudioClip
     `AudioClip($url, $description, $loop, $pitch, $startTime, $stopTime)'

WorldInfo
     `WorldInfo($title, $info)'

Shape
     `Shape($geometry, $appearance)'

Geometry
--------

Box
     `Box($size)'

Cone
     `Cone($radius, $height, $side, $bottom)'

Cylinder
     `Cylinder($radius, $height, $top, $side, $bottom)'

ElevationGrid
     `ElevationGrid($xDimension, $zDimension, $xSpacing, $zSpacing,
     $height, $creaseAngle, $color, $colorPerVertex, $solid)'

     $height should be a reference of a list of height values like `['0 1
     3 2', '2 3 5 4', ...]'

     $color should be a reference to a subroutine or list of color values

Extrusion
     `Extrusion($crossSection, $spine, $scale, $orientation, $beginCap,
     $endCap, $creaseAngle, $solid, $convex, $ccw)'

     $spine should be a reference of a list of spine values like `['0 0
     0', '0 1 0', ...]'

IndexedFaceSet
     `IndexedFaceSet($coord, $coordIndex, $color, $coordIndex,
     $colorPerVertex, $normal, $normalIndex_ref, $texCoord,
     $texCoordIndex_ref)'

     $coordIndex should be a list of point index strings or a reference
     like `'0 1 3 2', '2 3 5 4', ...'

     $coordIndex should be a reference of a list of colors

     $normalIndex_ref should be a reference of a list of normals

     $texCoordIndex_ref should be a reference of a list of textures

IndexedLineSet
     `IndexedLineSet($coord, $coordIndex, $color, $colorIndex,
     $colorPerVertex)'

     $coord should be a reference to a Coordinate method or a string with a
     Coordinate node.

     $coordIndex should be a reference of a list of point index strings
     like `'0, 1, 3, 2', '2, 3, 5, 4', ...'

     $colorIndex should be a reference of a list of colors

PointSet
     `PointSet($coord, $color)'

Sphere
     `Sphere($radius)'

     $radius have to be > 0

Text
     `Text($string, $fontStyle, $length, $maxExtent)'

Geometric Properties
--------------------

Coordinate
     `Coordinate(@point)'

     @point should be a list of points with strings like `'1.0 0.0 0.0',
     '-1 2 0''

Color
     `Color(@color)'

     @color should be a list of colors with strings like `'1.0 0.0 0.0',
     '.3 .2 .1''

Normal
     `Normal(@vector)'

     @vector should be a list of vectors with strings like `'1.0 0.0 0.0',
     '.4 .2 0''

Appearance
----------

Appearance
     Appearance

Fontstyle
     `FontStyle($size, $family, $style, $justify)' defines the current
     font style for the current Text Nodes

     $style can be 'PLAIN','BOLD','ITALIC','BOLD ITALIC'

     $familiy can be 'SERIF','SANS','TYPEWRITER'

     $justify can be 'BEGIN', 'MIDDLE', 'END'

Material
     `Material(%materials)'

ImageTexture
     `ImageTexture($url)'

MovieTexture
     `MovieTexture($url)'

Sensors
-------

CylinderSensor
     `CylinderSensor($maxAngle, $minAngle, $diskAngle, $offset,
     $autoOffset, $enabled)'

PlaneSensor
     `PlaneSensor($maxPosition, $minPosition, $offset, $autoOffset,
     $enabled)'

ProximitySensor
     `ProximitySensor($size, $center, $enabled)'

SphereSensor
     `SphereSensor($offset, $autoOffset, $enabled)'

TimeSensor
     `TimeSensor($cycleInterval, $loop, $startTime, $stopTime, $enabled)'

TouchSensor
     `TouchSensor($enabled)'

VisibilitySensor
     `VisibilitySensor($size, $center, $enabled)'

Interpolators
-------------

ColorInterpolator
     `ColorInterpolator($key, $keyValue)'

CoordinateInterpolator
     `CoordinateInterpolator($key, $keyValue)'

OrientationInterpolator
     `OrientationInterpolator($key, $keyValue)'

NormalInterpolator
     `NormalInterpolator($key, $keyValue)'

PositionInterpolator
     `PositionInterpolator($key, $keyValue)'

ScalarInterpolator
     `ScalarInterpolator($key, $keyValue)'

     $key	MFFloat $keyValue	MFFloat

Bindable Nodes
--------------

Background
     `Background($hash)'

     You only can use a hash. Parameter see VRML Spec

NavigationInfo
     `NavigationInfo($type, $speed, $headlight, $visibilityLimit,
     $avatarSize)'

     You can use a hash reference or all parameter in the same order above

Viewpoint
     `Viewpoint($description, $position, $orientation, $fieldOfView,
     $jump)'

PROTO
     `PROTO($name, $declaration, $definition)'

other
-----

USE
     `USE($name)'

DEF
     `DEF($name)'

ROUTE
     `ROUTE($from, $to)'

End
     `End($comment)'

     Close an open node with }

EndChildren
     `EndChildren($comment)'

     Close an open children part with ]

EndTransform
     `EndTransform($comment)'

     Close an open children part with ] and the node with }

SEE ALSO
========

   VRML::VRML2::Standard

   VRML::Base

   http://www.gfz-potsdam.de/~palm/vrmlperl/ for a description of
`VRML-modules' and how to obtain it.

AUTHOR
======

   Hartmut Palm `<palm@gfz-potsdam.de>'

   Homepage http://www.gfz-potsdam.de/~palm/


File: pm.info,  Node: VRML/Viewer,  Next: VcsTools/DataSpec/HpTnd,  Prev: VRML/VRML2/Standard,  Up: Module List

navigation modes of FreeWRL
***************************

NAME
====

   VRML::Viewer - navigation modes of FreeWRL

SYNOPSIS
========

   (used internally by FreeWRL)

DESCRIPTION
===========

   This module implements the various navigation modes for the FreeWRL
VRML browser (see *Note VRML/Browser: VRML/Browser,, `freewrl' in this
node).  `freewrl' in this node explains how to use the navigation modes.

AUTHOR
======

   Tuomas J. Lukka, with help from John Breen.


File: pm.info,  Node: VcsTools/DataSpec/HpTnd,  Next: VcsTools/DataSpec/Rcs,  Prev: VRML/Viewer,  Up: Module List

Hp Tnd custom data for HMS logs
*******************************

NAME
====

   VcsTools::DataSpec::HpTnd - Hp Tnd custom data for HMS logs

SYNOPSIS
========

     use VcsTools::DataSpec::HpTnd qw($description readHook);
     use VcsTools::LogParser ;

     my $ds = new VcsTools::LogParser
      (
       readHook => \&readHook,
       description => $description
      ) ;

DESCRIPTION
===========

   This class contains all the custom information needed to retrieve our
data from our database using the generic *Note VcsTools/LogParser:
VcsTools/LogParser, class.

   The $description hash ref defines the informations that are contained
in the log of each version of the HMS file.

   Needless to say this file is tailored for HP Tnd needs and HMS keywords.
Nevertheless, it can be used as a template for other VCS systems and other
needs.

HP TND DATA DESCRIPTION
=======================

state
-----

   Taken from 'state' HMS field. It can be either Dead Exp Team Lab
Special or Product according to the level of confidence.

branches
--------

   Taken from 'branches' HMS field. List the branches of a version.
read-only value.

author
------

   Taken from 'Author' HMS field. Name of the author of the revision or
the name of the last guy who modified the HMS log.

date
----

   Date of the archive. Set by HMS. read-only value.

merged from
-----------

   Specifies if this version is a merge between the parent revision and
another revision.

comes from
----------

   Explicitely specifies the parent revision. Use this field when the
parent cannot be infered. For instance, when the revision number jump from
1.19 to 2.1, set the 'comes from' field of the revision '2.1' to '1.19'.

writer
------

   The original writer of this version. Since HMS changes the 'Author'
field whenever you edit the history of a version, this field keeps track
of the guy who actually archived this version.

keywords
--------

   Keyword which refers to the functionnality added in this version.
(could be 'ANSI', 'cosmetic', 'doc_update' ...).

fix
---

   Official names of the bugs fixed in this version (a la 'GREhp01234').

misc
----

   Miscellaneous comments about this version.

CHANGE MODEL
============

   The 3 following keywords try to provide a model for changes introduced
with each revision of a file.

behavior change
---------------

   Specify whether this code can smoothly replace the previous revision.
Can be 'none', 'cosmetic', 'minor','major'

   Still need a clear definition of what it means.

interface change
----------------

   Specify the amount of change seen from the compiler's point of view. For
a header file, for instance, 'cosmetic' might mean 're-compilation needed',
'major' might mean 'code change needed in user code'.

   Can be 'none', 'cosmetic', 'major'

inter-peer change
-----------------

   Specify whether this code can inter-work with the previous revision.

   Can be 'none', 'cosmetic', 'major'

HOOKS
=====

readHook(hash ref)
------------------

   This method will try to get more information from the log of each
revision.

   If the 'fix' field is empty, readHook will look for GREhpxxxx keywords
in the log to guess what was fixed in this revision. Of course, it may
guess wrong if the log contains "*Gee I forgot to fix GREhp00007*".

   If the 'keywords' field is empty, readHook will look for keywords
matching `/\b([A-Z\d]{2,})\b/' in the log to guess what was added in this
revision.  The result is often relevant, but is sometime silly.

AUTHOR
======

   Dominique Dumont, Dominique_Dumont@grenoble.hp.com

   Copyright (c) 1998-1999 Dominique Dumont. All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

SEE ALSO
========

   perl(1)


