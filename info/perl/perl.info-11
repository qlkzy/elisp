This is Info file perl.info, produced by Makeinfo version 1.68 from the
input file bigperl.texi.

   settitle perl


File: perl.info,  Node: perlfaq5,  Next: Top,  Prev: Top,  Up: Top

Files and Formats ($Revision: 1.38 $, $Date: 1999/05/23 16:08:30 $)
*******************************************************************

NAME
====

   perlfaq5 - Files and Formats ($Revision: 1.38 $, $Date: 1999/05/23
16:08:30 $)

DESCRIPTION
===========

   This section deals with I/O and the "f" issues: filehandles, flushing,
formats, and footers.

How do I flush/unbuffer an output filehandle?  Why must I do this?
------------------------------------------------------------------

   The C standard I/O library (stdio) normally buffers characters sent to
devices.  This is done for efficiency reasons, so that there isn't a
system call for each byte.  Any time you use print() or write() in Perl,
you go though this buffering.  syswrite() circumvents stdio and buffering.

   In most stdio implementations, the type of output buffering and the
size of the buffer varies according to the type of device.  Disk files are
block buffered, often with a buffer size of more than 2k.  Pipes and
sockets are often buffered with a buffer size between 1/2 and 2k.  Serial
devices (e.g. modems, terminals) are normally line-buffered, and stdio
sends the entire line when it gets the newline.

   Perl does not support truly unbuffered output (except insofar as you can
`syswrite(OUT, $char, 1)').  What it does instead support is "command
buffering", in which a physical write is performed after every output
command.  This isn't as hard on your system as unbuffering, but does get
the output where you want it when you want it.

   If you expect characters to get to your device when you print them
there, you'll want to autoflush its handle.  Use select() and the $|
variable to control autoflushing (see `$|', *Note Perlvar: perlvar, and
`select', *Note Perlfunc: perlfunc,):

     $old_fh = select(OUTPUT_HANDLE);
     $| = 1;
     select($old_fh);

   Or using the traditional idiom:

     select((select(OUTPUT_HANDLE), $| = 1)[0]);

   Or if don't mind slowly loading several thousand lines of module code
just because you're afraid of the $| variable:

     use FileHandle;
     open(DEV, "+</dev/tty"); 	  # ceci n'est pas une pipe
     DEV->autoflush(1);

   or the newer IO::* modules:

     use IO::Handle;
     open(DEV, ">/dev/printer");   # but is this?
     DEV->autoflush(1);

   or even this:

     use IO::Socket;		  # this one is kinda a pipe?
     $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.com',
     				  PeerPort => 'http(80)',
     				  Proto    => 'tcp');
     die "$!" unless $sock;

     $sock->autoflush();
     print $sock "GET / HTTP/1.0" . "\015\012" x 2;
     $document = join('', <$sock>);
     print "DOC IS: $document\n";

   Note the bizarrely hardcoded carriage return and newline in their octal
equivalents.  This is the ONLY way (currently) to assure a proper flush on
all platforms, including Macintosh.  That's the way things work in network
programming: you really should specify the exact bit pattern on the
network line terminator.  In practice, `"\n\n"' often works, but this is
not portable.

   See *Note Perlfaq9: perlfaq9, for other examples of fetching URLs over
the web.

How do I change one line in a file/delete a line in a file/insert a line in the middle of a file/append to the beginning of a file?
-----------------------------------------------------------------------------------------------------------------------------------

   Those are operations of a text editor.  Perl is not a text editor.
Perl is a programming language.  You have to decompose the problem into
low-level calls to read, write, open, close, and seek.

   Although humans have an easy time thinking of a text file as being a
sequence of lines that operates much like a stack of playing cards - or
punch cards - computers usually see the text file as a sequence of bytes.
In general, there's no direct way for Perl to seek to a particular line of
a file, insert text into a file, or remove text from a file.

   (There are exceptions in special circumstances.  You can add or remove
at the very end of the file.  Another is replacing a sequence of bytes with
another sequence of the same length.  Another is using the `$DB_RECNO'
array bindings as documented in *Note DB_File: (pm.info)DB_File,.  Yet
another is manipulating files with all lines the same length.)

   The general solution is to create a temporary copy of the text file with
the changes you want, then copy that over the original.  This assumes no
locking.

     $old = $file;
     $new = "$file.tmp.$$";
     $bak = "$file.orig";

     open(OLD, "< $old") 	or die "can't open $old: $!";
     open(NEW, "> $new") 	or die "can't open $new: $!";

     # Correct typos, preserving case
     while (<OLD>) {
     	s/\b(p)earl\b/${1}erl/i;
     	(print NEW $_)		or die "can't write to $new: $!";
     }

     close(OLD)			or die "can't close $old: $!";
     close(NEW) 			or die "can't close $new: $!";

     rename($old, $bak)		or die "can't rename $old to $bak: $!";
     rename($new, $old)		or die "can't rename $new to $old: $!";

   Perl can do this sort of thing for you automatically with the -i
command-line switch or the closely-related $^I variable (see *Note
Perlrun: perlrun, for more details).  Note that -i may require a suffix on
some non-Unix systems; see the platform-specific documentation that came
with your port.

     # Renumber a series of tests from the command line
     perl -pi -e 's/(^\s+test\s+)\d+/ $1 . ++$count /e' t/op/taint.t

     # form a script
     local($^I, @ARGV) = ('.orig', glob("*.c"));
     while (<>) {
     	if ($. == 1) {
     	    print "This line should appear at the top of each file\n";
     	}
     	s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
     	print;
     	close ARGV if eof;              # Reset $.
     }

   If you need to seek to an arbitrary line of a file that changes
infrequently, you could build up an index of byte positions of where the
line ends are in the file.  If the file is large, an index of every tenth
or hundredth line end would allow you to seek and read fairly efficiently.
If the file is sorted, try the look.pl library (part of the standard perl
distribution).

   In the unique case of deleting lines at the end of a file, you can use
tell() and truncate().  The following code snippet deletes the last line
of a file without making a copy or reading the whole file into memory:

     open (FH, "+< $file");
             while ( <FH> ) { $addr = tell(FH) unless eof(FH) }
             truncate(FH, $addr);

   Error checking is left as an exercise for the reader.

How do I count the number of lines in a file?
---------------------------------------------

   One fairly efficient way is to count newlines in the file. The
following program uses a feature of tr///, as documented in *Note Perlop:
perlop,.  If your text file doesn't end with a newline, then it's not
really a proper text file, so this may report one fewer line than you
expect.

     $lines = 0;
     open(FILE, $filename) or die "Can't open `$filename': $!";
     while (sysread FILE, $buffer, 4096) {
     	$lines += ($buffer =~ tr/\n//);
     }
     close FILE;

   This assumes no funny games with newline translations.

How do I make a temporary file name?
------------------------------------

   Use the new_tmpfile class method from the IO::File module to get a
filehandle opened for reading and writing.  Use this if you don't need to
know the file's name.

     use IO::File;
     $fh = IO::File->new_tmpfile()
     	or die "Unable to make new temporary file: $!";

   Or you can use the tmpnam function from the POSIX module to get a
filename that you then open yourself.  Use this if you do need to know the
file's name.

     use Fcntl;
     use POSIX qw(tmpnam);

     # try new temporary filenames until we get one that didn't already
     # exist;  the check should be unnecessary, but you can't be too careful
     do { $name = tmpnam() }
         until sysopen(FH, $name, O_RDWR|O_CREAT|O_EXCL);

     # install atexit-style handler so that when we exit or die,
     # we automatically delete this temporary file
     END { unlink($name) or die "Couldn't unlink $name : $!" }

     # now go on to use the file ...

   If you're committed to doing this by hand, use the process ID and/or
the current time-value.  If you need to have many temporary files in one
process, use a counter:

     BEGIN {
     	use Fcntl;
     	my $temp_dir = -d '/tmp' ? '/tmp' : $ENV{TMP} || $ENV{TEMP};
     	my $base_name = sprintf("%s/%d-%d-0000", $temp_dir, $$, time());
     	sub temp_file {
     	    local *FH;
     	    my $count = 0;
     	    until (defined(fileno(FH)) || $count++ > 100) {
     		$base_name =~ s/-(\d+)$/"-" . (1 + $1)/e;
     		sysopen(FH, $base_name, O_WRONLY|O_EXCL|O_CREAT);
     	    }
     	    if (defined(fileno(FH))
     		return (*FH, $base_name);
     	    } else {
     		return ();
     	    }
     	}
     }

How can I manipulate fixed-record-length files?
-----------------------------------------------

   The most efficient way is using pack() and unpack().  This is faster
than using substr() when taking many, many strings.  It is slower for just
a few.

   Here is a sample chunk of code to break up and put back together again
some fixed-format input lines, in this case from the output of a normal,
Berkeley-style ps:

     # sample input line:
     #   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
     $PS_T = 'A6 A4 A7 A5 A*';
     open(PS, "ps|");
     print scalar <PS>;
     while (<PS>) {
     	($pid, $tt, $stat, $time, $command) = unpack($PS_T, $_);
     	for $var (qw!pid tt stat time command!) {
     	    print "$var: <$$var>\n";
     	}
     	print 'line=', pack($PS_T, $pid, $tt, $stat, $time, $command),
     		"\n";
     }

   We've used `$$var' in a way that forbidden by `use strict 'refs''.
That is, we've promoted a string to a scalar variable reference using
symbolic references.  This is ok in small programs, but doesn't scale
well.   It also only works on global variables, not lexicals.

How can I make a filehandle local to a subroutine?  How do I pass filehandles between subroutines?  How do I make an array of filehandles?
------------------------------------------------------------------------------------------------------------------------------------------

   The fastest, simplest, and most direct way is to localize the typeglob
of the filehandle in question:

     local *TmpHandle;

   Typeglobs are fast (especially compared with the alternatives) and
reasonably easy to use, but they also have one subtle drawback.  If you
had, for example, a function named TmpHandle(), or a variable named
%TmpHandle, you just hid it from yourself.

     sub findme {
         local *HostFile;
     	open(HostFile, "</etc/hosts") or die "no /etc/hosts: $!";
     	local $_;		# <- VERY IMPORTANT
         while (<HostFile>) {
     	    print if /\b127\.(0\.0\.)?1\b/;
     	}
     	# *HostFile automatically closes/disappears here
     }

   Here's how to use this in a loop to open and store a bunch of
filehandles.  We'll use as values of the hash an ordered pair to make it
easy to sort the hash in insertion order.

     @names = qw(motd termcap passwd hosts);
     my $i = 0;
     foreach $filename (@names) {
     	local *FH;
     	open(FH, "/etc/$filename") || die "$filename: $!";
         $file{$filename} = [ $i++, *FH ];
     }

     # Using the filehandles in the array
     foreach $name (sort { $file{$a}[0] <=> $file{$b}[0] } keys %file) {
         my $fh = $file{$name}[1];
         my $line = <$fh>;
         print "$name $. $line";
     }

   For passing filehandles to functions, the easiest way is to preface
them with a star, as in func(*STDIN).  See `"Passing Filehandles"', *Note
Perlfaq7: perlfaq7, for details.

   If you want to create many anonymous handles, you should check out the
Symbol, FileHandle, or IO::Handle (etc.) modules.  Here's the equivalent
code with Symbol::gensym, which is reasonably light-weight:

     foreach $filename (@names) {
     	use Symbol;
     	my $fh = gensym();
     	open($fh, "/etc/$filename") || die "open /etc/$filename: $!";
         $file{$filename} = [ $i++, $fh ];
     }

   Or here using the semi-object-oriented FileHandle module, which
certainly isn't light-weight:

     use FileHandle;

     foreach $filename (@names) {
         my $fh = FileHandle->new("/etc/$filename") or die "$filename: $!";
         $file{$filename} = [ $i++, $fh ];
     }

   Please understand that whether the filehandle happens to be a (probably
localized) typeglob or an anonymous handle from one of the modules, in no
way affects the bizarre rules for managing indirect handles.  See the next
question.

How can I use a filehandle indirectly?
--------------------------------------

   An indirect filehandle is using something other than a symbol in a
place that a filehandle is expected.  Here are ways to get those:

     $fh =   SOME_FH;       # bareword is strict-subs hostile
     $fh =  "SOME_FH";      # strict-refs hostile; same package only
     $fh =  *SOME_FH;       # typeglob
     $fh = \*SOME_FH;       # ref to typeglob (bless-able)
     $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob

   Or to use the new method from the FileHandle or IO modules to create an
anonymous filehandle, store that in a scalar variable, and use it as
though it were a normal filehandle.

     use FileHandle;
     $fh = FileHandle->new();

     use IO::Handle;                     # 5.004 or higher
     $fh = IO::Handle->new();

   Then use any of those as you would a normal filehandle.  Anywhere that
Perl is expecting a filehandle, an indirect filehandle may be used
instead. An indirect filehandle is just a scalar variable that contains a
filehandle.  Functions like print, open, seek, or the `< <FH' >> diamond
operator will accept either a read filehandle or a scalar variable
containing one:

     ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
     print $ofh "Type it: ";
     $got = <$ifh>
     print $efh "What was that: $got";

   If you're passing a filehandle to a function, you can write the
function in two ways:

     sub accept_fh {
         my $fh = shift;
         print $fh "Sending to indirect filehandle\n";
     }

   Or it can localize a typeglob and use the filehandle directly:

     sub accept_fh {
         local *FH = shift;
         print  FH "Sending to localized filehandle\n";
     }

   Both styles work with either objects or typeglobs of real filehandles.
(They might also work with strings under some circumstances, but this is
risky.)

     accept_fh(*STDOUT);
     accept_fh($handle);

   In the examples above, we assigned the filehandle to a scalar variable
before using it.  That is because only simple scalar variables, not
expressions or subscripts into hashes or arrays, can be used with
built-ins like print, printf, or the diamond operator.  These are illegal
and won't even compile:

     @fd = (*STDIN, *STDOUT, *STDERR);
     print $fd[1] "Type it: ";                           # WRONG
     $got = <$fd[0]>                                     # WRONG
     print $fd[2] "What was that: $got";                 # WRONG

   With print and printf, you get around this by using a block and an
expression where you would place the filehandle:

     print  { $fd[1] } "funny stuff\n";
     printf { $fd[1] } "Pity the poor %x.\n", 3_735_928_559;
     # Pity the poor deadbeef.

   That block is a proper block like any other, so you can put more
complicated code there.  This sends the message out to one of two places:

     $ok = -x "/bin/cat";
     print { $ok ? $fd[1] : $fd[2] } "cat stat $ok\n";
     print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\n";

   This approach of treating print and printf like object methods calls
doesn't work for the diamond operator.  That's because it's a real
operator, not just a function with a comma-less argument.  Assuming you've
been storing typeglobs in your structure as we did above, you can use the
built-in function named readline to reads a record just as `< <' >> does.
Given the initialization shown above for @fd, this would work, but only
because readline() require a typeglob.  It doesn't work with objects or
strings, which might be a bug we haven't fixed yet.

     $got = readline($fd[0]);

   Let it be noted that the flakiness of indirect filehandles is not
related to whether they're strings, typeglobs, objects, or anything else.
It's the syntax of the fundamental operators.  Playing the object game
doesn't help you at all here.

How can I set up a footer format to be used with write()?
---------------------------------------------------------

   There's no builtin way to do this, but *Note Perlform: perlform, has a
couple of techniques to make it possible for the intrepid hacker.

How can I write() into a string?
--------------------------------

   See `"Accessing Formatting Internals"', *Note Perlform: perlform, for
an swrite() function.

How can I output my numbers with commas added?
----------------------------------------------

   This one will do it for you:

     sub commify {
     	local $_  = shift;
     	1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
     	return $_;
     }

     $n = 23659019423.2331;
     print "GOT: ", commify($n), "\n";

     GOT: 23,659,019,423.2331

   You can't just:

     s/^([-+]?\d+)(\d{3})/$1,$2/g;

   because you have to put the comma in and then recalculate your position.

   Alternatively, this commifies all numbers in a line regardless of
whether they have decimal portions, are preceded by + or -, or whatever:

     # from Andrew Johnson <ajohnson@gpu.srv.ualberta.ca>
     sub commify {
        my $input = shift;
         $input = reverse $input;
         $input =~ s<(\d\d\d)(?=\d)(?!\d*\.)><$1,>g;
         return scalar reverse $input;
     }

How can I translate tildes (~) in a filename?
---------------------------------------------

   Use the <> (glob()) operator, documented in *Note Perlfunc: perlfunc,.
This requires that you have a shell installed that groks tildes, meaning
csh or tcsh or (some versions of) ksh, and thus may have portability
problems.  The Glob::KGlob module (available from CPAN) gives more
portable glob functionality.

   Within Perl, you may use this directly:

     $filename =~ s{
       ^ ~             # find a leading tilde
       (               # save this in $1
           [^/]        # a non-slash character
                 *     # repeated 0 or more times (0 means me)
       )
     }{
       $1
           ? (getpwnam($1))[7]
           : ( $ENV{HOME} || $ENV{LOGDIR} )
     }ex;

How come when I open a file read-write it wipes it out?
-------------------------------------------------------

   Because you're using something like this, which truncates the file and
*then* gives you read-write access:

     open(FH, "+> /path/name");		# WRONG (almost always)

   Whoops.  You should instead use this, which will fail if the file
doesn't exist.

     open(FH, "+< /path/name");  	# open for update

   Using ">" always clobbers or creates.  Using "<" never does either.
The "+" doesn't change this.

   Here are examples of many kinds of file opens.  Those using sysopen()
all assume

     use Fcntl;

   To open file for reading:

     open(FH, "< $path")                                 || die $!;
     sysopen(FH, $path, O_RDONLY)                        || die $!;

   To open file for writing, create new file if needed or else truncate
old file:

     open(FH, "> $path") || die $!;
     sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT)        || die $!;
     sysopen(FH, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666)  || die $!;

   To open file for writing, create new file, file must not exist:

     sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT)         || die $!;
     sysopen(FH, $path, O_WRONLY|O_EXCL|O_CREAT, 0666)   || die $!;

   To open file for appending, create if necessary:

     open(FH, ">> $path") || die $!;
     sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT)       || die $!;
     sysopen(FH, $path, O_WRONLY|O_APPEND|O_CREAT, 0666) || die $!;

   To open file for appending, file must exist:

     sysopen(FH, $path, O_WRONLY|O_APPEND)               || die $!;

   To open file for update, file must exist:

     open(FH, "+< $path")                                || die $!;
     sysopen(FH, $path, O_RDWR)                          || die $!;

   To open file for update, create file if necessary:

     sysopen(FH, $path, O_RDWR|O_CREAT)                  || die $!;
     sysopen(FH, $path, O_RDWR|O_CREAT, 0666)            || die $!;

   To open file for update, file must not exist:

     sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT)           || die $!;
     sysopen(FH, $path, O_RDWR|O_EXCL|O_CREAT, 0666)     || die $!;

   To open a file without blocking, creating if necessary:

     sysopen(FH, "/tmp/somefile", O_WRONLY|O_NDELAY|O_CREAT)
     	    or die "can't open /tmp/somefile: $!":

   Be warned that neither creation nor deletion of files is guaranteed to
be an atomic operation over NFS.  That is, two processes might both
successful create or unlink the same file!  Therefore O_EXCL isn't so
exclusive as you might wish.

   See also the new *Note Perlopentut: perlopentut, if you have it (new
for 5.6).

Why do I sometimes get an "Argument list too long" when I use <*>?
------------------------------------------------------------------

   The `< <' >> operator performs a globbing operation (see above).  In
Perl versions earlier than v5.6.0, the internal glob() operator forks
csh(1) to do the actual glob expansion, but csh can't handle more than 127
items and so gives the error message `Argument list too long'.  People who
installed tcsh as csh won't have this problem, but their users may be
surprised by it.

   To get around this, either upgrade to Perl v5.6.0 or later, do the glob
yourself with readdir() and patterns, or use a module like Glob::KGlob,
one that doesn't use the shell to do globbing.

Is there a leak/bug in glob()?
------------------------------

   Due to the current implementation on some operating systems, when you
use the glob() function or its angle-bracket alias in a scalar context,
you may cause a leak and/or unpredictable behavior.  It's best therefore
to use glob() only in list context.

How can I open a file with a leading ">" or trailing blanks?
------------------------------------------------------------

   Normally perl ignores trailing blanks in filenames, and interprets
certain leading characters (or a trailing "|") to mean something special.
To avoid this, you might want to use a routine like this.  It makes
incomplete pathnames into explicit relative ones, and tacks a trailing
null byte on the name to make perl leave it alone:

     sub safe_filename {
     	local $_  = shift;
         s#^([^./])#./$1#;
         $_ .= "\0";
     	return $_;
     }

     $badpath = "<<<something really wicked   ";
     $fn = safe_filename($badpath");
     open(FH, "> $fn") or "couldn't open $badpath: $!";

   This assumes that you are using POSIX (portable operating systems
interface) paths.  If you are on a closed, non-portable, proprietary
system, you may have to adjust the `"./"' above.

   It would be a lot clearer to use sysopen(), though:

     use Fcntl;
     $badpath = "<<<something really wicked   ";
     open (FH, $badpath, O_WRONLY | O_CREAT | O_TRUNC)
     	or die "can't open $badpath: $!";

   For more information, see also the new *Note Perlopentut: perlopentut,
if you have it (new for 5.6).

How can I reliably rename a file?
---------------------------------

   Well, usually you just use Perl's rename() function.  But that may not
work everywhere, in particular, renaming files across file systems.  Some
sub-Unix systems have broken ports that corrupt the semantics of rename()
- for example, WinNT does this right, but Win95 and Win98 are broken.
(The last two parts are not surprising, but the first is. :-)

   If your operating system supports a proper mv(1) program or its moral
equivalent, this works:

     rename($old, $new) or system("mv", $old, $new);

   It may be more compelling to use the File::Copy module instead.  You
just copy to the new file to the new name (checking return values), then
delete the old one.  This isn't really the same semantics as a real
rename(), though, which preserves metainformation like permissions,
timestamps, inode info, etc.

   The newer version of File::Copy exports a move() function.

How can I lock a file?
----------------------

   Perl's builtin flock() function (see *Note Perlfunc: perlfunc, for
details) will call flock(2) if that exists, fcntl(2) if it doesn't (on
perl version 5.004 and later), and lockf(3) if neither of the two previous
system calls exists.  On some systems, it may even use a different form of
native locking.  Here are some gotchas with Perl's flock():

  1. Produces a fatal error if none of the three system calls (or their
     close equivalent) exists.

  2. lockf(3) does not provide shared locking, and requires that the
     filehandle be open for writing (or appending, or read/writing).

  3. Some versions of flock() can't lock files over a network (e.g. on NFS
     file systems), so you'd need to force the use of fcntl(2) when you
     build Perl.  But even this is dubious at best.  See the flock entry
     of *Note Perlfunc: perlfunc,, and the INSTALL file in the source
     distribution for information on building Perl to do this.

     Two potentially non-obvious but traditional flock semantics are that
     it waits indefinitely until the lock is granted, and that its locks
     *merely advisory*.  Such discretionary locks are more flexible, but
     offer fewer guarantees.  This means that files locked with flock() may
     be modified by programs that do not also use flock().  Cars that stop
     for red lights get on well with each other, but not with cars that
     don't stop for red lights.  See the perlport manpage, your port's
     specific documentation, or your system-specific local manpages for
     details.  It's best to assume traditional behavior if you're writing
     portable programs.  (But if you're not, you should as always feel
     perfectly free to write for your own system's idiosyncrasies
     (sometimes called "features").  Slavish adherence to portability
     concerns shouldn't get in the way of your getting your job done.)

     For more information on file locking, see also `"File Locking"',
     *Note Perlopentut: perlopentut, if you have it (new for 5.6).


Why can't I just open(FH, ">file.lock")?
----------------------------------------

   A common bit of code *NOT TO USE* is this:

     sleep(3) while -e "file.lock";	# PLEASE DO NOT USE
     open(LCK, "> file.lock");		# THIS BROKEN CODE

   This is a classic race condition: you take two steps to do something
which must be done in one.  That's why computer hardware provides an
atomic test-and-set instruction.   In theory, this "ought" to work:

     sysopen(FH, "file.lock", O_WRONLY|O_EXCL|O_CREAT)
     		or die "can't open  file.lock: $!":

   except that lamentably, file creation (and deletion) is not atomic over
NFS, so this won't work (at least, not every time) over the net.  Various
schemes involving link() have been suggested, but these tend to involve
busy-wait, which is also subdesirable.

I still don't get locking.  I just want to increment the number in the file.  How can I do this?
------------------------------------------------------------------------------------------------

   Didn't anyone ever tell you web-page hit counters were useless?  They
don't count number of hits, they're a waste of time, and they serve only
to stroke the writer's vanity.  Better to pick a random number.  It's more
realistic.

   Anyway, this is what you can do if you can't help yourself.

     use Fcntl ':flock';
     sysopen(FH, "numfile", O_RDWR|O_CREAT) 	 or die "can't open numfile: $!";
     flock(FH, LOCK_EX) 				 or die "can't flock numfile: $!";
     $num = <FH> || 0;
     seek(FH, 0, 0) 				 or die "can't rewind numfile: $!";
     truncate(FH, 0) 				 or die "can't truncate numfile: $!";
     (print FH $num+1, "\n")			 or die "can't write numfile: $!";
     # Perl as of 5.004 automatically flushes before unlocking
     flock(FH, LOCK_UN) 				 or die "can't flock numfile: $!";
     close FH 					 or die "can't close numfile: $!";

   Here's a much better web-page hit counter:

     $hits = int( (time() - 850_000_000) / rand(1_000) );

   If the count doesn't impress your friends, then the code might.  :-)

How do I randomly update a binary file?
---------------------------------------

   If you're just trying to patch a binary, in many cases something as
simple as this works:

     perl -i -pe 's{window manager}{window mangler}g' /usr/bin/emacs

   However, if you have fixed sized records, then you might do something
more like this:

     $RECSIZE = 220; # size of record, in bytes
     $recno   = 37;  # which record to update
     open(FH, "+<somewhere") || die "can't update somewhere: $!";
     seek(FH, $recno * $RECSIZE, 0);
     read(FH, $record, $RECSIZE) == $RECSIZE || die "can't read record $recno: $!";
     # munge the record
     seek(FH, -$RECSIZE, 1);
     print FH $record;
     close FH;

   Locking and error checking are left as an exercise for the reader.
Don't forget them, or you'll be quite sorry.

How do I get a file's timestamp in perl?
----------------------------------------

   If you want to retrieve the time at which the file was last read,
written, or had its meta-data (owner, etc) changed, you use the -M, -A, or
-C filetest operations as documented in *Note Perlfunc: perlfunc,.  These
retrieve the age of the file (measured against the start-time of your
program) in days as a floating point number.  To retrieve the "raw" time
in seconds since the epoch, you would call the stat function, then use
localtime(), gmtime(), or POSIX::strftime() to convert this into
human-readable form.

   Here's an example:

     $write_secs = (stat($file))[9];
     printf "file %s updated at %s\n", $file,
     	scalar localtime($write_secs);

   If you prefer something more legible, use the File::stat module (part
of the standard distribution in version 5.004 and later):

     # error checking left as an exercise for reader.
     use File::stat;
     use Time::localtime;
     $date_string = ctime(stat($file)->mtime);
     print "file $file updated at $date_string\n";

   The POSIX::strftime() approach has the benefit of being, in theory,
independent of the current locale.  See *Note Perllocale: perllocale, for
details.

How do I set a file's timestamp in perl?
----------------------------------------

   You use the utime() function documented in `utime', *Note Perlfunc:
perlfunc,.  By way of example, here's a little program that copies the
read and write times from its first argument to all the rest of them.

     if (@ARGV < 2) {
     	die "usage: cptimes timestamp_file other_files ...\n";
     }
     $timestamp = shift;
     ($atime, $mtime) = (stat($timestamp))[8,9];
     utime $atime, $mtime, @ARGV;

   Error checking is, as usual, left as an exercise for the reader.

   Note that utime() currently doesn't work correctly with Win95/NT ports.
A bug has been reported.  Check it carefully before using it on those
platforms.

How do I print to more than one file at once?
---------------------------------------------

   If you only have to do this once, you can do this:

     for $fh (FH1, FH2, FH3) { print $fh "whatever\n" }

   To connect up to one filehandle to several output filehandles, it's
easiest to use the tee(1) program if you have it, and let it take care of
the multiplexing:

     open (FH, "| tee file1 file2 file3");

   Or even:

     # make STDOUT go to three files, plus original STDOUT
     open (STDOUT, "| tee file1 file2 file3") or die "Teeing off: $!\n";
     print "whatever\n"                       or die "Writing: $!\n";
     close(STDOUT)                            or die "Closing: $!\n";

   Otherwise you'll have to write your own multiplexing print function -
or your own tee program - or use Tom Christiansen's, at
http://www.perl.com/CPAN/authors/id/TOMC/scripts/tct.gz, which is written
in Perl and offers much greater functionality than the stock version.

How can I read in an entire file all at once?
---------------------------------------------

   The customary Perl approach for processing all the lines in a file is to
do so one line at a time:

     open (INPUT, $file) 	|| die "can't open $file: $!";
     while (<INPUT>) {
     	chomp;
     	# do something with $_
     }
     close(INPUT)	    	|| die "can't close $file: $!";

   This is tremendously more efficient than reading the entire file into
memory as an array of lines and then processing it one element at a time,
which is often - if not almost always - the wrong approach.  Whenever you
see someone do this:

     @lines = <INPUT>;

   You should think long and hard about why you need everything loaded at
once.  It's just not a scalable solution.  You might also find it more fun
to use the the standard DB_File module's $DB_RECNO bindings, which allow
you to tie an array to a file so that accessing an element the array
actually accesses the corresponding line in the file.

   On very rare occasion, you may have an algorithm that demands that the
entire file be in memory at once as one scalar.  The simplest solution to
that is:

     $var = `cat $file`;

   Being in scalar context, you get the whole thing.  In list context,
you'd get a list of all the lines:

     @lines = `cat $file`;

   This tiny but expedient solution is neat, clean, and portable to all
systems on which decent tools have been installed.  For those who prefer
not to use the toolbox, you can of course read the file manually, although
this makes for more complicated code.

     {
     	local(*INPUT, $/);
     	open (INPUT, $file) 	|| die "can't open $file: $!";
     	$var = <INPUT>;
     }

   That temporarily undefs your record separator, and will automatically
close the file at block exit.  If the file is already open, just use this:

     $var = do { local $/; <INPUT> };

How can I read in a file by paragraphs?
---------------------------------------

   Use the $/ variable (see *Note Perlvar: perlvar, for details).  You can
either set it to "" to eliminate empty paragraphs (`"abc\n\n\n\ndef"', for
instance, gets treated as two paragraphs and not three), or `"\n\n"' to
accept empty paragraphs.

   Note that a blank line must have no blanks in it.  Thus `"fred\n
\nstuff\n\n"' is one paragraph, but `"fred\n\nstuff\n\n"' is two.

How can I read a single character from a file?  From the keyboard?
------------------------------------------------------------------

   You can use the builtin `getc()' function for most filehandles, but it
won't (easily) work on a terminal device.  For STDIN, either use the
Term::ReadKey module from CPAN, or use the sample code in `getc', *Note
Perlfunc: perlfunc,.

   If your system supports the portable operating system programming
interface (POSIX), you can use the following code, which you'll note turns
off echo processing as well.

     #!/usr/bin/perl -w
     use strict;
     $| = 1;
     for (1..4) {
     	my $got;
     	print "gimme: ";
     	$got = getone();
     	print "--> $got\n";
     }
     exit;

     BEGIN {
     	use POSIX qw(:termios_h);

     my ($term, $oterm, $echo, $noecho, $fd_stdin);

     $fd_stdin = fileno(STDIN);

     $term     = POSIX::Termios->new();
     $term->getattr($fd_stdin);
     $oterm     = $term->getlflag();

     $echo     = ECHO | ECHOK | ICANON;
     $noecho   = $oterm & ~$echo;

     sub cbreak {
         $term->setlflag($noecho);
         $term->setcc(VTIME, 1);
         $term->setattr($fd_stdin, TCSANOW);
     }

     sub cooked {
         $term->setlflag($oterm);
         $term->setcc(VTIME, 0);
         $term->setattr($fd_stdin, TCSANOW);
     }

     sub getone {
         my $key = '';
         cbreak();
         sysread(STDIN, $key, 1);
         cooked();
         return $key;
     }

     }

     END { cooked() }

   The Term::ReadKey module from CPAN may be easier to use.  Recent version
include also support for non-portable systems as well.

     use Term::ReadKey;
     open(TTY, "</dev/tty");
     print "Gimme a char: ";
     ReadMode "raw";
     $key = ReadKey 0, *TTY;
     ReadMode "normal";
     printf "\nYou said %s, char number %03d\n",
         $key, ord $key;

   For legacy DOS systems, Dan Carson <dbc@tc.fluke.COM> reports the
following:

   To put the PC in "raw" mode, use ioctl with some magic numbers gleaned
from msdos.c (Perl source file) and Ralf Brown's interrupt list (comes
across the net every so often):

     $old_ioctl = ioctl(STDIN,0,0);     # Gets device info
     $old_ioctl &= 0xff;
     ioctl(STDIN,1,$old_ioctl | 32);    # Writes it back, setting bit 5

   Then to read a single character:

     sysread(STDIN,$c,1);               # Read a single character

   And to put the PC back to "cooked" mode:

     ioctl(STDIN,1,$old_ioctl);         # Sets it back to cooked mode.

   So now you have $c.  If `ord($c) == 0', you have a two byte code, which
means you hit a special key.  Read another byte with `sysread(STDIN,$c,1)',
and that value tells you what combination it was according to this table:

     # PC 2-byte keycodes = ^@ + the following:

     # HEX     KEYS
     # ---     ----
     # 0F      SHF TAB
     # 10-19   ALT QWERTYUIOP
     # 1E-26   ALT ASDFGHJKL
     # 2C-32   ALT ZXCVBNM
     # 3B-44   F1-F10
     # 47-49   HOME,UP,PgUp
     # 4B      LEFT
     # 4D      RIGHT
     # 4F-53   END,DOWN,PgDn,Ins,Del
     # 54-5D   SHF F1-F10
     # 5E-67   CTR F1-F10
     # 68-71   ALT F1-F10
     # 73-77   CTR LEFT,RIGHT,END,PgDn,HOME
     # 78-83   ALT 1234567890-=
     # 84      CTR PgUp

   This is all trial and error I did a long time ago, I hope I'm reading
the file that worked.

How can I tell whether there's a character waiting on a filehandle?
-------------------------------------------------------------------

   The very first thing you should do is look into getting the
Term::ReadKey extension from CPAN.  As we mentioned earlier, it now even
has limited support for non-portable (read: not open systems, closed,
proprietary, not POSIX, not Unix, etc) systems.

   You should also check out the Frequently Asked Questions list in
comp.unix.* for things like this: the answer is essentially the same.
It's very system dependent.  Here's one solution that works on BSD systems:

     sub key_ready {
     	my($rin, $nfd);
     	vec($rin, fileno(STDIN), 1) = 1;
     	return $nfd = select($rin,undef,undef,0);
     }

   If you want to find out how many characters are waiting, there's also
the FIONREAD ioctl call to be looked at.  The h2ph tool that comes with
Perl tries to convert C include files to Perl code, which can be required.
FIONREAD ends up defined as a function in the *sys/ioctl.ph* file:

     require 'sys/ioctl.ph';

     $size = pack("L", 0);
     ioctl(FH, FIONREAD(), $size)    or die "Couldn't call ioctl: $!\n";
     $size = unpack("L", $size);

   If h2ph wasn't installed or doesn't work for you, you can grep the
include files by hand:

     % grep FIONREAD /usr/include/*/*
     /usr/include/asm/ioctls.h:#define FIONREAD      0x541B

   Or write a small C program using the editor of champions:

     % cat > fionread.c
     #include <sys/ioctl.h>
     main() {
         printf("%#08x\n", FIONREAD);
     }
     ^D
     % cc -o fionread fionread.c
     % ./fionread
     0x4004667f

   And then hard-code it, leaving porting as an exercise to your successor.

     $FIONREAD = 0x4004667f;         # XXX: opsys dependent

     $size = pack("L", 0);
     ioctl(FH, $FIONREAD, $size)     or die "Couldn't call ioctl: $!\n";
     $size = unpack("L", $size);

   FIONREAD requires a filehandle connected to a stream, meaning sockets,
pipes, and tty devices work, but not files.

How do I do a `tail -f' in perl?
--------------------------------

   First try

     seek(GWFILE, 0, 1);

   The statement `seek(GWFILE, 0, 1)' doesn't change the current position,
but it does clear the end-of-file condition on the handle, so that the
next <GWFILE> makes Perl try again to read something.

   If that doesn't work (it relies on features of your stdio
implementation), then you need something more like this:

     for (;;) {
       for ($curpos = tell(GWFILE); <GWFILE>; $curpos = tell(GWFILE)) {
         # search for some stuff and put it into files
       }
       # sleep for a while
       seek(GWFILE, $curpos, 0);  # seek to where we had been
     }

   If this still doesn't work, look into the POSIX module.  POSIX defines
the clearerr() method, which can remove the end of file condition on a
filehandle.  The method: read until end of file, clearerr(), read some
more.  Lather, rinse, repeat.

   There's also a File::Tail module from CPAN.

How do I dup() a filehandle in Perl?
------------------------------------

   If you check `open', *Note Perlfunc: perlfunc,, you'll see that several
of the ways to call open() should do the trick.  For example:

     open(LOG, ">>/tmp/logfile");
     open(STDERR, ">&LOG");

   Or even with a literal numeric descriptor:

     $fd = $ENV{MHCONTEXTFD};
     open(MHCONTEXT, "<&=$fd");	# like fdopen(3S)

   Note that "<&STDIN" makes a copy, but "<&=STDIN" make an alias.  That
means if you close an aliased handle, all aliases become inaccessible.
This is not true with a copied one.

   Error checking, as always, has been left as an exercise for the reader.

How do I close a file descriptor by number?
-------------------------------------------

   This should rarely be necessary, as the Perl close() function is to be
used for things that Perl opened itself, even if it was a dup of a numeric
descriptor, as with MHCONTEXT above.  But if you really have to, you may
be able to do this:

     require 'sys/syscall.ph';
     $rc = syscall(&SYS_close, $fd + 0);  # must force numeric
     die "can't sysclose $fd: $!" unless $rc == -1;

   Or just use the fdopen(3S) feature of open():

     {
     	local *F;
     	open F, "<&=$fd" or die "Cannot reopen fd=$fd: $!";
     	close F;
     }

Why can't I use "C:\temp\foo" in DOS paths?  What doesn't `C:\temp\foo.exe` work?
---------------------------------------------------------------------------------

   Whoops!  You just put a tab and a formfeed into that filename!
Remember that within double quoted strings ("like\this"), the backslash is
an escape character.  The full list of these is in `Quote and Quote-like
Operators', *Note Perlop: perlop,.  Unsurprisingly, you don't have a file
called "c:(tab)emp(formfeed)oo" or "c:(tab)emp(formfeed)oo.exe" on your
legacy DOS filesystem.

   Either single-quote your strings, or (preferably) use forward slashes.
Since all DOS and Windows versions since something like MS-DOS 2.0 or so
have treated / and \ the same in a path, you might as well use the one
that doesn't clash with Perl - or the POSIX shell, ANSI C and C++, awk,
Tcl, Java, or Python, just to mention a few.  POSIX paths are more
portable, too.

Why doesn't glob("*.*") get all the files?
------------------------------------------

   Because even on non-Unix ports, Perl's glob function follows standard
Unix globbing semantics.  You'll need `glob("*")' to get all (non-hidden)
files.  This makes glob() portable even to legacy systems.  Your port may
include proprietary globbing functions as well.  Check its documentation
for details.

Why does Perl let me delete read-only files?  Why does -i clobber protected files?  Isn't this a bug in Perl?
-------------------------------------------------------------------------------------------------------------

   This is elaborately and painstakingly described in the "Far More Than
You Ever Wanted To Know" in
http://www.perl.com/CPAN/doc/FMTEYEWTK/file-dir-perms .

   The executive summary: learn how your filesystem works.  The
permissions on a file say what can happen to the data in that file.  The
permissions on a directory say what can happen to the list of files in
that directory.  If you delete a file, you're removing its name from the
directory (so the operation depends on the permissions of the directory,
not of the file).  If you try to write to the file, the permissions of the
file govern whether you're allowed to.

How do I select a random line from a file?
------------------------------------------

   Here's an algorithm from the Camel Book:

     srand;
     rand($.) < 1 && ($line = $_) while <>;

   This has a significant advantage in space over reading the whole file
in.  A simple proof by induction is available upon request if you doubt
its correctness.

Why do I get weird spaces when I print an array of lines?
---------------------------------------------------------

   Saying

     print "@lines\n";

   joins together the elements of `@lines' with a space between them.  If
`@lines' were `("little", "fluffy", "clouds")' then the above statement
would print:

     little fluffy clouds

   but if each element of `@lines' was a line of text, ending a newline
character `("little\n", "fluffy\n", "clouds\n")' then it would print:

     little
      fluffy
      clouds

   If your array contains lines, just print them:

     print @lines;

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as an integrated part of the Standard Distribution of
Perl or of its documentation (printed or otherwise), this works is covered
under Perl's Artistic License.  For separate distributions of all or part
of this FAQ outside of that, see *Note Perlfaq: perlfaq,.

   Irrespective of its distribution, all code examples here are in the
public domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you see
fit.  A simple comment in the code giving credit to the FAQ would be
courteous but is not required.


File: perl.info,  Node: perlfaq6,  Next: Top,  Prev: Top,  Up: Top

Regexes ($Revision: 1.27 $, $Date: 1999/05/23 16:08:30 $)
*********************************************************

NAME
====

   perlfaq6 - Regexes ($Revision: 1.27 $, $Date: 1999/05/23 16:08:30 $)

DESCRIPTION
===========

   This section is surprisingly small because the rest of the FAQ is
littered with answers involving regular expressions.  For example,
decoding a URL and checking whether something is a number are handled with
regular expressions, but those answers are found elsewhere in this
document (in the section on Data and the Networking one on networking, to
be precise).

How can I hope to use regular expressions without creating illegible and unmaintainable code?
---------------------------------------------------------------------------------------------

   Three techniques can make regular expressions maintainable and
understandable.

Comments Outside the Regex
     Describe what you're doing and how you're doing it, using normal Perl
     comments.

          # turn the line into the first word, a colon, and the
          # number of characters on the rest of the line
          s/^(\w+)(.*)/ lc($1) . ":" . length($2) /meg;

Comments Inside the Regex
     The `/x' modifier causes whitespace to be ignored in a regex pattern
     (except in a character class), and also allows you to use normal
     comments there, too.  As you can imagine, whitespace and comments help
     a lot.

     `/x' lets you turn this:

          s{<(?:[^>'"]*|".*?"|'.*?')+>}{}gs;

     into this:

          s{ <                    # opening angle bracket
              (?:                 # Non-backreffing grouping paren
                   [^>'"] *       # 0 or more things that are neither > nor ' nor "
                      |           #    or else
                   ".*?"          # a section between double quotes (stingy match)
                      |           #    or else
                   '.*?'          # a section between single quotes (stingy match)
              ) +                 #   all occurring one or more times
             >                    # closing angle bracket
          }{}gsx;                 # replace with nothing, i.e. delete

     It's still not quite so clear as prose, but it is very useful for
     describing the meaning of each part of the pattern.

Different Delimiters
     While we normally think of patterns as being delimited with /
     characters, they can be delimited by almost any character.  *Note
     Perlre: perlre, describes this.  For example, the s/// above uses
     braces as delimiters.  Selecting another delimiter can avoid quoting
     the delimiter within the pattern:

          s/\/usr\/local/\/usr\/share/g;	# bad delimiter choice
          s#/usr/local#/usr/share#g;		# better

I'm having trouble matching over more than one line.  What's wrong?
-------------------------------------------------------------------

   Either you don't have more than one line in the string you're looking at
(probably), or else you aren't using the correct modifier(s) on your
pattern (possibly).

   There are many ways to get multiline data into a string.  If you want
it to happen automatically while reading input, you'll want to set $/
(probably to " for paragraphs or undef for the whole file) to allow you to
read more than one line at a time.

   Read *Note Perlre: perlre, to help you decide which of `/s' and `/m'
(or both) you might want to use: `/s' allows dot to include newline, and
`/m' allows caret and dollar to match next to a newline, not just at the
end of the string.  You do need to make sure that you've actually got a
multiline string in there.

   For example, this program detects duplicate words, even when they span
line breaks (but not paragraph ones).  For this example, we don't need
`/s' because we aren't using dot in a regular expression that we want to
cross line boundaries.  Neither do we need `/m' because we aren't wanting
caret or dollar to match at any point inside the record next to newlines.
But it's imperative that $/ be set to something other than the default, or
else we won't actually ever have a multiline record read in.

     $/ = '';  		# read in more whole paragraph, not just one line
     while ( <> ) {
     	while ( /\b([\w'-]+)(\s+\1)+\b/gi ) {  	# word starts alpha
     	    print "Duplicate $1 at paragraph $.\n";
     	}
     }

   Here's code that finds sentences that begin with "From " (which would
be mangled by many mailers):

     $/ = '';  		# read in more whole paragraph, not just one line
     while ( <> ) {
     	while ( /^From /gm ) { # /m makes ^ match next to \n
     	    print "leading from in paragraph $.\n";
     	}
     }

   Here's code that finds everything between START and END in a paragraph:

     undef $/;  		# read in whole file, not just one line or paragraph
     while ( <> ) {
     	while ( /START(.*?)END/sm ) { # /s makes . cross line boundaries
     	    print "$1\n";
     	}
     }

How can I pull out lines between two patterns that are themselves on different lines?
-------------------------------------------------------------------------------------

   You can use Perl's somewhat exotic `..' operator (documented in *Note
Perlop: perlop,):

     perl -ne 'print if /START/ .. /END/' file1 file2 ...

   If you wanted text and not lines, you would use

     perl -0777 -ne 'print "$1\n" while /START(.*?)END/gs' file1 file2 ...

   But if you want nested occurrences of START through END, you'll run up
against the problem described in the question in this section on matching
balanced text.

   Here's another example of using `..':

     while (<>) {
         $in_header =   1  .. /^$/;
         $in_body   = /^$/ .. eof();
     	# now choose between them
     } continue {
     	reset if eof();		# fix $.
     }

I put a regular expression into $/ but it didn't work. What's wrong?
--------------------------------------------------------------------

   $/ must be a string, not a regular expression.  Awk has to be better
for something. :-)

   Actually, you could do this if you don't mind reading the whole file
into memory:

     undef $/;
     @records = split /your_pattern/, <FH>;

   The Net::Telnet module (available from CPAN) has the capability to wait
for a pattern in the input stream, or timeout if it doesn't appear within
a certain time.

     ## Create a file with three lines.
     open FH, ">file";
     print FH "The first line\nThe second line\nThe third line\n";
     close FH;

     ## Get a read/write filehandle to it.
     $fh = new FileHandle "+<file";

     ## Attach it to a "stream" object.
     use Net::Telnet;
     $file = new Net::Telnet (-fhopen => $fh);

     ## Search for the second line and print out the third.
     $file->waitfor('/second line\n/');
     print $file->getline;

How do I substitute case insensitively on the LHS, but preserving case on the RHS?
----------------------------------------------------------------------------------

   Here's a lovely Perlish solution by Larry Rosler.  It exploits
properties of bitwise xor on ASCII strings.

     $_= "this is a TEsT case";

     $old = 'test';
     $new = 'success';

     s{(\Q$old\E}
      { uc $new | (uc $1 ^ $1) .
     	(uc(substr $1, -1) ^ substr $1, -1) x
     	    (length($new) - length $1)
      }egi;

     print;

   And here it is as a subroutine, modelled after the above:

     sub preserve_case($$) {
     	my ($old, $new) = @_;
     	my $mask = uc $old ^ $old;

     uc $new | $mask .
         substr($mask, -1) x (length($new) - length($old))
         }

     $a = "this is a TEsT case";
     $a =~ s/(test)/preserve_case($1, "success")/egi;
     print "$a\n";

   This prints:

     this is a SUcCESS case

   Just to show that C programmers can write C in any programming language,
if you prefer a more C-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.  (It
also happens to run about 240% slower than the Perlish solution runs.)  If
the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.

     # Original by Nathan Torkington, massaged by Jeffrey Friedl
     #
     sub preserve_case($$)
     {
         my ($old, $new) = @_;
         my ($state) = 0; # 0 = no change; 1 = lc; 2 = uc
         my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
         my ($len) = $oldlen < $newlen ? $oldlen : $newlen;

     for ($i = 0; $i < $len; $i++) {
         if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) {
             $state = 0;
         } elsif (lc $c eq $c) {
             substr($new, $i, 1) = lc(substr($new, $i, 1));
             $state = 1;
         } else {
             substr($new, $i, 1) = uc(substr($new, $i, 1));
             $state = 2;
         }
     }
     # finish up with any remaining new (for when new is longer than old)
     if ($newlen > $oldlen) {
         if ($state == 1) {
             substr($new, $oldlen) = lc(substr($new, $oldlen));
         } elsif ($state == 2) {
             substr($new, $oldlen) = uc(substr($new, $oldlen));
         }
     }
     return $new;
         }

How can I make `\w' match national character sets?
--------------------------------------------------

   See *Note Perllocale: perllocale,.

How can I match a locale-smart version of `/[a-zA-Z]/'?
-------------------------------------------------------

   One alphabetic character would be `/[^\W\d_]/', no matter what locale
you're in.  Non-alphabetics would be `/[\W\d_]/' (assuming you don't
consider an underscore a letter).

How can I quote a variable to use in a regex?
---------------------------------------------

   The Perl parser will expand $variable and @variable references in
regular expressions unless the delimiter is a single quote.  Remember,
too, that the right-hand side of a s/// substitution is considered a
double-quoted string (see *Note Perlop: perlop, for more details).
Remember also that any regex special characters will be acted on unless you
precede the substitution with \Q.  Here's an example:

     $string = "to die?";
     $lhs = "die?";
     $rhs = "sleep, no more";

     $string =~ s/\Q$lhs/$rhs/;
     # $string is now "to sleep no more"

   Without the \Q, the regex would also spuriously match "di".

What is `/o' really for?
------------------------

   Using a variable in a regular expression match forces a re-evaluation
(and perhaps recompilation) each time through.  The `/o' modifier locks in
the regex the first time it's used.  This always happens in a constant
regular expression, and in fact, the pattern was compiled into the
internal format at the same time your entire program was.

   Use of `/o' is irrelevant unless variable interpolation is used in the
pattern, and if so, the regex engine will neither know nor care whether
the variables change after the pattern is evaluated the *very first* time.

   `/o' is often used to gain an extra measure of efficiency by not
performing subsequent evaluations when you know it won't matter (because
you know the variables won't change), or more rarely, when you don't want
the regex to notice if they do.

   For example, here's a "paragrep" program:

     $/ = '';  # paragraph mode
     $pat = shift;
     while (<>) {
         print if /$pat/o;
     }

How do I use a regular expression to strip C style comments from a file?
------------------------------------------------------------------------

   While this actually can be done, it's much harder than you'd think.
For example, this one-liner

     perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

   will work in many but not all cases.  You see, it's too simple-minded
for certain kinds of C programs, in particular, those with what appear to
be comments in quoted strings.  For that, you'd need something like this,
created by Jeffrey Friedl and later modified by Fred Curtis.

     $/ = undef;
     $_ = <>;
     s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs
     print;

   This could, of course, be more legibly written with the `/x' modifier,
adding whitespace and comments.  Here it is expanded, courtesy of Fred
Curtis.

     s{
        /\*         ##  Start of /* ... */ comment
        [^*]*\*+    ##  Non-* followed by 1-or-more *'s
        (
          [^/*][^*]*\*+
        )*          ##  0-or-more things which don't start with /
                    ##    but do end with '*'
        /           ##  End of /* ... */ comment

     |         ##     OR  various things which aren't comments:

     (
       "           ##  Start of " ... " string
       (
         \\.           ##  Escaped char
       |               ##    OR
         [^"\\]        ##  Non "\
       )*
       "           ##  End of " ... " string

     |         ##     OR

     '           ##  Start of ' ... ' string
     (
       \\.           ##  Escaped char
     |               ##    OR
       [^'\\]        ##  Non '\
     )*
     '           ##  End of ' ... ' string

     |         ##     OR

     .           ##  Anything other char
     [^/"'\\]*   ##  Chars which doesn't start a comment, string or escape
            )
          }{$2}gxs;

   A slight modification also removes C++ comments:

     s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs;

Can I use Perl regular expressions to match balanced text?
----------------------------------------------------------

   Although Perl regular expressions are more powerful than "mathematical"
regular expressions, because they feature conveniences like backreferences
(\1 and its ilk), they still aren't powerful enough - with the possible
exception of bizarre and experimental features in the development-track
releases of Perl.  You still need to use non-regex techniques to parse
balanced text, such as the text enclosed between matching parentheses or
braces, for example.

   An elaborate subroutine (for 7-bit ASCII only) to pull out balanced and
possibly nested single chars, like ``' and `'', `{' and `}', or ( and )
can be found in
http://www.perl.com/CPAN/authors/id/TOMC/scripts/pull_quotes.gz .

   The C::Scan module from CPAN contains such subs for internal usage, but
they are undocumented.

What does it mean that regexes are greedy?  How can I get around it?
--------------------------------------------------------------------

   Most people mean that greedy regexes match as much as they can.
Technically speaking, it's actually the quantifiers (?, *, +, `{}') that
are greedy rather than the whole pattern; Perl prefers local greed and
immediate gratification to overall greed.  To get non-greedy versions of
the same quantifiers, use (`??', `*?', `+?', `{}?').

   An example:

     $s1 = $s2 = "I am very very cold";
     $s1 =~ s/ve.*y //;      # I am cold
     $s2 =~ s/ve.*?y //;     # I am very cold

   Notice how the second substitution stopped matching as soon as it
encountered "y ".  The `*?' quantifier effectively tells the regular
expression engine to find a match as quickly as possible and pass control
on to whatever is next in line, like you would if you were playing hot
potato.

How do I process each word on each line?
----------------------------------------

   Use the split function:

     while (<>) {
     	foreach $word ( split ) {
     	    # do something with $word here
     	}
     }

   Note that this isn't really a word in the English sense; it's just
chunks of consecutive non-whitespace characters.

   To work with only alphanumeric sequences, you might consider

     while (<>) {
     	foreach $word (m/(\w+)/g) {
     	    # do something with $word here
     	}
     }

How can I print out a word-frequency or line-frequency summary?
---------------------------------------------------------------

   To do this, you have to parse out each word in the input stream.  We'll
pretend that by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than the non-whitespace chunk idea of a word given in
the previous question:

     while (<>) {
     	while ( /(\b[^\W_\d][\w'-]+\b)/g ) {   # misses "`sheep'"
     	    $seen{$1}++;
     	}
     }
     while ( ($word, $count) = each %seen ) {
     	print "$count $word\n";
     }

   If you wanted to do the same thing for lines, you wouldn't need a
regular expression:

     while (<>) {
     	$seen{$_}++;
     }
     while ( ($line, $count) = each %seen ) {
     	print "$count $line";
     }

   If you want these output in a sorted order, see the section on Hashes.

How can I do approximate matching?
----------------------------------

   See the module String::Approx available from CPAN.

How do I efficiently match many regular expressions at once?
------------------------------------------------------------

   The following is extremely inefficient:

     # slow but obvious way
     @popstates = qw(CO ON MI WI MN);
     while (defined($line = <>)) {
     	for $state (@popstates) {
     	    if ($line =~ /\b$state\b/i) {
     		print $line;
     		last;
     	    }
     	}
     }

   That's because Perl has to recompile all those patterns for each of the
lines of the file.  As of the 5.005 release, there's a much better
approach, one which makes use of the new `qr//' operator:

     # use spiffy new qr// operator, with /i flag even
     use 5.005;
     @popstates = qw(CO ON MI WI MN);
     @poppats   = map { qr/\b$_\b/i } @popstates;
     while (defined($line = <>)) {
     	for $patobj (@poppats) {
     	    print $line if $line =~ /$patobj/;
     	}
     }

Why don't word-boundary searches with `\b' work for me?
-------------------------------------------------------

   Two common misconceptions are that `\b' is a synonym for `\s+', and
that it's the edge between whitespace characters and non-whitespace
characters.  Neither is correct.  `\b' is the place between a `\w'
character and a `\W' character (that is, `\b' is the edge of a "word").
It's a zero-width assertion, just like ^, `$', and all the other anchors,
so it doesn't consume any characters.  *Note Perlre: perlre, describes the
behavior of all the regex metacharacters.

   Here are examples of the incorrect application of `\b', with fixes:

     "two words" =~ /(\w+)\b(\w+)/;	    # WRONG
     "two words" =~ /(\w+)\s+(\w+)/;	    # right

     " =matchless= text" =~ /\b=(\w+)=\b/;   # WRONG
     " =matchless= text" =~ /=(\w+)=/;       # right

   Although they may not do what you thought they did, `\b' and `\B' can
still be quite useful.  For an example of the correct use of `\b', see the
example of matching duplicate words over multiple lines.

   An example of using `\B' is the pattern `\Bis\B'.  This will find
occurrences of "is" on the insides of words only, as in "thistle", but not
"this" or "island".

Why does using $&, $`, or $' slow my program down?
--------------------------------------------------

   Because once Perl sees that you need one of these variables anywhere in
the program, it has to provide them on each and every pattern match.  The
same mechanism that handles these provides for the use of $1, $2, etc., so
you pay the same price for each regex that contains capturing parentheses.
But if you never use $&, etc., in your script, then regexes *without*
capturing parentheses won't be penalized. So avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price.  Remember that some algorithms
really appreciate them.  As of the 5.005 release.  the $& variable is no
longer "expensive" the way the other two are.

What good is `\G' in a regular expression?
------------------------------------------

   The notation `\G' is used in a match or substitution in conjunction the
`/g' modifier (and ignored if there's no `/g') to anchor the regular
expression to the point just past where the last match occurred, i.e. the
pos() point.  A failed match resets the position of `\G' unless the `/c'
modifier is in effect.

   For example, suppose you had a line of text quoted in standard mail and
Usenet notation, (that is, with leading `< ' >> characters), and you want
change each leading `< ' >> into a corresponding :.  You could do so in
this way:

     s/^(>+)/':' x length($1)/gem;

   Or, using `\G', the much simpler (and faster):

     s/\G>/:/g;

   A more sophisticated use might involve a tokenizer.  The following
lex-like example is courtesy of Jeffrey Friedl.  It did not work in 5.003
due to bugs in that release, but does work in 5.004 or better.  (Note the
use of `/c', which prevents a failed match with `/g' from resetting the
search position back to the beginning of the string.)

     while (<>) {
       chomp;
       PARSER: {
            m/ \G( \d+\b    )/gcx    && do { print "number: $1\n";  redo; };
            m/ \G( \w+      )/gcx    && do { print "word:   $1\n";  redo; };
            m/ \G( \s+      )/gcx    && do { print "space:  $1\n";  redo; };
            m/ \G( [^\w\d]+ )/gcx    && do { print "other:  $1\n";  redo; };
       }
     }

   Of course, that could have been written as

     while (<>) {
       chomp;
       PARSER: {
     	   if ( /\G( \d+\b    )/gcx  {
     		print "number: $1\n";
     		redo PARSER;
     	   }
     	   if ( /\G( \w+      )/gcx  {
     		print "word: $1\n";
     		redo PARSER;
     	   }
     	   if ( /\G( \s+      )/gcx  {
     		print "space: $1\n";
     		redo PARSER;
     	   }
     	   if ( /\G( [^\w\d]+ )/gcx  {
     		print "other: $1\n";
     		redo PARSER;
     	   }
       }
     }

   But then you lose the vertical alignment of the regular expressions.

Are Perl regexes DFAs or NFAs?  Are they POSIX compliant?
---------------------------------------------------------

   While it's true that Perl's regular expressions resemble the DFAs
(deterministic finite automata) of the egrep(1) program, they are in fact
implemented as NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing.  And they aren't POSIX-style either,
because those guarantee worst-case behavior for all cases.  (It seems that
some people prefer guarantees of consistency, even when what's guaranteed
is slowness.)  See the book "Mastering Regular Expressions" (from
O'Reilly) by Jeffrey Friedl for all the details you could ever hope to
know on these matters (a full citation appears in *Note Perlfaq2:
perlfaq2,).

What's wrong with using grep or map in a void context?
------------------------------------------------------

   Both grep and map build a return list, regardless of their context.
This means you're making Perl go to the trouble of building up a return
list that you then just ignore.  That's no way to treat a programming
language, you insensitive scoundrel!

How can I match strings with multibyte characters?
--------------------------------------------------

   This is hard, and there's no good way.  Perl does not directly support
wide characters.  It pretends that a byte and a character are synonymous.
The following set of approaches was offered by Jeffrey Friedl, whose
article in issue #5 of The Perl Journal talks about this very matter.

   Let's suppose you have some weird Martian encoding where pairs of ASCII
uppercase letters encode single Martian letters (i.e. the two bytes "CV"
make a single Martian letter, as do the two bytes "SG", "VS", "XX", etc.).
Other bytes represent single characters, just like ASCII.

   So, the string of Martian "I am CVSGXX!" uses 12 bytes to encode the
nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.

   Now, say you want to search for the single character `/GX/'. Perl
doesn't know about Martian, so it'll find the two bytes "GX" in the "I am
CVSGXX!"  string, even though that character isn't there: it just looks
like it is because "SG" is next to "XX", but there's no real "GX".  This
is a big problem.

   Here are a few ways, all painful, to deal with it:

     $martian =~ s/([A-Z][A-Z])/ $1 /g; # Make sure adjacent ``martian'' bytes
                                        # are no longer adjacent.
     print "found GX!\n" if $martian =~ /GX/;

   Or like this:

     @chars = $martian =~ m/([A-Z][A-Z]|[^A-Z])/g;
     # above is conceptually similar to:     @chars = $text =~ m/(.)/g;
     #
     foreach $char (@chars) {
         print "found GX!\n", last if $char eq 'GX';
     }

   Or like this:

     while ($martian =~ m/\G([A-Z][A-Z]|.)/gs) {  # \G probably unneeded
         print "found GX!\n", last if $1 eq 'GX';
     }

   Or like this:

     die "sorry, Perl doesn't (yet) have Martian support )-:\n";

   There are many double- (and multi-) byte encodings commonly used these
days.  Some versions of these have 1-, 2-, 3-, and 4-byte characters, all
mixed.

How do I match a pattern that is supplied by the user?
------------------------------------------------------

   Well, if it's really a pattern, then just use

     chomp($pattern = <STDIN>);
     if ($line =~ /$pattern/) { }

   Or, since you have no guarantee that your user entered a valid regular
expression, trap the exception this way:

     if (eval { $line =~ /$pattern/ }) { }

   But if all you really want to search for a string, not a pattern, then
you should either use the index() function, which is made for string
searching, or if you can't be disabused of using a pattern match on a
non-pattern, then be sure to use `\Q'...`\E', documented in *Note Perlre:
perlre,.

     $pattern = <STDIN>;

     open (FILE, $input) or die "Couldn't open input $input: $!; aborting";
     while (<FILE>) {
     	print if /\Q$pattern\E/;
     }
     close FILE;

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.


