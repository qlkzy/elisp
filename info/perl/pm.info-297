This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: POE/NFA,  Next: POE/Preprocessor,  Prev: POE/Kernel,  Up: Module List

a Nondeterministic Finite Automaton session
*******************************************

NAME
====

   POE::NFA - a Nondeterministic Finite Automaton session

SYNOPSIS
========

     use POE::NFA;

     # Define a machine's states, each state's events, and the coderefs
     # that handle each event.
     my %states =
       ( start =>
         { event_one => \&handler_one,
           event_two => \&handler_two,
           ...,
         },
         other_state =>
         { event_n          => \&handler_n,
           event_n_plus_one => \&handler_n_plus_one,
           ...,
         },
         ...,
       );

     # Spawn a state machine, and enter an initial state/event pair.
     POE::NFA->spawn( inline_states => \%states
                    )->goto_state( $start_state, $start_event );

     # Enter a new state without the intention of returning to the
     # current one.
     $machine->goto_state( $new_state, $new_event, @args );

     # Enter a new state with the intention of resuming the current
     # state.  $return_event is the event in the calling state that will
     # be invoked when the called state returns.
     $machine->call_state( $return_event, $new_state, $new_event, @args );

     # Return from the current state to its calling state.  The caller's
     # $return_event (from a previous call_state() call) will be invoked
     # with @returns.
     $machine->return_state( @returns );

     # Force the machine to stop.  The machine also will stop if it runs
     # out of events or event sources (such as filehandles or alarms).
     $machine->stop();

DESCRIPTION
===========

   This document assumes the reader already is familiar with POE::Session.

   POE::NFA instances run a particular kind of session: the
nondeterministic finite automaton (NFA).  NFAs are state machines which
determine the next state to be in by conditions at runtime.  This is
different from DFA (deterministic FAs), which have next states determined
for them at compile time.

Resource Tracking
-----------------

   See POE::Session's documentation.

Job Control and Family Values
-----------------------------

   See POE::Session's documentation.

State Types
-----------

   See POE::Session's documentation.

   Only inline_states are supported at this time.

POE::NFA Exports
================

   See POE::Session's documentation.

   Three exported constants differ from POE::Session:

MACHINE
     This is equivalent to POE::Sesion's SESSION constant.  It holds a
     reference to the current state machine, and it's useful for calling
     methods on it:

          $_[MACHINE]->goto_state( $next_state, $next_state_entry_event );

RUNSTATE
     This is equivalent to POE::Session's HEAP constant.  It holds an
     anonymous hash reference which POE will guarantee not to touch.  Each
     POE::NFA instance gets its own RUNSTATE.  This is a great place to put
     machine-scoped data.

EVENT
     This is equivalent to POE::Session's STATE constant.  It contains the
     name of the event which invoked the current event handler.  This is
     mainly for the _default state, which may need to know what was
     supposed to be invoked.

POE::NFA's Predefined Events
============================

   See POE::Session's documentation on "Predefined States".

   POE::NFA defines four events of its own:

poe_nfa_goto_state
poe_nfa_pop_state
poe_nfa_push_state
poe_nfa_stop
     POE::NFA uses these four states internally to manage state transitions
     and stopping the machine in an orderly fashion.  There may be others
     in the future, and they will all follow the /^poe_nfa_/ naming
     convention.  To avoid conflicts, please don't define events beginning
     with "poe_nfa_".

States' Return Values
---------------------

   See POE::Session's documentation.

PUBLIC METHODS
==============

   See POE::Session's documentation.

ID
     Same as with POE::Session.

no create method
no new method
     Instead, POE::NFA uses a spawn() method to spawn a new NFA nistance.
     The NFA is defined by one or more hashes that map state/event pairs to
     handlers:

          my %machine =
            ( state_1 =>
              { event_1 => \&handler_1,
                event_2 => \&handler_2,
              },
              state_2 =>
              { event_1 => \&handler_3,
                event_2 => \&handler_4,
              },
            );

     The same event may exist in different states.  POE::NFA will call the
     appropriate handler for the current event in the current state.  For
     example, if event_1 is dispatched while the machine is in state_2,
     then handler_3 will be called.  This happens because...

          $machine{state_2}->{event_1} = \&handler_3;

     POE::NFA's spawn() method currently only accepts inline_states and
     options.

option OPTION_NAME
option OPTION_NAME, OPTION_VALUE
option NAME_VALUE_PAIR_LIST
     Same as with POE::Session.

postback EVENT_NAME, PARAMETER_LIST
     Same as with POE::Session.

goto_state NEW_STATE
goto_state NEW_STATE, ENTRY_EVENT
goto_state NEW_STATE, ENTRY_EVENT, EVENT_ARGS
     Puts the current machine into a new state.  If an ENTRY_EVENT is
     specified, then that event will be called when the machine enters the
     new state.  EVENT_ARGS, if specified, will be passed to it via
     `@_[ARG0..$#_]'.

          $_[MACHINE]->goto_state( 'next_state' );
          $_[MACHINE]->goto_state( 'next_state', 'call_this_event' );
          $_[MACHINE]->goto_state( 'next_state', 'call_this_event', @with_these_args );

stop
     This forces a machine to stop.  It's similar to posting _stop to the
     machine, but it does some extra NFA cleanup.  The machine will also
     stop gracefully if it runs out of things to do.

     `stop()' is heavy-handed.  It will force resource cleanup.  Circular
     references in the machine's RUNSTATE are not POE's responsibility.

          $_[MACHINE]->stop();

call_state RETURN_EVENT, NEW_STATE
call_state RETURN_EVENT, NEW_STATE, ENTRY_EVENT
call_state RETURN_EVENT, NEW_STATE, ENTRY_EVENT, EVENT_ARGS
     call_state is similar to goto_state, but the intention is that the
     new state will eventually return_state back.  It accepts an extra
     parameter, RETURN_EVENT, which is the event in the caller's state
     that will be called when the callee's state returns.  That is, the
     called state returns to our RETURN_EVENT.

     ENTRY_EVENT is the event in the called state that will be called when
     the machine enters it.  ENTRY_ARGS are passed to the called state's
     event via `@_[ARG0..$#_]'.

     RETURN_EVENT is the event in the *caller's* state that is invoked
     when the *callee* returns via return_state.  It receives
     return_state's RETURN_ARGS via `@_[ARG0..$#_]'.

return_state
return_state RETURN_ARGS
     Return to the most recent state which called call_state, optionally
     invoking the call_state's RETURN_EVENT, possibly with RETURN_ARGS.

          $_[MACHINE]->return_state( );
          $_[MACHINE]->return_state( 'success', $something );

SEE ALSO
========

   The POE manpage contains holistic POE information, including an up to
date list of the modules comprising it.  The POE::Session manpage is a
"must read", says the New York Times, and it covers many concepts which
this manpage casually glosses over.

BUGS
====

   See POE::Session's documentation.

   Object and package states aren't implemented.  Some other stuff is just
lashed together with twine.  POE::NFA needs some more development.

   The documentation is slapped together hastily, too.

AUTHORS & COPYRIGHTS
====================

   Please see the POE manpage for authors and licenses.


File: pm.info,  Node: POE/Preprocessor,  Next: POE/Session,  Prev: POE/NFA,  Up: Module List

A Macro Preprocessor
********************

NAME
====

   POE::Preprocessor - A Macro Preprocessor

SYNOPSIS
========

     use POE::Preprocessor;

     macro max (one,two) {
       ((one) > (two) ? (one) : (two))
     }

     print {% max $one, $two %}, "\n";

     const PI 3.14159265359

     print "PI\n";  # Substitutions don't grok Perl!

     enum ONE TWO THREE
     enum 12 TWELVE THIRTEEN FOURTEEN
     enum + FIFTEEN SIXTEEN SEVENTEEN

     print "ONE TWO THREE TWELVE THIRTEEN FOURTEEN FIFTEEN SIXTEEN SEVENTEEN\n";

     if ($expression) {      # include
        ... lines of code ...
     }                       # include

     unless ($expression) {  # include
       ... lines of code ...
     } elsif ($expression) { # include
       ... lines of code ...
     } else {                # include
       ... lines of code ...
     }                       # include

DESCRIPTION
===========

   POE::Preprocessor is a Perl source filter that implements a simple
macro substitution language.

Macros
------

   The preprocessor defines a "macro" compile-time directive:

     macro macro_name (parameter_0, parameter_1) {
       macro code ... parameter_0 ... parameter_1 ...
     }

   The parameter list is optional for macros that don't accept parameters.

   Macros are substituted into a program with a syntax borrowed from
Iaijutsu and altered slightly to jive with Perl's native syntax.

     {% macro_name parameter_0, parameter_1 %}

Constants and Enumerations
--------------------------

   Constants are defined this way:

     const CONSTANT_NAME    'constant value'
     const ANOTHER_CONSTANT 23

   Enumerations can begin with 0:

     enum ZEROTH FIRST SECOND ...

   Or some other number:

     enum 10 TENTH ELEVENTH TWELFTH

   Or continue where the previous one left off, which is necessary because
an enumeration can't span lines:

     enum + THIRTEENTH FOURTEENTH FIFTEENTH ...

Conditional Code Inclusion (#ifdef)
-----------------------------------

   The preprocessor supports something like cpp's #if/#else/#endif by
usurping a bit of Perl's conditional syntax.  The following conditional
statements will be evaluated at compile time if they are followed by the
comment `# include':

     if (EXPRESSION) {      # include
       BLOCK;
     } elsif (EXPRESSION) { # include
       BLOCK;
     } else {               # include
       BLOCK;
     }                      # include

     unless (EXPRESSION) {  # include
       BLOCK;
     }                      # include

   The code in each conditional statement's BLOCK will be included or
excluded in the compiled code depending on the outcome of its EXPRESSION.

   Conditional includes are nestable, but else and elsif must be on the
same line as the previous block's closing brace.  This may change later.

DEBUGGING
=========

   POE::Preprocessor has three debugging constants: DEBUG (which traces
source filtering to stderr); DEBUG_INVOKE (which traces macro
substitutions); and DEBUG_DEFINE (which traces macro, const and enum
definitions).  They can be overridden prior to POE::Preprocessor's use:

     sub POE::Preprocessor::DEBUG        () { 1 } # trace preprocessor
     sub POE::Preprocessor::DEBUG_INVOKE () { 1 } # trace macro use
     sub POE::Preprocessor::DEBUG_DEFINE () { 1 } # trace macro/const/enum defs
     use POE::Preprocessor;

BUGS
====

   * Source filters are line-based, and so is the macro language.  The only
     constructs that may span lines are the brace-delimited macro
     definitions.  And those *must* span lines.

   * The regular expressions that detect and replace code are simplistic
     and may not do the right things when given challenging Perl syntax to
     parse.  This includes placing constants in strings.

   * Substitution is done in two phases: macros first, then constants.  It
     would be nicer (and more dangerous) if the phases looped around and
     around until no more substitutions occurred.

   * Optimum matches aren't, but they're better than nothing.

SEE ALSO
========

   The regexp optimizer is based on code in Ilya Zakharevich's Text::Trie.

AUTHOR & COPYRIGHT
==================

   POE::Preprocessor is Copyright 2000 Rocco Caputo.  All rights reserved.
POE::Preprocessor is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.


File: pm.info,  Node: POE/Session,  Next: POE/Wheel,  Prev: POE/Preprocessor,  Up: Module List

a POE thread of execution
*************************

NAME
====

   POE::Session - a POE thread of execution

SYNOPSIS
========

   The POE manpage includes and describes a sample program.

     # Import POE::Session constants.
     use POE::Session;

   POE::Session has two different constructors.  The older one, new(), is
quite DWIMmy.  This was clever to begin with, but it has impeded
understanding and maintainability as time has passed, and now it's
somewhat depreciated.  The newer constructor, create(), is very DWIS,
which enables it to validate its parameters better and accept more of
them.  The create() constructor is therefore recommended over new().

     # This is the older, more DWIMmy session constructor.
     POE::Session->new(

     # These are called inline states because they originally were
     # defined using inline coderefs.
     state_one => \&coderef_one,
     state_two => sub { ... },

     # Plain object and package states map state names to identical
     # method names.  For example, $object_one->state_three() is called
     # to handle 'state_three':
     $object_one  => [ 'state_three', 'state_four',  'state_five'  ],
     $package_one => [ 'state_six',   'state_seven', 'state_eight' ],

     # Mapped object and package states may have different method names
     # for their state names.  For example, $package_two->method_ten()
     # is called to handle 'state_ten'.  Mapped states are defined by
     # hashrefs, which in turn define the relationships between state
     # names and their handlers' methods.
     $object_two  => { state_nine => 'method_nine', ... },
     $package_two => { state_ten  => 'method_ten', ... },

     # A list reference by itself indicates arguments to pass to the
     # session's _start state.  This can occur anywhere in the
     # constructor's parameters.
     \@start_args,
       );

     # This is the newer, more explicit constructor.
     POE::Session->create(

     # The list 'args' refers to is passed as arguments to the
     # session's special _start state.
     args => [ argument_zero, argument_one, ... ],

     # "Inline" states are named as such because they can (and
     # originally were) defined with inline anonymous coderefs.
     inline_states =>
       { state_one => \&coderef_one,
         state_two => sub { ... },
       },

     # These plain and aliased object states match the ones shown in
     # POE::Session->new's synopsis.  Note, though, that the right side
     # of the => operator is a list reference; not a hash reference.
     # 'object_states' is associated with a list reference so that
     # object references aren't stringified when they would become hash
     # keys.
     object_states =>
     [ $object_one => [ 'state_three', 'state_four', 'state_five' ],
       $object_two => { state_nine => 'method_nine' },
     ],

     # These plain and aliased package states match the ones shown in
     # POE::Session->new's synopsis.  'package_states' is associated
     # with a list reference for consistency with 'object_states'.
     package_states =>
     [ $package_one => [ 'state_six', 'state_seven', 'state_eight' },
       $package_two => { state_ten => 'method_ten' },
     ],

     # create() has one feature over new(), which is somewhat
     # depreciated and falling behind in features.  create() allows
     # session options to be set at creation time.  'options' refers to
     # a hash containing option names and initial values.
     options => \%options,

     # Specify a heap other than the default empty hashref.
     heap => [ ],
       );

   Other methods:

     # Retrieve a session's unique identifier.
     $session_id = $session->ID;

     # Retrieve a reference to the session's heap.
     $session_heap = $session->get_heap;

     # Set or clear session options.
     $session->option( trace => 1, default => 1 );
     $session->option( trace );

     # Create a postback.  This is an anonymous coderef that posts an
     # event back to the current session when called.  It's part of POE's
     # cooperation interface to other event loops and resource watchers.
     $postback_coderef = $session->postback( $state_name, @state_args );
     &{ $postback_coderef }( @additional_args );

DESCRIPTION
===========

   POE::Session is a framework that binds discrete states into machines.
It accepts states as constructor parameters, wraps them up, and notifies
POE::Kernel that it's ready to begin.  The Kernel registers the it for
resource management, then invokes its special _start state to let it know
it's cleared for take-off.

   As sessions run, they post their state transitions through the Kernel's
FIFO event queue.  The Kernel dispatches the transitions back to sessions
in turn, and the sessions invoke the appropriate states to handle them.
When several sessions do this, their state invocations are interleaved,
and cooperative multitasking ensues.  This is much more stable than the
current state of Perl's threads, and it lends itself to cleaner and more
efficient design for certain classes of programs.

Resource Tracking
-----------------

   Sessions have POE::Kernel and other event loops watch for resources on
their behalf.  They do this by asking them to invoke their states when
resources become active: "Be a dear and let me know when someone clicks on
this widget.  Thanks so much!"  In the meantime, they can continue running
other states or just do nothing with such staggering efficiency that other
sessions can run *their* states.

   Some resources need to be serviced right away or they'll faithfully
continue reporting their readiness.  Filehandles are like this.  The
states that service this sort of resource are called right away, bypassing
the Kernel's FIFO.  Otherwise the time spent between enqueuing and
dispatching the "Hi, love; your resource is ready."  event will also be
spent by POE enqueuing several copies of it.  That's bad form.  States
that service friendlier resources, such as signals, are notified through
the FIFO.

   External libraries' resource watchers usually expect to call a coderef
when a resource becomes ready.  POE::Session's postback() method provides
a coderef for them that, when called, posts notice of the event through
the Kernel's FIFO.  This allows POE to use every event watcher currently
known without requiring special code for each.  It should also support
future event watchers without requiring extra code, so sessions can take
advantage of them as soon as they're available.

   Most importantly, since POE::Kernel keeps track of everything sessions
do, it knows when they've run out of them.  Rather than let defunct
sessions forever consume memory without ever doing another thing, the
Kernel invokes their _stop states as if to say "Please switch off the
lights and lock up; it's time to go." and then destroys them.

   Likewise, if a session stops on its own and there still are opened
resource watchers, the Kernel can close them.  POE excels at long-running
services, and resource leaks shall not be tolerated.

Job Control and Family Values
-----------------------------

   Sessions are resources too, but they are watched automatically
throughout their lifetimes.  The Kernel can do this since it's keenly
aware of their arrivals and departures.  It has to be since it's managing
resources for them.

   Sessions spawn children by creating new sessions.  It's that simple.
New sessions' _parent states are invoked to tell them who their parents
are.  Likewise, their parents' _child states are invoked to let them know
when child sessions come and go.  These are very handy for job control.

State Types
-----------

   POE::Session can wrap three sorts of state.  Each has a name that
strives to describe exactly what it does, but they still need detailed
explanations, so here we go.

   * Inline states

     Inline states are merely coderefs.  They originally were defined with
     inline anonymous coderefs, like so:

          POE::Session->create(
            inline_states =>
            { state_name_one => sub { print "state one"; },
              state_name_two => sub { print "state two"; },
            }
          );

     This can be taken to the extreme, defining enormous state machines in
     a single POE::Session constructor.  Some people consider this
     delightfully Java-esque while others hate it to death.  Luckily for
     the latter people, named coderefs are also possible:

          sub state_code_one { print "state one"; }
          sub state_code_two { print "state two"; }

          POE::Session->create(
            inline_states =>
            { state_name_one => \&state_code_one,
              state_name_two => \&state_code_two,
            }
          );

   * Object states

     Then came states that could be implemented as object methods.  I
     believe Artur asked for these to interface POE with objects he'd
     already written.  In this case, every state is mapped to method call:

          POE::Session->create(
            object_states =>
            [ $object => [ 'state_name_one', 'state_name_two' ]
            ]
          );

     It's important to note that while inline_states maps to a hash
     reference, object_states maps to a list reference.  $object would have
     lost its blessing had object_states mapped to a hashref, and invoking
     its methods would be difficult.

     Sessions can bind methods from multiple objects, too:

          POE::Session->create(
            object_states =>
            [ $object_1 => [ 'state_name_one',   'state_name_two'  ],
              $object_2 => [ 'state_name_three', 'state_name_four' ],
            ]
          );

     Abigail then insisted that the hard link between state and method
     names be broken.  She uses the common convention of leading
     underscores denoting private symbols.  This conflicted with POE
     wanting to invoke _start and similarly named object methods.  So
     mapped states were born:

          POE::Session->create(
            object_states =>
            [ $object_1 => { state_one => 'method_one', state_two => 'method_two' },
              $object_2 => { state_six => 'method_six', state_ten => 'method_ten' },
            ]
          );

   * Package states

     States are little more than functions, which in turn can be organized
     into packages for convenient maintenance and use.  Package methods are
     invoked the same as object methods, so it was easy to support them
     once object states were implemented.

          POE::Session->create(
            package_states =>
            [ Package_One => [ 'state_name_one',   'state_name_two'  ],
              Package_Two => [ 'state_name_three', 'state_name_four' ],
            ]
          );

     You may have noticed that package_states maps to a list reference when
     it could just as well have mapped to a hash reference.  This was done
     for nothing more than consistency with object states.

     Mapped package states are also possible:

          POE::Session->create(
            package_states =>
            [ Package_One => { state_one => 'method_one', state_two => 'method_two' },
              Package_Two => { state_six => 'method_six', state_ten => 'method_ten' },
            ]
          );

POE::Session Exports
====================

   Each session maintains its state machine's runtime context.  Every
state receives its context as several standard parameters.  These
parameters tell the state about its Kernel, its Session, the transition,
and itself.  Any number of states' own parameters may exist after them.

   The parameters' offsets into @_ were once defined, but changing them
would break existing code.  POE::Session now defines symbolic constants
for states' parameters, and their values are guaranteed to reflect the
correct offsets into @_ no matter how its order changes.

   These are the values that make up a session's runtime context, along
with the symbolic constants that define their places in a state's
parameter list.

ARG0 =item ARG1 =item ARG2 =item ARG3 =item ARG4 =item ARG5 =item ARG6 =item ARG7 =item ARG8 =item ARG9
     These are the first ten of the state's own parameters.  The state's
     parameters are guaranteed to exist at the end of @_, so it's possible
     to pull variable numbers of them off the call stack with this:

          my @args = @_[ARG0..$#_];

     These values correspond to PARAMETER_LIST in many of POE::Kernel's
     methods.  In the following example, the words "zero" through "four"
     will be passed into "some_state" as @_[ARG0..ARG4].

          $_[KERNEL]->yield( some_state => qw( zero one two three four ) );

HEAP
     Every session includes a hash for storing arbitrary data.  This hash
     is called a heap because it was modelled after process heaps.  Each
     session has only one heap, and its data persists for the session's
     lifetime.  States that store their persistent data in the heap will
     always be saving it with the correct session, helping to ensure their
     re-entrancy with a minimum of work.

          sub _start {
            $_[HEAP]->{start_time} = time();
          }

          sub _stop {
            my $elapsed_runtime = time() - $_[HEAP]->{start_time};
            print 'Session ', $_[SESSION]->ID, " elapsed runtime: $elapsed_runtime\n";
          }

KERNEL
     States quite often must call Kernel methods.  They receive a reference
     to the Kernel in $_[KERNEL] to assist them in this endeavor.  This
     example uses $_[KERNEL] post a delayed event:

          $_[KERNEL]->delay( time_is_up => 10 );

OBJECT
     Perl passes an extra parameter to object and package methods.  This
     parameter contains the object reference or package name in which the
     method is being invoked.  POE::Session exports this parameter's offset
     (which is always 0, by the way, but let's pretend it sometimes isn't)
     in the OBJECT constant.

     In this example, the ui_update_everything state multiplexes a single
     notification into several calls to the same object's methods.

          sub ui_update_everything {
            my $object = $_[OBJECT];
            $object->update_menu();
            $object->update_main_window();
            $object->update_status_line();
          }

     Inline states are implemented as plain coderefs, and Perl doesn't pass
     them any extra information, so $_[OBJECT] is always undef for them.

SENDER
     Every state is run in response to an event.  These events can be
     posted state transitions or immediate resource service callbacks.  The
     Kernel includes a reference to the thing that generated the event
     regardless of its delivery method, and that reference is contained in
     $_[SENDER].

     The SENDER can be used to verify that an event came from where it
     ought to.  It can also be used as a return address so that responses
     can be posted back to sessions that sent queries.

     This example shows both common uses.  It posts a copy of an event back
     to its sender unless the sender happens to be itself.  The condition
     is important in preventing infinite loops.

          sub echo_event {
            $_[KERNEL]->post( $_[SENDER], $_[STATE], @_[ARG0..$#_] )
              unless $_[SENDER] == $_[SESSION];
          }

SESSION
     The SESSION parameter contains a reference to the current session.
     This provides states with access to their session's methods.

          sub enable_trace {
            $_[SESSION]->option( trace => 1 );
            print "Session ", $_[SESSION]->ID, ": dispatch trace is now on.\n";
          }

STATE
     A single state can have several different names.  For example:

          POE::Session->create(
            inline_states =>
            { one => \&some_state,
              two => \&some_state,
              six => \&some_state,
              ten => \&some_state,
            }
          );

     Sometimes it's useful for the state to know which name it was invoked
     by.  The $_[STATE] parameter contains just that.

          sub some_state {
            print( "some_state in session ", $_[SESSION]-ID,
                   " was invoked as ", $_[STATE], "\n"
                 );
          }

     $_[STATE] is often used by the _default state, which by default can be
     invoked as almost anything.

POE::Session's Predefined States
================================

   POE defines some states with standard functions.  They all begin with a
single leading underscore, and any new ones will also follow this
convention.  It's therefore recommended not to use a single leading
underscore in custom state names, since there's a small but positive
probability of colliding with future standard events.

   Predefined states generally have serious side effects.  The _start
state, for example, performs much of the task of setting up a session.
Posting a redundant _start state transition will dutifully attempt to
allocate a session that already exists, which will in turn do terrible,
horrible things to the Kernel's internal data.  Such things would normally
be outlawed outright, but the extra overhead to check for them hasn't yet
been deemed worthwhile.  Please be careful!

   Here now are the predefined standard states, why they're invoked, and
what their parameters mean.

_child
     The _child state is invoked to notify a parent session when a new
     child arrives or an old one departs.  Also see the _child state for
     more information.

     $_[ARG0] contains a string describing what the child is doing:

    'create'
          The child session has just been created.  The current session is
          its original parent.

    'gain'
          Another session has stopped, and we have just inherited this
          child from it.

    'lose'
          The child session has stopped, and we are losing it.

     $_[ARG1] is a reference to the child in question.  It will still be
     valid even if the child is in its death throes, but it won't last long
     enough to receive posted events.

     $_[ARG2] is only valid when a new session has been created ($_[ARG0]
     is 'create').  It contains the new child session's _start state's
     return value.

_default
     It's not illegal to dispatch an event that a session cannot handle.
     If such a thing occurs, the session's _default state is invoke
     instead.  If no _default state exists, then the event is discarded
     quietly.  While this is considered a feature, some people may be vexed
     by misspelled state names.  See POE::Session's option() method for
     information about catching typos.

     Strange state parameters change slightly when they invoke _default.
     The original state's name is preserved in $_[ARG0] while its arguments
     are preserved in $_[ARG1].  Everything else remains the same.

     Beware!  _default states can accidentally make programs that will only
     be stopped by SIGKILL.  This happens because _default will catch
     signals when a signal handler isn't defined.  Please read about signal
     handlers along with POE::Kernel's signal watchers for information on
     avoiding this unfortunate problem.

_parent
     The _parent state is invoked to notify a child session when it's being
     passed from one parent to another.  $_[ARG0] contains the session's
     previous parent, and $_[ARG1] contains its new one.

     The _child state is the other side of this coin.

_signal
     The _signal state is a session's default signal handler.  Every signal
     that isn't mapped to a specific state will be delivered to this one.
     If _signal doesn't exist but _default does, then _default gets it
     instead.  See the _default state's description for a reason why this
     may not be desirable.  If both _signal and _default are missing, then
     the signal is discarded unhandled.

     POE::Kernel's sig() method can map a specific signal to another state.
     The other state is called instead of _signal, unless it isn't there;
     then _default gets a chance to handle it, etc.

     $_[ARG0] contains the signal's name, as used by Perl's %SIG hash.

     A signal handler state's return value is significant.  Please read
     more about signal watchers and in the POE::Kernel manpage.

_start
     The Kernel invokes a session's _start state once the session has been
     registered and is ready to begin running.  Sessions that have no
     _start states are never started.  In fact, creating such silly
     sessions is illegal since POE wouldn't know how to start them.

     $_[SENDER] contains a reference to the new session's parent session.
     Sessions created before $poe_kernel->run() is called will have
     $_[KERNEL] for a parent.

     @_[ARG0..$#_] contain the arugments passed into the Session's
     constructor.  See the documentation for POE::Session->new() and
     POE::Session->create() for more information.

_stop
     The Kernel invokes a session's _stop state when it realizes the
     session has run out of things to do.  It then destroys the session
     once the _stop state returns.  A session's _stop state usually
     contains special destructor code, possibly to clean up things that the
     kernel can't.

     This state receives nothing special in @_[ARG0..$#_].

States' Return Values
---------------------

   States always are evaluated in a scalar context.  States that must
return more than one value should return them in an array or hash
reference.

   The values signal handling states return are significant and are
covered along with signal watchers in the POE::Kernel manpage.

   States are prohibited from returning references to objects in the POE
namespace.  It's too easy to do this accidentally, and it has often
confounded Perl's garbage collection in the past.

PUBLIC METHODS
==============

ID
     Returns the POE::Session instance's unique identifier.  This is a
     number that starts with 1 and counts up forever, or until something
     causes the number to wrap.  It's theoretically possible that session
     IDs may collide after at 4.29 billion sessions have been created.

create LOTS_OF_STUFF
     Bundles some states together into a single machine, then starts it
     running.

     LOTS_OF_STUFF looks like a hash of parameter name/value pairs, but
     it's really just a list.  It's preferred over the older, more DWIMmy
     new() constructor because each kind of parameter is explicitly named,
     and it can therefore unambiguously figure out what it is a program is
     trying to do.

    args => LISTREF
          Defines the arguments to give to the machine's _start state.
          They're passed in as @_[ARG0..$#_].

               args => [ 'arg0', 'arg1', 'etc.' ],

    heap => ANYTHING or NOTHING
          Defines the session's heap, which will be passed to each of its
          states in $_[HEAP].  Sessions are created with anonymous hash
          references by default, which are used like this:

               my $heap = $_[HEAP];
               $heap->{variable} = $value;  # simple hashref stuff

          It's possible, however, to use create's heap parameter to change
          that into a list reference, or even some sort of magical tied
          thing.  It's also possible to pre-populate a session's heap.

               POE::Session->create(
                 ...,
                 heap => [ 'mi',    # HEAP_ALIAS ( These are constants defined
                           [ ],     # HEAP_QUEUE   elsewhere.
                           0,       # HEAP_COUNT )
                         ],
                 ....,
               );

    inline_states => HASHREF
          Defines inline coderefs that make up some or all of the session's
          states.

               inline_states =>
               { _start => sub { print "arg0=$_[ARG0], arg1=$_[ARG1], etc.=$_[ARG2]\n"; }
                 _stop  => \&stop_state
               },

    object_states => LISTREF
          Defines object methods that make up some or all of the session's
          states.

          LISTREF is a list of parameter pairs.  The first member of each
          pair is an object reference.  The second member is either a list
          reference or hash reference.  When it's a list reference, the
          referenced list contains methods from the referenced object.
          The methods define states with the same names.  When it's a hash
          reference, the referenced hash contains state/method pairs which
          map state names to methods that may have different names.

          Perhaps some examples are in order!  This one defines two states,
          state_one and state_two, which are implemented as
          $object->state_one() and $object->state_two().

               object_states =>
               [ $object => [ 'state_one', 'state_two' ],
               ],

          This second example defines two other states, state_five and
          state_six, which are implemented as $object->do_five() and
          $object->do_six().

               object_states =>
               [ $object => { state_five => 'do_five',
                              state_six  => 'do_six',
                            },
               ],

          It's a lot simpler to do than to describe.

    options => HASHREF
          Sets one or more initial session options before starting it.
          Please see the POE::Session option() method for a list of
          available session options and what they do.

               option => { trace => 1, debug => 1 },

    package_states => LISTREF
          Defines package methods that make up some or all of the session's
          states.

          LISTREF is virtually identical to the one for object_states, so
          I'll just skip to the examples.  Check out object_states'
          description if you'd like more details, replacing "object" and
          "object reference" with "package" and "package name",
          respectively.

          So, here's a package_states invocation that defines two states,
          state_one and state_two, which are implemented as
          Package->state_one() and Package->state_two.

               package_states =>
               [ Package => [ 'state_one', 'state_two' ],
               ],

          And here's an invocation that defines two other states,
          state_five and state_six, to Package->do_five() and
          Package->do_six().

               package_states =>
               [ Package => { state_five => 'do_five',
                              state_six  => 'do_six',
                            },
               ],

          Easy-peasy!

new LOTS_OF_STUFF
     POE::Session's new() constructor is slighly depreciated in favor of
     the newer create() constructor.  A detailed description of
     POE::Session->new() is not forthcoming, but POE::Session's SYNOPSIS
     briefly touches upon its use.

option OPTION_NAME
option OPTION_NAME, OPTION_VALUE
option NAME_VALUE_PAIR_LIST
     Sets and/or retrieves options' values.

     The first form returns the value of a single option, OPTION_NAME.

          my $trace_value = $_[SESSION]->option( 'trace' );

     The second form sets OPTION_NAME to OPTION_VALUE, returning the
     previous value of OPTION_NAME.

          my $old_trace_value = $_[SESSION]->option( trace => $new_trace_value );

     The final form sets several options, returning a hashref containing
     their name/value pairs.

          my $old_values = $_[SESSION]->option(
            trace => $new_trace_value,
            debug => $new_debug_value,
          );
          print "Old option values:\n";
          while (my ($option, $value) = each %$old_values) {
            print "$option = $value\n";
          }

postback EVENT_NAME, PARAMETER_LIST
     Creates an anonymous coderef which, when called, posts EVENT_NAME back
     to the session.  Postbacks will keep sessions alive until they're
     destroyed.

     The EVENT_NAME event will include two parameters.  $_[ARG0] will
     contain a reference to the PARAMETER_LIST passed to postback().
     $_[ARG1] will hold a reference to the parameters given to the coderef
     when it's called.

     This example creates a Tk button that posts an "ev_counters_begin"
     event at a session whenever it's pressed.

          $poe_tk_main_window->Button
            ( -text => 'Begin Slow and Fast Alarm Counters',
              -command => $session->postback( 'ev_counters_begin' )
            )->pack;

     It can also be used to post events from Event watchers' callbacks.
     This one posts back "ev_flavor" with $_[ARG0] holding [ 'vanilla' ]
     and $_[ARG1] containing a reference to whatever parameters
     Event->flawor gives its callback.

          Event->flavor
            ( cb   => $session->postback( 'ev_flavor', 'vanilla' ),
              desc => 'post ev_flavor when Event->flavor occurs',
            );

get_heap
     Returns a reference to the session's heap.  This is the same value
     that's passed to the session in $_[HEAP].  The difference is that this
     method may be used by functions which are expected to be called by a
     session but which don't want the heap to be passed to them.  In those
     cases, the function would use $poe_kernel->get_active_session() first
     to determine the session context in which it was called:

          sub use_a_wheel {
            my @stuff_to_put = @_;
            $poe_kernel->get_active_session()->heap()->{wheel}->put(@stuff_to_put);
          }

     It probably is more efficient for sessions to pass $_[HEAP] along:

          sub use_a_wheel {
            my ($heap, @stuff_to_put) = @_;
            $heap->{wheel}->put(@stuff_to_put);
          }

     Or even:

          sub use_a_wheel {
            my $heap = shift;
            $heap->{wheel}->put(@_);
          }

     Although if you expect to have a lot of calls to &put_a_wheel() in
     your program, you may want to optimize for programmer efficiency by
     using the first form.

SEE ALSO
========

   The POE manpage contains holstic POE information, including an up to
date list of the modules comprising it.

BUGS
====

   There is a chance that session IDs may collide after Perl's integer
value wraps.  This can occur after as few as 4.29 billion sessions.

   If you find another, tell the author!

AUTHORS & COPYRIGHTS
====================

   Please see the POE manpage for authors and licenses.


File: pm.info,  Node: POE/Wheel,  Next: POE/Wheel/FollowTail,  Prev: POE/Session,  Up: Module List

high-level protocol logic
*************************

NAME
====

   POE::Wheel - high-level protocol logic

SYNOPSIS
========

     $wheel = new POE::Wheel::Something( ... )
     $wheel->put($some_logical_data_chunks);

DESCRIPTION
===========

   Wheels contain reusable chunks of high-level logic.  For example,
Wheel::FollowTail contains the algorithm for reading data from the end of
an ever growing file.  Their logic is contained in bundles of reusable
states which they insert into and remove from their owners during creation
and destruction.

   Giving a wheel to another session will not transfer related states.  As
a result, the original owner will continue receiving a wheel's events
until it's destroyed.

COMMON PUBLIC WHEEL METHODS
===========================

   These are the methods that are common to every wheel.

allocate_wheel_id
     This is a static function; it should be called as
     &POE::Wheel::allocate_wheel_id().  It returns a number that may be
     used to uniquely identify a wheel.  POE::Wheel keeps track of
     allocated IDs to avoid collisions, so it's important to free the ID
     when it's done.

free_wheel_id($wheel_id)
     Frees a wheel ID.  Used when a wheel is being destroyed.

new LOTS_OF_STUFF
     Creates a new wheel, returning its reference.  The reference holder
     should keep the wheel reference around until it's ready for the wheel
     to stop.

     Every wheel has a different purpose and requires different parameters,
     so LOTS_OF_STUFF will vary from one to the next.

DESTROY
     Perl calls DESTROY when the wheel's reference is relinquished.  This
     triggers the wheel's destruction, which releases whatever resources it
     was managing.

     When passing resources from one wheel to another, it's important to
     destroy the old wheel before creating the new one.  If the hand-off is
     not in this order, the old wheel's destruction will release the
     resource after the new one has started watching it.  The new wheel
     will then not be watching the resource, even though it ought to be.

put LIST
     Send a LIST of things through the wheel.  The LIST may only contain
     one thing, and that's ok.  Each thing in the LIST is serialized by the
     wheel's Filter, and then bufferend until the wheel's Driver can flush
     it to a filehandle.

event TYPE => STATE_NAME, ...
     Changes the states that are called when a wheel notices certain types
     of events occurring.

     The event() method's parameters are pairs of event TYPEs and the
     STATE_NAMEs to call when they occur.  Event TYPEs differ for each
     wheel, and their manpages will discuss them in greater detail.
     STATE_NAMEs may be undef, in which case the wheel will stop invoking a
     state for that TYPE of event.

          $_[HEAP]->{wheel}->event( InputState   => 'new_input_state',
                                    ErrorState   => undef,
                                    FlushedState => 'new_flushed_state',
                                  );

SEE ALSO
========

   POE::Wheel::FollowTail; POE::Wheel::ListenAccept;
POE::Wheel::ReadWrite; POE::Wheel::SocketFactory.

BUGS
====

   Wheels really ought to be replaced with a proper stream-based I/O
abstraction and POE::Component classes to replace FollowTail and
SocketFactory.

AUTHORS & COPYRIGHTS
====================

   Please see the POE manpage for authors and licenses.


File: pm.info,  Node: POE/Wheel/FollowTail,  Next: POE/Wheel/ListenAccept,  Prev: POE/Wheel,  Up: Module List

POE FollowTail Protocol Logic
*****************************

NAME
====

   POE::Wheel - POE FollowTail Protocol Logic

SYNOPSIS
========

     $wheel = new POE::Wheel::FollowTail(
       Handle       => $file_handle,                 # File to tail
       Driver       => new POE::Driver::Something(), # How to read it
       Filter       => new POE::Filter::Something(), # How to parse it
       PollInterval => 1,                  # How often to check it
       InputState   => $input_event_name,  # State to call upon input
       ErrorState   => $error_event_name,  # State to call upon error
     );

DESCRIPTION
===========

   This wheel follows the end of an ever-growing file, perhaps a log file,
and generates events whenever new data appears.  It is a read-only wheel,
so it does not include a put() method.  It uses sysseek(2) wrapped in eval
{ }, so it should work okay on all sorts of files.  That is, if perl
supports select(2)'ing them on the underlying operating system.

PUBLIC METHODS
==============

   * POE::Wheel::FollowTail::event(...)

     Please see POE::Wheel.

   * POE::Wheel::FollowTail::ID()

     Returns the FollowTail wheel's unique ID.  This can be used to
     associate the wheel's events back to the wheel itself.

EVENTS AND PARAMETERS
=====================

   * PollInterval

     PollInterval is the number of seconds to wait between file checks.
     Once FollowTail re-reaches the end of the file, it waits this long
     before checking again.

   * SeekBack

     SeekBack is the number of bytes to seek back from the current end of
     file before reading.  By default, this is 4096, and data read up to
     the end of file is not returned.  (This is used to frame lines before
     returning actual data.)  If SeekBack is specified, then existing data
     up until EOF is returned, and then the wheel begins following tail.

   * InputState

     The InputState event is identical to POE::Wheel::ReadWrite's
     InputState.  It's the state to be called when the followed file
     lengthens.

     ARG0 contains a logical chunk of data, read from the end of the tailed
     file.  ARG1 contains the ID of the wheel that received this input.

   * ErrorState

     The ErrorState event contains the name of the state that will be
     called when a file error occurs.  The FollowTail wheel knows what to
     do with EAGAIN, so it's not considered a true error.  FollowTail will
     continue running even on an error, so it's up to the Session to stop
     things if that's what it wants.

     The ARG0 parameter contains the name of the function that failed.
     ARG1 and ARG2 contain the numeric and string versions of $! at the
     time of the error, respectively.  ARG3 contains the ID of the wheel
     that encountered the error; this is useful for closing the proper
     wheel when one of several has encountered an error.

     A sample ErrorState state:

          sub error_state {
            my ($operation, $errnum, $errstr) = @_[ARG0, ARG1, ARG2];
            warn "$operation error $errnum: $errstr\n";
          }

SEE ALSO
========

   POE::Wheel; POE::Wheel::ListenAccept; POE::Wheel::ReadWrite;
POE::Wheel::SocketFactory

BUGS
====

   This wheel can't tail pipes and consoles.  Blargh.

AUTHORS & COPYRIGHTS
====================

   Please see the POE manpage.


File: pm.info,  Node: POE/Wheel/ListenAccept,  Next: POE/Wheel/ReadWrite,  Prev: POE/Wheel/FollowTail,  Up: Module List

POE Listen/Accept Logic Abstraction
***********************************

NAME
====

   POE::Wheel::ListenAccept - POE Listen/Accept Logic Abstraction

SYNOPSIS
========

     $wheel = new POE::Wheel::ListenAccept(
       Handle      => $socket_handle,      # Listening socket
       AcceptState => $accept_state_name,  # Success state
       ErrorState  => $error_state_name,   # Failure state
     );

     $wheel->event( AcceptState => $new_state_name ); # Add/change state
     $wheel->event( ErrorState  => undef );           # Remove state

DESCRIPTION
===========

   ListenAccept waits for activity on a listening socket and accepts
remote connections as they arrive.  It generates events for successful and
failed connections (EAGAIN is not considered to be a failure).

   This wheel neither needs nor includes a put() method.

   ListenAccept is a good way to listen on sockets from other sources,
such as IO::Socket or plain socket() calls.

PUBLIC METHODS
==============

   * POE::Wheel::ListenAccept::event( ... )

     The event() method changes the events that a ListenAccept wheel emits
     for different conditions.  It accepts a list of event types and
     values.  Defined state names change the previous values.  Undefined
     ones turn off the given condition's events.

     For example, this event() call changes a wheel's AcceptState event and
     turns off its ErrorState event.

          $wheel->event( AcceptState => $new_accept_state_name,
                         ErrorState  => undef
                       );

   * POE::Wheel::ListenAccept::ID()

     Returns the ListenAccept wheel's unique ID.  This can be used to
     associate the wheel's events back to the wheel itself.

EVENTS AND PARAMETERS
=====================

   * AcceptState

     The AcceptState event contains the name of the state that will be
     called when a new connection has been accepted.

     The ARG0 parameter contains the accepted connection's new socket
     handle.

     ARG1 contains accept()'s return value.

     A sample AcceptState state:

          sub accept_state {
            my $accepted_handle = $_[ARG0];
            # Optional security things with getpeername might go here.
            &create_server_session($handle);
          }

   * ErrorState

     The ErrorState event contains the name of the state that will be
     called when a socket error occurs.  The ListenAccept wheel knows what
     to do with EAGAIN, so it's not considered an error worth reporting.

     The ARG0 parameter contains the name of the function that failed.
     This usually is 'accept'.  ARG1 and ARG2 contain the numeric and
     string versions of $! at the time of the error, respectively.

     A sample ErrorState state:

          sub error_state {
            my ($operation, $errnum, $errstr) = @_[ARG0, ARG1, ARG2];
            warn "$operation error $errnum: $errstr\n";
          }

SEE ALSO
========

   POE::Wheel; POE::Wheel::FollowTail; POE::Wheel::ReadWrite;
POE::Wheel::SocketFactory

BUGS
====

   Oh, probably some.

AUTHORS & COPYRIGHTS
====================

   Please see the POE manpage.


