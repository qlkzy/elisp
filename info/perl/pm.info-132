This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: DirHandle,  Next: Docclient,  Prev: Dir/Purge,  Up: Module List

supply object methods for directory handles
*******************************************

NAME
====

   DirHandle - supply object methods for directory handles

SYNOPSIS
========

     use DirHandle;
     $d = new DirHandle ".";
     if (defined $d) {
         while (defined($_ = $d->read)) { something($_); }
         $d->rewind;
         while (defined($_ = $d->read)) { something_else($_); }
         undef $d;
     }

DESCRIPTION
===========

   The DirHandle method provide an alternative interface to the opendir(),
closedir(), readdir(), and rewinddir() functions.

   The only objective benefit to using DirHandle is that it avoids
namespace pollution by creating globs to hold directory handles.


File: pm.info,  Node: Docclient,  Next: Document/Info,  Prev: DirHandle,  Up: Module List

client module for MS format conversions
***************************************

NAME
====

   Docclient - client module for MS format conversions

SEE ALSO
========

   docclient(1), Docserver(3), Win32::OLE(3)


File: pm.info,  Node: Document/Info,  Next: DotLock,  Prev: Docclient,  Up: Module List

determine file type for Office documents
****************************************

NAME
====

   Document::Info v0.01 - determine file type for Office documents

SYNOPSIS
========

     use Document::Info;

     if ( $Info=Document::Info->new($fileName) ) {;
         # $Info constructed, that means something has been determined.

     # Fetch the currently supported properties.
     $type = $Info -> getType ( );
     $rev  = $Info -> getRevision ( );
     $os   = $Info -> getOS ( );

     if ( $type eq $Info->cMSExcel() ) {
        # Do something. Note: when checking a type or an operating System
        # always use the string constants like cMSExcel().
     }
     if ( !$revision ) {
         # revision not determined.
     }
         } else {
     # Document type could not be determined.
         }

DESCRIPTION
===========

   The module tries to figure out the document type of Office files. It
utilizes OLE::Storage to determine the file type of Windows-documents. The
module is in a very early state.

AUTHOR
======

   Martin Schwartz, schwartz@cs.tu-berlin.de

SEE ALSO
========

   file(1), lfile(1), OLE::Storage.


File: pm.info,  Node: DotLock,  Next: Dua,  Prev: Document/Info,  Up: Module List

Multi-host advisory queing locking system
*****************************************

NAME
====

   DotLock - Multi-host advisory queing locking system

SYNOPSIS
========

   `use DotLock;'

   see CONSTRUCTOR & METHODS section below

DESCRIPTION
===========

   `DotLock' is a multipurpose queing locking system. Originally designed
to take some of the pain away from locking on NFS filesystems.

   This module allows script writers to develop on multiple hosts when
locking between these hosts is an issue. It allows queing - scary but
true. It also provides an atomic method of locking by using the "link"
function between files.

   The locking/queing method provided is purely on a file manipulation
level. Also note that this object does not handle signals. If the program
is interrupted, any open lockfiles will be left behind.

CONSTRUCTOR
===========

*new (OPTIONS)* - create a new DotLock object
     This is the constructor of the `DotLock' object.

     OPTIONS are passed to the object in a hash-like fashion using keys
     and values. The keys are the same as the methods provided below, as
     shown:

     $t = new DotLock(         path => "/home/ken/perl/locking/",
     errmode => "die",         timeout => 100,         maxqueue => 8,
       retrytime => 1,         domain => 'optusnet.com.au', );

     So you can define all settings in one go. Besides the "lock" method,
     this is the heart and soul of the module.

METHODS
=======

lock - attempt to obtain a lock
     This method will attempt to obtain a lock with the configuration
     passed to it from the constructor or from the various setup methods.

     The process is basically as follows:

     1. A temporary lockfile is created which is associated with the
     script and host.

     2. The lockfile directory is listed to find the highest free lock.

     3. Depending on the maxqueue setting, the highest lock is obtained.

     4. If for some reason the highest lock was nabbed before the current
     script could get it, the current script will try the next higher up
     lock que until it obtains a placing.

     5. Once a place in the que is obtained, lock will attempt to get the
     next lock. It will retry every second, or the time defined in the
     retrytime method.

     6. Unless the process has reached the point of obtaining the main
     lock, the script will return to step 5 to obtain the next que placing.

     7. Once the main lock is obtained, the script using this object will
     do its business.

unlock - remove all lockfiles
     The method removes all open lockfiles, enabling other processes to
     obtain any lock you have left open. This is also the method called
     upon object destruction.

*timeout ([TIMEOUT])* - timeout for obtaining a lock
     This defaults to 60 seconds.

     Set this method to the amount of time you want your script to wait
     for a lock. The TIMEOUT value is in seconds.

     If you fail to obtain the lock with the set time, the object will
     return an error and react based on the errmode method set when
     creating the object.

*path ([PATH])* - path of lockfiles
     Set the directory for where the lockfiles will be kept. This by
     default is set to /var/lock/quelock. If the path does not exist, an
     error will occur.

     For two processes to use the same lockfiles, this path must be the
     same in both processes.

     With this method you can either set the path of the lockfiles, or
     return the previous path.

*errmode ([MODE])* - set how to react to errors
     The errmode method can be set to either "die" to die when an error is
     encountered or "return" to return an error message. The error message
     can be obtained from the errmsg method.

     The default setting for errmode is "die".

*maxqueue ([QUE])* - the highest allowable que placing
     The maxqueue data method is used by the lock method. When attempting
     to find a place in the que, it will look at this figure - if the
     figure is higher than the highest free que then DotLock will return
     an error.

     By default, queing is turned off.

*retrytime ([TIME])* - the time in seconds to retry the next lock placing
     You set this data method to the amount of time in seconds you with
     the system to retry for the next available lock. The default is 1
     second.

*domain ([DOMAIN])* - set the domain of your system
     Although not necessary, this allows all hosts entries to be reduced
     to just their hostname. This is only really usefull if you plan on
     running scripts with one domain and one domain only.

errmsg - returns the last error message
     This method will return the error message of the last error found.
     When errmode is set to "return" this variable will be loaded with the
     error message.

SEE ALSO
========

   Some other good modules for locking:

   *LockFile::Simple*

   *IPC::Locker*

EXAMPLES
========

   use DotLock;

   $t = new DotLock(         path => "/home/ken/perl/locking/locktest",
    errmode => "return",         timeout => 100,         maxqueue => 8,
     retrytime => 1,         domain => 'optusnet.com.au', );

   $t->lock || print $t->errmsg . "\n";

   print "Locked\n";

   $blah = <STDIN>;

   $t->unlock;

AUTHOR
======

   Ken Barber <ken@optusnet.com.au>

COPYRIGHT
=========

   Copyright (c) 1999 Ken Barber. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Dua,  Next: Dumpvalue,  Prev: DotLock,  Up: Module List

DUA/Perl interface to an X.500 directory
****************************************

NAME
====

   Dua - DUA/Perl interface to an X.500 directory

SYNOPSIS
========

     use Dua;

DESCRIPTION
===========

     This module provides a set of subroutines which allow a Perl script to
     access to the X.500 directory.

SUBROUTINES
===========

     $dua = new Dua()

     Creates a new instance of a Dua object.

     $dua->open($dsa, $port, $dn, $passwd)

     Open an association to the DSA  specified  in  dsa  and
     running  on  the  port specified by port. If no port is
     specified, then  duaperl  will  use  the  default  port
     number.  duaperl  will bind to the DSA as dn, using the
     credentials supplied in passwd. Currently, only  simple
     authentication is supported.

     $dua->error()

     This routine returns a description of the problem when an error
     occurs.

     $dua->settmout($seconds, $microseconds)

     This routine sets the asynchronous timeout value for
     all operations.  The default is 30 seconds.

     $dua->close()

     This routine closes the association to the X.500 DSA.

     $dua->moveto($dn)

     Move to the location in the DIT specified by dn.

     $dua->modrdn($rdn, $newrdn)

     Modify the object whose RDN is rdn to newrdn.

     $dua->delete($rdn)

     Delete the object specified by rdn from the DIT.

     $dua->add($rdn, %attrs)

     Add a new object to the DIT with an RDN of rdn with the
     attributes attrs.

     $dua->modattr($rdn, %attrs)

     Modify the object specified by rdn with the  attribute-
     value pairs in attrs. If a value is set to an empty string
     the associated attribute is deleted from the entry.

     $dua->show($rdn)

     Returns in an  associative  array  the  attribute-value
     pairs found in the object specified by rdn.

     $dua->attribute($rdn,$attribute)

     Returns an array of values for the specified attribute
     found in the object specified by rdn.

     This method maybe used to retrieve binary attributes not
     accessible via the show method.

     $dua->find($rdn, $filter, $scope, $all)

     Returns in an associative array the attribute-value pairs found
     beneath the object specified by rdn. filter is a string
     representation of a filter to apply to the search.  A
     Backus-Naur Form definition is given below.  scope refers to how
     deep the search is to progress in the DIT. A value of 0
     specifies the immediate children of the object; a value of 1
     specifies the entire sub- tree beneath the object.  all refers
     to what will be returned in the associative array. A value of 0
     will return just the DN's of matching objects, keyed by their
     ordinality in the search response; a value of 1 specifies that
     the attribute-value pairs of all match- ing objects are to be
     returned.  This routine is used for non-leaf objects.

NOTES
=====

     $dua->moveto() determines the path which is prepended to the rdn of all
     other functions. This simulates ``standing'' at a particular position
     in the DIT, and being able to specify DN's relative to the current
     position. If a fully-qualified DN is more appropriate for a
     particular call, begin the rdn string with an `@' character.

     The Backus-Naur Form (BNF) for the filter specified in dua_find()
     is as follows:

     <filter> ::= '(' <filtercomp> ')'
     <filtercomp> ::= <and> | <or> | <not> | <simple>
     <and> ::= '&' <filterlist>
     <or> ::= '|' <filterlist>
     <not> ::= '!' <filter>
     <filterlist> ::= <filter> | <filter> <filterlist>
     <simple> ::= <attributetype> <filtertype> <attributevalue>
     <filtertype> ::= '=' | '~=' | '<=' | '>='

RETURN VALUES
=============

     All routines except $dua->show() and $dua->find() will return 1 on
     success, 0 otherwise. For those routines which return associative
     arrays ( $dua->show() and $dua->find() ), the array is returned
     empty if an error occurs. The description of the problem may be
     obtained by use of $dua->error().

AUTHOR
======

     Converted from duaperl Version 1.0a3 to a Perl 5 module by
     Stephen Pillinger, School of Computer Science,
     The University of Birmingham, UK.

     duaperl was written by Eric W. Douglas, California State University,
     Fresno.

SEE ALSO
========

   perl(1), ldap(3).


File: pm.info,  Node: Dumpvalue,  Next: Dunce/Files,  Prev: Dua,  Up: Module List

provides screen dump of Perl data.
**********************************

NAME
====

   Dumpvalue - provides screen dump of Perl data.

SYNOPSIS
========

     use Dumpvalue;
     my $dumper = new Dumpvalue;
     $dumper->set(globPrint => 1);
     $dumper->dumpValue(\*::);
     $dumper->dumpvars('main');

DESCRIPTION
===========

Creation
--------

   A new dumper is created by a call

     $d = new Dumpvalue(option1 => value1, option2 => value2)

   Recognized options:

`arrayDepth', `hashDepth'
     Print only first N elements of arrays and hashes.  If false, prints
     all the elements.

compactDump, veryCompact
     Change style of array and hash dump.  If true, short array may be
     printed on one line.

`globPrint'
     Whether to print contents of globs.

`DumpDBFiles'
     Dump arrays holding contents of debugged files.

`DumpPackages'
     Dump symbol tables of packages.

`DumpReused'
     Dump contents of "reused" addresses.

`tick', `HighBit', `printUndef'
     Change style of string dump.  Default value of `tick' is `auto', one
     can enable either double-quotish dump, or single-quotish by setting it
     to `"' or `''.  By default, characters with high bit set are printed
     *as is*.

`UsageOnly'
     *very* rudimentally per-package memory usage dump.  If set, dumpvars
     calculates total size of strings in variables in the package.

unctrl
     Changes the style of printout of strings.  Possible values are unctrl
     and quote.

subdump
     Whether to try to find the subroutine name given the reference.

bareStringify
     Whether to write the non-overloaded form of the stringify-overloaded
     objects.

quoteHighBit
     Whether to print chars with high bit set in binary or "as is".

stopDbSignal
     Whether to abort printing if debugger signal flag is raised.

   Later in the life of the object the methods may be queries with get()
method and set() method (which accept multiple arguments).

Methods
-------

dumpValue
          $dumper->dumpValue($value);
          $dumper->dumpValue([$value1, $value2]);

dumpValues
          $dumper->dumpValues($value1, $value2);

dumpvars
          $dumper->dumpvars('my_package');
          $dumper->dumpvars('my_package', 'foo', '~bar$', '!......');

     The optional arguments are considered as literal strings unless they
     start with `~' or !, in which case they are interpreted as regular
     expressions (possibly negated).

     The second example prints entries with names foo, and also entries
     with names which ends on bar, or are shorter than 5 chars.

set_quote
          $d->set_quote('"');

     Sets `tick' and unctrl options to suitable values for printout with
     the given quote char.  Possible values are `auto', `'' and `"'.

set_unctrl
          $d->set_unctrl('"');

     Sets unctrl option with checking for an invalid argument.  Possible
     values are unctrl and quote.

compactDump
          $d->compactDump(1);

     Sets compactDump option.  If the value is 1, sets to a reasonable big
     number.

veryCompact
          $d->veryCompact(1);

     Sets compactDump and veryCompact options simultaneously.

set
          $d->set(option1 => value1, option2 => value2);

get
          @values = $d->get('option1', 'option2');


File: pm.info,  Node: Dunce/Files,  Next: DynScalar,  Prev: Dumpvalue,  Up: Module List

Protects against sloppy use of files.
*************************************

NAME
====

   Dunce::Files - Protects against sloppy use of files.

SYNOPSIS
========

     use Dunce::Files;

     # open() warns you that you forgot to check if it worked.
     open(FILE, $filename);
     while( <FILE> ) {
         chop;     # chop() warns you to use chomp() instead
         print;
     }
     exit;

     # *FILE will warn you that you forgot to close it.

DESCRIPTION
===========

   One of the most common programming mistakes is failing to check if an
open() worked.  Same goes for other file and system operations.  The world
outside your program is a scary, unreliable place, and things you try to
do with it might not always work.

   Dunce::Files makes trick versions of all file functions which do some
basic sanity checking.

   If used in void context (ie. you didn't check to see if it worked),
they will throw a warning.  If the function returns a filehandle (like
open() and readdir()) that filehandle will complain if its never closed,
or if its never used.

   This module is useful for automated code auditing.  Its also useful as
a dunce cap to place on junior programmers, make sure they're not making
silly mistakes.

   The list of overridden functions is:

     chdir
     chmod
     chop
     chown
     chroot
     dbmopen
     flock
     link
     mkdir
     open
     opendir
     read
     rename
     rmdir
     seek
     seekdir
     symlink
     syscall
     sysseek
     system
     syswrite
     truncate
     unlink
     write

   A few functions have some additional warnings:

chmod
     Often, people will gratuitiously grant files more permissions than
     they really need causing unnecessary security problems.  Making
     non-program files executable is a common mistake.  Unnecessarily
     giving world write permission is another.  Dunce::Files will throw a
     warning if either is detected.

     *Note: It may be worthwhile to split this out into a seperate module*

chop
     chop() works a little differently.  Using it in void context is fine,
     but if it looks like you're using it to strip newlines it will throw a
     warning reminding you about chomp().

     NOTE chop() was non-overridable before 5.7.0, so this feature will
     only work on that perl or newer.

dbmopen
     dbmopen() will warn you if the hash argument you gave it already
     contains data.

open
     *NOT YET IMPLEMENTED*

     open() will warn you if you don't close its filehandle explicitly
     before the program ends.  It will also warn if you give it an already
     open filehandle.

     XXX I'd also like to have made sure $! is checked, but $! can't be
     usefully tied. :(

     #'# # Waiting on postamble callbacks in Function::Override.

opendir
     *NOT YET IMPLEMENTED*

     Same as open().

CAVEATS
=======

   Because of the way perl compiles, the following code will produce a
'Name main::FILE used only once: possible typo' where it shouldn't.

     use Dunce::Files;
     open(FILE, $filename) or die $!;
     print <FILE>;

   Because open() is really Dunce::Files::open() and not the real open,
Perl doesn't realize that FILE is the filehandle *FILE, so it thinks its
only being used once.

   Turns out this is a useful feature.  If you close FILE the warning will
go away, and you should have closed it in the first place.

TODO
====

   Make a flag to have Dunce::Files die instead of just warning.

   Complete Function::Override so I can finish open() and opendir().

AUTHOR
======

   Michael G Schwern <schwern@pobox.com> with help from crysflame and
Simon Cozens.  Thanks to Jay A. Kreibich for the chop() idea.

SEE ALSO
========

   *Note Function/Override: Function/Override,


File: pm.info,  Node: DynScalar,  Next: DynaLoader,  Prev: Dunce/Files,  Up: Module List

closure-in-a-box for simple scalars
***********************************

NAME
====

   DynScalar - closure-in-a-box for simple scalars

SYNOPSIS
========

     use DynScalar;  # imports as dynamic()
     use strict;
     use vars '$name';
     
     my $foo = dynamic { "Hello, $name!\n" };
     for $name ("Jeff", "Joe", "Jonas") { print $foo }

DESCRIPTION
===========

   This module creates closures, and masks them as objects that stringify
themselves when used.  This allows you to make incredibly simplistic string
templates:

     use DynScalar 'delay';  # import as delay()
     use strict;
     use vars qw( $name $age $sex );
     
     my $template = delay {
       "Hello, $name.  You're a good-looking $age-year-old $sex.\n"
     };
     
     while (my $rec = get_person()) {
       ($name,$age,$sex) = $rec->features;
       print $template;
     }

   You can embed arbitrarily complex code in the block.

CAVEATS
=======

   Lexically scoped variables can be used inside the block, but you must
do so with caution.  The variable must be visible, as in this example:

     use DynScalar;
     
     my $name;
     my $str = dynamic { $name };
     for ("Jeff", "Joe", "Jonas") { $name = $_; print $str }

   If you use the lexically scoped variable as the iterator variable in
the loop, however, Perl will scope it even further, and the `DynScalar'
object will not be able to see it:

     use DynScalar;
     
     my $name;
     my $str = dynamic { $name };
     # this next line will not print as you hoped
     for $name ("Jeff", "Joe", "Jonas") { print $str }

AUTHOR
======

     Jeff "japhy" Pinyan
     CPAN ID: PINYAN
     japhy@pobox.com
     http://www.pobox.com/~japhy/


File: pm.info,  Node: DynaLoader,  Next: EMatrix,  Prev: DynScalar,  Up: Module List

Dynamically load C libraries into Perl code
*******************************************

NAME
====

   DynaLoader - Dynamically load C libraries into Perl code

   dl_error(), dl_findfile(), dl_expandspec(), dl_load_file(),
dl_unload_file(), dl_find_symbol(), dl_find_symbol_anywhere(),
dl_undef_symbols(), dl_install_xsub(), dl_load_flags(), bootstrap() -
routines used by DynaLoader modules

SYNOPSIS
========

     package YourPackage;
     require DynaLoader;
     @ISA = qw(... DynaLoader ...);
     bootstrap YourPackage;

     # optional method for 'global' loading
     sub dl_load_flags { 0x01 }

DESCRIPTION
===========

   This document defines a standard generic interface to the dynamic
linking mechanisms available on many platforms.  Its primary purpose is to
implement automatic dynamic loading of Perl modules.

   This document serves as both a specification for anyone wishing to
implement the DynaLoader for a new platform and as a guide for anyone
wishing to use the DynaLoader directly in an application.

   The DynaLoader is designed to be a very simple high-level interface
that is sufficiently general to cover the requirements of SunOS, HP-UX,
NeXT, Linux, VMS and other platforms.

   It is also hoped that the interface will cover the needs of OS/2, NT
etc and also allow pseudo-dynamic linking (using `ld -A' at runtime).

   It must be stressed that the DynaLoader, by itself, is practically
useless for accessing non-Perl libraries because it provides almost no
Perl-to-C 'glue'.  There is, for example, no mechanism for calling a C
library function or supplying arguments.  A C::DynaLib module is available
from CPAN sites which performs that function for some common system types.

   DynaLoader Interface Summary

     @dl_library_path
     @dl_resolve_using
     @dl_require_symbols
     $dl_debug
     @dl_librefs
     @dl_modules
                                                     Implemented in:
     bootstrap($modulename)                               Perl
     @filepaths = dl_findfile(@names)                     Perl
     $flags = $modulename->dl_load_flags                  Perl
     $symref  = dl_find_symbol_anywhere($symbol)          Perl

     $libref  = dl_load_file($filename, $flags)           C
     $status  = dl_unload_file($libref)                   C
     $symref  = dl_find_symbol($libref, $symbol)          C
     @symbols = dl_undef_symbols()                        C
     dl_install_xsub($name, $symref [, $filename])        C
     $message = dl_error                                  C

@dl_library_path
     The standard/default list of directories in which dl_findfile() will
     search for libraries etc.  Directories are searched in order:
     $dl_library_path[0], [1], ... etc

     @dl_library_path is initialised to hold the list of 'normal'
     directories (`/usr/lib', etc) determined by Configure
     (`$Config{'libpth'}').  This should ensure portability across a wide
     range of platforms.

     @dl_library_path should also be initialised with any other directories
     that can be determined from the environment at runtime (such as
     LD_LIBRARY_PATH for SunOS).

     After initialisation @dl_library_path can be manipulated by an
     application using push and unshift before calling dl_findfile().
     Unshift can be used to add directories to the front of the search
     order either to save search time or to override libraries with the
     same name in the 'normal' directories.

     The load function that dl_load_file() calls may require an absolute
     pathname.  The dl_findfile() function and @dl_library_path can be
     used to search for and return the absolute pathname for the
     library/object that you wish to load.

@dl_resolve_using
     A list of additional libraries or other shared objects which can be
     used to resolve any undefined symbols that might be generated by a
     later call to load_file().

     This is only required on some platforms which do not handle dependent
     libraries automatically.  For example the Socket Perl extension
     library (`auto/Socket/Socket.so') contains references to many socket
     functions which need to be resolved when it's loaded.  Most platforms
     will automatically know where to find the 'dependent' library (e.g.,
     `/usr/lib/libsocket.so').  A few platforms need to be told the
     location of the dependent library explicitly.  Use @dl_resolve_using
     for this.

     Example usage:

          @dl_resolve_using = dl_findfile('-lsocket');

@dl_require_symbols
     A list of one or more symbol names that are in the library/object file
     to be dynamically loaded.  This is only required on some platforms.

@dl_librefs
     An array of the handles returned by successful calls to
     dl_load_file(), made by bootstrap, in the order in which they were
     loaded.  Can be used with dl_find_symbol() to look for a symbol in
     any of the loaded files.

@dl_modules
     An array of module (package) names that have been bootstrap'ed.

dl_error()
     Syntax:

          $message = dl_error();

     Error message text from the last failed DynaLoader function.  Note
     that, similar to errno in unix, a successful function call does not
     reset this message.

     Implementations should detect the error as soon as it occurs in any of
     the other functions and save the corresponding message for later
     retrieval.  This will avoid problems on some platforms (such as SunOS)
     where the error message is very temporary (e.g., dlerror()).

$dl_debug
     Internal debugging messages are enabled when $dl_debug is set true.
     Currently setting $dl_debug only affects the Perl side of the
     DynaLoader.  These messages should help an application developer to
     resolve any DynaLoader usage problems.

     $dl_debug is set to `$ENV{'PERL_DL_DEBUG'}' if defined.

     For the DynaLoader developer/porter there is a similar debugging
     variable added to the C code (see dlutils.c) and enabled if Perl was
     built with the *-DDEBUGGING* flag.  This can also be set via the
     PERL_DL_DEBUG environment variable.  Set to 1 for minimal information
     or higher for more.

dl_findfile()
     Syntax:

          @filepaths = dl_findfile(@names)

     Determine the full paths (including file suffix) of one or more
     loadable files given their generic names and optionally one or more
     directories.  Searches directories in @dl_library_path by default and
     returns an empty list if no files were found.

     Names can be specified in a variety of platform independent forms.
     Any names in the form *-lname* are converted into `libname.*', where
     `.*' is an appropriate suffix for the platform.

     If a name does not already have a suitable prefix and/or suffix then
     the corresponding file will be searched for by trying combinations of
     prefix and suffix appropriate to the platform: "$name.o", "lib$name.*"
     and "$name".

     If any directories are included in @names they are searched before
     @dl_library_path.  Directories may be specified as *-Ldir*.  Any other
     names are treated as filenames to be searched for.

     Using arguments of the form `-Ldir' and `-lname' is recommended.

     Example:

          @dl_resolve_using = dl_findfile(qw(-L/usr/5lib -lposix));

dl_expandspec()
     Syntax:

          $filepath = dl_expandspec($spec)

     Some unusual systems, such as VMS, require special filename handling
     in order to deal with symbolic names for files (i.e., VMS's Logical
     Names).

     To support these systems a dl_expandspec() function can be implemented
     either in the `dl_*.xs' file or code can be added to the autoloadable
     dl_expandspec() function in `DynaLoader.pm'.  See `DynaLoader.pm' for
     more information.

dl_load_file()
     Syntax:

          $libref = dl_load_file($filename, $flags)

     Dynamically load $filename, which must be the path to a shared object
     or library.  An opaque 'library reference' is returned as a handle for
     the loaded object.  Returns undef on error.

     The $flags argument to alters dl_load_file behaviour.  Assigned bits:

          0x01  make symbols available for linking later dl_load_file's.
                (only known to work on Solaris 2 using dlopen(RTLD_GLOBAL))
                (ignored under VMS; this is a normal part of image linking)

     (On systems that provide a handle for the loaded object such as SunOS
     and HPUX, $libref will be that handle.  On other systems $libref will
     typically be $filename or a pointer to a buffer containing $filename.
     The application should not examine or alter $libref in any way.)

     This is the function that does the real work.  It should use the
     current values of @dl_require_symbols and @dl_resolve_using if
     required.

          SunOS: dlopen($filename)
          HP-UX: shl_load($filename)
          Linux: dld_create_reference(@dl_require_symbols); dld_link($filename)
          NeXT:  rld_load($filename, @dl_resolve_using)
          VMS:   lib$find_image_symbol($filename,$dl_require_symbols[0])

     (The dlopen() function is also used by Solaris and some versions of
     Linux, and is a common choice when providing a "wrapper" on other
     mechanisms as is done in the OS/2 port.)

dl_unload_file()
     Syntax:

          $status = dl_unload_file($libref)

     Dynamically unload $libref, which must be an opaque 'library
     reference' as returned from dl_load_file.  Returns one on success and
     zero on failure.

     This function is optional and may not necessarily be provided on all
     platforms.  If it is defined, it is called automatically when the
     interpreter exits for every shared object or library loaded by
     DynaLoader::bootstrap.  All such library references are stored in
     @dl_librefs by DynaLoader::Bootstrap as it loads the libraries.  The
     files are unloaded in last-in, first-out order.

     This unloading is usually necessary when embedding a shared-object
     perl (e.g.  one configured with -Duseshrplib) within a larger
     application, and the perl interpreter is created and destroyed
     several times within the lifetime of the application.  In this case
     it is possible that the system dynamic linker will unload and then
     subsequently reload the shared libperl without relocating any
     references to it from any files DynaLoaded by the previous
     incarnation of the interpreter.  As a result, any shared objects
     opened by DynaLoader may point to a now invalid 'ghost' of the
     libperl shared object, causing apparently random memory corruption
     and crashes.  This behaviour is most commonly seen when using Apache
     and mod_perl built with the APXS mechanism.

          SunOS: dlclose($libref)
          HP-UX: ???
          Linux: ???
          NeXT:  ???
          VMS:   ???

     (The dlclose() function is also used by Solaris and some versions of
     Linux, and is a common choice when providing a "wrapper" on other
     mechanisms as is done in the OS/2 port.)

dl_loadflags()
     Syntax:

          $flags = dl_loadflags $modulename;

     Designed to be a method call, and to be overridden by a derived class
     (i.e. a class which has DynaLoader in its @ISA).  The definition in
     DynaLoader itself returns 0, which produces standard behavior from
     dl_load_file().

dl_find_symbol()
     Syntax:

          $symref = dl_find_symbol($libref, $symbol)

     Return the address of the symbol $symbol or undef if not found.  If
     the target system has separate functions to search for symbols of
     different types then dl_find_symbol() should search for function
     symbols first and then other types.

     The exact manner in which the address is returned in $symref is not
     currently defined.  The only initial requirement is that $symref can
     be passed to, and understood by, dl_install_xsub().

          SunOS: dlsym($libref, $symbol)
          HP-UX: shl_findsym($libref, $symbol)
          Linux: dld_get_func($symbol) and/or dld_get_symbol($symbol)
          NeXT:  rld_lookup("_$symbol")
          VMS:   lib$find_image_symbol($libref,$symbol)

dl_find_symbol_anywhere()
     Syntax:

          $symref = dl_find_symbol_anywhere($symbol)

     Applies dl_find_symbol() to the members of @dl_librefs and returns
     the first match found.

dl_undef_symbols()
     Example

          @symbols = dl_undef_symbols()

     Return a list of symbol names which remain undefined after
     load_file().  Returns `()' if not known.  Don't worry if your
     platform does not provide a mechanism for this.  Most do not need it
     and hence do not provide it, they just return an empty list.

dl_install_xsub()
     Syntax:

          dl_install_xsub($perl_name, $symref [, $filename])

     Create a new Perl external subroutine named $perl_name using $symref
     as a pointer to the function which implements the routine.  This is
     simply a direct call to newXSUB().  Returns a reference to the
     installed function.

     The $filename parameter is used by Perl to identify the source file
     for the function if required by die(), caller() or the debugger.  If
     $filename is not defined then "DynaLoader" will be used.

bootstrap()
     Syntax:

     bootstrap($module)

     This is the normal entry point for automatic dynamic loading in Perl.

     It performs the following actions:

        * locates an auto/$module directory by searching @INC

        * uses dl_findfile() to determine the filename to load

        * sets @dl_require_symbols to `("boot_$module")'

        * executes an `auto/$module/$module.bs' file if it exists
          (typically used to add to @dl_resolve_using any files which are
          required to load the module on the current platform)

        * calls dl_load_flags() to determine how to load the file.

        * calls dl_load_file() to load the file

        * calls dl_undef_symbols() and warns if any symbols are undefined

        * calls dl_find_symbol() for "boot_$module"

        * calls dl_install_xsub() to install it as "${module}::bootstrap"

        * calls &{"${module}::bootstrap"} to bootstrap the module (actually
          it uses the function reference returned by dl_install_xsub for
          speed)

AUTHOR
======

   Tim Bunce, 11 August 1994.

   This interface is based on the work and comments of (in no particular
order): Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto, Anno
Siegel, Thomas Neumann, Paul Marquess, Charles Bailey, myself and others.

   Larry Wall designed the elegant inherited bootstrap mechanism and
implemented the first Perl 5 dynamic loader using it.

   Solaris global loading added by Nick Ing-Simmons with design/coding
assistance from Tim Bunce, January 1996.


File: pm.info,  Node: EMatrix,  Next: Edit,  Prev: DynaLoader,  Up: Module List

SYNOPSIS
========

   use EMatrix; my $titleHash = {  "0,0" => "Header1",  "0,1" => "Header2",
"0,2" => "Header3",  "0,3" => "Header4",  "0,4" => "Header5", };

   my $table; $table = $mw->Scrolled('EMatrix',    -cols          => 5,
-bd            => 2,    -bg            => 'white',    -titlerows     => 1,
  -variable      => $titleHash, );

   $table->tagConfigure('title',    -bg => 'tan',    -fg => 'black',
-relief => 'raised' );

   $table->pack(-expand => 1, -fill => 'both');

DESCRIPTION
===========

   The EMatrix widget is a derived widget that provides 6 additional
methods above and beyond the traditional Tk::TableMatrix widget.

METHODS
=======

   *bindRow(-index =* int, -sequence => string, -command => sub ref);>

   bindRow binds a particular sequence to the subroutine at the row
specified by the "-index" option.  Note that binding row 0 will bind the
column headers, which may not be what you want.

   You cannot currently bind a range of rows (i.e. -index=>2-5) for now,
though that is an enhancement I may add in the future.

   e.g. $em->bindRow( 	-index    => 2,    -sequence => '<Control-g>',
-command  => sub{ print "Hello World!" } );

   *bindCol(-index =* int, -sequence => string, -command => sub ref);>

   This method is identical to 'bindRow()' above, except that it binds a
column instead of a row (duh).

   *getRow(index, ?range?);*

   Returns the row at specified index as an array in list context, or an
array reference in scalar context.

   If the range is omitted (or 'end' is used), it will return the contents
of all cells in that row (including empty cells).  Otherwise, it will only
return the contents of the cells up to the specified range, starting at
index 0.

   *getRowHash(index, ?range?, ?tie?);*

   Returns the row at the specified index as a hash.  The key is the cell
value ('0,1' for example), the value is the content of the cell.

   If a second index is omitted (or 'end' is used), it will return the
contents of all cells in that row (including empty cells).  Otherwise, it
will only return the contents of the cells up to the specified range
starting at index 0.

   If the string 'tie' is included, the hash will be returned in cell
order (left to right).  To use this option you must have the Tie::IxHash
module installed.

   *getCol(index, ?range?);*

   Returns the column at the specified index as an array in list context,
or an array reference in scalar context.  See 'getRow()' for more details.

   *getColHash(index, ?range?, ?tie?);*

   Returns the column at the specified index as a hash in list context, or
a hash reference in scalar context.  See 'getRowHash()' above for more
details.

   If the string 'tie' is included as an argument, the hash will be
returned in cell order (top to bottom).  This requires the Tie::IxHash
module.

FUTURE RELEASES
===============

  1. Cell ranges - allow a range of cells to be selected at a particular
     index.  e.g. $dw->getRow(0, 3-5); # Would return the contents of
     cells 3, 4 and 5 at row 0.

  2. A row of buttons on the left side to mimic MS Excel behavior.

  3. Methods to make importing Excel spreadsheets a snap (via the
     ParseExcel module perhaps).

AUTHOR
======

   Daniel Berger, djberg96@hotmail.com

   Many thanks go out to John Cerney for providing help with this module
(especially the bind methods).

SEE ALSO
========

   Tk::TableMatrix, Tie::IxHash.


File: pm.info,  Node: Edit,  Next: Eesh,  Prev: EMatrix,  Up: Module List

module to implement common text editing functions
*************************************************

NAME
====

   String::Edit - module to implement common text editing functions

   chopexpr - returns args after they've been chopped

   chompexpr - returns args after they've been chomped

   trim - remove leading and trailing white space

   trimleft - remove leading white space

   trimright - remove trailing white space

   sqsps - trim, then squeeze internal white space

   detab - convert tabs to spaces

   set_tab_width - set tab for detab() function

   detab_till - tab through a particular point

   commify - put commas in numbers

   unmeta - convert 8bit chars to M-<seven bit>

   uncontrol - convert control chars to ^a, etc.

   uncontrolmeta - make both control and metachars legible

DESCRIPTION
===========

   The String::Edit module implements various commonly executed functions
to maniuplate text.  All share the following properties:  they may be
called with one or more args; they leave their arguments unchanged,
instead returning the result of the change; and raise an exception if the
function is called without any arguments at all or else with many
arguments while in a scalar context.

   Here are the functions defined by the module:

Chopping Functions
------------------

chopexpr
     Each argument is chop()ed.  This takes care of the common problem of
     wanting to chop() an expression, like backticks.

chompexpr
     Like chopexpr() but calling chomp() instead.

Trimming Functions
------------------

trim
     All leading and trailing white space will be removed from the
     resulting string(s).  Strings with embedded newlines may not be
     handled as you expect: internal newlines will be ignored.

trimleft
     Like trim() but only the left-hand side of the string will be changed.

trimright
     Like trim() but only the right-hand side of the string will be
     changed.

sqsps
     First trim()s the string, then converts all runs of white space
     internally into just one space.

Tab Conversion Functions
------------------------

detab
     All tabs are converted into the appropriate number of spaces.  Note
     that characters of width other than one (like backspace, null, etc),
     will always be counted as length one.

detab_till
     First arg is the width of each tab, then remaining arguments are as
     in detab().

set_tab_width
     Reset internal tab width for further calls to detab().

Control and Meta-character Conversions
--------------------------------------

uncontrol
     Convert control chars to "^" plus the capital character.  For example,
     <CONTROL-H> goes to "^H".  <DELETE> will be represented as "^?".

unmeta
     Convert 8-bit chars to "M-" plus the character with the 8th bit
     stripped.  Octal 210 looks like "M-^H" though (4 chars).

uncontrolmeta
     Convert metacharacters to their printing equivalents and control
     characters to theirs.

Numerical Text Functions
------------------------

commify
     Put commas every 3 places in the integer portion of a number.

EXAMPLES
========

   Here are some examples of calling a few of these:

     print "Today is <", chopexpr(`date`), ">\n";

     $better = trim("  stuff\t\n");
     @best = trim(@old);

     $n = commify(65358979);

     set_tab_width(4);
     while (<>) {
         chop;
         print uncontrolmeta(detab($_)), "\n";
     }

INHERITANCE
===========

   You can define your own module that uses String::Edit's argument
checking and associated properties.  Inherit from String::Edit (you need
its AUTOLOAD() function), and place an entry in the %Command_Table from
that module.  The key is the name of the function, and the value is the
function to call for each of the functions arguments.  For example:

     package Sample;
     require String::Edit;
     require Exporter;
     @ISA = qw(Exporter String::Edit);
     @EXPORT = qw(intmany);
     $String::Edit::Command_Table{intmany} = sub {
         package String::Edit;
         warn "$AUTOLOAD called!";  # dang inheritance
         s/\..*//;  # $_ is a true global!!
     };
     1;

   Now someone can call it this way:

     use Sample;
     @short = intmany(2.12, 3.23, 23.122);

   and @short will be

     (2, 3, 23)

BUGS
====

   If you call these with a list of length 0, they will be very unhappy.

AUTHOR
======

   Tom Christiansen `<tchrist@perl.com>'.


File: pm.info,  Node: Eesh,  Next: Emacs,  Prev: Edit,  Up: Module List

Enlightenment Window Manager IPC Library
****************************************

NAME
====

   Eesh - Enlightenment Window Manager IPC Library

SYNOPSIS
========

     ## Long form:
     use Eesh qw( e_open e_send e_recv ) ;

     e_open() ;
     print e_recv( 'window_list' ) ;
     e_send( 'restart' ) ;

     ## Short form
     use Eesh qw( :all ) ;
     e_open() ;
     print "$_\n" for ( e_window_list ) ;

     my $win_id = (grep { /Terminal/ } e_window_list)[0] ;
     e_win_op( $win_id, 'raise' ) ;

     ## For non-blocking receives:
     my $hmmm = e_recv( { non_blocking => 1 } ) ;

DESCRIPTION
===========

   Eesh.pm provides simple wrappers around the routines from eesh
(included).

   This code is in alpha mode, please let me know of any improvements, and
patches are especially welcome.

Basic Communications Functions
------------------------------

e_open
     Opens communications with E.

e_send
     Sends to E.

e_recv
     Receives from E, blocking until data is received.

     Can send strings first and then wait for the result:

          my @windows = split( /^/m, e_recv( 'window_list' ) ) ;

     Can be called non-blocking:

          e_send( 'window_list' ) ;
          
          my $hmmm ;
          $hmmm = e_recv( { non_blocking => 1 } ) until defined $hmmmm ;

e_fileno
     Returns the file number of the connection to E, useful for select
     loops.

High level functions
--------------------

   These are simple functions that wrap around E IPC commands.  The really
simple commands aren't wrapped, since it wouldn't save much typing (though
they would provide varying levels of mispeled option detection):

     e_send( 'advanced_focus new_window_focus on' ) ;

   vs.

     e_enable_advanced_focus_new_window_focus() ;
     e_advanced_focus_new_window_focus( 'on' ) ;
     e_advanced_focus( 'new_window_focus', 'on' ) ;
     e_enable( 'advanced_focus', 'new_window_focus' ) ;

   Perhaps we could provide something like:

     e_enable_new_window_focus() ;

   which would be a savings and allow for safer programming (since a
mispelling would show up under 'use strict').  But that's only viable so
long as no identifier is used more than once in the entire command set,
which I can't guarantee.

   If you don't see a function here that you need, ask for it or send a
patch.  See the eesh help command for more documentation on these.

e_backgrounds
     Returns a list of all background ids, one per element.

e_delete_background
     Deletes a background

e_background
     Returns a hash reference to the values defined for a particular
     background:

          print e_background( shift e_backgrounds )->{'bg.solid'}, "\n" ;

e_set_background
     Takes a background id and either a hash or a list of key/value pairs
     and sets them:

          e_set_background( $bg_id, 'bg.file' => $filename ) ;

e_focused
     A short form of e_set_focus( '?' ) :

          my $win_id = e_focused() ;

e_internal_list
     Returns the requested list:

          e_internal_list( 'menus' ) ;

     might yield:

          ('1400509','14000f9')

     Note that spaces and newlines are stripped, and that these are
     strings, not numbers.

e_list_class
     Returns a list of the supplied class.

          e_list_class( 'backgrounds' ) ;

     should return the same list as e_backgrounds().

e_list_themes
     Returns a list of themes.

e_modules
     Returns a list of modules.  Don't ask me why this isn't
     "list_modules" or "modules_list".

e_remember
     Takes a window ID and a parameter.  The window ID may be the full item
     returned from e_window_list(), or just the ID portion.

e_set_focus
     Can take a window ID, the full ID returned from window_list().

     See e_focused() for a short form of e_set_focus( '?' ).

e_win_op
     Takes a window ID, or one of the values returned by e_window_list()
     and performs a win_op on it.

     If used in a non-void context, this will block and return any data
     received.  So don't do that if you might not get anything back.

e_window_list
     Returns a list of strings containing window IDs and titles:

          (
             '2400006 : Terminal',
             '3c00080 : VIM - ~/src/Eesh/Eesh.pm',
             ...
          )

     The leading whitespace and trailing newlines are trimmed.

     These may be passed in anywhere a window ID is needed, such as
     e_win_op() or e_iconify().

LICENSE
=======

   Copyright (C) 2000 Barrie Slaymaker, Carsten Haitzler, Geoff Harrison
and various contributors

   Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included
in all copies of the Software, its documentation and marketing & publicity
materials, and acknowledgment shall be given in the documentation,
materials and software packages that this Software was used.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

AUTHORS
=======

   Eesh: Barrie Slaymaker <barries@slaysys.com>

   eesh: Carsten Haitzler, Geoff Harrison and various contributors

SEE ALSO
========

   eesh


