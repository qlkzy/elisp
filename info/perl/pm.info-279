This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Number/Phone/US,  Next: Number/Spell,  Prev: Number/Latin,  Up: Module List

Validate US phone numbers
*************************

NAME
====

   Number::Phone::US - Validate US phone numbers

SYNOPSIS
========

     use Number::Phone::US qw(is_valid_number);

     &do_that_thing if is_valid_number($input);

DESCRIPTION
===========

   Number::Phone::US is a simple module to validate US phone numbers.

   Currently marks as valid, phone numbers of the following forms:

     (734) 555 1212
     (734) 555.1212
     (734) 555-1212
     (734) 5551212
     (734)5551212
     734 555 1212
     734.555.1212
     734-555-1212
     7345551212
     555 1212
     555.1212
     555-1212
     5551212
     5 1212
     5.1212
     5-1212
     51212

validate_number($ )
     Use like

          if ( validate_number($number) ) { &foo; }

     returns true if $number is a properly formatted US phone number.
     does _not_ check and see if $number is a functioning number, although
     maybe it should.

     this function can also be called as: is_valid_number($number)

get_regex ()
     Use like

          $rough_regex = get_regex;
          if ( $phone =~ /$rough_regex/o ) { &foo }

     returns the rough regex string (does not enforce phone number
     consistency.)

COPYRIGHT
=========

     COPYRIGHT  2000 THE REGENTS OF THE UNIVERSITY OF MICHIGAN
     ALL RIGHTS RESERVED

     PERMISSION IS GRANTED TO USE, COPY, CREATE DERIVATIVE WORKS
     AND REDISTRIBUTE THIS SOFTWARE AND SUCH DERIVATIVE WORKS FOR
     NON-COMMERCIAL EDUCATION AND RESEARCH PURPOSES, SO LONG AS NO
     FEE IS CHARGED, AND SO LONG AS THE COPYRIGHT NOTICE ABOVE,
     THIS GRANT OF PERMISSION, AND THE DISCLAIMER BELOW APPEAR IN
     ALL COPIES MADE; AND SO LONG AS THE NAME OF THE UNIVERSITY
     OF MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY
     PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE
     WITHOUT SPECIFIC, WRITTEN PRIOR AUTHORIZATION.

     THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION AS
     TO ITS FITNESS FOR ANY PURPOSE,  AND WITHOUT WARRANTY OF ANY
     KIND,  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
     LIMITATION THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE. THE REGENTS OF THE
     UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE FOR ANY DAMAGES,
     INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
     DAMAGES, WITH RESPECT TO ANY CLAIM ARISING OUT OF OR IN
     CONNECTION WITH THE USE OF THE SOFTWARE, EVEN IF IT HAS BEEN
     OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

SEE ALSO
========

   perl(1)

AUTHOR
======

   Hugh Kennedy <kennedyh@engin.umich.edu>

     __|   \   __|  \ |
         (     _ \  _|  .  |
        \___|_/  _\___|_|\_|


File: pm.info,  Node: Number/Spell,  Next: Number/Spice,  Prev: Number/Phone/US,  Up: Module List

Perl extension for spelling out numbers
***************************************

NAME
====

   Number::Spell - Perl extension for spelling out numbers

SYNOPSIS
========

     use Number::Spell;
     my $str=spell_number(519252);

DESCRIPTION
===========

   Number::Spell provides functionality for spelling out numbers.
Currently only integers are supported.

   By default Number::Spell does American formatting, but can be configured
to do European formatting by calling it with the "Format => 'eu'" option:

     spell_number( ...  , Format => 'eu');

   American and European formatting differ in how they represent numbers
one billion and above.

     number 		:  	20000000000 (2 * 10^11)
     American format :	twenty billion
     European format :	twenty thousand million

   With American formatting (default) Number::Spell should work for
integers to

     nine hundred ninety nine vigintillion nine hundred ninety nine
     novemdecillion nine hundred ninety nine octodecillion nine hundred
     ninety nine septendecillion nine hundred ninety nine sexdecillion nine
     hundred ninety nine quindecillion nine hundred ninety nine
     quattuordecillion nine hundred ninety nine tredecillion nine hundred
     ninety nine duodecillion nine hundred ninety nine undecillion nine
     hundred ninety nine decillion nine hundred ninety nine nonillion nine
     hundred ninety nine octillion nine hundred ninety nine septillion nine
     hundred ninety nine sextillion nine hundred ninety nine quintillion nine
     hundred ninety nine quadrillion nine hundred ninety nine trillion nine
     hundred ninety nine billion nine hundred ninety nine million nine
     hundred ninety nine thousand nine hundred ninety nine

   and in European formatting mode is should be valid up-to

     nine hundred ninety nine thousand nine hundred ninety nine vigintillion
     nine hundred ninety nine thousand nine hundred ninety nine
     novemdecillion nine hundred ninety nine thousand nine hundred ninety
     nine octodecillion nine hundred ninety nine thousand nine hundred
     ninety nine septendecillion nine hundred ninety nine thousand nine
     hundred ninety nine sexdecillion nine hundred ninety nine thousand nine
     hundred ninety nine quindecillion nine hundred ninety nine thousand
     nine hundred ninety nine quattuordecillion nine hundred ninety nine
     thousand nine hundred ninety nine tredecillion nine hundred ninety nine
     thousand nine hundred ninety nine duodecillion nine hundred ninety nine
     thousand nine hundred ninety nine undecillion nine hundred ninety nine
     thousand nine hundred ninety nine decillion nine hundred ninety nine
     thousand nine hundred ninety nine nonillion nine hundred ninety nine
     thousand nine hundred ninety nine octillion nine hundred ninety nine
     thousand nine hundred ninety nine septillion nine hundred ninety nine
     thousand nine hundred ninety nine sextillion nine hundred ninety nine
     thousand nine hundred ninety nine quintillion nine hundred ninety nine
     thousand nine hundred ninety nine quadrillion nine hundred ninety nine
     thousand nine hundred ninety nine trillion nine hundred ninety nine
     thousand nine hundred ninety nine billion nine hundred ninety nine
     thousand nine hundred ninety nine million nine hundred ninety nine
     thousand nine hundred ninety nine

FUTURE IMPROVEMENTS
===================

     o   more formatting options.  i.e. option to get "1500" to spell as
            		 "fifteen hundred" instead of "one thousand five hundred"
     o   support for even larger numbers
     o   support for taking input as a Math::BigInt, Math::BigInteger
     o   support for taking numbers in scientific notation
     o   foreign language support
     o   support for real numbers (including Math::BigFloat)
     o   ability to convert from a "spelled" number to an arithmetic number

AUTHOR
======

   Les Howard, les@lesandchris.com

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Number/Spice,  Next: O,  Prev: Number/Spell,  Up: Module List

handling of Spice number strings
********************************

NAME
====

   Number::Spice - handling of Spice number strings

SYNOPSIS
========

     use Number::Spice qw(:convert);

     print spice_to_number('5u');      # 5E-6
     print spice_to_number('1.0e4k');  # 1.0E7

     print number_to_spice(1.0e12); # 1T
     print number_to_spice(1.0e-2); # 10M (i.e. milli, not mega!)

DESCRIPTION
===========

   Number::Spice was written to support the number format used in the
syntax for netlists for the spice electrical circuit simulator. This number
format is also used in other applications, even in different fields.
Number::Spice can be used to any purpose, and does not require the
installation of the spice simulator.

   Spice syntax provides a shortcut for writing down numbers in scientific
notation, by appending a suffix to the value which corresponds to a
numeric multiplier. The following table lists the minimal suffices and the
corresponding multiplier:

     T	1.0E12
     G	1.0E9
     MEG	1.0E6
     X	1.0E6
     K	1.0E3
     M	1.0E-3
     MIL	2.54E-5 (i.e. 1/1000 inch)
     U	1.0E-6
     N	1.0E-9
     P	1.0E-12
     F	1.0E-15
     A	1.0E-18

USAGE
=====

FUNCTIONS
---------

   The following functions are provided.  All functions are available for
exporting.

pattern
     Returns the regular expression matching a Spice number.

is_spice_number($spice_number)
     Returns true is the given string matches a Spice number after removal
     of leading and trailing whitespace. Note that a plain number, i.e.
     without literal suffix, is also accepted as a valid Spice number.

split_spice_number($spice_number)
     Examines a string and returns a list holding a number and a spice
     suffix if the string holds a valid spice number. Returns undef
     otherwise.

     Note that a regular number is also considered to be a spice number,
     and an empty string will be returned as the suffix in this case.

suffix_value($suffixc)
     Returns the value of a given spice suffix, e.g. suffix_value('giga')
     yields 1.0E9.

spice_to_number($spice_number)
     Returns a regular number represented by the given spice number.
     spice_to_number() will die() if the given number is not a spice
     number.

number_to_spice($number)
     Returns the shortest spice number representing the given number.
     Note that no conversion to *mil* will be attempted, and numbers
     smaller than 1.0E-18 will not get a suffix.

normalize_spice_number($spice_number)
     Converts a spice number to its shortest form by invoking
     spice_to_number() and number_to_spice().

REGULAR EXPRESSIONS
-------------------

   In addition to the methods, the following scalars representing regular
expressions are also made available for exporting:

`$RE_NUMBER'
     matches a regular number

`$RE_SPICE_SUFFIX'
     matches any spice suffix

`$RE_SPICE_NUMBER'
     matches a spice number. Note that a regular number is considered a
     spice number with no suffix. If you need to check for pure spice
     numbers, i.e. numbers with a literal suffix, check with
     `/$RE_NUMBER$RE_SPICE_SUFFIX\b/' instead.

EXPORT TAGS
-----------

   The functions and regular expressions are tagged into the following
groups for easy importing:

convert
     spice_to_number(), number_to_spice() and normalize_spice_number()

re
     `$RE_NUMBER', `$RE_SPICE_SUFFIX' and `$RE_SPICE_NUMBER'

all
     All conversion functions and regular expressions

SEE ALSO
========

   More info on the Spice format is given in the on-line Spice3 manual at
the University of Exeter, located at
http://newton.ex.ac.uk/teaching/CDHW/Electronics2/userguide/sec2.html#2

   And to those who were looking for numbers on the Spice Girls, but
unfortunately stranded here, take a peek at their official home page:
http://c3.vmg.co.uk/spicegirls/ ;-)

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright (c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: O,  Next: ODBM_File,  Prev: Number/Spice,  Up: Module List

Generic interface to Perl Compiler backends
*******************************************

NAME
====

   O - Generic interface to Perl Compiler backends

SYNOPSIS
========

     perl -MO=Backend[,OPTIONS] foo.pl

DESCRIPTION
===========

   This is the module that is used as a frontend to the Perl Compiler.

CONVENTIONS
===========

   Most compiler backends use the following conventions: OPTIONS consists
of a comma-separated list of words (no white-space).  The -v option
usually puts the backend into verbose mode.  The `-ofile' option generates
output to file instead of stdout. The -D option followed by various
letters turns on various internal debugging flags. See the documentation
for the desired backend (named `B::Backend' for the example above) to find
out about that backend.

IMPLEMENTATION
==============

   This section is only necessary for those who want to write a compiler
backend module that can be used via this module.

   The command-line mentioned in the SYNOPSIS section corresponds to the
Perl code

     use O ("Backend", OPTIONS);

   The import function which that calls loads in the appropriate
`B::Backend' module and calls the compile function in that package,
passing it OPTIONS. That function is expected to return a sub reference
which we'll call CALLBACK. Next, the "compile-only" flag is switched on
(equivalent to the command-line option -c) and a CHECK block is registered
which calls CALLBACK. Thus the main Perl program mentioned on the
command-line is read in, parsed and compiled into internal syntax tree
form. Since the -c flag is set, the program does not start running
(excepting BEGIN blocks of course) but the CALLBACK function registered by
the compiler backend is called.

   In summary, a compiler backend module should be called "B::Foo" for
some foo and live in the appropriate directory for that name.  It should
define a function called compile. When the user types

     perl -MO=Foo,OPTIONS foo.pl

   that function is called and is passed those OPTIONS (split on commas).
It should return a sub ref to the main compilation function.  After the
user's program is loaded and parsed, that returned sub ref is invoked
which can then go ahead and do the compilation, usually by making use of
the B module's functionality.

AUTHOR
======

   Malcolm Beattie, `mbeattie@sable.ox.ac.uk'


File: pm.info,  Node: ODBM_File,  Next: OLE/PropertySet,  Prev: O,  Up: Module List

Tied access to odbm files
*************************

NAME
====

   ODBM_File - Tied access to odbm files

SYNOPSIS
========

     use ODBM_File;

     tie(%h, 'ODBM_File', 'Op.dbmx', O_RDWR|O_CREAT, 0640);

     untie %h;

DESCRIPTION
===========

   See `tie', *Note Perlfunc: (perl.info)perlfunc,, `tie', *Note
Perldbmfilter: (perl.info)perldbmfilter,


File: pm.info,  Node: OLE/PropertySet,  Next: OLE/Storage,  Prev: ODBM_File,  Up: Module List

Handles Property Sets
*********************

NAME
====

   OLE::PropertySet - Handles Property Sets

   $Revision: 1.1.1.1 $ $Date: 1998/02/25 21:13:00 $

SYNOPSIS
========

     use OLE::Storage();
     use OLE::PropertySet();

     $Var = OLE::Storage -> NewVar;
     $Doc = OLE::Storage -> open ($Startup, $Var, "testfile.doc");

direct mode
     *$PS* = OLE::PropertySet->load (*$Startup*, *$Var*, *$pps*, *$Doc*)

     *@list* = string { *$PS* -> property (2, 5, 6) }

tie mode
     *$PS* = tie *%PS*, OLE::PropertySet, *$Startup*, *$Var*, *$pps*,
     *$Doc*

     *@list* = string { *$PS*{2}, *$PS*{5}, *$PS*{6} }

DESCRIPTION
===========

   OLE::PropertySet gives read access to property sets. These are streams,
that e.g. are residing inside of Structured Storage documents. Because
property set technology is not limited to these documents borders, this
package was designed to connect easily to Structured Storage documents and
to arbitrary property set streams.

   To understand the use of this package, I recommend highly to study the
tool "ldat".

dictionary
     1||O == *$PS* -> dictionary (*\%dict* [,1])

     Stores the dictionary of PropertySet *$PS* in hash *%dict*. The
     dictionary is a hash array having the property identifier numbers as
     keys and the identifier names as values. By default the default
     dictionaries defined in OLE::PropertySet are also printed out. To
     leave them out, specify the optional parameter 1.

     Normally you will not need this method, but use idset() instead.

idset
     1||O == *$PS* -> idset (*\%idset* [,1]);

     Stores the idset of PropertySet *$PS* in hash *%idset*. The idset is
     a hash array based on the really available property identifiers.
     %idset has property identifier numbers as keys and the identifier
     names according to the PropertySets dictionary as values. The optional
     parameter spares out the default dictionary (see dictionary).

     Note: Some or all id names can be empty, if they cannot be figured
     out. Nevertheless the ids are valid.

idstr
     *$idstr*||undef = *$PS* -> idstr ($id [,1])

     Returns the property identifier string for property $id according to
     the PropertySets dictionary. The optional parameter spares out the
     default dictionary (see dictionary).

load

    *$PS*||0 ==
          1. load (*$Startup*, *$Var*, *$pps*, *$Doc* [,filter])

          2. load (*$Startup*, *$Var*, $name, *\$buf* [,filter])


     load() is the constructor of OLE::PropertySet. You can call it either
     with a Property Storage id *$pps* and a Structured Storage document
     handle *$Doc* as parameters, or with an PropertySetName $name and a
     reference to a PropertySetBuffer *\$buf*.

NewVar
     *$Var* == *$PS* -> NewVar ()

     Creates a new Variable handling object and returns it. (see also:
     open)

property
     Property||scalar = *$PS* -> property (*$id1* [,*$id2* [...]])

     Returns a *$Property* or a list of *@Properties*. (See
     OLE::Storage::Property to look what to do with it / them). If you
     applied a filter when loading *$PS*, property returns a scalar or a
     list of scalars.

type
     $type||0 = PropertySet -> type (*$Doc*, *$pps*)

     $type||0 = PropertySet -> type ($name)

     Returns the type of a PropertySet according to its name. The type is
     a OLE::PropertySet internal. It can be used to determine, if a
     property is a PropertySet or not. Momentarily are existing:

          type    meaning
          ---------------------------------------------------
          0x01    property is a "\05" PropertySet
          0x10    property is a "\01CompObj" fake PropertySet
          0x00    property is no PropertySet at all

SEE ALSO
========

   *Note OLE/Storage/Property: OLE/Storage/Property,, demonstration
program "ldat"

AUTHOR
======

   Martin Schwartz <`schwartz@cs.tu-berlin.de'>.


File: pm.info,  Node: OLE/Storage,  Next: OLE/Storage/Handler,  Prev: OLE/PropertySet,  Up: Module List

An Interface to *Structured Storage* Documents.
***********************************************

NAME
====

   OLE::Storage - An Interface to *Structured Storage* Documents.

   $Revision: 1.8 $ $Date: 1998/04/28 00:39:43 $

SYNOPSIS
========

   use OLE::Storage()

   use Startup;

   *$Var* = OLE::Storage->NewVar (); *$Startup* = new Startup;

   *$Doc* = OLE::Storage->open (*$Startup*, *$Var*, $file [,$m, *\$buf*])

   *$Doc* -> directory (*$pps*, *\%Names*, "string")

   *$Doc* -> read (*$pps*, *\$buf* [,$offset, $size])

   *$Doc* -> close ()

   Detailed syntax, descriptions and further methods: below.

DESCRIPTION
===========

   Documents done at Microsoft Windows Systems are tending to be stored in
a persistant data format, that MS calls "Structured Storage". This module
gives access to Structured Storage files. Alas, the current release allows
more or less read access, only. You can modify document contents (streams)
with it, but you cannot create or delete streams, nor rename them or
change their size. Also a file locking mechanism still is missing. I hope
to offer write support with next release.

close
     1||O == *$D* -> close ()

     Close the document.

clsid
     *$clsid* == *$D* -> clsid (*$pps*)

     Returns the CLSID of the property *$pps* as CLSID Property.

color
     0||1 == *$D* -> color (*$pps*)

     Returns the "color" of the property *$pps*.

date
     *$Date* == *$D* -> name (*$pps*)

     Returns a 0x40 Property (filetime) with the creation date of property
     storage *$pps*. See OLE::Storage::Property for more information.

     Note: As of now, only directory properties have filetime stamps.

directory
     1||O == *$D* -> directory (*$pps*, *\%Names* [,method])

     Read the directory denoted by property handle *$pps*. Fills the hash
     array *%Names* with the property names as keys and property handles
     as values.  The property names are Unicode Properties. To use the
     directory hash easily you optionally can apply a Property method. You
     will probably have to use *"string"* or *"wstring"*. See
     OLE::Storage::Property for more information.

     Note: To get the root directory, call directory (0, *\%Names*).

dirhandles
     *@pps* == *$D* -> dirhandles (*$pps*)

     Similar to directory (). Returns not the names, but only the property
     handles of the directory denoted by property handle *$pps*.

     Note: Normally you will use directory () instead.  To get the root
     directory, call dirhandles(0)

Startup
     *$Startup* == *$D* -> Startup ([*$NewStartup*])

     Gets the current *$Startup* handler. If an optional argument
     *$NewStartup* is given, this new handler will be installed and
     returned.

is_directory
     1||O == *$D* -> is_directory (*$pps*)

     Returns 1 if the property handle *$pps* is refering to a directory, 0
     otherwise.

is_file
     1||O == *$D* -> is_file (*$pps*)

     Returns 1 if the property handle *$pps* is refering to a file, 0
     otherwise.

is_root
     1||O == *$D* -> is_root (*$pps*)

     Returns 1 if the property handle *$pps* is refering to the document
     root, 0 otherwise.

modify
     1||O == *$D* -> modify (*$pps*, *\$buf*, $offset, $size)

     Modifies the contents of the property file *$pps*. $size bytes of the
     file *$pps* starting at offset $offset will be replaced by $size
     bytes of the buf *$buf* starting at offset 0.

     Note: This is still very restrictive, e.g. because the size of a file
     cannot be changed. Also missing is a possibility to give an offset to
     *$buf*.

modify_trash
     1||O == *$D* -> modify_trash ($type, *\$buf*, $offset, $size)

     Modifies the contents of the trash section $type. $size bytes of the
     trash section $type starting at offset $offset will be replaced by
     $size bytes of the buf *$buf* starting at offset 0.

name
     *$Name* == *$D* -> name (*$pps*)

     Returns the name of the property *$pps* as Unicode Property.

NewVar
     *$Var* == *$D* -> NewVar ()

     Creates a new Variable handling object and returns it. (see also:
     open)

open
     *$Doc*||O == Storage -> open (*$Startup*, *$Var*, $file [,$mode,
     *\$buf*])

     Constructor. Open the document with document path $file. $mode can be
     read or read/write. If you additionally specify modus buffer, the
     document data will be read from the buffer reference you specify with
     *$buf*.  Errors will be reported to Startup object *$Startup* (if
     present).

     Open modes:

          Bit	= 0 		= 1
          0	Read Only	Read and Write
          4	File Mode	Buffer Mode

read
     1||O == *$D* -> read (*$pps*, *\$buf*, [$offset, $size])

     Read the file property *$pps* into buffer *$buf*. If there is an
     optional $offset and $size, only this part of the file will be read.

read_trash
     1||O == *$D* -> read_trash ($type, *\$buf* [,$offset, $size])

     Read the trash section $type into buffer $buf. If there is an optional
     $offset and $size, only this part of the trash section will be read.
     Trash types can be 0, 1, 2, 4, 8 or a sum of this, like (1+2+8). 0 is
     default and yields (1+2+4+8). You can find an explanation of these
     types in `lclean' in this node.

     Trash types:

          #  Type
          -------------------
          1  Big blocks
          2  Small blocks
          4  File end space
          8  System space

size
     $size||undef == *$D* -> size (*$pps*)

     Returns the size of the file property *$pps* in terms of bytes.

size_trash
     $size == *$D* -> size_trash ($type)

     Returns the byte size of the trash section $type.

Var
     *$Var* == *$D* -> Var ([*$NewVar*])

     Gets the current $Var handler. If an optional argument $NewVar is
     given, this new handler will be installed and returned.

SEE ALSO
========

   *Note OLE/Storage/Property: OLE/Storage/Property,, *Note Startup:
Startup,, *Note OLE/Storage/Var: OLE/Storage/Var,

EXAMPLES
========

   *OLE::Storage* demonstration programs, as there are:

lls
     *Laola ls*. Lists document structures.

ldat
     *Loala Display Authress Title*. Displays content of property sets and
     shows, how by principle to fool around with Excel documents.

lclean
     Cleans and saves garbage in Structured Storage documents. Can also
     store and retrieve a file at the garbage sections.

lhalw
     *Have a look at Word*. Draws the text out of Word 6 and Word 7
     documents, supports a little bit Word 8.

WWW
===

   Latest distribution of *Laola* and *Elser* at:

     http://wwwwbs.cs.tu-berlin.de/~schwartz/pmh
     or
     http://www.cs.tu-berlin.de/~schwartz/pmh

BUGS
====

   None known. I'm waiting for your hints!

AUTHOR
======

   Martin Schwartz <`schwartz@cs.tu-berlin.de'>.


File: pm.info,  Node: OLE/Storage/Handler,  Next: OLE/Storage/Io,  Prev: OLE/Storage,  Up: Module List

Handle functions for OLE::Storage::Var
**************************************

NAME
====

   OLE::Storage::Handler - Handle functions for OLE::Storage::Var

   $Revision: 1.1.1.1 $ $Date: 1998/02/25 21:13:00 $

SYNOPSIS
========

   use OLE::Storage::Var;

   *$Var* = new Var;

   *$Handle* = *$Var* -> handle();

   Methods will be described below. But be aware, that this package is a
little bit likely to be removed in future. Actually you should not need to
deal with it at all.

DESCRIPTION
===========

   OLE::Storage::Handler is the interface used by OLE::Storage::Var. The
purpose was to allow the installation of new Property types easily and
even at runtime.  An example of how this could look like can be found in
"lls". Anyway, this all looks pretty superfluous to me, and therefore
might be removed some nice day.

   *\&sub* == *$Var* -> add (*$from*, *$fromstr*||0, *$to*, *\&sub*
[,*$par*])

   $data = *$Var* -> convert (*$from*, *$to*, *\$buf*, *\$o*)

   *\&sub* == *$Var* -> func (*$from*, *$to* [,*$Sub* [,*$par*]])

   *\&sub* == *$Var* -> code (*$from*, *$to* [,*$Sub*])

   *$par* = *$Var* -> par (*$from*, *$to* [,*$par*])

   *$typestr* = *$Var* -> typestr ($type [,*$typestr*])

SEE ALSO
========

   *Note OLE/Storage/Var: OLE/Storage/Var,, demonstration program "lls"

AUTHOR
======

   Martin Schwartz <`schwartz@cs.tu-berlin.de'>.


File: pm.info,  Node: OLE/Storage/Io,  Next: OLE/Storage/Iolist,  Prev: OLE/Storage/Handler,  Up: Module List

Laola's IO interface
********************

NAME
====

   OLE::Storage::Io - Laola's IO interface

SYNOPSIS
========

   use OLE::Storage::Io();

   s.b.

DESCRIPTION
===========

   Note: OLE::Storage is doing IO by maintaining lists consisting of
($offset, $length) elements.

close
     1||O == *$Io* -> close ([*\$streambuf*])

     Destructor. Flushes cache and closes file.

flush
     1 == *$Io* -> flush ()

     Flush *$Io* cache, if caching is turned on.

name
     $name = *$Io* -> name ()

     Returns name of *$Io*.

open
     *$Io*||O == open (*$Startup*, $name, [,$mode [,*\$streambuf*]])

     Constructor. Gives access to a file or a buffer. Default $mode is 0,
     that is read only. In file mode $name is a filepath. In buffer mode a
     reference to a buffer *\$streambuf* is mandatory. Errors occuring at
     Io methods will be reported to Startup object *$Startup*.

          Bit	Mode
          0	0 read only	1 read/write
          4	0 file mode	1 buffer mode

read
     1||O == *$Io* -> read ($offset, *$len*, *\$buf* [,*$var_offset*])

     Reads *$len* bytes starting at offset $offset into buffer referenced
     by *\$buf*. If *$var_offset* is given, buffer will be filled from
     this offset on.

rw_iolist
     1||0 == *$Io* -> rw_iolist (`"r"'||`"w"', *\$buf*, *$iolistO*);

     Read Iolist *$Io* into buffer *$buf* ("r"), or write buffer to Iolist
     *$Io*.

size
     *$len* = *$Io* -> size ()

     Returns size of *$Io* in bytes.

writable
     1||O == *$Io* -> writable ()

     *$Io* is writable (1) or not (0).

write
     1||O == *$Io* -> write ($offset, *$len*, *\$buf* [,*$var_offset*])

     Writes *$len* bytes starting at offset $offset from buffer referenced
     by *\$buf* to *$Io*. If *$var_offset* is given, buffer will be read
     from this offset on.

SEE ALSO
========

   *Note OLE/Storage/Iolist: OLE/Storage/Iolist,, *Note Startup: Startup,

AUTHOR
======

   Martin Schwartz <`schwartz@cs.tu-berlin.de'>


File: pm.info,  Node: OLE/Storage/Iolist,  Next: OLE/Storage/Property,  Prev: OLE/Storage/Io,  Up: Module List

Data management for OLE::Storage::Io (*alpha*)
**********************************************

NAME
====

   OLE::Storage::Iolist - Data management for OLE::Storage::Io (*alpha*)

SYNOPSIS
========

   use OLE::Storage::Iolist();

   s.b.

DESCRIPTION
===========

   Note: OLE::Storage uses Iolists in conjuntion with Io interface for IO
operations. An IO entry is a two element list like ($offset, $length).

aggregate
     *$NewIolist* = *$IoL* -> aggregate (*$method*)

     Sorts and merges Iolist *$IoL*, returns the new packed Iolist
     *$NewIolist*. Returns an empty Iolist on errors (!*to be changed*!).
     *$method* can be:

          method	sort offsets	allow offset overlaps
          1		yes		no
          2		yes		yes
          3		no		no
          4		no		yes

append
     (*$o1*, $l1) == *$IoL* -> append ($o, *$l*)

     Appends an entry to Iolist. Tries to merge the Iolists last entry
     with the new one. Returns the new last entry of Iolist.

entry
     ($o, *$l*) = *$IoL* -> entry ($i)

     rval: Get entry number $i.

     ($o, *$l*) == *$IoL* -> entry ($i, $o, *$l*)

     lval: Set entry number $i to ($o, *$l*).  Returns this entry.

length
     (*$l*) = *$IoL* -> length ($i)

     rval: Get length of entry number $i.

     *$l* == *$IoL* -> length ($i, *$l*)

     lval: Set length of entry number $i to *$l*. Returns *$l*.

max  
     $num = *$IoL* -> max ()

     Returns number of *$IoL*'s entries.

new  
     *$IoL* = new Iolist ([*\@offset*, *\@length*])

     Iolist constructor. Returns an Iolist handle. Can be initialized with
     references to corresponding offset and length lists.

offset
     ($o) = *$IoL* -> offset ($i)

     rval: Get offset of entry number $i.

     $o == *$IoL* -> offset ($i, $o)

     lval: Set offset of entry number $i to $o. Returns $o.

push
     1 == *$IoL* -> push (*$AnotherIolist*)

     Appends all entries of *$AnotherIolist* to *$IoL*.

sumlen
     $length = *$IoL* -> sumlen ()

     Returns total length of *$IoL*'s entries.

SEE ALSO
========

   *Note OLE/Storage/Io: OLE/Storage/Io,

AUTHOR
======

   Martin Schwartz <`schwartz@cs.tu-berlin.de'>


File: pm.info,  Node: OLE/Storage/Property,  Next: OLE/Storage/Var,  Prev: OLE/Storage/Iolist,  Up: Module List

maintain Properties for OLE::Storage::Var
*****************************************

NAME
====

   OLE::Storage::Property - maintain Properties for OLE::Storage::Var

   $Revision: 1.1.1.1 $ $Date: 1998/02/25 21:13:00 $

SYNOPSIS
========

   OLE::Storage and OLE::PropertySet are returning from time to time a
kind of variables called Properties (*$Prop*). Properties could be handled
as follows:

     sub work {
        my $Prop = shift;
        if (is_scalar $Prop) {
           do_something_with ($Prop); # $Prop definitively is a scalar.
        } else {
           foreach $P (@{array $Prop}) {
              work ($P);              # $P could be an array itself.
           }
        }
     }

   $string = *$Prop* -> string()

   *$NewProp* = *$OldProp* -> cast ("string")

DESCRIPTION
===========

   OLE::Storage::Property is maintaining the Properties, that are initially
instantiated by other packages. It gives storage places to
OLE::Storage::Var, manages Property to Property conversions, Property to
scalar conversions and type information. Though you will use the member
functions of OLE::Storage::Property quite often, you should never create a
Property directly with this package. Therefore "use OLE::Storage::Property"
even was useless.

   Type implementation itself is done at OLE::Storage::Var, that offers
some private methods for OLE::Storage::Property. Both, type conversions
and type availability are quite far from being complete (as you will
notice when looking at Var.pm). For this release I cared only to have the
something->string conversions working, and therefore only them are
documented above.

array
     *\@Properties* = *$Prop* -> array()

     Returns a reference to a Property list. You have to use this to find
     out, which properties are hiding inside an array property.

Conversion: Property to perl scalar
     $scalar = *$Prop* -> method()

     Returns a scalar variable, that perl understands. Momentarily method()
     should be string() only.

Conversion: Property to Property
     *$NewProp* = *$OldProp* -> cast ("method")

     Returns a Property of type method.

is_scalar
     1||0 == *$Prop* -> is_scalar()

     Returns 1 if $Prop is a scalar variable, 0 otherwise. A property is
     scalar, if it is not an array.

is_array
     1||0 == *$Prop* -> is_array()

     Returns 1 if $Prop is some array variable, 0 otherwise.

is_varray
     1||0 == *$Prop* -> is_varray()

     Returns 1 if $Prop is a variant array variable, 0 otherwise. A
     variant array is an array, that consists out of elements with
     different types.

stype
     $type = *$Prop* -> stype()

     Returns the scalar type of property $Prop. This is useful if $Prop is
     an array and you want to know, what kind of variables it consists of.

type
     $type = *$Prop* -> type()

     Returns the type of the Property. It is a number if it is a real
     property type, and it is a string, if it is an internal property type.

typestr
     *$typestr* = *$Prop* -> typestr()

     Returns the name of the property type as string.

KNOWN BUGS
==========

   Property handling is *very* slow.

SEE ALSO
========

   *Note OLE/Storage/Var: OLE/Storage/Var,, demonstration program "ldat"

AUTHOR
======

   Martin Schwartz <`schwartz@cs.tu-berlin.de'>.


File: pm.info,  Node: OLE/Storage/Var,  Next: OLE/Storage_Lite,  Prev: OLE/Storage/Property,  Up: Module List

Variable handling for properties
********************************

NAME
====

   OLE::Storage::Var - Variable handling for properties

   $Revision: 1.1.1.1 $ $Date: 1998/02/25 21:13:00 $

SYNOPSIS
========

   use OLE::Storage::Var;

   *$Var* = new Var;

   *$Property* = *$Var* -> property (*\$buf*, $o||*\$o* [,$type])

   *$Handler* = *$Var* -> handler ()

DESCRIPTION
===========

   This package is governing the two packages OLE::Storage::Property and
OLE::Storage::Handler. It manages the binary data of properties.
OLE::Storage::Property uses methods of $Var to store and convert
properties.  OLE::Storage::Var will probably be changed very much in close
future. So what a luck, that:

   Normally the only thing you will have to do with this package is to
create an instance either via package OLE::Storage with "$Var =
OLE::Storage->NewVar", or with same method of package OLE::PropertySet.
This $Var you need to pass to OLE::Storage->open calls.

   Note: If you should to have to create new properties by your own, do it
always via this $Var interface.

SEE ALSO
========

   *Note OLE/Storage/Property: OLE/Storage/Property,, *Note
OLE/Storage/Handler: OLE/Storage/Handler,, demonstration program "lls"

AUTHOR
======

   Martin Schwartz <`schwartz@cs.tu-berlin.de'>.


File: pm.info,  Node: OLE/Storage_Lite,  Next: OO/Closures,  Prev: OLE/Storage/Var,  Up: Module List

Simple Class for OLE document interface. (Version: 0.08)
********************************************************

NAME
====

   OLE::Storage_Lite - Simple Class for OLE document interface. (Version:
0.08)

SYNOPSIS
========

     use OLE::Storage_Lite;
     use strict;
     #1. Initialize
     #1.1 From File
     my $oOl = OLE::Storage_Lite->new("some.xls");
     #1.2 From Scalar
     my $oOl = OLE::Storage_Lite->new(\$sBuff);
     #1.3 From IO::Handle object
     use IO::File;
     my $oIo = new IO::File;
     $oIo->open("<iofile.xls");
     binmode($oIo);
     my $oOl = OLE::Storage_Lite->new($oFile);
     #2. Read and Get Data
     my $oPps = $oOl->getPpsTree(1);
     #3.Save Data
     #3.1 As File
     $oPps->save("kaba.xls"); #kaba.xls
     $oPps->save('-');        #STDOUT
     #3.2 As Scalar
     $oPps->save(\$sBuff);
     #3.3 As IO::Handle object
     my $oIo = new IO::File;
     $oIo->open(">iofile.xls");
     bimode($oIo);
     $oPps->save($oIo);

DESCRIPTION
===========

   OLE::Storage_Lite allows you to read and write an OLE structured file.
Please refer OLE::Storage by Martin Schwartz.

   OLE::Storage_Lite::PPS is a class representing PPS.
OLE::Storage_Lite::PPS::Root, OLE::Storage_Lite::PPS::File and
OLE::Storage_Lite::PPS::Dir are subclasses of OLE::Storage_Lite::PPS.

new
---

   *$oOle* = OLE::Storage_Lite->new(*$sFile*);

   Constructor.  Creates a OLE::Storage_Lite object for *$sFile*.
*$sFile* must be a correct file name.

   From 0.06, *$sFile* may be a scalar reference of file contents (ex.
\$sBuff)  and IO::Handle object (including IO::File etc).

getPpsTree
----------

   *$oPpsRoot* = *oOle*->getPpsTree([$bData]);

   returns PPS as OLE::Storage_Lite::PPS::Root object.  Other PPS objects
will be included as its children.  if *$bData* is true, the objects will
have data in the file.

getPpsSearch
------------

   *$oPpsRoot* = *oOle*->getPpsTree($raName [, $bData][, $iCase] );

   returns PPSs as OLE::Storage_Lite::PPS objects that has the name
specified in *$raName* array.  if *$bData* is true, the objects will have
data in the file.  if *$iCase* is true, search with case insensitive.

getNthPps
---------

   *$oPpsRoot* = *oOle*->getNthPps($iNth [, $bData]);

   returns PPS as OLE::Storage_Lite::PPS object specified number(*$iNth*).
if *$bData* is true, the objects will have data in the file.

Asc2Ucs
-------

   *$sUcs2* = OLE::Storage_Lite::Asc2Ucs(*$sAsc*);

   Utility function.  Just adding 0x00 afeter every characters in *$sAsc*.

Ucs2Asc
-------

   *$sAsc* = OLE::Storage_Lite::Ucs2Asc(*$sUcs2*);

   Utility function.  Just deletes 0x00 afeter words in *$sUcs*.

OLE::Storage_Lite::PPS
======================

   OLE::Storage_Lite::PPS has these properties:

No
     order number in saving.

Name
     its name in UCS2 (a.k.a Unicode).

Type
     its type (1:Dir, 2:File (Data), 5: Root)

PrevPps
     previous pps (as No)

NextPps
     next pps (as No)

DirPps
     dir pps (as No).

Time1st
     timestamp1st in array ref as similar fomat of localtime.

Time2nd
     timestamp2nd in array ref as similar fomat of localtime.

StartBlock
     start block number

Size
     size of the pps

Data
     its data

Child
     its child PPSs in array ref

OLE::Storage_Lite::PPS::Root
============================

   OLE::Storage_Lite::PPS::Root has 2 methods.

new
---

   *$oRoot* = OLE::Storage_Lite::PPS::Root->new(
*$raTime1st*,                     *$raTime2nd*,
*$raChild*);

   Constructor.

   *$raTime1st*, *$raTime2nd* is a array ref as ($iSec, $iMin, $iHour,
$iDay, $iMon, $iYear, $iHSec).  $iSec means seconds, $iMin means minutes.
$iHour means hours.  $iDay means day. $iMon is month -1. $iYear is year -
1900.  $iHSec is seconds/10,000,000 in Math::BigInt.

   *$raChild* is a array ref of children PPSs.

save
----

   *$oRoot* = $o<oRoot>->save(                     *$sFile*,
     *$bNoAs*);

   Saves infomations into *$sFile*. *$sFile* is '-', this will use STDOUT.

   From 0.06, *$sFile* may be a scalar reference of file contents (ex.
\$sBuff)  and IO::Handle object (including IO::File etc).

   if *$bNoAs* is defined, this function will use the No of PPSs for
saving order.  if *$bNoAs* is undefined, this will calculate PPS saving
order.

OLE::Storage_Lite::PPS::Dir
===========================

   OLE::Storage_Lite::PPS::Dir has 1 method.

new
---

   *$oRoot* = OLE::Storage_Lite::PPS::Dir->new(
*$sName*                   [, *$raTime1st*]                   [,
*$raTime2nd*]                   [, *$raChild*]);

   Constructor.

   *$sName* is a name of the PPS.

   *$raTime1st*, *$raTime2nd* is a array ref as ($iSec, $iMin, $iHour,
$iDay, $iMon, $iYear, $iHSec).  $iSec means seconds, $iMin means minutes.
$iHour means hours.  $iDay means day. $iMon is month -1. $iYear is year -
1900.  $iHSec is seconds/10,000,000 in Math::BigInt.

   *$raChild* is a array ref of children PPSs.

OLE::Storage_Lite::PPS::File
============================

   OLE::Storage_Lite::PPS::File has 3 method.

new
---

   *$oRoot* = OLE::Storage_Lite::PPS::File->new(*$sName*, *$sData*);

   *$sName* is name of the PPS.

   *$sData* is data of the PPS.

newFile
-------

   *$oRoot* = OLE::Storage_Lite::PPS::File->newFile(*$sName*, *$sFile*);

   This function makes to use file handle for geting and storing data.

   *$sName* is name of the PPS.

   If *$sFile* is scalar, it assumes that is a filename.  If *$sFile* is
an IO::Handle object, it uses that specified handle.  If *$sFile* is undef
or ", it uses temporary file.

   CAUTION: Take care *$sFile* will be updated by append method.  So if
you want to use IO::Handle and append a data to it, you should open the
handle with "r+".

append
------

   *$oRoot* = $oPps->append($sData);

   appends specified data to that PPS.

   *$sData* is appending data for that PPS.

CAUTION
=======

   A saved file with VBA (a.k.a Macros) by this module will not work
correctly.  However modules can get the same information from the file,
the file occurs a error in application(Word, Excel ...).

COPYRIGHT
=========

   The OLE::Storage_Lite module is Copyright (c) 2000,2001 Kawai Takanori.
Japan.  All rights reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.

ACKNOWLEDGEMENTS
================

   First of all, I would like to acknowledge to Martin Schwartz and his
module OLE::Storage.

AUTHOR
======

   Kawai Takanori kwitknr@cpan.org

SEE ALSO
========

   OLE::Storage


File: pm.info,  Node: OO/Closures,  Next: OS2/Attrib,  Prev: OLE/Storage_Lite,  Up: Module List

Object Oriented Programming using Closures.
*******************************************

NAME
====

   OO::Closures - Object Oriented Programming using Closures.

SYNOPSIS
========

     use OO::Closures;

     sub new {
         my (%methods, %ISA, $self);
         $self = create_object (\%methods, \%ISA, !@_);

     ...

     $self;
         }

DESCRIPTION
===========

   This package gives you a way to use Object Oriented programming using
Closures, including multiple inheritance, `SUPER::' and AUTOLOADing.

   To create the object, call the function `create_object' with three
arguments, a reference to a hash containing the methods of the object, a
reference to a hash containing the inherited objects, and a flag
determining whether the just created object is the base object or not.
This latter flag is important when it comes to trying AUTOLOAD after not
finding a method.

   `create_object' returns a closure which will act as the new object.

   Here is an example of the usage:

     use OO::Closures;
     sub dice {
         my (%methods, %ISA, $self);
         $self = create_object (\%methods, \%ISA, !@_);

     my $faces = 6;

     $methods {set}  = sub {$faces = shift;};
     $methods {roll} = sub {1 + int rand $faces};

     $self;
         }

   It is a simple object representing a die, with 2 methods, set, to set
the number of faces, and `roll', to roll the die. It does not inherit
anything. To make a roll on a 10 sided die, use:

     (my $die = dice) -> (set => 10);
     print $die -> ('roll');

   Note that since the objects are closures, method names are the first
arguments of the calls.

OBJECT VARIABLES
================

   One can make object variables available to the outside world as well.
Just like in Eiffel, for an outsider this will be indistinguishable from
accessing a argumentless method. (However, in a Perlish fashion, we will
actually allow arguments in the call). To do so, instead of putting a code
reference in the %methods hash, put a reference to a scalar in the hash.
Note that to the outside world, no more than read only access to the
variable is given.

   Here is an example:

     sub dice {
         my (%methods, %ISA, $self);
         $self = create_object (\%methods, \%ISA, !@_);

     my $faces = 6;

     $methods {set}   = sub {$faces = shift;};
     $methods {roll}  = sub {1 + int rand $faces};

     $methods {faces} = \$faces;

     $self;
         }

     (my $die = dice) -> (set => 10);
     print $die -> ('faces');

   This will print 10.

INHERITANCE
===========

   To use inheritance, we need to set the `%ISA' hash. We also need to
pass ourselves to the classes we inherited, so an inherited class can find
the base object. (This is similar to the first argument of the constructor
when using regular objects).

   Here is an example that implements multi dice, by subclassing dice.  We
will also give dice a method `print_faces' that prints the number of faces
and returns the object.

     use OO::Closures;

     sub dice {
         my (%methods, %ISA, $self);
         $self = create_object (\%methods, \%ISA, !@_);
         my $this_object = shift || $self;

     my $faces = 6;

     $methods {set}         = sub {$faces = shift};
     $methods {roll}        = sub {1 + int rand $faces};
     $methods {print_faces} = sub {print "Faces: $faces\n"; $this_object};

     $self;
         }

     sub multi_dice {
         my (%methods, %ISA, $self);
         $self = create_object (\%methods, \%ISA, !@_);
         my $this_object = shift || $self;

     %ISA  = (dice => dice $this_object);

     my $amount = 1;

     $methods {amount} = sub {$amount = shift};
     $methods {roll}   = sub {
         my $sum = 0;
         foreach (1 .. $amount) {$sum += $self -> ('dice::roll')}
         $sum;
     };

     $self;
         }

     my $die = multi_dice;
     $die -> (set    => 7);
     $die -> (amount => 4);
     print $die -> ('print_faces') -> ('roll'), "\n";
     __END__

   Notice the line `my $this_object = shift || $self;'. That will make
`$this_object' contain the base object, unlike `$self' which is the
instance of the current class.

   The class dice is subclassed in `multi_dice' by calling dice with an
extra argument, the base object. Now it's known that dice is subclassed,
and looking for AUTOLOAD if it cannot find the requested method should not
happen; that will be triggered by the base object.

   Inherited classes are named, but they are named by the inheriter, not
the inheritee. This allows you to inherit the same class multiple times,
and getting separate data and method space for it.

   When searching for methods in the inheritance tree, no order will be
garanteed. If you subclass multiple classes defining the methods with the
same name, it's better to mask those methods and explicitely redirect the
call to the class you want it to handle.

   You can call a method by prepending its class name(s); just like
regular objects.

   Inherited classes are stored in the `%ISA' hash, but since this variable
is private to the object, each object can have its own inheritance
structure. If you change a class, existing objects of the class will not
be modified.

   The pseudo class 'SUPER::' works the same way as regular objects do,
except that it works the right way. It will resolve 'SUPER::' depending on
the inherited classes of the object the method is called in; not on the
`@ISA' of the package the call is made from.

`use OO::Closures;'
===================

   By default, the module `OO::Closures' exports the function
`create_object'.  If you want this function to be known by another name,
give that name as an argument to the use statement.

     use OO::Closure 'other_name';

   Now you create objects with `other_name (\%methods, \%ISA, !@_);'

BUGS
====

   This documentation uses the word 'class' in cases where it's not really
a class in the sense of the usual object oriented way. Mark-Jason Dominus
calls this *class-less* object orientism.

HISTORY
=======

     $Log: Closures.pm,v $
     Revision 1.2  1999/08/02 06:06:04  abigail
     Bug fixes and more efficient use of code (Rick Delaney).
     Free and open software copyright/license.
     Scalar references as methods (to complement for Eiffel like features).
     CPAN friendly module.

     Revision 1.1  1998/10/01 22:54:57  abigail
     Initial revision

AUTHOR
======

   This package was written by Abigail, *abigail@delanet.com*.

COPYRIGHT and LICENSE
=====================

   This code is copyright 1998, 1999 by Abigail.

   This code is free and open software. You may use, copy, modify,
distribute, and sell this program (and any modified variants) in any way
you wish, provided you do not restrict others from doing the same.


File: pm.info,  Node: OS2/Attrib,  Next: OS2/Focus,  Prev: OO/Closures,  Up: Module List

Get or set OS/2 file attributes
*******************************

NAME
====

   OS2::Attrib - Get or set OS/2 file attributes

SYNOPSIS
========

     use OS2::Attrib qw(get_attribs set_attribs);
     $attribs = get_attribs($path);
     set_attribs($attribs, $path1, $path2, ...);

DESCRIPTION
===========

   OS2::Attrib provides access to OS/2 file attributes.  While the
read-only attribute can be handled by chmod and stat, the hidden, system,
and archive attributes cannot.

$attribs = get_attribs($path)
     Returns the attributes of $path, or the empty string if $path does
     not exist.  Attributes are returned as a five-character string in
     this format: "RHSAD".  Each letter is replaced by an underscore (_)
     if the file does not have the corresponding attribute.  (This is the
     same format as a 4OS2 directory listing.)  The attributes are:

          R  The file is read-only (not writable)
          H  The file is hidden (does not appear in directory listings)
          S  The file is a system file (does not appear in directory listings)
          A  The file needs to be archived (it has changed since last backup)
          D  The file is a directory

$count = set_attribs($attribs, $path1, [$path2, ...])
     Sets the attributes of `$path1', `$path2', etc.  You can either
     specify the complete set of attributes, or add and subtract attributes
     by using + and -.  The case and order of the attributes is not
     important.  For example, '-s+ra' will remove the system attribute and
     add the read-only and archive attributes.  You should not use
     whitespace between attributes, although underscores are OK.  See
     `get_attribs' for an explanation of the attribute values.  You cannot
     change the directory attribute; if you specify it, it is ignored.
     Returns the number of files successfully changed.

LICENSE
=======

   This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See either the GNU General Public
License or the Artistic License for more details.

AUTHOR
======

   Christopher J. Madsen <`ac608@yfn.ysu.edu'>

SEE ALSO
========

   The `OS2::ExtAttr' in this node module provides access to extended
attributes.


