This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: IPC/Run/IO,  Next: IPC/Run/Timer,  Prev: IPC/Run,  Up: Module List

I/O channels for IPC::Run.
**************************

NAME
====

     IPC::Run::IO -- I/O channels for IPC::Run.

SYNOPSIS
========

     use IPC::Run qw( io ) ;

     ## The sense of '>' and '<' is opposite of perl's open(),
     ## but agrees with IPC::Run.
     $io = io( "filename", '>',  \$recv ) ;
     $io = io( "filename", 'r',  \$recv ) ;

     ## Append to $recv:
     $io = io( "filename", '>>', \$recv ) ;
     $io = io( "filename", 'ra', \$recv ) ;

     $io = io( "filename", '<',  \$send ) ;
     $io = io( "filename", 'w',  \$send ) ;

     $io = io( "filename", '<<', \$send ) ;
     $io = io( "filename", 'wa', \$send ) ;

     ## Handles / IO objects that the caller opens:
     $io = io( \*HANDLE,   '<',  \$send ) ;

     $f = IO::Handle->new( ... ) ; # Any subclass of IO::Handle
     $io = io( $f, '<', \$send ) ;

     require IPC::Run::IO ;
     $io = IPC::Run::IO->new( ... ) ;

     ## Then run(), harness(), or start():
     run $io, ... ;

     ## You can, of course, use io() or IPC::Run::IO->new() as an
     ## argument to run(), harness, or start():
     run io( ... ) ;

DESCRIPTION
===========

   This class and module allows filehandles and filenames to be harnessed
for I/O when used IPC::Run, independant of anything else IPC::Run is doing
(except that errors & exceptions can affect all things that IPC::Run is
doing).

SUBCLASSING
===========

   This class uses the fields pragma, so you need to be aware of the
contraints and strengths that this confers upon subclasses.  See the *Note
Base: base, and *Note Fields: fields, pragmas for more information.

TODO
====

   Implement bidirectionality.

AUTHOR
======

   Barrie Slaymaker <barries@slaysys.com>

filename
     Gets/sets the filename.  Returns the value after the name change, if
     any.

init
     Does initialization required before this can be run.  This includes
     open()ing the file, if necessary, and clearing the destination scalar
     if necessary.

open
     If a filename was passed in, opens it.  Determines if the handle is
     open via fileno().  Throws an exception on error.

close
     Closes the handle.  Throws an exception on failure.

fileno
     Returns the fileno of the handle.  Throws an exception on failure.

mode
     Returns the operator in terms of 'r', 'w', and 'a'.  There is a state
     'ra', unlike Perl's open(), which indicates that data read from the
     handle or file will be appended to the output if the output is a
     scalar.  This is only meaningful if the output is a scalar, it has no
     effect if the output is a subroutine.

     The redirection operators can be a little confusing, so here's a
     reference table:

          >      r      Read from handle in to process
          <      w      Write from process out to handle
          >>     ra     Read from handle in to process, appending it to existing
                        data if the destination is a scalar.
          <<     wa     Write from process out to handle, appending to existing
                        data if IPC::Run::IO opened a named file.

op
     Returns the operation: '<', '>', '<<', '>>'.  See `' in this node if
     you want to spell these 'r', 'w', etc.


File: pm.info,  Node: IPC/Run/Timer,  Next: IPC/Semaphore,  Prev: IPC/Run/IO,  Up: Module List

Timer channels for IPC::Run.
****************************

NAME
====

     IPC::Run::Timer -- Timer channels for IPC::Run.

SYNOPSIS
========

     use IPC::Run qw( run  timer timeout ) ;
     ## or IPC::Run::Timer ( timer timeout ) ;
     ## or IPC::Run::Timer ( :all ) ;

     ## A non-fatal timer:
     $t = timer( 5 ) ; # or...
     $t = IO::Run::Timer->new( 5 ) ;
     run $t, ... ;

     ## A timeout (which is a timer that dies on expiry):
     $t = timeout( 5 ) ; # or...
     $t = IO::Run::Timer->new( 5, exception => "harness timed out" ) ;

DESCRIPTION
===========

   This class and module allows timers and timeouts to be created for use
by IPC::Run.  A timer simply expires when it's time is up.  A timeout is a
timer that throws an exception when it expires.

   Timeouts are usually a bit simpler to use  than timers: they throw an
exception on expiration so you don't need to check them:

     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timeout( 10 ) ;
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     ) ;
     pump $h until $out =~ /prompt/ ;

     $in = "some stimulus" ;
     $out = '' ;
     $t->time( 5 )
     pump $h until $out =~ /expected response/ ;

   You do need to check timers:

     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timer( 10 ) ;
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     ) ;
     pump $h until $t->is_expired || $out =~ /prompt/ ;

     $in = "some stimulus" ;
     $out = '' ;
     $t->time( 5 )
     pump $h until $out =~ /expected response/ || $t->is_expired ;

   Timers and timeouts that are reset get started by start() and pump().
Timers change state only in pump().  Since run() and finish() both call
pump(), they act like pump() with repect to timers.

   Timers and timeouts have three states: reset, running, and expired.
Setting the timeout value resets the timer, as does calling the reset()
method.  The start() method starts (or restarts) a timer with the most
recently set time value, no matter what state it's in.

Time values
-----------

   All time values are in seconds.  Times may be specified as integer or
floating point seconds, optionally preceded by puncuation-separated days,
hours, and minutes.\

   Examples:

     1           1 second
     1.1         1.1 seconds
     60          60 seconds
     1:0         1 minute
     1:1         1 minute, 1 second
     1:90        2 minutes, 30 seconds
     1:2:3:4.5   1 day, 2 hours, 3 minutes, 4.5 seconds

   Absolute date/time strings are *not* accepted: year, month and
day-of-month parsing is not available (patches welcome :-).

Interval fudging
----------------

   When calculating an end time from a start time and an interval,
IPC::Run::Timer instances add a little fudge factor.  This is to ensure
that no time will expire before the interval is up.

   First a little background.  Time is sampled in discrete increments.
We'll call the exact moment that the reported time increments from one
interval to the next a tick, and the interval between ticks as the time
period.  Here's a diagram of three ticks and the periods between them:

     -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
     ^                   ^                   ^
     |<--- period 0 ---->|<--- period 1 ---->|
     |                   |                   |
       tick 0              tick 1              tick 2

   To see why the fudge factor is necessary, consider what would happen
when a timer with an interval of 1 second is started right at the end of
period 0:

     -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
     ^                ^  ^                   ^
     |                |  |                   |
     |                |  |                   |
       tick 0             |tick 1              tick 2
                      |
                  start $t

   Assuming that check() is called many times per period, then the timer
is likely to expire just after tick 1, since the time reported will have
lept from the value '0' to the value '1':

     -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
     ^                ^  ^   ^               ^
     |                |  |   |               |
     |                |  |   |               |
       tick 0             |tick 1|             tick 2
                      |      |
                  start $t   |
     		            |
     			check $t

   Adding a fudge of '1' in this example means that the timer is guaranteed
not to expire before tick 2.

   The fudge is not added to an interval of '0'.

   This means that intervals guarantee a minimum interval.  Given that the
process running perl may be suspended for some period of time, or that it
gets busy doing something time-consuming, there are no other guarantees on
how long it will take a timer to expire.

SUBCLASSING
===========

   This class uses the fields pragma, so you need to be aware of the
contraints and strengths that this confers upon subclasses.  See the *Note
Base: base, and *Note Fields: fields, pragmas for more information.

FUNCTIONS & METHODS
===================

timer
     A constructor function (not method) of IPC::Run::Timer instances:

          $t = timer( 5 ) ;
          $t = timer( 5, name => 'stall timer', debug => 1 ) ;

          $t = timer ;
          $t->interval( 5 ) ;

          run ..., $t ;
          run ..., $t = timer( 5 ) ;

     This convenience function is a shortened spelling of

          IPC::Run::Timer->new( ... ) ;
          
          .  It returns a timer in the reset state with a given interval.

     If an exception is provided, it will be thrown when the timer notices
     that it has expired (in check()).  The name is for debugging usage,
     if you plan on having multiple timers around.  If no name is
     provided, an name like "timer #1" will be provided.

timeout
     A constructor function (not method) of IPC::Run::Timer instances:

          $t = timeout( 5 ) ;
          $t = timeout( 5, exception => "kablooey" ) ;
          $t = timeout( 5, name => "stall", exception => "kablooey" ) ;

          $t = timeout ;
          $t->interval( 5 ) ;

          run ..., $t ;
          run ..., $t = timeout( 5 ) ;

     A This convenience function is a shortened spelling of

          IPC::Run::Timer->new( exception => "IPC::Run: timeout ...", ... ) ;
          
          .  It returns a timer in the reset state that will throw an
          exception when it expires.

     Takes the same parameters as `' in this node, any exception passed in
     overrides the default exception.

new
          IPC::Run::Timer->new()   ;
          IPC::Run::Timer->new( 5 )   ;
          IPC::Run::Timer->new( 5, exception => 'kablooey' )   ;

     Constructor.  See `' in this node for details.

check
          check $t ;
          check $t, $now ;
          $t->check ;

     Checks to see if a timer has expired since the last check.  Has no
     effect on non-running timers.  This will throw an exception if one is
     defined.

     IPC::Run::pump() calls this routine for any timers in the harness.

     You may pass in a version of now, which is useful in case you have it
     lying around or you want to check several timers with a consistent
     concept of the current time.

     Returns the time left before end_time or 0 if end_time is no longer
     in the future or the timer is not running (unless, of course, check()
     expire()s the timer and this results in an exception being thrown).

     Returns undef if the timer is not running on entry, 0 if check()
     expires it, and the time left if it's left running.

debug
     Sets/gets the current setting of the debugging flag for this timer.
     This has no effect if debugging is not enabled for the current
     harness.

end_time
          $et = $t->end_time ;
          $et = end_time $t ;

          $t->end_time( time + 10 ) ;

     Returns the time when this timer will or did expire.  Even if this
     time is in the past, the timer may not be expired, since check() may
     not have been called yet.

     Note that this end_time is not start_time($t) + interval($t), since
     some small extra amount of time is added to make sure that the timer
     does not expire before interval() elapses.  If this were not so, then

     Changing end_time() while a timer is running will set the expiration
     time.  Changing it while it is expired has no affect, since
     reset()ing a timer always clears the end_time().

exception
          $x = $t->exception ;
          $t->exception( $x ) ;
          $t->exception( undef ) ;

     Sets/gets the exception to throw, if any.  'undef' means that no
     exception will be thrown.  Exception does not need to be a scalar: you
     may ask that references be thrown.

interval
          $i = interval $t ;
          $i = $t->interval ;
          $t->interval( $i ) ;

     Sets the interval.  Sets the end time based on the start_time() and
     the interval (and a little fudge) if the timer is running.

expire
          expire $t ;
          $t->expire ;

     Sets the state to expired (undef).  Will throw an exception if one is
     defined and the timer was not already expired.  You can expire a
     reset timer without starting it.

is_running
is_reset
is_expired
name
     Sets/gets this timer's name.  The name is only used for debugging
     purposes so you can tell which freakin' timer is doing what.

reset
          reset $t ;
          $t->reset ;

     Resets the timer to the non-running, non-expired state and clears the
     end_time().

start
          start $t ;
          $t->start ;
          start $t, $interval ;
          start $t, $interval, $now ;

     Starts or restarts a timer.  This always sets the start_time.  It
     sets the end_time based on the interval if the timer is running or if
     no end time has been set.

     You may pass an optional interval or current time value.

     Not passing a defined interval causes the previous interval setting
     to be re-used unless the timer is reset and an end_time has been set
     (an exception is thrown if no interval has been set).

     Not passing a defined current time value causes the current time to
     be used.

     Passing a current time value is useful if you happen to have a time
     value lying around or if you want to make sure that several timers
     are started with the same concept of start time.  You might even need
     to lie to an IPC::Run::Timer, occasionally.

start_time
     Sets/gets the start time, in seconds since the epoch.  Setting this
     manually is a bad idea, it's better to call `' in this node() at the
     correct time.

state
          $s = state $t ;
          $t->state( $s ) ;

     Get/Set the current state.  Only use this if you really need to
     transfer the state to/from some variable.  Use `' in this node, `' in
     this node, `' in this node, `' in this node, `' in this node, `' in
     this node.

     Note:  Setting the state to 'undef' to expire a timer will not throw
     an exception.

TODO
====

   use Time::HiRes ; if it's present.

   Add detection and parsing of [[[HH:]MM:]SS formatted times and
intervals.

AUTHOR
======

   Barrie Slaymaker <barries@slaysys.com>


File: pm.info,  Node: IPC/Semaphore,  Next: IPC/Session,  Prev: IPC/Run/Timer,  Up: Module List

SysV Semaphore IPC object class
*******************************

NAME
====

   IPC::Semaphore - SysV Semaphore IPC object class

SYNOPSIS
========

     use IPC::SysV qw(IPC_PRIVATE S_IRWXU IPC_CREAT);
     use IPC::Semaphore;
     
     $sem = new IPC::Semaphore(IPC_PRIVATE, 10, S_IRWXU | IPC_CREAT);
     
     $sem->setall( (0) x 10);
     
     @sem = $sem->getall;
     
     $ncnt = $sem->getncnt;
     
     $zcnt = $sem->getzcnt;
     
     $ds = $sem->stat;
     
     $sem->remove;

DESCRIPTION
===========

METHODS
=======

new ( KEY , NSEMS , FLAGS )
     Create a new semaphore set associated with KEY. `NSEMS' is the number
     of semaphores in the set. A new set is created if

        * KEY is equal to `IPC_PRIVATE'

        * KEY does not already  have  a  semaphore  identifier associated
          with it, and `*FLAGS* & IPC_CREAT' is true.

     On creation of a new semaphore set FLAGS is used to set the
     permissions.

getall
     Returns the values of the semaphore set as an array.

getncnt ( SEM )
     Returns the number of processed waiting for the semaphore `SEM' to
     become greater than it's current value

getpid ( SEM )
     Returns the process id of the last process that performed an operation
     on the semaphore `SEM'.

getval ( SEM )
     Returns the current value of the semaphore `SEM'.

getzcnt ( SEM )
     Returns the number of processed waiting for the semaphore `SEM' to
     become zero.

id
     Returns the system identifier for the semaphore set.

op ( OPLIST )
     OPLIST is a list of operations to pass to semop. OPLIST is a
     concatenation of smaller lists, each which has three values. The
     first is the semaphore number, the second is the operation and the
     last is a flags value. See `semop' in this node for more details. For
     example

          $sem->op(
          	0, -1, IPC_NOWAIT,
          	1,  1, IPC_NOWAIT
          );

remove
     Remove and destroy the semaphore set from the system.

set ( STAT )
set ( NAME => VALUE [, NAME => VALUE ...] )
     set will set the following values of the stat structure associated
     with the semaphore set.

          uid
          gid
          mode (oly the permission bits)

     set accepts either a stat object, as returned by the stat method, or
     a list of name-value pairs.

setall ( VALUES )
     Sets all values in the semaphore set to those given on the `VALUES'
     list.  `VALUES' must contain the correct number of values.

setval ( N , VALUE )
     Set the Nth value in the semaphore set to VALUE

stat
     Returns an object of type `IPC::Semaphore::stat' which is a sub-class
     of Class::Struct. It provides the following fields. For a description
     of these fields see you system documentation.

          uid
          gid
          cuid
          cgid
          mode
          ctime
          otime
          nsems

SEE ALSO
========

   *Note IPC/SysV: IPC/SysV, *Note Class/Struct: Class/Struct, `semget' in
this node `semctl' in this node `semop' in this node

AUTHOR
======

   Graham Barr <gbarr@pobox.com>

COPYRIGHT
=========

   Copyright (c) 1997 Graham Barr. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: IPC/Session,  Next: IPC/ShareLite,  Prev: IPC/Semaphore,  Up: Module List

Drive interactive shell command sessions, local or remote (like 'expect')
*************************************************************************

NAME
====

   IPC::Session - Drive interactive shell command sessions, local or
remote (like 'expect')

SYNOPSIS
========

     use IPC::Session;

     # open ssh session to fred
     # -- set timeout of 30 seconds for all send() calls
     my $session = new IPC::Session("ssh fred",30);
     
     $session->send("hostname");  # run `hostname` command on fred
     print $session->stdout();  # prints "fred"
     $session->send("date");  # run `date` within same ssh
     print $session->stdout();  # prints date
     
     # use like 'expect':
     $session->send("uname -s");
     for ($session->stdout)
     {
     	/IRIX/ && do { $netstat = "/usr/etc/netstat" };
     	/ConvexOS/ && do { $netstat = "/usr/ucb/netstat" };
     	/Linux/ && do { $netstat = "/bin/netstat" };
     }
     
     # errno returned in scalar context:
     $errno = $session->send("$netstat -rn");
     # try this:
     $session->send("grep '^$user:' /etc/passwd")
     	 && warn "$user not there";
     
     # hash returned in array context:
     %netstat = $session->send("$netstat -in");
     print "$netstat{'stdout'}\n";  # prints interface table
     print "$netstat{'stderr'}\n";  # prints nothing (hopefully)
     print "$netstat{'errno'}\n";   # prints 0

DESCRIPTION
===========

   This module encapsulates the open3() function call (see *Note
IPC/Open3: IPC/Open3,) and its associated filehandles.  This makes it easy
to maintain multiple interactive command sessions, such as multiple
persistent 'ssh' and/or 'rsh' sessions, within the same perl script.

   The remote shell session is kept open for the life of the object; this
avoids the overhead of repeatedly opening remote shells via multiple ssh
or rsh calls.  This persistence is particularly useful if you are using
ssh for your remote shell invocation; it helps you overcome the high ssh
startup time.

   For applications requiring remote command invocation, this module
provides functionality that is similar to 'expect' or Expect.pm, but in a
lightweight more Perlish package, with discrete STDOUT, STDERR, and return
code processing.

   BTW, There's nothing inherently ssh-ish about IPC::Session - it doesn't
even know anything about ssh, as a matter of fact.  It will work with any
interactive shell that supports 'echo'.  For instance, 'make test' just
drives a local /bin/sh session.

METHODS
=======

my $session = new IPC::Session("ssh fred",30);
----------------------------------------------

   The constructor accepts the command string to be used to open the remote
shell session, such as ssh or rsh; it also accepts an optional timeout
value, in seconds.  It returns a reference to the unique session object.

   If the timeout is not specified then it defaults to 60 seconds.  The
timeout value can also be changed later; see `"timeout()"' in this node.

$commandhandle = $session->send("hostname");
--------------------------------------------

   The send() method accepts a command string to be executed on the remote
host.  The command will be executed in the context of the default shell of
the remote user (unless you start a different shell by sending the
appropriate command...).  All shell escapes, command line terminators,
pipes, redirectors, etc. are legal and should work, though you of course
will have to escape special characters that have meaning to Perl.

   In a scalar context, this method returns the return code produced by the
command string.

   In an array context, this method returns a hash containing the return
code as well as the full text of the command string's output from the
STDOUT and STDERR file handles.  The hash keys are 'stdout', 'stderr', and
'errno'.

print $session->stdout();
-------------------------

   Returns the full STDOUT text generated from the last send() command
string.

   Also available via array context return codes - see `"send()"' in this
node.

print $session->stderr();
-------------------------

   Returns the full STDERR text generated from the last send() command
string.

   Also available via array context return codes - see `"send()"' in this
node.

print $session->errno();
------------------------

   Returns the return code generated from the last send() command string.

   Also available via array context return codes - see `"send()"' in this
node.

$session->timeout(90);
----------------------

   Allows you to change the timeout for subsequent send() calls.

   The timeout value is in seconds.  Fractional seconds are allowed.  The
timeout applies to all send() calls.

   Returns the current timeout.  Can be called with no args.

BUGS/RESTRICTIONS
=================

   * The remote shell command you specify in new() is assumed to not prompt
     for any passwords or present any challenge codes; i.e.; you must use
     .rhosts, authorized_keys, ssh-agent, or the equivalent.  This
     restriction may be removed in future versions of this module, but
     it's there now.

   * There must be a working /bin/sh on the target machine.

AUTHOR
======

     Steve Traugott <stevegt@TerraLuna.Org>

SEE ALSO
========

   *Note IPC/Open3: IPC/Open3,, `rsh(1)' in this node, `ssh(1)' in this
node, *Note Expect: Expect,, `expect(1)' in this node


File: pm.info,  Node: IPC/ShareLite,  Next: IPC/Shareable,  Prev: IPC/Session,  Up: Module List

Light-weight interface to shared memory
***************************************

NAME
====

   IPC::ShareLite - Light-weight interface to shared memory

SYNOPSIS
========

     use IPC::ShareLite;

     $share = new IPC::ShareLite( -key     => 1971,
                                  -create  => 'yes',
                                  -destroy => 'no' ) or die $!;

     $share->store("This is stored in shared memory");
     $str = $share->fetch;

DESCRIPTION
===========

   IPC::ShareLite provides a simple interface to shared memory, allowing
data to be efficiently communicated between processes.  Your operating
system must support SysV IPC (shared memory and semaphores) in order to
use this module.

   IPC::ShareLite provides an abstraction of the shared memory and
semaphore facilities of SysV IPC, allowing the storage of arbitrarily
large data; the module automatically acquires and removes shared memory
segments as needed.  Storage and retrieval of data is atomic, and locking
functions are provided for higher-level synchronization.

   In many respects, this module is similar to IPC::Shareable.  However,
IPC::ShareLite does not provide a tied interface, does not (automatically)
allow the storage of variables, and is written in C for additional speed.

   Construct an IPC::ShareLite object by calling its constructor:

     $share = new IPC::ShareLite( -key     => 1971,
                                          -create  => 'yes',
                                          -destroy => 'no' ) or die $!;

   Once an instance has been created, data can be written to shared memory
by calling the store() method:

     $share->store("This is going in shared memory");

   Retrieve the data by calling the fetch() method:

     $str = $share->fetch();

   The store() and fetch() methods are atomic; any processes attempting to
read or write to the memory are blocked until these calls finish.
However, in certain situations, you'll want to perform multiple operations
atomically.  Advisory locking methods are available for this purpose.

   An exclusive lock is obtained by calling the lock() method:

     $share->lock();

   Happily, the lock() method also accepts all of the flags recognized by
the flock() system call.  So, for example, you can obtain a shared lock
like this:

     $share->lock( LOCK_SH );

   Or, you can make either type of lock non-blocking:

     $share->lock( LOCK_EX|LOCK_NB );

   Release the lock by calling the unlock() method:

     $share->unlock;

METHODS
=======

new($key, $create, $destroy, $exclusive, $mode, $flags, $size)
     This is the constructor for IPC::ShareLite.  It accepts both the
     positional and named parameter calling styles.

     $key is an integer value used to associate data between processes.
     All processes wishing to communicate should use the same $key value.
     $key may also be specified as a four character string, in which case
     it will be converted to an integer value automatically.  If $key is
     undefined, the shared memory will not be accessible from other
     processes.

     $create specifies whether the shared memory segment should be created
     if it does not already exist.  Acceptable values are 1, 'yes', 0, or
     'no'.

     $destroy indicates whether the shared memory segments and semaphores
     should be removed from the system once the object is destroyed.
     Acceptable values are 1, 'yes', 0, or 'no'.

     If $exclusive is true, instantiation will fail if the shared memory
     segment already exists.  Acceptable values are 1, 'yes', 0, or 'no'.

     $mode specifies the permissions for the shared memory and semaphores.
     The default value is 0666.

     $flags specifies the exact shared memory and semaphore flags to use.
     The constants IPC_CREAT, IPC_EXCL, and IPC_PRIVATE are available for
     import.

     $size specifies the shared memory segment size, in bytes.  The
     default size is 65,536 bytes, which is fairly portable.  Linux, as an
     example, supports segment sizes of 4 megabytes.

     The constructor returns the undefined value on error.

store( $scalar )
     This method stores $scalar into shared memory.  $scalar may be
     arbitrarily long.  Shared memory segments are acquired and released
     automatically as the data length changes.  The only limits on the
     amount of data are the system-wide limits on shared memory pages
     (SHMALL) and segments (SHMMNI) as compiled into the kernel.

     Note that unlike IPC::Shareable, this module does not automatically
     allow variables to be stored.  Serializing all data is expensive, and
     is not always necessary.  If you need to store a variable, you should
     employ the Storable module yourself.  For example:

          use Storable qw( freeze thaw );
          ...
          	$hash = { red => 1, white => 1, blue => 1 };
          $share->store( freeze( $hash ) );
          ...
          $hash = thaw( $share->fetch );

     The method raises an exception on error.

fetch()
     This method returns the data that was previously stored in shared
     memory.  The empty string is returned if no data was previously
     stored.

     The method raises an exception on error.

lock( $type )
     Obtains a lock on the shared memory.  $type specifies the type of
     lock to acquire.  If $type is not specified, an exclusive read/write
     lock is obtained.  Acceptable values for $type are the same as for
     the flock() system call.  The method returns true on success, and
     undef on error.  For non-blocking calls (see below), the method
     returns 0 if it would have blocked.

     Obtain an exclusive lock like this:

     	$share->lock( LOCK_EX ); # same as default

     Only one process can hold an exclusive lock on the shared memory at a
     given time.

     Obtain a shared lock this this:

          $share->lock( LOCK_SH );

     Multiple processes can hold a shared lock at a given time.  If a
     process attempts to obtain an exclusive lock while one or more
     processes hold shared locks, it will be blocked until they have all
     finished.

     Either of the locks may be specified as non-blocking:

          $share->lock( LOCK_EX|LOCK_NB );
                  $share->lock( LOCK_SH|LOCK_NB );
          
          A non-blocking lock request will return 0 if it would have had to
          wait to obtain the lock.

     Note that these locks are advisory (just like flock), meaning that
     all cooperating processes must coordinate their accesses to shared
     memory using these calls in order for locking to work.  See the
     flock() call for details.

     Locks are inherited through forks, which means that two processes
     actually can possess an exclusive lock at the same time.  Don't do
     that.

     The constants LOCK_EX, LOCK_SH, LOCK_NB, and LOCK_UN are available
     for import:

          use IPC::ShareLite qw( :lock );

     Or, just use the flock constants available in the Fcntl module.

unlock()
     Releases any locks.  This is actually equivalent to:

          $share->lock( LOCK_UN );

     The method returns true on success and undef on error.

PERFORMANCE
===========

   For a rough idea of the performance you can expect, here are some
benchmarks.  The tests were performed using the Benchmark module on a
Cyrix PR166+ running RedHat Linux 5.2 with the 2.0.36 kernel, perl
5.005_02 using perl's malloc, and the default shared memory segment size.
Each test was run 5000 times.

     DATA SIZE (bytes)	TIME (seconds)	Op/Sec

     store	16384			2		2500
     fetch	16384			2		2500

     store	32768			3		1666
     fetch	32768			3		1666

     store	65536			6		833
     fetch	65536			5		1000

     store	131072			12		416
     fetch	131072			12		416

     store	262144			28		178
     fetch  262144			27		185

     store	524288			63		79
     fetch  524288			61		81

   Most of the time appears to be due to memory copying.  Suggestions for
speed improvements are welcome.

PORTABILITY
===========

   The module should compile on any system with SysV IPC and an ANSI C
compiler, and should compile cleanly with the -pedantic and -Wall flags.

   The module has been tested under Solaris, FreeBSD, and Linux.  Testing
on other platforms is needed.

   If you encounter a compilation error due to the definition of the semun
union, edit the top of sharelite.c and undefine the semun definition.  And
then please tell me about it.

   I've heard rumors that a SysV IPC interface has been constructed for
Win32 systems.  Support for it may be added to this module.

   IPC::ShareLite does not understand the shared memory data format used
by IPC::Shareable.

AUTHOR
======

   Copyright (C) 1998, Maurice Aubrey <maurice@hevanet.com>.  All rights
reserved.

   This module is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

CREDITS
=======

   Special thanks to Benjamin Sugars for developing the IPC::Shareable
module.

   See the Changes file for other contributors.

SEE ALSO
========

   *Note IPC/Shareable: IPC/Shareable,, ipc(2), shmget(2), semget(2), perl.


File: pm.info,  Node: IPC/Shareable,  Next: IPC/Shareable/SharedMem,  Prev: IPC/ShareLite,  Up: Module List

share Perl variables between processes
**************************************

NAME
====

   IPC::Shareable - share Perl variables between processes

SYNOPSIS
========

     use IPC::Shareable (':lock');
     tie SCALAR, 'IPC::Shareable', GLUE, OPTIONS;
     tie ARRAY,  'IPC::Shareable', GLUE, OPTIONS;
     tie HASH,   'IPC::Shareable', GLUE, OPTIONS;

     (tied VARIABLE)->shlock;
     (tied VARIABLE)->shunlock;

     (tied VARIABLE)->shlock(LOCK_SH|LOCK_NB)
            or print "resource unavailable\n";

     (tied VARIABLE)->remove;

     IPC::Shareable->clean_up;
     IPC::Shareable->clean_up_all;

CONVENTIONS
===========

   The occurrence of a number in square brackets, as in [N], in the text
of this document refers to a numbered note in the `' in this node.

DESCRIPTION
===========

   IPC::Shareable allows you to tie a variable to shared memory making it
easy to share the contents of that variable with other Perl processes.
Scalars, arrays, and hashes can be tied.  The variable being tied may
contain arbitrarily complex data structures - including references to
arrays, hashes of hashes, etc.

   The association between variables in distinct processes is provided by
GLUE.  This is an integer number or 4 character string[1] that serves as a
common identifier for data across process space.  Hence the statement

     tie $scalar, 'IPC::Shareable', 'data';

   in program one and the statement

     tie $variable, 'IPC::Shareable', 'data';

   in program two will bind $scalar in program one and $variable in
program two.

   There is no pre-set limit to the number of processes that can bind to
data; nor is there a pre-set limit to the complexity of the underlying
data of the tied variables[2].  The amount of data that can be shared
within a single bound variable is limited by the system's maximum size for
a shared memory segment (the exact value is system-dependent).

   The bound data structures are all linearized (using Raphael Manfredi's
Storable module) before being slurped into shared memory.  Upon retrieval,
the original format of the data structure is recovered.  Semaphore flags
can be used for locking data between competing processes.

OPTIONS
=======

   Options are specified by passing a reference to a hash as the fourth
argument to the tie() function that enchants a variable.  Alternatively
you can pass a reference to a hash as the third argument; IPC::Shareable
will then look at the field named key in this hash for the value of GLUE.
So,

     tie $variable, 'IPC::Shareable', 'data', \%options;

   is equivalent to

     tie $variable, 'IPC::Shareable', { key => 'data', ... };

   Boolean option values can be specified using a value that evaluates to
either true or false in the Perl sense.

   NOTE: Earlier versions allowed you to use the word *yes* for true and
the word no for false, but support for this "feature" is being removed.
*yes* will still act as true (since it is true, in the Perl sense), but
use of the word no now emits an (optional) warning and then converts to a
false value.  This warning will become mandatory in a future release and
then at some later date the use of no will stop working altogether.

   The following fields are recognized in the options hash.

key
     The key field is used to determine the GLUE when using the
     three-argument form of the call to tie().  This argument is then, in
     turn, used as the KEY argument in subsequent calls to shmget() and
     semget().

     The default value is IPC_PRIVATE, meaning that your variables cannot
     be shared with other processes.

create
     create is used to control whether calls to tie() create new shared
     memory segments or not.  If create is set to a true value,
     IPC::Shareable will create a new binding associated with GLUE as
     needed.  If create is false, IPC::Shareable will not attempt to
     create a new shared memory segment associated with GLUE.  In this
     case, a shared memory segment associated with GLUE must already exist
     or the call to tie() will fail and return undef.  The default is
     false.

exclusive
     If exclusive field is set to a true value, calls to tie() will fail
     (returning undef) if a data binding associated with GLUE already
     exists.  If set to a false value, calls to tie() will succeed even if
     a shared memory segment associated with GLUE already exists.  The
     default is false

mode
     The mode argument is an octal number specifying the access
     permissions when a new data binding is being created.  These access
     permission are the same as file access permissions in that 0666 is
     world readable, 0600 is readable only by the effective UID of the
     process creating the shared variable, etc.  The default is 0666 (world
     readable and writable).

destroy
     If set to a true value, the shared memory segment underlying the data
     binding will be removed when the process calling tie() exits
     (gracefully)[3].  Use this option with care.  In particular you
     should not use this option in a program that will fork after binding
     the data.  On the other hand, shared memory is a finite resource and
     should be released if it is not needed.  The default is false

size
     This field may be used to specify the size of the shared memory
     segment allocated.  The default is IPC::Shareable::SHM_BUFSIZ().

   Default values for options are

     key       => IPC_PRIVATE,
     create    => 0,
     exclusive => 0,
     destroy   => 0,
     mode      => 0,
     size      => IPC::Shareable::SHM_BUFSIZ(),

LOCKING
=======

   IPC::Shareable provides methods to implement application-level advisory
locking of the shared data structures.  These methods are called shlock()
and shunlock().  To use them you must first get the object underlying the
tied variable, either by saving the return value of the original call to
tie() or by using the built-in tied() function.

   To lock a variable, do this:

     $knot = tie $sv, 'IPC::Shareable', $glue, { %options };
     ...
     $knot->shlock;

   or equivalently

     tie($scalar, 'IPC::Shareable', $glue, { %options });
     (tied $scalar)->shlock;

   This will place an exclusive lock on the data of $scalar.  You can also
get shared locks or attempt to get a lock without blocking.
IPC::Shareable makes the constants LOCK_EX, LOCK_SH, LOCK_UN, and LOCK_NB
exportable to your address space with the export tags `:lock', `:flock',
or :all.  The values should be the same as the standard flock option
arguments.

     if ( (tied $scalar)->shlock(LOCK_SH|LOCK_NB) ) {
            print "The value is $scalar\n";
            (tied $scalar)->shunlock;
     } else {
            print "Another process has an exlusive lock.\n";
     }

   If no argument is provided to `shlock', it defaults to LOCK_EX.  To
unlock a variable do this:

     $knot->shunlock;

   or

     (tied $scalar)->shunlock;

   or

     $knot->shlock(LOCK_UN);        # Same as calling shunlock

   There are some pitfalls regarding locking and signals about which you
should make yourself aware; these are discussed in `' in this node.

   If you use the advisory locking, IPC::Shareable assumes that you know
what you are doing and attempts some optimizations.  When you obtain a
lock, either exclusive or shared, a fetch and thaw of the data is
performed.  No additional fetch/thaw operations are performed until you
release the lock and access the bound variable again.  During the time
that the lock is kept, all accesses are perfomed on the copy in program
memory.  If other processes do not honor the lock, and update the shared
memory region unfairly, the process with the lock will not be in sync.  In
other words, IPC::Shareable does not enforce the lock for you.

   A similar optimization is done if you obtain an exclusive lock.
Updates to the shared memory region will be postponed until you release
the lock (or downgrade to a shared lock).

   Use of locking can significantly improve performance for operations
such as iterating over an array, retrieving a list from a slice or doing a
slice assignment.

REFERENCES
==========

   When a reference to a non-tied scalar, hash, or array is assigned to a
tie()d variable, IPC::Shareable will attempt to tie() the thingy being
referenced[4].  This allows disparate processes to see changes to not only
the top-level variable, but also changes to nested data.  This feature is
intended to be transparent to the application, but there are some caveats
to be aware of.

   First of all, IPC::Shareable does not (yet) guarantee that the ids
shared memory segments allocated automagically are unique.  The more
automagical tie()ing that happens, the greater the chance of a collision.

   Secondly, since a new shared memory segment is created for each thingy
being referenced, the liberal use of references could cause the system to
approach its limit for the total number of shared memory segments allowed.

OBJECTS
=======

   IPC::Shareable implements tie()ing objects to shared memory too.  Since
an object is just a reference, the same principles (and caveats) apply to
tie()ing objects as other reference types.

DESTRUCTION
===========

   perl(1) will destroy the object underlying a tied variable when then
tied variable goes out of scope.  Unfortunately for IPC::Shareable, this
may not be desirable: other processes may still need a handle on the
relevant shared memory segment.  IPC::Shareable therefore provides an
interface to allow the application to control the timing of removal of
shared memory segments.  The interface consists of three methods -
remove(), clean_up(), and clean_up_all() - and the destroy option to tie().

*destroy option*
     As described in `' in this node, specifying the destroy option when
     tie()ing a variable coerces IPC::Shareable to remove the underlying
     shared memory segment when the process calling tie() exits gracefully.
     Note that any related shared memory segments created automagically by
     the use of references will also be removed.

remove()
          (tied $var)->remove;

     Calling remove() on the object underlying a tie()d variable removes
     the associated shared memory segment.  The segment is removed
     irrespective of whether it has the destroy option set or not and
     irrespective of whether the calling process created the segment.

clean_up()
          IPC::Shareable->clean_up;

     This is a class method that provokes IPC::Shareable to remove all
     shared memory segments created by the process.  Segments not created
     by the calling process are not removed.

clean_up_all()
          IPC::Shareable->clean_up_all;

     This is a class method that provokes IPC::Shareable to remove all
     shared memory segments encountered by the process.  Segments are
     removed even if they were not created by the calling process.

EXAMPLES
========

   In a file called server:

     #!/usr/bin/perl -w
     use strict;
     use IPC::Shareable;
     my $glue = 'data';
     my %options = (
         create    => 'yes',
         exclusive => 0,
         mode      => 0644,
         destroy   => 'yes',
     );
     my %colours;
     tie %colours, 'IPC::Shareable', $glue, { %options } or
         die "server: tie failed\n";
     %colours = (
         red => [
             'fire truck',
             'leaves in the fall',
         ],
         blue => [
             'sky',
             'police cars',
         ],
     );
     ((print "server: there are 2 colours\n"), sleep 5)
         while scalar keys %colours == 2;
     print "server: here are all my colours:\n";
     foreach my $c (keys %colours) {
         print "server: these are $c: ",
             join(', ', @{$colours{$c}}), "\n";
     }
     exit;

   In a file called client

     #!/usr/bin/perl -w
     use strict;
     use IPC::Shareable;
     my $glue = 'data';
     my %options = (
         create    => 0,
         exclusive => 0,
         mode      => 0644,
         destroy   => 0,
         );
     my %colours;
     tie %colours, 'IPC::Shareable', $glue, { %options } or
         die "client: tie failed\n";
     foreach my $c (keys %colours) {
         print "client: these are $c: ",
             join(', ', @{$colours{$c}}), "\n";
     }
     delete $colours{'red'};
     exit;

   And here is the output (the sleep commands in the command line prevent
the output from being interrupted by shell prompts):

     bash$ ( ./server & ) ; sleep 10 ; ./client ; sleep 10
     server: there are 2 colours
     server: there are 2 colours
     server: there are 2 colours
     client: these are blue: sky, police cars
     client: these are red: fire truck, leaves in the fall
     server: here are all my colours:
     server: these are blue: sky, police cars

RETURN VALUES
=============

   Calls to tie() that try to implement IPC::Shareable will return true if
successful, undef otherwise.  The value returned is an instance of the
IPC::Shareable class.

AUTHOR
======

   Benjamin Sugars <bsugars@canoe.ca>

NOTES
=====

Footnotes from the above sections
---------------------------------

  1. If GLUE is longer than 4 characters, only the 4 most significant
     characters are used.  These characters are turned into integers by
     unpack()ing them.  If GLUE is less than 4 characters, it is space
     padded.

  2. IPC::Shareable provides no pre-set limits, but the system does.
     Namely, there are limits on the number of shared memory segments that
     can be allocated and the total amount of memory usable by shared
     memory.

  3. If the process has been smoked by an untrapped signal, the binding
     will remain in shared memory.  If you're cautious, you might try

          $SIG{INT} = \&catch_int;
          sub catch_int {
              die;
          }
          ...
          tie $variable, IPC::Shareable, 'data', { 'destroy' => 'Yes!' };

     which will at least clean up after your user hits CTRL-C because
     IPC::Shareable's END method will be called.  Or, maybe you'd like to
     leave the binding in shared memory, so subsequent process can recover
     the data...

  4. This behaviour is markedly different from previous versions of
     IPC::Shareable.  Older versions would sometimes tie() referenced
     thingies, and sometimes not.  The new approach is more reliable (I
     think) and predictable (certainly) but uses more shared memory
     segments.


General Notes
-------------

o
     When using shlock() to lock a variable, be careful to guard against
     signals.  Under normal circumstances, IPC::Shareable's END method
     unlocks any locked variables when the process exits.  However, if an
     untrapped signal is received while a process holds an exclusive lock,
     DESTROY will not be called and the lock may be maintained even though
     the process has exited.  If this scares you, you might be better off
     implementing your own locking methods.

     One advantage of using flock on some known file instead of the
     locking implemented with semaphores in IPC::Shareable is that when a
     process dies, it automatically releases any locks.  This only happens
     with IPC::Shareable if the process dies gracefully.  The alternative
     is to attempt to account for every possible calamitous ending for your
     process (robust signal handling in Perl is a source of much debate,
     though it usually works just fine) or to become familiar with your
     system's tools for removing shared memory and semaphores.  This
     concern should be balanced against the significant performance
     improvements you can gain for larger data structures by using the
     locking mechanism implemented in IPC::Shareable.

o
     There is a program called ipcs(1/8) (and ipcrm(1/8)) that is
     available on at least Solaris and Linux that might be useful for
     cleaning moribund shared memory segments or semaphore sets produced
     by bugs in either IPC::Shareable or applications using it.

o
     This version of IPC::Shareable does not understand the format of
     shared memory segments created by versions prior to 0.60.  If you try
     to tie to such segments, you will get an error.  The only work around
     is to clear the shared memory segments and start with a fresh set.

o
     Iterating over a hash causes a special optimization if you have not
     obtained a lock (it is better to obtain a read (or write) lock before
     iterating over a hash tied to Shareable, but we attempt this
     optimization if you do not).  The fetch/thaw operation is performed
     when the first key is accessed.  Subsequent key and and value
     accesses are done without accessing shared memory.  Doing an
     assignment to the hash or fetching another value between key accesses
     causes the hash to be replaced from shared memory.  The state of the
     iterator in this case is not defined by the Perl documentation.
     Caveat Emptor.

CREDITS
=======

   Thanks to all those with comments or bug fixes, especially

     Maurice Aubrey      <maurice@hevanet.com>
     Stephane Bortzmeyer <bortzmeyer@pasteur.fr>
     Doug MacEachern     <dougm@telebusiness.co.nz>
     Robert Emmery       <roberte@netscape.com>
     Mohammed J. Kabir   <kabir@intevo.com>
     Terry Ewing         <terry@intevo.com>
     Tim Fries           <timf@dicecorp.com>
     Joe Thomas          <jthomas@women.com>
     Paul Makepeace      <Paul.Makepeace@realprogrammers.com>
     Raphael Manfredi    <Raphael_Manfredi@pobox.com>
     Lee Lindley         <Lee.Lindley@bigfoot.com>
     Dave Rolsky         <autarch@urth.org>

BUGS
====

   Certainly; this is beta software. When you discover an anomaly, send an
email to me at bsugars@canoe.ca.

SEE ALSO
========

   perl(1), perltie(1), Storable(3), shmget(2), ipcs(1), ipcrm(1) and
other SysV IPC man pages.


