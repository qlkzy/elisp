This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Paw/Label-de,  Next: Paw/Line,  Prev: Paw/Label,  Up: Module List

Label Widget
============

   *$label=Paw::Label::new($text, [$color], [$name]);*

   *Beispiel*

     $label=Paw::Label::new(text=>"Text", color=>3, name=>"Linux_Label");

   Parameter

     text  => Text des Labels

     color => Das Farbpaar (colorpair) muss mit
              Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
              erzeugt werden[optional]

     name  => Name des Fensters [optional]

set_text($text)
---------------

   Ändert den Text des Labels auf den String in $text.

   *Beispiel*

     $label->set_text("changed label text");

get_text();
-----------

   Gibt den Text des Labels zurueck.

   *Beispiel*

     $text=$label->get_text();

abs_move_widget($new_x, $new_y)
-------------------------------

   the widget moves to the new absolute screen position.  if you set only
one of the two parameters, the other one keeps the old value.

   Example

     $label->abs_move_widget( new_x=>5 );      #y-pos is the same

get_widget_pos()
----------------

   returns an array of two values, the x-position and the y-position of
the widget.

   Example

     ($xpos,$ypos)=$label->get_widget_pos();      #y-pos is the same

set_color($color_pair)
----------------------

   Set a new color_pair for the widget.

   Example

     $label->set_color(3);

abs_move_widget($new_x, $new_y)
-------------------------------

   Das Widget verschiebt sich auf die neue absolute Schirm Position.  Wird
nur einer der Parameter angegeben, so behaelt der andere seinen Wert bei.

   *Beispiel*

     $label->abs_move_widget( new_x=>5 );      #y-pos bleibt wie sie ist

get_widget_pos()
----------------

   returns an array of two values, the x-position and the y-position of
the widget.  Gibt ein Array mit den beiden Wertde (x-Position, y-Position)
zurueck.

   *Beispiel*

     ($xpos,$ypos)=$label->get_widget_pos();

set_color($color_pair)
----------------------

   Setzt ein neues color_pair.

   *Beispiel*

     $label->set_color(3);

set_border(["shade"])
---------------------

   aktiviert den Rahmen der Box. Optional auch mit Schatten.

   *Beispiel*

     $box->set_border("shade"); or $win->set_border();


File: pm.info,  Node: Paw/Line,  Next: Paw/Line-de,  Prev: Paw/Label-de,  Up: Module List

Line Widget
===========

   *$line=Paw::Line-*new($length, [$name], [$char], [$direction])>;

   Parameter

     $name      => name of the widget [optionally]

     $char      => character that will be used to build the line
                   (ACS_HLINE) [optionally]

     $direction => "v"ertically or "h"orizontally (default) [optional]

     $length    => length in characters of the line

   Example

     $l=Paw::Line->new(length=>$columns, char=>"#");

abs_move_widget($new_x, $new_y)
-------------------------------

   the widget moves to the new absolute screen position.  if you set only
one of the two parameters, the other one keeps the old value.

   Example

     $l->abs_move_widget( new_x=>5 );      #y-pos is the same

get_widget_pos()
----------------

   returns an array of two values, the x-position and the y-position of
the widget.

   Example

     ($xpos,$ypos)=$l->get_widget_pos();

set_color($color_pair)
----------------------

   Set a new color_pair for the widget.

   Example

     $box->set_color(3);

set_border(["shade"])
---------------------

   activates the border of the widget (optionally also with shadows).

   Example

     $widget->set_border("shade"); or $widget->set_border();


File: pm.info,  Node: Paw/Line-de,  Next: Paw/Listbox,  Prev: Paw/Line,  Up: Module List

Line Widget
===========

   *$line=Paw::Line::new($length, [$name], [$char], [$direction])*;

   Parameter

     $name      => Name des Widgets [optional]

     $char      => Zeichen aus dem die Linie aufgebaut wird (ACS_HLINE)
                   [optional]

     $direction => Richtung in der die Linie liegen soll "v" bzw. "h"
                   (h = default) [optional]

     $length    => Laenge der Linie

   Example

     $l=Paw::Line::new(length=>$columns, char=>"#");

abs_move_widget($new_x, $new_y)
-------------------------------

   Das Widget verschiebt sich auf die neue absolute Schirm Position.  Wird
nur einer der Parameter angegeben, so behaelt der andere seinen Wert bei.

   *Beispiel*

     $l->abs_move_widget( new_x=>5 );      #y-pos bleibt wie sie ist

get_widget_pos()
----------------

   Gibt ein Array mit den beiden Wertde (x-Position, y-Position) zurueck.

   *Beispiel*

     ($xpos,$ypos)=$l->get_widget_pos();

set_color($color_pair)
----------------------

   Setzt ein neues color_pair.

   *Beispiel*

     $l->set_color(3);

set_border(["shade"])
---------------------

   aktiviert den Rahmen der Box. Optional auch mit Schatten.

   *Beispiel*

     $box->set_border("shade"); or $win->set_border();


File: pm.info,  Node: Paw/Listbox,  Next: Paw/Listbox-de,  Prev: Paw/Line-de,  Up: Module List

Listbox
=======

   *$lb=Paw::Listbox-*new($height, $width, [$colored], [$name]);>

   Parameter

     $height  => Number of rows

     $width   => Number of columns

     $colored => 1 turns on the colored mode
                 (see also "add_row") default=0 [optionally]

     $name    => Name of the widget [optionally]

   Example

     $lb=Paw::Listbox->new(width=>10, height=>15, colored=>1);

clear_listbox()
---------------

   deletes all entrys out of the listbox

   Example

     $listbox->clear_listbox();

add_row($data, $color), add_row(\@data);
----------------------------------------

   adds a data-row into the listbox. When the color mode is activated, you
can give a second parameter as color-pair number.  Alternatively you can
give a refernce to an array to the listbox and it will put gradually each
array element into the box.  If the color mode is on, each second element
of the array must be a color-pair number.

   Example

     $listbox->add_row("Test", 3);

del_row($number)
----------------

   deletes the row with the number "$number". Start counting at zero.

   Example

     $listbox->del_row(4);

change_rows($first, $second);
-----------------------------

   swaps the $first and the $second row of the listbox.

   Example

     $listbox->change_rows($lower, $upper);

number_of_data()
----------------

   returns the number of data-rows in the listbox.

   Example

     $data=$listbox->number_of_data();

get_pushed_rows("data"), get_pushed_rows("linenumbers");
--------------------------------------------------------

   returns an array of all pushed data-rows, either the linenumbers or the
data.

   Example

     @data_rows=$listbox->get_pushed_rows("linenumbers");

get_all_rows();
---------------

   returns an array with the complete contents of the listbox.

   Example

     @full_data=$listbox->get_all_rows();

abs_move_widget($new_x, $new_y)
-------------------------------

   the widget moves to the new absolute screen position.  if you set only
one of the two parameters, the other one keeps the old value.

   Example

     $listbox->abs_move_widget( new_x=>5 );      #y-pos is the same

get_widget_pos()
----------------

   returns an array of two values, the x-position and the y-position of
the widget.

   Example

     ($xpos,$ypos)=$listbox->get_widget_pos();

set_border(["shade"])
---------------------

   activates the border of the widget (optionally also with shadows).

   Example

     $widget->set_border("shade"); or $widget->set_border();


File: pm.info,  Node: Paw/Listbox-de,  Next: Paw/Menu,  Prev: Paw/Listbox,  Up: Module List

Listbox
=======

   *$lb=Paw::Listbox::new($height, $width, [$colored], [$name]);*

   Parameter

     $height  => Anzahl der Reihen

     $width   => Anzahl der Spalten

     $colored => 1 schaltet den Farbmodus ein
                 (siehe Methode add_row) default=0 [optional]

     $name    => Name des Widgets [optional]

   *Beispiel*

     $lb=Paw::Listbox::new(width=>10, height=>15, colored=>1);

clear_listbox()
---------------

   entfernt alle Eintraege aus der Listbox

   *Beispiel*

     $listbox->clear_listbox();

add_row($data, $color), add_row(\@data);
----------------------------------------

   packt eine Zeile in die Listbox. Wenn der Farbmodus aktiv ist, kann
noch ein Farbpaar als weiterer Parameter uebergeben werden.  Wird eine
Referenz auf ein Array uebergeben, so werden nach und nach alle Elemente
des Arrays in die Listbox gepackt.  Ist hier der Colormodus aktiv, so
*muss* jedes zweite Element eine Farbpaar Nummer sein.

   *Beispiel*

     $listbox->add_row("Test", 3);

del_row($number)
----------------

   entfernt die Zeile mit der Nummer $number

   *Beispiel*

     $listbox->del_row(4);

change_rows($first, $second);
-----------------------------

   tauscht die beiden Zeilen in der Listbox

   *Beispiel*

     $listbox->change_rows($lower, $upper);

number_of_data()
----------------

   gibt die Anzahl der Reihen in der Listbox zurueck.

   *Beispiel*

     $data=$listbox->number_of_data();

get_pushed_rows("data"), get_pushed_rows("linenumbers");
--------------------------------------------------------

   gibt ein Array mit allen aktiven Reihen der Listbox zurueck. Entweder
die Zeilennummer(linenumber) oder direkt den Inhalt (data)

   *Beispiel*

     @data_rows=$listbox->get_pushed_rows("linenumbers");

get_all_rows();
---------------

   gibt ein Array mit dem kompletten Inhalt der Listbox zurueck.

   *Beispiel*

     @full_data=$listbox->get_all_rows();

abs_move_widget($new_x, $new_y)
-------------------------------

   Das Widget verschiebt sich auf die neue absolute Schirm Position.  Wird
nur einer der Parameter angegeben, so behaelt der andere seinen Wert bei.

   *Beispiel*

     $listbox->abs_move_widget( new_x=>5 );      #y-pos is the same

get_widget_pos()
----------------

   Gibt ein Array mit den beiden Wertde (x-Position, y-Position) zurueck.

   *Beispiel*

     ($xpos,$ypos)=$listbox->get_widget_pos();

set_border(["shade"])
---------------------

   aktiviert den Rahmen der Box. Optional auch mit Schatten.

   *Beispiel*

     $box->set_border("shade"); or $win->set_border();


File: pm.info,  Node: Paw/Menu,  Next: Paw/Menu-de,  Prev: Paw/Listbox-de,  Up: Module List

Pulldown Menu
=============

   *$pdm=Paw::Paw-*Menu->new($title, [$name], [$border]);>

   Parameter

     $title  => visible title

     $name   => name of the widget [optionally]

     $border => only "shade" as option so far [optionally]

   Example

     $pdm=Paw::Menu->new(title=>"Datei", border=>"shade");

add_menu_point($text, \&callback), add_menu_point($other_menu)
--------------------------------------------------------------

   generates a new menupoint (with name "$text") and branches on the
function "callback", if it is activated.  There is also the possibility to
give just another menu and you will get a Pulldown Menu in the Pulldown
Menu.

   Example

     $men->add_menu_point("Beep", \&menu_beep);

     #Pulldownmenu "$men" in Pulldownmenu "$men2".
     $men2->add_menu_point($men);


File: pm.info,  Node: Paw/Menu-de,  Next: Paw/Paw-de,  Prev: Paw/Menu,  Up: Module List

Pulldown Menu
=============

   *$pdm=Paw::Menu::new($title, [$name], [$border]);*

   Parameter

     $titel  => sichtbarer Titel des Pulldownmenus

     $name   => Name des Widgets [optional]

     $border => bisher nur "shade" als option [optional]

   *Beispiel*

     $pdm=Paw::Menu::new(title=>"Datei", border=>"shade");

add_menu_point($text, \&callback), add_menu_point($other_menu)
--------------------------------------------------------------

   erzeugt einen Menupunkt (Text) und springt die Funktion callback an,
wenn er aktiviert wird.  Es besteht auch die Moeglichkeit nur ein anderes
Menu zu uebergeben. Dadurch entstehen Untermenus.

   *Beispiel*

     $men->add_menu_point("Beep", \&menu_beep);

     #Pulldownmenu "$men" in Pulldownmenu "$men2".
     $men2->add_menu_point($men);


File: pm.info,  Node: Paw/Paw-de,  Next: Paw/Popup,  Prev: Paw/Menu-de,  Up: Module List

Allgemeines
===========

   Neben dieser Dokumentation befinden sich auch noch dokumentierte
Beispiele für einige Widgets im Unterverzeichnis example, sowie ein
komplettes Beispiel für die Oberfläche eines Setup Programms (app2.pl).

Widget handling
---------------

   Ein neues Widget wird immer mit

     $WIDGET_REFERENCE=Paw::WIDGETNAME::new(PARAMETERNAME=>VALUE).

   erzeugt. Dabei müssen die PARAMETER immer als HASH übergeben werden
Diese Regel gilt auch wenn nur ein Parameter übergeben wird. Die
Reihenfolge in der die PARAMETER übergeben werden ist dabei egal.  Die
Methoden eines Widgets werden mit

     $WIDGET_REFERENCE->METHOD(PARAMETER)
     $WIDGET_REFERENCE->METHOD(PARAMETER1=>VALUE1, PARAMETER2=>VALUE2)

   aufgerufen. Wenn einen Methode nur einen oder keinen Parameter erlaubt,
wird auf die Benennung des Parameters verzichtet

     $window->put($widget).

   Sollten mehr als 1 Parameter möglich sein, so muss wieder jeder
Parameter benannt werden, wobei auch hier die Reihenfolge der Parameter
egal ist.

     $window->abs_move_curs(new_x=>5, new_y=>6) #is okay,
     $window->abs_move_curs(5)                  # is not okay
     $window->put_dir("h")                      # is quite permitted.

Initialisierung
---------------

   Jedes Programm, welches dieses Modul einsetzt, beginnt im Grunde gleich
:

     #!/usr/bin/perl
     use Curses;
     use widget;
     ($columns, $rows)=Paw::init_widgetset();

   die Variablen $columns und $rows enthalten die Breite und Höhe des
Terminals und können z.B. verwendet werden, um die Grösse weiterer Fenster
in Abhängigkeit von der Terminalgrösse zu berechnen.

     $main_win=Paw::Window::new(abs_x=>1, abs_y=>1,
                                height=$rows-3, width=>$columns-2,
                                color=>1, statusbar=>1);

Farben
------

   Beim initialisieren des Widgetsets werden einige Color_Pairs bereits
gesetzt.  Dazu gehören:

     init_pair(1, COLOR_WHITE, COLOR_BLUE);   #default colors
     init_pair(31, COLOR_BLACK, COLOR_BLACK); #shadow
     init_pair(30, COLOR_BLACK, COLOR_CYAN);  #pulldown menu
     init_pair(29, COLOR_BLACK, COLOR_BLUE);  #filedialog

   Als Farben stehen black, red, green, yellow, blue, magenta, cyan, und
white zur Verfügung.  Neue color_pairs können mit

     init_pair(pair, foreground_color, background_color);

   erzeugt werden.  Für weitere Informationen zum Farbmodell empfehle ich
die Dokumentation der Curses Lib (man ncurses, bzw. man init_color und
perldoc Curses).

Widgetpacker
------------

   Es gibt zwei Möglichkeiten Widgets in ein Fenster zu bekommen.  Zum
einen kann man direkt die put Funktion des Fensters nehmen, zum anderen
kann man den Umweg über Boxen nehmen.  Zuerst mal ohne Boxen :

     #put the $label2 into the window
     $win2->put($label2);
     #tell to packer to put the next widget horizontally to the $label2
     $win2->put_dir("h");   # horizontal packen
     #keep on putting widgets ...
     $win2->put($butt1);    # Button for Faktor 2
     $win2->put($label3);   # Faktor 3
     $win2->put($butt2);    # Button for Faktor 3
     $win2->put($label4);   # Faktor 4
     $win2->put($butt3);    # Button for Faktor 4
     #switch the packer to vertikal-mode...
     $win2->put_dir("v");
     #...to get the label under the other widgets.
     $win2->put($label5);   # "Ergebnis : ..."

   Man bekommt dann

     $label2 $butt1 $label3 $butt2 $label4 $butt3
     $label5

   bzw.

     Faktor 2 [ ] Faktor 3 [ ] Faktor 4 [ ]
     Ergebnis : 200

   Diese Art Widgets zu packen ist für kleinere Oberflächen zwar eine
schnelle Lösung, man stösst aber auch ebenso schnell an die Grenzen der
Möglichkeiten. Hier kommen dann die Boxen zum Zuge.

   Eine Box nimmt mehrere Widgets auf und packt diese immer entweder
horizontal oder vertikal.  Der Clou an der Sache ist aber das eine Box
auch eine andere Box aufnehmen kann. Es ist also möglich ein horizontale
Box in eine vertikale Box zu packen und das in beliebiger Tiefe. Auf diese
Art lässt sich nahezu alles realisieren. Wer den Widgetpacker von GTK oder
TK kennt, der weiss auch wie es hier funktioniert.

     ###########################################
     # 7 Buttons building an H
     ###########################################

     $vbox0->put($b1);

     $hbox1->put($b2);
     $hbox1->put($b3);

     $vbox0->put($hbox1);
     $vbox0->put($b4);

     $hbox0->put($vbox0);

     $vbox1->put($b5);
     $vbox1->put($b6);
     $vbox1->put($b7);

     $hbox0->put($vbox1);

     $win->put($hbox0);

   Man bekommt dann:

     [1]   [5]
     [2][3][6]
     [4]   [7]

COPYRIGHT
=========

   Copyright (c) 1999 SuSE GmbH, Nuernberg, Germany. All rights reserved.


File: pm.info,  Node: Paw/Popup,  Next: Paw/Popup-de,  Prev: Paw/Paw-de,  Up: Module List

Popup Window
============

   *$popup=Paw::Popup-*new([$height], [$width], [$shade], \@buttons,
\$text, [$name]);>

   Parameter

     $height   => number of rows [optionally]

     $width    => number of columns [optionally]

     $shade    => popup box has a shadow (shade=>1)

     $name     => name of the widget [optionally]

     \@buttons => an array of strings for the labels on the buttons
                  in the box.

     \$text    => reference to a scalar with the Text.
     
     B<Example>

     @butt=('Okay', 'Cancel');
     $text=('Do you really want to continue ?');
     $pu=Popup::new(height=>20, width=>20,
                        buttons=>\@butt, text=>\$text);

   If a button is pressed, the box closes and the number of the button is
returned (beginning by 0).

draw();
-------

   raises the popup-window, returns the number of the pushed button.

   Example

     $button=$pu->draw();

set_border(["shade"])
---------------------

   activates the border of the widget (optionally also with shadows).

   Example

     $widget->set_border("shade"); or $widget->set_border();


File: pm.info,  Node: Paw/Popup-de,  Next: Paw/Popup_menu,  Prev: Paw/Popup,  Up: Module List

Popup Window
============

   *$popup=Paw::Popup::new($height, $width, \@buttons, \$text, [$name]);*

   Parameter

     $height   => Anzahl der Reihen

     $width    => Anzahl der Spalten

     $name     => Name des Widgets [optional]

     \@buttons => Ein Array von Strings fuer die Label der Buttons in der Box.

     \$text    => Eine Refernez auf ein Scalar mit dem Text

   *Beispiel*

     @butt=("Okay", "Cancel");
     $text=("Do you really not want to continue ?");
     $pu=Paw::Popup::new(height=>20, width=>20,
                         buttons=>\@butt, text=>\$text);

   Wenn ein Button gedrueckt wird, schliesst sich die Box und es wird die
Nummer des Buttons zurueck gegeben (beginnend bei 0).

draw();
-------

   Stellt das Popup Fenster am Schirm da, gibt den gedrueckten Button
zurueck.

   *Beispiel*

     $button=$pu->draw();

set_border(["shade"])
---------------------

   aktiviert den Rahmen der Box. Optional auch mit Schatten.

   *Beispiel*

     $box->set_border("shade"); or $win->set_border();


File: pm.info,  Node: Paw/Popup_menu,  Next: Paw/Progressbar,  Prev: Paw/Popup-de,  Up: Module List

Listbox
=======

   *$lb= new Paw::Popup_menu ( \@data, [$size], [$width], [$default],
[$color], [\&callback], [$name]);*

   Parameter

     \@data     => Reference to an array that contains the entries

     $size      => Number of entries that are shown without scrolling,
                   if the widget is pushed [default is 5]

     $width     => Number of columns [default is 15]

     $default   => Number of the default element (starting at 0)
                   [default is 0]

     $name      => Name of the widget [optionally]

     $color     => the colorpair must be generated with
                   Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                   [optionally]
     
     \&callback => will be called when the value has changed.
                   the $this reference is given to it and no return value will be parsed

   Example

     $data = [ "one", "two", "three", "four" ];
     $pm=Paw::Popup_menu->new( data => $data, width=>10, size=>8 );

get_choice()
------------

   returns the choosen value of the box as string

   Example

     $choice = $pm->get_choice();

set_choice($number)
-------------------

   sets the choosen value of the box. $number is the element number in the
array

   Example

     $pm->set_choice(3);


File: pm.info,  Node: Paw/Progressbar,  Next: Paw/Progressbar-de,  Prev: Paw/Popup_menu,  Up: Module List

Button Widget
=============

   *$pb=Paw::Progressbar-*new( \$variable, [$from], [$to], [$blocks],
[$color], [$name] );>

   Parameter

     variable => a reference to a scalar variable which
                 should be represented by the progressbar

     from     => the minimum value (defaults to 0)

     to       => the maximum value (defaults to 100)

     blocks   => the number ob blocks between 'from' and 'to'
                 defaults to 10

     name     => name of the progressbar [optionally]

     color    => the colorpair must be generated with
                 Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                 [optionally]

   Example

     $pb=Paw::Progressbar->new( from=>-10, to=>10, blocks=>25, color=>3 );


File: pm.info,  Node: Paw/Progressbar-de,  Next: Paw/Radiobutton,  Prev: Paw/Progressbar,  Up: Module List

Button Widget
=============

   *$pb=Paw::Progressbar-*new( \$variable, [$from], [$to], [$blocks],
[$color], [$name] );>

   Parameter

     variable => Referenz auf ein Skalar welches durch den
     	          Progrssbar repraesentiert werden soll

     from     => der Minimum Wert (default ist 0)

     to       => der Maximum Wert (default ist 100)

     blocks   => Die Anzahl der Bloecke zwischen
                 Minimum und Maximum (default ist 10)

     name     => Name des Progressbar [optional]

     $color   => Das Farbpaar (colorpair) muss mit
                 Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                 erzeugt werden[optional]

   *Beispiel*

     $pb=Paw::Progressbar->new( from=>-10, to=>10, blocks=>25, color=>3 );


File: pm.info,  Node: Paw/Radiobutton,  Next: Paw/Radiobutton-de,  Prev: Paw/Progressbar-de,  Up: Module List

Radiobutton Widget
==================

   *$rb=Paw::Radiobutton-*new(\@labels, [$direction], [$color], [$name],
[\&callback]);>

   Parameter

     \@labels   => array of label for the buttons,
                   one element for each button.

     $color     => The colorpair must be generated with
                   Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                   [optionally]

     $name      => name of the widget [optionally]

     \&callback => reference to a function which will be executed
                   if the radiobutton is being pressed. [optional]

     $direction => "h"orizontally or "v"ertically (default) [optionally]

   Example

     @labels=("Red", "Green", "Blue");
     $rb=Paw::Radiobutton->new(labels=>\@labels, direction=>"v");

   Callback

   Similarly as with the normal button.

set_button()
------------

   the aktive button will be set/pushed.

   Example

     $rb->set_button();

get_pressed()
-------------

   returns the number of the pressed button. (starting at 0).

   Example

     $pushed_button=$rb->get_pressed();

abs_move_widget($new_x, $new_y)
-------------------------------

   the widget moves to the new absolute screen position.  if you set only
one of the two parameters, the other one keeps the old value.

   Example

     $rb->abs_move_widget( new_x=>5 );      #y-pos is the same

get_widget_pos()
----------------

   returns an array of two values, the x-position and the y-position of
the widget.

   Example

     ($xpos,$ypos)=$rb->get_widget_pos();

set_color($color_pair)
----------------------

   Set a new color_pair for the widget.

   Example

     $box->set_color(3);

set_border(["shade"])
---------------------

   activates the border of the widget (optionally also with shadows).

   Example

     $widget->set_border("shade"); or $widget->set_border();


File: pm.info,  Node: Paw/Radiobutton-de,  Next: Paw/Scrollbar,  Prev: Paw/Radiobutton,  Up: Module List

Radiobutton Widget
==================

   *$rb=Paw::Radiobutton::new(\@labels, [$direction], [$color], [$name],
[\&callback]);*

   Parameter

     \@labels   => Die Label fuer die Buttons.
                   Hiermit wird auch Anzahl der Buttons festgelegt.

     $color     => Das Farbpaar (colorpair) muss mit
                   Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                   erzeugt werden[optional]

     $name      => Name des Widgets [optional]

     \&callback => Referenz auf Function die bei betaetigen des Radiobuttons
                   angesprungen wird. [optional]

     $direction => Richtung in der die Buttons liegen sollen "h" bzw. "v"
                   (default) [optional]

   *Beispiel*

     @labels=("Red", "Green", "Blue");
     $rb=Paw::Radiobutton::new(labels=>\@labels, direction=>"v");

   Callback

   Ähnlich wie beim "normalen" Button wird bei Betaetigung des
Radiobuttons die Callback Funktion angesprungen. (perldoc Paw::Button)

set_button()
------------

   Der aktive Button wird gesetzt/gedrueckt.

   *Beispiel*

     $rb->set_button();

get_pressed()
-------------

   gibt die Nummer des Buttons zurueck der gedrueckt ist (Zaehlung
beginnend bei 0).

   *Beispiel*

     $pushed_button=$rb->get_pressed();

abs_move_widget($new_x, $new_y)
-------------------------------

   Das Widget verschiebt sich auf die neue absolute Schirm Position.  Wird
nur einer der Parameter angegeben, so behaelt der andere seinen Wert bei.

   *Beispiel*

     $rb->abs_move_widget( new_x=>5 );      #y-pos is the same

get_widget_pos()
----------------

   Gibt ein Array mit den beiden Wertde (x-Position, y-Position) zurueck.

   *Beispiel*

     ($xpos,$ypos)=$rb->get_widget_pos();

set_color($color_pair)
----------------------

   Setzt ein neues color_pair.

   *Beispiel*

     $box->set_color(3);

set_border(["shade"])
---------------------

   aktiviert den Rahmen der Box. Optional auch mit Schatten.

   *Beispiel*

     $box->set_border("shade"); or $win->set_border();


File: pm.info,  Node: Paw/Scrollbar,  Next: Paw/Scrollbar-de,  Prev: Paw/Radiobutton-de,  Up: Module List

Scrollbar
=========

   *$sb=Paw::Scrollbar-*new($widget, [$name]);  #a little bit buggy>

   Parameter

     $name      => Name des Widgets [optional]

     $widget    => A reference to the widget which will be
                   "scrollbared".

   Example

     $sb=Paw::Scrollbar->new(widget=>$listbox, name=>"List Scrollbar");


File: pm.info,  Node: Paw/Scrollbar-de,  Next: Paw/Text_entry,  Prev: Paw/Scrollbar,  Up: Module List

Scrollbar
=========

   *$sb=Paw::Scrollbar::new($widget, [$name]);  #a little bit buggy*

   Parameter

     $name      => Name des Widgets [optional]

     $widget    => A reference to the widget which will be
                   "scrollbared".

   *Beispiel*

     $sb=Paw::Scrollbar::new(widget=>$listbox, name=>"List Scrollbar");


File: pm.info,  Node: Paw/Text_entry,  Next: Paw/Text_entry-de,  Prev: Paw/Scrollbar-de,  Up: Module List

Textentry Widget
================

   *$te=Paw::Text_entry-*new($width, [$cursor_color], [$color], [$name],
[\&callback], [$text], [$side], [$echo], [$max_length] );>

   Parameter

     width        => width of the text-entry (in other words: columns)

     color        => the colorpair must be generated with
                   Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                   [optionally]

     cursor_color => same like color but only for the cursor

     name         => name of the widget [optionally]

     callback     => reference to the function that will be
                   executed each time you press a key in the entry.
                   [optionally]

     text         => default text for the entry [optionally]

     orientation  => "left"(default) or "right"
                   for left/right-justified text.

     echo         => 0, 1  oder 2 : 0=no echo of the entered text,
                   1=Stars instead of characters, 2=full echo (default)
                   (0 and 1 good for passwords) [optional]

     max_length   => maximum length of the entry (default = 1024)

   Example

     $te=Paw::Text_entry->new(width=>15, text=>"PLEASE ENTER NAME",
                                  max_length=>25);

   Callback

   The callback function will be started each time you press a key in the
text-entry.  The object reference ($this) and the key value will be given
to the callback.  This will give you the chance to allow only digits or
whatever you want.  You must return the key-value or no text will ever
reach into the widget.

   sub callback {    my $this = shift;    my $key  = shift;

     [... do some stuff ...]

     return $key;
     }

get_text()
----------

   returns the text of the entry.

   Example

     $text=$te->get_text();

set_text($text)
---------------

   set the text in the entry to $text.

   Example

     $te->set_text("default");

abs_move_widget($new_x, $new_y)
-------------------------------

   the widget moves to the new absolute screen position.  if you set only
one of the two parameters, the other one keeps the old value.

   Example

     $te->abs_move_widget( new_x=>5 );      #y-pos is the same

get_widget_pos()
----------------

   returns an array of two values, the x-position and the y-position of
the widget.

   Example

     ($xpos,$ypos)=$te->get_widget_pos();

set_color($color_pair)
----------------------

   Set a new color_pair for the widget.

   Example

     $box->set_color(3);

set_border(["shade"])
---------------------

   activates the border of the widget (optionally also with shadows).

   Example

     $widget->set_border("shade"); or $widget->set_border();


File: pm.info,  Node: Paw/Text_entry-de,  Next: Paw/Textbox,  Prev: Paw/Text_entry,  Up: Module List

Textentry Widget
================

   *$te=Paw::Text_entry::new($width, [$color], [$name], [\&callback],
[$text], [$side], [$echo], [$max_length]);*

   Parameter

     width      => Breite des Text Entrys

     color      => Das Farbpaar (colorpair) muss mit
                   Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                   erzeugt werden[optional]

     name       => Name des Widgets [optional]

     callback   => Referenz auf Funktion die bei jedem Tastendruck
                   angesprungen wird. [optional]

     text       => Ein Text der im Entry stehen soll. [optional]

     orientation=> "left"(default) oder "right" fuer links- bzw.
                   rechtsbuendigen Text

     echo       => 0, 1  oder 2 : 0=keine Wiedergabe des eingegebenen Textes,
                   1=´*´ statt Buchstaben, 2=volle Widergabe (default)
                   (0 und 1 fuer z.B. Passwoerter) [optional]

     max_length => Maximale Laenge einer Eingabe (default = 1024)

   *Beispiel*

     $te=Paw::Text_entry::new(width=>15, text=>"PLEASE ENTER NAME",
                              max_length=>25);

   Callback

   Die Callback Funktion wird bei jedem Tastendruck angesprungen, dabei
wird die Objekt-Referenz ($this) sowie der Wert der gedrueckten Taste
uebergeben.  Dieser muss auch wieder zurueck gegeben werden, wenn er in
das Textentry soll.  So laesst sich eine Art Filter programmieren, der
z.B. nur Ziffern zulaesst.

   sub callback {    my $this = shift;    my $key  = shift;

     [... Programmcode ...]

     return $key;
     }

get_text()
----------

   gibt den Text des Entry's zurueck

   *Beispiel*

     $text=$te->get_text();

set_text($text)
---------------

   setzt den Text im Entry.

   *Beispiel*

     $te->set_text("default");

abs_move_widget($new_x, $new_y)
-------------------------------

   Das Widget verschiebt sich auf die neue absolute Schirm Position.  Wird
nur einer der Parameter angegeben, so behaelt der andere seinen Wert bei.

   *Beispiel*

     $te->abs_move_widget( new_x=>5 );      #y-pos is the same

get_widget_pos()
----------------

   Gibt ein Array mit den beiden Wertde (x-Position, y-Position) zurueck.

   *Beispiel*

     ($xpos,$ypos)=$te->get_widget_pos();

set_color($color_pair)
----------------------

   Setzt ein neues color_pair.

   *Beispiel*

     $box->set_color(3);

set_border(["shade"])
---------------------

   aktiviert den Rahmen der Box. Optional auch mit Schatten.

   *Beispiel*

     $box->set_border("shade"); or $win->set_border();


File: pm.info,  Node: Paw/Textbox,  Next: Paw/Textbox-de,  Prev: Paw/Text_entry-de,  Up: Module List

Textbox
=======

   *$popup=Paw::Textbox-*new($height, $width, \$text, [$color],
[$cursor_color], [$name], [$edit]);>

   Parameter

     $height       => number of rows

     $width        => number of columns

     \$text        => reference to a scalar that contains the text.

     $edit         => text edit able (0/1) default is 0

     $color        => the colorpair must be generated with
                      Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                      [optionally]

     $cursor_color => same like color but only for the cursor

     $name         => Name of the widget [optionally]

   Example

     $data=("This is free software with ABSOLUTELY NO WARRANTY.\n");
     $pu=Paw::Textbox->new(height=>20, width=>20, text=>\$text);

set_border(["shade"])
---------------------

   activates the border of the widget (optionally also with shadows).

   Example

     $widget->set_border("shade"); or $widget->set_border();


File: pm.info,  Node: Paw/Textbox-de,  Next: Paw/Window,  Prev: Paw/Textbox,  Up: Module List

Textbox
=======

   *$popup=Paw::Textbox::new($height, $width, \$text, [$name], [$edit] );*

   Parameter

     $height => Anzahl der Reihen

     $width  => Anzahl der Spalten

     \$text  => Referenz auf den Text.

     $edit   => editierbarer Text ?
                (0=nein, 1=ja). Standard ist 0

   *Beispiel*

     $data=("This is free software with ABSOLUTELY NO WARRANTY.\n")
     $pu=Paw::Paw_textbox->new(height=>20, width=>20, text=>\$data);

set_border(["shade"])
---------------------

   aktiviert den Rahmen der Box. Optional auch mit Schatten.

   *Beispiel*

     $box->set_border("shade"); or $win->set_border();


File: pm.info,  Node: Paw/Window,  Next: Paw/Window-de,  Prev: Paw/Textbox-de,  Up: Module List

Window
======

   *$window=Paw::Window-*new($height, $width, [$abs_x], [$abs_y],
[$color], [$name], [\&callback], [\$statusbar], [$orientation],
[\&time_function]);>

   Parameter

     $height         => number of rows

     $width          => number of columns

     $abs_x          => absolute x-coordinate at the screen
                        [optionally]

     $abs_y          => absolute y-coordinate at the screen
                        [optionally]

     $color          => the colorpair must be generated with
                        Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                        [optionally]

     $name           => name of the widget [optionally]

     \&callback      => reference to the function which will be
                        executed on each key-press.
                        [optionally]

     $quit_key       => Key-Code which terminates the window
                        [optionally]

     \@statusbar     => Reference of an array with 10 elements
                        [optionally]

     \$statusbar     => a reference on a scalar-string wich should
                        appear as text in the statusbar [optional]
                        Since it concerns a reference,
                        the text can be changed at run time.

     $orientation    => "topleft", "topright", "bottomleft",
                        "bottomright", "center"  "grow"
                        are the possible parameters.
                        They indicate how the box will behave on
                        modifications of the terminal size.
                        Either it keeps it's distance to the
                        indicated terminal side, it remains
                        centered or it grows/shrinks with
                        the new terminal size
                        (default is "center") [optionally].

     $title          => Title of the box (will be shown in the top-left
                        corner of the box [optionally]

     \&time_function => This function will be called about
                        every 0,1 seconds as long as
                        the window has the focus.

   Example

     $window=Paw::Window->new(height=>20, width=>10,
                                  color=>2, callback=>\&function,
                                  statusbar=>\$status, quit_key=>KEY_F(10));

   Callback

   The callback method usually is a loop which constantly checks the
keyboard for pressed keys and passes those key-codes to the active widget.
The internal callback routine, which one is used if none callback Function
for the window is defined, for example :

     sub Paw_main_loop {
     
         my $main_win = $_[0];
     
         my $i = "";
         $main_win->_refresh();
         while ( not $main_win->{close_it} and
                     ($i ne $main_win->{quit_key}) )
         {
             $this->{main_win} = $main_win;
             $i = getch();                  # read key
             &{$main_win->{time_function}} if ( defined $main_win->{time_function} );
             if ( $i ne -1 ) {
                 $main_win->key_press($i);  # keycode to widgetset
                 $main_win->_refresh();
             }
             else {
                 $main_win->_refresh() if ( defined $main_win->{time_function} );
             }
         };
         Curses::clear();
         $main_win->{close_it}=0;
         endwin();
     }

   if the getch() Function don't receive a key-code for about 0,1 seconds,
then it will be left again and "$i" contains the value " -1 ".
$widget->key_press($i) passes the key-code to the active widget.

get_window_parameter()
----------------------

   returns the most important parameters of the window.

   Example

     ($cols, $rows, $color)=$win->get_window_parameter();

put_dir($direction)
-------------------

   sets the pack-direction of the next widget. "v"ertically or
"h"orizontally.  This function can be walked around by using boxes.

   Example

     $win->put_dir("h");

close_win();
------------

   The window loses the focus. If no other window takes over the focus,
the program ends.

   Example

     $win->close_win();

put($widget)
------------

   put the widget into the window.

   Example

     $win->put($button0);

set_border(["shade"])
---------------------

   activate the border of the window, optionally with shadow.

   Example

     $win->set_border("shade"); oder $win->set_border();

set_focus($widget_name)
-----------------------

   Sets the focus not on the next widget but on the "$widget_name" named
one.  Required however that the widget has a name.

   Example

     $win->set_focus($button0);

abs_move_curs($new_x, $new_y);
------------------------------

   Sets the packer to the absolute position in the box (negative values
lay outside of the box).

   Example

     $win->abs_move_curs(new_y=>5, new_x=>2);

rel_move_curs($new_x, $new_y);
------------------------------

   Sets the packer relative to the current position in the box (also
negative values are possible).

   Example

     $win->rel_move_curs(new_x=>-5);


File: pm.info,  Node: Paw/Window-de,  Next: Penguin/Easy,  Prev: Paw/Window,  Up: Module List

Window
======

   *$window=Paw::Window::new($height, $width, [$abs_x], [$abs_y],
[$color], [$name], [\&callback], [\$statusbar], [$orientation],
[\&time_function]);*

   Parameter

     $height         => Anzahl der Reihen (Laenge)

     $width          => Anzahl der Spalten (Breite)

     $abs_x          => Absolute x-Koordiante am Schirm [optional]

     $abs_y          => Absolute y-Koordiante am Schirm [optional]

     $color          => Das Farbpaar (colorpair) muss mit
                        Curses::init_pair(pair_nr, COLOR_fg, COLOR_bg)
                        erzeugt werden [optional]

     $name           => Name des Fensters [optional]

     \&callback      => Referenz auf Funktion die bei jedem Tastendruck
                        angesprungen wird. [optional]

     $quit_key       => Taste die das Fenster schliesst [optional]

     \@statusbar     => Referenz auf ein Array mit 10 Eintraegen [optional]

     \$statusbar     => eine Referenz auf ein Scalar welcher als Text
                        im Statusbar stehen soll [optional]
                        Da es sich um eine Referenz handelt,
                        kann sich der Text waehrend der Laufzeit aendern.

     $orientation    => "topleft", "topright", "bottomleft", "bottomright",
                        "center" und "grow" sind die moeglichen
                        Parameter. Sie geben an wie sich das
                        Fenster bei Aenderung des Terminalgroesse
                        verhaelt. Entweder behaelt es seinen
                        Abstand zu der angegebenen Seite bei,
                        es bleibt zentriert oder es waechst
                        bzw. schrumpft mit der neuen Terminalgroesse.
                        (default ist "center") [optional].

     $title          => Titel der Box (wird oben links an der Box dargestellt)
                        [optional]

     \&time_function => Die Funktion wird ca. alle 0,1 s angesprungen
                        so lange das Fenster den Focus hat.

   *Beispiel*

     $window=Paw::Window::new(height=>20, width=>10,
                              color=>2, callback=>\&function,
                              statusbar=>\$status, quit_key=>KEY_F(10));

   Callback

   Die Callback Methode ist in der Regel eine Schleife die laufend die
Tastatur abfragt und gedrueckte Tasten an die Widgets im Fenster
weitergibt. Die interne Callback Routine welche benutzt wird falls keine
Callback Function fuer das Fenster definiert wurde lautet zum Beispiel :

     sub Paw_main_loop {
     
         my $main_win = $_[0];
     
         my $i = "";
         $main_win->_refresh();
         while ( not $main_win->{close_it} and
                     ($i ne $main_win->{quit_key}) )
         {
             $this->{main_win} = $main_win;
             $i = getch();                  # read key
             &{$main_win->{time_function}} if ( defined $main_win->{time_functio
             if ( $i ne -1 ) {
                 $main_win->key_press($i);  # keycode to widgetset
                 $main_win->_refresh();
             }
             else {
                 $main_win->_refresh() if ( defined $main_win->{time_function} )
             }
         };
         Curses::clear();
         $main_win->{close_it}=0;
         endwin();
     }

   Empfaengt die getch() Function nach ca. 0.1 Sekunden keinen Tastendruck,
so wird sie wieder verlassen und die $i Variable enthaelt den Wert "-1".
Die key_press Methdode reicht die Taste an die Widgets weiter.

get_window_parameter()
----------------------

   Gibt die wichtigsten Parameter eines Fensters zurueck.

   *Beispiel*

     ($cols, $rows, $color)=$win->get_window_parameter();

put_dir($direction)
-------------------

   Setzt die Richtung in die das naechste Widget gepackt werden soll.
Direction kann "v" oder "h" fuer vertikal bzw. horizontal sein.  Diese
Funktion kann voellig durch benutzen von Boxen umgangen werden.

   *Beispiel*

     $win->put_dir("h");

close_win();
------------

   Das Fenster verliert den Focus. Wenn kein anderes Fenster den Focus
uebernimmt, kommt das dem Programmende gleich.

   *Beispiel*

     $win->close_win();

put($widget)
------------

   Packt das Widget in das Fenster.

   *Beispiel*

     $win->put($button0);

set_border(["shade"])
---------------------

   aktiviert den Rahmen des Fensters optional auch mit Schatten.

   *Beispiel*

     $win->set_border("shade"); oder $win->set_border();

set_focus($widget_name)
-----------------------

   Setzt den Focus nicht auf das eigentlich naechste Widget, sondern auf
das Übergebene. Erfordert allerdings das das Widget einen Namen hat.

   *Beispiel*

     $win->set_focus($button0);

abs_move_curs($new_x, $new_y);
------------------------------

   Setzt den Packer an die absolute Position im Fenster (negative Werte
liegen ausserhalb des Fensters).

   *Beispiel*

     $win->abs_move_curs(new_y=>5, new_x=>2);

rel_move_curs($new_x, $new_y);
------------------------------

   Setzt den Packer relativ zur momentanen Position im Fenster (auch
negative Werte moeglich).

   *Beispiel*

     $win->rel_move_curs(new_x=>-5);


File: pm.info,  Node: Penguin/Easy,  Next: Perf/ARM,  Prev: Paw/Window-de,  Up: Module List

provides easy access to Penguin module.
***************************************

NAME
====

     Penguin::Easy -- provides easy access to Penguin module.

SYNOPSIS
========

     use Penguin::Easy;
     my $ep = new Penguin::Easy Title => 'Easy Program',
     			     Name => 'James Duncan',
     			     Sig => $my_pgp_sig,
     			     Code => $my_perl_code;
     $results = $ep->run;
     print "$results\n";

DESCRIPTION
===========

   `Penguin::Easy' is an OO module, that provides quick-and-dirty access
to the penguin module for those not wanting to learn the nittygrittys
about it.  The Easy module provides transparent access to the `Penguin'
module, even to the extent of deciding whether the Penguin code should be
transparently wrapped, or PGP wrapped (if you include a sig in the call to
the new method,  it will use PGP).

NOTES
=====

   While writing this little module,  I've decided that `Wrapper' is
perhaps one of the funniest words I have ever seen.  It has completly lost
all meaning.


File: pm.info,  Node: Perf/ARM,  Next: PerlPoint/Backend,  Prev: Penguin/Easy,  Up: Module List

Perl extension wrapper for the ARM 2.0 implementation
*****************************************************

NAME
====

   Perf::ARM - Perl extension wrapper for the ARM 2.0 implementation

SYNOPSIS
========

     use Perf::ARM;

     my ($appl_id,$tran_handle, $tran_id, $rc);

     ($appl_id=Perf::ARM::arm_init( "$0", "*", 0,0,0)) ||
       die "arm_init() failed \n";
     $tran_id=Perf::ARM::arm_getid($appl_id, "simple_tran",
       "detail_$$", 0,0,0);
     $tran_handle=Perf::ARM::arm_start($tran_id, 0,0,0);

     #  do the unit of work to be measured
     &do_my_work(@my_args)

     $rc=Perf::ARM::arm_stop($tran_handle, 0, 0,0,0);

     $rc=Perf::ARM::arm_end($appl_id, 0,0,0);

DESCRIPTION
===========

   This serves as a simple wrapper around the ARM C routines:

   arm_init(char *,char *,long ,char *,long );     [ returns long  ]

   arm_getid(long ,char *,char *,long ,char *,long );     [ returns long  ]

   arm_start(long ,long ,char *,long );     [ returns long  ]

   arm_update(long ,long ,char *,long );     [ returns long  ]

   arm_stop(long ,long ,long ,char *,long );     [ returns long  ]

   arm_end(long ,long ,char *,long );     [ returns long  ]

Exported functions, with ARM defines
====================================

     extern arm_int32_t  arm_init(
       char*        appl_name,
       char*        appl_user_id,
       arm_int32_t  flags,
       char*        data,
       arm_int32_t  data_size);
     extern arm_int32_t  arm_getid(
       arm_int32_t  appl_id,
       char*        tran_name,
       char*        tran_detail,
       arm_int32_t  flags,
       char*        data,
       arm_int32_t  data_size);
     extern arm_int32_t  arm_start(
       arm_int32_t  tran_id,
       arm_int32_t  flags,
       char*        data,
       arm_int32_t  data_size);
     extern arm_int32_t  arm_update(
       arm_int32_t  start_handle,
       arm_int32_t  flags,
       char*        data,
       arm_int32_t  data_size);
     extern arm_int32_t  arm_stop(
       arm_int32_t  start_handle,
       arm_int32_t  tran_status,
       arm_int32_t  flags,
       char*        data,
       arm_int32_t  data_size);
     extern arm_int32_t  arm_end(
       arm_int32_t  appl_id,
       arm_int32_t  flags,
       char*        data,
       arm_int32_t  data_size);

AUTHOR
======

   bryan_backer@hp.com

SEE ALSO
========

   ARM FAQ at http://www.cmg.org/regions/cmgarmw/armfaq.html

   Glance docs at http://www.openview.hp.com/products/

   CMG ARM Working Group info page at http://www.cmg.org/regions/cmgarmw/

   HP-UX: /opt/perf/include/arm.h or /usr/include/arm.h


File: pm.info,  Node: PerlPoint/Backend,  Next: PerlPoint/Constants,  Prev: Perf/ARM,  Up: Module List

frame class to transform PerlPoint::Parser output
*************************************************

NAME
====

   PerlPoint::Backend - frame class to transform PerlPoint::Parser output

VERSION
=======

   This manual describes version *0.07*.

SYNOPSIS
========

     # load the module:
     use PerlPoint::Backend;

     # build the backend
     my ($backend)=new PerlPoint::Backend(name=>'synopsis');

     # register handlers
     $backend->register(DIRECTIVE_BLOCK, \&handleBlock);
     $backend->register(DIRECTIVE_COMMENT, \&handleComment);
     $backend->register(DIRECTIVE_DOCUMENT, \&handleDocument);
     $backend->register(DIRECTIVE_HEADLINE, \&handleHeadline);
     $backend->register(DIRECTIVE_POINT, \&handlePoint);
     $backend->register(DIRECTIVE_SIMPLE, \&handleSimple);
     $backend->register(DIRECTIVE_TAG, \&handleTag);
     $backend->register(DIRECTIVE_TEXT, \&handleText);
     $backend->register(DIRECTIVE_VERBATIM, \&handleVerbatim);

     # finally run the backend
     $backend->run(\@streamData);

DESCRIPTION
===========

   After an ASCII text is parsed by an PerlPoint::Parser object, the
original text is transformed into stream data hold in a Perl array. To
process this intermediate stream further (mostly to generate output in a
certain document description language), a program has to walk through the
stream and to process its tokens.

   Well, PerlPoint::Backend provides a class which encapsulates this walk
in objects which deal with the stream, while the translator programmer is
focussed on generating the final representation of the original text. This
is done by registering handlers which will be called when their target
objects are discovered in the intermediate stream.

METHODS
=======

new()
-----

   The constructor builds and prepares a new backend object. You may have
more than one object at a certain time, they work independently.

   Parameters: All parameters except of the class parameter are named
(pass them by hash).

class
     The class name.

name
     Because there can be more than exactly one backend object, your object
     should be named. This is not necessarily a need but helpful reading
     traces.

trace
     This parameter is optional. It is intended to activate trace code
     while the object methods run. You may pass any of the "TRACE_..."
     constants declared in PerlPoint::Constants, combined by addition as
     in the following example:

          trace => TRACE_NOTHING+TRACE_BACKEND,

     In fact, only TRACE_NOTHING and TRACE_BACKEND take effect to backend
     objects.

     If you omit this parameter or pass TRACE_NOTHING, no traces will be
     displayed.

display
     This parameter is optional. It controls the display of runtime
     messages like informations or warnings in all object methods. By
     default, all messages are displayed. You can suppress these
     informations partially or completely by passing one or more of the
     "DISPLAY_..." variables declared in PerlPoint::Constants.

     Constants can be combined by addition.

   *Returns:* the new object.

   Example:

     my ($parser)=new PerlPoint::Backend(name=>'example');

register()
----------

   After building a new object by new() the object can be prepared by
calls of the register method.

   If the object walks through the data stream generated by
PerlPoint::Parser, it will find several directives. A directive is a data
struture flagging that a certain document part (or even formatting) starts
or is completed.  E.g. a headline is represented by headline start
directive followed by tokens for the headline contents followed by a
headline completion directive.

   By using this method, you can register directive specific functions
which should be called when the related directives are discovered. The
idea is that such a function can produce a target language construct
representing exactly the same document token that is modelled by the
directive. E.g. if your target language is HTML and you register a
headline handler and a headline start is found, this handler can generate
a "<HEAD>" tag. This is quite simple.

   According to this design, the object will pass the following data to a
registered function:

directive
     the directive detected, this should be the same the function was
     registered for. See PerlPoint::Constants for a list of directives.

start/stop flag
     The document stream generated by the parser is strictly synchronous.
     Everything except of plain strings is represented by an open directive
     and a close directive, which may embed other parts of the document.
     A headline begins, something is in, then it is complete. It's the
     same for every tag or paragraph and even for the whole document.

     So well, because of this structure, a handler registered for a certain
     directive is called for opening directives as well as for closing
     directives. To decide which case is true, a callback receives this
     parameter. It's always one of the constants DIRECTIVE_START or
     DIRECTIVE_COMPLETED.

     For simple strings (words, spaces etc.) and line number hints, the
     callback will always be called with DIRECTIVE_START.

directive values, if available
     Certain directives provide additional data such as the headline level
     or the original documents name which are passed to their callbacks
     additionally.  See the following list:

    Documents
          transfer the *basename* of the original ASCII document being
          parsed;

    Headlines
          transfer the headline level;

    Ordered list points
               optionally transfer a fix point number;

    Tags
          transfer the tag name ("I", "B" etc.).

   To express this by a prototype, all registered functions should have an
interface of "$$:@".

   Parameters:

object
     a backend object as made by new();

directive
     the directive this handler is registered for. See
     PerlPoint::Constants for a list of directives.

handler
     the function to be called if a pointed directive is entered while the
     run() method walks through the document stream.

   *Returns:* no certain value;

   Example:

     $backend->register(DIRECTIVE_HEADLINE, \&handleHeadline);

   where handleHeadline could be something like

     sub handleDocument
      {
       my ($directive, $startStop, $level)=@_;
       confess "Something is wrong\n"
         unless $directive==DIRECTIVE_HEADLINE;
       if ($startStop==DIRECTIVE_START)
         {print "<head$level>";}
       else
         {print "</head>";}
      }

SEE ALSO
========

PerlPoint::Parser
     A parser for Perl Point ASCII texts.

PerlPoint::Constants
     Public PerlPoint::... module constants.

AUTHOR
======

   Jochen Stenzel (perl@jochen-stenzel.de), 1999-2000. All rights reserved.

   This module is free software, you can redistribute it and/or modify it
under the terms of the Artistic License distributed with Perl version
5.003 or (at your option) any later version. Please refer to the Artistic
License that came with your Perl distribution for more details.

   The Artistic License should have been included in your distribution of
Perl. It resides in the file named "Artistic" at the top-level of the Perl
source tree (where Perl was downloaded/unpacked - ask your system
administrator if you dont know where this is).  Alternatively, the current
version of the Artistic License distributed with Perl can be viewed
on-line on the World-Wide Web (WWW) from the following URL:
http://www.perl.com/perl/misc/Artistic.html

DISCLAIMER
==========

   This software is distributed in the hope that it will be useful, but is
provided "AS IS" WITHOUT WARRANTY OF ANY KIND, either expressed or
implied, INCLUDING, without limitation, the implied warranties of
MERCHANTABILITY and FITNESS FOR A PARTICULAR PURPOSE.

   The ENTIRE RISK as to the quality and performance of the software IS
WITH YOU (the holder of the software).  Should the software prove
defective, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
CORRECTION.

   IN NO EVENT WILL ANY COPYRIGHT HOLDER OR ANY OTHER PARTY WHO MAY CREATE,
MODIFY, OR DISTRIBUTE THE SOFTWARE BE LIABLE OR RESPONSIBLE TO YOU OR TO
ANY OTHER ENTITY FOR ANY KIND OF DAMAGES (no matter how awful - not even
if they arise from known or unknown flaws in the software).

   Please refer to the Artistic License that came with your Perl
distribution for more details.


