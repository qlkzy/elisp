This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Device/ISDN/OCLM/CurrentStatistics,  Next: Device/ISDN/OCLM/ISDNStatistics,  Prev: Device/ISDN/OCLM,  Up: Module List

OCLM current call statistics
****************************

NAME
====

   Device::ISDN::OCLM::CurrentStatistics - OCLM current call statistics

SYNOPSIS
========

     $status = $lanmodem->getCurrentStatistics ();
     ...
     $info = $lanmodem->currentStatistics ();
     $sp = $info->spName (1);

DESCRIPTION
===========

   This class encapsulates 3com OCLM current call statistics, including
call time, destination, etc.

   This class is a subclass of *Device::ISDN::OCLM::Statistics*.

CONSTRUCTORS
============

   Extract instances of this class from *Device::ISDN::OCLM::LanModem*.

METHODS
=======

   The following methods are provided: For most calls, a call number must
be specified; this will be either 1 or 2.

$copy = $info->clone ()
     This method returns a clone of this object.

$type = $info->callType ($index)
     This method returns the call type of the specified call or undef.

$dir = $info->callDirection ($index)
     This method returns the call direction of the specified call or undef.

$sp = $info->spName ($index)
     This method returns the service provider name or dial-in user of the
     specified call or undef.

$ip = $info->ipAddress ($index)
     This method returns the IP address of the specified call or undef.

$dns = $info->primaryDNS ($index)
     This method returns the primary DNS server of the specified call or
     undef.

$dns = $info->secondaryDNS ($index)
     This method returns the secondary DNS server of the specified call or
     undef.

$opt = $info->callOptions ($index)
     This method returns the call options of the specified call or undef.

$st = $info->startTime ($index)
     This method returns the start time of the specified call or undef.

$ut = $info->upTime ($index)
     This method returns the up time of the specified call or undef.

$it = $info->idleTime ($index)
     This method returns the idle time of the specified call or undef.

$oct = $info->octetsReceived ($index)
     This method returns the octets received on the specified call or
     undef.

$oct = $info->octetsTransmitted ($index)
     This method returns the octets transmitted on the specified call or
     undef.

$num = $info->callingNumber ($index)
     This method returns the calling number of the specified call or undef.

$num = $info->calledNumber ($index)
     This method returns the called number of the specified call or undef.

$reason = $info->upReason ($index)
     This method returns the reason for the specified call going up or
     undef.

$str = $info->toString ()
     This method returns a textual representation of this object.

COPYRIGHT
=========

   Copyright 1999-2000 Merlin Hughes.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Merlin Hughes <merlin@merlin.org>


File: pm.info,  Node: Device/ISDN/OCLM/ISDNStatistics,  Next: Device/ISDN/OCLM/Last10Statistics,  Prev: Device/ISDN/OCLM/CurrentStatistics,  Up: Module List

OCLM ISDN statistics
********************

NAME
====

   Device::ISDN::OCLM::ISDNStatistics - OCLM ISDN statistics

SYNOPSIS
========

     $status = $lanmodem->getISDNStatistics ();
     ...
     $info = $lanmodem->isdnStatistics ();
     $tei = $info->tei ();

DESCRIPTION
===========

   This class encapsulates 3com OCLM ISDN statistics, including line
status, etc.

   This class is a subclass of *Device::ISDN::OCLM::Statistics*.

CONSTRUCTORS
============

   Extract instances of this class from *Device::ISDN::OCLM::LanModem*.

METHODS
=======

   The following methods are provided:

$copy = $info->clone ()
     This method returns a clone of this object.

$l1 = $info->layer1 ()
     This method returns the layer 1 status.

$l2 = $info->layer2 ()
     This method returns the layer 2 status.

$tei = $info->tei ()
     This method returns the line TEI.

$str = $info->toString ()
     This method returns a textual representation of this object.

COPYRIGHT
=========

   Copyright 1999-2000 Merlin Hughes.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Merlin Hughes <merlin@merlin.org>


File: pm.info,  Node: Device/ISDN/OCLM/Last10Statistics,  Next: Device/ISDN/OCLM/LastStatistics,  Prev: Device/ISDN/OCLM/ISDNStatistics,  Up: Module List

OCLM Last10 call statistics
***************************

NAME
====

   Device::ISDN::OCLM::Last10Statistics - OCLM Last10 call statistics

SYNOPSIS
========

     $status = $lanmodem->getLast10Statistics ();
     ...
     $info = $lanmodem->Last10Statistics ();
     $sp = $info->serviceProvider (1);

DESCRIPTION
===========

   This class encapsulates 3com OCLM last 10 call statistics, including
known service providers and whether or not they are currently connected.

CONSTRUCTORS
============

   Extract instances of this class from *Device::ISDN::OCLM::LanModem*.

METHODS
=======

   The following methods are provided:

$copy = $info->clone ()
     This method returns a clone of this object.

$typ = $info->callType ($index)
     This method returns the call type of the specified call (1-offset) or
     undef.

$sp = $info->serviceProvider ($index)
     This method returns the name of the service provider of the specified
     call (1-offset) or undef.

$dur = $info->duration ($index)
     This method returns the duration of the specified call (1-offset) or
     undef.

$reason = $info->initiationReason ($index)
     This method returns the initiation reason of the specified call
     (1-offset) or undef.

$str = $info->toString ()
     This method returns a textual representation of this object.

COPYRIGHT
=========

   Copyright 1999-2000 Merlin Hughes.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Merlin Hughes <merlin@merlin.org>


File: pm.info,  Node: Device/ISDN/OCLM/LastStatistics,  Next: Device/ISDN/OCLM/ManualStatistics,  Prev: Device/ISDN/OCLM/Last10Statistics,  Up: Module List

OCLM last call statistics
*************************

NAME
====

   Device::ISDN::OCLM::LastStatistics - OCLM last call statistics

SYNOPSIS
========

     $status = $lanmodem->getLastStatistics ();
     ...
     $info = $lanmodem->lastStatistics ();
     $reason = $info->downReason (1);

DESCRIPTION
===========

   This class encapsulates 3com OCLM last call statistics, including call
time, destination, etc.

   This class is a subclass of *Device::ISDN::OCLM::Statistics*.

CONSTRUCTORS
============

   Extract instances of this class from *Device::ISDN::OCLM::LanModem*.

METHODS
=======

   The following methods are provided: For most calls, a call number must
be specified; this will be either 1 or 2.

$copy = $info->clone ()
     This method returns a clone of this object.

$type = $info->callType ($index)
     This method returns the call type of the specified call or undef.

$dir = $info->callDirection ($index)
     This method returns the call direction of the specified call or undef.

$sp = $info->spName ($index)
     This method returns the service provider name or dial-in user of the
     specified call or undef.

$opt = $info->callOptions ($index)
     This method returns the call options of the specified call or undef.

$st = $info->startTime ($index)
     This method returns the start time of the specified call or undef.

$ut = $info->upTime ($index)
     This method returns the up time of the specified call or undef.

$oct = $info->octetsReceived ($index)
     This method returns the octets received on the specified call or
     undef.

$oct = $info->octetsTransmitted ($index)
     This method returns the octets transmitted on the specified call or
     undef.

$num = $info->callingNumber ($index)
     This method returns the calling number of the specified call or undef.

$num = $info->calledNumber ($index)
     This method returns the called number of the specified call or undef.

$reason = $info->upReason ($index)
     This method returns the reason for the specified call going up or
     undef.

$reason = $info->downReason ($index)
     This method returns the reason for the specified call going down or
     undef.

$str = $info->toString ()
     This method returns a textual representation of this object.

COPYRIGHT
=========

   Copyright 1999-2000 Merlin Hughes.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Merlin Hughes <merlin@merlin.org>


File: pm.info,  Node: Device/ISDN/OCLM/ManualStatistics,  Next: Device/ISDN/OCLM/SPStatistics,  Prev: Device/ISDN/OCLM/LastStatistics,  Up: Module List

OCLM manual call statistics
***************************

NAME
====

   Device::ISDN::OCLM::ManualStatistics - OCLM manual call statistics

SYNOPSIS
========

     $status = $lanmodem->getManualStatistics ();
     ...
     $info = $lanmodem->manualStatistics ();
     $sp = $info->serviceProvider (1);

DESCRIPTION
===========

   This class encapsulates 3com OCLM manual call statistics, including
known service providers and whether or not they are currently connected.

CONSTRUCTORS
============

   Extract instances of this class from *Device::ISDN::OCLM::LanModem*.

METHODS
=======

   The following methods are provided:

$copy = $info->clone ()
     This method returns a clone of this object.

$sp = $info->serviceProvider ($index)
     This method returns the name of the service provider at the specified
     index (1-offset) or undef. Beware of *TempSvcProvider* as this is not
     a normal service provider.

$st = $info->callStatus ($index)
     This method returns the call status of the service provider at the
     specified index (1-offset) or undef. Typically this will be *Down* or
     *Up (1B)* or something like that.

$cm = $info->command ($index)
     This method returns the command hyperlink of the service provider at
     the specified index (1-offset) or undef. Typically this will be
     *CALL1.HTM* or *DISC1.htm* or something like that.

$str = $info->toString ()
     This method returns a textual representation of this object.

COPYRIGHT
=========

   Copyright 1999-2000 Merlin Hughes.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Merlin Hughes <merlin@merlin.org>


File: pm.info,  Node: Device/ISDN/OCLM/SPStatistics,  Next: Device/ISDN/OCLM/Statistics,  Prev: Device/ISDN/OCLM/ManualStatistics,  Up: Module List

OCLM service provider statistics
********************************

NAME
====

   Device::ISDN::OCLM::SPStatistics - OCLM service provider statistics

SYNOPSIS
========

     $status = $lanmodem->getSPStatistics ();
     ...
     $info = $lanmodem->spStatistics ();
     $sp = $info->providerName (1);

DESCRIPTION
===========

   This class encapsulates 3com OCLM service provider statistics, including
total call time, failures, etc.

   This class is a subclass of *Device::ISDN::OCLM::Statistics*.

CONSTRUCTORS
============

   Extract instances of this class from *Device::ISDN::OCLM::LanModem*.

METHODS
=======

   The following methods are provided: For most calls, a provider index
must be specified; this should probably range from 1 through 5.

$copy = $info->clone ()
     This method returns a clone of this object.

$type = $info->providerName ($index)
     This method returns the name of the specified provider or undef.

$dir = $info->successes ($index)
     This method returns the number of successful connections to the
     specified provider or undef.

$dir = $info->failures ($index)
     This method returns the number of failed connections to the specified
     provider or undef.

$dir = $info->octetsReceived ($index)
     This method returns the number of octets received from the specified
     provider or undef.

$dir = $info->octetsTransmitted ($index)
     This method returns the number of octets transmitted to the specified
     provider or undef.

$dir = $info->connectTime ($index)
     This method returns the total connect time with the specified
     provider or undef.

$str = $info->toString ()
     This method returns a textual representation of this object.

COPYRIGHT
=========

   Copyright 1999-2000 Merlin Hughes.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Merlin Hughes <merlin@merlin.org>


File: pm.info,  Node: Device/ISDN/OCLM/Statistics,  Next: Device/ISDN/OCLM/SystemStatistics,  Prev: Device/ISDN/OCLM/SPStatistics,  Up: Module List

OCLM statistics superclass
**************************

NAME
====

   Device::ISDN::OCLM::Statistics - OCLM statistics superclass

SYNOPSIS
========

     $fields = $info->supportedFields ();
     foreach my $field (@{$fields}) {
       ...
     }

DESCRIPTION
===========

   This is the superclass of various OCLM statistics classes.

METHODS
=======

   The following methods are provided:

$copy = $info->clone ()
     This method returns a clone of the subclass.

$fields = $lanmodem->suppoertedFields ()
     This method returns a reference to a list of all the statistics fields
     supported by the subclass.

$str = $lanmodem->toString ()
     This method returns a textual representation of the subclass.

COPYRIGHT
=========

   Copyright 1999-2000 Merlin Hughes.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Merlin Hughes <merlin@merlin.org>


File: pm.info,  Node: Device/ISDN/OCLM/SystemStatistics,  Next: Dialog,  Prev: Device/ISDN/OCLM/Statistics,  Up: Module List

OCLM system statistics
**********************

NAME
====

   Device::ISDN::OCLM::SystemStatistics - OCLM system statistics

SYNOPSIS
========

     $status = $lanmodem->getSystemStatistics ();
     ...
     $info = $lanmodem->systemStatistics ();
     $upTime = $info->upTime ();

DESCRIPTION
===========

   This class encapsulates 3com OCLM system statistics, including serial
number, firmware version, etc.

   This class is a subclass of *Device::ISDN::OCLM::Statistics*.

CONSTRUCTORS
============

   Extract instances of this class from *Device::ISDN::OCLM::LanModem*.

METHODS
=======

   The following methods are provided:

$copy = $info->clone ()
     This method returns a clone of this object.

$id = $info->productID ()
     This method returns the device product ID.

$sn = $info->serialNumber ()
     This method returns the device serial number.

$addr = $info->ethernetAddress ()
     This method returns the device ethernet address. Note that this is
     the NIC address, not the IP address.

$sv = $info->systemVersion ()
     This method returns the device system software version.

$bv = $info->bootVersion ()
     This method returns the device boot software version.

$ut = $info->upTime ()
     This method returns the device up-time.

$dat = $info->date ()
     This method returns the device date.

$tim = $info->upTime ()
     This method returns the device time.

$str = $info->toString ()
     This method returns a textual representation of this object.

COPYRIGHT
=========

   Copyright 1999-2000 Merlin Hughes.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Merlin Hughes <merlin@merlin.org>


File: pm.info,  Node: Dialog,  Next: Digest,  Prev: Device/ISDN/OCLM/SystemStatistics,  Up: Module List

Perl interface to `dialog(3)' in this node
******************************************

NAME
====

   *Dialog* - Perl interface to `dialog(3)' in this node

SYNOPSIS
========

     B<use Dialog;>

     #now we are creating the new dialog window
     $dlg  = Dialog->new(title, y,x,height,width);
     #inserting input line
     $line = $dlg->inputline(name, y, x, width, text);
     #adding button
     $btn  = $dlg->button(name, y, x, text, result);
     #and text label
     $labl = $dlg->label(name, y, x, text);
     #and now running all the stuff
     $res  = $dlg->run;

DESCRIPTION
===========

   Debauched Perl interface to `dialog(3)' in this node. Seems to work
somehow.  At least it's been working as v0.01 for 3-4 years at
*http://www.vlink.ru/* before I decided to donate it free as v0.02.

   The idea itself of *$dlg->run*, *$obj->draw* etc was stolen cynically
from Borland Turbo Vision library. Sorry, guys, and if it breaks any
copyrights, please, let me know. Trust me, I haven't got any profit from
this stuff yet. Hopefully will haven't.

   Read `"SEE ALSO"' in this node and maybe it helps.

   Besides `"SYNOPSIS"' in this node the next OOP tricks are available:

     $dlg->redraw;
     $mr = $dlg->modalresult;
     $dlg->modalresult(number);
     $obj = $dlg->object(name);
     $obj = $dlg->current;
     $dlg->current(name);
     $dlg->current($obj);
     $text = $obj->data;
     $obj->data(newtext);
     $tabstop = $obj->tabstop;
     $obj->tabstop(boolean);
     $name = $obj->name;

   And, of course, good ancient non-OOP functions:

     Dialog::<many-many-consts>;
     Dialog::Const::<yet-same-and-other-consts>;
     void Dialog::Init(); /* only use it if there are no Dialog->new statements */
     void Dialog::Exit(); /* the same note */
     void Dialog::draw_shadow(y, x, h, w, win=stdscr);
     void Dialog::draw_box(y, x, h, w, box, border, win=stdscr);
     int Dialog::line_edit(y, x, w, box, border, win=stdscr);
     WINDOW *Dialog::stdscr();
     void Dialog::refresh();
     int Dialog::ungetch(ch);
     void Dialog::attrset(attr);
     void Dialog::mvprintw(y, x, s);
     void Dialog::gotoyx(y, x);
     int Dialog::getch();
     int Dialog::YesNo(title, prompt, h, w);
     int Dialog::PrgBox(title, line, h, w, pause, use_shell);
     int Dialog::MsgBox(title, prompt, h, w, pause);
     int Dialog::TextBox(title, file, h, w);
     str Dialog::Menu(title, prompt, h, w, menu_h, ...);
     str Dialog::RadioList(title, prompt, h, w, list_h, ...);
     array Dialog::CheckList(title, prompt, h, w, list_h, ...);
     str Dialog::InputBox(title, prompt, h, w, str);
     int Dialog::Y();
     int Dialog::X();

   Strings passed to Menu, CheckList and RadioList may contain single zero
char (ASCII 0) which delimites menu columns. You may, of course, pass such
strings into other routines, but it will be your pain yet.

   And, at all, see test.pl and try to understand anything.

   If you have any suggestions and/or contributions, please, don't
hesitate to send me.

AUTHOR
======

   Michael Samanov <samanov@yahoo.com>

SEE ALSO
========

   dialog.h, dialog(1), dialog(3), ncurses(3).


File: pm.info,  Node: Digest,  Next: Digest/HMAC,  Prev: Dialog,  Up: Module List

Modules that calculate message digests
**************************************

NAME
====

   Digest:: - Modules that calculate message digests

SYNOPSIS
========

     $md2 = Digest->MD2;
     $md5 = Digest->MD5;

     $sha1 = Digest->SHA1;
     $sha1 = Digest->new("SHA-1");

     $hmac = Digest->HMAC_MD5($key);

DESCRIPTION
===========

   The `Digest::' modules calculate digests, also called "fingerprints" or
"hashes", of some data, called a message.  The digest is some small fixed
size string.  The actual size of the digest depend of the algorithm used.
The message is simply a sequence of arbitrary bytes.

   An important property of the digest algorithms is that the digest is
*likely* to change if the message change in some way.  Another property is
that digest functions are one-way functions, i.e. it should be *hard* to
find a message that correspond to some given digest.  Algorithms differ in
how "likely" and how "hard", as well as how efficient they are to compute.

   All `Digest::' modules provide the same programming interface.  A
functional interface for simple use, as well as an object oriented
interface that can handle messages of arbitrary length and which can read
files directly.

   The digest can be delivered in three formats:

binary
     This is the most compact form, but it is not well suited for printing
     or embedding in places that can't handle arbitrary data.

hex
     A twice as long string of (lowercase) hexadecimal digits.

base64
     A string of portable printable characters.  This is the base64 encoded
     representation of the digest with any trailing padding removed.  The
     string will be about 30% longer than the binary version.  *Note
     MIME/Base64: MIME/Base64, tells you more about this encoding.

   The functional interface is simply importable functions with the same
name as the algorithm.  The functions take the message as argument and
return the digest.  Example:

     use Digest::MD5 qw(md5);
     $digest = md5($message);

   There are also versions of the functions with "_hex" or "_base64"
appended to the name, which returns the digest in the indicated form.

OO INTERFACE
============

   The following methods are available for all `Digest::' modules:

$ctx = Digest->XXX($arg,...)
$ctx = Digest->new(XXX => $arg,...)
$ctx = Digest::XXX->new($arg,...)
     The constructor returns some object that encapsulate the state of the
     message-digest algorithm.  You can add data to the object and finally
     ask for the digest.  The "XXX" should of course be replaced by the
     proper name of the digest algorithm you want to use.

     The two first forms are simply syntactic sugar which automatically
     load the right module on first use.  The second form allow you to use
     algorithm names which contains letters which are not legal perl
     identifiers, e.g. "SHA-1".

     If new() is called as a instance method (i.e. $ctx->new) it will just
     reset the state the object to the state of a newly created object.  No
     new object is created in this case, and the return value is the
     reference to the object (i.e. $ctx).

$ctx->reset
     This is just an alias for $ctx->new.

$ctx->add($data,...)
     The $data provided as argument are appended to the message we
     calculate the digest for.  The return value is the $ctx object itself.

$ctx->addfile($io_handle)
     The $io_handle is read until EOF and the content is appended to the
     message we calculate the digest for.  The return value is the $ctx
     object itself.

$ctx->digest
     Return the binary digest for the message.

     Note that the digest operation is effectively a destructive,
     read-once operation. Once it has been performed, the $ctx object is
     automatically reset and can be used to calculate another digest value.

$ctx->hexdigest
     Same as $ctx->digest, but will return the digest in hexadecimal form.

$ctx->b64digest
     Same as $ctx->digest, but will return the digest as a base64 encoded
     string.

SEE ALSO
========

   *Note Digest/MD5: Digest/MD5,, *Note Digest/SHA1: Digest/SHA1,, *Note
Digest/HMAC: Digest/HMAC,, *Note Digest/MD2: Digest/MD2,

   *Note MIME/Base64: MIME/Base64,

AUTHOR
======

   Gisle Aas <gisle@aas.no>

   The `Digest::' interface is based on the interface originally developed
by Neil Winton for his MD5 module.


File: pm.info,  Node: Digest/HMAC,  Next: Digest/HMAC_MD5,  Prev: Digest,  Up: Module List

Keyed-Hashing for Message Authentication
****************************************

NAME
====

   Digest::HMAC - Keyed-Hashing for Message Authentication

SYNOPSIS
========

     # Functional style
     use Digest::HMAC qw(hmac hmac_hex);
     $digest = hmac($data, $key, \&myhash);
     print hmac_hex($data, $key, \&myhash);

     # OO style
     use Digest::HMAC;
     $hmac = Digest::HMAC->new($key, "Digest::MyHash");

     $hmac->add($data);
     $hmac->addfile(*FILE);

     $digest = $hmac->digest;
     $digest = $hmac->hexdigest;
     $digest = $hmac->b64digest;

DESCRIPTION
===========

   HMAC is used for message integrity checks between two parties that
share a secret key, and works in combination with some other Digest
algorithm, usually MD5 or SHA-1.  The HMAC mechanism is described in RFC
2104.

   HMAC follow the common `Digest::' interface, but the constructor takes
the secret key and the name of some other simple `Digest::' as argument.

SEE ALSO
========

   *Note Digest/HMAC_MD5: Digest/HMAC_MD5,, *Note Digest/HMAC_SHA1:
Digest/HMAC_SHA1,

   RFC 2104

AUTHORS
=======

   Graham Barr <gbarr@ti.com>, Gisle Aas <gisle@aas.no>


File: pm.info,  Node: Digest/HMAC_MD5,  Next: Digest/HMAC_SHA1,  Prev: Digest/HMAC,  Up: Module List

Keyed-Hashing for Message Authentication
****************************************

NAME
====

   Digest::HMAC_MD5 - Keyed-Hashing for Message Authentication

SYNOPSIS
========

     # Functional style
     use Digest::HMAC_MD5 qw(hmac_md5 hmac_md5_hex);
     $digest = hmac_md5($data, $key);
     print hmac_md5_hex($data, $key);

     # OO style
     use Digest::HMAC_MD5;
     $hmac = Digest::HMAC_MD5->new($key);

     $hmac->add($data);
     $hmac->addfile(*FILE);

     $digest = $hmac->digest;
     $digest = $hmac->hexdigest;
     $digest = $hmac->b64digest;

DESCRIPTION
===========

   This module provide HMAC-MD5 hashing.

SEE ALSO
========

   *Note Digest/HMAC: Digest/HMAC,, *Note Digest/MD5: Digest/MD5,, *Note
Digest/HMAC_SHA1: Digest/HMAC_SHA1,

AUTHOR
======

   Gisle Aas <gisle@aas.no>


File: pm.info,  Node: Digest/HMAC_SHA1,  Next: Digest/MD2,  Prev: Digest/HMAC_MD5,  Up: Module List

Keyed-Hashing for Message Authentication
****************************************

NAME
====

   Digest::HMAC_SHA1 - Keyed-Hashing for Message Authentication

SYNOPSIS
========

     # Functional style
     use Digest::HMAC_SHA1 qw(hmac_sha1 hmac_sha1_hex);
     $digest = hmac_sha1($data, $key);
     print hmac_sha1_hex($data, $key);

     # OO style
     use Digest::HMAC_SHA1;
     $hmac = Digest::HMAC_SHA1->new($key);

     $hmac->add($data);
     $hmac->addfile(*FILE);

     $digest = $hmac->digest;
     $digest = $hmac->hexdigest;
     $digest = $hmac->b64digest;

DESCRIPTION
===========

   This module provide HMAC-SHA-1 hashing.

SEE ALSO
========

   *Note Digest/HMAC: Digest/HMAC,, *Note Digest/SHA1: Digest/SHA1,, *Note
Digest/HMAC_MD5: Digest/HMAC_MD5,

AUTHOR
======

   Gisle Aas <gisle@aas.no>


File: pm.info,  Node: Digest/MD2,  Next: Digest/MD4,  Prev: Digest/HMAC_SHA1,  Up: Module List

Perl interface to the MD2 Algorithm
***********************************

NAME
====

   Digest::MD2 - Perl interface to the MD2 Algorithm

SYNOPSIS
========

     # Functional style
     use Digest::MD2  qw(md2 md2_hex md2_base64);

     $digest = md2($data);
     $digest = md2_hex($data);
     $digest = md2_base64($data);

     # OO style
     use Digest::MD2;

     $ctx = Digest::MD2->new;

     $ctx->add($data);
     $ctx->addfile(*FILE);

     $digest = $ctx->digest;
     $digest = $ctx->hexdigest;
     $digest = $ctx->b64digest;

DESCRIPTION
===========

   The `Digest::MD2' module allows you to use the RSA Data Security Inc.
MD2 Message Digest algorithm from within Perl programs.  The algorithm
takes as input a message of arbitrary length and produces as output a
128-bit "fingerprint" or "message digest" of the input.

   The `Digest::MD2' programming interface is identical to the interface
of Digest::MD5.

SEE ALSO
========

   *Note Digest/MD5: Digest/MD5,

COPYRIGHT
=========

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

     Copyright 1998-2000 Gisle Aas.
     Copyright 1990-1992 RSA Data Security, Inc.

AUTHOR
======

   Gisle Aas <gisle@aas.no>


File: pm.info,  Node: Digest/MD4,  Next: Digest/MD5,  Prev: Digest/MD2,  Up: Module List

Perl interface to the RSA Data Security Inc. MD4 Message-Digest Algorithm
*************************************************************************

NAME
====

   Digest::MD4 - Perl interface to the RSA Data Security Inc. MD4
Message-Digest Algorithm

SYNOPSIS
========

     use Digest::MD4;
     
     $context = new Digest::MD4;
     $context->reset();
     
     $context->add(LIST);
     $context->addfile(HANDLE);
     
     $digest = $context->digest();
     $string = $context->hexdigest();

     $digest = Digest::MD4->hash(SCALAR);
     $string = Digest::MD4->hexhash(SCALAR);

DESCRIPTION
===========

   The *Digest::MD4* module allows you to use the RSA Data Security Inc.
MD4 Message Digest algorithm from within Perl programs.

   A new MD4 context object is created with the new operation.  Multiple
simultaneous digest contexts can be maintained, if desired.  The context
is updated with the add operation which adds the strings contained in the
LIST parameter. Note, however, that `add('foo', 'bar')', `add('foo')'
followed by `add('bar')' and `add('foobar')' should all give the same
result.

   The final message digest value is returned by the digest operation as a
16-byte binary string. This operation delivers the result of add
operations since the last new or reset operation. Note that the digest
operation is effectively a destructive, read-once operation. Once it has
been performed, the context must be reset before being used to calculate
another digest value.

   Several convenience functions are also provided. The *addfile*
operation takes an open file-handle and reads it until end-of file in 1024
byte blocks adding the contents to the context. The file-handle can either
be specified by name or passed as a type-glob reference, as shown in the
examples below. The *hexdigest* operation calls digest and returns the
result as a printable string of hexdecimal digits. This is exactly the
same operation as performed by the unpack operation in the examples below.

   The hash operation can act as either a static member function (ie you
invoke it on the MD4 class as in the synopsis above) or as a normal
virtual function. In both cases it performs the complete MD4 cycle (reset,
add, digest) on the supplied scalar value. This is convenient for handling
small quantities of data. When invoked on the class a temporary context is
created. When invoked through an already created context object, this
context is used. The latter form is slightly more efficient. The *hexhash*
operation is analogous to *hexdigest*.

EXAMPLES
========

     use Digest::MD4;
     
     $md4 = new Digest::MD4;
     $md4->add('foo', 'bar');
     $md4->add('baz');
     $digest = $md4->digest();
     
     print("Digest is " . unpack("H*", $digest) . "\n");

   The above example would print out the message

     Digest is 6df23dc03f9b54cc38a0fc1483df6e21

   provided that the implementation is working correctly.

   Remembering the Perl motto ("There's more than one way to do it"), the
following should all give the same result:

     use Digest::MD4;
     $md4 = new Digest::MD4;

     die "Can't open /etc/passwd ($!)\n" unless open(P, "/etc/passwd");

     seek(P, 0, 0);
     $md4->reset;
     $md4->addfile(P);
     $d = $md4->hexdigest;
     print "addfile (handle name) = $d\n";

     seek(P, 0, 0);
     $md4->reset;
     $md4->addfile(\*P);
     $d = $md4->hexdigest;
     print "addfile (type-glob reference) = $d\n";

     seek(P, 0, 0);
     $md4->reset;
     while (<P>)
     {
         $md4->add($_);
     }
     $d = $md4->hexdigest;
     print "Line at a time = $d\n";

     seek(P, 0, 0);
     $md4->reset;
     $md4->add(<P>);
     $d = $md4->hexdigest;
     print "All lines at once = $d\n";

     seek(P, 0, 0);
     $md4->reset;
     while (read(P, $data, (rand % 128) + 1))
     {
         $md4->add($data);
     }
     $d = $md4->hexdigest;
     print "Random chunks = $d\n";

     seek(P, 0, 0);
     $md4->reset;
     undef $/;
     $data = <P>;
     $d = $md4->hexhash($data);
     print "Single string = $d\n";

     close(P);

NOTE
====

   The MD4 extension may be redistributed under the same terms as Perl.
The MD4 algorithm is defined in RFC1320. The basic C code implementing the
algorithm is derived from that in the RFC and is covered by the following
copyright:

     Copyright (C) 1990-2, RSA Data Security, Inc. All rights reserved.

     License to copy and use this software is granted provided that it
     is identified as the "RSA Data Security, Inc. MD4 Message-Digest
     Algorithm" in all material mentioning or referencing this software
     or this function.

     License is also granted to make and use derivative works provided
     that such works are identified as "derived from the RSA Data
     Security, Inc. MD4 Message-Digest Algorithm" in all material
     mentioning or referencing the derived work.

     RSA Data Security, Inc. makes no representations concerning either
     the merchantability of this software or the suitability of this
     software for any particular purpose. It is provided "as is"
     without express or implied warranty of any kind.

     These notices must be retained in any copies of any part of this
     documentation and/or software.

   This copyright does not prohibit distribution of any version of Perl
containing this extension under the terms of the GNU or Artistic licences.

AUTHOR
======

   The MD4 interface was adapted by Mike McCauley (`mikem@open.com.au'),
based entirely on MD5-1.7, written by Neil Winton
(`N.Winton@axion.bt.co.uk').

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Digest/MD5,  Next: Digest/Perl/MD5,  Prev: Digest/MD4,  Up: Module List

Perl interface to the MD5 Algorithm
***********************************

NAME
====

   Digest::MD5 - Perl interface to the MD5 Algorithm

SYNOPSIS
========

     # Functional style
     use Digest::MD5  qw(md5 md5_hex md5_base64);

     $digest = md5($data);
     $digest = md5_hex($data);
     $digest = md5_base64($data);

     # OO style
     use Digest::MD5;

     $ctx = Digest::MD5->new;

     $ctx->add($data);
     $ctx->addfile(*FILE);

     $digest = $ctx->digest;
     $digest = $ctx->hexdigest;
     $digest = $ctx->b64digest;

DESCRIPTION
===========

   The Digest::MD5 module allows you to use the RSA Data Security Inc. MD5
Message Digest algorithm from within Perl programs.  The algorithm takes
as input a message of arbitrary length and produces as output a 128-bit
"fingerprint" or "message digest" of the input.

   The Digest::MD5 module provide a procedural interface for simple use,
as well as an object oriented interface that can handle messages of
arbitrary length and which can read files directly.

   A binary digest will be 16 bytes long.  A hex digest will be 32
characters long.  A base64 digest will be 22 characters long.

FUNCTIONS
=========

   The following functions can be exported from the Digest::MD5 module.
No functions are exported by default.

md5($data,...)
     This function will concatenate all arguments, calculate the MD5 digest
     of this "message", and return it in binary form.

md5_hex($data,...)
     Same as md5(), but will return the digest in hexadecimal form.

md5_base64($data,...)
     Same as md5(), but will return the digest as a base64 encoded string.

METHODS
=======

   The following methods are available:

$md5 = Digest::MD5->new
     The constructor returns a new Digest::MD5 object which encapsulate
     the state of the MD5 message-digest algorithm.  You can add data to
     the object and finally ask for the digest.

     If called as a instance method (i.e. $md5->new) it will just reset the
     state the object to the state of a newly created object.  No new
     object is created in this case.

$md5->reset
     This is just an alias for $md5->new.

$md5->add($data,...)
     The $data provided as argument are appended to the message we
     calculate the digest for.  The return value is the $md5 object itself.

$md5->addfile($io_handle)
     The $io_handle is read until EOF and the content is appended to the
     message we calculate the digest for.  The return value is the $md5
     object itself.

$md5->digest
     Return the binary digest for the message.

     Note that the digest operation is effectively a destructive,
     read-once operation. Once it has been performed, the Digest::MD5
     object is automatically reset and can be used to calculate another
     digest value.

$md5->hexdigest
     Same as $md5->digest, but will return the digest in hexadecimal form.

$md5->b64digest
     Same as $md5->digest, but will return the digest as a base64 encoded
     string.

EXAMPLES
========

   The simplest way to use this library is to import the md5_hex()
function (or one of its cousins):

     use Digest::MD5 qw(md5_hex);
     print "Digest is ", md5_hex("foobarbaz"), "\n";

   The above example would print out the message

     Digest is 6df23dc03f9b54cc38a0fc1483df6e21

   provided that the implementation is working correctly.  The same
checksum can also be calculated in OO style:

     use Digest::MD5;
     
     $md5 = Digest::MD5->new;
     $md5->add('foo', 'bar');
     $md5->add('baz');
     $digest = $md5->hexdigest;
     
     print "Digest is $digest\n";

   With OO style you can break the message arbitrary.  This means that we
are no longer limited to have space for the whole message in memory, i.e.
we can handle messages of any size.

   This is useful when calculating checksum for files:

     use Digest::MD5;

     my $file = shift || "/etc/passwd";
     open(FILE, $file) or die "Can't open '$file': $!";
     binmode(FILE);

     $md5 = Digest::MD5->new;
     while (<FILE>) {
         $md5->add($_);
     }
     close(FILE);
     print $md5->b64digest, " $file\n";

   Or we can use the builtin addfile method for more efficient reading of
the file:

     use Digest::MD5;

     my $file = shift || "/etc/passwd";
     open(FILE, $file) or die "Can't open '$file': $!";
     binmode(FILE);

     print Digest::MD5->new->addfile(*FILE)->hexdigest, " $file\n";

SEE ALSO
========

   *Note Digest: Digest,, *Note Digest/MD2: Digest/MD2,, *Note
Digest/SHA1: Digest/SHA1,, *Note Digest/HMAC: Digest/HMAC,

   `md5sum(1)' in this node

   RFC 1321

COPYRIGHT
=========

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

     Copyright 1998-2000 Gisle Aas.
     Copyright 1995-1996 Neil Winton.
     Copyright 1991-1992 RSA Data Security, Inc.

   The MD5 algorithm is defined in RFC 1321. The basic C code implementing
the algorithm is derived from that in the RFC and is covered by the
following copyright:


     Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
     rights reserved.

     License to copy and use this software is granted provided that it is
     identified as the "RSA Data Security, Inc. MD5 Message-Digest
     Algorithm" in all material mentioning or referencing this software or
     this function.

     License is also granted to make and use derivative works provided
     that such works are identified as "derived from the RSA Data
     Security, Inc. MD5 Message-Digest Algorithm" in all material
     mentioning or referencing the derived work.

     RSA Data Security, Inc. makes no representations concerning either
     the merchantability of this software or the suitability of this
     software for any particular purpose. It is provided "as is" without
     express or implied warranty of any kind.

     These notices must be retained in any copies of any part of this
     documentation and/or software.

   This copyright does not prohibit distribution of any version of Perl
containing this extension under the terms of the GNU or Artistic licenses.

AUTHORS
=======

   The original MD5 interface was written by Neil Winton
(`N.Winton@axion.bt.co.uk').

   This release was made by Gisle Aas <gisle@aas.no>


File: pm.info,  Node: Digest/Perl/MD5,  Next: Digest/SHA1,  Prev: Digest/MD5,  Up: Module List

Perl implementation of Ron Rivests MD5 Algorithm
************************************************

NAME
====

   Digest::MD5::Perl - Perl implementation of Ron Rivests MD5 Algorithm

DISCLAIMER
==========

   This is not an interface (like Digest::MD5) but a Perl implementation
of MD5.  It is written in perl only and because of this it is slow but it
works without C-Code.  You should use Digest::MD5 instead of this module
if it is available.  This module is only usefull for


     computers where you cannot install Digest::MD5 (e.g. lack of a
     C-Compiler)


     encrypting only small amounts of data (less than one million bytes).
     I use it to hash passwords.


     educational purposes

SYNOPSIS
========

     # Functional style
     use Digest::MD5  qw(md5 md5_hex md5_base64);

     $hash = md5 $data;
     $hash = md5_hex $data;
     $hash = md5_base64 $data;

     # OO style
     use Digest::MD5;

     $ctx = Digest::MD5->new;

     $ctx->add($data);
     $ctx->addfile(*FILE);

     $digest = $ctx->digest;
     $digest = $ctx->hexdigest;
     $digest = $ctx->b64digest;

DESCRIPTION
===========

   This modules has the same interface as the much faster Digest::MD5. So
you can easily exchange them, e.g.

     BEGIN {
       eval {
         require Digest::MD5;
         import Digest::MD5 'md5_hex'
       };
       if ($@) { # ups, no Digest::MD5
         require Digest::Perl::MD5;
         import Digest::Perl::MD5 'md5_hex'
       }
     }

   If the Digest::MD5 module is available it is used and if not you take
`Digest::Perl::MD5'.

   You can also install the Perl part of Digest::MD5 together with
Digest::Perl::MD5 and use Digest::MD5 as normal, it falls back to
Digest::Perl::MD5 if it cannot load its object files.

   For a detailed Documentation see the Digest::MD5 module.

EXAMPLES
========

   The simplest way to use this library is to import the md5_hex()
function (or one of its cousins):

     use Digest::Perl::MD5 'md5_hex';
     print 'Digest is ', md5_hex('foobarbaz'), "\n";

   The above example would print out the message

     Digest is 6df23dc03f9b54cc38a0fc1483df6e21

   provided that the implementation is working correctly.  The same
checksum can also be calculated in OO style:

     use Digest::MD5;
     
     $md5 = Digest::MD5->new;
     $md5->add('foo', 'bar');
     $md5->add('baz');
     $digest = $md5->hexdigest;
     
     print "Digest is $digest\n";

LIMITATIONS
===========

   This implementation of the MD5 algorithm has some limitations:


     It's slow, very slow. I've done my very best but Digest::MD5 is still
     about 135 times faster.  You can only encrypt Data up to one million
     bytes in an acceptable time. But it's very usefull for encrypting
     small amounts of data like passwords.


     You can only encrypt up to 2^32 bits = 512 MB on 32bit archs. You
     should use Digest::MD5 for those amounts of data.


     `Digest::Perl::MD5' loads all data to encrypt into memory. This is a
     todo.

SEE ALSO
========

   *Note Digest/MD5: Digest/MD5,

   `md5sum(1)' in this node

   RFC 1321

COPYRIGHT
=========

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

     Copyright 2000 Christian Lackas, Imperia Software Solutions
     Copyright 1998-1999 Gisle Aas.
     Copyright 1995-1996 Neil Winton.
     Copyright 1991-1992 RSA Data Security, Inc.

   The MD5 algorithm is defined in RFC 1321. The basic C code implementing
the algorithm is derived from that in the RFC and is covered by the
following copyright:


     Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
     rights reserved.

     License to copy and use this software is granted provided that it is
     identified as the "RSA Data Security, Inc. MD5 Message-Digest
     Algorithm" in all material mentioning or referencing this software or
     this function.

     License is also granted to make and use derivative works provided
     that such works are identified as "derived from the RSA Data
     Security, Inc. MD5 Message-Digest Algorithm" in all material
     mentioning or referencing the derived work.

     RSA Data Security, Inc. makes no representations concerning either
     the merchantability of this software or the suitability of this
     software for any particular purpose. It is provided "as is" without
     express or implied warranty of any kind.

     These notices must be retained in any copies of any part of this
     documentation and/or software.

   This copyright does not prohibit distribution of any version of Perl
containing this extension under the terms of the GNU or Artistic licenses.

AUTHORS
=======

   The original MD5 interface was written by Neil Winton
(`N.Winton@axion.bt.co.uk').

   Digest::MD5 was made by Gisle Aas <gisle@aas.no> (I took his Interface
and part of the documentation)

   Thanks to Guido Flohr for his 'use integer'-hint.

   This release was made by Christian Lackas <delta@clackas.de>.


File: pm.info,  Node: Digest/SHA1,  Next: Digest/Tiger,  Prev: Digest/Perl/MD5,  Up: Module List

Perl interface to the SHA-1 Algorithm
*************************************

NAME
====

   Digest::SHA1 - Perl interface to the SHA-1 Algorithm

SYNOPSIS
========

     # Functional style
     use Digest::SHA1  qw(sha1 sha1_hex sha1_base64);

     $digest = sha1($data);
     $digest = sha1_hex($data);
     $digest = sha1_base64($data);

     # OO style
     use Digest::SHA1;

     $ctx = Digest::SHA1->new;

     $ctx->add($data);
     $ctx->addfile(*FILE);

     $digest = $ctx->digest;
     $digest = $ctx->hexdigest;
     $digest = $ctx->b64digest;

DESCRIPTION
===========

   The `Digest::SHA1' module allows you to use the NIST SHA-1 message
digest algorithm from within Perl programs.  The algorithm takes as input
a message of arbitrary length and produces as output a 160-bit
"fingerprint" or "message digest" of the input.

   The `Digest::SHA1' module provide a procedural interface for simple
use, as well as an object oriented interface that can handle messages of
arbitrary length and which can read files directly.

   A binary digest will be 20 bytes long.  A hex digest will be 40
characters long.  A base64 digest will be 27 characters long.

FUNCTIONS
=========

   The following functions can be exported from the `Digest::SHA1' module.
No functions are exported by default.

sha1($data,...)
     This function will concatenate all arguments, calculate the SHA-1
     digest of this "message", and return it in binary form.

sha1_hex($data,...)
     Same as sha1(), but will return the digest in hexadecimal form.

sha1_base64($data,...)
     Same as sha1(), but will return the digest as a base64 encoded string.

METHODS
=======

   The `Digest::SHA1' module provide the standard `Digest' OO-interface.
The constructor looks like this:

$sha1 = Digest->new('SHA-1')

$sha1 = Digest::SHA1->new
     The constructor returns a new `Digest::SHA1' object which encapsulate
     the state of the SHA-1 message-digest algorithm.  You can add data to
     the object and finally ask for the digest using the methods described
     in *Note Digest: Digest,.

SEE ALSO
========

   *Note Digest: Digest,, *Note Digest/HMAC_SHA1: Digest/HMAC_SHA1,, *Note
Digest/MD5: Digest/MD5,

   http://www.itl.nist.gov/fipspubs/fip180-1.htm

COPYRIGHT
=========

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

     Copyright 1999-2000 Gisle Aas.
     Copyright 1997 Uwe Hollerbach.

AUTHORS
=======

   Peter C. Gutmann, Uwe Hollerbach <uh@alumni.caltech.edu>, Gisle Aas
<gisle@aas.no>


File: pm.info,  Node: Digest/Tiger,  Next: Dir/Purge,  Prev: Digest/SHA1,  Up: Module List

a module that implements the tiger hash
***************************************

NAME
====

   Digest::Tiger - a module that implements the tiger hash

SYNOPSIS
========

     use Digest::Tiger;

     # hash() returns a 192 bit hash
     my $hash = Digest::Tiger::hash('Tiger')

     # hexhash() returns a hex representation of the 192 bits...
     # $hexhash should be '9F00F599072300DD276ABB38C8EB6DEC37790C116F9D2BDF'
     my $hexhash = Digest::Tiger::hexhash('Tiger')

DESCRIPTION
===========

   A perl module that implements the tiger hash, which is believed to be
secure and runs quickly on 64-bit processors.

AUTHOR
======

   Perl interface by Clinton Wong, reference C code used by Digest::Tiger
supplied by Ross Anderson and Eli Biham.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

     http://www.cs.technion.ac.il/~biham/Reports/Tiger/


File: pm.info,  Node: Dir/Purge,  Next: DirHandle,  Prev: Digest/Tiger,  Up: Module List

Purge directories to a given number of files.
*********************************************

NAME
====

   Dir::Purge - Purge directories to a given number of files.

SYNOPSIS
========

     perl -MDir::Purge -e 'purgedir (5, @ARGV)' /spare/backups

     use Dir::Purge;
     purgedir ({keep => 5, strategy => "by_age", verbose => 1}, "/spare/backups");

     use Dir::Purge qw(purgedir_by_age);
     purgedir_by_age (5, "/spare/backups");

DESCRIPTION
===========

   Dir::Purge implements functions to reduce the number of files in a
directory according to a strategy. It currently provides one strategy:
removal of files by age.

   By default, the module exports one user subroutine: `purgedir'.

   The first argument of `purgedir' should either be an integer,
indicating the number of files to keep in each of the directories, or a
reference to a hash with options. In either case, a value for the number
of files to keep is mandatory.

   The other arguments are the names of the directories that must be
purged. Note that this process is not recursive. Also, hidden files (file
name starts with a .) and non-plain files (e.g., directories, symbolic
links) are not taken into account.

   All directory arguments and options are checked before anything else is
done. In particular, all arguments should point to existing directories
and the program must have read, write, and search (execute) access to the
directories.

   One additional function, `purgedir_by_age', can be exported on demand,
or called by its fully qualified name. `purgedir_by_age' calls `purgedir'
with the "by age" purge strategy preselected. Since this happens to be the
default strategy for `purgedir', calling `purgedir_by_age' is roughly
equivalent to calling `purgedir'.

WARNING
=======

   Removing files is a quite destructive operation. Supply the test
option, described below, to dry-run before production.

OPTIONS
=======

   Options are suppled by providing a hash reference as the first
argument. The following calls are equivalent:

     purgedir ({keep => 3, test => 1}, "/spare/backups");
     purgedir_by_age ({keep => 3, test => 1}, "/spare/backups");
     purgedir ({strategy => "by_age", keep => 3, test => 1}, "/spare/backups");

   All subroutines take the same arguments.

keep
     The number of files to keep.

     If positive, the newest files will be kept. If negative, the absolute
     value will be used and the oldest files will be kept.

strategy
     Specifies the purge strategy.  Default (and only allowed) value is
     "by_age".

     This option is for `purgedir' only. The other subroutines should not
     be provided with a strategy option.

verbose
     Verbosity of messages. Default value is 1. A value of 0 (zero) will
     suppress messages.

debug
     For internal debugging only.

test
     If true, no files will be removed. For testing.

EXPORT
======

   Subroutine `purgedir' is exported by default.

   Subroutine `purgedir_by_age' may be exported on demand.

   Calling purgedir_by_age() is roughly equivalent to calling purgedir()
with an options hash that includes `strategy =' "by_age">.

   The variable $Dir::Purge::VERSION may be used to inspect the version of
the module.

AUTHOR
======

   Johan Vromans (jvromans@squirrel.nl) wrote this module.

COPYRIGHT AND DISCLAIMER
========================

   This program is Copyright 2000 by Squirrel Consultancy. All rights
reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of either: a) the GNU General Public License as published
by the Free Software Foundation; either version 1, or (at your option) any
later version, or b) the "Artistic License" which comes with Perl.

   This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See either the GNU General Public
License or the Artistic License for more details.


