This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: DBIx/FullTextSearch/StopList,  Next: DBIx/HTMLView,  Prev: DBIx/FullTextSearch,  Up: Module List

Stopwords for DBIx::FullTextSearch
**********************************

NAME
====

   DBIx::FullTextSearch::StopList - Stopwords for DBIx::FullTextSearch

SYNOPSIS
========

     use DBIx::FullTextSearch::StopList;
     # connect to database (regular DBI)
     my $dbh = DBI->connect('dbi:mysql:database', 'user', 'passwd');

     # create a new empty stop word list
     my $sl1 = DBIx::FullTextSearch::StopList->create_empty($dbh, 'sl_web_1');

     # or create a new one with default stop words
     my $sl2 = DBIx::FullTextSearch::StopList->create_default($dbh, 'sl_web_2', 'english');

     # or open an existing one
     my $sl3 = DBIx::FullTextSearch::StopList->open($dbh, 'sl_web_3');

     # add stop words
     $sl1->add_stop_word(['a','in','on','the']);

     # remove stop words
     $sl2->remove_stop_word(['be','because','been','but','by']);

     # check if word is in stoplist
     $bool = $sl1->is_stop_word('in');

     # empty stop words
     $sl3->empty;

     # drop stop word table
     $sl2->drop;

DESCRIPTION
===========

   DBIx::FullTextSearch::StopList provides stop lists that can be used
-*Note DBIx/FullTextSearch: DBIx/FullTextSearch,.  StopList objects can be
reused accross several FullTextSearch objects.

METHODS
=======

CONSTRUCTERS
------------

create_empty
          my $sl = DBIx::FullTextSearch::StopList->create_empty($dbh, $sl_name);

     This class method creates a new StopList object.

create_default
          my $sl = DBIx::FullTextSearch::StopList->create_default($dbh, $sl_name, $language);

     This class method creates a new StopList object, with default words
     loaded in for the given language.  Supported languages include
     Danish, Dutch, English, Finnish, French, German, Italian, Portuguese,
     Spanish, and Swedish.

open
          my $sl = DBIx::FullTextSearch::StopList->open($dbh, $sl_name);

     Opens and returns StopList object

OBJECT METHODS
--------------

add_stop_word
          $sl->add_stop_word(\@stop_words);

     Adds stop words to StopList object.  Expects array reference as
     argument.

remove_stop_word
          $sl->remove_stop_word(\@stop_words);

     Remove stop words from StopList object.

is_stop_word
          $bool = $sl->is_stop_word($stop_word);

     Returns true iff stop_word is StopList object

empty
          $sl->empty;

     Removes all stop words in StopList object.

drop
          $sl->drop;

     Removes table associated with the StopList object.

AUTHOR
======

   Thomas J. Mather, tjmather@alumni.princeton.edu,
http://www.thoughtstore.com/tjmather/perl/ New York, NY, USA

COPYRIGHT
=========

   All rights reserved. This package is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

SEE ALSO
========

   *Note DBIx/FullTextSearch: DBIx/FullTextSearch,


File: pm.info,  Node: DBIx/HTMLView,  Next: DBIx/HTMLView/Bool,  Prev: DBIx/FullTextSearch/StopList,  Up: Module List

For handling DBI relation databases and web interfaces
******************************************************

NAME
====

     DBIx::HTMLView - For handling DBI relation databases and web interfaces

SYNOPSIS
========

   use DBIx::HTMLView; my $dbi=DB("DBI:mSQL:HTMLViewTester:localhost", "",
"",            Table ('Test', Id('id'), Str('testf')),
Table('Test2', Id('id'), Str('str'), Int('nr'))           );

DESCRIPTION
===========

   HTMLView is a set of modules to handle relational SQL databases through
a DBI interface and create web user interfaces to them. Among its features
are the posibility to handle relations in the same manner as fields and it
is easily extended with additional field or relation specifications as
well as custom editors and viewers.

   For a general overview description of the system see the README file,
for a quick start see the test.pl script. It conatins instructions on how
to set up a simple test database and then it preforms all the basic
opperations in a comented manner. There is also a tutorial (not yet
written) describing the basics of relation databases and how to build web
interfaces to them using HTMLView. Finaly there is a man page for every
package describing it's methods and functionality.

   This package contains shourtcuts for the constructors of some of the
basic objects under DBIx::HTMLView that are used to created the database
description structure. This structure describes all the tables in the
database and its fields, and is then used as an interface to the database
and the tables.

   For a description of parameters to the separate functions see the
diffrent packages man pages, eg DB is actualy the new method of
DBIx::HTMLView::DB. Curently we have shourtcuts for the following objects:

     msqlDB
     mysqlDB
     Table
     Int
     Date
     Str
     Bool
     Text
     Id
     N2N
     N2One
     
     For backwards compatibility there is also a DB method calling msqlDB.

METHODS =cut
============

   package DBIx::HTMLView; use strict; use vars qw(@ISA $VERSION @EXPORT);

   $VERSION="0.7";

   require Exporter; require DBIx::HTMLView::DB; require
DBIx::HTMLView::mysqlDB; require DBIx::HTMLView::msqlDB; require
DBIx::HTMLView::Table; require DBIx::HTMLView::Int; require
DBIx::HTMLView::Str; require DBIx::HTMLView::Date; require
DBIx::HTMLView::Bool; require DBIx::HTMLView::Text; require
DBIx::HTMLView::Id; require DBIx::HTMLView::N2N; require
DBIx::HTMLView::N2One; require DBIx::HTMLView::Tree;

   @ISA         = qw(Exporter);  @EXPORT      = qw(DB mysqlDB msqlDB Table
Str Bool Text Id N2N Int N2One Date Tree);

   sub DB {   msqlDB(@_) # For backwards compatibility }

   sub mysqlDB {   DBIx::HTMLView::mysqlDB->new(@_); }

   sub msqlDB {   DBIx::HTMLView::msqlDB->new(@_); }

   sub Table {   DBIx::HTMLView::Table->new(@_); }

   sub Int {   DBIx::HTMLView::Int->new(@_); }

   sub Str {   DBIx::HTMLView::Str->new(@_); }

   sub Date {   DBIx::HTMLView::Date->new(@_); }

   sub Bool {   DBIx::HTMLView::Bool->new(@_); }

   sub Text {   DBIx::HTMLView::Text->new(@_); }

   sub Id {   DBIx::HTMLView::Id->new(@_); }

   sub N2N {   DBIx::HTMLView::N2N->new(@_); }

   sub N2One {   DBIx::HTMLView::N2One->new(@_); }

   sub Tree {   DBIx::HTMLView::Tree->new(@_); }

   1;

   # Local Variables: # mode:              perl # tab-width:         8 #
perl-indent-level: 2 # End:


File: pm.info,  Node: DBIx/HTMLView/Bool,  Next: DBIx/HTMLView/CGIGermanListView,  Prev: DBIx/HTMLView,  Up: Module List

A boolean field
***************

NAME
====

     DBIx::HTMLView::Bool - A boolean field

SYNOPSIS
========

     $fld=$post->fld('testf');
     print $fld->view_html;

DESCRIPTION
===========

   This is a subclass of DBIx::HTMLView::Str used to represent boolean
data (eg true or false). It is represented by a one character field that
is default wither Y or N. The main difference from a Str is that the
default edit_html editor uses a two  <input type=radio ...> buttons to
construct the editor.

   $data of the constructor (see the new method of DBIx::HTMLView::Fld)
can have the following values specified:

   true - the value stored in the databse when this field should represent
 true, default Y.  false - the value stored in the databse when this
field should represent   false, default N.  view_true - the value used to
view a true value for the view_html,   edit_html and view_text methods,
defaule Yes.  view_false - the value used to view a false value for the
view_html,   edit_html and view_text methods, defaule No.

METHODS =cut
============

   package DBIx::HTMLView::Bool; use strict; use Carp;

   use vars qw(@ISA); require DBIx::HTMLView::Bool;  @ISA =
qw(DBIx::HTMLView::Str);

   sub true {   my $self=shift;   if ($self->got_data('true')) {return
$self->data('true')}   return 'Y'; } sub false {   my $self=shift;   if
($self->got_data('false')) {return $self->data('false')}   return 'N'; }
sub view_true {   my $self=shift;   if ($self->got_data('view_true'))
{return $self->data('view_true')}   return 'Yes'; } sub view_false {   my
$self=shift;

     if ($self->got_data('view_false')) {return $self->data('view_false')}
     return 'No';
     }

   sub default_fmt {   my ($self, $kind)=@_;   if ($kind eq 'view_text' ||
$kind eq 'view_html') {     return   '<perl>if ($self->got_val &&
$self->val eq $self->true) {return $self->view_true} else {return
$self->view_false}</perl>';   }   if ($kind eq 'edit_html') {     return
'<perl>if ($self->got_val && $self->val eq $self->true) {'.
    '$val2="";$val1="checked"} else {$val1="";$val2="checked"}'.
  '"";</perl>'.             "<input type='radio' name='<var name>'
value='" . $self->true .             "' <perl>\$val1</perl> >" .
$self->view_true . "&nbsp;&nbsp;" .             "<input type='radio'
name='<var name>' value='" . $self->false .             "'
<perl>\$val2</perl>>" . $self->view_false;

     }
     return DBIx::HTMLView::Field::default_fmt(@_);
     }

   sub sql_create {my$self=shift;$self->db->sql_type("Bool",$self)}

   1;

   # Local Variables: # mode:              perl # tab-width:         8 #
perl-indent-level: 2 # End:


File: pm.info,  Node: DBIx/HTMLView/CGIGermanListView,  Next: DBIx/HTMLView/CGIListView,  Prev: DBIx/HTMLView/Bool,  Up: Module List

A List user interface for DBI databases
***************************************

NAME
====

     DBIx::HTMLView::CGIGermanListView - A List user interface for DBI databases

SYNOPSIS
========

     $view=new DBIx::HTMLView::CGIGermanListView($script, $dbi, $cgi);
     print $view->view_html;

DESCRIPTION
===========

   This is a database viewer/editer using the CGI interface and HTML forms
to present the user interface to the user. It's a very simple interface.
At the top all the tables of the database are listed to allow the user to
select which one to edit (including a + sign for adding a new post, and at
the bottom the selected table is listed.  If the table has more than
defined in {'rows'}, output is split into pages.  Every post has a link to
allow you to show, edit or delete them.  There is also a link to add new
posts to the table.

   To be able to use this you need a cgi script that sets up a few things
and decides which editor to use to edit single posts and to insert default
values and so on... For a simple such script see View.cgi.

   This is a subclass to DBIx::HTMLView::CGIView.  =head1 METHODS =cut

   package DBIx::HTMLView::CGIGermanListView; use strict;

   use vars qw(@ISA); require DBIx::HTMLView::CGIView;  @ISA =
qw(DBIx::HTMLView::CGIView);

   sub new {   my $self=DBIx::HTMLView::CGIView::new(@_); #pass rows via
new HOWTO?    $self->{'view_flds'}=undef;   $self->{'extra_sql'}=undef;
$self->{'page'}=1;   $self->{'rows'}=50;   $self; }

$view->flds_to_view(@flds)
--------------------------

   Specifys which flds to view by listing there names. Default is to view
all fields of a post but none of the relations.

$view->extra_sql($extra)
------------------------

   If you want to add some extra SQL clauses to the end of the select
command they can be given here. This can be used to specify in which order
the posts should appear by giving an ORDER clause.

$view->view_html
----------------

   Returns the html code for the editor as specified by previous methods.


File: pm.info,  Node: DBIx/HTMLView/CGIListView,  Next: DBIx/HTMLView/CGIQueryListView,  Prev: DBIx/HTMLView/CGIGermanListView,  Up: Module List

A List user interface for DBI databases
***************************************

NAME
====

     DBIx::HTMLView::CGIListView - A List user interface for DBI databases

SYNOPSIS
========

     $view=new DBIx::HTMLView::CGIReqEdit($script, $dbi, $cgi);
     print $view->view_html;

DESCRIPTION
===========

   This is a database viewer/editer using the CGI interface and HTML forms
to present the user interface to the user. It's a very simple interface.
At the top all the tables of the database are listed to allow the user to
select which one to edit (including a + sign for adding a new post, and at
the bottom the selected table is listed.  If the table has more than
defined in {'rows'}, output is split into pages.  Every post has a link to
allow you to show, edit or delete them.  There is also a link to add new
posts to the table.

   To be able to use this you need a cgi script that sets up a few things
and decides which editor to use to edit single posts and to insert default
values and so on... For a simple such script see View.cgi.

   This is a subclass to DBIx::HTMLView::CGIView.  =head1 METHODS =cut

   package DBIx::HTMLView::CGIListView; use strict;

   use vars qw(@ISA); require DBIx::HTMLView::CGIView;  @ISA =
qw(DBIx::HTMLView::CGIView);

   sub new {   my $self=DBIx::HTMLView::CGIView::new(@_);

     $self->{'view_flds'}=undef;
     $self->{'extra_sql'}=undef;
     $self->{'page'}=1;
     $self->{'rows'}=50;
     $self;
     }

$view->rows($nr)
----------------

   Specifies how many rows should be displayed on one page. Default is 50.

$view->flds_to_view(@flds)
--------------------------

   Specifies which flds to view by listing there names. Default is to view
all fields of a post but none of the relations.

$view->extra_sql($extra)
------------------------

   If you want to add some extra SQL clauses to the end of the select
command they can be given here. This can be used to specify in which order
the posts should appear by giving an ORDER clause.

$view->view_html
----------------

   Returns the html code for the editor as specified by previous methods.


File: pm.info,  Node: DBIx/HTMLView/CGIQueryListView,  Next: DBIx/HTMLView/CGIReqEdit,  Prev: DBIx/HTMLView/CGIListView,  Up: Module List

A List user interface for DBI databases
***************************************

NAME
====

     DBIx::HTMLView::CGIQueryListView - A List user interface for DBI databases

SYNOPSIS
========

     $view=new DBIx::HTMLView::CGIQueryListView($script, $dbi, $cgi);
     print $view->view_html;

DESCRIPTION
===========

   This is a database viewer/editer using the CGI interface and HTML forms
to present the user interface to the user. It's a very simple interface.
At the top all the tabels of the database is listed to allow the user to
select which one to edit, and at the botom the selected table is listed.
Every post has a link to allow you to show, edit or delete them. There is
also a link to add new posts to the table.

   To be able to use this you need a cgi script that sets up a few things
and decides which editor to use to edit single posts and to insert default
values and so on... For a simple such script see View.cgi.

   This is a subclass to DBIx::HTMLView::CGIView.  =head1 METHODS =cut

   package DBIx::HTMLView::CGIQueryListView; use strict;

   use vars qw(@ISA); require DBIx::HTMLView::CGIView;  @ISA =
qw(DBIx::HTMLView::CGIView);

   sub new {   my $self=DBIx::HTMLView::CGIView::new(@_);

     $self->{'view_flds'}=undef;
     $self->{'extra_sql'}=undef;
     $self;
     }

$view->extra_sql($extra)
------------------------

   If you want to add some extra SQL clauses to the end of the select
command they can be given here. This can be used to specify in which order
the posts should appear by giving an ORDER clause.

$view->view_html
----------------

   Returns the html code for the editor as specified by previous methods.


File: pm.info,  Node: DBIx/HTMLView/CGIReqEdit,  Next: DBIx/HTMLView/CGIReqView,  Prev: DBIx/HTMLView/CGIQueryListView,  Up: Module List

A simple CGI editor for single posts
************************************

NAME
====

     DBIx::HTMLView::CGIListView - A simple CGI editor for single posts

SYNOPSIS
========

     $view=new DBIx::HTMLView::CGIReqEdit($script, $post);
     print $view->view_html;

DESCRIPTION
===========

   This is a post editer using the CGI interface and HTML forms to present
the user interface to the user. It's a very simple interface, that list
all the flds and allows the user to modify.

   A Fld can be taged read-only, and then it will not show up in the list.

METHODS =cut
============

   package DBIx::HTMLView::CGIReqEdit; use strict;

   use vars qw(@ISA); require DBIx::HTMLView::CGIView;  @ISA =
qw(DBIx::HTMLView::CGIView);

$view=DBIx::HTMLView::CGIReqEdit->new($script, $post, $read_only, $cgi)
-----------------------------------------------------------------------

   Creats a new post editor to edit the post $post (a DBIx::HTMLView::Post
object. $read_only should be a regular expretion matching the fields that
should not show up in the editor.

   Note that this is not a secure way to prevent users from getting access
to specific fields as some simple tampering with the html forms passed to
the user will bring up the other tabels as well for editing.

$view->post
-----------

   Returns the post being edited (a DBIx::HTMLView::Post object).

$view->db
---------

   Returns the databse we'r working with (a DBIx::HTMLVIew::Db object).

$view->tab
----------

   Returns the table we'r working with (a DBIx::HTMLVIew::Table object.)

$view->read_only
----------------

   Returns the readonly reg exp as psecified in the constructor parameter
$read_only.

$view->view_html
----------------

   Returns the html code for the editor as specified by previous methods.


File: pm.info,  Node: DBIx/HTMLView/CGIReqView,  Next: DBIx/HTMLView/CGIView,  Prev: DBIx/HTMLView/CGIReqEdit,  Up: Module List

A Requester viewer/editor for DBI databases
*******************************************

NAME
====

     DBIx::HTMLView::CGIReqView - A Requester viewer/editor for DBI databases

SYNOPSIS
========

   use DBIx::HTMLView::CGIListView; use DBIx::HTMLView::CGIReqView;

   my $db="DBI:mSQL:HTMLViewTester:athena.af.lu.se:1114";

   $q = new CGI; if (DBIx::HTMLView::CGIReqView::Handles($q)) { 	$v=new
DBIx::HTMLView::CGIReqView($db, {}, $q); } else {   # Use some other view
list CGIListView for example...  }

   $v->PrintPage("this_file.cgi");

DESCRIPTION
===========

   This is a CGI interface based on the CGIView class (eg a subclass of)
that allows you to edit or view one post in a table. Alla data is shown
and all data except the key is editable, if the $self->{'editable'}
variable is not modified, in which case it should contain a regexp
matching all editable fields. It could be costruncted as
"<field1>|<field2>|<field3>|...".

   By seting the _New key in the CGI query a blank form will show upp for
adding new posts. By setting the key _Edit together with _Id, the vaule of
_Id will be looked up as the key of a post and that post will be presented
for editing.

   Is is also possible to show a post by setting _Show and _Id. The value
of _New, _Edit and _Show are never used and thereby on no importance.

METHODS
=======

$c=new DBIx::HTMLView::CGIReqView($db, $fmt, $query)
====================================================

   Initiats the viewer. $db and $fmt is the database specifier and format
specification as descriped in the DBIx::HTMLView manual. $query is the cgi
query as returned by "new CGI;".

$c->PrintPage($script)
======================

   Will print the html page, with links back to the cgi script $script.

DBIx::HTMLView::CGIReqView::Handles($q)
=======================================

   Returns 1 if this object can handle the request make by $q, otherwise 0.
$q should be an CGI object created with "new CGI";

Author
======

     Hakan Ardo <hakan@debian.org>


File: pm.info,  Node: DBIx/HTMLView/CGIView,  Next: DBIx/HTMLView/DB,  Prev: DBIx/HTMLView/CGIReqView,  Up: Module List

Common CGI functions for the viewers
************************************

NAME
====

     DBIx::HTMLView::CGIView - Common CGI functions for the viewers

SYNOPSIS
========

   package MyCGIViewer

   require DBIx::HTMLView::CGIView;  @ISA = qw(DBIx::HTMLView::CGIView);

   sub new {   my $self=DBIx::HTMLView::CGIView::new(@_);

     # ...
     }

DESCRIPTION
===========

   This class some basic functions that can be used to create cgi
interfaces to a HTMLView database. And is therefor suited as a base class
for viewr or edit classes.

METHODS =cut
============

   package DBIx::HTMLView::CGIView; use strict; use Carp;

$view=DBIx::HTMLView::CGIView->new($script, $db, $cgi)
------------------------------------------------------

   Creates a new CGIView object that will use the url $script for future
requests to the database $db (a DBIx::HTMLVIew::DB object) and $cgi is the
CGI object containing the request we got from the user.

$view->script =head2 $view->script_name
---------------------------------------

   Returns the name of the script we should use for future calls as set by
the $script param to the constructor.

$view->lnk =head2 $view->link_data
----------------------------------

   Returns a string that can be included in a link that will set the
params that is supposed to be presistand between requests. Curent that is:
_Table, the name of the table we are currently working on, _usr, the user
name, and _pw, the password used to access the database.

$view->form_data
----------------

   Will return the same data as $view->link_data but in form of <input
type=hidden ...> tags to be included in a html form instead.

$view->db
---------

   Returns the database (a DBIx::HTMLView::DB object) we'r using, as set
by the $db parameter to the constructor.

$view->cgi
----------

   Returns the CGI object as set by the $cgi parameter to the constructor.

$view->got_cgi
--------------

   Returns true if the CGI object was set by the $cgi parameter to the
constructor.

$view->tab
----------

   Returns the table (a DBIx::HTMLView::Table object) we're currently
working with. Either as specified in the CGI query or the first table
found in the database if none was defined.


File: pm.info,  Node: DBIx/HTMLView/DB,  Next: DBIx/HTMLView/Date,  Prev: DBIx/HTMLView/CGIView,  Up: Module List

A generic DBI databse with SQL interface
****************************************

NAME
====

     DBIx::HTMLView::DB - A generic DBI databse with SQL interface

SYNOPSIS
========

   use DBIx::HTMLView; my $dbi=my
$dbi=DB("DBI:mSQL:HTMLViewTester:localhost", "", "",
Table ('Test', Id('id'), Str('testf'))); my
$hist=$dbi->tab('Test')->list();

DESCRIPTION
===========

   The DB object is usualy only used to represent the top level database
and to access the diffrent tabel objects. But all databse communications
is routed through it.

   This class is intended as a generic base class it is then inherited by
engine specifik classes such as DBIx::HTMLView::msqlDB and
DBIx::HTMLView::mysqlDB. If you plan to use this with another database
engine you'll probably have to atleast overide the insert sub to handle
the assignmet of id values to new posts correctly.

METHODS =cut
============

   package DBIx::HTMLView::DB; use strict;

   use DBI; use Carp;

$dbi=DBIx::HTMLView::DB->new($db, $user, $pass, @tabs) =head2 $dbi=DBIx::HTMLView::DB->new($dbh, @tabs)
-------------------------------------------------------------------------------------------------------

   Creates a new database representation to the database engine represented
by the DBI data_source $db and connect's to it using $user and $pass as
user name and pasword. @tabs is a list of the tables contained in the
database in form of DBIx::HTMLView::Table objects.

   If you'r db needs more initialising than a DBI connect you can
initialise the connection yourself and then pass the dbh (as returned by
the DBI->connect call) using the second form of the constructor.

   The database connection will not be closed untill this object is
destroyed.

$dbi->send($cmd)
----------------

   Will prepare and send the SQL command $cmd to the database and it dies
on errors. The $sth is returned.

$dbi->tab($tab)
---------------

   Returns the DBIx::HTMLView::Table object representing the table named
$tab.

$dbi->tabs
----------

   Returns an array of DBIx::HTMLView::Table objects representing all the
tables in the database.

$dbi->sql_escape
----------------

   Escapes the supplied string to be valid inside an SQL command.  That
is, it changes the string q[I'm a string] to q['I\'m a string'];

$dbi->del($tab, $id)
--------------------

   Deletes the post with id $id form the table $tab (a
DBIx::HTMLView::Table object).

$dbi->update($tab, $post)
-------------------------

   Updates the data in the database of the post represented by $post (a
DBIx::HTMLView::Post object) in the table $tab (a DBIx::HTMLView::Table
object) with the data contained in the $post object.

$dbi->insert($tab, $post)
-------------------------

   Insert the post $post (a DBIx::HTMLView::Post object) into the table
$tab (a DBIx::HTMLView::Table object). This is the method to override if
you need to change the way new post get's their id numbers assigned. This
method should also make sure to set the id fld of $post to the id assigned
to it.

$dbi->sql_create
----------------

   Will create the tables of the database using SQL commands that works
with msql. The database has to be created by hand using msqladmin or
msqlconfig.

$dbi->sql_create_table($table)
------------------------------

   Creates the table $table, a DBIx::HTMLView::Table object, using SQL
commands that works with msql.

$dbi->sql_type($type, $fld)
---------------------------

   Returns the SQL type string used for the type $type of the Fld $fld.
$type should be one of "Id", "Int", "Str", "Text", "Bool", "Date" and $fld
should be a DBIx::HTMLView::Fld object.


File: pm.info,  Node: DBIx/HTMLView/Date,  Next: DBIx/HTMLView/Field,  Prev: DBIx/HTMLView/DB,  Up: Module List

A simple date filed
*******************

NAME
====

     DBIx::HTMLView::Date - A simple date filed

SYNOPSIS
========

     $fld=$post->fld('testf');
     print $fld->view_html;

DESCRIPTION
===========

   This is a subcalss of DBIx::HTMLView::Str used to represent date fields
in the databse as well as the data contained in it. Se the
DBIx::HTMLView::Field and DBIx::HTMLView:.Fld (the superclass of Field)
manpage for info on the methods of this class.


File: pm.info,  Node: DBIx/HTMLView/Field,  Next: DBIx/HTMLView/Fld,  Prev: DBIx/HTMLView/Date,  Up: Module List

Base class for field classes
****************************

NAME
====

     DBIx::HTMLView::Field - Base class for field classes

SYNOPSIS
========

     $fld=$post->fld('testf');
     print $fld->view_html;

DESCRIPTION
===========

   This is a subcalss of DBIx::HTMLView::Fld used to represent fields in
the databse as well as the data contained in it. Except for the methods
decsribed in the DBIx::HTMLView::Fld man page this class contains some
methods for handling the data contain in the field. They are described
below.

   It also contains default implementations of all the virtual methods
except name_vals described in that man page. For viewing this means the
value is used without any formating (both for text and html), and for the
edit_html method a standard <input size=80 ...> tag is used.

   The size 80 can be changed by setting the edit_size key to the wanted
size in the $data hash passed to the new method, see DBIx::HTMLView::Fld.

METHODS =cut
============

   package DBIx::HTMLView::Field; use strict; use Carp;

   use vars qw(@ISA); require DBIx::HTMLView::Fld;  @ISA =
qw(DBIx::HTMLView::Fld);

$fld->val
---------

   Returns the value of this field if it's value is set. otherwise it dies
with "Field conatins no data".

$fld->got_val
-------------

   Return true if the value of this field is set (defined).

$fld->view_fmt($fmt_name, $fmt)
-------------------------------

   Se DBIx::HTMLView::Fld for a general description. As for the format of
the fmt string used here, the following substrings will be replaced with
described values:

   $val - The value of this field $name - The name of this field


File: pm.info,  Node: DBIx/HTMLView/Fld,  Next: DBIx/HTMLView/Fmt,  Prev: DBIx/HTMLView/Field,  Up: Module List

Base class for field and relation classes
*****************************************

NAME
====

     DBIx::HTMLView::Fld - Base class for field and relation classes

SYNOPSIS
========

     $fld=$post->fld('testf');
     print $fld->view_html;

DESCRIPTION
===========

   These objects are used to represent the fields and relations of a table
inside the and the DBIx::HTMLView::Table object as well as the data
contained in those fields and relations in the DBIx::HTMLView::Post
objects.

   This is the base class of all field classes such as
DBIx::HTMLView::Text DBIx::HTMLView::Str and DBIx::HTMLView::Int as well
as the relations such as DBIx::HTMLView::N2N.

METHODS =cut
============

   package DBIx::HTMLView::Fld; use strict; use Carp;

$fld=DBIx::HTMLView::Fld->($name, $data) =head2 $fld=DBIx::HTMLView::Fld->new($name, $val, $tab)
------------------------------------------------------------------------------------------------

   The only time you create this kind of objects is when you create the
DBIx::HTMLView::Table objects of the top level description of the databse
(se DBIx::HTMLView::DB). And in that case it is the first version of the
constructor you use preferable through the shortcuts in DBIx::HTMLView.
$name is a string naming the relation or field while $data is a hashref
with parameters specific to the field or relation kind used. There are a
few parameters that are common though:

   sql_size - The size to be used to store this in the database, eg the
value 100 in the sql type definition CHAR(100).  sql_type - Allows you to
overide the database specific default type to   use for a fld. If this is
defined it will be used as sql type for   this fld.  fmt - A string
specifying how this Fld should be viewed by default. It   is the fmt
string that will be used by view_fmt if no other are   specified, or if
the one specified does not excist. The format of   this string depends on
the type of Fld se the docs to the view_fmt   methods of the diffrent Fld
subclasses for info on it.  fmt_* - You can give each Fld any number of
custom fmts used to view   this fld in diffrent contexts. There are a few
special one:   fmt_view_html, fmt_edit_html, fmt_view_text that are tied
to the   method calls view_html, edit_html, view_text respectivly (eg the
method call view_html is the same as view_fmt('view_html'))

   The second version of the constructor is used by the
DBIx::HTMLView::Table class when it creates copies of its flds, gives them
their data $val and places them in a post. $tab is the
DBIx::HTMLView::Table object the fld belongs to.

   For fields data ($val) is specified as a string or as the first item of
an array referenced to by $val. Relations are represented as a reference
to an array of the id's of the posts being related to.

$fld->name
----------

   Returns the name of the fld.

$fld->data($key)
----------------

   Returns the value of $key set from the $data hashref in the new method.
It dies if the data was not set.

$fld->got_data($key)
--------------------

   Returns true if the value of $key was set in the $data hashref in the
new method.

$fld->set_tab($tab)
-------------------

   Used by DBIx::HTMLView::Table to inform the fld of which table it
belongs to. All fld belongs to either a Table or a Post.

$fld->set_post($post)
---------------------

   Used by DBIx::HTMLView::Post to inform the fld pf which post it belongs
to. All fld belongs to either a Table or a Post.

$fld->tab
---------

   Return the DBIx::HTMLView::Table object this fld belongs to.

$fld->db
--------

   Return the DBIx::HTMLView::Db object this fld belongs to.

$fld->post
----------

   Returns the DBIx::HTMLView::Post object this fld belongs to.

VIRTUAL METHODS
===============

   Those methods are not defined in this class, but are suposed to be
defined in all fld subclasses.

$fld->view_fmt($fmt_name,$fmt)
------------------------------

   Returns a string used to display the contents (value) of the fld.
Usually this is just the value of the fld, but for more complex Fld, like
relations, $fmt_name can be used to specify which fmt that should be used
(the diffrent fmts are defined in the constructor, se the $fld->new
method). If the $fmt param is defined it will be used as the fmt string
insteda of looking up a default one.

$fld->view_html
---------------

   Returns a html string used to display the contents (value) of the fld.

$fld->edit_html
---------------

   Returns a string that can be placed inside an html <form> section used
to edit this field or relation. It will be some sort of input tag with the
same name as the fld.

$fld->sql_data($sel)
--------------------

   Called if this fld is used in the selection string in a
DBIx::HTMLView::Selection object $sel. It is supposed to add apropriate
data to the object using $sel->add_fld and $sel->add_tab (se the
DBIx::HTMLView::Selection manpage for details) and return the string to
represent it in the where clause (it will usualy be the name of the field
itself).

$fld->view_text
---------------

   Returns a text string used to view the contents (value) of the fld
(this method is not yet implemented for all fld classes).

$fld->del($id)
--------------

   Is called when a post with id $id is deleted. This is to allow the
relations of this post to clean out the data that is placed in other
tabels. The actual post will be removed from the table after all fld
object del methods has been called.

$fld->field_name
----------------

   The name of the sql field in the main table representing this fld. For
a N2N relation it will be undefined as it is represented in a separate
table and not in the main one. For fields it will ofcourse be the name of
the field.

$fld->name_vals
---------------

   This medthod is called whenever the data of a post are updated in the
actual database or a new post is added. It returns an array of hashes
containing the two keys name and val.  Where the value of the name keys
are the names of database fields that are supposed to be set to the values
of the val keys.  e.g.  return ( {'name' => 'Color', 'value' => 'Red'},
{'name' => 'Size', 'value' => 'XXL'} );

   This is the method where relations are supposed to update all secondary
tabels (eg the tables used to represent the actuall relations).

$fld->sql_create
----------------

   Will send the nesesery SQL commands to create this fld in database and
return the sql type (if any) of this field to be included in the CREATE
clause for the main table. That is normal fields will only return their
type while relations will create it's link table.

$fld->fmt($kind)
----------------

   Returns the "fmt_$kind" param as passed to the constructor (se new
method for info). If that one does not excist the default one "fmt" is
used. If thatone isn't specified either the default fmt '$val' is returned.

   To allow subclasses to provide more decent defaults the
default_fmt($kind) method is called if "fmt_$kind" is not defined.  If it
returns undef this method carries on as described above, otherwise the
return value of default_fmt is returned. Then default_fmt is called again
if there was no "fmt" param speciefied, but this time with $kind undefined.

   The default implementation here is ofcourse to always return undef, that
will give the behaviour described in the first paragraph here.

   A replacment default_fmt should never return undef but instead execute
it's supreclass version of it and return it's value if it dosn't want to
override the specified kind.

$fld->default_fmt($kind)
------------------------

   Used to allow subclasses to provide there own default fmts, se
$fld->fmt($kind).

$fld->view_text =head2 $fld->view_html =head2 $fld->edit_text
-------------------------------------------------------------

   For backwards compatibility those are linked to view_fmt('view_text'),
view_fmt('view_html'), view_fmt('edit:html'), respectivly.

   A replacment default_fmt should never return undef but instead execute
it's supreclass version of it and return it's value if it dosn't want to
override the specified kind.


File: pm.info,  Node: DBIx/HTMLView/Fmt,  Next: DBIx/HTMLView/Id,  Prev: DBIx/HTMLView/Fld,  Up: Module List

Basic parser for fmt strings and files
**************************************

NAME
====

     DBIx::HTMLView::Fld - Basic parser for fmt strings and files

SYNOPSIS =head1 DESCRIPTION
===========================

   ANY: VAR | FLD | FMT | PERL | TXT VAR: "<VAR " ... ">" FLD: "<FLD " ...
">" FMT: "<FMT " ... ">" ANY "</FTM>" PERL: "<PERL " ... ">" ... "</PERL>"
TXT: Anything else

$sel->token
-----------

   Returns the current token.

$sel->token($kind)
------------------

   Returns true if the current token is of the kind $kind.

$sel->token($kind,$val)
-----------------------

   Set $val as the curent token, and $kind as the kind of that token.


File: pm.info,  Node: DBIx/HTMLView/Id,  Next: DBIx/HTMLView/Int,  Prev: DBIx/HTMLView/Fmt,  Up: Module List

A index field used to identify posts
************************************

NAME
====

     DBIx::HTMLView::Id - A index field used to identify posts

SYNOPSIS
========

     $fld=$post->fld('id');
     print $fld->view_html;

DESCRIPTION
===========

   This is a subclass of DBIx::HTMLView::Field used to represent the id
fields of a table in the databse as well as the data contained in it.  See
the DBIx::HTMLView::Field and DBIx::HTMLView:.Fld (the superclass of
Field) manpage for info on the methods of this class.

   Each post must have an unique id number which the HTMLView system uses
to identify the post. The id has to be stored in the database in a field
which is specifyed by this class in the DBIx::HTMLView::Table object used
to represent the table. There should only be one Id field.

   If you try to generate an html editor using the edit_html method this
Fld will return a <input type=hidden ...> field that is used in the form
to specify which post is being edited.

   This behaviour of not allowing the user to edit the id should probably
not be modified as the id might be stored in other places (for eaxample
relations) too, and has to be updated there too.


File: pm.info,  Node: DBIx/HTMLView/Int,  Next: DBIx/HTMLView/N2N,  Prev: DBIx/HTMLView/Id,  Up: Module List

An integer field
****************

NAME
====

     DBIx::HTMLView::Int - An integer field

SYNOPSIS
========

     $fld=$post->fld('testf');
     print $fld->view_html;

DESCRIPTION
===========

   This is a subcalss of DBIx::HTMLView::Field used to represent integer
fields in the databse as well as the data contained in it. Se the
DBIx::HTMLView::Field and DBIx::HTMLView:.Fld (the superclass of Field)
manpage for info on the methods of this class.


File: pm.info,  Node: DBIx/HTMLView/N2N,  Next: DBIx/HTMLView/N2One,  Prev: DBIx/HTMLView/Int,  Up: Module List

A many to many relation between two tabels
******************************************

NAME
====

     DBIx::HTMLView::N2N - A many to many relation between two tabels

SYNOPSIS
========

     $fld=$post->fld('testf');
     print $fld->view_html;

DESCRIPTION
===========

   This is a subcalss of DBIx::HTMLView::Relation used to represent N2N
relations in the databse as well as the data contained in them. Se the
DBIx::HTMLView::Relation and DBIx::HTMLView:.Fld (the superclass of
Relation) manpage for info on the methods of this class.

   A N2N relation as where each post in one table can be related to any
number of posts in an other table. As for example in the User/Group table
pair example described in the tutorial where each user can be part of
several groups.

   A third table, called link table, will be used to represent the
relations. It should contain three fields. One id field (as all tabels),
one from id (eg user id) and one to id (eg group id). Now one relation
consists of a set of posts in this table each linking one from post (eg
user) to one to post (eg group).

   As for the overall operation this kind of Flds should wokr like any
other Fld, but you can also do a few extra things, as described below.

METHODS =cut
============

   package DBIx::HTMLView::N2N; use strict; use Carp;

   use vars qw(@ISA); require DBIx::HTMLView::Relation;  @ISA =
qw(DBIx::HTMLView::Relation);

   require DBIx::HTMLView::Fmt;

$fld=DBIx::HTMLView::N2N->($name, $data) =head2 $fld=DBIx::HTMLView::N2N->new($name, $val, $tab)
------------------------------------------------------------------------------------------------

   The constructor works in the exakt same way as for DBIx::HTMLView::Fld,
se it's man page for details.

   The following parameters passed within the $data has is recognised:

   tab - The table this table is related to (to table) from_field - The
field name of the link table where the from table post    id is stored.
Default is "<from table>_id".  to_field - The field name of the link table
where the to table post    id is stored. Default is "<to table>_id".
lnk_tab - The name of the link table. Default is "<from table>_to_<to
table>".  id_name - The name of the link post id field in the link table.
Default    is "id".  view - String used when viewing a related post
withing the post being    viewed (eg the groups list of a user post). All
$<fld name> constructs    will be replaced with the data of the post
beeing viewed. Obsolete, use    the fmt param instead.  join_str - As a
post can be related to several other and each will be    viewed using the
view string above and then joined together using this    string as glue.
Default is ", ".  Obsolete, use the fmt param instead.  fmt - Specifies
the fmt string to be passed to view_fmt of the PostSet    object
representing the posts we are related to. For backwards    compatibility
it defaults to "<node join="$join_str">$view</node>",    if $view is
defined. $view and $join_str are the var defined above.  extra_sql - Extra
sql code passe to the list method when listing related    posts. This can
for example be used to specify in which order related    posts should be
viewed. Default is "ORDER BY <to table id name>".

   As you se, it is only tab that does not have any default value, so it
has to be defined within the table declaration, it's usually also a good
idea to specify fmt to something decent as well.

   =cut

   sub new {   my $this = shift;   my $class = ref($this) || $this;   my
$self=  bless {}, $class;

     my ($name, $data, $tab)=@_;
     $self->{'name'}=$name;
     $self->{'tab'}=$tab;
     
     if (ref $data eq "HASH") {
       $self->{'data'}=$data;
     } elsif (ref $data eq "ARRAY") {
       if (ref $this) {$self->{'data'}=$this->{'data'};}
       $self->{'posts'}=DBIx::HTMLView::PostSet->new($self->to_tab);
       foreach (@$data) {
         if ($_ ne "do_edit") {
           $self->{'posts'}->add($self->to_tab->new_post({$self->tab->id->name=>$_}));
         }
       }
     } else {
       $self->{'id'}=$data;
       if (ref $this) {$self->{'data'}=$this->{'data'};}
     }
     
     $self;
     }

$fld->db
--------

   Returns the database handle of the tabels.

$fld->id
--------

   Returns the id of the post this relation belongs to.

$fld->to_tab_name
-----------------

   Returns the name of the to table.

$fld->to_tab
------------

   Returns the DBIx::HTMLView::Table object representing the to table.

$fld->from_field_name
---------------------

   Returns the name of the from field in the link table as specified in the
$data param to the constructor.

$fld->to_field_name
-------------------

   Returns the name of the to field in the link table as specified in the
$data param to the constructor.

$fld->lnk_tab_name
------------------

   Returns the name of the link table as specified in the $data param to
the constructor.

$fld->id_name
-------------

   Returns the name of the link post id field in the link table as
specified in the $data param to the constructor.

$fld->lnk_tab
-------------

   Creates and returns a DBIx::HTMLView::Table object representing the link
table.

$fld->join_str
--------------

   Returns the join_str parameter as specified in the $data param to the
constructor.

$fld->extra_sql
---------------

   Returns the extra_sql parameter as specified in the $data param to the
constructor.

$fld->got_post_set
------------------

   Returns true if we have a post set. Se the post_set method.

$fld->post_set
--------------

   When this object is used to represent the data of a relation that can
be done in two ways. Either we just know the id of the post we belong to
and can look up the related posts from the db whenever needed. When such a
post lookup is done the (parts of the) posts returned are stored in a
DBIx::HTMLView::PostSet object.

   This method will return such an object after selecting it from the
server if nesessery. You can use the got_post_set method to check if it
was already donwloaded. If this Fld did not belong to a specifik post, eg
no id was defiedn it will die with "Post not defined!".

$fld->posts
-----------

   Will return an array of the posts after calling the post_set method. If
there are no related posts it will not die, but return an empthy array.

$fld->view_fmt_edit_html($postfmt_name, $postfmt)
-------------------------------------------------

   Used by the default edit_html fmt. It will return a string containing
"<input type=checkbox ...>" constructs to allow the user to specify which
posts we should be related to. All posts in the to table will be listed
here and viewed with view_fmt($postfmt_name,$postfmt).

   $postfmt_name will default to 'view_html'. If $postfmt isn't defined
some decent default is tried to be derived from the default fmt for
$postfmt_name.

   The $postfmt should contain a <Var Edit> tag that will be raplaced by
the checkbox button.

$fld->del($id)
--------------

   Will remove the relation from post $id. Eg it will no longer be related
to any posts.

$fld->name_vals
---------------

   Returns an empthy array as no fields in the from table should be
modifed.

$fld->post_updated
------------------

   Updates the relation data in the db.

$fld->sql_data($sel, $sub)
--------------------------

   Used by the DBIx::HTMLView::Selection object $sel when it finds a
relation->field construct in a search string that should be evaled into an
sql select expretion. $sub will be a refference to an array of all names
after the -> signs, eg for rel1->rel2->rel3->field $sub would contain
("rel2", "rel3", "field") and this would be the rel1 relation.

$fld->field_name
----------------

   Returns undef as we've not got any field in the main table. Se
DBIx::HTMLView::Fld.

$fld->view_fmt($fmt_name, $fmt)
-------------------------------

   Will call view_fmt($fmt_name, $fmt) on the postset containing all the
posts this relation is pointing to and return the result, see
DBIx::HTMLView::PostSet for info on the $fmt format.

   If the fmt string starts with "<InRel>", the rest of the fmt will be
handled by this method instead of calling the PostSet version.  Current
the only supported construct here is <perl>...</perl> which will be
replaced by the returnvalue of eval(...).


File: pm.info,  Node: DBIx/HTMLView/N2One,  Next: DBIx/HTMLView/Post,  Prev: DBIx/HTMLView/N2N,  Up: Module List

A many to one relation between two tabels
*****************************************

NAME
====

     DBIx::HTMLView::N2One - A many to one relation between two tabels

SYNOPSIS
========

     $fld=$post->fld('testf');
     print $fld->view_html;

DESCRIPTION
===========

   This is a subcalss of DBIx::HTMLView::Int used to represent a relation
to a post in another (or possibly the same) table. The relation will be
represented in the database by a field containing the id of the post
related to. Se the DBIx::HTMLView::Field and DBIx::HTMLView:.Fld (the
superclass of Field) manpage for info on the methods of this class.

   NOTE: Even if this is a relation it is NOT a subclass of
DBIx::HTMLView::Relation.

   #FIXME: List possible params

$fld->to_tab_name
-----------------

   Returns the name of the to table.

$fld->to_tab
------------

   Returns the DBIx::HTMLView::Table object representing the to table.

$fld->view_fmt_edit_html($postfmt_name, $postfmt)
-------------------------------------------------

   Used by the default edit_html fmt. It will return a string containing
"<input type=radio ...>" constructs to allow the user to specify which
post we should be related to. All posts in the to table will be listed
here and viewed with view_fmt($postfmt_name,$postfmt).

   $postfmt_name will default to 'view_html'. If $postfmt isn't defined
some decent default is tried to be derived from the default fmt for
$postfmt_name.

   The $postfmt should contain a <Var Edit> tag that will be replaced by
the radio button.

$fld->view_fmt($fmt_name, $fmt)
-------------------------------

   Will call view_fmt($fmt_name, $fmt) on the post this relation is
pointing to and return the result, se DBIx::HTMLView::Post for info on the
$fmt format.

   If $fmt is not defined the fmt parameter named $fmt_name specified in
the $data parameter to the constructor will be used as fmt string.

   If the fmt string starts with "<InRel>", the rest of the fmt will be
handled by this method instead of calling the PostSet version.  Current
the only supported construct here is <perl>...</perl> which will be
replaced by the returnvalue of eval(...).


File: pm.info,  Node: DBIx/HTMLView/Post,  Next: DBIx/HTMLView/PostSet,  Prev: DBIx/HTMLView/N2One,  Up: Module List

A post in a DBI database
************************

NAME
====

     DBIx::HTMLView::Post - A post in a DBI database

SYNOPSIS
========

     $post=$post_set->first;
     print $post->view_html;   # View a post

     $post->set('testf', 7);   # Set the testf field to 7
     $post->update;            # Update the database with the modified post

     $post=DBIx::HTMLView::Post->new($tab)   # Create a new post
     $post->set('testf', 7);   # Set the testf field to 7
     $post->update;            # Insert the new post in the databse

DESCRIPTION
===========

   This object represents a single post in a specific table in the
database. It has methods to view post as well as to modify it's data and
to reflect those modifications in the database.

$post=DBIx::HTMLView::Post->new($tab, $data, $sth)
--------------------------------------------------

   Creates a new post belonging to the table $tab (a DBIx::HTMLview::Table
object). $data and $sth is used to initialize the post with it's fields,
which can be done in several ways:

   1. To create a new empty post with no data set, simply don't specify
those arguments.  2. If $data is an array reference, $sth is supposed to
be the object    returned by a DBI execude call with a select command, and
$data should    be the array ref with the data you want to create a post
object of. If    the same fieldname apperas twice in the select the first
one is    presumed to be the one belonging to this post.  3. If $data is a
hash reference, it is supposed to contain Fld/Value    pairs.  4. If $data
is a CGI object the CGI params is supposed to be Fld/Value    pairs. Note
that relations in this case is defined by setting the name    of the
relation to the id's of the posts related to, eg it will be    defined
once for every post.

$post->set($fld, $val)
----------------------

   Set's the Fld named $fld to $val. If $val is not a DBIx::HTMLView::Fld
object $post->tab->new_fld($fld,$val) is called to create the Fld object
to represent this fld and it's data.

   For fields data ($val) is specified as a string or as the first item of
a array referenced to by $val. Relations are represented as a reference to
an array of the id's of the posts being related to.

$post->got_fld($fld_name)
-------------------------

   Returns true if we have data specified for the fld named $fld_name.

$post->view_text
----------------

   Returns a string that could be used to view this post in text format

$post->view_html
----------------

   Returns a string that could be used to view this post in html format.

$post->view_fmt($fmt_name, $fmt)
--------------------------------

   Returns a string represeting this post in the format named by $fmt_name
as returned by DBIx::HTMLView::post_fmt($fmt_name). If $fmt is specified
it will be used as the fmt strings instead of looking up a default one.

   All <Var ...> will be replaced with there corisponding values or removed
if they are not know, currently no such values are know here (eg all is
remeved).

   To include the value of an Fld in output simply put $<fld_name> in the
desired place in the $fmt string. (eg $name will be replaced with the
outpit of $self->fld('name')->view_fmt($fmt_name)).

   If $fmt is not specified the default post fmt will be used as returned
by post_fmt in DBIx::HTMLView::Table.

   $fmt_name is passed on to fld objects, so it can be used to specify how
the flds should be represented even if you use a custom fmt passed to $fmt.

$post->fld_names
----------------

   Returns an array of the fld names currently specified in this post, use
$post->tab->fld_names to list all Fld of the post.

$post->fld($fld_name) =head2 $post->val($fld_name)
--------------------------------------------------

   Returns the Fld representing that data of the Fld named $fld_name.

$post->tab
----------

   Returns the table this post belongs to (a DBIx::HTMLView::Table object).

$post->got_id
-------------

   Returns true if the id of this post is defined, which is the same as
that the post is represented in the database as well (which is not true
for new posts that not yet have been added to the datbase, using
$post->update).

$post->id
---------

   Returns the id of this post or dies with "No id defined" if it is not
defined. Se $post->got_id.

$post->update
-------------

   Updates the database with the data found in this object or creats a new
post in the database with that data if the id is not defined. Se
$post->got_id.


