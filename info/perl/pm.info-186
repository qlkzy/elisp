This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Heap/Fibonacci,  Next: Hook/WrapSub,  Prev: Heap/Elem/StrRev,  Up: Module List

a Perl extension for keeping data partially sorted
**************************************************

NAME
====

   Heap::Fibonacci - a Perl extension for keeping data partially sorted

SYNOPSIS
========

     use Heap::Fibonacci;

     $heap = Heap::Fibonacci->new;
     # see Heap(3) for usage

DESCRIPTION
===========

   Keeps elements in heap order using a linked list of Fibonacci trees.
The heap method of an element is used to store a reference to the node in
the list that refers to the element.

   See *Note Heap: Heap, for details on using this module.

AUTHOR
======

   John Macdonald, jmm@elegant.com

COPYRIGHT
=========

   Copyright 1998, O'Reilly & Associates.

   This code is distributed under the sme copyright as perl itself.

SEE ALSO
========

   Heap(3), Heap::Elem(3).


File: pm.info,  Node: Hook/WrapSub,  Next: HtDig/Config,  Prev: Heap/Fibonacci,  Up: Module List

wrap subs with pre- and post-call hooks
***************************************

NAME
====

   Hook::WrapSub - wrap subs with pre- and post-call hooks

SYNOPSIS
========

     use Hook::WrapSub qw( wrap_subs unwrap_subs );

     wrap_subs \&before, 'some_func', 'another_func', \&after;

     unwrap_subs 'some_func';

DESCRIPTION
===========

wrap_subs
---------

   This function enables intercepting a call to any named function;
handlers may be added both before and after the call to the intercepted
function.

   For example:

     wrap_subs \&before, 'some_func', \&after;

   In this case, whenever the sub named 'some_func' is called, the &before
sub is called first, and the &after sub is called afterwards.  These are
both optional.  If you only want to intercept the call beforehand:

     wrap_subs \&before, 'some_func';

   You may pass more than one sub name:

     wrap_subs \&before, 'foo', 'bar', 'baz', \&after;

   and each one will have the same hooks applied.

   The sub names may be qualified.  Any unqualified names are assumed to
reside in the package of the caller.

   The &before sub and the &after sub are both passed the argument list
which is destined for the wrapped sub.  This can be inspected, and even
altered, in the &before sub:

     sub before {
       ref($_[1]) && $_[1] =~ /\bARRAY\b/
         or croak "2nd arg must be an array-ref!";
       @_ or @_ = qw( default values );
       # if no args passed, insert some default values
     }

   The &after sub is also passed this list.  Modifications to it will
(obviously) not be seen by the wrapped sub, but the caller will see the
changes, if it happens to be looking.

   Here's an example that causes a certain method call to be redirected to
a specific object.  (Note, we use splice to change $_[0], because
assigning directly to $_[0] would cause the change to be visible to the
caller, due to the magical aliasing nature of @_.)

     my $handler_object = new MyClass;

     Hook::WrapSub::wrap_subs
       sub { splice @_, 0, 1, $handler_object },
       'MyClass::some_method';
     
     my $other_object = new MyClass;
     $other_object->some_method;

     # even though the method is invoked on
     # $other_object, it will actually be executed
     # with a 0'th argument = $handler_obj,
     # as arranged by the pre-call hook sub.

Package Variables
-----------------

   There are some Hook::WrapSub package variables defined, which the
&before and &after subs may inspect.

$Hook::WrapSub::name
     This is the fully qualified name of the wrapped sub.

@Hook::WrapSub::caller
     This is a list which strongly resembles the result of a call to the
     built-in function caller; it is provided because calling caller will
     in fact produce confusing results; if your sub is inclined to call
     caller, have it look at this variable instead.

@Hook::WrapSub::result
     This contains the result of the call to the wrapped sub.  It is empty
     in the &before sub.  In the &after sub, it will be empty if the sub
     was called in a void context, it will contain one value if the sub
     was called in a scalar context; otherwise, it may have any number of
     elements.  Note that the &after function is not prevented from
     modifying the contents of this array; any such modifications will be
     seen by the caller!

   This simple example shows how Hook::WrapSub can be used to log certain
subroutine calls:

     sub before {
       print STDERR <<"    EOF";
         About to call $Hook::WrapSub::name( @_ );
         Wantarray=$Hook::WrapSub::caller[5]
       EOF
     }

     sub after {
       print STDERR <<"    EOF";
         Called $Hook::WrapSub::name( @_ );
         Result=( @Hook::WrapSub::result )
       EOF
       @Hook::WrapSub::result
         or @Hook::WrapSub::result = qw( default return );
       # if the sub failed to return something...
     }

   Much more elaborate uses are possible.  Here's one one way it could be
used with database operations:

     my $dbh; # initialized elsewhere.

     wrap_subs
       sub {
         $dbh->checkpoint
       },

     'MyDb::update',
     'MyDb::delete',

     sub {
       # examine result of sub call:
       if ( $Hook::WrapSub::result[0] ) {
         # success
         $dbh->commit;
       }
       else {
         # failure
         $dbh->rollback;
       }
     };

unwrap_subs
-----------

   This removes the most recent wrapping of the named subs.

   NOTE: Any given sub may be wrapped an unlimited number of times.  A
"stack" of the wrappings is maintained internally.  wrap_subs "pushes" a
wrapping, and unwrap_subs "pops".

AUTHOR
======

   jdporter@min.net (John Porter)

COPYRIGHT
=========

   This is free software.  This software may be modified and/or
distributed under the same terms as Perl itself.


File: pm.info,  Node: HtDig/Config,  Next: HtDig/Database,  Prev: Hook/WrapSub,  Up: Module List

Perl extension for managing ht://Dig configuration files
********************************************************

NAME
====

   HtDig::Config - Perl extension for managing ht://Dig configuration files

SYNOPSIS
========

     use HtDig::Config;
     my $htdig = new HtDig::Config('/opt/www/conf/configdig_sites.pl');
     $htdig->autodetect();
     while (my ($site_name, $path) = each %{$htdig->sites()}) {
       print "Site $site_name found at $path\n";
     }
     my $site = $htdig->sites("default");
     #etc.
     #See the HtDig::Site module for information on using the Site object
     #

DESCRIPTION
===========

   HtDig::Config provides an object-oriented interface to the
configuration files for ht://Dig, a popular, open-source content indexing
and searching system.

   ht://Dig allows you to specify a configuration file to use when
beginning an indexing run or doing a search, thus allowing you to maintain
multiple databases of indexed web pages.  The Config object's main job is
to help you keep track of all the site configuration files you have, using
a sort of "registry" to keep track of sites you've registered with
ConfigDig.  The HtDig::Site object works with the Config object to help
you modify and save each site's configuration settings.

METHODS
=======

   *      my $htdig = new HtDig::Config(conf_path=>'/opt/www/conf/configdig_sites.pl');

     Returns a new Config object.  No required parameters.  If you don't
     pass in conf_path, the value for $DEFAULT_CONFIF_LOCATION is used.
     You can change this to your own preference for convenience if you
     wish, with no ill effects.  You can also pass in auto_create=>1 to
     cause a blank file to be created at conf_path, if one doesn't already
     exist.  Dies on failure.

   *      $htdig->save();

     Causes the current Site registry to be written to the file at
     $config_object->{conf_path};

   *      my @site_list = $htdig->sites();

     Returns an array listing the names of all the sites in the Site
     registry.

   *      my $site = $htdig->get_site("default");

     Returns an HtDig::Site object corresponding to the string name passed
     in.  Returns undef on failure, such as when the site name is not
     found in the Site registry.

   *      $htdig->add_site(site_name=>"My Site", conf_path=>"/opt/www/conf/mysite.conf");

     Adds a new site to the registry, giving it the name specified in
     site_name, and using the config file at conf_path.  Returns the Site
     object on success, undef on failure.

   *      $htdig->delete_site(site_name=>'My Site');

     Removes the site specified in site_name from the registry.  The
     config file itself is not removed.

   *      $htdig->autodetect(paths=>['/users/jtillman/confs/', '/users/bob/htdig'], use_env_path=>1);

     Causes the Config object to search the paths specified in paths for
     .conf files, attempting to add each file found to the registry.  If
     use_env_path is specified, the PATH environment variable is used to
     search for the htdig executable and the base htdig directory is
     determined using its location.  Then the [base_location]/conf
     directory is searched for .conf files.

     The method also searches /opt/www/conf and /usr/local/htdig/conf by
     default.

   *      print $htdig->errstr . "\n";

     Returns the most recently generated error.  The Config object doesn't
     bother with error numbers, since they would be arbitrary and
     difficult to track.  This may change if demand is high enough for
     error numbers.

KNOWN ISSUES
============

   * isn't very clever or clean.  Error reporting could be better, and
     some attempt should be made to detect which .conf files really are
     htdig .conf files

   * get_site require attrib=>value convention?  Nearly all the other
     methods do, even delete_site.

AUTHOR
======

   James Tillman <jtillman@bigfoot.com> CPAN PAUSE ID jtillman

SEE ALSO
========

   HtDig::Site.

   perl(1).


File: pm.info,  Node: HtDig/Database,  Next: HtDig/Site,  Prev: HtDig/Config,  Up: Module List

Perl interface Ht://Dig docdb and config files
**********************************************

NAME
====

   Htdig::Database - Perl interface Ht://Dig docdb and config files

SYNOPSIS
========

     use Htdig::Database;

     my $config = Htdig::Database::get_config( $config_file )
     	    or die "$0: Can't access $config_file\n";
     my $record = Htdig::Database::parse_docdb( $docdb_record );
     print "URL = $record->{URL}\n";

DESCRIPTION
===========

Exported functions
------------------

   The following functions are provided by Htdig::Database:

     get_config
     parse_docdb
     encode_url
     decode_url

   By default, functions are not exported into the callers namespace, and
you must invoke them using the full package name, e.g.:

     Htdig::Database::getconfig( $config_file );

   To import all available function names, invoke the module with:

     use Htdig::Database qw(:all);

Parsing a config file
---------------------

   `get_config' parses a config file and returns a hash ref that contains
the configuration attributes.  For example:

     my $config = Htdig::Database::get_config( $config_file )
     	or die "$0: Can't access $config_file\n";
     print "start_url = $config->{start_url}\n";

   All values in the hash are scalars, and any items that are intended to
be lists or booleans must be parsed by the calling program.  `get_config'
returns undef if the config file can't be opened, and carps about various
syntax errors.

Parsing a record from the document database
-------------------------------------------

   `parse_docdb' parses a record from the document database and returns a
hash ref.  For example:

     my %docdb;
     tie( %docdb, 'DB_File', $docdb, O_RDONLY, 0, $DB_BTREE ) ||
     	die "$0: Unable to open $docdb: $!";

     while ( my ( $key, $value ) = each %docdb ) {
     	next if $key =~ /^nextDocID/;
         my %rec = Htdig::Database:parse_docdb( $value );
     	print "     URL: $record->{URL}\n";
     	print "HOPCOUNT: $record->{HOPCOUNT}\n";
     }

   URL's in the database are encoded using two attributes from the
configuration file: *common_url_parts* and *url_part_aliases*.
`parse_docdb' does only rudimentary decoding.  It can't handle more than
25 elements in the *common_url_parts* list, and it currently can't handle
*url_part_aliases* at all.

   `get_config' caches the value of *common_url_parts* that's used for
decoding URL's, and should usually be called before `parse_docdb'.

   Compressed data in the HEAD element will be automatically decompressed
if the Compress::Zlib module is available.  If Compress::Zlib is not
installed, compressed data will be silently replaced by the string:

     "Compressed data: Zlib not available"

   If only a single value is needed from the database record, it can be
specified as a second parameter to `parse_docdb', which then returns the
requested value as a scalar.  For example:

     my $url = Htdig::Database:parse_docdb( $value, 'URL' );

Encoding a URL
--------------

     my $encoded_url = Htdig::Database::encode_url( $url );

   This may be useful for computing database keys, since the keys are
encoded URL's.  `get_config' should be called before `encode_url' or
`decode_url' to initialize the value of `common_url_parts'.

Decoding a URL
--------------

     my $url = Htdig::Database::decode_url( $encoded_url );

   This should seldom be necessary, since URL's are normally decoded by
`parse_docdb'.

AUTHOR
======

   Warren Jones <`wjones@halcyon.com'>

BUGS
====

   Only simple cases of URL encoding are handled correctly.  No more than
25 elements are allowed in *common_url_parts*.  The value of
*url_part_aliases* is not used at all.  Someday this module may implement
the same URL encoding logic found in `HtWordCodec.cc', but a better
solution might be to provide an XSUB interface to the C++ functions.

   This module works with ht://Dig 3.1.4.  It probably works with 3.1.5,
though this hasn't been tested.  Because of changes in the database
format, it *will not work* with version 3.2.


File: pm.info,  Node: HtDig/Site,  Next: HyperWave/CSP,  Prev: HtDig/Database,  Up: Module List

Perl extension for managing a single ht://Dig configuration
***********************************************************

NAME
====

   HtDig::Site - Perl extension for managing a single ht://Dig
configuration

SYNOPSIS
========

     use HtDig::Site;
     $site = new HtDig::Site(conf_path=>"/opt/www/conf/htdig.conf");
     $site->setting("maintainer", "jtillman@bigfoot.com");
     $site->save();
     $site->dig(verbose=>3);

DESCRIPTION
===========

   HtDig::Site provides an object for manipulating configuration files for
ht://Dig, a popular open source content indexing and searching system.
The Site object allows you to open a configuration file, modify settings
in it, including custom settings that don't directly relate to ht://Dig
executibles, and also allows you to perform database operations such as
site index runs, database merges, and fuzzy index creation.

METHODS
=======

   *      $site = new HtDig::Site(conf_path=>"/opt/www/conf/htdig.conf", trace_lvl=>1, site_name=>"Default");

     new creates a new Site object and returns it.  The only required
     parameter is conf_path.  auto_create allows the object to create the
     file specified in conf_path if it doesn't already exist.  trace_lvl
     is mainly for debugging problems, and site_name is really only meant
     to be used by the Config object, which provides you with named access
     to registered configuration files.  Wouldn't you rather be able to
     use the name "My Site", instead of "/opt/www/conf/htdig.conf"?
     That's what Config does for you.  But there's nothing stopping you
     from naming a Site object yourself when you create it explicitly; the
     name just won't persist beyond the current session.

   *      $site->setting("exclude_urls", ["http://localhost/cgi-bin", "http://localhost/images"]);
          @exlude_urls = $site->setting("exclude_urls");

     Allows you to modify or retrieve a setting in the configuration file.
     You must save the file before it will be persisted.

     As illustrated in the example, if the datatype of the setting you are
     attempting to modify is a "string list", you can pass in an array
     reference.  Otherwise, you can pass in a space separated list of
     values, and the Site object will convert it to an array reference by
     splitting on the white space.  The array reference is for internal
     representation only, and will be converted to a space separated list
     when the config file is written to disk.

   *      $site->refresh();

     When a configuration file is first loaded from disk (or saved for the
     first time), its modification time is stored in memory and will be
     compared when the save method is called.  If you suspect someone
     might have touched the file on disk and wish to sync up with its
     current version, you can use the refresh method.  Any changes since
     the last save will be lost.

   *      $site->save();
          $site->save(save_to=>'/opt/www/conf/htdig2.conf');

     Saves the in-memory settings to disk.  If the optional save_to
     parameter is provided, the file is written to that path, otherwise,
     it's written to the original conf_path that was provided when the
     object was created.

   *      $site->dig();

     Initiates a site indexing run.

   *      $site->generate_fuzzy_index();

     Generates a fuzzy_index of the type specified in the parameter type.

   *      $site->merge(merge_site=>"/opt/www/conf/othersite.conf",not_words=>1, not_documents=>0, work_files=>1);

     Performs a merge using htmerge, merging the configuration file
     specified in merge_site into the current Site's database.  not_words,
     not_documents, and work_files correspond to the htmerge command line
     options -w, -d, and -a, respectively.

   *      my @stock_settings = keys %{$site->datatypes};

     Returns a hash that describes ht://Dig configuration file setting
     datatypes.  These are documented at
     http://www.htdig.org/confindex.html.  The example uses the hash to
     get a list of stock settings that htdig recognizes.

     The hash structure looks something like this:

          {
           setting_name => 'DATATYPE'
          }

     ...where setting_name is the name of the configuration file setting,
     such as "maintainer", and DATATYPE is the documented datatype of the
     setting.  There are four currently documented datatypes: string,
     string list, number, and boolean.

     This feature is probably not very useful for the perl scripter using
     the Site object, but it is provided just in case some input
     validation needs to be done, or some options need to be presented to
     the user.  It's a good way to present a list of the stock settings
     that can appear in a configuration file.

   *      print $site->errstr . "\n";

     Returns the most recently generated error.  The Site object doesn't
     bother with error numbers, since they would be arbitrary and
     difficult to track.  This may change if demand is high enough for
     error numbers.

KNOWN ISSUES
============

   * Timed digs are broken.  Needs work.

AUTHOR
======

   James Tillman <jtillman@bigfoot.com> CPAN PAUSE ID: jtillman

SEE ALSO
========

   HtDig::Config.

   perl(1).


File: pm.info,  Node: HyperWave/CSP,  Next: I18N/Charset,  Prev: HtDig/Site,  Up: Module List

Communicate with a HyperWave server
***********************************

NAME
====

   HyperWave::CSP - Communicate with a HyperWave server

SYNOPSIS
========

     use HyperWave::CSP;
     
     $server = HyperWave::CSP->New("my.hyperwave.server");
     $server->quit;

DESCRIPTION
===========

   `HyperWave' is a class implementing a simple HyperWave client in Perl.

CONSTRUCTOR
===========

new ( [ HOST [, PORT [, USERNAME [, PASSWORD [, ENCRYPT [, LANGUAGE ] ] ] ] ] ] )
     This is the constructor for a new HyperWave object. `HOST' is the
     name of the remote host to which a HyperWave connection is required.
     If not given the environment variables `HWHOST' and then `HGHOST' are
     checked, and if a host is not found then `localhost' is used.

     `PORT' is the HyperWave port to connect to, it defaults to the
     environment variable `HWPORT', then `HGPORT' and then to the standard
     port 418 if nothing else is found.

     USERNAME and PASSWORD are the HyperWave username and password, they
     default to anonymous.  `ENCRYPT' will eventually allow you to pass
     the password in in encrypted form rather than plaintext, but is not
     yet implemented.

     `LANGUGAE' also is not yet used, and defaults to the value of the
     environment variable `HWLANGUAGE' and then to English.

     The constructor returns the open socket, or undef if an error has
     been encountered.

METHODS
=======

   Unless otherwise stated all methods return either a *true* or false
value, with *true* meaning that the operation was a success.  When a
method states that it returns a value, failure will be returned as undef
or an empty list.

command_stat ( )
     Returns string containing various statistics for the server.

command_ftstat ( )
     Returns string containing various statistics for the server.

command_dcstat ( )
     Returns string containing various statistics for the server.

command_who ( )
     Returns string containing current users for the server.

get_objnum_by_name ( NAME )
     Returns object number for the document with NAME as an attribute, or
     false on error.

get_url ( OBJNUM )
     Returns a guess at a URL that might work for the document OBJNUM to be
     retreived via the HyperWave HTTP interface.  Note that it is ONLY a
     guess.  For one thing, it depends on the HyperWave server running a
     web interface on the default HTTP port.

get_attributes ( OBJNUM )
     Returns a string containing the attributes for OBJNUM.  The string is
     in form `key1=value1\nkey2=value2\n...'.

get_attributes_hash ( OBJNUM )
     Like get_attributes() except that the attributes are returned as a
     hash.

get_text ( OBJNUM )
     Returns body text for the objnum passed.  This usually means HTML
     sans anchors in practical terms.

get_html ( OBJNUM )
     Returns HTML text, including anchors, for the objnum passed.

exec_cgi ( OBJNUM )
     Returns output of the CGI, for the objnum passed.  Depends on the CGI
     script not requiring input.

insert_attribute ( OBJNUM, NAME, VALUE )
     Adds an attribute to the given objnum.  Note that HyperWave allows
     multiple attributes of the same name, so if you add an attribute that
     already exists you'll end up with two.  Use change_attribute if you
     want to overwrite the old one.

remove_attribute ( OBJNUM, NAME, VALUE )
     Removes an attribute to the given objnum.  Note that you DO need to
     know the old value because HyperWave allows multiple attributes with
     the same value.

change_attribute ( OBJNUM, NAME, OLD_VALUE, NEW_VALUE )
     Alters an attribute to the given objnum (NB: needs to know old value).

get_children ( OBJNUM )
     Returns objnums for all the children in the objnum passed.  If the
     object was a leaf node (ie: no children) you'll get a 0 back.

get_parents ( OBJNUM )
     Returns objnums for all the parents in the objnum passed.  If the
     object had no parents (it was the root collection) you'll get a 0
     back.

get_anchors ( OBJNUM )
     Returns objnums for all the anchors in the document passed.

insert_object ( OBJRECORD );
     Inserts an object on the HyperWave server.  Returns object ID of the
     new object.

     `OBJRECORD' should be in the form
     `Attribute=AttributeValue\nAttr2=Value2' and must contain certain
     parameters such as the parent object, name, document type, etc.  It is
     suggested that you use one of the other insert_* commands as they
     provide a friendlier interface.  This command is provided primarily
     for completeness.

insert_collection ( PARENT_OBJNUM, NAME [, OTHER_PARAMS ] )
     Inserts a collection on the HyperWave server.  Returns object ID of
     the new collection.

     `PARENT_OBJNUM' is the object number (probably returned from
     get_objnum_by_name() of the collection to insert this collection into.
     NAME is the name attribute, this will become the apparent URL to
     somebody using the WaveMaster interface.

     `OTHER_PARAMS' should be in the form
     `Attribute=AttributeValue\nAttr2=Value2' and so on.  You might
     particularly want to set a Title for the collection.

insert_image ( OBJNUM, PARENT, NAME )
     Adds a new picture.  NOT YET IMPLEMENTED.

insert_text ( OBJNUM, PARENT )
     Adds a new text object (no anchors).  NOT YET IMPLEMENTED.

insert_html ( OBJNUM )
     Adds a new html object (we parse the anchors).  NOT YET IMPLEMENTED.

error ( )
     Returns a human-readable string describing the previous server error.

server_error_message ( )
     Returns a human-readable string describing the previous server error.

SEE ALSO
========

AUTHOR
======

   Bek Oberin <gossamer@tertius.net.au>

COPYRIGHT
=========

   Copyright (c) 1998 Bek Oberin.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: I18N/Charset,  Next: I18N/Collate,  Prev: HyperWave/CSP,  Up: Module List

IANA Character Set Registry names and Unicode::Map8 conversion scheme names
***************************************************************************

NAME
====

   I18N::Charset - IANA Character Set Registry names and Unicode::Map8
conversion scheme names

SYNOPSIS
========

     use I18N::Charset;

     $sCharset = iana_charset_name('WinCyrillic');
     # $sCharset is now 'windows-1251'
     $sCharset = map8_charset_name('windows-1251');
     # $sCharset is now 'cp1251' which can be passed to Unicode::Map8->new()
     $sCharset = umap_charset_name('Adobe DingBats');  # $sCharset gets ''
     # $sCharset is now 'ADOBE-DINGBATS' which can be passed to Unicode::Map->new()

     I18N::Charset::add_iana_alias('my-japanese' => 'iso-2022-jp');
     I18N::Charset::add_map8_alias('my-arabic' => 'arabic7');
     I18N::Charset::add_umap_alias('my-hebrew' => 'ISO-8859-8');

DESCRIPTION
===========

   The `I18N::Charset' module provides access to the IANA Character Set
Registry names for identifying character encoding schemes.  It also
provides a mapping to the character set names used by the Unicode::Map8
and Unicode::Map modules.

   So, for example, if you get an HTML document with a META CHARSET="..."
tag, you can fairly quickly determine what Unicode:: module can be used to
convert it to Unicode.

   If you don't have the module Unicode::Map8 installed, the map8_
functions will always return undef; similarly for Unicode::Map and the
umap_ functions.

CONVERSION ROUTINES
===================

   There are three conversion routines: iana_charset_name(),
map8_charset_name(), and umap_charset_name().

iana_charset_name()
     This function takes a string containing the name of a character set
     and returns a string which contains the official IANA name of the
     character set identified. If no valid character set name can be
     identified, then undef will be returned.  The case and punctuation
     within the string are not important.

          $sCharset = iana_charset_name('WinCyrillic');

map8_charset_name()
     This function takes a string containing the name of a character set
     (in almost any format) and returns a string which contains a name for
     the character set that can be used to designate a Unicode::Map8
     character code map. If no valid character set name can be identified,
     then undef will be returned.  The case and punctuation within the
     argument string are not important.

          $sCharset = map8_charset_name('windows-1251');

umap_charset_name()
     This function takes a string containing the name of a character set
     (in almost any format) and returns a string which contains a name for
     the character set that can be used to designate a Unicode::Map
     character code mapping. If no valid character set name can be
     identified, then undef will be returned.  The case and punctuation
     within the argument string are not important.

          $sCharset = umap_charset_name('hebrew');

QUERY ROUTINES
==============

   There is one function which can be used to obtain a list of all
IANA-registered character set names.

`all_iana_charset_names()'
     Returns a list of all registered IANA character set names.  The names
     are not in any particular order.

CHARACTER SET NAME ALIASING
===========================

   This module supports three semi-private routines for specifying
character set name aliases.

add_iana_alias()
     This function takes two strings: a new alias, and a target IANA
     Character Set Name (or another alias).  It defines the new alias to
     refer to that character set name (or to the character set name to
     which the second alias refers).

     Returns the target character set name of the successfully installed
     alias.  Returns 'undef' if the target character set name is not
     registered.  Returns 'undef' if the target character set name of the
     second alias is not registered.

          I18N::Charset::add_iana_alias('my-alias1' => 'Shift_JIS');

     With this code, "my-alias1" becomes an alias for the existing IANA
     character set name 'Shift_JIS'.

          I18N::Charset::add_iana_alias('my-alias2' => 'sjis');

     With this code, "my-alias2" becomes an alias for the IANA character
     set name referred to by the existing alias 'sjis' (which happens to
     be 'Shift_JIS').

add_map8_alias()
     This function takes two strings: a new alias, and a target
     Unicode::Map8 Character Set Name (or an exising alias to a Map8 name).
     It defines the new alias to refer to that mapping name (or to the
     mapping name to which the second alias refers).

     If the first argument is a registered IANA character set name, then
     all aliases of that IANA character set name will end up pointing to
     the target Map8 mapping name.

     Returns the target mapping name of the successfully installed alias.
     Returns 'undef' if the target mapping name is not registered.
     Returns 'undef' if the target mapping name of the second alias is not
     registered.

          I18N::Charset::add_map8_alias('normal' => 'ANSI_X3.4-1968');

     With the above statement, "normal" becomes an alias for the existing
     Unicode::Map8 mapping name 'ANSI_X3.4-1968'.

          I18N::Charset::add_map8_alias('normal' => 'US-ASCII');

     With the above statement, "normal" becomes an alias for the existing
     Unicode::Map mapping name 'ANSI_X3.4-1968' (which is what "US-ASCII"
     is an alias for).

          I18N::Charset::add_map8_alias('IBM297' => 'EBCDIC-CA-FR');

     With the above statement, "IBM297" becomes an alias for the existing
     Unicode::Map mapping name 'EBCDIC-CA-FR'.  As a side effect, all the
     aliases for 'IBM297' (i.e. 'cp297' and 'ebcdic-cp-fr') also become
     aliases for 'EBCDIC-CA-FR'.

add_umap_alias()
     This function works identically to add_map8_alias() above, but
     operates on Unicode::Map encoding tables.

EXAMPLES
========

KNOWN BUGS AND LIMITATIONS
==========================

   * There could probably be many more aliases added (for convenience) to
     all the IANA names.  If you have some specific recommendations,
     please email the author!

   * The only character set names which have a corresponding mapping in the
     Unicode::Map8 module are the character sets that Unicode::Map8 can
     convert.

     Similarly, the only character set names which have a corresponding
     mapping in the Unicode::Map module are the character sets that
     Unicode::Map can convert.

   * In the current implementation, all tables are read in and initialized
     when the module is loaded, and then held in memory until the program
     exits.  A "lazy" implementation (or a less-portable tied hash) might
     lead to a shorter startup time.  Suggestions, patches, comments are
     always welcome!

SEE ALSO
========

Unicode::Map
     Convert strings from various multi-byte character encodings to and
     from Unicode.

Unicode::Map8
     Convert strings from various 8-bit character encodings to and from
     Unicode.

Jcode
     Convert strings among various Japanese character encodings and
     Unicode.

Unicode::MapUTF8
     A wrapper around all three of these character set conversion
     distributions.

AUTHOR
======

   Martin Thurn <MartinThurn@iname.com>

COPYRIGHT
=========

   Copyright (c) 1998-2001 TASC, Inc.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: I18N/Collate,  Next: I18N/LangTags,  Prev: I18N/Charset,  Up: Module List

compare 8-bit scalar data according to the current locale
*********************************************************

NAME
====

   I18N::Collate - compare 8-bit scalar data according to the current
locale

     ***

     WARNING: starting from the Perl version 5.003_06
     the I18N::Collate interface for comparing 8-bit scalar data
     according to the current locale

     HAS BEEN DEPRECATED

     That is, please do not use it anymore for any new applications
     and please migrate the old applications away from it because its
     functionality was integrated into the Perl core language in the
     release 5.003_06.

     See the perllocale manual page for further information.

     ***

SYNOPSIS
========

     use I18N::Collate;
     setlocale(LC_COLLATE, 'locale-of-your-choice');
     $s1 = new I18N::Collate "scalar_data_1";
     $s2 = new I18N::Collate "scalar_data_2";

DESCRIPTION
===========

   This module provides you with objects that will collate according to
your national character set, provided that the POSIX setlocale() function
is supported on your system.

   You can compare $s1 and $s2 above with

     $s1 le $s2

   to extract the data itself, you'll need a dereference: $$s1

   This module uses POSIX::setlocale(). The basic collation conversion is
done by strxfrm() which terminates at NUL characters being a decent C
routine.  collate_xfrm() handles embedded NUL characters gracefully.

   The available locales depend on your operating system; try whether
`locale -a' shows them or man pages for "locale" or "nlsinfo" or the
direct approach `ls /usr/lib/nls/loc' or `ls /usr/lib/nls' or `ls
/usr/lib/locale'.  Not all the locales that your vendor supports are
necessarily installed: please consult your operating system's
documentation and possibly your local system administration.  The locale
names are probably something like `xx_XX.(ISO)?8859-N' or
`xx_XX.(ISO)?8859N', for example `fr_CH.ISO8859-1' is the Swiss (CH)
variant of French (fr), ISO Latin (8859) 1 (-1) which is the Western
European character set.


File: pm.info,  Node: I18N/LangTags,  Next: IETF/ACE,  Prev: I18N/Collate,  Up: Module List

functions for dealing with RFC1766-style language tags
******************************************************

NAME
====

   I18N::LangTags - functions for dealing with RFC1766-style language tags

SYNOPSIS
========

     use I18N::LangTags qw(is_language_tag same_language_tag
                           extract_language_tags super_languages
                           similarity_language_tag is_dialect_of
                           locale2language_tag alternate_language_tags
                           encode_language_tag
                          );

   ...or whatever of those functions you want to import.  Those are all
the exportable functions - you're free to import only some, or none at
all.  By default, none are imported.

   If you don't import any of these functions, assume a `&I18N::LangTags::'
in front of all the function names in the following examples.

DESCRIPTION
===========

   Language tags are a formalism, described in RFC 1766, for declaring
what language form (language and possibly dialect) a given chunk of
information is in.

   This library provides functions for common tasks involving language
tags as they are needed in a variety of protocols and applications.

   Please see the "See Also" references for a thorough explanation of how
to correctly use language tags.

   * the function is_language_tag($lang1)

     Returns true iff $lang1 is a formally valid language tag.

          is_language_tag("fr")            is TRUE
          is_language_tag("x-jicarilla")   is FALSE
              (Subtags can be 8 chars long at most -- 'jicarilla' is 9)

          is_language_tag("i-Klikitat")    is TRUE
              (True without regard to the fact noone has actually
               registered Klikitat -- it's a formally valid tag)

          is_language_tag("fr-patois")     is TRUE
              (Formally valid -- altho descriptively weak!)

          is_language_tag("Spanish")       is FALSE
          is_language_tag("french-patois") is FALSE
              (No good -- first subtag has to match
               /^([xXiI]|[a-zA-Z]{2})$/ -- see RFC1766)

   * the function extract_language_tags($whatever)

     Returns a list of whatever looks like formally valid language tags in
     $whatever.  Not very smart, so don't get too creative with what you
     want to feed it.

          extract_language_tags("fr, fr-ca, i-mingo")
            returns:   ('fr', 'fr-ca', 'i-mingo')

          extract_language_tags("It's like this: I'm in fr -- French!")
            returns:   ('It', 'in', 'fr')
          (So don't just feed it any old thing.)

   * the function same_language_tag($lang1, $lang2)

     Returns true iff $lang1 and $lang2 are acceptable variant tags
     representing the same language-form.

          same_language_tag('x-kadara', 'i-kadara')  is TRUE
             (The x/i- alternation doesn't matter)
          same_language_tag('X-KADARA', 'i-kadara')  is TRUE
             (...and neither does case)
          same_language_tag('en',       'en-US')     is FALSE
             (all-English is not the SAME as US English)
          same_language_tag('x-kadara', 'x-kadar')   is FALSE
             (these are totally unrelated tags)

     `same_language_tag' works by just seeing whether
     `encode_language_tag($lang1)' is the same as
     `encode_language_tag($lang2)'.

     (Yes, I know this function is named a bit oddly.  Call it historic
     reasons.)

   * the function similarity_language_tag($lang1, $lang2)

     Returns an integer representing the degree of similarity between tags
     $lang1 and $lang2 (the order of which does not matter), where
     similarity is the number of common elements on the left, without
     regard to case and to x/i- alternation.

          similarity_language_tag('fr', 'fr-ca')           is 1
             (one element in common)
          similarity_language_tag('fr-ca', 'fr-FR')        is 1
             (one element in common)

          similarity_language_tag('fr-CA-joual',
                                  'fr-CA-PEI')             is 2
          similarity_language_tag('fr-CA-joual', 'fr-CA')  is 2
             (two elements in common)

          similarity_language_tag('x-kadara', 'i-kadara')  is 1
             (x/i- doesn't matter)

          similarity_language_tag('en',       'x-kadar')   is 0
          similarity_language_tag('x-kadara', 'x-kadar')   is 0
             (unrelated tags -- no similarity)

          similarity_language_tag('i-cree-syllabic',
                                  'i-cherokee-syllabic')   is 0
             (no B<leftmost> elements in common!)

   * the function is_dialect_of($lang1, $lang2)

     Returns true iff language tag $lang1 represents a subdialect of
     language tag $lang2.

     *Get the order right!  It doesn't work the other way around!*

          is_dialect_of('en-US', 'en')            is TRUE
            (American English IS a dialect of all-English)

          is_dialect_of('fr-CA-joual', 'fr-CA')   is TRUE
          is_dialect_of('fr-CA-joual', 'fr')      is TRUE
            (Joual is a dialect of (a dialect of) French)

          is_dialect_of('en', 'en-US')            is FALSE
            (all-English is a NOT dialect of American English)

          is_dialect_of('fr', 'en-CA')            is FALSE

          is_dialect_of('en',    'en'   )            is TRUE
          is_dialect_of('en-US', 'en-US')            is TRUE
            (B<Note:> these are degenerate cases)

          is_dialect_of('i-mingo-tom', 'x-Mingo') is TRUE
            (the x/i thing doesn't matter, nor does case)

   * the function super_languages($lang1)

     Returns a list of language tags that are superordinate tags to $lang1
     - it gets this by removing subtags from the end of $lang1 until
     nothing (or just "i" or "x") is left.

          super_languages("fr-CA-joual")  is  ("fr-CA", "fr")

          super_languages("en-AU")  is  ("en")

          super_languages("en")  is  empty-list, ()

          super_languages("i-cherokee")  is  empty-list, ()
           ...not ("i"), which would be illegal as well as pointless.

     If $lang1 is not a valid language tag, returns empty-list in a list
     context, undef in a scalar context.

     A notable and rather unavoidable problem with this method:
     "x-mingo-tom" has an "x" because the whole tag isn't an
     IANA-registered tag - but super_languages('x-mingo-tom') is
     ('x-mingo') - which isn't really right, since 'i-mingo' is
     registered.  But this module has no way of knowing that.  (But note
     that same_language_tag('x-mingo', 'i-mingo') is TRUE.)

     More importantly, you assume *at your peril* that superordinates of
     $lang1 are mutually intelligible with $lang1.  Consider this
     carefully.

   * the function locale2language_tag($locale_identifier)

     This takes a locale name (like "en", "en_US", or "en_US.ISO8859-1")
     and maps it to a language tag.  If it's not mappable (as with,
     notably, "C" and "POSIX"), this returns empty-list in a list context,
     or undef in a scalar context.

          locale2language_tag("en") is "en"

          locale2language_tag("en_US") is "en-US"

          locale2language_tag("en_US.ISO8859-1") is "en-US"

          locale2language_tag("C") is undef or ()

          locale2language_tag("POSIX") is undef or ()

          locale2language_tag("POSIX") is undef or ()

     I'm not totally sure that locale names map satisfactorily to language
     tags.  Think REAL hard about how you use this.  YOU HAVE BEEN WARNED.

   * the function encode_language_tag($lang1)

     This function, if given a language tag, returns an encoding of it such
     that:

     * tags representing different languages never get the same encoding.

     * tags representing the same language always get the same encoding.

     * an encoding of a formally valid language tag always is a string
     value that is defined, has length, and is true if considered as a
     boolean.

     Note that the encoding itself is not a formally valid language tag.
     Note also that you cannot, currently, go from an encoding back to a
     language tag that it's an encoding of.

     Note also that you must consider the encoded value as atomic; i.e.,
     you should not consider it as anything but an opaque, unanalysable
     string value.  (The internals of the encoding method may change in
     future versions, as the language tagging standard changes over time.)

     `encode_language_tag' returns undef if given anything other than a
     formally valid language tag.

     The reason `encode_language_tag' exists is because different language
     tags may represent the same language; this is normally treatable with
     `same_language_tag', but consider this situation:

     You have a data file that expresses greetings in different languages.
     Its format is "[language tag]=[how to say 'Hello']", like:

          en-US=Hiho
          fr=Bonjour
          i-mingo=Hau'

     And suppose you write a program that reads that file and then runs as
     a daemon, answering client requests that specify a language tag and
     then expect the string that says how to greet in that language.  So an
     interaction looks like:

          greeting-client asks:    fr
          greeting-server answers: Bonjour

     So far so good.  But suppose the way you're implementing this is:

          my %greetings;
          die unless open(IN, "<in.dat");
          while(<IN>) {
            chomp;
            next unless /^([^=]+)=(.+)/s;
            my($lang, $expr) = ($1, $2);
            $greetings{$lang} = $expr;
          }
          close(IN);

     at which point %greetings has the contents:

          "en-US"   => "Hiho"
          "fr"      => "Bonjour"
          "i-mingo" => "Hau'"

     And suppose then that you answer client requests for language $wanted
     by just looking up $greetings{$wanted}.

     If the client asks for "fr", that will look up successfully in
     %greetings, to the value "Bonjour".  And if the client asks for
     "i-mingo", that will look up successfully in %greetings, to the value
     "Hau'".

     But if the client asks for "i-Mingo" or "x-mingo", or "Fr", then the
     lookup in %greetings fails.  That's the Wrong Thing.

     You could instead do lookups on $wanted with:

          use I18N::LangTags qw(same_language_tag);
          my $repsonse = '';
          foreach my $l2 (keys %greetings) {
            if(same_language_tag($wanted, $l2)) {
              $response = $greetings{$l2};
              last;
            }
          }

     But that's rather inefficient.  A better way to do it is to start your
     program with:

          use I18N::LangTags qw(encode_language_tag);
          my %greetings;
          die unless open(IN, "<in.dat");
          while(<IN>) {
            chomp;
            next unless /^([^=]+)=(.+)/s;
            my($lang, $expr) = ($1, $2);
            $greetings{
                        encode_language_tag($lang)
                      } = $expr;
          }
          close(IN);

     and then just answer client requests for language $wanted by just
     looking up

          $greetings{encode_language_tag($wanted)}

     And that does the Right Thing.

   * the function alternate_language_tags($lang1)

     This function, if given a language tag, returns all language tags that
     are alternate forms of this language tag.  (There is little
     alternation in the current language tagging formalism, but extensions
     to the formalism are under consideration which could add a great deal
     of alternation.)

     Examples from the current formalism:

          alternate_language_tags('en')           is   ()
          alternate_language_tags('x-mingo-tom')  is   ('i-mingo-tom')
          alternate_language_tags('x-klikitat')   is   ('i-klikitat')
          alternate_language_tags('i-klikitat')   is   ('x-klikitat')

     This function returns undef if given anything other than a formally
     valid language tag.

NOTE ABOUT FUTURE VERSIONS
==========================

   I *will* need to change this library *when* RFC1766 is superceded.
Currently (1999-03-06) there are plans to do just that, by adding a whole
series of *three*-letter language codes like "nav" for Navajo - which
would currently be a formally invalid language code.  Be sure to check
CPAN for updates of this library.

ABOUT LOWERCASING
=================

   I've considered making all the above functions that output language
tags return all those tags strictly in lowercase.  Having all your
language tags in lowercase does make some things easier.  But you might as
well just lowercase as you like, or call `encode_language_tag($lang1)'
where appropriate.

ABOUT UNICODE PLAINTEXT LANGUAGE TAGS
=====================================

   In some future version of I18N::LangTags, I plan to include support for
RFC2482-style language tags - which are basically just normal language
tags with their ASCII characters shifted into Plane 14.

SEE ALSO
========

   * RFC 1766, `ftp://ftp.isi.edu/in-notes/rfc1766.txt', "Tags for the
Identification of Languages".

   * RFC 2277, `ftp://ftp.isi.edu/in-notes/rfc2277.txt', "IETF Policy on
Character Sets and Languages".

   * RFC 2231, `ftp://ftp.isi.edu/in-notes/rfc2231.txt', "MIME Parameter
Value and Encoded Word Extensions: Character Sets, Languages, and
Continuations".

   * RFC 2482, `ftp://ftp.isi.edu/in-notes/rfc2482.txt', "Language Tagging
in Unicode Plain Text".

   * Locale::Codes, in `http://www.perl.com/CPAN/modules/by-module/Locale/'

   * ISO 639, "Code for the representation of names of languages",
`http://www.indigo.ie/egt/standards/iso639/iso639-1-en.html'

   * The IANA list of registered languages (hopefully up-to-date),
`ftp://ftp.isi.edu/in-notes/iana/assignments/languages/'

COPYRIGHT
=========

   Copyright (c) 1998,1999,2000 Sean M. Burke. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Sean M. Burke `sburke@cpan.org'


File: pm.info,  Node: IETF/ACE,  Next: IMAP/Admin,  Prev: I18N/LangTags,  Up: Module List

Perl extension for IETF IDN WG ACE character conversions
********************************************************

NAME
====

   IETF::ACE - Perl extension for IETF IDN WG ACE character conversions

SYNOPSIS
========

     use IETF::ACE qw / ... /;

DESCRIPTION
===========

   IETF::ACE - Perl extension for IETF IDN WG ACE character conversions

     Subroutines

     UCS4toName
     UCS4toUPlus
     UTF5toUCS4
     GetCharFromUTF5
     UCS4toRACE
     RACEtoUCS4
     UCS4toLACE
     LACEtoUCS4
     Base32Encode
     Base32Decode
     CheckForSTD13Name
     CheckForBadSurrogates
     HexOut
     DebugOn
     DebugOff
     DebugOut

     The formats are:

     utf8
     utf16
     ucs4
     utf5      from draft-jseng-utf5-01.txt
     race      draft-ietf-idn-race-03.txt
     lace      draft-ietf-idn-lace-01.txt
     name      The character names; output only
     u+        The character hex values in U+ notation; output only

   Sample Program

     use strict;
     use diagnostics;

     use Unicode::String qw / utf8 /;
     use IETF::ACE qw / &UCS4toRACE /;

     my $TheIn="ábcde"; # .com

     my $TheUCS4 = utf8($TheIn)->ucs4;

     my $TheOut = &UCS4toRACE($TheUCS4);

     print <<EOD;
     Latin1 Input = $TheIn.com
     RACE Output = $TheOut.com
     EOD

EXPORT
------

   None by default.

AUTHOR
======

   Paul Hoffman, Internet Mail Consortium phoffman@mail.imc.org

   James Briggs, ActiveMessage, Inc.  james@rf.net

SEE ALSO
========

   *Note Perl: (perl.info)perl,.


