This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Verilog/Parser,  Next: Verilog/SigParser,  Prev: Verilog/Parse,  Up: Module List

Parse Verilog language files
****************************

NAME
====

   Verilog::Parser - Parse Verilog language files

SYNOPSIS
========

     use Verilog::Parser;

     my $parser = new Verilog::Parser;
     $string = $parser->unreadback ();
     $line   = $parser->line ();
     $parser->parse ($text)
     $parser->parse_file ($filename)

DESCRIPTION
===========

   The `Verilog::Parser' package will tokenize a Verilog file when the
parse() method is called and invoke various callback methods.

   The external interface to Verilog::Parser is:

$parser = Verilog::Parser->new
     Create a new Parser.

$parser->parse ($string)
     Parse the $string as a verilog file.  Can be called multiple times.
     The return value is a reference to the parser object.

$parser->parse_file ($filename);
     This method can be called to parse text from a file.  The argument can
     be a filename or an already opened file handle. The return value from
     parse_file() is a reference to the parser object.

$parser->unreadback ()
     Return any input string from the file that has not been sent to the
     callback.  This will include whitespace and tokens which did not have
     a callback.  (For example comments, if there is no comment callback.)
     This is useful for recording the entire contents of the input, for
     preprocessors, pretty-printers, and such.

$parser->line ($set)
     Return (if $set is undefined) or set current line number.

$parser->filename ($set)
     Return (if $set is undefined) or set current filename.

   In order to make the parser do anything interesting, you must make a
subclass where you override one or more of the following methods as
appropriate:

$self->comment ( $token )
     This method is called when any text in // or /**/ comments are
     recognized.  The first argument, $token, is the contents of the
     comment excluding the comment delimiters.

$self->string ( $token )
     This method is called when any text in double quotes are recognized.
     The first argument, $token, is the contents of the string including
     the quotes.

$self->keyword ( $token )
     This method is called when any Verilog keyword is recognized.  The
     first argument, $token, is the keyword.

$self->symbol ( $token )
     This method is called when any Verilog symbol is recognized.  A
     symbol is considered a non-keyword bareword.  The first argument,
     $token, is the symbol.

$self->operator ( $token )
     This method is called when any symbolic operator (+, -, etc) is
     recognized.  The first argument, $token, is the operator.

$self->number ( $token )
     This method is called when any number is recognized.  The first
     argument, $token, is the number.  The Verilog::Language::number_value
     function may be useful for converting a Verilog value to a perl
     integer.

EXAMPLE
=======

   Here\'s a simple example which will print every symbol in a verilog
file.

   package MyParser; use Verilog::Parser;  @ISA = qw(Verilog::Parser);

   # parse, parse_file, etc are inherited from Verilog::Parser sub new {
 my $class = shift;     #print "Class $class\n";     my $self =
$class->SUPER::new();     # we could have inherited new, but we want to
initialize symbols     %{$self->{symbols}} = ();     bless $self, $class;
  return $self; }

   sub symbol {     my $self = shift;     my $token = shift;

   $self->{symbols}{$token}++; }

   sub report {     my $self = shift;

     foreach my $sym (sort keys %{$self->{symbols}}) {
     	 printf "Symbol %-30s occurs %4d times\n",
     	 $sym, $self->{symbols}{$sym};
     }
     }

   package main;

   my $parser = MyParser->new(); $parser->parse_file (shift);
$parser->report();

SEE ALSO
========

   `Verilog::ParserSig', `Verilog::Language', `vrename'

BUGS
====

   This is being distributed as a baseline for future contributions.
Don\'t expect a lot, the Parser is still nieve, and there are many awkward
cases that aren\'t covered.

   The parser currently assumes the string it is passed ends on a newline
boundary.  It should be changed to allow arbitrary chunks.

DISTRIBUTION
============

   The latest version is available from
`http://www.ultranet.com/~wsnyder/verilog-perl'.

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Verilog/SigParser,  Next: Video/Capture/V4l,  Prev: Verilog/Parser,  Up: Module List

Signal Parsing for Verilog language files
*****************************************

NAME
====

   Verilog::SigParser - Signal Parsing for Verilog language files

SYNOPSIS
========

     use Verilog::SigParser;

     my $parser = new Verilog::SigParser;
     $string = $parser->unreadback ();
     $line   = $parser->line ();
     $parser->parse ($text)
     $parser->parse_file ($filename)

DESCRIPTION
===========

   The `Verilog::SigParser' package builds upon the Verilog::Parse function
to provide callbacks for when a signal is declared, a module instantiated,
or a module defined.

   The external interface to Verilog::SigParser is described in the
Verilog::Parser module.

   In order to make the parser do anything interesting, you must make a
subclass where you override one or more of the following methods as
appropriate:

$self->module ( $keyword, $name )
     This method is called when a module is defined.

$self->task ( $keyword, $name )
     This method is called when a module is defined.

$self->function ( $keyword, $name )
     This method is called when a function is defined.

$self->signal_decl ( $keyword, $signame, $vector, $mem )
     This method is called when a signal is declared.  The first argument,
     $keyword is ('input', 'output', etc), the second argument is the name
     of the signal.  The third argument is the vector bits or "".  The
     fourth argument is the memory bits or "".

$self->instant ( $module, $cell )
     This method is called when a instantantiation is defined.  The first
     parameter is the name of the module being instantiated, and the second
     parameter is the name of the cell.

SEE ALSO
========

   `Verilog::Parser', `Verilog::Language',

BUGS
====

   This is being distributed as a baseline for future contributions.
Don\'t expect a lot, the Parser is still nieve, and there are many awkward
cases that aren\'t covered.

DISTRIBUTION
============

   The latest version is available from
`http://www.ultranet.com/~wsnyder/verilog-perl'.

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Video/Capture/V4l,  Next: Video/Capture/VBI,  Prev: Verilog/SigParser,  Up: Module List

Perl interface to the Video4linux framegrabber interface.
*********************************************************

NAME
====

   Video::Capture::V4l - Perl interface to the Video4linux framegrabber
interface.

SYNOPSIS
========

     use Video::Capture::V4l;

DESCRIPTION
===========

   Not documentation AGAIN! Please see the scripts grab, inexer or vbi that
are packaged in the distribution and direct any question and feature
requests (as well as bug reports) to the author.

Exported constants
==================

   The following hideous constants are defined in the
`Video::Capture::V4l' package, but you seldom need to use them.

     AUDIO_BASS
     AUDIO_MUTABLE
     AUDIO_MUTE
     AUDIO_TREBLE
     AUDIO_VOLUME
     CAPTURE_EVEN
     CAPTURE_ODD
     MAX_FRAME
     MODE_AUTO
     MODE_NTSC
     MODE_PAL
     MODE_SECAM
     PALETTE_COMPONENT
     PALETTE_GREY
     PALETTE_HI240
     PALETTE_PLANAR
     PALETTE_RAW
     PALETTE_RGB24
     PALETTE_RGB32
     PALETTE_RGB555
     PALETTE_RGB565
     PALETTE_UYVY
     PALETTE_YUV410P
     PALETTE_YUV411
     PALETTE_YUV411P
     PALETTE_YUV420
     PALETTE_YUV420P
     PALETTE_YUV422
     PALETTE_YUV422P
     PALETTE_YUYV
     SOUND_LANG1
     SOUND_LANG2
     SOUND_MONO
     SOUND_STEREO
     TUNER_LOW
     TUNER_MBS_ON
     TUNER_NORM
     TUNER_NTSC
     TUNER_PAL
     TUNER_RDS_ON
     TUNER_SECAM
     TUNER_STEREO_ON
     TYPE_CAMERA
     TYPE_TV
     VC_AUDIO
     VC_TUNER
     TYPE_CAPTURE
     TYPE_CHROMAKEY
     TYPE_CLIPPING
     TYPE_FRAMERAM
     TYPE_MONOCHROME
     TYPE_OVERLAY
     TYPE_SCALES
     TYPE_SUBCAPTURE
     TYPE_TELETEXT
     TYPE_TUNER

AUTHOR
======

   Marc Lehmann <pcg@goof.com>

LICENSE
=======

   This module is available under GPL only (see the file COPYING for
details), if you want an exception please contact the author, who might
grant exceptions freely ;)

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Video/Capture/VBI,  Next: Video/Frequencies,  Prev: Video/Capture/V4l,  Up: Module List

Functions to manipulate vbi fields & lines.
*******************************************

NAME
====

   Video::Capture::VBI - Functions to manipulate vbi fields & lines.

SYNOPSIS
========

     use Video::Capture::VBI;

DESCRIPTION
===========

new
     Create a new VBI decoder object. VBI decoding often requires state,
     which this object represents

reset
     Reset the state (e.g. after switching a channel).


File: pm.info,  Node: Video/Frequencies,  Next: Video/RTjpeg,  Prev: Video/Capture/VBI,  Up: Module List

Many, many frequency constants and lists.
*****************************************

NAME
====

   Video::Frequencies - Many, many frequency constants and lists.

SYNOPSIS
========

     use Video::Frequencies;

     while (my($name,$list) = each %CHANLIST) {
        print "$name\n";
        while (my($channel,$freq) = each %$list) {
           printf "   %-4s %9d\n", $channel, $freq;
        }
        print "\n";
     }

DESCRIPTION
===========

   This module exports (yes, exports!) frequency constants as well as
hashes with channel => frequency relations for digital and analog video
and audio broadcast. Another, shorter way to put it is "worldwide
channel/frequency list". All frequencies are given in kHz.

   It's a good idea to use `perldoc -m Video::Frequencies' to get an idea
on how the various constants and lists look like.

Exported Audio Carrier Frequencies
==================================

     NTSC_AUDIO_CARRIER
     PAL_AUDIO_CARRIER_I
     PAL_AUDIO_CARRIER_BGHN
     PAL_AUDIO_CARRIER_MN
     PAL_AUDIO_CARRIER_D
     SEACAM_AUDIO_DKK1L
     SEACAM_AUDIO_BG
     NICAM728_PAL_BGH
     NICAM728_PAL_I

   NICAM 728 32-kHz, 14-bit digital stereo audio is transmitted in 1ms
frames containing 8 bits frame sync, 5 bits control, 11 bits additional
data, and 704 bits audio data.  The bit rate is reduced by transmitting
only 10 bits plus parity of each 14 bit sample, the largest sample in a
frame determines which 10 bits are transmitted.  The parity bits for audio
samples also specify the scaling factor used for that channel during that
frame.  The companeded audio data is interleaved to reduce the influence
of dropouts and the whole frame except for sync bits is scrambled for
spectrum shaping.  Data is modulated using QPSK, at below following
subcarrier freqs

Broadcast Format by Country
===========================

(M) NTSC
     Antigua, Aruba, Bahamas, Barbados, Belize, Bermuda, Bolivia, Burma,
     Canada, Chile, Colombia, Costa Rica, Cuba, Curacao, Dominican
     Republic, Ecuador, El Salvador, Guam Guatemala, Honduras, Jamaica,
     Japan, South Korea, Mexico, Montserrat, Myanmar, Nicaragua, Panama,
     Peru, Philippines, Puerto Rico, St Christopher and Nevis, Samoa,
     Suriname, Taiwan, Trinidad/Tobago, United States, Venezuela, Virgin
     Islands

(B) PAL
     Albania, Algeria, Australia, Austria, Bahrain, Bangladesh, Belgium,
     Bosnia-Herzegovinia, Brunei Darussalam, Cambodia, Cameroon, Croatia,
     Cyprus, Denmark, Egypt, Ethiopia, Equatorial Guinea, Finland, Germany,
     Ghana, Gibraltar, Greenland, Iceland, India, Indonesia, Israel, Italy,
     Jordan, Kenya, Kuwait, Liberia, Libya, Luxembourg, Malaysa, Maldives,
     Malta, Nepal, Netherlands, New Zeland, Nigeria, Norway, Oman,
     Pakistan, Papua New Guinea, Portugal, Qatar, Sao Tome and Principe,
     Saudi Arabia, Seychelles, Sierra Leone, Singapore, Slovenia, Somali,
     Spain, Sri Lanka, Sudan, Swaziland, Sweden, Switzeland, Syria,
     Thailand, Tunisia, Turkey, Uganda, United Arab Emirates, Yemen

(N) PAL
     Argentina (Combination N), Paraguay, Uruguay

(M) PAL (525/60, 3.57MHz burst)
     Brazil

(G) PAL
     Albania, Algeria, Austria, Bahrain, Bosnia/Herzegovinia, Cambodia,
     Cameroon, Croatia, Cyprus, Denmark, Egypt, Ethiopia, Equatorial
     Guinea, Finland, Germany, Gibraltar, Greenland, Iceland, Israel,
     Italy, Jordan, Kenya, Kuwait, Liberia, Libya, Luxembourg, Malaysia,
     Monaco, Mozambique, Netherlands, New Zealand, Norway, Oman, Pakistan,
     Papa New Guinea, Portugal, Qatar, Romania, Sierra Leone, Singapore,
     Slovenia, Somalia, Spain, Sri Lanka, Sudan, Swaziland, Sweeden,
     Switzerland, Syria, Thailand, Tunisia, Turkey, United Arab Emirates,
     Yemen, Zambia, Zimbabwe

(D) PAL
     China, North Korea, Romania, Czech Republic

(H) PAL
     Belgium

(I) PAL
     Angola, Botswana, Gambia, Guinea-Bissau, Hong Kong, Ireland, Lesotho,
     Malawi, Nambia, Nigeria, South Africa, Tanzania, United Kingdom,
     Zanzibar

(B) SECAM
     Djibouti, Greece, Iran, Iraq, Lebanon, Mali, Mauritania, Mauritus,
     Morocco

(D) SECAM
     Afghanistan, Armenia, Azerbaijan, Belarus, Bulgaria, Estonia, Georgia,
     Hungary, Zazakhstan, Lithuania, Mongolia, Moldova, Poland, Russia,
     Slovak Republic, Ukraine, Vietnam

(G) SECAM
     Greece, Iran, Iraq, Mali, Mauritus, Morocco, Saudi Arabia

(K) SECAM
     Armenia, Azerbaijan, Bulgaria, Estonia, Georgia, Hungary, Kazakhstan,
     Lithuania, Madagascar, Moldova, Poland, Russia, Slovak Republic,
     Ukraine, Vietnam

(K1) SECAM
     Benin, Burkina Faso, Burundi, Chad, Cape Verde, Central African
     Republic, Comoros, Congo, Gabon, Madagascar, Niger, Rwanda, Senegal,
     Togo, Zaire

(L) SECAM
     France

Channel->Frequency Relations
============================

   The Channel->Frequency relations are stored in the following hashes. The
keys are the Channel names, the values are the corresponding frequency in
kHz. For example, "arte" is channel "SE6" in the town in Germany I live
in, so, consequently, $PAL_EUROPE{SE6} equals 140250, the frequency I have
to tune my receiver.

     US broadcast          %NTSC_BCAST
     US cable              %NTSC_CABLE
     US HRC                %NTSC_HRC
     JP broadcast          %NTSC_BCAST_JP
     JP cable              %NTSC_CABLE_JP
     Australia             %PAL_AUSTRALIA
     Europe                %PAL_EUROPE
     Europe East           %PAL_EUROPE_EAST
     Italy                 %PAL_ITALY
     Ireland               %PAL_IRELAND
     Newzealand            %PAL_NEWZEALAND

     CCIR frequencies      %FREQ_CCIR_I_III
                           %FREQ_CCIR_SL_SH
                           %FREQ_CCIR_H
     OIRT frequencies      %FREQ_OIRT_I_III
                           %FREQ_OIRT_SL_SH
                           %FREQ_UHF

The List of Lists
=================

   The hash %CHANLIST contains name => channel-list pairs, e.g.
$CHANLIST{"ntsc-bcast"} contains a reference to %NTSC_BCAST.

AUTHOR
======

   Nathan Laredo (laredo@broked.net), adapted to perl by Marc Lehmann
<pcg@goof.com>


File: pm.info,  Node: Video/RTjpeg,  Next: Video/XawTV,  Prev: Video/Frequencies,  Up: Module List

Real time, jpeg-like video compression.
***************************************

NAME
====

   Video::RTjpeg - Real time, jpeg-like video compression.

SYNOPSIS
========

     use Video::RTjpeg;

DESCRIPTION
===========


File: pm.info,  Node: Video/XawTV,  Next: VoiceXML/Server,  Prev: Video/RTjpeg,  Up: Module List

read, create and edit .xawtvrc's.
*********************************

NAME
====

   Video::XawTV - read, create and edit .xawtvrc's.

SYNOPSIS
========

     use Video::XawTV;

     $rc = new Video::XawTV;
     # - or -
     $rc = new Video::XawTV "$HOME{ENV}/.xawtv";
     $rc->load("otherrcfile");
     $rc->save;
     $rc->save("filename");

     $source = $rc->opt('source');
     $rc->opt('source') = "Television";

     @channels = $rc->channels;
     $rc->channels(@channels);

     print $channels[0]{name};	# Arte
     print $channels[0]{channel};	# E4

DESCRIPTION
===========

   Pardon? Ha! Haa! Hahahahahaha!!!


File: pm.info,  Node: VoiceXML/Server,  Next: WDDX,  Prev: Video/XawTV,  Up: Module List

An easy-to-use VoiceXML server class
************************************

NAME
====

   VoiceXML::Server - An easy-to-use VoiceXML server class

SYNOPSIS
========

     #!/usr/bin/perl -w
     use diagnostics;
     use strict;

     require VoiceXML::Server;
     my $server = VoiceXML::Server->new(avoidfirewall => 1);

     $server->Audio("Pick a number between 1 and 99.");

     my $num = int(rand(99)) + 1;

     while (1) {
         my $guess = $server->Listen(grammar => "NATURAL_NUMBER_THRU_99");
         if ($guess < $num) {
             $server->Audio("No, $guess is too low.  Try again.");
         } elsif ($guess > $num) {
             $server->Audio("No, $guess is too high.  Try again.");
         } else {
             $server->Audio("That's right, my number was $num.  OK, " .
                            "let's play again.  I'm thinking of a " .
                            "different number.");
             $num = int(rand(99)) + 1;
         }
     }

DESCRIPTION
===========

   `VoiceXML::Server' is a class implementing a simple server for VoiceXML
applications.  It was designed in particular to work with Tellme Studio (
http://studio.tellme.com/ ), although it should also work with other
VoiceXML products.

   Using this library, you can make programs that you interact with over
the phone.  Using Tellme Studio, you can develop and debug your program by
calling a toll-free number.  You can then publish your finished
application to be a part of the main Tellme service, at 1-800-555-TELL.

   Applications written using `VoiceXML::Server' install as a CGI scripts.
However, unlike most web server software, they do not get repeatedly
executed every time the user responds to an interaction.  Instead, the
script gets invoked only once per user, and it can remember the state of
the interaction on the stack and in local variables.  This is a much, much
easier way to code than traditional web solutions provide, as the above
example should illustrate.

   The disadvantage of this approach is that it can be more expensive to
support, and performance can suffer compared to hand-tuned VoiceXML code.

INSTALLATION
============

   The trickiest part of all this is setting up Tellme Studio and an
initial application and getting things up and limping.  Once you've done
that, it's easy to tweak the application to make it do virtually anything
you can think of.

   Here's the steps to get the above "guess a number" example code up and
running.

   First, get yourself a webserver where you can install CGI scripts.
Learning about that is beyond the scope of this document.

   Next, make sure that the version of perl on that server includes this
VoiceXML::Server module.  This is done by the usual CPAN method of
unpacking the tarball and running the following commands (you may have to
be root to do 'make install'):

     perl Makefile.PL
     make
     make test
     make install

   Next, cut and paste the above example code into a file on your server.
I'll assume that file is called "guessanumber.cgi".  You may need to
change the first line to point to your perl executable.

   Next, you can run the "guessanumber.cgi" executable on the command
line.  The VoiceXML::Server library will automatically detect that you are
running on the command line instead of being served from a webserver, and
will play the game in dumb terminal mode.  This is a very useful technique
for debugging the logic of your program without worrying about all the
telephony details.

   When you can run guessanumber.cgi on the command line, then you know
you have all the perl setup done properly.  Next, go to
http://studio.tellme.com/ and create an account by clicking the "join
studio" link.  This is all pretty self-explainatory.

   Once you're able to log into your Tellme Studio account, and have
accepted the terms of service, you need tell Studio where your application
lives.  Click on the "MyStudio" link at left of the screen.  Log in if
necessary.  Make sure the "Application URL" tab is selected; click on it
if it is not.  Then type the full URL to get to your guessanumber.cgi
script, and click the "Update" button.

   At this point, you should be able to call the toll-free number listed
on that page.  Enter your Studio Developer ID and PIN on the phone, and
you should find yourself playing the "guess a number" game.

METHODS
=======

   The following methods are available:

$server = VoiceXML::Server->new([name => value, ...]);
     Constructs the server object.  Can take the following named arguments:

    minport
          Specifies the smallest port number to try and use.  Defaults to
          7500.

    maxport
          Specifies the biggest port number to try and use.  Defaults to
          7550.

    avoidfirewall
          If set to 1 (as in the example at the top of this document), then
          extra stuff will be done to avoid firewalls.  VoiceXML::Server
          works by spawning off a new server process, speaking the HTTP
          protocol, usually on a port between 7500 and 7550.  Sometimes
          firewalls will get in the way and prevent the VoiceXML browser
          from reaching these ports.  If you turn on avoidfirewall, then
          things will always work, but there will be a noticable
          performance penalty.  If at all possible, don't use this.

          If all the ports in the designated range are already being used,
          it will continue to try and use a higher port number, but will
          turn on the avoidfirewall behavior.  So, you can just punch a
          few ports through your firewall, and have things work even if
          those get filled up.

    debug
          If you set debug to 1, then files will be created in /tmp
          containing debugging output.  This is very useful to determine
          what causes crashes or weird behaviors.  But remember, the first
          thing to try is just running your program on the command line.

$server->Audio([wav => 'file.wav'], [tts =>'text here']);
     The `Audio' method takes up to two named parameters, wav and tts.  At
     least one of these must be provided.

    wav
          wav specifies a .wav audio file.  This file will be played.

    tts
          tts specifies plain text.  (tts stands for Text To Speech.)  This
          will be read in a computerized voice over the phone if a .WAV
          file isn't specified or isn't found.

     You can also call `Audio' with one or two non-named parameters.  If
     you pass it only one parameter, it is assumed to be a tts value.  If
     you pass it two parameters, the first one is treated as a wav value,
     and the second as a tts value.

$server->Pause(milliseconds => $num)
     The Pause method introduces a pause of the given number of
     milliseconds. Use it between pieces of audio so that the audio sounds
     more natural.  It must be called using the named parameter syntax.

$server->Listen(grammar => $grammar, [nomatch => $nomatchstr],  [noinput => $noinputstr], [timeout => $seconds]);
     The Listen method will wait for the user to say something, and return
     that value.

    grammar => $grammar
          grammar specifies the set of valid expressions that a user can
          say at this point.  To learn more about grammars, please see the
          Tellme Studio documentation at
          http://studio.tellme.com/grammarref/.  You must specify either
          grammar or grammarsrc.

    grammarsrc => $grammarfile
          grammarsrc specifies a file containing a grammar.  The grammar
          file will be downloaded in a separate server transaction, much
          as audio files (or image files in the HTML world) get downloaded
          separately.  This is the right thing to do if your grammar is
          very big and does not dynamically change.

    nomatch => $nomatch
          nomatch specifies what value to return if the user says something
          that could not be matched by the grammar.  If you do not give
          this parameter, then the VoiceXML::Server library will
          automatically tell the user it didn't understand and will
          reprompt them.  This behavior does not always work out so well,
          though, and it is a good idea to provide your own nomatch
          handling.

    noinput => $noinput
          noinput specifies what value to return if the user does not say
          anything.  If you do not give this parameter, then the
          VoiceXML::Server library will automatically tell the user it
          didn't hear anything and will reprompt them.  This behavior does
          not always work out so well, though, and it is a good idea to
          provide your own noinput handling.

    timeout => $seconds
          timeout specifies how many seconds to wait before generating a
          noinput event.  If you do not specify one, a platform default
          value is used.

$server->GoToURL(url)
     `GoToURL' is used to exit your application.  It specifies a URL of
     another VoiceXML page that should be loaded.

CHANGE LOG
==========

     * $Log: Server.pm,v $
     * Revision 1.6  2000/10/03 22:07:08  weissman
     * Fixed minor typo.
     *
     * Revision 1.5  2000/10/03 19:17:25  weissman
     * Added "Cache-Control: no-cache" header.
     *
     * Revision 1.4  2000/09/29 22:35:54  weissman
     * Added 'grammarsrc' parameter to Listen(), so that you can now specify
     * a separate grammar file.
     *
     * Revision 1.3  2000/09/27 22:23:53  weissman
     * GoToURL() wasn't working if given a relative URL.
     *
     * Revision 1.2  2000/09/27 18:22:05  weissman
     * Allow specifying the range of ports to use.
     *
     * Revision 1.1  2000/09/26 23:26:53: weissman
     * Initial release of Server::VoiceXML module.

AUTHOR
======

   Terry Weissman <weissman@tellme.com>

   Web page: http://studio.tellme.com/downloads/VoiceXML-Server/


File: pm.info,  Node: WDDX,  Next: WML/Card,  Prev: VoiceXML/Server,  Up: Module List

a module for reading and writing WDDX packets
*********************************************

NAME
====

   WDDX.pm - a module for reading and writing WDDX packets

SYNOPSIS
========

     use WDDX;
     my $wddx = new WDDX;
     
     ##########################
     ## Serialization example
     
     my $wddx_hash = $wddx->hash( {
             str     =>  $wddx->string( "Welcome to WDDX!\n" ),
             num     =>  $wddx->number( -12.456 ),
             date    =>  $wddx->datetime( date ),
             bool    =>  $wddx->boolean( 1 ),
             arr     =>  $wddx->array( [
                         $wddx->boolean( 0 ),
                         $wddx->number( 10 ),
                         $wddx->string( "third element" ),
                     ] ),
             rec     =>  $wddx->recordset(
                         [ "NAME", "AGE" ],
                         [ "string", "number" ],
                         [
                             [ "John Doe", 34 ],
                             [ "Jane Doe", 25 ],
                             [ "Fred Doe", 90 ],
                         ]
                     ),
             obj     =>  $wddx->hash( {
                         str => $wddx->string( "a string" ),
                         num => $wddx->number( 3.14159 ),
                     } ),
             bin     => $wddx->binary( $img_data ),
             null    => $wddx->null(),
         } );
     
     print $wddx->header;
     print $wddx->serialize( $wddx_hash );
     
     ##########################
     ## Deserialization example
     
     my $wddx_request = $wddx->deserialize( $packet );
     
     # Assume that our code expects an array
     $wddx_request->type eq "array" or die "Invalid request";
     my $array_ref = $wddx_request->as_arrayref;

DESCRIPTION
===========

About WDDX
----------

   This is from the WDDX.org web site: "The Web Distributed Data Exchange,
or WDDX, is a free, open XML-based technology that allows Web applications
created with any platform to easily exchange data with one another over
the Web."

   For more information about WDDX, visit http://www.wddx.org/. For
information about using Perl with WDDX (including examples) you can also
visit http://www.scripted.com/wddx/.

WDDX and Perl
-------------

   WDDX defines basic data types that mirror the data types available in
other common programming languages. Many of these data types don't have
corresponding data types in Perl. To Perl, strings, numbers, booleans, and
dates are just scalars. However, in order to communicate effectively with
other languages (and this is the point of WDDX), you do have to learn the
basic WDDX data types. Here is a table that maps the WDDX data type to
Perl, along with the intermediate object WDDX.pm represents it as:

     WDDX Type      WDDX.pm Data Object      Perl Type
     ---------      -------------------      ---------
     String         WDDX::String             Scalar
     Number         WDDX::Number             Scalar
     Boolean        WDDX::Boolean            Scalar (1 or "")
     Datetime       WDDX::Datetime           Scalar (seconds since epoch)
     Null           WDDX::Null               Scalar (undef)
     Binary         WDDX::Binary             Scalar
     Array          WDDX::Array              Array
     Struct         WDDX::Struct             Hash
     Recordset      WDDX::Recordset          WDDX::Recordset

   In languages that have data types similar to the WDDX data types, the
WDDX modules allow you to convert directly from a variable to a WDDX
packet and vice versa. This Perl implementation is different; here you
must always go through an intermediate stage where the data is represented
by an object with a corresponding data type. These objects can be
converted to a WDDX packet, converted to a basic Perl type, or converted
to JavaScript code (which will recreate the data for you in JavaScript).
We will refer to these objects as *data objects* throughout this
documentation.

Requirements
============

   This module requires *Note XML/Parser: XML/Parser, and *Note
MIME/Base64: MIME/Base64,, which are both available on CPAN at
http://www.cpan.org/. Windows users note: These modules use compiled code,
but I have been told that they are both included with recent distributions
of ActiveState Perl.

METHODS
=======

new
     This creates a new WDDX object. You need one of these to do pretty
     much anything else. It doesn't take any arguments.

$wddx->deserialize( $string_or_filehandle )
     This method deserializes a WDDX packet and returns a data object. Note
     that you can pass either a string or a reference to an open filehandle
     containing a packet (XML::Parser is flexible this way):

          $wddx_obj = $wddx->deserialize( $packet );     # OR
          $wddx_obj = $wddx->deserialize( \*HANDLE );

     If WDDX.pm or the underlying *Note XML/Parser: XML/Parser, finds any
     errors with the structure of the WDDX packet, then it will die with
     an error message that identifies the problem. If you don't want this
     to terminate your script, you will have to place this call within an
     eval block to trap the die.

$wddx->serialize( $wddx_obj )
     This accepts a data object as an argument and returns a WDDX packet.
     This method calls the as_packet() method on the data object it
     receives. However, this method does provide one feature that
     as_packet() does not. If `$WDDX::INDENT' is set to a defined value,
     then the generated WDDX packet is indented using `$WDDX::INDENT' as
     the unit of indentation. Otherwise packets are generated without extra
     whitespace.

     Note that the generated packet is not a valid XML document without
     the header, see below.

$wddx->header
     This returns a header that should accompany every serialized packet
     you send.

WDDX DATA OBJECTS
=================

Common Methods
--------------

   All of the WDDX data objects share the following common methods:

$wddx_obj->type
     This returns the data type of the object. It is lowercase and maps to
     the package name without the WDDX prefix. For example, type will
     return "string" for WDDX::String objects, "datetime" for
     WDDX::Datetime objects, etc.

$wddx_obj->as_packet
     This returns a WDDX packet for the object. You can also do this by
     passing the object to the `$wddx-'serialize> method. See the warning
     in `$wddx-'header>.

$wddx_obj->as_javascript( $js_varname )
     This method takes the name of a JavaScript variable and returns the
     actual JavaScript code to assign this data object to the given
     JavaScript variable. No temporary variables are created to avoid any
     danger of variable name collisions.

     Example:

          $options[0] = $wddx->string( "First Choice" );
          $options[1] = $wddx->string( "Second Choice" );
          $options[2] = $wddx->string( "Third Choice" );
          $w_array    = $wddx->array( \@options );
          print $w_array->as_javascript( "myArray" );

     This prints the text (new lines added for readability):

          myArray=new Array();
          myArray[0]="First Choice";
          myArray[1]="Second Choice";
          myArray[2]="Third Choice";

     All data types are supported, and arrays and hashes (structs) can nest
     to any level. Recordset and binary objects require the JavaScript
     WddxRecordset and WddxBinary constructors. The easiest way to include
     these is to add a reference to the wddx.js file:

          <SCRIPT NAME="javascript" SRC="wddx.js"></SCRIPT>

     wddx.js is the WDDX library for JavaScript. It is available as part of
     the WDDX SDK at http://www.wddx.org/.

WDDX::String
------------

$wddx->string( 'Just a bunch of text...' )
     This creates a WDDX string object. Strings contain 8 bit characters,
     can be any length, and should not include embedded nulls. However,
     control characters and characters that have special meaning for XML
     (like <, >, and E<amp>) are safely encoded for you.

$w_string->as_scalar
     This returns the value of the WDDX::String as a Perl scalar.

WDDX::Number
------------

$wddx->number( 3.14159 )
     This creates a WDDX number object. Numbers are restricted to
     +/-1.7e308 and if you exceed these bounds this method dies with an
     error. Floating point numbers are restricted to 15 digits of accuracy
     past the decimal. If you exceed this then the number is truncated to
     15 digits with a warning. If you pass a non-numeric scalar to this,
     then it is simply treated as a number: Perl will attempt to translate
     it, will probably use zero, and will issue a warning.

$w_number->as_scalar
     This returns the value of the WDDX::Number as a Perl scalar.

WDDX::Boolean
-------------

$wddx->boolean( 1 )
     This creates a WDDX boolean object. It simply tests the argument in a
     boolean context, so "0" and "" are false and anything else is true.

$w_boolean->as_scalar
     This returns the value of the WDDX::Boolean as a Perl scalar. True is
     represented by 1 and false is represented by an empty string.

WDDX::Datetime
--------------

$wddx->datetime
     This creates a WDDX Datetime object.

$w_datetime->use_timezone_info( 1 )
     This sets or reads the flag that says whether to include the timezone
     info (local hour and minute offset from UTC) in WDDX packets created
     from this object. By default this is turned on for new objects. You
     can turn it off by passing a false (but not undef) argument to this
     method.

     When a WDDX::Datetime object is deserialized from a packet, this
     method will indicate whether timezone information was present in that
     packet.

$w_datetime->as_scalar
     This returns the value of the WDDX::Datetime as a Perl scalar. It
     contains the number of seconds since the epoch localized for the
     current machine (like Perl's built-in time function). This number can
     be passed into Perl's localtime function.

WDDX::Null
----------

$wddx->null()
     This creates a WDDX null object. This is roughly the equivalent of
     undef in Perl. It takes no arguments.

$w_datetime->as_scalar
     This simply returns undef (this was a hard one to code :).

WDDX::Binary
------------

$wddx->binary( $binary_data )
     This creates a WDDX binary object. It takes a scalar containing any
     data, which will be base64 encoded before being serialized into the
     packet.

WDDX::Array
-----------

$wddx->array( [ $wddx_obj1, $wddx_obj2, ... ] )
     This creates a WDDX::Array object. It takes a reference to an array
     containing data objects. You must construct a WDDX data object for
     each element of an array before adding them to the array. WDDX::Arrays
     can contain any other WDDX data type and do not need to be of a
     uniform type, so one array can contain a WDDX::String, a
     WDDX::Number, and a WDDX::Struct, for example.

     If you need to create an array of uniform types, Perl's built-in map
     function makes this easy. If you have a standard Perl array called
     `@array', you can generate a WDDX::Array of WDDX::String objects like
     this:

          my @obj_array = map $wddx->number( $_ ), @array;
          my $wddx_array = $wddx->array( \@obj_array );

     If you need to serialize more complicated array structures, refer to
     `array2wddx' in the UTILITY METHODS section.

$wddx_array->as_arrayref()
     This returns a reference to a Perl array. Every element in the
     WDDX::Array is recursively deserialized to Perl data structures. Only
     WDDX::Recordsets remain as WDDX data objects.

$wddx_array->get_element( $i )
$wddx_array->get( $i )
     This allows you to get an element of a WDDX::Array as a data object
     instead of having it deserialized to Perl.

$wddx_array->set( $i => $wddx_obj );
     This allows you to set an element in a WDDX::Array. Note that
     `$wddx_obj' should be a WDDX data object of some type.

$wddx_array->splice( $offset, $length, $wddx_obj1, $wddx_obj2, ... );
$wddx_array->splice( $offset, $length );
$wddx_array->splice( $offset );
     This allows you to insert or delete elements in a WDDX::Array using
     the syntax of Perl's built-in splice function.

$wddx_array->length();
     This returns the number of elements in the WDDX::Array object.

$wddx_array->push( $wddx_obj1, $wddx_obj2, ... );
     This will push the given elements onto the WDDX::Array object.

$wddx_array->pop();
     This will pop the last element off the WDDX::Array object and return
     it.

$wddx_array->unshift( $wddx_obj1, $wddx_obj2, ... );
     This will unshift the given elements onto the WDDX::Array object.

$wddx_array->shift();
     This will shift the first element off the WDDX::Array object and
     return it.

WDDX::Struct
------------

$wddx->struct( { key1 => $wddx_obj1, key2 => $wddx_obj2, ... } )
$wddx->hash  ( { key1 => $wddx_obj1, key2 => $wddx_obj2, ... } )
     This creates a WDDX::Struct object. To WDDX, a struct is simply what
     Perl refers to as a hash (or associative array). These two methods are
     aliases so you can use whichever name you prefer.

     There are no restrictions on keys, but values must be WDDX data types.
     Just like with WDDX::Arrays, you have to create a WDDX data type for
     each value you want to insert into a WDDX::Struct.

     Here's how to use Perl's built-in map function to generate a
     WDDX::Struct if all of your values have the same data type.  If you
     have a standard Perl hash called `%hash', you can generate a
     WDDX::Struct of WDDX::String objects like this:

          my %obj_hash = map { $_ => $wddx->number( $hash{$_} } keys %hash;
          my $wddx_hash = $wddx->hash( \@obj_hash );

     If you need to serialize more complicated hash structures, refer to
     `hash2wddx' in the UTILITY METHODS section.

$wddx_array->as_hashref()
     This returns a reference to a Perl hash. Every element in the hash is
     recursively deserialized to Perl data structures. Only
     WDDX::Recordsets remain as data objects.

$wddx_hash->get_element( $key );
$wddx_hash->get( $key );
     This allows you to get an element of a WDDX::Struct as a data object
     instead of having it deserialized to Perl.

$wddx_hash->set( $key => $wddx_obj );
     This allows you to set a key/value pair in a WDDX::Struct. Note that
     `$wddx_obj' should be a WDDX data object of some type.

$wddx_hash->delete( $key );
     This allows you to delete a key from a WDDX::Struct.

$wddx_hash->keys();
     This will return a list of keys for the WDDX::Struct object or the
     number of keys (if called in a scalar context).

$wddx_hash->values();
     This will return a list of values for the WDDX::Struct object or the
     number of values (if called in a scalar context). Note that each one
     of these values should be a WDDX data object of some type.

WDDX::Recordset
---------------

$wddx->recordset( [ NAME_A, NAME_B, ... ], [ TYPE_A, TYPE_B, ... ], [ DATA ] )
     This creates a WDDX::Recordset object. Recordsets hold tabular data.
     There is no corresponding data type in Perl, but it corresponds with
     the type of output you would receive from a SQL query.

     The first argument when constructing a recordset should be a reference
     to an array containing the names of each of the fields. The second
     argument an reference to an array containing the types of each of the
     fields. Field types must be simple, so the valid types are "string",
     "number", "boolean", or "datetime". The last argument is an optional
     reference to an array of arrays - in other words a table of data.
     Note that this table of data contains plain old Perl scalars; you
     should not create WDDX objects for each value as you would for an
     array or a hash.

          $wddx_rec = $wddx->recordset( [ NAME_A, NAME_B, ... ],
                                        [ TYPE_A, TYPE_B, ... ],
                                        [ [ $val_a1, $val_b1, ... ],
                                          [ $val_b1, $val_b2, ... ],
                                          ...
                                        ] )

     This is simple to use with DBI:

     $data = $dbh->selectall_arrayref( "SELECT NAME, AGE FROM TABLE" ) or
       die $dbh->errstr;   $wddx_rec = $wddx->recordset( [ "NAME", "AGE"
     ],                                 [ "string", "number" ],
                         $data );

     Recordsets that are within arrays or hashes are not automatically
     deserialized for you when you deserialize the array or hash. They
     remain as recordset objects. You can use the methods below to access
     the data.

     Note: It is possible to receive a packet for a recordset that does not
     contain any records. In WDDX, the data type for each field is
     determined by looking at how the data in the field has been tagged;
     so if there is no data, then there is no data type information. Thus
     if you deserialize an empty recordset packet, add data to the
     resulting recordset object, and attempt to serialize it back into a
     packet, you will get an error because WDDX.pm will not know what data
     type to assign to the data you added. To avoid this, you should call
     the types() method to set the data types before you serialize a
     recordset object that was created by deserializing a packet. (If this
     explanation makes no sense, reread it a few times; if it still
     doesn't make sense, email me and let me know. :)

$wddx_rec->names
     Returns a reference to an array of the field names. You can also pass
     a reference to an array to set the names.

$wddx_rec->types
     Returns a reference to an array of the field data types. You can also
     pass a reference to an array to set the data types.

$wddx_rec->table
     Returns a reference to an array of rows, each containing an array of
     fields.  You can also pass a reference to an array to set all the
     data at once.

$wddx_rec->num_rows
     Returns the number of rows.

$wddx_rec->num_columns
     Returns the number of columns (or fields in a row).

$wddx_rec->get_row( $row_num )
     Takes an row index (0 base) and returns a reference to an array for
     that row.

$wddx_rec->add_row( [ ARRAY ] )
     Takes a reference to an array and adds this row to the bottom of the
     rows.

$wddx_rec->del_row( $row_num )
     Takes a row index and deletes that row.

$wddx_rec->set_row( $row_num, [ ARRAY ] )
     Takes a row index and a reference to an array. It replaces that row
     with this new array.

$wddx_rec->get_column( $col_name )
     Takes a column name or index (0 base) and returns a reference to an
     array for that column.

$wddx_rec->add_column( 'NAME', 'TYPE', [ ARRAY ] )
     Takes a column name, type, and a reference to an array and adds the
     column to the end of the columns.

$wddx_rec->set_column( 'NAME', [ ARRAY ] )
     Takes a column name or index (0 base) and a reference to an array.
     Replaces the column with the values from this array.

$wddx_rec->del_column( $name )
     Takes a column name or index (0 base) and deletes the column.

$wddx_rec->get_element( $col_name, $row_num )
     Takes a column name or index (0 base) and row number and returns the
     value of the intersecting cell.

$wddx_rec->set_element( $col_name, $row_num, 'New value' )
     Takes a row number, a column number, and a value and sets the value of
     the intersecting cell.

$wddx_rec->get_field( $row_num, $col_num )
     DEPRECATED! Takes a row number and column number and returns the value
     of the intersecting cell.

     This method is deprecated. Because WDDX often refers to columns in a
     recordset as fields, this method name may be confusing. It has been
     replaced by get_element() and will be removed in a future version.

$wddx_rec->set_field( $row_num, $col_num, 'New value' )
     DEPRECATED! Takes a row number, a column number, and a value and sets
     the value of the intersecting cell.

     This method is deprecated. Because WDDX often refers to columns in a
     recordset as fields, this method name may be confusing. It has been
     replaced by set_element() and will be removed in a future version.

Utility Methods
===============

   These methods make it easier to go from Perl to WDDX data objects and
vice versa.

$wddx->wddx2perl( $wddx_obj );
     This takes a WDDX data object and returns a scalar if it is a simple
     data type, an array reference if it is an array, a hash reference if
     it is a struct, and a WDDX::Recordset object if it is a recordset.

$wddx->scalar2wddx( $scalar, [ $type ] );
     This method takes a scalar and a data type and returns the scalar as a
     WDDX data object of the given type. Type should be one of the simple
     WDDX data types (i.e. string, number, boolean, datetime, null, or
     binary), and if it is not supplied, then string is assumed.

     This method is convenient if you have the type stored in a variable,
     since it avoids you having to do a bunch of if/else statements to
     call the corresponding data object constructor.

$wddx->array2wddx( $arrayref, [ $coderef ] );

$wddx->hash2wddx( $hashref, [ $coderef ] );
     These methods attempt to provide a way for you to generate complex
     WDDX data types from complicated Perl structures. In their simplest
     form, they will generate a corresponding WDDX data object by
     serializing all scalars as strings. This may be sufficient for your
     needs, but it likely will not. Thus, these methods also allow you to
     determine the type for each scalar. To do so, you must provide a
     reference to a sub.

     Your sub will be called for each value within the array or a hash you
     supply, as well as each value within any nested arrays or hashes.
     Thus your sub may need to support both hashes and arrays.

     If your sub is called within an array, it will receive the following
     arguments:

          1. the index of the current element
          2. the value of the current element
          3. the text "ARRAY"
          
          If your sub is called within a hash, it will receive the following
          arguments:

          1. the key of the current pair
          2. the value of the current pair
          3. the text "HASH"

     You must return the type of the data object to construct (e.g.
     "number") or a false value if you want to let the element continue to
     the next rule. The rules for converting elements into WDDX data
     objects are as follows:

     1. If the element is already a WDDX data object, then it is left
     alone.

     2. Your subroutine is called (if provided). If a true value is not
     returned, then we skip to rule 3. If you return an invalid data type,
     then this method dies with an error. If you return a valid data type
     then:

     a. If the current element is a scalar then this element is converted
     to a WDDX data object of the type you specified.

     b. If the current element is a reference to a hash or an array, then
     this hash or array is converted to a WDDX data object with each
     element having the type you specified (this applies to all nested
     arrays and hashes too).

   3. If the current element is a reference to a hash or an array then
`wddx2array' or `wddx2hash' is called on it and your sub (if provided)
propagates.

   4. Any scalars that have not been handled by a previous rule are
treated as strings.

   Here is an example. Assume that you have the following data structure
in Perl:

     $weather_data = {
        title       => "Weather Conditions",
        region      => "San Francisco Bay Area",
        current     => {
          temp      => 72,
          sky       => "mostly clear",
          precip    => undef,
          wind      => 12
        },
        tomorrow    => {
          temps     => [ 62 => 75 ],
          sky       => "partly cloudy",
          precip    => undef,
          winds     => [ 5  => 10 ]
        }
     };

   To convert this to a WDDX object you could create a handler and use it
to create a WDDX object like this:

   $type_sub = sub {     my( $name, $val, $mode ) = @_;     ! defined(
$val )   and return "null";     $name =~ /temp/     and return "number";
 $name =~ /wind/     and return "number";  };

   my $wddx_weather = $wddx->hash2wddx( $weather_data, $type_sub );

   Then you can easily serialize the WDDX object to a packet:

   $WDDX::INDENT = "   ";  print $wddx->serialize( $wddx_weather );

   This prints:

     <wddxPacket version='1.0'>
        <header/>
        <data>
           <struct>
              <var name='tomorrow'>
                 <struct>
                    <var name='temps'>
                       <array length='2'>
                          <number>0</number>
                          <number>1</number>
                       </array>
                    </var>
                    <var name='precip'>
                       <null/>
                    </var>
                    <var name='winds'>
                       <array length='2'>
                          <number>0</number>
                          <number>1</number>
                       </array>
                    </var>
                    <var name='sky'>
                       <string>partly cloudy</string>
                    </var>
                 </struct>
              </var>
              <var name='title'>
                 <string>Weather Conditions</string>
              </var>
              <var name='current'>
                 <struct>
                    <var name='wind'>
                       <number>12</number>
                    </var>
                    <var name='precip'>
                       <null/>
                    </var>
                    <var name='temp'>
                       <number>72</number>
                    </var>
                    <var name='sky'>
                       <string>mostly clear</string>
                    </var>
                 </struct>
              </var>
              <var name='region'>
                 <string>San Francisco Bay Area</string>
              </var>
           </struct>
        </data>
     </wddxPacket>

   Of course, the handler you construct will vary depending on each
particular data structure.

EXAMPLES
========

   I pulled the examples out of here when I realized that this POD was
over 50 screenfuls on a standard term! For more lengthy examples, please
visit http://www.scripted.com/wddx/ or http://www.wddx.org/.

BUGS
====

   WDDX does not support 16 bit character sets (at least not without
encoding them as binary objects).

   Every element of data must be encoded as an object. This increases
memory usage somewhat, and it also means any data you transfer must fit in
memory.

   This is actually a non-bug: XML::Parser untaints data as it parses it.
This is dangerous. WDDX.pm retaints the data it receives from XML::Parser
so you should be safe if you are running in taint mode. Note: WDDX.pm uses
$0 to retaint data, so if you untaint $0 then any subsequent WDDX.pm data
will be untainted too. Taint is explained *Note Perlsec:
(perl.info)perlsec,.

CREDITS
=======

   Nate Weiss, the man behind the WDDX SDK, has been an especially huge
help.

   David Medinets started an earlier version of a Perl and WDDX module
available at http://www.codebits.com/wddx/.

   The following people have helped provide feedback, bug reports, etc.
for this module:

     Thomas R. Hall
     David J. MacKenzie
     Jon Sala
     Wolfgang ???
     James Ritter
     Miguel Marques
     Vadim Geshel
     Adolfo Garcia
     Sean McGeever
     Allie Rogers
     Ziying Sherwin

AUTHOR
======

   Scott Guelich <scott@scripted.com>


