This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Safe/Hole,  Next: Scalar/Listify,  Prev: Safe,  Up: Module List

make a hole to the original main compartment in the Safe compartment
********************************************************************

NAME
====

   Safe::Hole - make a hole to the original main compartment in the Safe
compartment

SYNOPSIS
========

     use Safe;
     use Safe::Hole;
     $cpt = new Safe;
     $hole = new Safe::Hole;
     sub test { Test->test; }
     $Testobj = new Test;
     # $cpt->share('&test');  # alternate as next line
     $hole->wrap(\&test, $cpt, '&test');
     # ${$cpt->varglob('Testobj')} = $Testobj;  # alternate as next line
     $hole->wrap($Testobj, $cpt, '$Testobj');
     $cpt->reval('test; $Testobj->test;');
     print $@ if $@;
     package Test;
     sub new { bless {},shift(); }
     sub test { my $self = shift; $self->test2; }
     sub test2 { print "Test->test2 called\n"; }

DESCRIPTION
===========

     We can call outside defined subroutines from the Safe compartment
     using share(), or can call methods through the object that is copied into
     the Safe compartment using varglob(). But that subroutines or methods
     are executed in the Safe compartment too, so they cannot call another
     subroutines that are dinamically qualified with the package name such as
     class methods.
     Through Safe::Hole, we can execute outside defined subroutines in the
     original main compartment from the Safe compartment.

Methods
-------

new [NAMESPACE]
     Class method. Constructor.    NAMESPACE is the alternate root
     namespace that makes the compartment in which call() method execute
     the subroutine.  Default of NAMESPACE means 'main'. We use the
     default usually.

call $coderef [,@args]
     Object method.    Call the subroutine refered by $coderef in the
     compartment that is specified with constructor new. @args are passed
     to called $coderef.

wrap $ref [,$cpt ,$name]
     Object method.    If $ref is a code reference, this method returns
     the anonymous subroutine reference that calls $ref using call()
     method of Safe::Hole (see above).    If $ref is a class object, this
     method makes a wrapper class of that object and returns a new object
     of the wrapper class. Through the wrapper class, all original class
     methods called using call() method of Safe::Hole.    If $cpt as Safe
     object and $name as subroutine or scalar name specified, this method
     works like share() method of Safe. When $ref is a code reference
     $name must like '&subroutine'. When $ref is a object $name must like
     '$var'.    Name $name may not be same as referent of $ref. For
     example:   $hole->wrap(\&foo, $cpt, '&bar');   $hole->wrap(sub{...},
     $cpt, '&foo');   $hole->wrap($objfoo, $cpt, '$objbar');

root
     Object method.    Return the namespace that is specified with
     constructor new.

Warning
-------

   You MUST NOT share the Safe::Hole object with the Safe compartment. If
you do it the Safe compartment is NOT safe.

AUTHOR
======

   Sey Nakajima <sey@jkc.co.jp>

SEE ALSO
========

   Safe(3).


File: pm.info,  Node: Scalar/Listify,  Next: Scalar/Util,  Prev: Safe/Hole,  Up: Module List

produces an array from a scalar value or array ref.
***************************************************

NAME
====

   Scalar::Listify - produces an array from a scalar value or array ref.

SYNOPSIS
========

     use Scalar::Listify;

     $text_scalar = 'text';
     $aref_scalar = [ 1.. 5 ];

     print join ':', listify $text_scalar; # => text
     print join ':', listify $aref_scalar; # => 1:2:3:4:5

DESCRIPTION
===========

   A lot of Perl code ends up with scalars having either a single scalar
value or a reference to an array of scalar values. In order to handle the
two conditions, one must check for what is in the scalar value before
getting on with one's task. Ie:

     $text_scalar = 'text';
     $aref_scalar = [ 1.. 5 ];

     print ref($text_scalar) ? (join ':', @$text_scalar) : $text_scalar;

   And this module is designed to address just that!

EXPORT
------

   listify() - listify takes a scalar as an argument and returns the value
of the scalar in a format useable in list contexts.

AUTHOR
======

   T. M. Brannon, <tbone@CPAN.org>

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Scalar/Util,  Next: Schedule/At,  Prev: Scalar/Listify,  Up: Module List

A selection of general-utility scalar subroutines
*************************************************

NAME
====

   Scalar::Util - A selection of general-utility scalar subroutines

SYNOPSIS
========

     use Scalar::Util qw(blessed dualvar reftype weaken isweak);

DESCRIPTION
===========

   `Scalar::Util' contains a selection of subroutines that people have
expressed would be nice to have in the perl core, but the usage would not
really be high enough to warrant the use of a keyword, and the size so
small such that being individual extensions would be wasteful.

   By default `Scalar::Util' does not export any subroutines. The
subroutines defined are

blessed EXPR
     If EXPR evaluates to a blessed reference the name of the package that
     it is blessed into is returned. Otherwise undef is returned.

dualvar NUM, STRING
     Returns a scalar that has the value NUM in a numeric context and the
     value STRING in a string context.

          $foo = dualvar 10, "Hello";
          $num = $foo + 2;			# 12
          $str = $foo . " world";		# Hello world

isweak EXPR
     If EXPR is a scalar which is a weak reference the result is true.

reftype EXPR
     If EXPR evaluates to a reference the type of the variable referenced
     is returned. Otherwise undef is returned.

weaken REF
     REF will be turned into a weak reference. This means that it will not
     hold a reference count on the object it references. Also when the
     reference count on that object reaches zero, REF will be set to undef.

     This is useful for keeping copies of references , but you don't want
     to prevent the object being DESTROY-ed at it's usual time.

COPYRIGHT
=========

   Copyright (c) 1997-2000 Graham Barr <gbarr@pobox.com>. All rights
reserved.  This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

   except weaken and isweak which are

   Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as perl itself.

BLATANT PLUG
============

   The weaken and isweak subroutines in this module and the patch to the
core Perl were written in connection  with the APress book `Tuomas J.
Lukka's Definitive Guide to Object-Oriented Programming in Perl', to avoid
explaining why certain things would have to be done in cumbersome ways.


File: pm.info,  Node: Schedule/At,  Next: Schedule/Cron,  Prev: Scalar/Util,  Up: Module List

OS independent interface to the Unix 'at' command
*************************************************

NAME
====

   Schedule::At - OS independent interface to the Unix 'at' command

SYNOPSIS
========

     require Schedule::At;

     Schedule::At::add(TIME => $string, COMMAND =>$string [, TAG =>$string]);
     Schedule::At::add(TIME => $string, FILE => $string [, TAG => $string])

     Schedule::At::remove(JOBID => $string);
     Schedule::At::remove(TAG => $string);

     %jobs = Schedule::At::getJobs();

DESCRIPTION
===========

   This modules provides an OS independent interface to 'at', the Unix
command that allows you to execute commands at a specified time.

Schedule::At::add
     Adds a new job to the at queue.

     You have to specify a TIME and a command to execute. The TIME has a
     common format: YYYYMMDDHHmm. Where *YYYY* is the year (4 digits), *MM*
     the month (01-12), *DD* is the day (01-31), *HH* the hour (00-23) and
     mm the minutes.

     The command is passed with the *COMMAND* or the FILE parameter.
     *COMMAND* can be used to pass the command as an string, and FILE to
     read the commands from a file.

     The optional parameter TAG serves as an application specific way to
     identify a job or a set of jobs.

     Returns 0 on success or a value != 0 if an error occurred.

Schedule::At::remove
     Remove an at job.

     You identify the job to be deleted using the *JOBID* parameter (an
     opaque string returned by the getJobs subroutine). You can also
     specify a job or a set of jobs to delete with the TAG parameter,
     removing all the jobs that have the same tag (as specified with the
     add subroutine).

     Returns 0 on success or a value != 0 if an error occurred.

Schedule::At::getJobs
     Returns a hash with all the current jobs or undef if an error
     occurred.  For each job the key is a JOBID (an OS dependent string
     that shouldn't be interpreted), and the value is a hash reference.

     This hash reference points to a hash with the keys:

    TIME
          An OS dependent string specifying the time to execute the command

    TAG
          The tag specified in the Schedule::At::add subroutine

EXAMPLES
========

     use Schedule::At;

     # 1
     Schedule::At::add (TIME => '199801181530', COMMAND => 'ls',
     	TAG => 'ScheduleAt');
     # 2
     Schedule::At::add (TIME => '199801181630', COMMAND => 'ls',
     	TAG => 'ScheduleAt');
     # 3
     Schedule::At::add (TIME => '199801181730', COMMAND => 'ls');

     # This will remove #1 and #2 but no #3
     Schedule::At::remove (TAG => 'ScheduleAt');

     my %atJobs = Schedule::At::getJobs();
     foreach my $job (values %atJobs) {
     	print "\t", $job->{JOBID}, "\t", $job->{TIME}, ' ',
     		($job->{TAG} || ''), "\n";
     }

AUTHOR
======

   Jose A. Rodriguez (josear@ac.upc.es)


File: pm.info,  Node: Schedule/Cron,  Next: Schedule/Load,  Prev: Schedule/At,  Up: Module List

cron-like scheduler for Perl subroutines
****************************************

NAME
====

   Cron - cron-like scheduler for Perl subroutines

SYNOPSIS
========

     use Schedule::Cron;

     # Subroutines to be called
     sub dispatcher {
       print "ID:   ",shift,"\n";
       print "Args: ","@_","\n";
     }

     sub check_links {
       # do something...
     }

     # Create new object with default dispatcher
     my $cron = new Schedule::Cron(\&dispatcher);

     # Load a crontab file
     $cron->load_crontab("/var/spool/cron/perl");

     # Add dynamically  crontab entries
     $cron->add_entry("3 4  * * *",ROTATE => "apache","sendmail");
     $cron->add_entry("0 11 * * Mon-Fri",\&check_links);

     # Run scheduler
     $cron->run(detach=>1);

DESCRIPTION
===========

   This  module provides  a simple  but complete  cron like scheduler.
I.e   this  modules   can   be  used   for periodically executing Perl
subroutines.  The dates and parameters  for   the  subroutines  to   be
called  are specified   with  a  format   known  as   crontab  entry
(`"METHODS"' in this node, `add_entry()' and `crontab(5)' in this node)

   The  philosophy  behind  `Schedule::Cron'  is  to  call subroutines
periodically from  within  one single  Perl program  instead  of  letting
`cron'  trigger  several (possibly different) perl  scripts. Everything
under one roof.  Furthermore  `Schedule::Cron' provides mechanism to
create crontab  entries dynamically, which isn't that easy with `cron'.

   `Schedule::Cron' knows  about all extensions  (well, at least all
extensions  I'm aware of, i.e those  of the so called  "Vixie" cron)  for
crontab  entries  like ranges including  'steps', specification of  month
and  days of the week by  name or coexistence of lists  and ranges in the
same  field.  And  even a bit  more (like  lists and ranges with symbolic
names).

METHODS
=======

$cron = new Schedule::Cron($dispatcher,[extra args])
     Creates  a new  `Cron' object.   `$dispatcher' is  a reference  to a
     subroutine, which  will be called by default.   `$dispatcher' will be
     invoked with the arguments parameter  provided in the crontab entry if
     no other subroutine is specified. This can be either a single argument
     containing  the  argument  parameter  literally  has  string  (default
     behavior)  or a  list  of  arguments when  using  the eval  option
     described below.

     The date  specifications must  be either provided  via a  crontab like
     file or added explicitly with `add_entry()' (`"add_entry"' in this
     node).

     extra_args  can  be  a   hash  or  hash  reference  for  additional
     arguments.  The following parameters are recognized:

          file => <crontab>  Load the crontab entries from <crontab>

          eval =>  1         Eval  the argument  parameter in  a crontab
                             entry   before   calling   the   subroutine
                             (instead    of   literally    calling   the
                             dispatcher  with the argument  parameter as
                             string

$cron->load_crontab($file)

$cron->load_crontab(file=>$file,[eval=>1])
     Loads and parses the crontab  file $file. The entries found in this
     file   will   be   added   to   the   current   time   table   with
     `$cron->add_entry'.

     The format of  the file consists of cron  commands containing of lines
     with at least 5 columns, whereas the first 5 columns specify the date.
     The rest of the line (i.e columns 6 and greater) contains the argument
     with which the dispatcher subroutine  will be called.  By default, the
     dispatcher will  be called with one single  string argument containing
     the  rest of  the line  literally.   Alternatively, if  you call  this
     method with  the optional argument  `eval=>1' (you must  then use the
     second  format shown above), the  rest of the line  will be evaled
     before used as argument for the dispatcher.

     For the format of the first 5 columns, please see `"add_entry"' in
     this node.

     Blank lines and lines starting with a `#' will be ignored.

     There's  no  way to  specify  another  subroutine  within the  crontab
     file.  All  calls   will  be  made  to  the   dispatcher  provided  at
     construction time.

     If    you   want    to    start   up    fresh,    you   should    call
     `$cron->clean_timetable()' before.

     Example of a crontab fiqw(le:)

          # The following line runs on every Monday at 2:34 am
          34 2 * * Mon  "make_stats"
          # The next line should be best read in with an eval=>1 argument
          *  * 1 1 *    { NEW_YEAR => '1',HEADACHE => 'on' }

$cron->add_entry($timespec,[arguments])
     Adds a new entry to the list of scheduled cron jobs.

     *Time and Date specification*

     `$timespec' is the  specification of the scheduled time in  crontab
     format  (`crontab(5)' in this node) which  contains five time and
     date fields. `$timespec' can be either a plain string, which
     contains a whitespace  separated time and date specification.
     Alternatively, `$timespec' can be a reference to an array containing
     the five elements for the date fields.

     The time and date  fields are (cited from `crontab(5)' in this node,
     "Vixie" cron):

          field          values
          =====          ======
          minute         0-59
          hour           0-23
          day of month   1-31
          month          1-12 (or as names)
          day of week    0-7 (0 or 7 is Sunday, or as names )

          A field may be an asterisk (*), which always stands for
          ``first-last''.

          Ranges of numbers are  allowed.  Ranges are two numbers
          separated  with  a  hyphen.   The  specified  range  is
          inclusive.   For example, 8-11  for an  ``hours'' entry
          specifies execution at hours 8, 9, 10 and 11.

          Lists  are allowed.   A list  is a  set of  numbers (or
          ranges)  separated by  commas.   Examples: ``1,2,5,9'',
          ``0-4,8-12''.

          Step  values can  be used  in conjunction  with ranges.
          Following a range with ``/<number>'' specifies skips of
          the  numbers value  through the  range.   For example,
          ``0-23/2'' can  be used in  the hours field  to specify
          command execution every  other hour (the alternative in
          the V7 standard is ``0,2,4,6,8,10,12,14,16,18,20,22'').
          Steps are  also permitted after an asterisk,  so if you
          want to say ``every two hours'', just use ``*/2''.

          Names can also  be used for the ``month''  and ``day of
          week''  fields.  Use  the  first three  letters of  the
          particular day or month (case doesn't matter).

          Note: The day of a command's execution can be specified
                by two fields  -- day of month, and  day of week.
                If both fields are restricted (ie, aren't *), the
                command will be run when either field matches the
                current  time.  For  example, ``30  4 1,15  * 5''
                would cause a command to be run at 4:30 am on the
                1st and 15th of each month, plus every Friday

     In addition, ranges or lists of names are allowed.

     Examples:

          "8  0 * * *"       ==> 8 minutes after midnight, every day
          "5 11 * * Sat,Sun" ==> at 11:05 on each Saturday and Sunday
          "0-59/5 * * * *"   ==> every five minutes
          "42 12 3 Feb Sat"  ==> at 12:42 on 3rd of February and on
                                 each Saturday in February

     *Command specification*

     The subroutine to be  executed when the the `$timespec' matches can
     be specified in several ways.

     First,  if the  optional `arguments'  are  lacking, the default
     dispatching  subroutine provided at construction time will be called
     without arguments.

     If the second parameter to this method is a reference to a
     subroutine,  this subroutine  will be used  instead of the dispatcher.

     Any additional parameters will  be given as arguments to the
     subroutine  to be executed.  You can also  specify a reference to an
     array instead of a list of parameters.

     You can also  use a named parameter list  provided as an hashref.
     The named parameters recognized are:

          subroutine      reference to subroutine to be executed
          sub

          arguments       reference to array containing arguments
          args            to be use when calling the subroutine

          eval            if  set, provide the  subroutine with
                          the  evaled string provided  with the
                          'arguments'      parameter.       The
                          evaluation     will     take    place
                          immediately (not  when the subroutine
                          is to be called)

     Examples:

          $cron->add_entry("* * * * *");
          $cron->add_entry("* * * * *","doit");
          $cron->add_entry("* * * * *",\&dispatch,"first",2,"third");
          $cron->add_entry("* * * * *",{'subroutine' => \&dispatch,
          				 'arguments'  => [ "first",2,"third" ]});
          $cron->add_entry("* * * * *",{'subroutine' => \&dispatch,
          				 'arguments'  => '[ "first",2,"third" ]',
          				 'eval'       => 1});

$cron->run([options])
     This method starts the scheduler.

     When  called  without options,  this  method will  never return  and
     executes the  scheduled subroutine  calls as needed.

     Alternatively,  you can detach  the main  scheduler loop from the
     current process  (daemon mode). In  this case, the  pid  of  the
     forked  scheduler  process  will  be returned.

     The options  parameter specifies the  running mode of
     `Schedule::Cron'.  It can be  either a plain list which will be
     interpreted  as a hash or it  can be a reference to  hash. The
     following named  parameters (keys  of the provided hash) are
     recognized:

          detach    if set to one, detach the scheduler process
                    from the current process

          pid_file  if  running   in  daemon  mode,   name  the
                    optional file,  in which the  process id of
                    the scheduler process should be written. By
                    default, no PID File will be created.

     Examples:

          # Start  scheduler, detach  from current  process and
          # write  the  PID  of  the forked  scheduler  to  the
          # specified file
          $cron->run(detach=>1,pid_file=>"/var/run/scheduler.pid");

          # Start scheduler and wait forever.
          $cron->run();

$cron->clean_timetable()
     Remove all scheduled entries

$cron->check_entry($id)
     Check, whether the given ID is already registered in the timetable.
     A ID is the first argument in the argument parameter of the a crontab
     entry.

     Returns (one of) the index in the  timetable (can be 0, too) if the ID
     could be found or undef otherwise.

     Example:

          $cron->add_entry("* * * * *","ROTATE");
          .
          .
          defined($cron->check_entry("ROTATE")) || die "No ROTATE entry !"

$cron->get_next_execution_time($cron_entry,[$ref_time])
     Well, this is mostly an internal method, but it might be useful on
     its own.

     The purpose of this method is to calculate the next execution time
     from a specified crontab entry

     Parameters:

          $cron_entry  The crontab entry as specified in L<"add_entry">
          $ref_time    the reference time for which the next time should be
                       searched which matches $cron_entry. By default, take
                       the current time

     This method returns the number of epoch-seconds of the next matched
     date for `$cron_entry'.

     Since I suspect, that this calculation of the next execution time
     might fail in some circumstances (bugs are lurking everywhere ;-) an
     additional interactive method `bug()' is provided for checking
     crontab entries against your expected output. Refer to the top-level
     README for additional usage information for this method.

TODO
====

   * Provide a `reload()' method for reexaming the crontab file

   * Clean up `get_next_execution_time()' and give it at least some
     rational grounding ;-)

   * Provide support for systems without fork() via `OS::Process'

   * Add logging

COPYRIGHT
=========

   Copyright 1999,2000 Roland Huss.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

     ...roland


File: pm.info,  Node: Schedule/Load,  Next: Schedule/Load/Chooser,  Prev: Schedule/Cron,  Up: Module List

Load distribution and status across multiple host machines
**********************************************************

NAME
====

   Schedule::Load - Load distribution and status across multiple host
machines

SYNOPSIS
========

     # Get per-host or per top process information
     use Schedule::Load::Hosts;
     foreach my $host ($hosts->hosts) {
         printf $host->hostname " is on our network\n";
     }

     # Choose hosts
     use Schedule::Load::Schedule;
     my $scheduler = Schedule::Load::Schedule->fetch();
     print "Best host for a new job: ", $scheduler->best();

     # user access
     rtop
     rschedule reserve <hostname>

DESCRIPTION
===========

   This package provides useful utilities for load distribution and status
across multiple machines in a network.  To just see what is up in the
network, see the rschedule or `rtop', `rloads' or `rhosts' commands.

   The system is composed of four unix programs (each also with a
underlying Perl module):

slreportd
     slreportd is run on every host in the network, usually started with a
     init.d script.  It reports itself to the slchoosed daemon
     periodically, and is responsible for checking loading and top
     processes specific to the host that it runs on.

     slreportd may also be invoked with some variables set.  This allows
     static host information, such as class settings to be passed to
     applications.

slchoosed
     slchoosed is run on one host in the network.  It collects connections
     from the slreportd reporters, and maintains a internal database of the
     entire network.  User clients also connect to the chooser, which then
     gets updated information from the reporters, and returns the
     information to the user client.  As the chooser has the entire
     network state, it can also choose the best host across all CPUs in
     the network.

rschedule
     rschedule is a command line interface to this package.  It and the
     aliases `rtop', `rhosts', and `rloads' report the current state of the
     network including hosts and top loading.  rschedule also allows
     reserving hosts and setting the classes of the machines, as described
     later.

slpolice
     slpolice is a optional client daemon which is run as a `cron' job.
     When a user process has over a hour of CPU time, it nices that process
     and sends mail to the user.  It is intended as a example which can be
     used directly or changed to suit the system manager preferences.

MODULES
=======

Schedule::Load::Hosts
     Schedule::Load::Hosts provides the connectivity to the slchoosed
     daemon, and accessors to load and modify that information.

Schedule::Load::Schedule
     Schedule::Load::Schedule provides functions to choose the best host
     for a new job, reserving hosts, and for setting what hosts specific
     classes of jobs can run on.

Schedule::Load::Reporter
     Schedule::Load::Reporter implements the internals of slreportd.

Schedule::Load::Chooser
     Schedule::Load::Chooser implements the internals of slchoosed.

RESERVATIONS
============

   Occasionally clusters have members that are only to be used by specific
people, and not for general use.  A host may be reserved with `rschedule
reserve'.  This will place a special comment on the machine that
`rschedule hosts' will show.  Reservations also prevent the
Schedule::Load::Schedule package from picking that host as the best host.

   To be able to reserve a host, the reservable variable must be set on
that host.  This is generally done when slreportd is invoked on the
reservable host by using `slreportd reservable=1'.

CLASSES
=======

   Different hosts often have different properties, and jobs need to be
able select a host with certain properties, such as hardware or licensing
requirements.  Classes are generally just boolean variables which start
with class_.  Classes can be specified when slreportd is invoked on the
`slreportd class_foo=1'.  The class setting may be seen with `rschedule
classes' or may be read (as may any other variable) as a accessor from a
`Schedule::Load::Hosts::Host' object.

   Once a class is defined, a scheduling call can include it the classes
array that is passed when the best host is requested.  Only machines which
match one of those classes will be selected.

COMMAND COMMENTS
================

   `rschedule loads' or `rloads' show the command that is being run.  By
default this is the basename of the command invoked, as reported by the
operating system.  Often this is of little use, especially when the same
program is used by many people.  The `rschedule cmnd_comment' command or
`Schedule::Load::Schedule::cmnd_comment' function will assign a more
verbose command to that process id.  For example, we use dc_shell, and put
the name of the module being compiled into the comment, so rather then
several copies of the generic "dc_shell" we see "dc module", "dc module2",
etc.

HOLD KEYS
=========

   When a best host is picked for a new job, there is often a lag before a
process actually starts up on the selected host, and enough CPU time
elapses for that new process to claim CPU time.  To prevent another job
from scheduling onto that host during this lag, scheduling calls may
specify a hold key.  For a limited time, the load on the host will be
incremented.  When the job begins and a little CPU time has elapsed a
hold_release call may be made, (or the timer expires), which releases the
hold.  This will cause the load reported by `rschedule hosts' to
occasionally be higher then the number of jobs on that host.

FIXED LOADS
===========

   Some jobs have CPU usage patterns which contain long periods of low CPU
activity, such as when doing disk IO.  make is a typical example; the
parent make process uses little CPU time, but the children of the make pop
in and out of the cpu run list.

   When scheduling, it is useful to have such jobs always count as one (or
more) job, so that the idle time is not misinterpreted and another job
scheduled onto that machine.  Fixed loading allows all children of a given
parent to count as a given fixed CPU load.  Using make again, if the
parent make process is set as a fixed_load of one, the make and all
children will always count as one load, even if not consuming CPU
resources.  The `rschedule loads' or `rloads' command includes not only
top cpu users, but also all fixed loads.  If a child process is using CPU
time, that is what is displayed.  If no children are using appreciable CPU
time (~2%), the parent is the one shown in the loads list.

DISTRIBUTION
============

   The latest version is available from CPAN.

SEE ALSO
========

   User program for viewing loading, etc:

   rschedule

   Daemons:

   slreportd, slchoosed, slpolice

   Perl modules:

   Schedule::Load::Chooser, `Schedule::Load::Hosts::Host',
`Schedule::Load::Hosts::Proc', Schedule::Load::Hosts,
Schedule::Load::Reporter, Schedule::Load::Schedule

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Schedule/Load/Chooser,  Next: Schedule/Load/Hosts,  Prev: Schedule/Load,  Up: Module List

Distributed load choosing daemon
********************************

NAME
====

   Schedule::Load::Chooser - Distributed load choosing daemon

SYNOPSIS
========

     use Schedule::Load::Chooser;

     Schedule::Load::Chooser->start(port=>1234,);

DESCRIPTION
===========

   Schedule::Load::Chooser on startup creates a daemon that clients can
connect to using the Schedule::Load package.

start ([parameter=>value ...]);
     Starts the chooser daemon.  Does not return.

PARAMETERS
==========

port
     The port number of slchoosed.  Defaults to 'slchoosed' looked up via
     /etc/services, else 1752.

dead_time
SEE ALSO
========

   `Schedule::Load', slchoosed

DISTRIBUTION
============

   This package is distributed via CPAN.

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Schedule/Load/Hosts,  Next: Schedule/Load/Hosts/Host,  Prev: Schedule/Load/Chooser,  Up: Module List

Return host loading information across a network
************************************************

NAME
====

   Schedule::Load::Hosts - Return host loading information across a network

SYNOPSIS
========

     use Schedule::Load::Hosts;

     my $hosts = Schedule::Load::Hosts->fetch();
     $hosts->print_machines();
     $hosts->print_top();

     # Overall machine status
     my $hosts = Schedule::Load::Hosts->fetch();
     (my $FORMAT =    "%-12s    %4s     %4s   %6s%%       %5s    %s\n") =~ s/\s\s+/ /g;
     printf ($FORMAT, "HOST", "CPUs", "FREQ", "TotCPU", "LOAD", "ARCH/OS");
     foreach my $host ($hosts->hosts) {
     	printf STDOUT ($FORMAT,
     		       $host->hostname,
     		       $host->cpus,
     		       $host->max_clock,
     		       sprintf("%3.1f", $host->total_pctcpu),
     		       $host->adj_load,
     		       $host->archname ." ". $host->osvers,
     		       );
     }

     # Top processes
     (my $FORMAT =    "%-12s   %6s    %-8s      %-5s    %6s     %5s%%    %s\n") =~ s/\s\s+/ /g;
     printf ($FORMAT, "HOST", "PID", "USER",  "STATE", "RUNTM", "CPU","COMMAND");
     foreach my $host ($hosts->hosts) {
     	foreach $p ($host->top_processes) {
     	    printf($FORMAT,
     		   $host->hostname,
     		   $p->pid, 		$p->uname,
     		   $p->state, 		$p->time_hhmm,
     		   $p->pctcpu,		$p->fname);
     	}
     }

DESCRIPTION
===========

   This package provides information about host loading and top processes
from many machines across a entire network.

fetch ()
     Fetch the data structures from across the network.  This also creates
     a new object.  Accepts the port and host parameters.

restart ()
     Restart all daemons, loading their code from the executables again.
     Use sparingly.  chooser parameter if true (default) restarts chooser,
     reporter parameter if true (default) restarts reporter.

hosts ()
     Returns the host objects, accessable with
     `Schedule::Load::Hosts::Host'.  In an array context, returns a list;
     In a a scalar context, returns a reference to a list.

get_host ($hostname)
     Returns a reference to a host object with the specified hostname, or
     undef if not found.

classes ()
     Returns all class_ variables under all hosts.  In an array context,
     returns a list; In a a scalar context, returns a reference to a list.

print_classes
     Returns a string with the list of machines and classes that may run
     on them in a printable format.

print_hosts
     Returns a string with the list of host machines and loading in a
     printable format.

print_top
     Returns a string with the top jobs on all machines in a printable
     format, ala the top program.

print_loads
     Returns a string with the top jobs command lines, including any jobs
     with a fixed loading.

PARAMETERS
==========

dhost
     List of daemon hosts that may be running the slchoosed server.  The
     second host is only used if the first is down, and so on down the
     list.

port
     The port number of slchoosed.  Defaults to 'slchoosed' looked up via
     /etc/services, else 1752.

SEE ALSO
========

   `Schedule::Load::Hosts::Host', `Schedule::Load::Hosts::Proc'

   `Schedule::Load', rschedule

DISTRIBUTION
============

   The latest version is available from CPAN.

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Schedule/Load/Hosts/Host,  Next: Schedule/Load/Hosts/Proc,  Prev: Schedule/Load/Hosts,  Up: Module List

Return information about a host
*******************************

NAME
====

   Schedule::Load::Hosts::Host - Return information about a host

SYNOPSIS
========

     See Schedule::Load::Hosts

DESCRIPTION
===========

   This package provides accessors for information about a specific host
obtained via the Schedule::Load::Host package.

fields
     Returns all information fields for this host.

exists (key)
     Returns if a specific field exists for this host.

get (key)
     Returns the value of a specific field for this host.

ACCESSORS
=========

   A accessor exists for each field returned by the fields() call.
Typical elements are described below.

top_processes
     Returns a reference to a list of top process objects,
     `Schedule::Load::Hosts::Proc' to access the information for each
     process.  In an array context, returns a list; In a a scalar context,
     returns a reference to a list.

archname
     Architecture name from Perl build.

cpus
     Number of CPUs.

hostname
     Name of the host.

max_clock
     Maximum clock frequency.

load_limit
     Limit on the loading that a machine can bear, often set to the number
     of CPUs to not allow overloading of a machine.  Undefined if no limit.

osname
     Operating system name from Perl build.

reservable
     If true, this host may be reserved for exclusive use by a user.

reserved
     If true, this host is reserved, and this field contains a username and
     start time comment.

systype
     System type from Perl build.

total_load
     Total number of processes in run or on processor state.

adj_load
     Total number of processes in run or on processor state, adjusted for
     any jobs that have a specific fixed_load or hold time.  This is the
     load used for picking hosts.

total_pctcpu
     Total CPU percentage used by all processes.

SEE ALSO
========

   `Schedule::Load', Schedule::Load::Hosts, `Schedule::Load::Hosts::Proc'

DISTRIBUTION
============

   The latest version is available from CPAN.

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Schedule/Load/Hosts/Proc,  Next: Schedule/Load/Reporter,  Prev: Schedule/Load/Hosts/Host,  Up: Module List

Return process information
**************************

NAME
====

   Schedule::Load::Hosts::Proc - Return process information

SYNOPSIS
========

     See Schedule::Load::Hosts

DESCRIPTION
===========

   This package provides accessors for information about a specific
process obtained via the Schedule::Load::Hosts package.

fields
     Returns all information fields for this process.

exists (key)
     Returns true if a specific field exists for this process.

get (key)
     Returns the value of a specific field for this process.

ACCESSORS
=========

   A accessor exists for each field returned by the fields() call.  Typical
elements are described below.  All fields that `Proc::ProcessTable'
supports are also included here.

nice0
     Nice value with 0 being normal and 19 maximum nice.

time_hhmm
     Returns the runtime of the process in mmm:ss or hh.hH format,
     whichever is appropriate.

username
     Texual user name running this process.

SEE ALSO
========

   `Schedule::Load', Schedule::Load::Hosts, `Schedule::Load::Hosts::Host'

DISTRIBUTION
============

   The latest version is available from CPAN.

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Schedule/Load/Reporter,  Next: Schedule/Load/Schedule,  Prev: Schedule/Load/Hosts/Proc,  Up: Module List

Distributed load reporting daemon
*********************************

NAME
====

   Schedule::Load::Reporter - Distributed load reporting daemon

SYNOPSIS
========

     use Schedule::Load::Reporter;

     Schedule::Load::Reporter->start(dhost=>('host1', 'host2'),
     				  port=>1234,);

DESCRIPTION
===========

   Schedule::Load::Reporter on startup connects to the requested server
host and port.  The server connected to can then poll this host for
information about system configuration and current loading conditions.

start ([parameter=>value ...]);
     Starts the reporter.  Does not return.

PARAMETERS
==========

dhost
     List of daemon hosts that may be running the slchoosed server.  The
     second host is only used if the first is down, and so on down the
     list.

port
     The port number of slchoosed.  Defaults to 'slchoosed' looked up via
     /etc/services, else 1752.

min_pctcpu
     The minimum percentage of the CPU that a job must have to be included
     in the list of top processes sent to the client.  Defaults to 3.
     Setting to 0 will consume a lot of bandwidth.

stored_filename
     The filename to store persistant items in, such as if this host is
     reserved.  Must be either local-per-machine, or have the hostname in
     it.  Defaults to /usr/local/lib/rschedule/slreportd_{hostname}_store.
     Set to undef to disable persistance (thus if the machine reboots the
     reservation is lost.)

SEE ALSO
========

   `Schedule::Load', slreportd

DISTRIBUTION
============

   This package is distributed via CPAN.

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Schedule/Load/Schedule,  Next: Schedule/Match,  Prev: Schedule/Load/Reporter,  Up: Module List

Functions for choosing a host among many
****************************************

NAME
====

   Schedule::Load::Schedule - Functions for choosing a host among many

SYNOPSIS
========

     use Schedule::Load::Schedule;

     my $scheduler = Schedule::Load::Schedule->fetch();
     print "Best host for a new job: ", $scheduler->best();

DESCRIPTION
===========

   This package will allow the most lightly loaded host to be choosen for
new jobs across many machines across a entire network.

   It is also a superclass of Schedule::Load::Hosts, so any functions that
work for that module also work here.

best (...)
     Returns the hostname of the best host in the network for a new job.

    allow_none
          If allow_none is true, if there is less then a free CPU across
          the entire network, then no cpu will be choosen.  This is useful
          for programs that can dynamically adjust their outstanding job
          count.  (Presumably you would only set allow_none if you already
          have one job running, or you can get livelocked out of getting
          anything!)

    classes
          An array reference of which classes the host must support to
          allow this job to be run on that host.  Defaults to [], which
          allows any host.

    favor_host
          The hostname to try and choose if all is equal, under the
          presumption that there are disk access time benefits to doing
          so.  Defaults to the current host.

    hold_key
          A hold key will reserve a job slot on the choosen CPU until a
          release_hold function is called.  This prevents overscheduling a
          host due to the delay between choosing a host with a light load
          and starting the job on it which rases the CPU load of that
          choosen host.

    hold_time
          Number of seconds to allow the hold to remain before being
          removed automatically.

fixed_load (load=>load_value, [pid=>$$], [host=>localhost])
     Sets the current process and all children as always having at least
     the load value specified.  This prevents undercounting CPU
     utilization when a large batch job is running which is just paused in
     the short term to do disk IO or sleep.

hold_release (hold_key=>key)
     Releases the temporary hold placed with the best function.

hosts_of_class (class=>name)
     Returns `Schedule::Load::Hosts::Host' objects for every host that
     matches the given class.

jobs (...)
     Returns the maximum number of jobs suggested for the given scheduling
     parameters.  Presumably this will be used to spawn parallel jobs for
     one given user, such as the `make -j' command.  Jobs() takes the same
     arguments as best(), in addition to:

    max_jobs
          Maximum number of jobs that jobs() can return.  Defaults to 6
          jobs during the day, unlimited at night.

release (host=>hostname)
     Releases the machine from exclusive use of any user.  The user doing
     the release does not have to be the same user that reserved the host.

reserve (host=>hostname, [comment=>comment])
     Reserves the machine for exclusive use of the current user.  The host
     choosen must have the reservable flag set.  `rschedule hosts' will
     show the host as reserved, along with the provided comment.

PARAMETERS
==========

   Parameters for the new and fetch calls are shown in
Schedule::Load::Hosts.

night_hours_cb
     Reference to Function for determining if this is night time, defaults
     to M-F 6am-10pm.  When it is nighttime hours, every class passed to
     the best option has a new class with _night appended.

SEE ALSO
========

   `Schedule::Load', Schedule::Load::Hosts, rschedule

DISTRIBUTION
============

   The latest version is available from CPAN.

AUTHORS
=======

   Wilson Snyder <wsnyder@wsnyder.org>


File: pm.info,  Node: Schedule/Match,  Next: Script,  Prev: Schedule/Load/Schedule,  Up: Module List

Handles and detects clash between pattern-based schedules
*********************************************************

NAME
====

     Schedule::Match - Handles and detects clash between pattern-based schedules

SYNOPSIS
========

     use Schedule::Match qw(scheck rcheck isleap uthash expand localtime);

     # hash structure of handled schedule
     $this = {
       life => 3600, # how long each execution of schedule lasts (in second)
       t_mh => '*',  # minute of the hour      - in crontab(5) format
       t_hd => '*',  # hour of the day         - in crontab(5) format
       t_dw => '*',  # day of the week         - in crontab(5) format
       t_dm => '*',  # date of the month       - in crontab(5) format
       t_wm => '*',  # week of the month       - in crontab(5) format
       t_my => '*',  # month of the year       - in crontab(5) format
       t_yt => '*',  # year (of the time)      - in crontab(5) format
       t_om => '*',  # occurrence in the month - in crontab(5) format
     };

     # create hash structure from given time
     $that = uthash($time, $life);

     @when = scheck($this, $that, ...); # list clash (duration not considered)
     @when = rcheck($this, $that, ...); # list clash (duration     considered)

     $bool = isleap($year);         # check for leap year
     @list = expand($expr, \@fill); # expand each crontab(5) expression

     @time = localtime($time);      # feature enhanced localtime(3)

DESCRIPTION
===========

   This library allows you to manage schedule which has structure similar
to crontab(5) format. It offers methods to detect clash between schedules
(with or without duration considered), and can also tell when, and how
often they clash.

   From the viewpoint of data structure, one major difference compared to
crontab(5) is a concept of duration. Each schedule has its own duration,
and clash detection can be done upon that.  For more information on data
structure, please consult SCHEDULE STRUCTURE section below.

   All schedules are assumed to be in the same timezone. You will have to
align them beforehand if not.

   Currently available methods are as follows:

@when = lcheck($this, $deep, $keep, $init, $last);
     Returns list of UNIX times which is a time given schedule gets
     invoked.

@when = scheck($this, $that, $deep, $keep, $init, $last);
     Detects clash between given schedules _without_ considering duration.
     Returns the list of clash time (empty if not).  It is safe to assume
     the list is sorted.

     Options are:

    - $deep
          Sets the "depth" of clash detection. If set to false, it will
          report only one clash (first one) per day.

    - $keep
          Sets the maximum number of clashes to detect. Defaults to 1.

    - $init
          Set the starting time of timespan to do the detection.  Defaults
          to the moment this method is called.

    - $done
          Set the closing time of timespan to do the detection.  Defaults
          to 3 years after $init.

$list = rcheck($exp0, $exp1, $deep, $keep, $init, $done);
     Detects clash between given schedules _with_ duration considered.

     This is almost compatible with *scheck* except that $deep and $keep
     option does not work as expected (for current implementation). For
     $deep, it is always set to 1, and for $keep, you would need to
     specify much larger value (I cannot give the exact number since it
     depends on how often two schedules clash).

$bool = isleap($year);
     Returns wheather given year is leap year or not. Returns true if it
     is, false otherwise.

$hash = uthash($time[, $life]);
     Create schedule structure from given UNIX time. Optionally, you can
     also set the duration of created schedule (which defaults to 0).

@time = localtime($time);
     Converts a time as returned by the time function to a 11-element
     array with the time analyzed for the local time zone.

     Except for appended 10th and 11th element, this is compatible with
     built-in localtime.

     Appended 2 elements (10th and 11th) are "week of the month" and
     "occurence in the month", both in 1-indexed style.

@list = expand($expr, \@fill);
     Function to expand given crontab(5)-like expression to the list of
     matching values. \@fill is used to expand wildcard.

SCHEDULE STRUCTURE
==================

   Below is a structure of schedule used in this library:

     life => duration of the schedule (in second)
     t_mh => minute of the hour
     t_hd => hour of the day
     t_dm => day of the month
     t_my => month of the year
     t_yt => year (of the time)
     t_dw => day of the week
     t_wm => week of the month
     t_om => occurrence in the month

   As you can see, this is a simple hashtable. And for all t_* entries,
crontab(5)-like notation is supported. For this notation, please consult
crontab(5) manpage.

   Next goes some examples. To make description short, I stripped the text
"Schedule lasting for an hour, starting from midnight" off from each
description. Please assume that when reading.

  1. on every Jan. 1.
          $schedule = {
              life => 3600,
              t_mh => '0',
              t_hd => '0',
              t_dm => '1',
              t_my => '0',
              t_yt => '*',
              t_dw => '*',
              t_wm => '*',
              t_om => '*',
          }

  2. on every 3rd Sunday.
          $schedule = {
              life => 3600,
              t_mh => '0',
              t_hd => '0',
              t_dm => '*',
              t_my => '*',
              t_yt => '*',
              t_dw => '0',
              t_wm => '*',
              t_om => '3',
          }

  3. on Monday of every 3rd week.
          $schedule = {
              life => 3600,
              t_mh => '0',
              t_hd => '0',
              t_dm => '*',
              t_my => '*',
              t_yt => '*',
              t_dw => '1',
              t_wm => '3',
              t_om => '*',
          }

  4. on every other day.
          $schedule = {
              life => 3600,
              t_mh => '0',
              t_hd => '0',
              t_dm => '*/1',
              t_my => '*',
              t_yt => '*',
              t_dw => '*',
              t_wm => '*',
              t_om => '*',
          }

  5. on every other 2 days, from January to May.
          $schedule = {
              life => 3600,
              t_mh => '0',
              t_hd => '0',
              t_dm => '*/2',
              t_my => '0-4',
              t_yt => '*',
              t_dw => '*',
              t_wm => '*',
              t_om => '*',
          }

  6. on the day which is Sunday _and_ the 1st day of the month.
          $schedule = {
              life => 3600,
              t_mh => '0',
              t_hd => '0',
              t_dm => '1',
              t_my => '*',
              t_yt => '*',
              t_dw => '0',
              t_wm => '*',
              t_om => '*',
          }

  7. on Jan. 1, 1999
          $schedule = {
              life => 3600,
              t_mh => '0',
              t_hd => '0',
              t_dm => '1',
              t_my => '0',
              t_yt => '1999',
              t_dw => '*',
              t_wm => '*',
              t_om => '*',
          }

     Got the idea? You need to be careful on how you specify pattern,
     since it is possible to create pattern which never happens (Say,
     every Monday of 1st week which is 3rd Monday of the month).

     Other key-value pair can be in the hash, but there is no gurantee for
     those entries. It might clash with future enhancements to the
     strcuture, or it might even be dropped when the internal copy of the
     structure is made.


BUGS
====

   Two potential bugs are currently known:

UNIX-Y2K++ bug
     Due to a feature of localtime(3), this cannot cannot handle year
     beyond 2038. Since clash-detection code checks for the date in the
     future, this library is likely to break before that (around 2030?).

Clash detection bug
     When schedule(s) in question repeat in very short time (like every
     minute), method rcheck might not be able to check through timespan
     that is long enough.

     This can be avoided if you specify HUGE value for $keep, but then
     things will be so slow, I believe it is not practical.

COPYRIGHT
=========

   Copyright 1999, Taisuke Yamada <tai@imasy.or.jp>.  All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


