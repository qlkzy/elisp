This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Tk/form,  Next: Tk/getOpenFile,  Prev: Tk/focus,  Up: Module List

Geometry manager based on attachment rules
******************************************

NAME
====

   Tk::form - Geometry manager based on attachment rules

       $widget->form?(args)?

       $widget->formOption?(args)?

DESCRIPTION
===========

   The form method is used to communicate with the form Geometry Manager,
a geometry manager that arranges the geometry of the children in a parent
window according to attachment rules. The form geometry manager is very
flexible and powerful; it can be used to emulate all the existing features
of the Tk packer and placer geometry managers (see `pack|Tk::pack' in this
node, `place|Tk::place' in this node).  The form method can have any of
several forms, depending on Option:

*$slave*->form?(options)?
     Sets or adjusts the attachment values of the slave window according
     to the *-option*=>value argument pairs.

    -b => attachment
          Abbreviation for the *-bottom* option.

    *-bottom* => attachment
          Specifies an attachment for the bottom edge of the slave window.
          The attachment must specified according to `"SPECIFYING
          ATTACHMENTS"' in this node below.

    *-bottomspring* => weight
          Specifies the weight of the spring at the bottom edge of the
          slave window. See `"USING SPRINGS"' in this node below.

    *-bp* => value
          Abbreviation for the *-padbottom* option.

    *-bs* => weight
          Abbreviation for the *-bottomspring* option.

    *-fill* => style
          Specifies the fillings when springs are used for this widget. The
          value must be x, y, both or none.

    *-in* => *$master*
          Places the slave window into the specified *$master* window. If
          the slave was originally in another master window, all
          attachment values with respect to the original master window are
          discarded. Even if the attachment values are the same as in the
          original master window, they need to be specified again.  The
          *-in* flag, when needed, must appear as the first flag of
          options. Otherwise an error is generated.

    -l => attachment
          Abbreviation for the *-left* option.

    *-left* => attachment
          Specifies an attachment for the left edge of the slave window.
          The attachment must specified according to `"SPECIFYING
          ATTACHMENTS"' in this node below.

    *-leftspring* => weight
          Specifies the weight of the spring at the left edge of the slave
          window. See `"USING SPRINGS"' in this node below.

    *-lp* => value
          Abbreviation for the *-padleft* option.

    *-ls* => weight
          Abbreviation for the *-leftspring* option.

    *-padbottom* => value
          Specifies the amount of external padding to leave on the bottom
          side of the slave. The value may have any of the forms
          acceptable to *Tk_GetPixels*.

    *-padleft* => value
          Specifies the amount of external padding to leave on the left
          side of the slave.

    *-padright* => value
          Specifies the amount of external padding to leave on the right
          side of the slave.

    *-padtop* => value
          Specifies the amount of external padding to leave on the top
          side of the slave.

    *-padx* => value
          Specifies the amount of external padding to leave on both the
          left and the right sides of the slave.

    *-pady* => value
          Specifies the amount of external padding to leave on both the
          top and the bottom sides of the slave.

    -r => attachment
          Abbreviation for the *-right* option.

    *-right* => attachment
          Specifies an attachment for the right edge of the slave window.
          The attachment must specified according to `"SPECIFYING
          ATTACHMENTS"' in this node below.

    *-rightspring* => weight
          Specifies the weight of the spring at the right edge of the slave
          window. See `"USING SPRINGS"' in this node below.

    *-rp*  => value
          Abbreviation for the *-padright* option.

    *-rs* => weight
          Abbreviation for the *-rightspring* option.

    -t => attachment
          Abbreviation for the *-top* option.

    *-top* => attachment
          Specifies an attachment for the top edge of the slave window. The
          attachment must specified according to `"SPECIFYING
          ATTACHMENTS"' in this node below.

    *-topspring* => weight
          Specifies the weight of the spring at the top edge of the slave
          window. See `"USING SPRINGS"' in this node below.

    *-tp* => value
          Abbreviation for the *-padtop* option.

    *-ts* => weight
          Abbreviation for the *-topspring* option.

*$master*->*formCheck*
     This method checks whether there is circular dependency in the
     attachments of the master's slaves (see `"CIRCULAR DEPENDENCY"' in
     this node below).  It returns the Boolean value TRUE if it discover
     circular dependency and FALSE otherwise.

*$slave*->*formForget*
     Removes the slave from its master and unmaps its window.  The slave
     will no longer be managed by form. All attachment values with respect
     to its master window are discarded. If another slave is attached to
     this slave, then the attachment of the other slave will be changed to
     grid attachment based on its geometry.

*$master*->*formGrid*?(*x_size, y_size*)?
     When *x_size* and *y_size* are given, this method returns the number
     of grids of the *$master* window in a pair of integers of the form
     (*x_size, y_size*). When both *x_size* and *y_size* are given, this
     method changes the number of horizontal and vertical grids on the
     master window.

*$slave*->*formInfo*?(*-option)*?
     Queries the attachment options of a slave window. *-option* can be
     any of the options accepted by the form method. If *-option* is
     given, only the value of that option is returned.  Otherwise, this
     method returns a list whose elements are the current configuration
     state of the slave given in the same *option-value* form that might
     be specified to form. The first two elements in this list list are
     "*-in*=>*$master*" where *$master* is the slave's master window.

*$master*->*formSlaves*
     Returns a list of all of the slaves for the master window. The order
     of the slaves in the list is the same as their order in the packing
     order. If master has no slaves then an empty string is returned.

SPECIFYING ATTACHMENTS
======================

   One can specify an attachment for each side of a slave window managed
by form. An attachment is specified in the the form "-*side* =>
[*anchor_point*, offset]". -*side* can be one of *-top*, *-bottom*,
*-left* or *-right*.

   Offset is given in screen units (i.e. any of the forms acceptable to
*Tk_GetPixels*).  A positive offset indicates shifting to a position to
the right or bottom of an anchor point. A negative offset indicates
shifting to a position to the left or top of an anchor point.

   *Anchor_point* can be given in one of the following forms:

*Grid Attachment*
     The master window is divided into a number of horizontal and vertical
     grids. By default the master window is divided into 100x100 grids; the
     number of grids can be adjusted by the *formGrid* method. A grid
     attachment anchor point is given by a % sign followed by an integer
     value. For example, *'%0'* specifies the first grid line (the top or
     left edge of the master window). *'%100'* specifies the last grid
     line (the bottom or right edge of the master window).

*Opposite Side Attachment*
     Opposite attachment specifies an anchor point located on the
     *opposite* side of another slave widget, which must be managed by
     form in the same master window. An opposite attachment anchor point
     is given by the name of another widget. For example,
     "$b->form(*-top*=>[*$a*,0])" attaches the top side of the widget $b
     to the bottom of the widget *$a*.

*Parallel Side Attachment*
     Opposite attachment specifies an anchor point located on the *same*
     side of another slave widget, which must be managed by form in the
     same master window. An parallel attachment anchor point is given by
     the sign *E<amp*> follwed by the name of another widget.  For
     example, "$b->form(*-top*=>['&',*$a*,0])" attaches the top side of
     the widget $b to the top of the widget *$a*, making the top sides of
     these two widgets at the same vertical position in their parent
     window.

*No Attachment*
     Specifies a side of the slave to be attached to nothing, indicated by
     the keyword none. When the none anchor point is given, the offset
     must be zero (or not present).  When a side of a slave is attached to
     *['none', 0]*, the position of this side is calculated by the
     position of the other side and the natural size of the slave. For
     example, if a the left side of a widget is attached to *['%0', 100]*,
     its right side attached to *['none', 0]*, and the natural size of the
     widget is 50 pixels, the right side of the widget will be positioned
     at pixel *['%0', 149]*.  When both *-top* and *-bottom* are attached
     to none, then by default *-top* will be attached to *['%0', 0]*. When
     both *-left* and *-right* are attached to none, then by default
     *-left* will be attached to *['%0', 0]*.

   Shifting effects can be achieved by specifying a non-zero offset with
an anchor point. In the following example, the top side of widget *\$b* is
attached to the bottom of *\$a*; hence *\$b* always appears below *\$a*.
Also, the left edge of *\$b* is attached to the left side of *\$a* with a
10 pixel offest.  Therefore, the left edge of *\$b* is always shifted 10
pixels to the right of *\$a*'s left edge:

       $b->form(*-left*=>[*$a*,10], *-top*=>[*$a*,0]);

ABBREVIATIONS:
--------------

   Certain abbreviations can be made on the attachment specifications:
First an offset of zero can be omitted.  Thus, the following two lines are
equivalent:

       $b->form(*-top*=>[*$a*,0], *-right*=>['%100',0]);

       $b->form(*-top*=>[*$a*], *-right*=>'%100');

   In the second case, when the anchor point is omitted, the offset must
be given. A default anchor point is chosen according to the value of the
offset. If the anchor point is 0 or positive, the default anchor point %0
is used; thus, "$b->form(*-top*=>15)" attaches the top edge of $b to a
position 15 pixels below the top edge of the master window. If the anchor
point is "-0" or negative, the default anchor point *%100* is used; thus,
"*$a*->form(*-right*=>-2)" attaches the right edge of *\$a* to a position
2 pixels to the left of the master window's right edge.  An further example
below shows a method with its equivalent abbreviation.

       $b->form(*-top*=>['%0',10], *-bottom*=>['%100',0]);

       $b->form(*-top*=>10, *-bottom*=>-0);

USING SPRINGS
=============

   To be written.

ALGORITHM OF FORM
=================

   form starts with any slave in the list of slaves of the master window.
Then it tries to determine the position of each side of the slave.

   If the attachment of a side of the slave is grid attachment, the
position of the side is readily determined.

   If the attachment of this side is none, then form tries to determine
the position of the opposite side first, and then use the position of the
opposite side and the natural size of the slave to determine the position
of this side.

   If the attachment is opposite or parallel widget attachments, then form
tries to determine the positions of the other widget first, and then use
the positions of the other widget and the natural size of the slave
determine the position of this side. This recursive algorithmis carried on
until the positions of all slaves are determined.

CIRCULAR DEPENDENCY
===================

   The algorithm of form will fail if a circular dependency exists in the
attachments of the slaves. For example:

       $c->form(*-left*=>$b);

       $b->form(*-right*=>$c);

   In this example, the position of the left side of $b depends on the
right side of $c, which in turn depends on the left side of $b.

   When a circular dependency is discovered during the execution of the
form algorithm, form will generate a background error and the geometry of
the slaves are undefined (and will be arbitrary). Notice that form only
executes the algorithm when the specification of the slaves' attachments
is complete.  Therefore, it allows intermediate states of circular
dependency during the specification of the slaves' attachments.  Also,
unlike the Motif Form manager widget, form defines circular dependency as
"*dependency in the same dimension*".  Therefore, the following code
fragment will does not have circular dependency because the two widgets do
not depend on each other in the same dimension ($b depends $c in the
horizontal dimension and $c depends on $b in the vertical dimension):

       $b->form(*-left*=>$c);

       $c->form(*-top*=>$b);

BUGS
====

   Springs have not been fully implemented yet.

SEE ALSO
========

   `Tk::grid|Tk::grid' in this node `Tk::pack|Tk::pack' in this node
`Tk::place|Tk::place' in this node

KEYWORDS
========

   geometry manager, form, attachment, spring, propagation, size, pack,
tix, master, slave


File: pm.info,  Node: Tk/getOpenFile,  Next: Tk/grab,  Prev: Tk/form,  Up: Module List

pop up a dialog box for the user to select a file to open or save.
******************************************************************

NAME
====

   getOpenFile, getSaveFile - pop up a dialog box for the user to select a
file to open or save.

       $widget->*getOpenFile*(?*-option*=>value, ...>?)

       $widget->*getSaveFile*(?*-option*=>value, ...>?)

DESCRIPTION
===========

   The methods *getOpenFile* and *getSaveFile* pop up a dialog box for the
user to select a file to open or save.

   The *getOpenFile* method is usually associated with the Open command in
the File menu.  Its purpose is for the user to select an existing file
*only*.  If the user enters an non-existent file, the dialog box gives the
user an error prompt and requires the user to give an alternative
selection. If an application allows the user to create new files, it
should do so by providing a separate New menu command.

   The *getSaveFile* method is usually associated with the Save as command
in the File menu. If the user enters a file that already exists, the
dialog box prompts the user for confirmation whether the existing file
should be overwritten or not.

   If the user selects a file, both *getOpenFile* and *getSaveFile* return
the full pathname of this file. If the user cancels the operation, both
commands return an undefined value.

   The following *option-value* pairs are possible as command line
arguments to these two commands:

*-defaultextension* => *extension*
     Specifies a string that will be appended to the filename if the user
     enters a filename without an extension. The default value is the empty
     string, which means no extension will be appended to the filename in
     any case. This option is ignored on the Macintosh platform, which
     does not require extensions to filenames.

*-filetypes* => [*filePattern* ?, ...?]
     If a File types listbox exists in the file dialog on the particular
     platform, this option gives the filetypes in this listbox. When the
     user choose a filetype in the listbox, only the files of that type
     are listed. If this option is unspecified, or if it is set to the
     empty list, or if the File types listbox is not supported by the
     particular platform then all files are listed regardless of their
     types. See `"SPECIFYING FILE PATTERNS"' in this node below for a
     discussion on the contents of *filePattern*s.

*-initialdir* => directory
     Specifies that the files in directory should be displayed when the
     dialog pops up. If this parameter is not specified, then the files in
     the current working directory are displayed.  This option may not
     always work on the Macintosh.  This is not a bug.  Rather, the
     *General Controls* control panel on the Mac allows the end user to
     override the application default directory.

*-initialfile* => filename
     Specifies a filename to be displayed in the dialog when it pops up.
     This option is ignored by the *getOpenFile* method.

*-title* => *titleString*
     Specifies a string to display as the title of the dialog box. If this
     option is not specified, then a default title is displayed. This
     option is ignored on the Macintosh platform.

SPECIFYING FILE PATTERNS
========================

   The *filePattern*s given by the *-filetypes* option are a list of file
patterns. Each file pattern is a list of the form

     typeName [extension ?extension ...?] ?[macType ?macType ...?]?

   *typeName* is the name of the file type described by this file pattern
and is the text string that appears in the File types listbox. *extension*
is a file extension for this file pattern.  *macType* is a four-character
Macintosh file type. The list of *macType*s is optional and may be omitted
for applications that do not need to execute on the Macintosh platform.

   Several file patterns may have the same *typeName,* in which case they
refer to the same file type and share the same entry in the listbox. When
the user selects an entry in the listbox, all the files that match at
least one of the file patterns corresponding to that entry are listed.
Usually, each file pattern corresponds to a distinct type of file. The use
of more than one file patterns for one type of file is necessary on the
Macintosh platform only.

   On the Macintosh platform, a file matches a file pattern if its name
matches at least one of the *extension*(s) AND it belongs to at least one
of the *macType*(s) of the file pattern. For example, the *C Source Files*
file pattern in the sample code matches with files that have a *\.c*
extension AND belong to the *macType* TEXT. To use the OR rule instead,
you can use two file patterns, one with the *extensions* only and the
other with the *macType* only. The *GIF Files* file type in the sample
code matches files that EITHER have a *\.gif* extension OR belong to the
*macType* *GIFF*.

   On the Unix and Windows platforms, a file matches a file pattern if its
name matches at at least one of the *extension*(s) of the file pattern.
The *macType*s are ignored.

SPECIFYING EXTENSIONS
=====================

   On the Unix and Macintosh platforms, extensions are matched using
glob-style pattern matching. On the Windows platforms, extensions are
matched by the underlying operating system. The types of possible
extensions are: (1) the special extension * matches any file; (2) the
special extension "" matches any files that do not have an extension
(i.e., the filename contains no full stop character); (3) any character
string that does not contain any wild card characters (* and ?).

   Due to the different pattern matching rules on the various platforms,
to ensure portability, wild card characters are not allowed in the
extensions, except as in the special extension *. Extensions without a
full stop character (e.g, ~) are allowed but may not work on all platforms.

EXAMPLE
=======

     my $types = [
         ['Text Files',       ['.txt', '.text']],
         ['TCL Scripts',      '.tcl'           ],
         ['C Source Files',   '.c',      'TEXT'],
         ['GIF Files',        '.gif',          ],
         ['GIF Files',        '',        'GIFF'],
         ['All Files',        '*',             ],
     ];
     my $filename = $widget->getOpenFile(-filetypes=>$types);

     if ($filename ne "") {
         # Open the file ...
     }

SEE ALSO
========

   `Tk::FBox|Tk::FBox' in this node, `Tk::FileSelect|Tk::FileSelect' in
this node

KEYWORDS
========

   file selection dialog


File: pm.info,  Node: Tk/grab,  Next: Tk/grid,  Prev: Tk/getOpenFile,  Up: Module List

Confine pointer and keyboard events to a window sub-tree
********************************************************

NAME
====

   grab - Confine pointer and keyboard events to a window sub-tree

   $widget->*grab*

   $widget->*grab*Option

DESCRIPTION
===========

   This set of methods implement simple pointer and keyboard grabs for Tk.
Tk's grabs are different than the grabs described in the Xlib
documentation.  When a grab is set for a particular window, Tk restricts
all pointer events to the grab window and its descendants in Tk's window
hierarchy.  Whenever the pointer is within the grab window's subtree, the
pointer will behave exactly the same as if there had been no grab at all
and all events will be reported in the normal fashion.  When the pointer
is outside $widget's tree, button presses and releases and mouse motion
events are reported to $widget, and window entry and window exit events
are ignored.  The grab subtree "owns" the pointer: windows outside the
grab subtree will be visible on the screen but they will be insensitive
until the grab is released.  The tree of windows underneath the grab
window can include top-level windows, in which case all of those top-level
windows and their descendants will continue to receive mouse events during
the grab.

   Two forms of grabs are possible:  local and global.  A local grab
affects only the grabbing application:  events will be reported to other
applications as if the grab had never occurred.  Grabs are local by
default.  A global grab locks out all applications on the screen, so that
only the given subtree of the grabbing application will be sensitive to
pointer events (mouse button presses, mouse button releases, pointer
motions, window entries, and window exits).  During global grabs the
window manager will not receive pointer events either.

   During local grabs, keyboard events (key presses and key releases) are
delivered as usual:  the window manager controls which application
receives keyboard events, and if they are sent to any window in the
grabbing application then they are redirected to the focus window.  During
a global grab Tk grabs the keyboard so that all keyboard events are always
sent to the grabbing application.  The focus method is still used to
determine which window in the application receives the keyboard events.
The keyboard grab is released when the grab is released.

   Grabs apply to particular displays.  If an application has windows on
multiple displays then it can establish a separate grab on each display.
The grab on a particular display affects only the windows on that display.
It is possible for different applications on a single display to have
simultaneous local grabs, but only one application can have a global grab
on a given display at once.

   The *grab* methods take any of the following forms:

$widget->*grabCurrent*
     Returns the current grab window in this application for $widget's
     display, or an empty string if there is no such window.

$widget->*grabs*
     Returns a list whose elements are all of the windows grabbed by this
     application for all displays, or an empty string if the application
     has no grabs.

     *Not implemented yet!*

$widget->*grabRelease*
     Releases the grab on $widget if there is one, otherwise does nothing.
     Returns an empty string.

$widget->*grab*
     Sets a local grab on $widget.  If a grab was already in effect for
     this application on $widget's display then it is automatically
     released.  If there is already a local grab on $widget, then the
     command does nothing.  Returns an empty string.

$widget->*grabGlobal*
     Sets a global grab on $widget.  If a grab was already in effect for
     this application on $widget's display then it is automatically
     released.  If there is already a global grab on $widget, then the
     command does nothing.  Returns an empty string.

$widget->*grabStatus*
     Returns none if no grab is currently set on $widget, local if a local
     grab is set on $widget, and global if a global grab is set.

BUGS
====

   It took an incredibly complex and gross implementation to produce the
simple grab effect described above.  Given the current implementation, it
isn't safe for applications to use the Xlib grab facilities at all except
through the Tk grab procedures.  If applications try to manipulate X's
grab mechanisms directly, things will probably break.

   If a single process is managing several different Tk applications, only
one of those applications can have a local grab for a given display at any
given time.  If the applications are in different processes, this
restriction doesn't exist.

KEYWORDS
========

   grab, keyboard events, pointer events, window


File: pm.info,  Node: Tk/grid,  Next: Tk/mega,  Prev: Tk/grab,  Up: Module List

Geometry manager that arranges widgets in a grid
************************************************

NAME
====

   Tk::grid - Geometry manager that arranges widgets in a grid

       $widget->grid?(?widget ...,? ?*arg* ?...>?)?

       $widget->gridOption?(*arg* ?,*arg* ...?)?

DESCRIPTION
===========

   The grid method is used to communicate with the grid geometry manager
that arranges widgets in rows and columns inside of another window, called
the geometry master (or master window).  The grid method can have any of
several forms, depending on the option argument:

*$slave*->grid(?*$slave, ...*??, options?)
     The arguments consist of the optional references to more slave windows
     followed by pairs of arguments that specify how to manage the slaves.
     The characters -,  x and ^, can be specified instead of a window
     reference to alter the default location of a *$slave*, as described
     in `"RELATIVE PLACEMENT"' in this node, below.

     If any of the slaves are already managed by the geometry manager then
     any unspecified options for them retain their previous values rather
     than receiving default values.

     The following options are supported:

    *-column* => n
          Insert the *$slave* so that it occupies the nth column in the
          grid.  Column numbers start with 0.  If this option is not
          supplied, then the *$slave* is arranged just to the right of
          previous slave specified on this call to grid, or column "0" if
          it is the first slave.  For each x that immediately precedes the
          *$slave*, the column position is incremented by one.  Thus the x
          represents a blank column for this row in the grid.

    *-columnspan* => n
          Insert the slave so that it occupies n columns in the grid.  The
          default is one column, unless the window name is followed by a
          -, in which case the columnspan is incremented once for each
          immediately following -.

    *-in* => *$other*
          Insert the slave(s) in the master window given by *$other*.  The
          default is the first slave's parent window.

    *-ipadx* => *amount*
          The *amount* specifies how much horizontal internal padding to
          leave on each side of the slave(s).  This is space is added
          inside the slave(s) border.  The *amount* must be a valid screen
          distance, such as 2 or *'.5c'*.  It defaults to 0.

    *-ipady* => *amount*
          The *amount* specifies how much vertical internal padding to
          leave on on the top and bottom of the slave(s).  This space is
          added inside the slave(s) border.  The *amount*  defaults to 0.

    *-padx* => *amount*
          The *amount* specifies how much horizontal external padding to
          leave on each side of the slave(s), in screen units.  The
          *amount* defaults to 0.  This space is added outside the
          slave(s) border.

    *-pady* => *amount*
          The *amount* specifies how much vertical external padding to
          leave on the top and bottom of the slave(s), in screen units.
          The *amount* defaults to 0.  This space is added outside the
          slave(s) border.

    *-row* => n
          Insert the slave so that it occupies the nth row in the grid.
          Row numbers start with 0.  If this option is not supplied, then
          the slave is arranged on the same row as the previous slave
          specified on this call to grid, or the first unoccupied row if
          this is the first slave.

    *-rowspan* => n
          Insert the slave so that it occupies n rows in the grid.  The
          default is one row.  If the next grid method contains ^
          characters instead of *$slave*s that line up with the columns of
          this *$slave*, then the *rowspan* of this *$slave* is extended
          by one.

    *-sticky* => style
          If a slave's cell is larger than its requested dimensions, this
          option may be used to position (or stretch) the slave within its
          cell.  Style  is a string that contains zero or more of the
          characters n, s, e or w.  The string can optionally contain
          spaces or commas, but they are ignored.  Each letter refers to a
          side (north, south, east, or west) that the slave will "stick"
          to.  If both n and s (or e and w) are specified, the slave will
          be stretched to fill the entire height (or width) of its cavity.
          The *sticky* option subsumes the combination of *-anchor* and
          *-fill* that is used by `pack|Tk::pack' in this node.  The
          default is ", which causes the slave to be centered in its
          cavity, at its requested size.

*$master*->*gridBbox*(?*column, row*,? ?*column2, row2*?)
     With no arguments, the bounding box (in pixels) of the grid is
     returned.  The return value consists of 4 integers.  The first two
     are the pixel offset from the master window (x then y) of the
     top-left corner of the grid, and the second two integers are the
     width and height of the grid, also in pixels.  If a single column and
     row is specified on the command line, then the bounding box for that
     cell is returned, where the top left cell is numbered from zero.  If
     both column and row arguments are specified, then the bounding box
     spanning the rows and columns indicated is returned.

*$master*->*gridColumnconfigure*(index?, *-option*=>*value, ...*?)
     Query or set the column properties of the index column of the
     geometry master, *$master*.  The valid options are *-minsize*,
     *-weight* and *-pad*.  If one or more options are provided, then
     index may be given as a list of column indices to which the
     configuration options will operate on.  The *-minsize* option sets
     the minimum size, in screen units, that will be permitted for this
     column.  The *-weight* option (an integer value) sets the relative
     weight for apportioning any extra spaces among columns.  A weight of
     zero (0) indicates the column will not deviate from its requested
     size.  A column whose weight is two will grow at twice the rate as a
     column of weight one when extra space is allocated to the layout.
     The *-pad* option specifies the number of screen units that will be
     added to the largest window contained completely in that column when
     the grid geometry manager requests a size from the containing window.
     If only an option is specified, with no value, the current value of
     that option is returned.  If only the master window and index is
     specified, all the current settings are returned in an list of
     "-option value" pairs.

*$slave*->*gridConfigure*(?*$slave, ...*?, options?)
     The same as grid method.

*$slave*->*gridForget*?(*$slave, ...*)?
     Removes each of the *$slave*s from grid for its master and unmaps
     their windows.  The slaves will no longer be managed by the grid
     geometry manager.  The configuration options for that window are
     forgotten, so that if the slave is managed once more by the grid
     geometry manager, the initial default settings are used.

*$slave*->*gridInfo*
     Returns a list whose elements are the current configuration state of
     the slave given by *$slave* in the same option-value form that might
     be specified to *gridConfigure*.  The first two elements of the list
     are "*-in*=>*$master*" where *$master* is the slave's master.

*$master*->*gridLocation*(*x, y*)
     Given  x and y values in screen units relative to the master window,
     the column and row number at that x and y location is returned.  For
     locations that are above or to the left of the grid, *-1* is returned.

*$master*->*gridPropagate*?(boolean)?
     If boolean has a true boolean value such as 1 or *on* then
     propagation is enabled for *$master*, which must be a window name
     (see `"GEOMETRY PROPAGATION"' in this node below).  If boolean has a
     false boolean value then propagation is disabled for *$master*.  In
     either of these cases an empty string is returned.  If boolean is
     omitted then the method returns 0 or 1 to indicate whether
     propagation is currently enabled for *$master*.  Propagation is
     enabled by default.

*$master*->*gridRowconfigure*(index?, *-option*=>*value, ...*?)
     Query or set the row properties of the index row of the geometry
     master, *$master*.  The valid options are *-minsize*, *-weight* and
     *-pad*.  If one or more options are provided, then index may be given
     as a list of row indeces to which the configuration options will
     operate on.  The *-minsize* option sets the minimum size, in screen
     units, that will be permitted for this row.  The *-weight* option (an
     integer value) sets the relative weight for apportioning any extra
     spaces among rows.  A weight of zero (0) indicates the row will not
     deviate from its requested size.  A row whose weight is two will grow
     at twice the rate as a row of weight one when extra space is
     allocated to the layout.  The *-pad* option specifies the number of
     screen units that will be added to the largest window contained
     completely in that row when the grid geometry manager requests a size
     from the containing window.  If only an option is specified, with no
     value, the current value of that option is returned.  If only the
     master window and index is specified, all the current settings are
     returned in an list of "option-value" pairs.

*$slave*->*gridRemove*?(*$slave, ...*)?
     Removes each of the *$slave*s from grid for its master and unmaps
     their windows.  The slaves will no longer be managed by the grid
     geometry manager.  However, the configuration options for that window
     are remembered, so that if the slave is managed once more by the grid
     geometry manager, the previous values are retained.

*$master*->*gridSize*
     Returns the size of the grid (in columns then rows) for *$master*.
     The size is determined either by the *$slave* occupying the largest
     row or column, or the largest column or row with a *-minsize*,
     *-weight*, or *-pad* that is non-zero.

*$master*->*gridSlaves*?(*-option*=>value)?
     If no options are supplied, a list of all of the slaves in *$master*
     are returned, most recently manages first.  *-option* can be either
     *-row* or *-column* which causes only the slaves in the row (or
     column) specified by value to be returned.

RELATIVE PLACEMENT
==================

   The grid method contains a limited set of capabilities that permit
layouts to be created without specifying the row and column information
for each slave.  This permits slaves to be rearranged, added, or removed
without the need to explicitly specify row and column information.  When
no column or row information is specified for a *$slave*, default values
are chosen for *-column*, *-row*, *-columnspan* and *-rowspan* at the time
the *$slave* is managed. The values are chosen based upon the current
layout of the grid, the position of the *$slave* relative to other
*$slave*s in the same grid method, and the presence of the characters -,
^, and ^ in grid method where *$slave* names are normally expected.

-
     This increases the columnspan of the *$slave* to the left.  Several
     -'s in a row will successively increase the columnspan. A - may not
     follow a ^ or a x.

x
     This leaves an empty column between the *$slave* on the left and the
     *$slave* on the right.

^
     This extends the *-rowspan* of the *$slave* above the ^'s in the
     grid.  The number of ^'s in a row must match the number of columns
     spanned by the *$slave* above it.

THE GRID ALGORITHM
==================

   The grid geometry manager lays out its slaves in three steps.  In the
first step, the minimum size needed to fit all of the slaves is computed,
then (if propagation is turned on), a request is made of the master window
to become that size.  In the second step, the requested size is compared
against the actual size of the master.  If the sizes are different, then
space is added to or taken away from the layout as needed.  For the final
step, each slave is positioned in its row(s) and column(s) based on the
setting of its *sticky* flag.

   To compute the minimum size of a layout, the grid geometry manager
first looks at all slaves whose columnspan and rowspan values are one, and
computes the nominal size of each row or column to be either the *minsize*
for that row or column, or the sum of the padding plus the size of the
largest slave, whichever is greater.  Then the slaves whose rowspans or
columnspans are greater than one are examined.  If a group of rows or
columns need to be increased in size in order to accommodate these slaves,
then extra space is added to each row or column in the group according to
its weight.  For each group whose weights are all zero, the additional
space is apportioned equally.

   For masters whose size is larger than the requested layout, the
additional space is apportioned according to the row and column weights.
If all of the weights are zero, the layout is centered within its master.
For masters whose size is smaller than the requested layout, space is taken
away from columns and rows according to their weights.  However, once a
column or row shrinks to its minsize, its weight is taken to be zero.  If
more space needs to be removed from a layout than would be permitted, as
when all the rows or columns are at there minimum sizes, the layout is
clipped on the bottom and right.

GEOMETRY PROPAGATION
====================

   The grid geometry manager normally computes how large a master must be
to just exactly meet the needs of its slaves, and it sets the requested
width and height of the master to these dimensions.  This causes geometry
information to propagate up through a window hierarchy to a top-level
window so that the entire sub-tree sizes itself to fit the needs of the
leaf windows.  However, the *gridPropagate* method may be used to turn off
propagation for one or more masters.  If propagation is disabled then grid
will not set the requested width and height of the master window.  This
may be useful if, for example, you wish for a master window to have a
fixed size that you specify.

RESTRICTIONS ON MASTER WINDOWS
==============================

   The master for each slave must either be the slave's parent (the
default) or a descendant of the slave's parent.  This restriction is
necessary to guarantee that the slave can be placed over any part of its
master that is visible without danger of the slave being clipped by its
parent.  In addition, all slaves in one call to grid must have the same
master.

STACKING ORDER
==============

   If the master for a slave is not its parent then you must make sure
that the slave is higher in the stacking order than the master.  Otherwise
the master will obscure the slave and it will appear as if the slave
hasn't been managed correctly.  The easiest way to make sure the slave is
higher than the master is to create the master window first:  the most
recently created window will be highest in the stacking order.

CREDITS
=======

   The grid method is based on ideas taken from the *GridBag* geometry
manager written by Doug. Stein, and the *blt_table* geometry manager,
written by George Howlett.

SEE ALSO
========

   `Tk::form|Tk::form' in this node `Tk::pack|Tk::pack' in this node
`Tk::place|Tk::place' in this node

KEYWORDS
========

   geometry manager, location, grid, cell, propagation, size, pack,
master, slave


File: pm.info,  Node: Tk/mega,  Next: Tk/messageBox,  Prev: Tk/grid,  Up: Module List

perl/Tk support to write widgets in perl
****************************************

NAME
====

   Tk::mega - perl/Tk support to write widgets in perl

       *package Tk::**Whatever*;

       *Construct Tk::**ValidFor* *'Whatever'*;

       *sub ClassInit* { *my ($mega, $args) = @_; ...* }

   For composite widget classes:

       *sub Populate* { *my ($composite, $args) = @_; ...* }

   For derived widget classes:

       *sub InitObject* { *my ($derived, $args) = @_; ...* }

DESCRIPTION
===========

   The goal of the mega widget support of perl/Tk is to make it easy to
write mega widgets that obey the same protocol and interface that the Tk
core widgets support.  There are two kinds of mega widgets:

   * Composite Widgets

     A composite widget is composed with one or more existing widgets.
     The composite widget looks to the user like a simple single widget.
     A well known example is the file selection box.

   * Derived Widgets

     A derived widget adds/modifies/removes properties and methods from a
     single widget (this widget may itself be a mega widget).

MEGA WIDGET SUPPORT
===================

Advertise
---------

   Give a subwidget a symbolic name.

   Usage:

       *$cw*->Advertise(name=>$widget);

   Gives a subwidget $widget of the composite widget *$cw* the name name.
One can retrieve the reference of an advertised subwidget with the
`Subwidget|"Subwidget"' in this node method.

   Comment: Mega Widget Writers: Please make sure to document the
advertised widgets that are intended for *public* use.  If there are none,
document this fact, e.g.:

     =head1 ADVERTISED WIDGETS

     None.

Callback
--------

   Invoke a callback specified with an option.

   Usage:

       *$mega*->Callback(*-option* ?,args ...?);

   Callback executes the `callback|Tk::callbacks' in this node defined with
*$mega*->ConfigSpecs(*-option*, [*CALLBACK*, ...]); If args are given they
are passed to the callback. If *-option* is not defined it does nothing.

ClassInit
---------

   Initialization of the mega widget class.

   Usage:

       *sub ClassInit* { *my ($class, $mw) = @_;* ...  }

   ClassInit is called once for each `MainWindow|Tk::MainWindow' in this
node just before the first widget instance of a class is created in the
widget tree of *MainWindow*.

   ClassInit is often used to define bindings and/or other resources
shared by all instances, e.g., images.

   Examples:

     $mw->bind($class,"<Tab>", sub { my $w = shift; $w->Insert("\t"); $w->focus; $w->break});
     $mw->bind($class,"<Return>", ['Insert',"\n"]);
     $mw->bind($class,"<Delete>",'Delete');

   Notice that $class is the class name (e.g. *Tk::MyText*) and *$mw* is
the mainwindow.

   Don't forget to call $class->*SUPER::ClassInit($mw)* in ClassInit.

Component
---------

   Convenience function to create subwidgets.

   Usage:

     $cw->Component('Whatever', 'AdvertisedName',
     		   -delegate => ['method1', 'method2', ...],
     		   ... Whatever widget options ...,
     		  );

   Component does several things for you with one call:

   o Creates the widget

   o Advertises it with a given name (overridden by 'Name' option)

   o Delegates a set of methods to this widget (optional)

   Example:

     $cw->Component('Button', 'quitButton', -command => sub{$mw->'destroy'});

ConfigSpecs
-----------

   Defines options and their treatment

   Usage:

     $cw->ConfigSpecs(
     	    -option => [ where, dbname, dbclass, default],
     	    ...,
     	    DEFAULT => [where],
     	    );

   Defines the options of a mega widget and what actions are triggered by
configure/cget of an option (see *Note Tk/ConfigSpecs: Tk/ConfigSpecs, and
*Note Tk/Derived: Tk/Derived, for details).

Construct
---------

   Make the new mega widget known to Tk.

   Usage:

       Construct *baseclass* *'Name'*;

   Construct declares the new widget class so that your mega widget works
like normal Perl/Tk widgets.

   Examples:

       *Construct Tk::Widget* *'Whatever'*;     *Construct Tk::Menu*
*'MyItem'*;

   First example lets one use $widget->*Whatever* to create new *Whatever*
widget.

   The second example restricts the usage of the *MyItem* constructor
method to widgets that are derived from Menu: *$isamenu*->*MyItem*.

CreateArgs
----------

   Mess with options before any widget is created

       *sub CreateArgs* { *my ($package, $parent, $args) = @_; ...; return
@newargs;* }

   *$package* is the package of the mega widget (e.g., *Tk::MyText*,
*$parent* the parent of the widget to be created and $args the hash
reference to the options specified in the widget constructor call.

   Don't forget to call *$package*->*SUPER::CreateArgs*(*$parent*, $args)
in CreateArgs.

Delegates
---------

   Redirect a method of the mega widget to a subwidget of the composite
widget

   Usage:

     $cw->Delegates(
     		'method1' => $subwidget1,
     		'method2' => 'advertived_name',
     		...,
     		'Construct' => $subwidget2,
     		'DEFAULT'   => $subwidget3,
     		);

   The *'Construct'* delegation has a special meaning.  After 'Construct'
is delegated all Widget constructors are redirected.  E.g. after

       *$mega*->Delegates(*'Construct'*=>*$subframe*);

   a *$mega*->Button does really a *$subframe*->Button so the created
button is a child of *$subframe* and not *$mega*.

   Comment: Delegates works only with methods that *$cw* does not have
itself.

InitObject
----------

   Defines construction and interface of derived widgets.

   Usage:

     sub InitObject {
     	my ($derived, $args) = @_;
     	...
     }

   where *$derived* is the widget reference of the already created
baseclass widget and $args is the reference to a hash of *-option-value*
pairs.

   InitObject is almost identical to `Populate|"Populate"' in this node
method.  Populate does some more 'magic' things useful for mega widgets
with several widgets.

   Don't forget to call *$derived*->*SUPER::InitObject*($args) in
InitObject.

OnDestroy
---------

   Define callback invoked when widget is destroyed.

   Usage:

       $widget->OnDestroy(callback);

   OnDestroy installs a `callback|Tk::callbacks' in this node that's called
when a widget is going to to be destroyed.  Useful for special cleanup
actions.  It differs from a normal destroy in that all the widget's data
structures are still intact.

   Comment: This method could be used with any widgets not just for mega
widgets.  It's listed here because of it's usefulness.

Populate
--------

   Defines construction and interface of the composite widget.

   Usage:

     sub Populate {
     	my ($mega, $args) = @_;
     	...
     }

   where *$mega* is the widget reference of the already created baseclass
widget and $args is the reference to a hash of *-option-value* pairs.

   Most the other support function are normally used inside the Populate
subroutine.

   Don't forget to call *$cw*->*SUPER::Populate*($args) in Populate.

privateData
-----------

   Set/get a private hash of a widget to storage composite internal data

   Usage:

       $hashref = *$mega*->privateData();

       *$another* = *$mega*->privateData(*unique_key*|package);

Subwidget
---------

   Get the widget reference of an advertised subwidget.

       *$subwidget* = *$cw*->Subwidget(name);

       *@subwidget* = *$cw*->Subwidget(name ?,...?);

   Returns the widget reference(s) of the subwidget known under the name
name.  See `Advertise|"Advertise"' in this node method how to define name
for a subwidget.

   Comment: Mega Widget Users: Use Subwidget to get *only* documented
subwidgets.

PITFALLS
========

   * Resource DB class name

     Some of the standard options use a resource date base class that is
     not equal to the resource database name.  E.g.,

          Switch:            Name:             Class:

          -padx              padX              Pad
          -activerelief      activeRelief      Relief
          -activebackground  activeBackground  Foreground
          -status            undef             undef

     One should do the same when one defines one of these options via
     ConfigSpecs.

   * Method delegation

     Redirecting methods to a subwidget with *Delegate* can only work if
     the base widget itself does have a method with this name.  Therefore
     one can't "delegate" any of the methods listed in
     `Tk::Widget|Tk::Widget' in this node.  A common problematic method is
     bind.  In this case one as to explicitely redirect the method.

          sub bind
            {
              my $mega = shift;
              my $to = $mega->privateData->{'my_bind_target'};
              $to->bind(@_);
            }

   * privateData

     Graham Barr wrote: ... It is probably more private than most people
     think. Not all calls to privateData will return that same HASH
     reference. The HASH reference that is returned depends on the package
     it was called from, a different HASH is returned for each package.
     This allows a widget to hold private data, but then if it is
     sub-classed the sub-class will get a different HASH and so not cause
     duplicate name clashes.

     But privateData does take an optional argument if you want to force
     which HASH is returned.

   * Scrolled and Composite

     *Scrolled*(*Kind*,...) constructor can not be used with Composite.
     One has to use $cw->Composite(*Scrl**Kind* => *'name'*, ...);

MISSING
=======

   Of course perl/Tk does not define support function for all necessities.
Here's a short list of things you have to handle yourself:

   * no support to define construction-time only options.

   * no support to remove an option that is known to the base widget.

   * it's hard to define undef as fallback for an widget option that is
     not already undef.

   * Frame in perl/Tk carries magic and overhead not needed for composite
     widget class definition.

   * No support methods for bindings that are shared between all widgets
     of a composite widget (makes sense at all?)

KEYWORDS
========

   mega, composite, derived, widget

SEE ALSO
========

   `Tk::composite|Tk::composite' in this node
`Tk::ConfigSpecs|Tk::ConfigSpecs' in this node `Tk::option|Tk::option' in
this node `Tk::callbacks|Tk::callbacks' in this node `Tk::bind|Tk::bind'
in this node


