This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Net/Pager,  Next: Net/Patricia,  Prev: Net/POP3,  Up: Module List

Send Numeric/AlphaNumeric Pages to any pager/phone around  the world through the SimpleWire network.
****************************************************************************************************

NAME
====

   Net::Pager - Send Numeric/AlphaNumeric Pages to any pager/phone around
the world through the SimpleWire network.

SYNOPSIS
========

   NOTE!: Version 2.00 is not compatible with Net::Pager 1.12.  All
client/server communication has been redesigned with XML in mind.  Thus,
this module had to dramatically change and so did the interface.  I
apologize for this, but the change has boosted performance 200-300% with
the addition of asynchronous paging and the many other enhancements.

   `use Net::Pager;'

   See all the documenation and example code in both this installation
package and on the www.simplewire.com website.  The sendpage.pl,
checkstatus.pl, and the servicelist.pl show great example code for every
feature supported in v2.00.  These are located on both the
www.simplewire.com website and in the /eg directory with the
Net-Pager-2.00.tar.gz file.

DESCRIPTION
===========

   Net::Pager is a global numeric and alphanumeric paging interface via the
Internet. It is the first and only way to interface any brand or type of
pager through one consistent protocol without using the telephone network.
SimpleWire has defined a XML paging standard so paging technology can be
better utilized.

   The module interacts with SimleWire's Remote Procedure Calls. This new
standard, and subsequently this Perl module, has a great deal of
development energy behind it.

   For futher support or questions, you should visit s website at
*www.simplewire.com* where you can visit our developer support forum, faq,
or download the most recent documentation.  SimpleWire's site has more
example code.

NEW FEATURES IN 2.00
====================

     * The module was totally re-written since XML has been introduced
       as the language for all client/server communication between this
       client tool and the SimpleWire network.
     * Support for asynchronous sending of pages has been added.  This
       means that network delays are now handled by the SimpleWire servers
       rather than the client tools. This has eliminated any timeout
       bugs that might occur, since SimpleWire can now respond immediately.
     * Object oriented design following the HTTP::Response and
       HTTP::Request methodology.  Clients now construct Net::Pager::Request
       objects, submit various requests through this object, and use
       the Net::Pager::Response object to analyze the response from the
       SimpleWire servers.  This resulted in three more objects:
       Net::Pager::Common, Net::Pager::Request, and Net::Pager::Response.
     * SimpleWire now captures more error messages from each paging service.
       A good example is the attempt to send pages to Sprint PCS phones
       even though text messaging costs extra and most users don't have
       it.  SimpleWire now catches this kind of error.
     * Added new services: Verizon, VoiceStream/OmniPoint
       Bell Mobility, and Weblink Wireless Two-Way.
     	* Introduction of a ticket system where a TICKET ID is assigned
       to every sendpage transaction.  This allows clients to check on
       the status of pages sent asynchronously or to check up on older
       pages sent through our system.
     * Added support for sending a page to a simplewire alias.  This
       means clients can now send pages to an alias instead of a pin
       and service id, provided that the alias is setup and registered
       on the SimpleWire network.
     * Fixed small issue with clients entering pins that contain a dash
     	  or a period.  Our servers will now filter out this garbage to
       ensure proper formatting of the pin.
     * Added support for Subscriber IDs and Subscriber passwords.
     * Added an optional delimiter parameter to be passed along with a page
       so that client tools can override our default delimiter to
       seperate the from, callback, and text fields in messages.
     * Fixed timeout bugs by using LWP::UserAgent instead of our own
       networking code.
     * SimpleWire can now support proxy servers via the LWP::UserAgent
       module.  However, this will take custom tweaking of our
     	  Net::Pager moduele until native support is added.
     * Revised the system for remotely retrieving our service list.  Many new
       options have been added so that the list comes back sorted or
       filtered in whatever way you like.
     * Improved functions to use with the service list.  New functions
       include DBI-like interface for retrieval and looping.  Such
       functions are fetchrow_service, fetchall_services, and fetchrow_rewind.
     * Fixed small bug that was related to timeouts where 2 or 3 duplicated
       pages would be sent off.  This was solved via LWP and smarter
       error checking before moving onto the next simplewire server.

AUTHOR
======

   Joe Lauer <joelauer@rootlevel.com>

COPYRIGHT
=========

   Copyright (c) 2000 Rootlevel. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.


File: pm.info,  Node: Net/Patricia,  Next: Net/Pcap,  Prev: Net/Pager,  Up: Module List

Patricia Trie perl module for fast IP address lookups
*****************************************************

NAME
====

   Net::Patricia - Patricia Trie perl module for fast IP address lookups

SYNOPSIS
========

     use Net::Patricia;

     my $pt = new Net::Patricia;

     $pt->add_string('127.0.0.0/8', \$user_data);
     $pt->match_string('127.0.0.1');
     $pt->match_exact_string('127.0.0.0');
     $pt->match_integer(2130706433); # 127.0.0.1
     $pt->match_exact_integer(2130706432, 8); # 127.0.0.0
     $pt->remove_string('127.0.0.0/8');
     $pt->climb(sub { print "climbing at node $_[0]\n" });

     undef $pt; # automatically destroys the Patricia Trie

DESCRIPTION
===========

   This module uses a Patricia Trie data structure to quickly perform IP
address prefix matching for applications such as IP subnet, network or
routing table lookups.  The data structure is based on a radix tree using
a radix of two, so sometimes you see patricia implementations called
"radix" as well.  The term "Trie" is derived from the word "retrieval" but
is pronounced like "try".  Patricia stands for "Practical Algorithm to
Retrieve Information Coded as Alphanumeric", and was first suggested for
routing table lookups by Van Jacobsen.  Patricia Trie performance
characteristics are well-known as it has been employed for routing table
lookups within the BSD kernel since the 4.3 Reno release.

   The BSD radix code is thoroughly described in "TCP/IP Illustrated,
Volume 2" by Wright and Stevens and in the paper "A Tree-Based Packet
Routing Table for Berkeley Unix" by Keith Sklower.

METHODS
=======

new - create a new Net::Patricia object
          $pt = new Net::Patricia;

     This is the class' constructor - it returns a `Net::Patricia' object
     upon success or undef on failure.  For now, the constructor takes no
     arguments, and defaults to creating a tree which uses AF_INET IPv4
     address and mask values as keys.  In the future it will probably take
     one argument such as AF_INET or AF_INET6 to specify whether or not you
     are use 32-bit IP addresses as keys or 128-bit IPv6 addresses.

     The `Net::Patricia' object will be destroyed automatically when there
     are no longer any references to it.

add_string
          $pt->add_string(key_string[,user_data]);

     The first argument, key_string, is a network or subnet specification
     in canonical form, e.g. "10.0.0.0/8", where the number after the slash
     represents the number of bits in the netmask.  If no mask width is
     specified, the longest possible mask is assumed, i.e. 32 bits for
     AF_INET addresses.

     The second argument, user_data, is optional.  If supplied, it should
     be a SCALAR value (which may be a perl reference) specifying the user
     data that will be stored in the Patricia Trie node.  Subsequently,
     this value will be returned by the match methods described below to
     indicate a successful search.  Remember that perl references and
     objects are represented as SCALAR values and therefore the user data
     can be complicated data objects.

     If no second argument is passed, the key_string will be stored as the
     user data and therfore will likewise be returned by the match
     functions.

     On success, this method returns the user_data passed as the second
     argument or key_string if no user data was specified.  It returns
     undef on failure.

match_string
          $pt->match_string(key_string);

     This method searches the Patricia Trie to find a matching node,
     according to normal subnetting rules for the address and mask
     specified.

     The key_string argument is a network or subnet specification in
     canonical form, e.g. "10.0.0.0/8", where the number after the slash
     represents the number of bits in the netmask.  If no mask width value
     is specified, the longest mask is assumed, i.e. 32 bits for AF_INET
     addresses.

     If a matching node is found in the Patricia Trie, this method returns
     the user data for the node.  This method returns undef on failure.

match_exact_string
          $pt->match_exact_string(key_string);

     This method searches the Patricia Trie to find a matching node.  Its
     semantics are exactly the same as those described for match_string
     except that the key must match a node exactly.  I.e. it is not
     sufficient that the address and mask specified merely falls within the
     subnet specified by a particular node.

match_integer
          $pt->match_integer(integer[,mask_bits]);

     This method searches the Patricia Trie to find a matching node,
     according to normal subnetting rules for the address and mask
     specified.  Its semantics are similar to those described for
     match_string except that the key is specified using an integer (i.e.
     SCALAR), such as that returned by perl's unpack function for values
     converted using the "N" (network-ordered long).  Note that this
     argument is not a packed network-ordered long.

     Just to be completely clear, the integer argument should be a value of
     the sort produced by this code:

          use Socket;
          $integer = unpack("N", inet_aton("10.0.0.0"));

match_exact_integer
          $pt->match_exact_integer(integer[,mask_bits]);

     This method searches the Patricia Trie to find a matching node.  Its
     semantics are exactly the same as match_integer except that the key
     must match a node exactly.  I.e. it is not sufficient that the address
     and mask specified merely falls within the subnet specified by a
     particular node.

remove_string
          $pt->remove_string(key_string);

     This method removes the node which exactly matches the the address and
     mask specified from the Patricia Trie.

     If the matching node is found in the Patricia Trie, it is removed, and
     this method returns the user data for the node.  This method returns
     undef on failure.

climb
          $pt->climb([CODEREF]);

     This method climbs the Patricia Trie, visiting each node as it does
     so.

     The CODEREF argument is optional.  It is a perl code reference used to
     specify a user-defined subroutine to be called when visiting each
     node.  The node's user data will be passed as the sole argument to
     that subroutine.

     This method returns the number of nodes successfully visited while
     climbing the Trie.  That is, without a CODEREF argument, it simply
     counts the number of nodes in the Patricia Trie.

     Note that currently the return value from your CODEREF subroutine is
     ignored.  In the future the climb method may return the number of
     times your subroutine returned non-zero, as it is called once per
     node.  So, if you are currently relying on the climb return value to
     accurately report a count of the number of nodes in the Patricia
     Trie, it would be prudent to have your subroutine return a non-zero
     value.

     This method is called climb() rather than walk() because climbing
     trees (and therfore tries) is a more popular pass-time than walking
     them.

BUGS
====

   I've only had the opportunity to test this code on GNU/Linux and
Solaris.  [Why is it that I have fewer platforms available to me in
academia than I used to have in the private industry?  Ugh.]  As such I am
somewhat concerned about the portability of the C code on which this
module is based and whether or not the resulting objects will link on
other platforms.  Please send me reports, preferably including fixes for
my Makefile.PL files and such.

   This is the first XSUB perl extension that I have written.  Consider
yourself warned! ;^)  I'm particularly concerned as to whether or not my
XS code is correct and whether or not this code leaks memory.  I've made
an effort to avoid leaks in my use of the C patricialib API and in my
manipulation of perl xVs, but am not sure if I have been successful in
either case.  If leaks are discovered please report them to me as they are
surely my fault and not that of the authors of the code on which this
module is based.

   Methods to add or remove nodes using integer arguments are yet to be
implemented.  This was a lower priority since it is less necessary to
avoid the overhead involved in translation from a string representation
since add and remove operations are usually performed less frequently than
matching operations.

   This modules does not yet support AF_INET6 (IP version 6) 128 bit
addresses, although the underlying patricialib C code does.

   When passing a CODEREF argument to the climb method, the return value
from your CODEREF subroutine is currently ignored.  In the future the
climb method may return the number of times your subroutine returned
non-zero, as it is called once per node.  So, if you are currently relying
on the climb return value to accurately report a count of the number of
nodes in the Patricia Trie, it would be prudent to have your subroutine
return a non-zero value.

AUTHOR
======

   Dave Plonka <plonka@doit.wisc.edu>

   Copyright (C) 2000  Dave Plonka.  This program is free software; you
can redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

   This product includes software developed by the University of Michigan,
Merit Network, Inc., and their contributors.  See the copyright file in
the patricialib sub-directory of the distribution for details.

   patricialib, the C library used by this perl extension, is an extracted
version of MRT's patricia code from radix.[ch], which was worked on by
Masaki Hirabaru and Craig Labovitz.  For more info on MRT see:

     http://www.mrtd.net/

   The MRT patricia code owes some heritage to GateD's radix code, which
in turn owes something to the BSD kernel.

SEE ALSO
========

   perl(1), Socket, Net::Netmask, Text::Trie, Tree::Trie.

   Tree::Radix and Net::RoutingTable are modules by Daniel Hagerty
<hag@linnaean.org> written entirely in perl, unlike this module.  At the
time of this writing, they are works-in-progress but may be available at:

     http://www.linnaean.org/~hag/


File: pm.info,  Node: Net/Pcap,  Next: Net/PcapUtils,  Prev: Net/Patricia,  Up: Module List

Interface to pcap(3) LBL packet capture library
***********************************************

NAME
====

   *Net::Pcap* - Interface to pcap(3) LBL packet capture library

SYNOPSIS
========

     use Net::Pcap;

DESCRIPTION
===========

   *Net::Pcap* is a Perl binding to the LBL pcap(3) library, version 0.4.
The README for libpcap describes itself as:

     "a system-independent interface for user-level packet capture.
     libpcap provides a portable framework for low-level network
     monitoring.  Applications include network statistics collection,
     security monitoring, network debugging, etc."

FUNCTIONS
=========

   All functions defined by *Net::Pcap* are direct mappings to the libpcap
functions.  Consult the pcap(3) documentation and source code for more
information.

   Arguments that change a parameter, for example *Net::Pcap::lookupdev()*,
are passed that parameter as a reference.  This is to retain compatibility
with previous versions of *Net::Pcap*.

Lookup functions
----------------

Net::Pcap::lookupdev(\$err);
     Returns the name of a network device that can be used with
     *Net::Pcap::open_live() function*.  On error, the $err parameter is
     filled with an appropriate error message else it is undefined.

*Net::Pcap::lookupnet($dev, \$net, \$mask, \$err);*
     Determine the network number and netmask for the device specified in
     $dev.  The function returns 0 on success and sets the $net and $mask
     parameters with values.  On failure it returns -1 and the $err
     parameter is filled with an appropriate error message.

Packet capture functions
------------------------

*Net::Pcap::open_live($dev, $snaplen, $promisc, $to_ms, \$err);*
     Returns a packet capture descriptor for looking at packets on the
     network.  The $dev parameter specifies which network interface to
     capture packets from.  The $snaplen and $promisc parameters specify
     the maximum number of bytes to capture from each packet, and whether
     to put the interface into promiscuous mode, respectively.  The $to_ms
     parameter specifies a read timeout in ms.  The packet descriptor will
     be undefined if an error occurs, and the $err parameter will be set
     with an appropriate error message.

*Net::Pcap::loop($pcap_t, $cnt, \&callback_fn, $user_data);*
     Read $cnt packets from the packet capture descriptor $pcap_t and call
     the perl function &callback_fn with an argument of $user_data.  If
     $cnt is negative, then the function loops forever or until an error
     occurs.

     The callback function is also passed packet header information and
     packet data like so:

          sub process_pkt {
              my($user_data, $hdr, $pkt) = @_;

          ...
            }

     The header information is a reference to a hash containing the
     following fields.

        * len

          The total length of the packet.

        * caplen

          The actual captured length of the packet data.  This corresponds
          to the snapshot length parameter passed to
          *Net::Pcap::open_live()*.

        * tv_sec

          Seconds value of the packet timestamp.

        * tv_usec

          Microseconds value of the packet timestamp.

*Net::Pcap::open_offline($filename, \$err);*
     Return a packet capture descriptor to read from a previously created
     "savefile".  The returned descriptor is undefined if there was an
     error and in this case the $err parameter will be filled.  Savefiles
     are created using the Net::Pcap::dump_* commands.

Net::Pcap::close($pcap_t);
     Close the packet capture device associated with descriptor $pcap_t.

*Net::Pcap::dispatch($pcap_t, $cnt, \&callback_fn, $user_data);*
     Collect $cnt packets and process them with callback function
     &callback_fn.  if $cnt is -1, all packets currently buffered are
     processed.  If $cnt is 0, process all packets until an error occurs.

*Net::Pcap::next($pcap_t, \%hdr);*
     Return the next available packet on the interface associated with
     packet descriptor $pcap_t.  Into the %hdr hash is stored the received
     packet header.  If not packet is available, the return value and
     header is undefined.

*Net::Pcap::compile($pcap_t, \$filter_t, $filter_str, $optimize, $netmask);*
     Compile the filter string contained in $filter_str and store it in
     $filter_t.  A description of the filter language can be found in the
     libpcap source code, or the manual page for tcpdump(8) .  The filter
     is optimized the filter if the $optimize variable is true.  The
     netmask of the network device must be specified in the $netmask
     parameter.  The function returns 0 if the compilation was successful,
     or -1 if there was a problem.

*Net::Pcap::setfilter($pcap_t, $filter_t);*
     Associate the compiled filter stored in $filter_t with the packet
     capture descriptor $pcap_t.

Savefile commands
-----------------

*Net::Pcap::dump_open($pcap_t, $filename);*
     Open a savefile for writing and return a descriptor for doing so.  If
     $filename is "-" data is written to standard output.  On error, the
     return value is undefined and *Net::Pcap::geterr()* can be used to
     retrieve the error text.

*Net::Pcap::dump($pcap_dumper_t, \%hdr, $pkt);*
     Dump the packet described by header %hdr and packet data $pkt to the
     savefile associated with $pcap_dumper_t.  The packet header has the
     same format as that passed to the *Net::Pcap::loop()* callback.

Net::Pcap::dump_close($pcap_dumper_t);
     Close the savefile associated with descriptor $pcap_dumper_t.

Status functions
----------------

Net::Pcap::datalink($pcap_t);
     Returns the link layer type associated with the currently open device.

Net::Pcap::snapshot($pcap_t);
     Returns the snapshot length (snaplen) specified in the call to
     *Net::Pcap::open_live()*.

Net::Pcap::is_swapped($pcap_t);
     This function returns true if the endianess of the currently open
     savefile is different from the endianess of the machine.

Net::Pcap::major_version($pcap_t);
     Return the major version number of the pcap library used to write the
     currently open savefile.

Net::Pcap::minor_version($pcap_t);
     Return the minor version of the pcap library used to write the
     currently open savefile.

*Net::Pcap::stats($pcap_t, \%stats);*
     Returns a hash containing information about the status of packet
     capture device $pcap_t.  The hash contains the following fields.

        * *ps_recv*

          The number of packets received by the packet capture software.

        * *ps_drop*

          The number of packets dropped by the packet capture software.

        * *ps_ifdrop*

          The number of packets dropped by the network interface.

Net::Pcap::file($pcap_t);
     Return the filehandle associated with a savefile opened with
     *Net::Pcap::open_offline()*.

Net::Pcap::fileno($pcap_t);
     Return the file number of the network device opened with
     *Net::Pcap::open_live()*.

Error handling
--------------

Net::Pcap::geterr($pcap_t);
     Return an error message for the last error associated with the packet
     capture device $pcap_t.

Net::Pcap::strerror($errno);
     Return a string describing error number $errno.

*Net::Pcap::perror($pcap_t, $prefix);*
     Print the text of the last error associated with descriptor $pcap_t on
     standard error, prefixed by $prefix.

LIMITATIONS
===========

   The following limitations apply to this version of *Net::Pcap*.

   * At present, only one callback function and user data scalar can be
     current at any time as they are both stored in global variables.

EXAMPLES
========

   See the 't' directory of the *Net::Pcap* distribution for examples on
using this module.

COPYRIGHT
=========

   Copyright (c) 1999-2000 Tim Potter. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

SEE ALSO
========

   pcap(3), tcpdump(8)

   The source code for libpcap is available from
*ftp://ftp.ee.lbl.gov/libpcap.tar.Z*

AUTHOR
======

   Tim Potter <tpot@frungy.org>


File: pm.info,  Node: Net/PcapUtils,  Next: Net/Ping,  Prev: Net/Pcap,  Up: Module List

Utility routines for Net::Pcap module
*************************************

NAME
====

   `Net::PcapUtils' - Utility routines for Net::Pcap module

SYNOPSIS
========

     require Net::Pcap 0.03;
     use Net::PcapUtils;

     # Call function for all packets received

     Net::PcapUtils::loop(\&callbackfn, [optional args]);

     # Return the next packet available on the interface

     ($pkt, %hdr) = Net::PcapUtils::next($pcap_t);

     # Open a network device for processing

     $pcap_t = Net::PcapUtils::open([optional args]);

DESCRIPTION
===========

   Net::PcapUtils is a module to sit in front of Net::Pcap in order to
hide some of the pcap(3) initialisation by providing sensible defaults.
This enables a programmer to easily write small, specific scripts for a
particular purpose without having to worry about too many details.

   The functions implemented in Net::PcapUtils are named after those in
Net::Pcap.  The loop function sits in a loop and executes a callback for
each packet received, while next retrieves the next packet from the
network device, and open returns an opened packet descriptor suitable for
use with other Net::Pcap routines.

Functions
---------

*Net::PcapUtils::loop(\&callback_fn, [ARG => value]);*
     Given a callback function and a list of optional named parameterss,
     open a network interface, configure it, and execute the callback
     function for each packet received on the interface.  If the SAVEFILE
     parameter is present, a saved file of that name will be opened for
     reading, else the network interface specified by the DEV parameter
     will be opened.  If no saved file or device is specified, the
     interface returned by Net::Pcap::lookupdev() is opened.

     The optional arguments are those which are normally passed to the
     pcap_open_live() function from the pcap(3) library.  Their defaults
     are given below.

          my %args = (
              SNAPLEN => 100,         # Num bytes to capture from packet
          	PROMISC => 1,           # Operate in promiscuous mode?
              TIMEOUT => 1000,        # Read timeout (ms)
              NUMPACKETS => -1,       # Pkts to read (-1 = loop forever)
              FILTER => '',           # Filter string
          	USERDATA => '',         # Passed as first arg to callback fn
          	SAVEFILE => '',         # Default save file
          	DEV => '',              # Network interface to open
              );

     Consult the documentation for the pcap(3) library for more details on
     the nature of these parameters.

     On error, this function returns an error string describing the error.
     An empty string is returned upon success.

*Net::PcapUtils::open([ARG => value]);*
     Return a packet capture descriptor.  The optional arguments passed to
     this function are the same as those which can be passed to
     Net::PcapUtils::loop().

     If the open() command was successful, it returns a reference to a
     packet capture descriptor, else a string containing an error message.

Net::PcapUtils::next($pcap_t);
     Return the next packet available on the interface specified by packet
     capture descriptor $pcap_t.  This may be obtained from the
     Net::PcapUtils::open() function, Net::Pcap::open_live() or
     Net::Pcap::open_offline().

EXAMPLE
=======

   The following script prints a message for each IP packet received.

     #!/usr/bin/perl -w

     use strict;
     use Net::PcapUtils;

     sub process_pkt {
         print("packet\n");
     }

     Net::PcapUtils::loop(\&process_pkt, FILTER => 'ip');

SEE ALSO
========

   The `Net::Pcap' module for XS bindings to the `pcap(3)' library.

   The pcap library is available from ftp://ftp.ee.lbl.gov/libpcap.tar.Z

COPYRIGHT
=========

     Copyright (c) 1995,1996,1997,1998,1999 ANU and CSIRO on behalf of
     the participants in the CRC for Advanced Computational Systems
     ('ACSys').

     ACSys makes this software and all associated data and documentation
     ('Software') available free of charge.  You may make copies of the
     Software but you must include all of this notice on any copy.

     The Software was developed for research purposes and ACSys does not
     warrant that it is error free or fit for any purpose.  ACSys
     disclaims any liability for all claims, expenses, losses, damages
     and costs any user may incur as a result of using, copying or
     modifying the Software.

AUTHOR
======

   Tim Potter <tpot@acsys.anu.edu.au>


File: pm.info,  Node: Net/Ping,  Next: Net/Printer,  Prev: Net/PcapUtils,  Up: Module List

check a remote host for reachability
************************************

NAME
====

   Net::Ping - check a remote host for reachability

SYNOPSIS
========

     use Net::Ping;

     $p = Net::Ping->new();
     print "$host is alive.\n" if $p->ping($host);
     $p->close();

     $p = Net::Ping->new("icmp");
     foreach $host (@host_array)
     {
         print "$host is ";
         print "NOT " unless $p->ping($host, 2);
         print "reachable.\n";
         sleep(1);
     }
     $p->close();

     $p = Net::Ping->new("tcp", 2);
     while ($stop_time > time())
     {
         print "$host not reachable ", scalar(localtime()), "\n"
             unless $p->ping($host);
         sleep(300);
     }
     undef($p);

     # For backward compatibility
     print "$host is alive.\n" if pingecho($host);

DESCRIPTION
===========

   This module contains methods to test the reachability of remote hosts
on a network.  A ping object is first created with optional parameters, a
variable number of hosts may be pinged multiple times and then the
connection is closed.

   You may choose one of three different protocols to use for the ping.
With the "tcp" protocol the ping() method attempts to establish a
connection to the remote host's echo port.  If the connection is
successfully established, the remote host is considered reachable.  No
data is actually echoed.  This protocol does not require any special
privileges but has higher overhead than the other two protocols.

   Specifying the "udp" protocol causes the ping() method to send a udp
packet to the remote host's echo port.  If the echoed packet is received
from the remote host and the received packet contains the same data as the
packet that was sent, the remote host is considered reachable.  This
protocol does not require any special privileges.

   If the "icmp" protocol is specified, the ping() method sends an icmp
echo message to the remote host, which is what the UNIX ping program does.
If the echoed message is received from the remote host and the echoed
information is correct, the remote host is considered reachable.
Specifying the "icmp" protocol requires that the program be run as root or
that the program be setuid to root.

Functions
---------

Net::Ping->new([$proto [, $def_timeout [, $bytes]]]);
     Create a new ping object.  All of the parameters are optional.  $proto
     specifies the protocol to use when doing a ping.  The current choices
     are "tcp", "udp" or "icmp".  The default is "udp".

     If a default timeout ($def_timeout) in seconds is provided, it is used
     when a timeout is not given to the ping() method (below).  The timeout
     must be greater than 0 and the default, if not specified, is 5
     seconds.

     If the number of data bytes ($bytes) is given, that many data bytes
     are included in the ping packet sent to the remote host. The number of
     data bytes is ignored if the protocol is "tcp".  The minimum (and
     default) number of data bytes is 1 if the protocol is "udp" and 0
     otherwise.  The maximum number of data bytes that can be specified is
     1024.

$p->ping($host [, $timeout]);
     Ping the remote host and wait for a response.  $host can be either the
     hostname or the IP number of the remote host.  The optional timeout
     must be greater than 0 seconds and defaults to whatever was specified
     when the ping object was created.  If the hostname cannot be found or
     there is a problem with the IP number, undef is returned.  Otherwise,
     1 is returned if the host is reachable and 0 if it is not.  For all
     practical purposes, undef and 0 and can be treated as the same case.

$p->close();
     Close the network connection for this ping object.  The network
     connection is also closed by "undef $p".  The network connection is
     automatically closed if the ping object goes out of scope (e.g. $p is
     local to a subroutine and you leave the subroutine).

pingecho($host [, $timeout]);
     To provide backward compatibility with the previous version of
     Net::Ping, a pingecho() subroutine is available with the same
     functionality as before.  pingecho() uses the tcp protocol.  The
     return values and parameters are the same as described for the ping()
     method.  This subroutine is obsolete and may be removed in a future
     version of Net::Ping.

WARNING
=======

   pingecho() or a ping object with the tcp protocol use alarm() to
implement the timeout.  So, don't use alarm() in your program while you
are using pingecho() or a ping object with the tcp protocol.  The udp and
icmp protocols do not use alarm() to implement the timeout.

NOTES
=====

   There will be less network overhead (and some efficiency in your
program) if you specify either the udp or the icmp protocol.  The tcp
protocol will generate 2.5 times or more traffic for each ping than either
udp or icmp.  If many hosts are pinged frequently, you may wish to
implement a small wait (e.g. 25ms or more) between each ping to avoid
flooding your network with packets.

   The icmp protocol requires that the program be run as root or that it
be setuid to root.  The tcp and udp protocols do not require special
privileges, but not all network devices implement the echo protocol for
tcp or udp.

   Local hosts should normally respond to pings within milliseconds.
However, on a very congested network it may take up to 3 seconds or longer
to receive an echo packet from the remote host.  If the timeout is set too
low under these conditions, it will appear that the remote host is not
reachable (which is almost the truth).

   Reachability doesn't necessarily mean that the remote host is actually
functioning beyond its ability to echo packets.

   Because of a lack of anything better, this module uses its own routines
to pack and unpack ICMP packets.  It would be better for a separate module
to be written which understands all of the different kinds of ICMP packets.


File: pm.info,  Node: Net/Printer,  Next: Net/RMI,  Prev: Net/Ping,  Up: Module List

Perl extension for direct-to-lpd printing.
******************************************

NAME
====

   Net::Printer - Perl extension for direct-to-lpd printing.

SYNOPSIS
========

     use Net::Printer;

     # Create new Printer Object
     $lineprinter = new Net::Printer(
     				  filename    => "/home/jdoe/myfile.txt",
     				  printer     => "lp",
     				  server      => "printserver",
     				  port        => 515,
     				  lineconvert => "YES"
     				  );
     # Print the file
     $result = $lineprinter->printfile();

     # Print a string
     $result =
       $lineprinter->printstring("Smoke me a kipper, I'll be back for breakfast.");

     # Get Queue Status
     $result = $lineprinter->queuestatus();

DESCRIPTION
===========

     Perl module for directly printing to a print server/printer without
     having to create a pipe to either lpr or lp.  This essentially
     mimics what the BSD LPR program does by connecting directly to the
     line printer printer port (almost always 515), and transmitting
     the data and control information to the print server.

     Please note that this module only talks to print servers that
     speak BSD.  It will not talk to printers using SMB or SysV unless
     they are set up as BSD printers.

Parameters
----------

     filename    - [optional] absolute path to the file you wish to print.

     printer     - [optional] Name of the printer you wish to print to.
                   Default "lp".
     
     server      - [optional] Name of the server that is running
                   lpd/lpsched.  Default "localhost".

     port        - [optional] The port you wish to connect to.
                   Default "515".
     
     lineconvert - [optional] Perform LF -> LF/CR translation.
                   Default "NO"

Functions
---------

     I<printfile> prints a specified file to the printer.  Returns a 1 on
     success, otherwise returns a string containing the error.

     I<printstring> prints a specified string to the printer as if it
     were a complete file  Returns a 1 on success, otherwise returns a
     string containing the error.

     I<queuestatus> returns the current status of the print queue.  I
     recommend waiting a short period of time between printing and
     issueing a queuestatus to give your spooler a chance to do it's
     thing.  5 seconds tends to work for me.

NOTES
=====

     When printing text, if you have the infamous "stair-stepping"
     problem, try setting lineconvert to "YES".  This should, in most
     cases, rectify the problem.

     Running with the -w option will cause the interpreter to complain
     about a couple of sprintf statements.  These can be safely ignored.

AUTHOR
======

   C. M. Fuhrman, cfuhrman@tfcci.com

SEE ALSO
========

   Socket, lpr(1), lp(1), perl(1).


File: pm.info,  Node: Net/RMI,  Next: Net/RMI/Client,  Prev: Net/Printer,  Up: Module List

Perl Remote Method Invocation (RMI) base class and utilities.
*************************************************************

NAME
====

   Net::RMI - Perl Remote Method Invocation (RMI) base class and utilities.

SYNOPSIS
========

     $d = serialize(\%sourceData);

     %destinationData = %{ deserialize($d) };

DESCRIPTION
===========

   This is the base class for Perl RMI. It provided some basic methods
common to both the client and server, and provides for data serialization.

METHODS
=======

set
     Sets an object's parameter to the specified value.

          Parameters: the parameter's name and value.
          Returns: nothing.

get
     Gets an object's parameter value.

          Parameters: the parameter's name.
          Returns: the parameter's value.

stripEOLN
     Removes a SINGLE traling 0x0A (LF) character from the end of a scalar.

          Parameters: a scalar.
          Returns: a scalar.

serialize
     Serializes an arbitrarily deep (or shallow for that matter) Perl data
     structure into a scalar.

          Parameter: a reference to a scalar, array, or hash.
          Returns: a scalar containing the serialized data.

deserialize
     Converts a scalar containing serialized data back into the data
     structures it represents.

          Parameters: a scalar containing the serialized data.
          Returns: a reference to a scalar, array, or hash.

SEE ALSO
========

   *Note Net/RMI/Server: Net/RMI/Server,, and *Note Net/RMI/Client:
Net/RMI/Client,.

AUTHOR
======

   Stephen Pandich, pandich@yahoo.com

   <a HREF="mailto:pandich@yahoo.com">Contact the Author</a>


File: pm.info,  Node: Net/RMI/Client,  Next: Net/RMI/Server,  Prev: Net/RMI,  Up: Module List

Perl client-side extension for Remote Method Invocation (RMI).
**************************************************************

NAME
====

   Net::RMI::Client - Perl client-side extension for Remote Method
Invocation (RMI).

SYNOPSIS
========

     use Net::RMI::Client;

     # Initialize the client
     @servers = qw(localhost);
     $client = new Net::RMI::Client(@servers);

     # Refresh it's function list.
     $client->pollAllServers();

     $result = $client->RM_someFunction(@someParameters));

DESCRIPTION
===========

   The client portion of Net::RMI, contains the methods neccessary to find
and invoke remote methods. Remote methods can be invoked explicitly via
the `$client-'RM_someFunction> or implicitly via a more subtly mechanism:

     sub AUTOLOAD {
     	my $function = $AUTOLOAD;
     	$function =~ s/^.+::(.+)$/RM_$1/;
     	return $client->$function(@_);
     }

     someUnusedFunctionName(@someParameters);

   As the AUTOLOAD function will catch this attempt, and forward it to the
Net::RMI::Client instance (in this example called $client).

METHODS
=======

AUTOLOAD
     This function looks for all functions called that begin with "RM_".
     It then attempt to invoke those methods remotely, by taking all text
     after the "RM_" and using it as the remote function name.

          Parameters: none.
          Returns: the results of the RMI.

new
     The new method creates a new RMI client and defines its initial list
     of RMI method servers.

          Parameters: a list of method servers.
          Returns: a new instance.

addServer
     Adds one or more method servers to the list of servers for this
     client.

          Parameters: a list of method servers.
          Returns: nothing.

addServerFunction
     Adds a specific server, function name pair to the list of available
     remote methods for this client.

          Parameters: a server name and port, function name, function's
          	parameter list and return-type.
          Returns: nothing.

getFunction
     Gets a specific server, function name pair based on function name.
     If multiple servers provide a function with the same name, they are
     picked in round-robin fashion.

          Parameters: the function name.
          Returns: the method server's name and port, the function's
          	parameter list and return-type.

refresh
     An alias for pollAllServers.

     (See Below.)

pollAllServers
     Iterates over all method-servers for this client and retrieves the
     information about all functions available on those servers.

          Parameters: none.
          Returns: nothing.

pollServer
     Retrieves all information, including function parameters and
     return-type, for all functions on a specific method-server.

          Parameters: the method-server's name and port.
          Returns: nothing.

SEE ALSO
========

   *Note Net/RMI: Net/RMI,, and *Note Net/RMI/Server: Net/RMI/Server,.

AUTHOR
======

   Stephen Pandich, pandich@yahoo.com

   <a HREF="mailto:pandich@yahoo.com">Contact the Author</a>


File: pm.info,  Node: Net/RMI/Server,  Next: Net/RRP,  Prev: Net/RMI/Client,  Up: Module List

Perl server-side extension for Remote Method Invocation (RMI).
**************************************************************

NAME
====

   Net::RMI::Server - Perl server-side extension for Remote Method
Invocation (RMI).

SYNOPSIS
========

     use Net::RMI::Server;

     $s = new Net::RMI::Server ||
     	die "Error: could not create object.\n";

     sub add2Numbers ($$) {
     	my ($n1, $n2) = @_;
     	return $n1 + $n2;
     }

     $function = "add2Numbers";
     $s->registerFunction($function, \&$function, ['$', '$'], '$');

     $s->listen();

DESCRIPTION
===========

   The server portion of Net::RMI, contains the methods for registering
and serving remotely invoked methods.

   Functions may only receive scalars or references. Complex data types
(i.e., arrays and hashes), must be passed by reference. Scalars, may also
be optionally passed by reference.

   Functions may only return scalars or references. Complex data types
(i.e., arrays and hashes), must be return as a reference. Scalars, may
also be optionally returned as a reference.

METHODS
=======

new
     Creates a new method-server.

          Parameters: none.
          Returns: a new instance of this class.

listen
     Listens forever for remote method requests.

          Parameters: none.
          Returns: never returns.

getFunction
     Returns a pointer to the function referenced by the function name.

          Parameters: the function's name.
          Returns: a reference to the function code.

getFunctionInfo
     Returns the "meta-information" about the function reference by the
     function name.

          Parameters: the function's name.
          Returns: the function's parameter list and return-type.

registerFunction
     Register's a local method with this remote-method server.

          Parameters: the function's name, code, parameter list and
          	return-list.
          Returns: nothing.

listFunctions
          Parameters: none.
          Returns: a list of functions registered to this method-server instance.

REAPER
     Reaps the zombie children, stolen with thanks from the Perl Cookbook.

          Parameters: none.
          Returns: nothing.

SEE ALSO
========

   *Note Net/RMI: Net/RMI,, and *Note Net/RMI/Client: Net/RMI/Client,.

AUTHOR
======

   Stephen Pandich, pandich@yahoo.com

   <a HREF="mailto:pandich@yahoo.com">Contact the Author</a>


File: pm.info,  Node: Net/RRP,  Next: Net/RRP/Codec,  Prev: Net/RMI/Server,  Up: Module List

there are file for RRP protocol and operations.
***********************************************

NAME
====

   Net::RRP - there are file for RRP protocol and operations.

SYNOPSIS
========

     use IO::Socket::SSL;

     use Net::RRP::Protocol;
     use Net::RRP::Request::Add;
     use Net::RRP::Entity::Domain;

     my $socket = new IO::Socket::SSL ( ... );
     my $protocol = new Net::RRP::Protocol ( socket => $socket );

     $protocol->getHello();

     my $entity   = new Net::RRP::Entity::Domain();
     $entity->setAttribute ( 'DomainName' => 'test.ru' );
     $entity->setAttribute ( 'NameServer' => [ 'ns1.test.ru', 'ns2.test.ru' ] );

     my $request  = new Net::RRP::Request::Add();
     $request->setEntity ( $entity );
     $request->setOption ( Period => 10 );

     $protocol->sendRequest ( $request );
     my $response = $protocol->getResponse ();

     die unless $request->isSuccessResponse ( $response );

DESCRIPTION
===========

   Net::RRP - there are file for RRP protocol and operations.

AUTHOR AND COPYRIGHT
====================

     Net::RRP (C) Zenon N.S.P., Michael Kulakov, 2000
                  125124, 19, 1-st Jamskogo polja st,
                  Moscow, Russian Federation

     mkul@cpan.org

     All rights reserved.

     You may distribute this package under the terms of either the GNU
     General Public License or the Artistic License, as specified in the
     Perl README file.

SEE ALSO
========

   RFC 2832, `Net::RRP::Codec(3)' in this node, `Net::RRP::Protocol(3)' in
this node, `Net::RRP::Request(3)' in this node, `Net::RRP::Entity(3)' in
this node, `Net::RRP::Response(3)' in this node, `Net::RRP::Toolkit(3)' in
this node, `Net::RRP::Entity::Domain(3)' in this node,
`Net::RRP::Entity::NameServer(3)' in this node,
`Net::RRP::Request::Add(3)' in this node, `Net::RRP::Request::Check(3)' in
this node, `Net::RRP::Request::Del(3)' in this node,
`Net::RRP::Request::Describe(3)' in this node, `Net::RRP::Request::Mod(3)'
in this node, `Net::RRP::Request::Quit(3)' in this node,
`Net::RRP::Request::Session(3)' in this node,
`Net::RRP::Request::Status(3)' in this node,
`Net::RRP::Request::Transfer(3)' in this node,
`Net::RRP::Request::Renew(3)' in this node, `Net::RRP::Response::n200(3)'
in this node, `Net::RRP::Response::n210(3)' in this node,
`Net::RRP::Response::n211(3)' in this node, `Net::RRP::Response::n212(3)'
in this node, `Net::RRP::Response::n213(3)' in this node,
`Net::RRP::Response::n220(3)' in this node, `Net::RRP::Response::n420(3)'
in this node, `Net::RRP::Response::n421(3)' in this node,
`Net::RRP::Response::n500(3)' in this node, `Net::RRP::Response::n501(3)'
in this node, `Net::RRP::Response::n502(3)' in this node,
`Net::RRP::Response::n503(3)' in this node, `Net::RRP::Response::n504(3)'
in this node, `Net::RRP::Response::n505(3)' in this node,
`Net::RRP::Response::n506(3)' in this node, `Net::RRP::Response::n507(3)'
in this node, `Net::RRP::Response::n508(3)' in this node,
`Net::RRP::Response::n509(3)' in this node, `Net::RRP::Response::n520(3)'
in this node, `Net::RRP::Response::n521(3)' in this node,
`Net::RRP::Response::n530(3)' in this node, `Net::RRP::Response::n531(3)'
in this node, `Net::RRP::Response::n532(3)' in this node,
`Net::RRP::Response::n533(3)' in this node, `Net::RRP::Response::n534(3)'
in this node, `Net::RRP::Response::n535(3)' in this node,
`Net::RRP::Response::n536(3)' in this node, `Net::RRP::Response::n540(3)'
in this node, `Net::RRP::Response::n541(3)' in this node,
`Net::RRP::Response::n542(3)' in this node, `Net::RRP::Response::n543(3)'
in this node, `Net::RRP::Response::n544(3)' in this node,
`Net::RRP::Response::n545(3)' in this node, `Net::RRP::Response::n546(3)'
in this node, `Net::RRP::Response::n547(3)' in this node,
`Net::RRP::Response::n548(3)' in this node, `Net::RRP::Response::n549(3)'
in this node, `Net::RRP::Response::n550(3)' in this node,
`Net::RRP::Response::n551(3)' in this node, `Net::RRP::Response::n552(3)'
in this node, `Net::RRP::Response::n553(3)' in this node,
`Net::RRP::Response::n554(3)' in this node, `Net::RRP::Response::n555(3)'
in this node, `Net::RRP::Response::n556(3)' in this node


File: pm.info,  Node: Net/RRP/Codec,  Next: Net/RRP/Entity,  Prev: Net/RRP,  Up: Module List

codec class for serialization/deserialization of Net::RRP::Request/Response
***************************************************************************

NAME
====

   Net::RRP::Codec - codec class for serialization/deserialization of
Net::RRP::Request/Response

SYNOPSIS
========

     use Net::RRP::RRP::Codec;
     my $codec = new Net::RRP::Codec();

DESCRIPTION
===========

   Net::RRP::Codec - codec class for serialization/deserialization of
Net::RRP::Request/Response

new
---

   Constructor of this class.

   Example:

     use Net::RRP::RRP::Codec;
     my $codec = new Net::RRP::Codec();

decodeRequest
-------------

   This method get the buffer with unparsed rrp request && decode it and
return Net::RRP::Request object.  The real return object is a instance of
Net::RRP::Request::$requestName class. This method dynamic loads required
class ( package ). Next, we a parse the Entity part of RRP request and
construct the instance of Net::RRP::Entity::$entityName class ( with
dynamic loading of this class ) and add entity attributes to this object.
After this, parser process the rrp request options and add it's to request
object. When all done, method return a constructed rrp request object.
This method say throw() at any errors.

   Example:

     my $request = $codec->decodeRequest ( $buffer );



   This method encode the rrp request to buffer for send it's to any
stream.

   Example:

     my $buffer = $codec->encodeRequest ( $request );

decodeResponse
--------------

   This method constructs the instance of Net::RRP::Response::n$NNN class
from input buffer, where the $NNN is a response number ( the
Net::RRP::Response::n$NNN loads dynamic ). This method say throw() at any
errors;

   Example: my $response = $codec->decodeResponse ( $buffer );

encodeResponse
--------------

   This method get the instance of Net::RRP::Response child class and
encodes it's to rrp format.

   Example:

     my $buffer = $codec->encodeResponse ( $response );

AUTHOR AND COPYRIGHT
====================

     Net::RRP::Codec (C) Michael Kulakov, Zenon N.S.P. 2000
                         125124, 19, 1-st Jamskogo polja st,
                         Moscow, Russian Federation

     mkul@cpan.org

     All rights reserved.

     You may distribute this package under the terms of either the GNU
     General Public License or the Artistic License, as specified in the
     Perl README file.

SEE ALSO
========

   `Net::RRP::Request(3)' in this node, `Net::RRP::Response(3)' in this
node, `Net::RRP::Entity(3)' in this node, RFC 2832


