This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Bio/SeqIO/largefasta,  Next: Bio/SeqIO/pir,  Prev: Bio/SeqIO/genbank,  Up: Module List

method i/o on very large fasta sequence files
*********************************************

NAME
====

   Bio::SeqIO::largefasta - method i/o on very large fasta sequence files

SYNOPSIS
========

   Do not use this module directly.  Use it via the Bio::SeqIO class.

DESCRIPTION
===========

   This object can transform Bio::Seq objects to and from fasta flat file
databases.

   This module handles very large sequence files by using the *Note
Bio/Seq/LargePrimarySeq: Bio/Seq/LargePrimarySeq, module to store all the
sequence data in a file.  This can be a problem if you have limited disk
space on your computer because this will effectively cause 2 copies of the
sequence file to reside on disk for the life of the *Note
Bio/Seq/LargePrimarySeq: Bio/Seq/LargePrimarySeq, object.  The default
location for this is specified by the *Note File/Spec: File/Spec,->tmpdir
routine which is usually /tmp on UNIX.  If a sequence file is larger than
the swap space (capacity of the /tmp dir) this could cause problems for
the machine.  It is possible to set the directory where the temporary file
is located by adding the following line to your code BEFORE calling
next_seq.

   $Bio::Seq::LargePrimarySeq::DEFAULT_TEMP_DIR = 'newdir';

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org            - General discussion
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHORS - Jason Stajich
=======================

   Email: jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

next_seq
--------

     Title   : next_seq
     Usage   : $seq = $stream->next_seq()
     Function: returns the next sequence in the stream
     Returns : Bio::Seq object
     Args    : NONE

next_primary_seq
----------------

     Title   : next_seq
     Usage   : $seq = $stream->next_seq()
     Function: returns the next sequence in the stream
     Returns : Bio::PrimarySeq object
     Args    : NONE

write_seq
---------

     Title   : write_seq
     Usage   : $stream->write_seq(@seq)
     Function: writes the $seq object into the stream
     Returns : 1 for success and 0 for error
     Args    : Bio::Seq object


File: pm.info,  Node: Bio/SeqIO/pir,  Next: Bio/SeqIO/raw,  Prev: Bio/SeqIO/largefasta,  Up: Module List

PIR sequence input/output stream
********************************

NAME
====

   Bio::SeqIO::pir - PIR sequence input/output stream

SYNOPSIS
========

   Do not use this module directly.  Use it via the Bio::SeqIO class.

DESCRIPTION
===========

   This object can transform Bio::Seq objects to and from fasta flat file
databases.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                 - General discussion
     http://www.bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHORS
=======

   Aaron Mackey <amackey@virginia.edu> Lincoln Stein <lstein@cshl.org>

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

next_seq
--------

     Title   : next_seq
     Usage   : $seq = $stream->next_seq()
     Function: returns the next sequence in the stream
     Returns : Bio::Seq object
     Args    :

write_seq
---------

     Title   : write_seq
     Usage   : $stream->write_seq(@seq)
     Function: writes the $seq object into the stream
     Returns : 1 for success and 0 for error
     Args    : Bio::Seq object


File: pm.info,  Node: Bio/SeqIO/raw,  Next: Bio/SeqIO/scf,  Prev: Bio/SeqIO/pir,  Up: Module List

raw sequence file input/output stream
*************************************

NAME
====

   Bio::SeqIO::raw - raw sequence file input/output stream

SYNOPSIS
========

   Do not use this module directly.  Use it via the *Note Bio/SeqIO:
Bio/SeqIO, class.

DESCRIPTION
===========

   This object can transform Bio::Seq objects to and from raw flat file
databases.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                 - General discussion
     http://www.bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHORS
=======

     Ewan Birney  <birney@ebi.ac.uk>
     Lincoln Stein <lstein@cshl.org>

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

next_seq
--------

     Title   : next_seq
     Usage   : $seq = $stream->next_seq()
     Function: returns the next sequence in the stream
     Returns : Bio::Seq object
     Args    :

write_seq
---------

     Title   : write_seq
     Usage   : $stream->write_seq($seq)
     Function: writes the $seq object into the stream
     Returns : 1 for success and 0 for error
     Args    : Bio::Seq object


File: pm.info,  Node: Bio/SeqIO/scf,  Next: Bio/SeqIO/swiss,  Prev: Bio/SeqIO/raw,  Up: Module List

SCF sequence input/output stream
********************************

NAME
====

   Bio::SeqIO::scf - SCF sequence input/output stream

SYNOPSIS
========

   Do not use this module directly.  Use it via the *Note Bio/SeqIO:
Bio/SeqIO, class.

DESCRIPTION
===========

   This object can transform Bio::Seq objects to and from SCF trace files.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                 - General discussion
     http://www.bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHORS
=======

     Aaron Mackey
     Lincoln Stein lstein@cshl.org

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

next_seq
--------

     Title   : next_seq
     Usage   : $seq = $stream->next_seq()
     Function: returns the next sequence in the stream
     Returns : Bio::Seq object
     Args    :

write_seq
---------

     Title   : write_seq
     Usage   : $stream->write_seq(@seq)
     Function: writes the $seq object into the stream
     Returns : 1 for success and 0 for error
     Args    : Bio::Seq object


File: pm.info,  Node: Bio/SeqIO/swiss,  Next: Bio/SeqUtils,  Prev: Bio/SeqIO/scf,  Up: Module List

Swissprot sequence input/output stream
**************************************

NAME
====

   Bio::SeqIO::swiss - Swissprot sequence input/output stream

SYNOPSIS
========

   It is probably best not to use this object directly, but rather go
through the SeqIO handler system. Go:

     $stream = Bio::SeqIO->new(-file => $filename, -format => 'swiss');

     while ( my $seq = $stream->next_seq() ) {
     	# do something with $seq
     }

DESCRIPTION
===========

   This object can transform Bio::Seq objects to and from swissprot flat
file databases.

   There is alot of flexibility here about how to dump things which I need
to document fully.

Optional functions
------------------

_show_dna()
     (output only) shows the dna or not

_post_sort()
     (output only) provides a sorting func which is applied to the
     FTHelpers before printing

_id_generation_func()
     This is function which is called as

          print "ID   ", $func($seq), "\n";

     To generate the ID line. If it is not there, it generates a sensible
     ID line using a number of tools.

          =back

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Elia Stupka
====================

   Email elia@ebi.ac.uk

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

next_seq
--------

     Title   : next_seq
     Usage   : $seq = $stream->next_seq()
     Function: returns the next sequence in the stream
     Returns : Bio::Seq object
     Args    :

write_seq
---------

     Title   : write_seq
     Usage   : $stream->write_seq($seq)
     Function: writes the $seq object (must be seq) to the stream
     Returns : 1 for success and 0 for error
     Args    : Bio::Seq

_generateCRCTable
-----------------

     Title   : _generateCRCTable
     Usage   :
     Function:
     Example :
     Returns :
     Args    :

_crc32
------

     Title   : _crc32
     Usage   :
     Function:
     Example :
     Returns :
     Args    :

_print_swissprot_FTHelper
-------------------------

     Title   : _print_swissprot_FTHelper
     Usage   :
     Function:
     Example :
     Returns :
     Args    :

_read_swissprot_References
--------------------------

     Title   : _read_swissprot_References
     Usage   :
     Function: Reads references from swissprot format. Internal function really
     Example :
     Returns :
     Args    :

_read_swissprot_Species
-----------------------

     Title   : _read_swissprot_Species
     Usage   :
     Function: Reads the swissprot Organism species and classification
               lines.
     Example :
     Returns : A Bio::Species object
     Args    :

_filehandle
-----------

     Title   : _filehandle
     Usage   : $obj->_filehandle($newval)
     Function:
     Example :
     Returns : value of _filehandle
     Args    : newvalue (optional)

_read_FTHelper_swissprot
------------------------

     Title   : _read_FTHelper_swissprot
     Usage   : _read_FTHelper_swissprot(\$buffer)
     Function: reads the next FT key line
     Example :
     Returns : Bio::SeqIO::FTHelper object
     Args    : filehandle and reference to a scalar

_write_line_swissprot
---------------------

     Title   : _write_line_swissprot
     Usage   :
     Function: internal function
     Example :
     Returns :
     Args    :

_write_line_swissprot_regex
---------------------------

     Title   : _write_line_swissprot_regex
     Usage   :
     Function: internal function for writing lines of specified
               length, with different first and the next line
               left hand headers and split at specific points in the
               text
     Example :
     Returns : nothing
     Args    : file handle, first header, second header, text-line, regex for line breaks, total line length

_post_sort
----------

     Title   : _post_sort
     Usage   : $obj->_post_sort($newval)
     Function:
     Returns : value of _post_sort
     Args    : newvalue (optional)

_show_dna
---------

     Title   : _show_dna
     Usage   : $obj->_show_dna($newval)
     Function:
     Returns : value of _show_dna
     Args    : newvalue (optional)

_id_generation_func
-------------------

     Title   : _id_generation_func
     Usage   : $obj->_id_generation_func($newval)
     Function:
     Returns : value of _id_generation_func
     Args    : newvalue (optional)

_ac_generation_func
-------------------

     Title   : _ac_generation_func
     Usage   : $obj->_ac_generation_func($newval)
     Function:
     Returns : value of _ac_generation_func
     Args    : newvalue (optional)

_sv_generation_func
-------------------

     Title   : _sv_generation_func
     Usage   : $obj->_sv_generation_func($newval)
     Function:
     Returns : value of _sv_generation_func
     Args    : newvalue (optional)

_kw_generation_func
-------------------

     Title   : _kw_generation_func
     Usage   : $obj->_kw_generation_func($newval)
     Function:
     Returns : value of _kw_generation_func
     Args    : newvalue (optional)


File: pm.info,  Node: Bio/SeqUtils,  Next: Bio/SimpleAlign,  Prev: Bio/SeqIO/swiss,  Up: Module List

Additional methods for PrimarySeq objects
*****************************************

NAME
====

   Bio::SeqUtils - Additional methods for PrimarySeq objects

SYNOPSIS
========

     # get a Bio::PrimarySeqI compliant object, $seq, somehow
     $util = new Bio::SeqUtils;
     $poplypeptide_3char = $util->seq3($seq);
     #or
     $poplypeptide_3char = Bio::SeqUtils->seq3($seq);

     #set the sequence string (stored in one char code in the object)
     Bio::SeqUtils->seq3($seq, $poplypeptide_3char);

DESCRIPTION
===========

   This class is a holder of methods that work on *Note Bio/PrimarySeqI:
Bio/PrimarySeqI, compliant sequence objects, e.g. *Note Bio/PrimarySeq:
Bio/PrimarySeq, and *Note Bio/Seq: Bio/Seq,. These methods are not part of
the *Note Bio/PrimarySeqI: Bio/PrimarySeqI, interface and should in
general not essential to the primary function of sequence objects. If you
are thinking of adding essential functions, it might be better to create
your own sequence class.

   The methods take as their first argument a sequence object. It is
possible to use methods without first creating a SeqUtils object, i.e. use
it as an anonymous hash.

   The first two methodsgive out or read in protein sequences coded in
three letter IUPAC amino acid codes.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Heikki Lehvaslaiho
===========================

   Email:  heikki@ebi.ac.uk Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

seq3
----

     Title   : seq3
     Usage   : $string = Bio::SeqUtils->seq3($seq)
     Function:

     Read only method that returns the amino acid sequence as a
     string of three letter codes. moltype has to be
     'protein'. Output follows the IUPAC standard plus 'Ter' for
     terminator. Any unknown character, including the default
     unknown character 'X', is changed into 'Xaa'. A noncoded
     aminoacid selenocystein is recognized (Sel, U).

     Returns : A scalar
     Args    : character used for stop in the protein seqence optional,
               defaults to '*' string used to separate the output amino
               acid codes, optional, defaults to ''

seq3in
------

     Title   : seq3in
     Usage   : $string = Bio::SeqUtils->seq3in($seq, 'MetGlyTer')
     Function:

     Read only method that returns the amino acid sequence as a
     string of three letter codes. moltype has to be
     'protein'. Output follows the IUPAC standard plus 'Ter' for
     terminator. Any unknown character, including the default
     unknown character 'X', is changed into 'Xaa'

     Returns : Bio::PrimarySeq object;
     Args    : character to be used for stop in the protein seqence,
                  optional, defaults to '*'
               character to be used for unknown in the protein seqence,
                  optional, defaults to 'X'
               string used to separate the output amino acid codes,
                  optional, defaults to ''


File: pm.info,  Node: Bio/SimpleAlign,  Next: Bio/Species,  Prev: Bio/SeqUtils,  Up: Module List

Multiple alignments held as a set of sequences
**********************************************

NAME
====

   SimpleAlign - Multiple alignments held as a set of sequences

SYNOPSIS
========

     $aln = new Bio::SimpleAlign;

     $aln->read_MSF(\*STDIN);

     $aln->write_fasta(\*STDOUT);

INSTALLATION
============

   This module is included with the central Bioperl distribution:

     http://bio.perl.org/Core/Latest
     ftp://bio.perl.org/pub/DIST

   Follow the installation instructions included in the README file.

DESCRIPTION
===========

   SimpleAlign handles multiple alignments of sequences. It is very
permissive of types (it wont insist on things being all same length etc):
really it is a SequenceSet explicitly held in memory with a whole series of
built in manipulations and especially file format systems for read/writing
alignments.

   SimpleAlign basically views an alignment as an immutable block of text.
SimpleAlign *is not* the object to be using if you want to perform complex
alignment alignment manipulations.  These functions are much better done
by UnivAln by Georg Fuellen.

   However for lightweight display/formatting and minimal manipulation
(e.g. removiung all-gaps columns) - this is the one to use.

   Tricky concepts. SimpleAlign expects name,start,end to be 'unique' in
the alignment, and this is the key for the internal hashes.
(name,start,end is abreviated nse in the code). However, in many cases
people don't want the name/start-end to be displayed: either multiple
names in an alignment or names specific to the alignment (ROA1_HUMAN_1,
ROA1_HUMAN_2 etc). These names are called 'displayname', and generally is
what is used to print out the alignment. They default to name/start-end

   The SimpleAlign Module came from Ewan Birney's Align module

PROGRESS
========

   SimpleAlign is being slowly converted to bioperl coding standards,
mainly by Ewan.

Use Bio::Root::Object - done
Use proper exceptions - done
Use hashed constructor - not done!
FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules.  Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR
======

   Ewan Birney, birney@sanger.ac.uk

SEE ALSO
========

     Bio::LocatableSeq.pm

     http://bio.perl.org/Projects/modules.html  - Online module documentation
     http://bio.perl.org/Projects/SeqAlign/     - Bioperl sequence alignment project
     http://bio.perl.org/                       - Bioperl Project Homepage

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

addSeq
------

     Title     : addSeq
     Usage     : $myalign->addSeq($newseq);
               :
               :
     Function  : Adds another sequence to the alignment
               : *does not* align it - just adds it to the
               : hashes
               :
     Returns   : nothing
     Argument  :

column_from_residue_number
--------------------------

     Title   : column_from_residue_number
     Usage   : $col = $ali->column_from_residue_number( $seqname, $resnumber)
     Function:
        This function gives the position in the alignment (i.e. column number) of
        the given residue number in the sequence with the given name. For example,
        for the alignment

     Seq1/91-97 AC..DEF.GH
     Seq2/24-30 ACGG.RTY..
     Seq3/43-51 AC.DDEFGHI

     column_from_residue_number( "Seq1", 94 ) returns 5.
     column_from_residue_number( "Seq2", 25 ) returns 2.
     column_from_residue_number( "Seq3", 50 ) returns 9.

     An exception is thrown if the residue number would lie outside the length
     of the aligment (e.g. column_from_residue_number( "Seq2", 22 )

     Returns :
        A column number for the postion in the alignment of the given residue in the given
             sequence (1 = first column)
     Args    :
        A sequence name (not a name/start-end)
        A residue number in the whole sequence (not just that segment of it in the alignment)

consensus_string
----------------

     Title     : consensus_string
     Usage     : $str = $ali->consensus_string($threshold_percent)
     Function  : Makes a consensus
     Returns   :
     Argument  : Optional treshold ranging from 0 to 100.  If consensus residue appears in
     		fewer than threshold % of the sequences at a given location
     		consensus_string will return a "?" at that location rather than the consensus
     		letter. (Default value = 0%)

consensus_aa
------------

     Title     : consensus_aa
     Usage     : $consensus_residue = $ali->consensus_aa($residue_number, $threshold_percent)
     Function  : Makes a consensus
     Returns   :
     Argument  : Optional treshold ranging from 0 to 100.  If consensus residue appears in
     		fewer than threshold % of the sequences at the specified location
     		consensus_string will return a "?"  rather than the consensus
     		letter. (Default value = 0%)

each_alphabetically
-------------------

     Title     : each_alphabetically
     Usage     : foreach $seq ( $ali->each_alphabetically() )
               :
               :
     Function  : returns an array of sequence object sorted
               : alphabetically by name and then by start point
               :
               : Does not change the order of the alignment
     Returns   :
     Argument  :

eachSeq
-------

     Title     : eachSeq
     Usage     : foreach $seq ( $align->eachSeq() )
               :
               :
     Function  : gets an array of Seq objects from the
               : alignment
               :
               :
     Returns   : an array
     Argument  : nothing

eachSeqWithId
-------------

     Title     : eachSeqWithId
     Usage     : foreach $seq ( $align->eachSeqWithName() )
               :
               :
     Function  : gets an array of Seq objects from the
               : alignment, the contents being those sequences
               : with the given name (there may be more than one
               :
     Returns   : an array
     Argument  : nothing

id
--

     Title     : id
     Usage     : $myalign->id("Ig")
     Function  : Gets/sets the id field of the alignment
               :
     Returns   : An id string
     Argument  : An id string (optional)

is_flush
--------

     Title     : is_flush
     Usage     : if( $ali->is_flush() )
               :
               :
     Function  : Tells you whether the alignment
               : is flush, ie all of the same length
               :
               :
     Returns   : 1 or 0
     Argument  :

length_aln
----------

     Title     : length_aln()
     Usage     : $len = $ali->length_aln()
               :
               :
     Function  : returns the maximum length of the alignment.
               : To be sure the alignment is a block, use is_flush
               :
               :
     Returns   :
     Argument  :

map_chars
---------

     Title     : map_chars
     Usage     : $ali->map_chars('\.','-')
               :
               :
     Function  : does a s/$arg1/$arg2/ on
               : the sequences. Useful for
               : gap characters
               :
               : Notice that the from (arg1) is interpretted
               : as a regex, so be careful about quoting meta
               : characters (eg $ali->map_chars('.','-') wont
               : do what you want)
     Returns   :
     Argument  :

no_residues
-----------

     Title     : no_residues
     Usage     : $no = $ali->no_residues
               :
               :
     Function  : number of residues in total
               : in the alignment
               :
               :
     Returns   :
     Argument  :

no_sequences
------------

     Title     : no_sequences
     Usage     : $depth = $ali->no_sequences
               :
               :
     Function  : number of sequence in the
               : sequence alignment
               :
               :
     Returns   :
     Argument  :

percentage_identity
-------------------

     Title   : percentage_identity
     Usage   : $id = $align->percentage_identity
     Function:
        The function uses a fast method to calculate the average percentage identity of the alignment
     Returns : The average percentage identity of the alignment
     Args    : None

purge
-----

     Title   : purge
     Usage   : $aln->purge(0.7);
     Function: removes sequences above whatever %id
     Example :
     Returns : An array of the removed sequences
     Arguments

     This function will grind on large alignments. Beware!

     (perhaps not ideally implemented)

read_fasta
----------

     Title     : read_fasta
     Usage     : $ali->read_fasta(\*INPUT)
               :
               :
     Function  : reads in a fasta formatted
               : file for an alignment
               :
               :
     Returns   :
     Argument  :

read_mase
---------

     Title     : read_mase
     Usage     : $ali->read_mase(\*INPUT)
               :
               :
     Function  : reads mase (seaview)
               : formatted alignments
               :
               :
     Returns   :
     Argument  :

read_MSF
--------

     Title   : read_MSF
     Usage   : $al->read_MSF(\*STDIN);
     Function: reads MSF formatted files. Tries to read *all* MSF
              It reads all non whitespace characters in the alignment
              area. For MSFs with weird gaps (eg ~~~) map them by using
              $al->map_chars('~','-');
     Example :
     Returns :
     Args    : filehandle

read_Pfam
---------

     Title     : read_Pfam
     Usage     : $ali->read_Pfam(\*INPUT)
               :
               :
     Function  : reads a Pfam formatted
               : Alignment (Mul format).
               : - this is the format used by Belvu
               :
     Returns   :
     Argument  :

read_Pfam_file
--------------

     Title     : read_Pfam_file
     Usage     : $ali->read_Pfam_file("thisfile");
               :
     Function  : opens a filename, reads
               : a Pfam (mul) formatted alignment
               :
               :
               :
     Returns   :
     Argument  :

read_Prodom
-----------

     Title   : read_Prodom
     Usage   : $ali->read_Prodom( $file )
     Function: Reads in a Prodom format alignment
     Returns :
        Args    : A filehandle glob or ref. to a filehandle object

read_selex
----------

     Title     : read_selex
     Usage     : $ali->read_selex(\*INPUT)
               :
               :
     Function  : reads selex (hmmer) format
               : alignments
               :
               :
     Returns   :
     Argument  :

read_stockholm
--------------

     Title     : read_stockholm
     Usage     : $ali->read_stockholm(\*INPUT)
               :
               :
     Function  : reads stockholm  format alignments
               :
               :
     Returns   :
     Argument  :

removeSeq
---------

     Title     : removeSeq
     Usage     : $aln->removeSeq($seq);
     Function  : removes a single sequence from an alignment

set_displayname_count
---------------------

     Title     : set_displayname_count
     Usage     : $ali->set_displayname_count
               :
               :
     Function  : sets the names to be name_#
               : where # is the number of times this
               : name has been used.
               :
     Returns   :
     Argument  :

set_displayname_flat
--------------------

     Title     : set_displayname_flat
     Usage     : $ali->set_displayname_flat()
               :
               :
     Function  : Makes all the sequences be displayed
               : as just their name, not name/start-end
               :
               :
     Returns   :
     Argument  :

set_displayname_normal
----------------------

     Title     : set_displayname_normal
     Usage     : $ali->set_displayname_normal()
               :
               :
     Function  : Makes all the sequences be displayed
               : as name/start-end
               :
               :
     Returns   :
     Argument  :

sort_alphabetically
-------------------

     Title     : sort_alphabetically
     Usage     : $ali->sort_alphabetically
               :
               :
     Function  : changes the order of the alignemnt
               : to alphabetical on name followed by
               : numerical by number
               :
     Returns   :
     Argument  :

uppercase
---------

     Title     : uppercase()
     Usage     : $ali->uppercase()
               :
               :
     Function  : Sets all the sequences
               : to uppercase
               :
               :
     Returns   :
     Argument  :

write_clustalw
--------------

     Title     : write_clustalw
     Usage     : $ali->write_clustalw
               :
               :
     Function  : writes a clustalw formatted
               : (.aln) file
               :
               :
     Returns   :
     Argument  :

write_fasta
-----------

     Title     : write_fasta
     Usage     : $ali->write_fasta(\*OUTPUT)
               :
               :
     Function  : writes a fasta formatted alignment
               :
     Returns   :
     Argument  : reference-to-glob to file or filehandle object

write_MSF
---------

     Title     : write_MSF
     Usage     : $ali->write_MSF(\*FH)
               :
               :
     Function  : writes MSF format output
               :
               :
               :
     Returns   :
     Argument  :

write_Pfam
----------

     Title     : write_Pfam
     Usage     : $ali->write_Pfam(\*OUTPUT)
               :
               :
     Function  : writes a Pfam/Mul formatted
               : file
               :
               :
     Returns   :
     Argument  :

write_selex
-----------

     Title     : write_selex
     Usage     : $ali->write_selex(\*OUTPUT)
               :
               :
     Function  : writes a selex (hmmer) formatted alignment
               :
     Returns   :
     Argument  : reference-to-glob to file or filehandle object


File: pm.info,  Node: Bio/Species,  Next: Bio/Tk/GO_Browser,  Prev: Bio/SimpleAlign,  Up: Module List

Generic species object
**********************

NAME
====

   Bio::Species - Generic species object

SYNOPSIS
========

     $species = Bio::Species->new(-classification => [@classification]);
                                     # Can also pass classification
                                     # array to new as below

     $species->classification(qw( sapiens Homo Hominidae
                                  Catarrhini Primates Eutheria
                                  Mammalia Vertebrata Chordata
                                  Metazoa Eukaryota ));

     $genus = $species->genus();

     $bi = $species->binomial();     # $bi is now "Homo sapiens"

     # For storing common name
     $species->common_name("human");

     # For storing subspecies
     $species->sub_species("accountant");

DESCRIPTION
===========

   Provides a very simple object for storing phylogenetic information.
The classification is stored in an array, which is a list of nodes in a
phylogenetic tree.  Access to getting and setting species and genus is
provided, but not to any of the other node types (eg: "phlum", "class",
"order", "family").  There's plenty of scope for making the model more
sophisticated, if this is ever needed.

   A methods are also provided for storing common names, and subspecies.

CONTACT
=======

   James Gilbert email *jgrg@sanger.ac.uk*

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

classification
--------------

     Title   : classification
     Usage   : $self->classification(@class_array);
               @classification = $self->classification();
     Function: Fills or returns the classifcation list in
               the object.  The array provided must be in
               the order SPECIES, GENUS ---> KINGDOM.
               Checks are made that species is in lower case,
               and all other elements are in title case.
     Example : $obj->classification(qw( sapiens Homo Hominidae
               Catarrhini Primates Eutheria Mammalia Vertebrata
               Chordata Metazoa Eukaryota));
     Returns : Classification array
     Args    : Classification array

common_name
-----------

     Title   : common_name
     Usage   : $self->common_name( $common_name );
               $common_name = $self->common_name();
     Function: Get or set the commonn name of the species
     Example : $self->common_name('human')
     Returns : The common name in a string
     Args    : String, which is the common name

species
-------

     Title   : species
     Usage   : $self->species( $species );
               $species = $self->species();
     Function: Get or set the scientific species name.  The species
               name must be in lower case.
     Example : $self->species( 'sapiens' );
     Returns : Scientific species name as string
     Args    : Scientific species name as string

genus
-----

     Title   : genus
     Usage   : $self->genus( $genus );
               $genus = $self->genus();
     Function: Get or set the scientific genus name.  The genus
               must be in title case.
     Example : $self->genus( 'Homo' );
     Returns : Scientific genus name as string
     Args    : Scientific genus name as string

sub_species
-----------

     Title   : sub_species
     Usage   : $obj->sub_species($newval)
     Function:
     Returns : value of sub_species
     Args    : newvalue (optional)

binomial
--------

     Title   : binomial
     Usage   : $binomial = $self->binomial();
               $binomial = $self->binomial('FULL');
     Function: Returns a string "Genus species", or "Genus species subspecies",
               the first argument is 'FULL' (and the species has a subspecies).
     Args    : Optionally the string 'FULL' to get the full name including the
               the subspecies.


File: pm.info,  Node: Bio/Tk/GO_Browser,  Next: Bio/Tk/HitDisplay,  Prev: Bio/Species,  Up: Module List

NAME
----

   Bio::Tk::GO_Browser.pm - Simplistic browser for GO ontology terms

AUTHORS
-------

   Mark Wilkinson (mwilkinson@gene.pbi.nrc.ca) Plant Biotechnology
Institute, National Research Council of Canada.  Copyright (c) National
Research Council of Canada, October, 2000.

DISCLAIMER
----------

   Anyone who intends to use and uses this software and code acknowledges
and agrees to the following: The National Research Council of Canada
(herein "NRC") disclaims any warranties, expressed, implied, or statutory,
of any kind or nature with respect to the software, including without
limitation any warranty or merchantability or fitness for a particular
purpose.  NRC shall not be liable in any event for any damages, whether
direct or indirect, consequential or incidental, arising from the use of
the software.

SYNOPSIS
--------

     use GO_Browser;
     use Tk;
     use strict;

     Begin();

     MainLoop;

     sub Begin {

     my $Textbox;
     my $GO;
     
     # create new main window.
     my $mw = MainWindow->new(-title => "GO Ontology Browser");
     
     # create new textbox with scrollbars
     $Textbox = $mw->Scrolled("Text", -background => "black")->pack(-fill => "both", -expand => 1);
     
     # alternate method to create new textbox, NOT RECOMMENDED!!
     #$Textbox = $mw->Text(-background => "black")->pack;
     
     # create new GO browser
     $GO = GO_Browser->new($Textbox, TopWindow => $mw);
     
     
     # set up binding of button-2 to retrieve information
       $Textbox->bind("<Button-2>" => sub {
          my $acc = $GO->GOAcc;
          my $term = $GO->Term;
          my $def = $GO->Definition;
          print "Acc = $acc Term = $term Def = $def\n\n";
       });
     
      }

DESCRIPTION and ACKNOWLEDGEMENTS
--------------------------------

   Fills a Tk::Text widget with a browsable display of the GO ontology
(http://www.geneontology.org/).  Items in red are "branches", while items
in green are "leaves" of the GO ontology tree.  Double-clicking branches
moves you up and down the tree.  Middle-clicking on any element records the
clicked-upon term and definition (if available) and this event can be
trapped by the top-level windowing system to retrieve this info for
whatever external application you are building.

   Unlike previous versions, this browser connects directly to the GO
ontology database.  Therefore it requires no pre-downloading and parsing
of the XML files (halleluja!)

   Because it is connecting "live" there is sometimes a small delay while
the query is being sent over the net.  The number of queries required for
the browser has been mitigated as much as possible by some clever
left-joins written by Dave Block (dblock@gene.pbi.nrc.ca).  Thanks Dave!

CONTACT
-------

   Mark Wilkinson (mwilkinson@gene.pbi.nrc.ca)

Options
-------

     $GO = GO_Browser->new(
       $Textbox,          	# the Tk Text widget
       TopWindow => $mw,   # the top-level window (or undef)
       GO_IP => "headcase.lbl.gov",  # the IP address of your GO database
       GO_dbName => "go"   # the name of the GO database
     );

Methods
-------

     $GO->GOAcc	# returns Accession number of the middle-clicked term
     $GO->Term   # returns the Term name of the middle-clicked term
     $GO->Definition  # returns the associated definition


File: pm.info,  Node: Bio/Tk/HitDisplay,  Next: Bio/Tk/SeqCanvas,  Prev: Bio/Tk/GO_Browser,  Up: Module List

Frame-based widget for displaying Fasta or Blast hits/HSPs with optional text annotation
****************************************************************************************

NAME
====

   Bio::Tk::HitDisplay - Frame-based widget for displaying Fasta or Blast
hits/HSPs with optional text annotation

SYNOPSIS
========

     use Bio::Tk::HitDisplay;
     ...
     $hds = $parent->HitDisplay(?options?);

DESCRIPTION
===========

   *HitDisplay* is a Frame-based widget which contains a Canvas. When
provided with a list of data structures, each representing a hit of a
query sequence to a database, it draws:

   * A scale

     This is marked in residues (aa for a protein query, nt for a nucleic
     acid query)

   * The query sequence

     Represented as a single green line

   * Database hits

     A line for each Fasta hit, or a group of lines for each Blast hit (one
     per HSP)

   The coordinates of the hits/HSPs on the subject sequence (i.e. the
sequence in the database) are indicated below the ends of each line.

   The *HitDisplay* delegates all standard options to the Canvas contained
within it. The non-standard options for *HitDisplay* are:

*-hitdata* => \@hitdata
     The structure of each element of this list is quite complex. They are
     normally generated from object(s) representing Blast or Fasta hits
     e.g.

          Bio::PSU::IO::Blast::Hit
          Bio::PSU::IO::Fasta::Hit

     by their respective adapters

          Bio::PSU::IO::Blast::HitAdapter
          Bio::PSU::IO::Fasta::HitAdapter

     This is normally hidden, unless you want to go and look.

     Each element is a reference to a hash containing the following keys
     and values:

          { q_id     => 'query id',
          	    s_id     => 'subject id',
          	    expect   => 'expect value',
          	    score    => 'percentage identity',
          	    overlap  => 'length of hit',
          	    q_len    => 'query length',
          	    s_len    => 'subject length',
          	    data     => \@data,
            text     => "Some text",
            callback => $callback }

     @data is a list of references to lists, each of which contains the
     coordinates of a single Fasta hit or Blast HSP on both the query and
     subject sequences.  Each innermost list contains 4 values; the start
     and end coordinates on the query sequence (indices 0 and 1) and the
     start and end coordinates on the subject sequence (indices 2 and 3). A
     Blast hit with 3 HSPs will look like this:

          [ [ q_start1, q_end1, s_start1, s_end1 ],
            [ q_start2, q_end2, s_start2, s_end2 ],
            [ q_start3, q_end3, s_start3, s_end3 ] ]

     The text field may contain any text which should be associated with
     that hit e.g. a more detailed account of the result or of the subject
     sequence. The display of this text is bound to a right mouse button
     click on the subject id in the canvas window. The text will appear
     just below the hit with one click and a subsequent click will hide it
     again.

     The callback is a code reference which, if defined, will be bound to a
     left mouse button click on the subject id in the canvas window.

*-hitcolours* => \%colourhash
     The hits or HSPs will be colour-coded according to percentage identity
     according to the key->value pairs in the colourhash. The default
     values are:

          { 90 => 'red',
          	    80 => 'orange',
          	    60 => 'gold',
          	    40 => 'yellow' }

     This indicates that hits where the query is >= 90% identical to the
     subject will be red, >= 80% will be orange etc. The hash supplied to
     *-hitcolours* will override the defaults.

*-interval* => integer >= 10
     This defines the vertical spacing between hit lines on the canvas. The
     minimum (and default) value is 10.

   Mouse bindings provided:

   * Vertical scrolling

     Wheel-mouse support is provided by binding buttons 4 and 5 to vertical
     scrolling (standard Z-axis mapping under XFree86 on Linux).

   * Panning

     Holding down the middle mouse button while dragging will pan the
     canvas in all directions

   * Display/hide all text annotations

     Double-clicking the left mouse button within the canvas will display
     all text annotations, while double-clicking with the right button will
     hide them. This is slow at the moment, with more than about 20 hits.

   Possible improvements:

   * Speed up opening/closing all text annotations at once

   * Items other than text between the hits

   * Make more of the canvas configurable

     Mouse bindings should be made configurable. Perhaps the canvas items
     making up each hit should be given a unique tag

METHODS
=======

   Interaction with this widget should generally be by means of the
standard Perl/Tk options. Internal methods are documented below.

AUTHOR
======

   Keith James (kdj@sanger.ac.uk)

ACKNOWLEDGEMENTS
================

   See Bio::PSU.pod

COPYRIGHT
=========

   Copyright (C) 2000 Keith James. All Rights Reserved.

DISCLAIMER
==========

   This module is provided "as is" without warranty of any kind. It may
redistributed under the same conditions as Perl itself.

Populate
--------

     Title   : Populate
     Usage   : N/A
     Function: Standard composite Frame-based widget setup.
             : See 'man Tk::composite' for details
     Returns : Nothing
     Args    : Hash reference

draw_align
----------

     Title   : draw_align
     Usage   : N/A
     Function: Draws hit text, line and coords for the hits
     Returns : Nothing
     Args    : Canvas, hitdata hash reference, left margin for text,
             : x coord for lines, y coord for lines, interval between
             : sets of lines (representing 1 Fasta hit or 1+ Blast
             : HSPs), hitcolours hash reference

h_line
------

     Title   : h_line
     Usage   : N/A
     Function: Draws a single hit/HSP line with the subject coords
             : below it
     Returns : Nothing
     Args    : Canvas, hit hash reference, x coord for line,
             : y coord for line, line width, line colour

draw_scale
----------

     Title   : draw_scale
     Usage   : N/A
     Function: Draws scale alongside line representing query
             : sequence
     Returns : Nothing
     Args    : Canvas, hit hash reference, left margin for text
             : x coord for line, y coord for line

deannotate_hit
--------------

     Title   : deannotate_hit
     Usage   : N/A
     Function: Reverses the effect of annotate_hit
     Returns : Nothing
     Args    : Canvas, text item (subject id), text to be inserted
             : in gap, interval between hits

annotate_hit
------------

     Title   : annotate_hit
     Usage   : N/A
     Function: Displays hit annotation below a hit line by shuffling
             : all canvas elements down the canvas and placing the
             : annotation text in the gap
     Returns : Nothing
     Args    : Canvas, text item (subject id), text to be inserted
             : in gap, interval between hits


File: pm.info,  Node: Bio/Tk/SeqCanvas,  Next: Bio/Tools/AlignFactory,  Prev: Bio/Tk/HitDisplay,  Up: Module List

AUTHORS
-------

   Mark Wilkinson (mwilkinson@gene.pbi.nrc.ca), David Block
(dblock@gene.pbi.nrc.ca) Plant Biotechnology Institute, National Research
Council of Canada.  Copyright (c) National Research Council of Canada,
October, 2000.

DISCLAIMER
----------

   Anyone who intends to use and uses this software and code acknowledges
and agrees to the following: The National Research Council of Canada
(herein "NRC") disclaims any warranties, expressed, implied, or statutory,
of any kind or nature with respect to the software, including without
limitation any warranty or merchantability or fitness for a particular
purpose.  NRC shall not be liable in any event for any damages, whether
direct or indirect, consequential or incidental, arising from the use of
the software.

SYNOPSIS
--------

     # To create a BioSeq map and return a handle to the map object:

     use Tk;
     Begin();
     MainLoop;

     sub Begin {

     # set up the Tk Windows
      	   my $MW = MainWindow = MainWindow->new (-title => "Map Of BioSeq Object");
      	   my $Frame = $MW->Frame()->pack(-side => 'top');
      	   my $lblSysMess = $MW->Label()->pack(-side => 'bottom', -fill => 'both');

     # create a BioSeq object
        my $SIO = Bio::SeqIO->new(-file=> 'genbankfile.gb', -format => 'GenBank');
        my $SeqObj = $SIO->next_seq();

     my $axis_length = 800;  # how large I want the final map to be

     # Draw the Map

     $MapObj = SeqCanvas->new(
     			$axis_length,
     			$Frame,
     			$lblSysMess,
     			$SeqObj,
     			-orientation => 'vertical'
     			label => 'primary_id');

     # SeqCanvas returns object reference for success
     # returns -1 for failed initiation - no $SeqObj supplied
     # returns -2 for bad sequence object
     # returns -3 sequence has length 0
     # returns -4 if orientation is uninterpretable
     # returns -5 if supplied frame object is not a TK::frame

     }

DESCRIPTION and ACKNOWLEDGEMENTS
--------------------------------

   Creates an interactive scalable/zoomable map of all features and
subfeatures of a Bio::SeqI compliant object. Basic functionality for
selecting single and multiple map objects is inherent in the object
itself: left-mouse click to select, SHIFT-left-mouse to select multiple.
All other Tk Events are passed back up to the MainWindow object and can be
trapped/bound by the user as they see fit.  Colors and axis-offsets of
mapped objects are assigned based on the "source" tag of the feature
object. These are assigned "on the fly" based on whatever is contained in
the BioSeq object provided.

   This module requires an updated version of Gregg Helt's original
BioTkPerl modules(version 0.81) which are available from BioPerl.  The
original BioTkPerl (version 0.80) is Copyright (c) Gregg Helt, 1995;
Version 0.81 was generated by Mark Wilkinson, PBI-NRC, Oct., 2000.

   Zooming routines/events in this module are conceptually based on the
Zoom routines from Genotator (Copyright (c) 1996, The Regents of the
University of California.  Harris, N.L. (1997), Genome Research
7(7):754-762)

CONTACT
-------

   Mark Wilkinson (mwilkinson@gene.pbi.nrc.ca) and Dave Block
(dblock@gene.pbi.nrc.ca)

APPENDIX
--------

   Description of Object tags, SeqCanvas Methods, and trapping Mouse
events.

Object Tags:
------------

   Each map-widget has several "reliable" tags attached to it. These tags
are FIDxxxx, Source and Strand, Type, and Canvas, where:

   * FIDxxxx is the unique identifier for that particular map-widget over
     all maps (even in multiple windows)

   * Source is derived from the "source" tag of the SeqFeature object this
     widget represents

   * Strand is derived from the "strand" tag of the SeqFeature object,
     converted into the GFF standard of +/-/. to represent the three
     possible strand values.

   * Type isthe feature type, derived from the primary_tag of the
     SeqFeature object

   * Map is either 'draft' or 'finished' to represent an object on the
     white or blue maps respectively

   So for example, a map widget might have the tags :

     FID22354 (no space)
     Source GeneMarkHMM (single space separated)
     Strand + (single space separated)
     Type exon ( " )
     Canvas draft ( " )

   If your BioSeq Features are being derived from an external database, it
is possible to also include the unique index number of that database entry
as a fourth tag on the associated map-widget. To do so, create your
SeqFeature objects with an additional tag "id", where the unique databse
index number is the value of this tag. This index number is then attached
to the widget as a fourth tag with the form:

     DB_ID xxxxx (x's represent the unique index value)

   The values of these three/four tags can be retrieved for any selected
object using the getSelectedTags function (see below) in order to relate
mapped objects back to their original database entries.  Using the
selectWithTag or recolorWithTag routines (see below) requires that you
pass the **full tag** as the desired selection (eg. pass "Source
GeneMarkHMM" not just "GeneMarkHMM")

METHODS
-------

new
---

     Title    : new
     Usage    : $MapObj= SeqCanvas->new(
     				$axis_length,
     				$Frame,
     				[$lblSysMess | undef],
     				$SeqObj,
     				-orientation => ['horizontal'|'vertical']
     				[, label => $tag])
     
     Function : create a map from the Feature object provided
     Returns  : Handle to the Map object
     Args     :
     	    axis_length in pixels,
     	    a Tk::Frame object,
     	    a Tk::Label or undef,
     	    a BioSeqI compliant object,
     	    the orientation for the map,
     	    optionally the SeqFeature tag you wish to
                   use as the label

mapFeatures
-----------

     Title    : mapFeatures
     Usage    : $FeatureIDs = $MapObj->mapFeatures('draft'|'finished',
     					       \@FeatureObj)
     Function : map SeqFeature objects to the 'draft'(white) or
                   'finished' (blue) maps
     Returns  : reference to a list of the FeatureID's of the mapped Features
     Args     : 'draft'|'finished', \@FeatureObj

unmapFeatures
-------------

     Title    : unmapFeatures
     Usage    : my $FeatureObjsRef = $MapObj->unmapFeatures(\@FeatureIDs)
     Function : to remove mapped features from the map display
     Returns  : referenced list of removed $FeatureObj objects

getSelectedIDs
--------------

     Title    : getSelectedIDs
     Usage    : $FeatureIDs = $MapObj->getSelectedIDs
     Function : to retrieve the FeatureID's of
                   all currently selected mapped objects
     Returns  : reference to a list of FeatureID's
     Args     : none

getSelectedTags
---------------

     Title   : getSelectedTags
     Usage   : ($FeatureID, $strand, $source,
     	    $type, $canvas [, $DB_ID]) = $MapObj->getSelectedTags
     Returns : FeatureID, Source, Strand, Type (i.e. Primary_tag),
        Canvas ('draft' or 'finished'),
        and Database_Index (if available).
     Comment : This is to be used for single-selection events only!
     Args    : none

getIDsWithTag       Title    : getIDsWithTag  Usage    : $FeatureIDs = $MapObj->getIDsWithTag(\@taglist)  Function : to retrieve the FeatureID's of all currently selected mapped objects  Returns  : reference to a list of FeatureID's  Args     : a reference to a list of tags (see discussion of proper tag format above)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

getSelectedFeatures
-------------------

     Title   : getSelectedFeatures
     Usage   : $FeatureHashRef = $MapObj->getSelectedFeatures
     Returns : a reference to a hash where the FeatureID is the key,
               and the Bio::SeqFeature Object is the value
     Args : none

getFeaturesWithTag
------------------

     Title   : getFeaturesWithTag
     Usage   : $FeatureHashRef = $MapObj->getFeaturesWithTag(\@taglist)
     Returns : a reference to a hash where the FeatureID is the
               key, and the Bio::SeqFeature Object is the value
     Args    : reference to a list of valid tags
               (see discussion of proper tag format)

clearSelections
---------------

     Title    : clearSelections
     Usage    : $MapObj->clearSelections
     Function : Clear all selection boxes and "selected" status of all Features.
     Returns  : nothing
     Args     : none

selectFeatures
--------------

     Title    : selectFeatures
     Usage    : $MapObj->selectFeatures(\@FeatureIDs)
     Function : "select" all Features with @FeatureID id's
     Args     : @FeatureIDs - a list of valid
                FeatureIDs (of the form FIDnnn where nnn is a unique integer)

selectWithTag
-------------

     Title    : selectWithTag
     Usage    : $MapObj->selectWithTag(\@tag_list [,'draft'|'finished'])
     Function : "select" all features which have any of @tag_list tags.
     Args     : @taglist, and optional 'draft' or 'finished' which map

recolorWithTag
--------------

     Title    : recolorWithTag
     Usage    : $MapObj->recolorWithTag('#XXXXXX'|'default', 'draft'|'finished', \@tag_list)
     Function : change the color of mapped objects having one of @tag_list tags.
     Returns  : nothing
     Args     :
     	First arg:hex-reference to an RGB color value, or 'default'.
     	Second arg: the canvas ('draft', or 'finished')
     	Third arg: a referenced list of tags.

assignCustomColors
------------------

     Title    : assignCustomColors
     Usage    : $MapObj->assignCustomColors($top)
     Function : change the default map-color for a selected widgets "Source" tag.
     Returns  : nothing
     Args     : a reference to a Tk::MainWindow object (new or existing).

is_draft_feature
----------------

     Title    : is_draft_feature
     Usage    : $result = $MapObj->is_draft_feature($FeatureID)
     Function : check if a $FeatureID is on the draft (white) map.
     Returns  : 1 for true, undef for false
     Args     : the FeatureID you are querying

is_finished_feature
-------------------

     Title    : is_finished_feature
     Usage    : $result = $MapObj->is_finished_feature($FeatureID)
     Function : check if $FeatureID is on the finished (blue) map.
     Returns  : 1 for true, undef for false
     Args     : the FeatureID you are querying

EVENTS
======

   The SeqCanvas both internally responds to mouse events, and sets "tags"
on the mapped feature in response to mouse events such that the user can
"trap" these events in the top-level windowing system and evaluate which
mapped feature the user was manupulating.

Mouse-Click
-----------

   Clicking or shift-Clicking the left mouse button over a mapped feature
causes the feature(s) to become "selected".  A selected object is
displayed on the screen with a black box surrounding the object, and the
object becomes tagged with a testable tag "selected" (use the
getSelectedFeatures or getSelectedIDs to retrieve additional information
about this object)

Mouse-Double-Click
------------------

   Both Double-clicking and Shift Double-Clicking the mouse over an object
selects that (single) mapped feature. All other features become unselected.

Mouse-Click and Drag
--------------------

   Used to select multiple objects. Any object touched by the bounding box
will be included in the selection.

Mouse-Over
----------

   As the mouse pointer enters the mapped widget, the tag "Mouse_over" is
added to this object. information about this object could be retrieved by,
for example, calling the getIDsWithTag(["Mouse_over"]) method. This tag is
removed when the mouse pointer leaves the mapped-feature space. Bind the
<Movement> event in the top-level windowing system to track the mouse
movements if you wish to monitor the Mouse-Over widget events.


