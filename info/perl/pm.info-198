This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Java,  Next: Jcode,  Prev: Jail,  Up: Module List

Perl extension for accessing a JVM remotely or locally
******************************************************

NAME
====

   Java - Perl extension for accessing a JVM remotely or locally

SYNOPSIS
========

     use Java;
     $java = new Java;
     $frame = $java->create_object("java.awt.Frame","Frame's Title");
     $frame->setSize(400,400);
     $frame->show();
     $java->do_event($frame,"addWindowListener",\&event_handler);
     
     $array = $java->create_array("java.lang.String",5);
     // Set array element 3 to "Java is lame"
     $array->set_field(3,"Java is lame");
     $element = $array->get_field(3)->get_value();

     $button = $java->create_object("java.awt.Button","Push Me");
     // Listen for 'Action' events from $button object
     $java->do_event($button,"addActionListener",\&event_handler);

     // Loop & wait mode
     while(1)
     {
          my $continue = $java->go;
          last if (!defined $continue);
     }

     // Got an event!
     sub event_handler
     {
     	my($object_that_caused_event,$event_object) = @_;
           if ($object_that_caused_event->same($button))
     	{
     		// From $button!
     		print "You pushed my button!!\n";
     	}
     }

DESCRIPTION
===========

   This module allows you to talk to a JVM on a local or remote machine.
You can create objects, call functions, access fields, deal with arrays,
get events & all the nonsense you can do in Java - from Perl!

Starting a JVM server
---------------------

   First you must run 'JavaServer' on the machine to which you will make
connections.  Simply to a 'java JavaServer' to start the server.  By
default it will start listening on port 2000.  Make sure the
'JavaServer.jar' is in your classpath - also make sure the Swing stuff
(JFC if you prefer) is in your classpath as well if you want to use Swing
stuff (note this does not apply to JVM 1.2+).

Creating the root Java object
-----------------------------

   You connect to a remote (or local) JVM when you create a new Java
instance.  The new call accepts a hash with the following keys:

     host => hostname of remote machine to connect to
     		default is 'localhost'
     port => port the JVM is listening on (JavaServer)
     		default is 2000
     event_port => port that the remote JVM will send events to
     		default is 2001

   For example:

     $java = new Java(host => "java.zzo.com", event_port => 4032);
     $java2 = new Java(port => 8032);

   You can have any number of java 'environments' in a Perl program.

   Also if you 'use strict' you must do a 'no struct 'subs" 'cuz all Java
method calls are AUTOLOAD'ed - sorry.

Creating java primitives
------------------------

   The Java.pm module will treat all integers encountered in parameter
lists as integer and strings as java Strings.  All other primitive types
must be suffixed with an identifier so Java.pm knows what primitive Java
type to convert it to - for instance boolean types are tagged like:
"true:b" or "false:b"

   Here's a complete list of supported Java primitives:

     Perl String Value  -> (converted to) -> Java Primitive
     -----------------			--------------
     2344					int
     "23:short"				short
     "23:byte"				byte
     "a:char"				char
     "23445:long"				long
     "3.42:float"				float
     "3.14159:double"			double
     "true:b" or "false:b"			boolean
     "Anything else"				String
     	or
     "Anything else:string"			String

   So... if you need to use an integer as a String say "343:string".

Localization and String encoding
--------------------------------

   Quick note on String encodings, you can specify that your strings are
encoded in a specific format using the ":string_<ENCODING>" syntax like:

     my $label = $java->create_object("java.awt.Label","Label:string_UTF8");

   This specifies that this String uses Unicode encoding.  See
http://www.javasoft.com/products/jdk/1.1/docs/guide/intl/encoding.doc.html
for the complete list of valid Java String encodings.

Creating java objects
---------------------

   Once you've connected to a JVM via the 'new Java' call you can start
creating Java objects.  This is accomplished via the 'create_object'
function.  The first argument must be the 'fully-qualified'/'full path' of
the Java object you want to create - like 'java.lang.String' or
'java.awt.Frame'.  The remaining arguments are passed to that object's
constructor.

   For example:

     my $frame = $java->create_object("java.awt.Frame","Frame Title");
     my $dialog = $java->create_object("java.awt.Dialog",$frame,
     		"Dialog Title","true:b");

   Note the use of "true:b" in the constructor to tell Java.pm that that
value should be a 'true' Java boolean value.

   In these cases a 'java.awt.Frame' takes a String as the lone parameter,
whereas a 'java.awt.Dialog' takes a Frame, a String, and a boolean value
in its constructor.

Calling java methods
--------------------

   You can make both static and instantiated method calls on java objects.
The parameter lists work exactly like constructor parameter lists - if you
want to pass a java primitive anything other than integers or Strings need
to be tagged accordingly.  All function calls that return something return
a java object - so even if the java function returns an 'int' it is
returned to perl as a 'java.lang.Integer'.  To get the value of that
Integer you must use the 'get_value' function.  The syntax is exactly what
you'd expect (I hope!).

   For example:

     $frame->setSize(200,500);
     $frame->show();  (or $frame->show)

   Note functions that don't take any parameters don't need the
parentheses!

     To call static functions the syntax is slightly different.

   For example:

   To call the static method 'forName' in the object 'java.lang.Class' it
looks like this:

     my $class = $java->java_lang_Class("forName","Test");

   Note you use the '$java' object returned from the call to 'new Java' to
access static methods - the static object must be fully-qualified
separated by '_'s instead of '.'s.  And finally the first parameter is the
name of the static function followed by any parameters to it.

   If your static class is NOT in a package you MUST use the 'static_call'
function like:

     my $return_value = $java->static_call("MyStaticClass","<function_name>",@params);

Getting and Setting java object fields
--------------------------------------

   You can get and set individual fields in java objects (static or
instantiated) using the 'get_field' and 'set_field' methods.  All
'get_field' calls return java objects just like calling java functions.
You must use the 'get_value' function to 'unwrap' primitive types to their
actual values.

   For example:

   Get a static field

     my $win_act = $java->get_field("java.awt.event.WindowEvent",
     					"WINDOW_ACTIVATED");

   Note the first parameter must be the fully qualified java object name
and the second parameter is the static field.

   Get an instantiated field

     my $obj = $java->create_object("java.my.Object");
     my $field = $obj->get_field("my_field");

   Similarly to set a field another parameter is added to the 'set_field'
call with the object that the specified field is to be set to:

   Set a static field

     $java->set_field("java.static.Object","field_name",$obj);

   Set an instantiated field

     $obj->set_field("integer_field_name",400);

Exceptions
----------

   Currently Java.pm will 'croak' when an Exception is encountered in
JavaServer.  So the way to deal with them is to enclose your Java
expression that might throw an exception in an 'eval' block & then check
the $@ variable to see if an Exception was indeed thrown.  You then need
to parse the $@ variable to see exactly what Exception was thrown.
Currently the format of the $@ string is:

     ERROR: java.lang.Exception: some.java.Exception: <more info> at $0 line XX

   Note the '<more info>' part is the result of the getMessage() function
of that Exception.  Everything after that is the stuff put in there by
croak; the filename & line number of your Perl program.  So here's what an
Exception handler can look like:

     my $I;
     eval
     {
     	$I = $java->java_lang_Integer("parseInt","$some_string:string");
     };
     if ($@)
     {
     	# An exception was thrown!!
     	$@ =~ s/ERROR: //;	# Gets rid of 'ERROR: '
     	$@ =~ s/at $0.*$//;	# Gets rid of 'croak' generated stuff

     # Print just the Java stuff
     print "$@\n";

     }

   So in this example if the scalar $some_string did NOT contain a parsable
integer - say 'dd' - the printed error message would be:

     java.lang.Exception: java.lang.NumberFormatException: dd

Comparing Java objects
----------------------

   You can see if two references to java objects actually point to the same
object by using the 'same' function like:

     if ($object1->same($object2))
     {
     	# They're the same!
     }
     else
     {
     	# Nope, not the same
     }

   You'll see why this is useful in the next section 'Events'.

Events
------

   Events are passed from the remote JVM to Perl5 via a separate event
port.  To enable events on an object use the 'do_event' function.  Your
callback function will receive the object that caused the event as its
first parameter and the event object itself as the second parameter.
Here's where ya wanna use the 'same' function to see what object caused
this event if you set up multiple objects to call the same event function.

   For example:

     my $frame = $java->create_object("java.awt.Frame","Title");
     $java->do_event($frame,"addWindowListener",\&event_handler);
     my $button = $java->create_object("java.awt.Button","Push Me");
     $java->do_event($button,"addActionListener",\&event_handler);

   To stop listening for events do:

     $java->do_event($frame,"removeWindowListener");

   Where: - $frame is the object for which you'd like to receive events -
"addWindowListener" specifies the types of events you want to listen for -
\&event_handler is your event callback routing that will handle these
events

   You will keep receiving events you registered for until you make a
"remove" call or your Java object goes away (out of scope, you destroy it,
whatever).

   Note the second parameter MUST be of the form:

     "<add | remove><Event Type>Listener"

   Default <Event Types> are:

     Component
     Container
     Focus
     Key
     Mouse
     MouseMotion
     Window
     Action
     Item
     Adjustment
     Text

   Swing <Event Types> are:

     Ancestor
     Caret
     CellEditor
     Change
     Hyperlink
     InternalFrame
     ListData
     ListSelection
     MenuDragMouse
     MenuKey
     Menu
     PopupMenu
     TreeExpansion
     TreeSelection
     TreeWillExpand

   And within most of these <Event Types> there are a number of specific
events.  Check out the Java event docs if you don't know what I'm talking
about...

   Here's what an event handler looks like:

   	sub event_handler 	{ 		my($object,$event) = @_; 		if ($object->same($frame))
{ 			# Event caused by our frame object!

   			# This will get this event's ID value 			my $event_id =
$event->getID->get_value;

     # Get value for a WINDOW_CLOSING event
     my $closing_id = $java->get_field("java.awt.event.WindowEvent","WINDOW_CLOSING")->get_value;

     if ($event_id == $closing_id)
     {
     	# Close our frame @ user request
     	$object->dispose;
     }
     		}
     		if ($object->same($button))
     		{
     print "You Pushed My Button!\n";
     		}
     	}

   Note return values from event handlers are ignored by Java.pm BUT are
returned from the Event Loop as you'll see in a bit.

   Note also how I had to call 'get_value' to get the actualy integer
values of the 'getID' function return value and the field value of
WINDOW_CLOSING.

Event Loops
-----------

   Once you've set up your event handlers you must start the event loop to
begin getting events - there are two ways to do this.

     1. Have Java.pm handle the event loop
     2. Roll your own.

   Java.pm's event loop will block until an events happens - typically this
is what you want but sometimes you might want more control, so I've decided
to be nice this _one_ time & let you roll your own too.

   Here's how Java.pm's event loop works for ya:

     #
     # Set up a bunch of events...
     #

     while(1)
     {
     	my $cont = $java->go;
     	last if (!defined $cont);
     }

   Note this works similarly to Tk's event loop.  Your program will now
just sit & respond to events via your event handlers.  Also note that
Java.pm's event loop only handles ONE event & then returns - the return
value is whatever your event handler returned OR undef if there was an
error (like you lost yer connexion to the JVM).

   Here's how you can create yer own Event Loop:

   You ask Java.pm for a FileHandle that represents the incoming event
stream.  You can then select on this FileHandle or do whatever else you
want - remember this is a READ ONLY FileHandle so writing to it ain't
going to do anything.  Once you get a 'line' from this FileHandle you can
(and probably should) call 'decipher_event' & the event will be dispatched
to your event handler appropriately - the return value being the return
value of your event handler.  This can look something like this:

     ## Roll my own event loop

     # Get event FileHandle
     my $event_file_handle = $java->get_event_FH;

     # Set up my select loop
     my $READBITS = 0;
     vec($READBITS,$event_file_handle->fileno,1) = 1;

     # Suck in lines forever & dispatch events
     while(1)
     {
     	my $nf = select(my $rb = $READBITS,undef,undef,undef);
     	if ($nf)
     	{
     		my $event_line = <$event_file_handle>;
     		$java->decipher_event($event_line);
     	}
     }

   Note this example is EXACTLY what Java.pm's 'go' function does - if you
roll yer own Event Loop you prolly want to do something more interesting
than this!

   The upshot is you'll probably just want to use the 'go' function but if
you've got some other FileHandles going on & you don't want to block on
just this one you can (and should) use the 'roll your own' method.

Getting values
--------------

   To 'unwrap' java primitives (including Strings) you need to call the
'get_value' function.  This will stringify any object given to it -
typcially this is only useful for 'unwrapping' java primitives and Strings.

   For example:

     my $string1 = $java->create_object("java.lang.String","Mark");
     my $string2 = $java->create_object("java.lang.String","Jim");

     if ($string1 eq $string2)
     {
     	# WRONG!!!
     	# $string1 & $string2 are objects!
     }

     if ($string1->get_value eq $string2->get_value)
     {
     	# RIGHT!!!
     	# now you're comparing actual strings...
     }
     
     =head2 Arrays

   Arrays are created with the 'create_array' function call.  It needs a
fully-qualified java object or primitive name and a dimension.

   For example:

     # This will create a char array with 100 elements
     my $char_array  = $java->create_array("char",100);

     # This will create a String array with 5 elements
     my $string_array = $java->create_array("java.lang.String",5);
     
     Array elements are get and set using the 'get_field' and 'set_field' function calls.

   For example:

     # Set element #22 to 'B'
     # Don't forget on primitive arrays to use the ':' notation!
     $char_array->set_field(22,"B:char");

     # Set element #3 to 'Mark Rox'
     $string_array->set_field(3,"Mark Rox");

     # Get element #99
     my $element_99 = $char_array->get_field(99);

     # Get element #4
     my $element_4 = $string_array->get_field(4);

     # Don't forget to get the actual string value you gotta call
     #	'get_value'!
     my $char_value = $char_element_99->get_value;
     my $string_value = $string_element_4->get_value;

   To get the length of an array use the get_length function.

   For example:

     my $length = $string_array->get_length;

   Note this will return an actual integer!  You do not need to call
'get_value' on 'get_length's return value!

EXPORT
------

   None by default.

AUTHOR
======

   Mark Ethan Trostler, mark@zzo.com

SEE ALSO
========

   perl(1).  http://www.javasoft.com/.  Any sorta Java documentation you
can get yer hands on!  http://www.zzo.com/Java/getit.html


File: pm.info,  Node: Jcode,  Next: Jcode/Unicode,  Prev: Java,  Up: Module List

Japanese Charset Handler
************************

NAME
====

   Jcode - Japanese Charset Handler

SYNOPSIS
========

     use Jcode;
     
     # traditional
     Jcode::convert(\$str, $ocode, $icode, "z");
     # or OOP!
     print Jcode->new($str)->h2z->tr($from, $to)->utf8;

DESCRIPTION
===========

   Jcode.pm supports both object and traditional approach.  With object
approach, you can go like;

   $iso_2022_jp = Jcode->new($str)->h2z->jis;

   Which is more elegant than;

   $iso_2022_jp = &jcode::convert(\$str,'jis',jcode::getcode(\str), "z");

   For those unfamiliar with objects, Jcode.pm still supports getcode()
and convert().

Methods
=======

   Methods mentioned here all return Jcode object unless otherwise
mentioned.

$j = Jcode->new($str [, $icode]);
     Creates Jcode object $j from $str.  Input code is automatically
     checked unless you explicitly set $icode. For available charset, see
     `getcode()' in this node below.

     The object keeps the string in EUC format enternaly.  When the object
     itself is evaluated, it returns the EUC-converted string so you can
     "print $j;" without calling access method if you are using EUC
     (thanks to function overload).

Passing Reference
     Instead of scalar value, You can use reference as

     Jcode->new(\$str);

     This saves time a little bit.  In exchange of the value of $str being
     converted. (In a way, $str is now "tied" to jcode object).

$j->set($str [, $icode]);
     Sets $j's internal string to $str.  Handy when you use Jcode object
     repeatedly (saves time and memory to create object).

          # converts mailbox to SJIS format
          my $jconv = new Jcode;
          while(&lt;&gt;){
              print $jconv->set(\$_)->mime_decode->sjis;
          }

$j->append($str [, $icode]);
     Appends $str to $j's internal string.

$j = jcode($str [, $icode]);
     shortcut for Jcode->new() so you can go like;

     $sjis = jcode($str)->sjis;

$euc = $j->euc;
$jis = $j->jis;
$sjis = $j->sjis;
     What you code is what you get :)

$iso_2022_jp = $j->iso_2022_jp
     Same as $j->z2h->jis.  Hankaku Kanas are forcibly converted to
     Zenkaku.

[@lines =] $jcode->jfold([$bytes_per_line, $newline_str]);
     folds lines in jcode string every $bytes_per_line (default: 72) in a
     way that does not clobber the multibyte string.  (Sorry, no Kinsoku
     done!)  with a newline string spified by $newline_str (default: \n).

Methods that use MIME::Base64
-----------------------------

   To use methods below, you need MIME::Base64.  To install, simply

     perl -MCPAN -e 'CPAN::Shell->install("MIME::Base64")'

$mime_header = $j->mime_encode([$lf, $bpl]);
     Converts $str to MIME-Header documented in RFC1522.  When $lf is
     specified, it uses $lf to fold line (default: \n); When $bpl is
     specified, it uses $bpl for the number of bytes (default: 76);

$j->mime_decode;
     Decodes MIME-Header in Jcode object.

     You can retrieve the number of matches via $j->nmatch;

Methods implemented by Jcode::H2Z
---------------------------------

   Methods below are actually implemented in Jcode::H2Z.

$j->h2z([$keep_dakuten]);
     Converts X201 kana (Hankaku) to X208 kana (Zenkaku).  When
     $keep_dakuten is set, it leaves dakuten as is (That is, "ka +
     dakuten" is left as is instead of being converted to "ga")

     You can retrieve the number of matches via $j->nmatch;

$j->z2h;
     Converts X208 kana (Zenkaku) to X201 kana (Hankazu).

     You can retrieve the number of matches via $j->nmatch;

Methods implemented in Jcode::Tr
--------------------------------

   Methods here are actually implemented in Jcode::Tr.

$j->tr($from, $to);
     Applies tr on Jcode object. $from and $to can contain EUC Japanese.

     You can retrieve the number of matches via $j->nmatch;

Methods implemented in Jcode::Unicode
-------------------------------------

   If your perl does not support XS (or you can't `perl Makefile.PL',
Jcode::Unicode::NoXS will be used.

   See *Note Jcode/Unicode: Jcode/Unicode, and *Note Jcode/Unicode/NoXS:
Jcode/Unicode/NoXS, for details

$ucs2 = $j->ucs2;
     Returns UCS2 (Raw Unicode) string.

$ucs2 = $j->utf8;
     Returns utf8 String.

Instance Variables
------------------

   If you need to access instance variables of Jcode object, use access
methods below instead of directly accessing them (That's what OOP is all
about)

   FYI, Jcode uses a ref to array instead of ref to hash (common way) to
optimize speed (Actually you don't have to know as long as you use access
methods instead;  Once again, that's OOP)

$j->r_str
     Reference to the EUC-coded String.

$j->icode
     Input charcode in recent operation.

$j->nmatch
     Number of matches (Used in $j->tr, etc.)

Subroutines
===========

($code, [$nmatch]) = getcode($str);
     Returns char code of $str. Return codes are as follows

          ascii   Ascii (Contains no Japanese Code)
          binary  Binary (Not Text File)
          euc     EUC-JP
          sjis    SHIFT_JIS
          jis     JIS (ISO-2022-JP)
          ucs2    UCS2 (Raw Unicode)
          utf8    UTF8

     When array context is used instead of scaler, it also returns how many
     character codes are found.  As mentioned above, $str can be \$str
     instead.

jcode.pl Users:
     This function is 100% upper-conpatible with jcode::getcode() - well,
     almost;

          * When its return value is an array, the order is the opposite;
            jcode::getcode() returns $nmatch first.

          * jcode::getcode() returns 'undef' when the number of EUC characters
            is equal to that of SJIS.  Jcode::getcode() returns EUC.  for
            Jcode.pm is no in-betweens.

Jcode::convert($str, [$ocode, $icode, $opt]);
     Converts $str to char code specified by $ocode.  When $icode is
     specified also, it assumes $icode for input string instead of the one
     checked by getcode(). As mentioned above, $str can be \$str instead.

jcode.pl Users:
     This function is 100% upper-conpatible with jcode::convert() !

BUGS
====

Unicode support by Jcode is far from efficient!
ACKNOWLEDGEMENTS
================

   This package owes a lot in motivation, design, and code, to the jcode.pl
for Perl4 by Kazumasa Utashiro <utashiro@iij.ad.jp>.

   Hiroki Ohzaki <ohzaki@iod.ricoh.co.jp> has helped me polish regexp from
the very first stage of development.

   And folks at Jcode Mailing list <jcode5@ring.gr.jp>.  Without them, I
couldn't have coded this far.

SEE ALSO
========

*Note Jcode/Unicode: Jcode/Unicode,
*Note Jcode/Unicode/NoXS: Jcode/Unicode/NoXS,
COPYRIGHT
=========

   Copyright 1999 Dan Kogai <dankogai@dan.co.jp>

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Jcode/Unicode,  Next: Jcode/Unicode/Constants,  Prev: Jcode,  Up: Module List

Aux. routines for Jcode
***********************

NAME
====

   Jcode::Unicode - Aux. routines for Jcode

SYNOPSIS
========

   NONE

DESCRIPTION
===========

   This module implements following subs as XS.  Used via Jcode.pm.

   This module is called by Jcode.pm on demand.  This module is not
intended for direct use by users.  This modules implements functions
related to Unicode.  Following functions are defined here;

Jcode::ucs2_euc();

Jcode::euc_ucs2();

Jcode::ucs2_utf8();

Jcode::utf8_ucs2();

Jcode::euc_utf8();

Jcode::utf8_euc();
VARIABLES
=========

$Jcode::Unicode::PEDANTIC
     When set to non-zero, x-to-unicode conversion becomes pedantic.  That
     is, '\' (chr(0x5c)) is converted to zenkaku backslash and '~"
     (chr(0x7e)) to JIS-x0212 tilde.

     By Default, Jcode::Unicode leaves ascii ([0x00-0x7f]) as it is.

BUGS
====

   If any, that is Unicode, Inc. to Blame (Especially JIS0201.TXT).

SEE ALSO
========

http://www.unicode.org/
COPYRIGHT
=========

   Copyright 1999 Dan Kogai <dankogai@dan.co.jp>

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   Unicode conversion table used here are based uponon files at
ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/, Copyright (c)
1991-1994 Unicode, Inc.


File: pm.info,  Node: Jcode/Unicode/Constants,  Next: Jcode/Unicode/NoXS,  Prev: Jcode/Unicode,  Up: Module List

UCS2-EUC conversion table
*************************

NAME
====

   Jcode::Unicode::Constants - UCS2-EUC conversion table

SYNOPSIS
========

   NONE

DESCRIPTION
===========

   This module just contains a huge hash that converts UCS2 from/to EUC.

SEE ALSO
========

ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/
     Unicode mapping data

COPYRIGHT
=========

   Copyright 1999 Dan Kogai <dankogai@dan.co.jp>

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   Unicode conversion table here is based on files at
ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/, Copyright (c)
1991-1994 Unicode, Inc.


File: pm.info,  Node: Jcode/Unicode/NoXS,  Next: Kite,  Prev: Jcode/Unicode/Constants,  Up: Module List

Non-XS version of Jcode::Unicode
********************************

NAME
====

   Jcode::Unicode::NoXS - Non-XS version of Jcode::Unicode

SYNOPSIS
========

   NONE

DESCRIPTION
===========

   This module is called by Jcode.pm on demand.  This module is not
intended for direct use by users.  This modules implements functions
related to Unicode.  Following functions are defined here;

Jcode::ucs2_euc();

Jcode::euc_ucs2();

Jcode::ucs2_utf8();

Jcode::utf8_ucs2();

Jcode::euc_utf8();

Jcode::utf8_euc();
VARIABLES
=========

$Jcode::Unicode::PEDANTIC
     When set to non-zero, x-to-unicode conversion becomes pedantic.  That
     is, '\' (chr(0x5c)) is converted to zenkaku backslash and '~"
     (chr(0x7e)) to JIS-x0212 tilde.

     By Default, Jcode::Unicode leaves ascii ([0x00-0x7f]) as it is.

MODULES
=======

Jcode::Unicode::Constants
     Jumbo hash that contains UCS2-EUC conversion table is there.

BUGS
====

     * It's very slow to initialize, due to the size of the conversion
       table it has to load.  Once loaded, however, the perfomance is not
       too bad (But still much slower than XS version).
     * Besides that, that is Unicode, Inc. to Blame (Especially JIS0201.TXT).

SEE ALSO
========

http://www.unicode.org/
COPYRIGHT
=========

   Copyright 1999 Dan Kogai <dankogai@dan.co.jp>

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   Unicode conversion table used here are based uponon files at
ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/, Copyright (c)
1991-1994 Unicode, Inc.


File: pm.info,  Node: Kite,  Next: Kite/Base,  Prev: Jcode/Unicode/NoXS,  Up: Module List

collection of modules useful in Kite design and construction.
*************************************************************

NAME
====

   Kite - collection of modules useful in Kite design and construction.

SYNOPSIS
========

     use Kite;

     my $profile = Kite->profile(...)
     	|| die $Kite::ERROR;

     my $xml2ps = Kite->xml2ps(...)
         || die $Kite::ERROR;

     my $xml_parser = Kite->xml_parser(...)
         || die $Kite::ERROR;

DESCRIPTION
===========

   The Kite::* modules are a collection of Perl modules and scripts
written to help with various tasks in the design and construction of
traction kites.

   The Kite module acts as a general interface to the other modules in the
collection, providing factory methods for loading and instantiating them.

METHODS
=======

profile()
---------

   Loads the Kite::Profile module and calls the new() constructor.  All
parameters are forwarded to the constructor.

   This example:

     use Kite;
     
     my $profile = Kite->profile( name => 'My Profile', ... )
         || die $Kite::ERROR, "\n";

   is equivalent to:

     use Kite::Profile;

     my $profile = Kite::Profile->new( name => 'My Profile', ... )
         || die $Kite::Profile::ERROR, "\n";

xml2ps()
--------

   Loads the Kite::XML2PS module and calls the new() constructor.  All
parameters are forwarded to the constructor as per the previous example.

xml_parser()
------------

   Loads the Kite::XML::Parser module and calls the new() constructor.  All
parameters are forwarded to the constructor as per the previous examples.

MODULES
=======

   The following modules are distributed with the Kite bundle.

Kite
----

   Front-end for the Kite::* modules.  Contains factory methods for loading
modules and instantiating objects of other Kite::* classes.

Kite::Base
----------

   Base class implementing common functionality such as error reporting.

Kite::Profile
-------------

   Module defining an object class used to represent and manipulate 2D
profiles.

Kite::XML2PS
------------

   Module to convert a curve definition from OpenKite XML format to
PostScript.  Provides automatic page tiling, path following text,
registration marks, etc.

Kite::XML::Parser
-----------------

   Module for parsing an XML file and generating a representative tree of
node (element) objects.

Kite::XML::Node
---------------

   Base class for XML element nodes created by Kite::XML::Parser.

Kite::XML::Node::Kite
---------------------

   Derived node elements specific to Kite markup (e.g. Kite, Part,
Outline, Curve, Point, etc.)

Kite::PScript::Defs
-------------------

   Module defining a number of PostScript definitions useful for
generating PostScript documents for kite part layout, etc.

SCRIPTS
=======

   The following scripts are distributed with the Kite bundle.

okprof
------

   Utility script providing a user interface to the Kite::Profile module.
Allows 2D profiles to be loaded and manipulated via simple commands.  See
'*perldoc okprof*' or '*okprof -h*'.

okxml2ps
--------

   Utility script for converting XML kite part definition and layout
markup to PostScript.  Uses the Kite::XML2PS module.

AUTHORS
=======

   Andy Wardley <abw@kfs.org> is the primary author and current maintainer
of the Kite::* bundle.

   Simon Stapleton <simon@tufty.co.uk> is another key contributor.

VERSION
=======

   This is version 0.4 of the Kite bundle.

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   See also *Note Kite/Profile: Kite/Profile,, *Note Kite/XML2PS:
Kite/XML2PS,, *Note Kite/XML/Parser: Kite/XML/Parser,, *Note
Kite/XML/Node: Kite/XML/Node,, *Note Kite/XML/Node/Kite:
Kite/XML/Node/Kite,, *Note Kite/PScript/Defs: Kite/PScript/Defs,, *Note
Kite/Base: Kite/Base,, `okprof' in this node and `okxml2ps' in this node.


File: pm.info,  Node: Kite/Base,  Next: Kite/PScript/Defs,  Prev: Kite,  Up: Module List

base class module implementing common functionality
***************************************************

NAME
====

   Kite::Base - base class module implementing common functionality

SYNOPSIS
========

     package Kite::MyModule;

     use Kite::Base;
     use base qw( Kite::Base );
     use vars qw( $PARAMS $ERROR );

     $PARAMS = {
     	TITLE => 'Default Title',
     	ALPHA => 3.14,
     	OMEGA => 2.718,
     };

     package main;
     
     # specify config as a hash reference...
     my $module = Kite::MyModule->new({
     	TITLE => 'Grand Title',
     	ALPHA => 3,
     }) || die $Kite::MyModule::ERROR, "\n";

     # ...or as a list of items;  parameter case is insignificant
     my $module = Kite::MyModule->new( TITLE => 'Grand Title' )
     	|| die $Kite::MyModule::ERROR, "\n";
     
     print $module->title();
     print $module->alpha();
     print $module->omega();

DESCRIPTION
===========

   Base class module which implements a constructor and error reporting
functionality for various Kite modules.

PUBLIC METHODS
==============

new(\%config)
-------------

   Constructor method which accepts a reference to a hash array or a list
of `name => value' parameters which are folded into a hash.  The init()
method is then called, passing the configuration hash and should return
true/false to indicate success or failure.  A new object reference is
returned, or undef on error.  Any error message raised can be examined via
the error() class method or directly via the package variable ERROR in the
derived class.

     package Kite::MyModule;

     use Kite::Base;
     use base qw( Kite::Base );

     package main;

     my $module1 = Kite::MyModule->new({ param => 'value' })
         || die Kite::MyModule->error(), "\n";

     my $module2 = Kite::MyModule->new( param => 'value' )
         || die "constructor error: $Kite::MyModule::ERROR\n";

init(\%config)
--------------

   This method is called by the new() constructor to initialise the object.
A reference to a hash array of configuration items is passed as a
parameter.

   The method looks for a hash reference defined as the $PARAMS package
variable in the package of the derived class.  If defined, this hash array
should contain keys which define the acceptable configuration paramaters
and values which provide default values for that item.  The method then
iterates through the items in this hash, copying any defined value in the
$config hash or otherwise the default value in the $PARAMS hash, into the
$self object.

   All parameter names should be specified in the $PARAMS hash in UPPER
CASE.  The user may specify UPPER or lower case parameters names and these
will both be correctly handled.   Parameter names which are prefixed with
an underscore will be considered 'private'.  The default value, defined in
the $PARAMS hash will be copied into the $self object, but any value
provided in the $config hash will be ignored.

     package Kite::MyModule;

     use Kite::Base;
     use base qw( Kite::Base );
     use vars qw( $ERROR $PARAMS );

     $PARAMS = {
     	TITLE  => 'Default Title',
     	AUTHOR => undef,		# no default
     	_COUNT => 1,			# private variable
     };

     package main;
     
     my $mod = Kite::MyModule->new(title => 'The Title')
     	|| die $Kite::MyModule::ERROR;

   Derived classes may elect to redefine the init() subroutine to provide
their own custom initialisation routines.  They can, of course, explicitly
call the init() method on the parent class if they need to do so.

     package Kite::MyModule;

     ...

     sub init {
     	my ($self, $config) = @_;
     
     	$self->SUPER::init($config)
     	    || return undef;

     # more configuration...

     return $self;
         }

error($msg)
-----------

   May be called as an object method to get/set the internal _ERROR member
or as a class method to get/set the $ERROR variable in the derived class's
package.

     my $module = Kite::MyModule->new({ ... })
         || die Kite::MyModule->error(), "\n";

     $module->do_something()
     	|| die $module->error(), "\n";

   When called with parameters (multiple params are concatenated), this
method will set the relevant variable and return undef.  This is most
often used within object methods to report errors to the caller.

     package Kite::MyModule;

     ...

     sub foobar {
     	my $self = shift;
     	...
     	return $self->error('some kind of error...')
     	    if $some_condition;
     	...
     }

AUTHOR
======

   Andy Wardley <abw@kfs.org>

REVISION
========

   $Revision: 1.3 $

COPYRIGHT
=========

   Copyright (C) 2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Kite|Kite' in this node


File: pm.info,  Node: Kite/PScript/Defs,  Next: Kite/Profile,  Prev: Kite/Base,  Up: Module List

useful PostScript definitions for kite layout et al
***************************************************

NAME
====

   Kite::PScript::Defs - useful PostScript definitions for kite layout et
al

SYNOPSIS
========

     use Kite::PScript::Defs;

     # access package variables directly
     print $Kite::PScript::Defs::mm;

     # or as package subs
     print Kite::PScript::Defs::mm();

     # or as class methods
     print Kite::PScript::Defs->mm();

     # here's a convenient shorthand
     my $ps = 'Kite::PScript::Defs';
     print $ps->mm;

     # import various definitions
     use Kite::PScript::Defs qw( mm clip );
     print mm, clip;

     # or specify :all tag to import all definitions as subs
     use Kite::PScsript::Defs qw( :all );
     print mm, reg, clip, pathtext;

DESCRIPTION
===========

   Module defining a number of useful PostScript definitions for kite part
layout and other similar tasks.

   The definitions are provided as package variables which can be accessed
directly:

     use Kite::PScript::Defs;

     print $Kite::PScript::Defs::mm;

   An AUTOLOAD method is provided which translates any subroutine or method
calls into accesses to the appropriate variable.  Thus, the PostScript
definition specified in the $mm package variable can be accessed by calling
either of:

     Kite::PScript::mm();
     Kite::PScript->mm();

   The latter use allows a 'factory' variable to be defined to make this
less tedious.

     my $ps = 'Kite::PScript::Defs';
     print $ps->mm, $ps->clip, $ps->pathtext;

   You can specify import parameters when loading the module.  Any
definitions specified will be imported as subroutines into the caller's
namespace.

     use Kite::PScript::Defs qw( mm clip );
     print mm, clip;

   The ':all' import tag can be specified to import all the PoscScript
definitions.

     use Kite::PScript::Defs qw( :all );
     print mm, clip, pathtext;

TEMPLATE TOOLKIT
================

   The module is defined to be intimately useful when used in conjunction
with the Template Toolkit.  To use the PostScript definitions within a
template, simply ensure that the module is loaded and bless an empty hash
into the Kite::PScript::Defs package.  This will allow the Template
Toolkit to resolve to the correct class methods.

     use Template;
     use Kite::PScript::Defs;

     my $tt2  = Template->new();
     my $vars = {
     	psdefs => bless({ }, 'Kite::PScript::Defs'),
     };

     $tt2->process(\*DATA, $vars)
     	|| die $tt2->error();

     __END__
     %!PS-Adobe-3.0
     %%EndComments

     [% psdefs.mm %]
     [% psdefs.lines %]
     [% psdefs.cross %]
     [% psdefs.dot %]
     [% psdefs.circle %]
     [% psdefs.crop %]
     [% psdefs.reg %]

     0 mm 0 mm moveto	% /mm defined in psdefs.mm
     crop		% /crop defined in psdefs.crop
     regmarks		% /regmarks defined in psdefs.reg
     ...etc...

POSTSCRIPT DEFINITION METHODS
=============================

mm
     Defines millimetres /mm.

          [% psdefs.mm %]
          10 mm 10 mm moveto
          50 mm 10 mm lineto

lines
     Defines the following line styles:

          linelight		% 0.25 setlinewidth
          linenormal		% 0.5  setlinewidth
          lineheavy		% 0.75 setlinewidth
          linedotted		% 0.5  setlinewidth + dotted
          linedashed		% 0.5  setlinewidth + dashed

     Example:

          [% psdefs.mm %]
          [% psdefs.lines %]
          linenormal
          newpath
          0 mm 0 mm moveto
          100 mm 0 mm lineto
          stroke
          
          =item cross

     Defines a procedure to generate a cross from vertical and horizontal
     lines 10mm in length, crossing at the current point.  Requires 'mm'
     and 'lines'.

          [% psdefs.mm %]
          [% psdefs.lines %]
          [% psdefs.cross %]
          50 mm 50 mm		% move to a point
          cross		% draw cross

dot
     Defines a procedure to generate a small filled dot at the current
     point.  Requires 'mm' and 'lines'.

          [% psdefs.mm %]
          [% psdefs.lines %]
          [% psdefs.dot %]
          50 mm 50 mm		% move to a point
          dot			% draw dot

circle
     Defines a procedure to generate a small circle at the current point.
     Requires 'mm' and 'lines'.

          [% psdefs.mm %]
          [% psdefs.lines %]
          [% psdefs.circle %]
          50 mm 50 mm		% move to a point
          circle		% draw circle

crop
     Defines a procedure to generate a crop mark at the current point,
     built from a combination of /cross and /circle.  Requires 'mm',
     'lines', 'cross' and 'circle'.

          [% psdefs.mm %]
          [% psdefs.lines %]
          [% psdefs.cross %]
          [% psdefs.circle %]
          0 mm 0 mm		% move to a point
          circle		% draw crop mark

clip
     Defines /cliprect as a procedure to return a clipping rectangle set to
     the imageable size.  Defines a number of other variables containing
     information about the clipping rectangle.

          cliprect		% clipping rectangle
          cliptrx		% top right x
          cliptry		% top right y
          clipblx		% bottom left x
          clipbly		% bottom left y
          clipxsize		% width
          clipysize		% height

reg
     Defines /regmarks to generate registration marks (crop) at the corners
     of the clipping rectangle, /cliprect.  Requires 'mm', 'lines',
     'cross', 'circle', 'crop' and 'clip'.

          [% psdefs.mm %]
          [% psdefs.lines %]
          [% psdefs.cross %]
          [% psdefs.circle %]
          [% psdefs.crop %]
          [% psdefs.clip %]

          regmarks		% draw registration marks

noreg
     Defines /regmarks as a no-op procedure to prevent registration marks
     from being produced.

          regmarks		% null registration marks

pathtext
     Defines /pathtext to draw text along an arbitrary path.

          path text pathtext	% draw text along path

          ** TODO - see Blue Book for examples **

tiles
     Defines /tiles as a procedure which calculates the number of pages
     required to display the current path on the output device.  Also
     calculates the X/Y origin required for the path to be centered within
     the tile set.  Defines the following items.

          tilesnx		% no. of tiles in x
          tilesny		% no. of tiles in y
          tilesxorg		% suggested x origin
          tilesyorg		% suggested y origin

     See next item for example of use.

dotiles
     Generates PostScript to tile an image into multiple pages.  It
     requires that a number of items be pre-defined.  The first,
     /tileimage, should be a procedure defined to generate the image
     itself.

          /tileimage {
          	...PostScript to generate your image...
          } def

     The next item, /tilepath, should be a procedure defined to generate a
     path which encloses the image.  This is used to calculate the
     bounding box for the image.

          /tilepath {
          	...PostScript path to bound your image...
          } def

     Finally, the /tilepage item should be a procedure defined to generate
     any output required on each tiled page (i.e. independant of the main
     image which ends up split across many pages).

          [% psdefs.mm %]
          [% psdefs.reg %]
          [% psdefs.clip %]

          /tilepage {
          	regmarks		% generate registration marks
          	/Times-Roman findfont
          	24 scalefont setfont	% set font
          	clipblx 3 mm add
          	clipbly 3 mm add moveto	% move to lower left corner
          	([% title %]) show	% print title
          	tilemap			% generate tiling map
          } def

     To tile the image onto multiple pages, the /tiles procedure should be
     called to determine the tiling requirements.  The /tilepath item
     should be on the stack (i.e. precede the call).

          [% psdefs.tiles %]

          tilepath tiles

     Then, the 'dotiles' method can be called to generate the appropriate
     PostScript code to tile the image onto multiple pages.

          [% defs.dotiles %]

Box
     This item generates a PostScript definition for a Box object which can
     be used for all kinds of things boxlike.  The following documentation
     items describe the available Box "methods" in more detail, but for
     now, here's a complete example.

          %!PS-Adobe-3.0
          %%Title: Box Example
          %%EndComments

          [% defs.mm %]
          [% defs.lines %]
          [% defs.cross %]
          [% defs.dot %]
          [% defs.circle %]
          [% defs.crop %]
          [% defs.box %]

          # define a general border value
          /border [% border %] mm def

          % convert the clipping path into a Box
          clippath pathbbox Box

          % inset this Box by /border
          border Box_border

          % and define /page to be this slightly smaller Box
          /page exch def

          % split /page into 3 vertical boxes
          page 3 border 0 Box_vsplit
          /upper  exch def
          /middle exch def
          /lower  exch def

          % inset upper box by border and define /inner
          upper border Box_border
          /inner exch def

          % split it horizontally into /left and /right
          inner 2 border 0 Box_hsplit
          /right exch def
          /left  exch def

          % stroke /upper, /middle and /lower boxes.
          linenormal
          upper  Box_rect rectstroke
          middle Box_rect rectstroke
          lower  Box_rect rectstroke

          % focus the drawing context on the /middle box
          middle Box_focus
          newpath
          0 0 moveto
          100 mm 100 mm lineto
          ...more complicated stuff here...
          stroke
          middle Box_defocus

          showpage

Box_select
     Unpacks a Box structure to define various Box_* variables.

          Box_try	    % top right y
          Box_trx	    % top right x
          Box_bly	    % bottom left y
          Box_blx	    % bottom left x
          Box_width	    % width of Box
          Box_height	    % height of Box

     Example:

          mybox Box_select

Box_rect
     Unpacks a Box structure to a rect suitable for rectstroke, etc.

          mybox Box_rect rectstroke

Box_path
     Unpacks a Box structure to a path suitable for stroke, clip, etc.

          mybox Box_path stroke

Box_border
     Creates a new Box within a specified border of an existing Box.

          mybox 10 mm Box_bqorder
          /smallbox exch def

Box_vsplit
     Splits a box vertically into a number of equal sized boxes.  Spacing
     and padding variables should also be specified to control the sizes
     and relative positions of the new boxes.

          % split /mybox into 3 new Box objects, /upper, /middle and
          % /lower, padded 10 mm within existing /mybox and spaced
          % 5 mm apart from each other
          mybox 3 10 mm 5 mm Box_vsplit
          /upper  exch def
          /middle exch def
          /lower  exch def

Box_hsplit
     As per Box_Vsplit but splitting a Box horizontally.

          middle 2 10 mm 5 mm Box_hsplit
          /right exch def
          /left  exch def

Box_focus
     Creates a new drawing context which is focussed on a particular Box.
     That is, all drawing will happen relative to the origin of the Box and
     be clipped within its bounds.

          middle Box_focus

Box_defocus
     Restores the previous drawing context saved by a prior Box_focus.

     =back

AUTHOR
======

   Simon Stapleton <simon@tufty.co.uk> wrote the original xml2ps.pl
utility which inspired much of the original PostScript contained herein.
Most of that, he freely admits, was gleaned from the Blue Book (PostScript
Language Tutorial and Cookbook, Adobe).

   Andy Wardley <abw@kfs.org> re-packaged it into a module for integration
into the Kite bundle.  Various features and more advanced defintions have
been added along the way.

REVISION
========

   $Revision: 1.3 $

COPYRIGHT
=========

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

TODO
====

   It would be nice to have some way of automatically managing all
dependencies between different procedures.  For example, if you call the
'circle' method then it should ensure that 'mm' and 'lines' are first
called if they haven't been called previously.

   It may make more sense to package this module as a general purpose
PostScript library and/or plugin for the Template Toolkit.

SEE ALSO
========

   For further information on the Kite::* modules, see *Note Kite: Kite,.
For further information on the Template Toolkit, see *Note Template:
Template, or http://www.template-toolkit.org/ .


File: pm.info,  Node: Kite/Profile,  Next: Kite/XML2PS,  Prev: Kite/PScript/Defs,  Up: Module List

represent and manipulate a 2d profile
*************************************

NAME
====

   Kite::Profile - represent and manipulate a 2d profile

SYNOPSIS
========

     use Kite::Profile;

     # create new profile
     my $profile = Kite::Profile->new({
     	NAME => "Profile Name",
         X    => [ $x1, $x2, $x3 ... $xn ],
         Y    => [ $y1, $y2, $y3 ... $yn ]
     });

     # load profile from file (plotfoil format)
     my $profile = Kite::Profile->new({
     	FILE => 'profiles/S2091'
     }) || die Kite::Profile->error(), "\n";

     # create profile from text string (plotfoil format)
     my $profile = Kite::Profile->new({
     	TEXT => "Profile Name\n x1 y1\n x2 y2\n ...\n"
     }) || die Kite::Profile->error(), "\n";

     # get/set the profile name
     print $profile->name();
     $profile->name("New name for this profile");

     # methods for general information and data output
     print $profile->about();
     print $profile->output();

     # methods to return specific profile characteristics
     print $profile->height();
     print $profile->length();
     print $profile->max_x();
     print $profile->min_x();
     print $profile->max_y();
     print $profile->min_y();

     # move (translate) the x or y values by a given amount
     $profile->translate_x($amount);
     $profile->translate_y($amount);

     # move the profile to zero it at the origin (minx = miny = 0)
     $profile->origin();
     $profile->origin_x();
     $profile->origin_y();

     # scale the profile by a given factor
     $profile->scale_xy($factor);
     $profile->scale_x($factor);
     $profile->scale_y($factor);

     # scale the profile to a length (x) or height (y) of 1
     $profile->normalise();
     $profile->normalise_x();
     $profile->normalise_y();

     # insert a node $n with values $x and $y
     $profile->insert($n, $x, $y)
         || warn $profile->error(), "\n";

     # delete node $n
     $profile->delete($n)
         || warn $profile->error(), "\n";

     # discard all but a sub-section of nodes
     $profile->keep($from, $to)
         || warn $profile->error(), "\n";

     # test if profile is closed (first node == last node)
     print "profile is closed\n"
         if $profile->closed();
     
     # add final node if necessary to ensure a closed profile
     $profile->close();

     # find set of X/Y values where profile crosses point on Y/X axis
     my $xpoints = $profile->x_at_y($y);
     print "profile crosses X at Y=$y at [ @$xpoints ]\n";

     my $ypoints = $profile->y_at_x($x);
     print "profile crosses Y at X=$x at [ @$ypoints ]\n";

     # retrieve number of nodes and lists of node values
     my $no_of_nodes = $profile->n_nodes();
     my ($x, $y) = $profile->nodes();
     for (my $i = 0; $i < $no_of_nodes; $i++) {
     	print "$i  x: $x->[$i]  y: $y->[$i]\n";
     }

DESCRIPTION
===========

   This module defines an object class which can be used to represent and
manipulate 2D profiles.  In this context, a profile is a set of X,Y
co-ordinates (nodes) that define the outline of a shape.

   For the original intended use in kite construction, these profiles
ultimately represent cutting patterns for pieces of fabric which are sewn
together to form the kite.  However, this module is not specific to kite
design and can be applied to any situation where you wish to represent a
2-dimensional shapes  by a set of co-ordinates and perform simple
manipulations on it (e.g. scale, translate, sub-section, etc.)

   The profile data can be output in a simple format which can be
subsequently processed (e.g. convert to Postscript) by other tools (e.g.
plotfoil).

METHODS
=======

new(\%params)
-------------

   Class constructor method to create a new profile object based on data
provided as configuration items, read from a file or provided as a text
string.  The method should be passed a reference to a hash array
containing one of the following items or sets of items.

NAME, X, Y
     Specify the profile name, and X and Y values for each of the points
     that constitute the profile.  The X and Y values should be specified
     as references to lists.

          my $profile = Kite::Profile->new({
          	NAME => 'Peter Lynn "Pilot" 4m^2 - Flare'
              X    => [ 2250, 985, 110, 0, 2250 ],
          	Y    => [ 0, 480, 280, 0, 0 ],
          });

FILE
     Specify a filename from which the profile data should be read.

          my $profile = Kite::Profile->new({
          	FILE => '/home/abw/kites/pilot/rib'
          });

     The constructor returns undef if the file cannot be opened.  The
     error() class method can be called to retrieve the specific error
     message.

          my $profile = Kite::Profile->new({
          	FILE => '/home/abw/kites/pilot/rib'
          }) || die Kite::Profile->error();

     The expected file format is as per Plotfoil:

          Name of the profile
          x1  y1
          x2  y2
          .   .
          .   .
          xn  yn

     Comments (lines starting with # or %) are ignored, as are blank lines.

     Example:

          Peter Lynn "Pilot" 4m^2 - Rib
          # either:
          #   cut 5 of these
          # or:
          #   cut 2 of these and cut the other 3 with the flares (30mm overlap)
          2330    0
          2330   20
           350  270
           300  277
             .    .
             .    .
          2330    0

TEXT
     This option allows you to specify the profile data as a text string.
     The format should be as above.

          my $text =

          my $profile = Kite::Profile->new({
          	TEXT => "Peter Lynn \"Pilot\" 4m^2 - Rib\n2330 0\n2330 20\n...";
          });

name()
------

   Returns the profile name.  Can also be called with an argument to set a
new name.

     $profile->name("New name for the profile");

length()
--------

   Returns the profile length (max_x - min_x).

height()
--------

   Returns the profile height (max_y - min_y).

min_x()
-------

   Returns the smallest X value.

max_x()
-------

   Returns the largest X value.

min_y()
-------

   Returns the smallest Y value.

max_y()
-------

   Returns the largest Y value.

translate_x($amount)
--------------------

   Add a given amount to all the X values, effectively moving the profile
in the X direction.

translate_y($amount)
--------------------

   Add a given amount to all the Y values, effectively moving the profile
in the Y direction.

origin()
--------

   Translates the profile to the origin so that both minx and max are 0.

origin_x()
----------

   Translates the profile X values so that minx is 0.

origin_y()
----------

   Translates the profile Y values so that miny is 0.

scale_x($factor)
----------------

   Multiply all the X values by a given amount, effectively scaling the
profile in the X direction.

scale_y($factor)
----------------

   Multiply all the Y values by a given amount, effectively scaling the
profile in the Y direction.

scale_xy($factor)
-----------------

   Multiply all the X and Y values by a given amount, effectively scaling
the profile in both X and Y directions.

normalise_x()
-------------

   Scales the X values (by 1/length) to achieve a profile length of 1.
The profile is moved along the X axis to ensure that min_x is 0.  The
max_x value is then 1 and all other values lie proportionately between 0
and 1.

normalise_y()
-------------

   Scales the Y values (by 1/height) to acheive a profile height of 1.
The profile is *NOT* translated to min_x = 0 to ensure that the original
centre line position of the profile is preserved.  range 0 - 1.

normalise()
-----------

   Normalises the profile to a length of 1 (see normalise_x()) and then
scales the Y values by the same factor (1/length).  The end result is a
proportionately scaled profile of length 1.

insert($node, $x, $y)
---------------------

   Inserts a new node at the position specified by $node with the $x and $y
values.  The value for $node should be in the range 0 - $nnodes.  The
existing node $n and any elements following will be shifted futher down
the list by one to make room for the new element.  An element inserted at
$node position 0 is added to the front of the list.  An element inserted
at a $node position one greater than the last current node will be added to
the end of the list.

   Returns 1 if the new node was successfully inserted or undef on error.

delete($node)
-------------

   Deletes the node at the position specified by $node and moves the
remaining items in the list up by one to close the gap.

   Returns 1 if the node was sucessfully inserted or undef on error.

keep($from, $to)
----------------

   Reduces the profile to a sub-section of nodes identified by $from and
$to.  These should be specified as node numbers from 0 to n_nodes-1.  The
nodes in this range (inclusively) are kept to form the new profile and the
others are discarded.

closed()
--------

   Returns a true/false value to indicate if the profile is closed.  That
is, if the first and last nodes contain identical X and Y values.

close()
-------

   Duplicates the first node at the end of the list to ensure that the
profile is closed.  Has no effect if the profile is already closed.

x_at_y($y)
----------

   Returns a reference to a list of X values where the profile crosses
point $y on the Y axis.  The profile must be closed.  The list returned
will be empty if the profile does not cross the specified point or will
contain an even number of items if it does.  Each pair of items thus
represents an entry/exit transition into/out of the enclosed profile area
for increasing values of X at a fixed Y.

   Returns undef on error (e.g. profile not closed).

y_at_x($x)
----------

   Returns a reference to a list of Y values where the profile crosses
point $y on the X axis.  Otherwise similar to x_at_y() above.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

VERSION
=======

   $Revision: 1.3 $

COPYRIGHT
=========

   Copyright (C) 2000 Andy Wardley.  All Rights Reserved.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `okprof|okprof' in this node, `Kite|Kite' in this node,
`Kite::Base|Kite::Base' in this node


