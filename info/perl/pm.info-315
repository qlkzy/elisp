This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Pod/XML,  Next: Pod/foo,  Prev: Pod/Usage,  Up: Module List

Module to convert POD to XML
****************************

NAME
====

   Pod::XML - Module to convert POD to XML

SYNOPSIS
========

     use Pod::XML;
     my $parser = Pod::XML->new();
     $parser->parse_from_file("foo.pod");

DESCRIPTION
===========

   This module uses Pod::Parser to parse POD and generates XML from the
resulting parse stream. It uses its own format, described below.

XML FORMAT
==========

   The XML format is not a standardised format - if you wish to generate
some standard XML format such as docbook, please use a tool such as XSLT
to convert between this and that format.

   The format uses the namespace "http://axkit.org/ns/2000/pod2xml". Do not
try and request this URI - it is virtual. You will get a 404.

   The best way to describe the format is to show you:

     <pod xmlns="http://axkit.org/ns/2000/pod2xml">
       <head>
         <title>The first =head1 goes in here</title>
       </head>
       <sect1>
       <title>Subsequent =head1's create a sect1</title>
         <para>
         Ordinary paragraphs of text create a para tag.
         </para>
         <verbatim><![CDATA[
         Indented verbatim sections go in verbatim tags using a CDATA
         section rather than XML escaping.
         ]]></verbatim>
         <sect2>
         <title>=head2's go in sect2</title>
           <para>
           Up to =head4 is supported (despite not really being
           supported by pod), producing sect3 and
           sect4 respectively for =head3 and =head4.
           </para>
           <para>
           Bold text goes in a <strong>strong</strong> tag.
           </para>
           <para>
           Italic text goes in a <emphasis>emphasis</emphasis> tag.
           </para>
           <para>
           Code goes in a <code>code</code> tag.
           </para>
           <para>
           Lists (=over, =item, =back) go in list/item/itemtext
           tags. The itemtext element is only present if the
           =item text is <strong>not</strong> the "*" character.
           </para>
         </sect2>
       </sect1>
     </pod>

   If the first =head1 is "NAME" (like standard perl modules are supposed
to be) it takes the next paragraph as the document title. Other standard
head elements of POD are left unchanged (particularly, the SYNOPSIS and
DESCRIPTION elements of standard POD).

   Pod::XML tries to be careful about nesting sects based on the head
level in the original POD. Let me know if this doesn't work for you.

AUTHOR
======

   Matt Sergeant, matt@sergeant.org

SEE ALSO
========

   Pod::Parser

BUGS
====

   There is no xml2pod.

   POD L<> sections are barely implemented. Expect to see the <link> tag
contents change as I get more of a hang of how to parse it.

LICENSE
=======

   This is free software, you may use it and distribute it under the same
terms as Perl itself.


File: pm.info,  Node: Pod/foo,  Next: Pod/newrun,  Prev: Pod/XML,  Up: Module List

   perlvar - Perl predefined variables

   The following names have special meaning to Perl. Most of the
punctuational names have reasonable mnemonics, or analogues in one of the
shells. Nevertheless, if you wish to use the long variable names, you just
need to say

     use English;

   at the top of your program. This will alias all the short names to the
long names in the current package. Some of them even have medium names,
generally borrowed from *awk*.

   To go a step further, those variables that depend on the currently
selected filehandle may instead be set by calling an object method on the
FileHandle object. (Summary lines below for this contain the word HANDLE.)
First you must say

     use FileHandle;

   after which you may use either

     method HANDLE EXPR

   or

     HANDLE->method(EXPR)

   Each of the methods returns the old value of the FileHandle attribute.
The methods each take an optional EXPR, which if supplied specifies the new
value for the FileHandle attribute in question. If not supplied, most of
the methods do nothing to the current value, except for *autoflush()*,
which will assume a 1 for you, just to be different.

   A few of these variables are considered "read-only". This means that if
you try to assign to this variable, either directly or indirectly through
a reference, you'll raise a run-time exception.

X<$ARG>
X<$_>
     The default input and pattern-searching space. The following pairs are
     equivalent:

          while (<>) {...}    # only equivalent in while!
          while ($_ = <>) {...}

          /^Subject:/
          $_ =~ /^Subject:/

          tr/a-z/A-Z/
          $_ =~ tr/a-z/A-Z/

          chop
          chop($_)

     Here are the places where Perl will assume `$_' even if you don't use
     it:


     Various unary functions, including functions like *ord()* and *int()*,
     as well as the all file tests (-f, -d) except for -t, which defaults
     to STDIN.


     Various list functions like *print()* and *unlink()*.


     The pattern matching operations m//, s///, and tr/// when used
     without an `=~' operator.


     The default iterator variable in a foreach loop if no other variable
     is supplied.


     The implicit iterator variable in the *grep()* and *map()* functions.


     The default place to put an input record when a `<FH>' operation's
     result is tested by itself as the sole criterion of a while test.
     Note that outside of a while test, this will not happen.

     (Mnemonic: underline is understood in certain operations.)

X<$<digit;$<digit>>
     Contains the subpattern from the corresponding set of parentheses in
     the last pattern matched, not counting patterns matched in nested
     blocks that have been exited already. (Mnemonic: like \digit.) These
     variables are all read-only.

X<$MATCH>
X<$&>
     The string matched by the last successful pattern match (not counting
     any matches hidden within a BLOCK or *eval()* enclosed by the current
     BLOCK). (Mnemonic: like & in some editors.) This variable is
     read-only.

X<$PREMATCH>
X<$`>
     The string preceding whatever was matched by the last successful
     pattern match (not counting any matches hidden within a BLOCK or eval
     enclosed by the current BLOCK). (Mnemonic: ` often precedes a quoted
     string.) This variable is read-only.

X<$POSTMATCH>
X<$'>
     The string following whatever was matched by the last successful
     pattern match (not counting any matches hidden within a BLOCK or
     *eval()* enclosed by the current BLOCK). (Mnemonic: ' often follows a
     quoted string.) Example:

          $_ = 'abcdefghi';
          /def/;
          print "$`:$&:$'\n";         # prints abc:def:ghi

     This variable is read-only.

X<$LAST_PAREN_MATCH>
X<$+>
     The last bracket matched by the last search pattern. This is useful
     if you don't know which of a set of alternative patterns matched. For
     example:

          /Version: (.*)|Revision: (.*)/ && ($rev = $+);

     (Mnemonic: be positive and forward looking.) This variable is
     read-only.

X<$MULTILINE_MATCHING>

     Set to 1 to do multiline matching within a string, 0 to tell Perl
     that it can assume that strings contain a single line, for the
     purpose of optimizing pattern matches. Pattern matches on strings
     containing multiple newlines can produce confusing results when $* is
     0. Default is 0.  (Mnemonic: * matches multiple things.) Note that
     this variable only influences the interpretation of ^ and `$'. A
     literal newline can be searched for even when `$* == 0'.

     Use of $* is deprecated in Perl 5.

X<input_line_number> HANDLE EXPR
X<$INPUT_LINE_NUMBER>
X<$NR>
X<$.>
     The current input line number of the last filehandle that was read. An
     explicit close on the filehandle resets the line number. Since `<>'
     never does an explicit close, line numbers increase across ARGV files
     (but see examples under *eof()*). Localizing $. has the effect of also
     localizing Perl's notion of "the last read filehandle". (Mnemonic:
     many programs use "." to mean the current line number.)

X<input_record_separator> HANDLE EXPR
X<$INPUT_RECORD_SEPARATOR>
X<$RS>
X<$/>
     The input record separator, newline by default. Works like *awk*'s RS
     variable, including treating blank lines as delimiters if set to the
     null string. You may set it to a multicharacter string to match a
     multi-character delimiter. Note that setting it to `"\n\n"' means
     something slightly different than setting it to "", if the file
     contains consecutive blank lines. Setting it to "" will treat two or
     more consecutive blank lines as a single blank line. Setting it to
     `"\n\n"' will blindly assume that the next input character belongs to
     the next paragraph, even if it's a newline. (Mnemonic: / is used to
     delimit line boundaries when quoting poetry.)

          undef $/;
          $_ = <FH>;          # whole file now here
          s/\n[ \t]+/ /g;

X<autoflush> HANDLE EXPR
X<$OUTPUT_AUTOFLUSH>
X<$|>
     If set to nonzero, forces a flush after every write or print on the
     currently selected output channel. Default is 0. Note that STDOUT will
     typically be line buffered if output is to the terminal and block
     buffered otherwise. Setting this variable is useful primarily when
     you are outputting to a pipe, such as when you are running a Perl
     script under rsh and want to see the output as it's happening. This
     has no effect on input buffering. (Mnemonic: when you want your pipes
     to be piping hot.)

X<output_field_separator> HANDLE EXPR
X<$OUTPUT_FIELD_SEPARATOR>
X<$OFS>
X<$,>
     The output field separator for the print operator. Ordinarily the
     print operator simply prints out the comma separated fields you
     specify. In order to get behavior more like *awk*, set this variable
     as you would set *awk*'s OFS variable to specify what is printed
     between fields.  (Mnemonic: what is printed when there is a , in your
     print statement.)

X<output_record_separator> HANDLE EXPR
X<$OUTPUT_RECORD_SEPARATOR>
X<$ORS>
X<$\>
     The output record separator for the print operator. Ordinarily the
     print operator simply prints out the comma separated fields you
     specify, with no trailing newline or record separator assumed. In
     order to get behavior more like *awk*, set this variable as you would
     set *awk*'s ORS variable to specify what is printed at the end of the
     print. (Mnemonic: you set $\ instead of adding \n at the end of the
     print. Also, it's just like /, but it's what you get "back" from
     Perl.)

X<$LIST_SEPARATOR>
X<$">
     This is like $, except that it applies to array values interpolated
     into a double-quoted string (or similar interpreted string). Default
     is a space. (Mnemonic: obvious, I think.)

X<$SUBSCRIPT_SEPARATOR>
X<$SUBSEP>
X<$;>
     The subscript separator for multi-dimensional array emulation. If you
     refer to a hash element as

          $foo{$a,$b,$c}

     it really means

          $foo{join($;, $a, $b, $c)}

     But don't put

          @foo{$a,$b,$c}      # a slice--note the @

     which means

          ($foo{$a},$foo{$b},$foo{$c})

     Default is "\034", the same as SUBSEP in *awk*. Note that if your keys
     contain binary data there might not be any safe value for $;.
     (Mnemonic: comma (the syntactic subscript separator) is a
     semi-semicolon.  Yeah, I know, it's pretty lame, but $, is already
     taken for something more important.)

     Consider using "real" multi-dimensional arrays in Perl 5.

X<$OFMT>
X<$#>
     The output format for printed numbers. This variable is a half-hearted
     attempt to emulate *awk*'s OFMT variable. There are times, however,
     when *awk* and Perl have differing notions of what is in fact
     numeric. Also, the initial value is %.20g rather than %.6g, so you
     need to set $# explicitly to get *awk*'s value. (Mnemonic: # is the
     number sign.)

     Use of $# is deprecated in Perl 5.

X<format_page_number> HANDLE EXPR
X<$FORMAT_PAGE_NUMBER>
X<$%>
     The current page number of the currently selected output channel.
     (Mnemonic: % is page number in *nroff*.)

X<format_lines_per_page> HANDLE EXPR
X<$FORMAT_LINES_PER_PAGE>
X<$=>
     The current page length (printable lines) of the currently selected
     output channel. Default is 60. (Mnemonic: = has horizontal lines.)

X<format_lines_left> HANDLE EXPR
X<$FORMAT_LINES_LEFT>
X<$->
     The number of lines left on the page of the currently selected output
     channel. (Mnemonic: lines_on_page - lines_printed.)

X<format_name> HANDLE EXPR
X<$FORMAT_NAME>
X<$~>
     The name of the current report format for the currently selected
     output channel. Default is name of the filehandle. (Mnemonic: brother
     to $^.)

X<format_top_name> HANDLE EXPR
X<$FORMAT_TOP_NAME>
X<$^>
     The name of the current top-of-page format for the currently selected
     output channel. Default is name of the filehandle with _TOP appended.
     (Mnemonic: points to top of page.)

X<format_line_break_characters> HANDLE EXPR
X<$FORMAT_LINE_BREAK_CHARACTERS>
X<$:>
     The current set of characters after which a string may be broken to
     fill continuation fields (starting with ^) in a format. Default is
     " \n-", to break on whitespace or hyphens. (Mnemonic: a "colon" in
     poetry is a part of a line.)

X<format_formfeed> HANDLE EXPR
X<$FORMAT_FORMFEED>
X<$^L>
     What formats output to perform a formfeed. Default is \f.

X<$ACCUMULATOR>
X<$^A>
     The current value of the *write()* accumulator for *format()* lines.
     A format contains *formline()* commands that put their result into
     $^A. After calling its format, *write()* prints out the contents of
     $^A and empties. So you never actually see the contents of $^A unless
     you call *formline()* yourself and then look at it. See
     `ARRAY(0xd73c0)<' in this node> and `ARRAY(0xd7054)<' in this node>.

X<$CHILD_ERROR>
X<$?>
     The status returned by the last pipe close, backtick (```') command,
     or *system()* operator. Note that this is the status word returned by
     the *wait()* system call, so the exit value of the subprocess is
     actually (`$? >> 8'). Thus on many systems, `$? & 255' gives which
     signal, if any, the process died from, and whether there was a core
     dump. (Mnemonic: similar to *sh* and *ksh*.)

X<$OS_ERROR>
X<$ERRNO>
X<$!>
     If used in a numeric context, yields the current value of errno, with
     all the usual caveats. (This means that you shouldn't depend on the
     value of $!  to be anything in particular unless you've gotten a
     specific error return indicating a system error.) If used in a string
     context, yields the corresponding system error string. You can assign
     to $! in order to set errno if, for instance, you want $! to return
     the string for error n, or you want to set the exit value for the
     *die()* operator. (Mnemonic: What just went bang?)

X<$EVAL_ERROR>
X<$@>
     The Perl syntax error message from the last *eval()* command. If null,
     the last *eval()* parsed and executed correctly (although the
     operations you invoked may have failed in the normal fashion).
     (Mnemonic: Where was the syntax error "at"?)

     Note that warning messages are not collected in this variable. You
     can, however, set up a routine to process warnings by setting
     `$SIG'{__WARN__} below.

X<$PROCESS_ID>
X<$PID>
X<$$>
     The process number of the Perl running this script. (Mnemonic: same as
     shells.)

X<$REAL_USER_ID>
X<$UID>
X<$<;$<>
     The real uid of this process. (Mnemonic: it's the uid you came
     *FROM*, if you're running setuid.)

X<$EFFECTIVE_USER_ID>
X<$EUID>
X<$>>
     The effective uid of this process. Example:

          $< = $>;       # set real to effective uid
          ($<,$>) = ($>,$<);  # swap real and effective uid

     (Mnemonic: it's the uid you went TO, if you're running setuid.) Note:
     `$<' and `$>' can only be swapped on machines supporting *setreuid()*.

X<$REAL_GROUP_ID>
X<$GID>
X<$(>
     The real gid of this process. If you are on a machine that supports
     membership in multiple groups simultaneously, gives a space separated
     list of groups you are in. The first number is the one returned by
     *getgid()*, and the subsequent ones by *getgroups()*, one of which
     may be the same as the first number. (Mnemonic: parentheses are used
     to *GROUP* things.  The real gid is the group you *LEFT*, if you're
     running setgid.)

X<$EFFECTIVE_GROUP_ID>
X<$EGID>
X<$)>
     The effective gid of this process. If you are on a machine that
     supports membership in multiple groups simultaneously, gives a space
     separated list of groups you are in. The first number is the one
     returned by *getegid()*, and the subsequent ones by *getgroups()*,
     one of which may be the same as the first number. (Mnemonic:
     parentheses are used to *GROUP* things.  The effective gid is the
     group that's *RIGHT* for you, if you're running setgid.)

     Note: `$<', `$>', $( and $) can only be set on machines that support
     the corresponding *set[re][ug]*id()** routine. $( and $) can only be
     swapped on machines supporting *setregid()*. Because Perl doesn't
     currently use *initgroups()*, you can't set your group vector to
     multiple groups.

X<$PROGRAM_NAME>

X<$0>
     Contains the name of the file containing the Perl script being
     executed.  Assigning to $0 modifies the argument area that the
     *ps(1)* program sees. This is more useful as a way of indicating the
     current program state than it is for hiding the program you're
     running. (Mnemonic: same as *sh* and *ksh*.)

X<$[>
     The index of the first element in an array, and of the first
     character in a substring. Default is 0, but you could set it to 1 to
     make Perl behave more like *awk* (or Fortran) when subscripting and
     when evaluating the *index()* and *substr()* functions. (Mnemonic: [
     begins subscripts.)

     As of Perl 5, assignment to $[ is treated as a compiler directive, and
     cannot influence the behavior of any other file. Its use is
     discouraged.

X<$PERL_VERSION>
X<$]>
     The string printed out when you say `perl -v'. (This is currently
     *BROKEN*).  It can be used to determine at the beginning of a script
     whether the perl interpreter executing the script is in the right
     range of versions. If used in a numeric context, returns the version
     + patchlevel / 1000.  Example:

          # see if getc is available
          ($version,$patchlevel) =
                   $] =~ /(\d+\.\d+).*\nPatch level: (\d+)/;
          print STDERR "(No filename completion available.)\n"
                   if $version * 1000 + $patchlevel < 2016;

     or, used numerically,

          warn "No checksumming!\n" if $] < 3.019;

     (Mnemonic: Is this version of perl in the right bracket?)

X<$DEBUGGING>
X<$^D>
     The current value of the debugging flags. (Mnemonic: value of
     -D;switches/-D;-D switch.)

X<$SYSTEM_FD_MAX>
X<$^F>
     The maximum system file descriptor, ordinarily 2. System file
     descriptors are passed to *exec()*ed processes, while higher file
     descriptors are not. Also, during an *open()*, system file
     descriptors are preserved even if the *open()* fails. (Ordinary file
     descriptors are closed before the *open()* is attempted.) Note that
     the close-on-exec status of a file descriptor will be decided
     according to the value of $^F at the time of the open, not the time
     of the exec.

X<$INPLACE_EDIT>
X<$^I>
     The current value of the inplace-edit extension. Use undef to disable
     inplace editing. (Mnemonic: value of -i;switches/-i;-i switch.)

X<$PERLDB>
X<$^P>
     The internal flag that the debugger clears so that it doesn't debug
     itself. You could conceivable disable debugging yourself by clearing
     it.

X<$BASETIME>
X<$^T>
     The time at which the script began running, in seconds since the epoch
     (beginning of 1970). The values returned by the -M;switches/-M;-M,
     -A;switches/-A;-A and -C;switches/-C;-C filetests are based on this
     value.

X<$WARNING>
X<$^W>
     The current value of the warning switch, either TRUE or FALSE.
     (Mnemonic: related to the -w;switches/-w;-w switch.)

X<$EXECUTABLE_NAME>
X<$^X>
     The name that the Perl binary itself was executed as, from C's
     `argv[0]'.

X<$ARGV>
     contains the name of the current file when reading from <>.

X<@ARGV>
     The array `@ARGV' contains the command line arguments intended for the
     script. Note that `$#ARGV' is the generally number of arguments minus
     one, since `$ARGV[0]' is the first argument, *NOT* the command name.
     See $0 for the command name.

X<@INC>
     The array `@INC' contains the list of places to look for Perl scripts
     to be evaluated by the `do EXPR', require, or use constructs. It
     initially consists of the arguments to any -I;switches/-I;-I command
     line switches, followed by the default Perl library, probably
     "/usr/local/lib/perl", followed by ".", to represent the current
     directory. If you need to modify this at runtime, you should use the
     `use lib' pragma in order to also get the machine-dependent library
     properly loaded:

          use lib '/mypath/libdir/';
          use SomeMod;

X<%INC>
     The hash `%INC' contains entries for each filename that has been
     included via do or require. The key is the filename you specified,
     and the value is the location of the file actually found. The require
     command uses this array to determine whether a given file has already
     been included.

X<$ENV{expr}>
     The hash `%ENV' contains your current environment. Setting a value in
     ENV changes the environment for child processes.

X<$SIG{expr}>
     The hash `%SIG' is used to set signal handlers for various signals.
     Example:

          sub handler {       # 1st argument is signal name
              local($sig) = @_;
              print "Caught a SIG$sig--shutting down\n";
              close(LOG);
              exit(0);
          }

          $SIG{'INT'} = 'handler';
          $SIG{'QUIT'} = 'handler';
          ...
          $SIG{'INT'} = 'DEFAULT';    # restore default action
          $SIG{'QUIT'} = 'IGNORE';    # ignore SIGQUIT

     The `%SIG' array only contains values for the signals actually set
     within the Perl script. Here are some other examples:

          $SIG{PIPE} = Plumber;       # SCARY!!
          $SIG{"PIPE"} = "Plumber";   # just fine, assumes main::Plumber
          $SIG{"PIPE"} = \&Plumber;   # just fine; assume current Plumber
          $SIG{"PIPE"} = Plumber();   # oops, what did Plumber() return??

     The one marked scary is problematic because it's a bareword, which
     means sometimes it's a string representing the function, and
     sometimes it's going to call the subroutine call right then and
     there! Best to be sure and quote it or take a reference to it.
     *Plumber works too. See `ARRAY(0xd7228)<' in this node>.

     Certain internal hooks can be also set using the `%SIG' hash. The
     routine indicated by `$SIG'{__WARN__} is called when a warning message
     is about to be printed. The warning message is passed as the first
     argument. The presence of a __WARN__ hook causes the ordinary
     printing of warnings to STDERR to be suppressed. You can use this to
     save warnings in a variable, or turn warnings into fatal errors, like
     this:

          local $SIG{__WARN__} = sub { die $_[0] };
          eval $proggie;

     The routine indicated by `$SIG'{__DIE__} is called when a fatal
     exception is about to be thrown. The error message is passed as the
     first argument. When a __DIE__ hook routine returns, the exception
     processing continues as it would have in the absence of the hook,
     unless the hook routine itself exits via a goto, a loop exit, or a
     *die()*. The __DIE__ handler is explicitly disabled during the call,
     so that you can die from a __DIE__ handler. Similarly for __WARN__.


File: pm.info,  Node: Pod/newrun,  Next: Pod/newvar,  Prev: Pod/foo,  Up: Module List

how to execute the Perl interpreter
***********************************

NAME
====

   perlrun - how to execute the Perl interpreter

SYNOPSIS
========

   *perl* [switches] filename args

DESCRIPTION
===========

   Upon startup, Perl looks for your script in one of the following places:

  1. Specified line by line via -e switches on the command line.

  2. Contained in the file specified by the first filename on the command
     line.  (Note that systems supporting the #! notation invoke
     interpreters this way.)

  3. Passed in implicitly via standard input.  This only works if there are
     no filename arguments-to pass arguments to a STDIN script you must
     explicitly specify a "-" for the script name.

        With methods 2 and 3, Perl starts parsing the input file from the
beginning, unless you've specified a -x switch, in which case it scans for
the first line starting with #! and containing the word "perl", and starts
there instead.  This is useful for running a script embedded in a larger
message.  (In this case you would indicate the end of the script using the
__END__ token.)

   As of Perl 5, the #! line is always examined for switches as the line is
being parsed.  Thus, if you're on a machine that only allows one argument
with the #! line, or worse, doesn't even recognize the #! line, you still
can get consistent switch behavior regardless of how Perl was invoked,
even if -x was used to find the beginning of the script.

   Because many operating systems silently chop off kernel interpretation
of the #! line after 32 characters, some switches may be passed in on the
command line, and some may not; you could even get a "-" without its
letter, if you're not careful.  You probably want to make sure that all
your switches fall either before or after that 32 character boundary.
Most switches don't actually care if they're processed redundantly, but
getting a - instead of a complete switch could cause Perl to try to
execute standard input instead of your script.  And a partial -I switch
could also cause odd results.

   Parsing of the #! switches starts wherever "perl" is mentioned in the
line.  The sequences "-*" and "- " are specifically ignored so that you
could, if you were so inclined, say

     #!/bin/sh -- # -*- perl -*- -p
     eval 'exec perl $0 -S ${1+"$@"}'
     	if 0;

   to let Perl see the -p switch.

   If the #! line does not contain the word "perl", the program named after
the #! is executed instead of the Perl interpreter.  This is slightly
bizarre, but it helps people on machines that don't do #!, because they
can tell a program that their SHELL is /usr/bin/perl, and Perl will then
dispatch the program to the correct interpreter for them.

   After locating your script, Perl compiles the entire script to an
internal form.  If there are any compilation errors, execution of the
script is not attempted.  (This is unlike the typical shell script, which
might run partway through before finding a syntax error.)

   If the script is syntactically correct, it is executed.  If the script
runs off the end without hitting an exit() or die() operator, an implicit
`exit(0)' is provided to indicate successful completion.

Switches
--------

   A single-character switch may be combined with the following switch, if
any.

     #!/usr/bin/perl -spi.bak	# same as -s -p -i.bak

   Switches include:

-0digits
     specifies the record separator ($/) as an octal number.  If there are
     no digits, the null character is the separator.  Other switches may
     precede or follow the digits.  For example, if you have a version of
     find which can print filenames terminated by the null character, you
     can say this:

          find . -name '*.bak' -print0 | perl -n0e unlink

     The special value 00 will cause Perl to slurp files in paragraph mode.
     The value 0777 will cause Perl to slurp files whole since there is no
     legal character with that value.

-a
     turns on autosplit mode when used with a -n or -p.  An implicit split
     command to the @F array is done as the first thing inside the
     implicit while loop produced by the -n or -p.

          perl -ane 'print pop(@F), "\n";'

     is equivalent to

          while (<>) {
          	@F = split(' ');
          	print pop(@F), "\n";
          }

     An alternate delimiter may be specified using -F.

-c
     causes Perl to check the syntax of the script and then exit without
     executing it.  Actually, it will execute BEGIN and use blocks, since
     these are considered part of the compilation.

-d
     runs the script under the Perl debugger.  See *Note Perldebug:
     (perl.info)perldebug,.

-Dnumber
-Dlist
     sets debugging flags.  To watch how it executes your script, use
     *-D14*.  (This only works if debugging is compiled into your Perl.)
     Another nice value is *-D1024*, which lists your compiled syntax
     tree.  And *-D512* displays compiled regular expressions. As an
     alternative specify a list of letters instead of numbers (e.g. *-D14*
     is equivalent to *-Dtls*):

          1  p  Tokenizing and Parsing
          2  s  Stack Snapshots
          4  l  Label Stack Processing
          8  t  Trace Execution
                 16  o  Operator Node Construction
                 32  c  String/Numeric Conversions
                 64  P  Print Preprocessor Command for -P
                128  m  Memory Allocation
                256  f  Format Processing
                512  r  Regular Expression Parsing
               1024  x  Syntax Tree Dump
               2048  u  Tainting Checks
               4096  L  Memory Leaks (not supported anymore)
               8192  H  Hash Dump -- usurps values()
              16384  X  Scratchpad Allocation
              32768  D  Cleaning Up

-e *commandline*
     may be used to enter one line of script.  If -e is given, Perl will
     not look for a script filename in the argument list.  Multiple -e
     commands may be given to build up a multi-line script.  Make sure to
     use semicolons where you would in a normal program.

-Fregexp
     specifies a regular expression to split on if -a is also in effect.
     If regexp has `//' around it, the slashes will be ignored.

-i*extension*
     specifies that files processed by the `<>' construct are to be edited
     in-place.  It does this by renaming the input file, opening the output
     file by the original name, and selecting that output file as the
     default for print() statements.  The extension, if supplied, is added
     to the name of the old file to make a backup copy.  If no extension
     is supplied, no backup is made.  From the shell, saying

          $ perl -p -i.bak -e "s/foo/bar/; ... "

     is the same as using the script:

          #!/usr/bin/perl -pi.bak
          s/foo/bar/;

     which is equivalent to

          #!/usr/bin/perl
          while (<>) {
          	if ($ARGV ne $oldargv) {
          	    rename($ARGV, $ARGV . '.bak');
          	    open(ARGVOUT, ">$ARGV");
          	    select(ARGVOUT);
          	    $oldargv = $ARGV;
          	}
          	s/foo/bar/;
          }
          continue {
          	print;	# this prints to original filename
          }
          select(STDOUT);

     except that the -i form doesn't need to compare $ARGV to $oldargv to
     know when the filename has changed.  It does, however, use ARGVOUT for
     the selected filehandle.  Note that STDOUT is restored as the default
     output filehandle after the loop.

     You can use eof without parenthesis to locate the end of each input
     file, in case you want to append to each file, or reset line
     numbering (see example in `eof', *Note Perlfunc:
     (perl.info)perlfunc,).

-Idirectory
     may be used in conjunction with -P to tell the C preprocessor where
     to look for include files.  By default /usr/include and /usr/lib/perl
     are searched.

-l*octnum*
     enables automatic line-ending processing.  It has two effects:  first,
     it automatically chomps the line terminator when used with -n or -p,
     and second, it assigns "$\" to have the value of *octnum* so that any
     print statements will have that line terminator added back on.  If
     *octnum* is omitted, sets "$\" to the current value of "$/".  For
     instance, to trim lines to 80 columns:

          perl -lpe 'substr($_, 80) = ""'

     Note that the assignment `$\ = $/' is done when the switch is
     processed, so the input record separator can be different than the
     output record separator if the -l switch is followed by a -0 switch:

          gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

     This sets $\ to newline and then sets $/ to the null character.

-n
     causes Perl to assume the following loop around your script, which
     makes it iterate over filename arguments somewhat like *sed -n* or
     *awk*:

          while (<>) {
          	...		# your script goes here
          }

     Note that the lines are not printed by default.  See -p to have lines
     printed.  Here is an efficient way to delete all files older than a
     week:

          find . -mtime +7 -print | perl -nle 'unlink;'

     This is faster than using the `-exec' switch of find because you don't
     have to start a process on every filename found.

     BEGIN and END blocks may be used to capture control before or after
     the implicit loop, just as in *awk*.

-p
     causes Perl to assume the following loop around your script, which
     makes it iterate over filename arguments somewhat like *sed*:

          while (<>) {
          	...		# your script goes here
          } continue {
          	print;
          }

     Note that the lines are printed automatically.  To suppress printing
     use the -n switch.  A -p overrides a -n switch.

     BEGIN and END blocks may be used to capture control before or after
     the implicit loop, just as in awk.

-P
     causes your script to be run through the C preprocessor before
     compilation by Perl.  (Since both comments and cpp directives begin
     with the # character, you should avoid starting comments with any
     words recognized by the C preprocessor such as "if", "else" or
     "define".)

-s
     enables some rudimentary switch parsing for switches on the command
     line after the script name but before any filename arguments (or
     before a -).  Any switch found there is removed from @ARGV and sets
     the corresponding variable in the Perl script.  The following script
     prints "true" if and only if the script is invoked with a *-xyz*
     switch.

          #!/usr/bin/perl -s
          if ($xyz) { print "true\n"; }

-S
     makes Perl use the PATH environment variable to search for the script
     (unless the name of the script starts with a slash).  Typically this
     is used to emulate #! startup on machines that don't support #!, in
     the following manner:

          #!/usr/bin/perl
          eval "exec /usr/bin/perl -S $0 $*"
          	    if $running_under_some_shell;

     The system ignores the first line and feeds the script to /bin/sh,
     which proceeds to try to execute the Perl script as a shell script.
     The shell executes the second line as a normal shell command, and thus
     starts up the Perl interpreter.  On some systems $0 doesn't always
     contain the full pathname, so the -S tells Perl to search for the
     script if necessary.  After Perl locates the script, it parses the
     lines and ignores them because the variable $running_under_some_shell
     is never true.  A better construct than $* would be `${1+"$@"}', which
     handles embedded spaces and such in the filenames, but doesn't work if
     the script is being interpreted by csh.  In order to start up sh
     rather than csh, some systems may have to replace the #! line with a
     line containing just a colon, which will be politely ignored by Perl.
     Other systems can't control that, and need a totally devious
     construct that will work under any of csh, sh or Perl, such as the
     following:

          eval '(exit $?0)' && eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
          & eval 'exec /usr/bin/perl -S $0 $argv:q'
          	if 0;

-T
     forces "taint" checks to be turned on.  Ordinarily these checks are
     done only when running setuid or setgid.  See *Note Perlsec:
     (perl.info)perlsec,.

-u
     causes Perl to dump core after compiling your script.  You can then
     take this core dump and turn it into an executable file by using the
     *undump* program (not supplied).  This speeds startup at the expense
     of some disk space (which you can minimize by stripping the
     executable).  (Still, a "hello world" executable comes out to about
     200K on my machine.)  If you want to execute a portion of your script
     before dumping, use the dump() operator instead.  Note: availability
     of *undump* is platform specific and may not be available for a
     specific port of Perl.

-U
     allows Perl to do unsafe operations.  Currently the only "unsafe"
     operations are the unlinking of directories while running as
     superuser, and running setuid programs with fatal taint checks turned
     into warnings.

-v
     prints the version and patchlevel of your Perl executable.

-w
     prints warnings about identifiers that are mentioned only once, and
     scalar variables that are used before being set.  Also warns about
     redefined subroutines, and references to undefined filehandles or
     filehandles opened readonly that you are attempting to write on.  Also
     warns you if you use values as a number that doesn't look like
     numbers, using an array as though it were a scalar, if your
     subroutines recurse more than 100 deep, and innumerable other things.
     See *Note Perldiag: (perl.info)perldiag, and *Note Perltrap:
     (perl.info)perltrap,.

-x directory
     tells Perl that the script is embedded in a message.  Leading garbage
     will be discarded until the first line that starts with #! and
     contains the string "perl".  Any meaningful switches on that line will
     be applied (but only one group of switches, as with normal #!
     processing).  If a directory name is specified, Perl will switch to
     that directory before running the script.  The -x switch only
     controls the the disposal of leading garbage.  The script must be
     terminated with `__END__' if there is trailing garbage to be ignored
     (the script can process any or all of the trailing garbage via the
     DATA filehandle if desired).


File: pm.info,  Node: Pod/newvar,  Next: Pod/newvar2,  Prev: Pod/newrun,  Up: Module List

Perl predefined variables
*************************

NAME
====

   perlvar - Perl predefined variables

DESCRIPTION
===========

Predefined Names
----------------

   The following names have special meaning to Perl.  Most of the
punctuational names have reasonable mnemonics, or analogues in one of the
shells.  Nevertheless, if you wish to use the long variable names, you
just need to say

     use English;

   at the top of your program.  This will alias all the short names to the
long names in the current package.  Some of them even have medium names,
generally borrowed from *awk*.

   To go a step further, those variables that depend on the currently
selected filehandle may instead be set by calling an object method on the
FileHandle object.  (Summary lines below for this contain the word
HANDLE.)  First you must say

     use FileHandle;

   after which you may use either

     method HANDLE EXPR

   or

     HANDLE->method(EXPR)

   Each of the methods returns the old value of the FileHandle attribute.
The methods each take an optional EXPR, which if supplied specifies the
new value for the FileHandle attribute in question.  If not supplied, most
of the methods do nothing to the current value, except for autoflush(),
which will assume a 1 for you, just to be different.

   A few of these variables are considered "read-only".  This means that if
you try to assign to this variable, either directly or indirectly through
a reference, you'll raise a run-time exception.

$ARG
$_
     The default input and pattern-searching space.  The following pairs
     are equivalent:

          while (<>) {...}	# only equivalent in while!
          while ($_ = <>) {...}

          /^Subject:/
          $_ =~ /^Subject:/

          tr/a-z/A-Z/
          $_ =~ tr/a-z/A-Z/

          chop
          chop($_)

     (Mnemonic: underline is understood in certain operations.)

$<digit>
     Contains the subpattern from the corresponding set of parentheses in
     the last pattern matched, not counting patterns matched in nested
     blocks that have been exited already.  (Mnemonic: like \digit.)
     These variables are all read-only.

$MATCH
$&
     The string matched by the last successful pattern match (not counting
     any matches hidden within a BLOCK or eval() enclosed by the current
     BLOCK).  (Mnemonic: like & in some editors.)  This variable is
     read-only.

$PREMATCH
$`
     The string preceding whatever was matched by the last successful
     pattern match (not counting any matches hidden within a BLOCK or eval
     enclosed by the current BLOCK).  (Mnemonic: ` often precedes a quoted
     string.)  This variable is read-only.

$POSTMATCH
$'
     The string following whatever was matched by the last successful
     pattern match (not counting any matches hidden within a BLOCK or
     eval() enclosed by the current BLOCK).  (Mnemonic: ' often follows a
     quoted string.)  Example:

          $_ = 'abcdefghi';
          /def/;
          print "$`:$&:$'\n";  	# prints abc:def:ghi

     This variable is read-only.

$LAST_PAREN_MATCH
$+
     The last bracket matched by the last search pattern.  This is useful
     if you don't know which of a set of alternative patterns matched.  For
     example:

          /Version: (.*)|Revision: (.*)/ && ($rev = $+);

     (Mnemonic: be positive and forward looking.)  This variable is
     read-only.

$MULTILINE_MATCHING

     Set to 1 to do multiline matching within a string, 0 to tell Perl
     that it can assume that strings contain a single line, for the purpose
     of optimizing pattern matches.  Pattern matches on strings containing
     multiple newlines can produce confusing results when "$*" is 0.
     Default is 0.  (Mnemonic: * matches multiple things.)  Note that this
     variable only influences the interpretation of "^" and "`$'".  A
     literal newline can be searched for even when `$* == 0'.

     Use of "$*" is deprecated in Perl 5.

input_line_number HANDLE EXPR
$INPUT_LINE_NUMBER
$NR
$.
     The current input line number of the last filehandle that was read.
     An explicit close on the filehandle resets the line number.  Since
     "`<>'" never does an explicit close, line numbers increase across
     ARGV files (but see examples under eof()).  Localizing $. has the
     effect of also localizing Perl's notion of "the last read
     filehandle".  (Mnemonic: many programs use "." to mean the current
     line number.)

input_record_separator HANDLE EXPR
$INPUT_RECORD_SEPARATOR
$RS
$/
     The input record separator, newline by default.  Works like *awk*'s RS
     variable, including treating blank lines as delimiters if set to the
     null string.  You may set it to a multicharacter string to match a
     multi-character delimiter.  Note that setting it to `"\n\n"' means
     something slightly different than setting it to "", if the file
     contains consecutive blank lines.  Setting it to "" will treat two or
     more consecutive blank lines as a single blank line.  Setting it to
     `"\n\n"' will blindly assume that the next input character belongs to
     the next paragraph, even if it's a newline.  (Mnemonic: / is used to
     delimit line boundaries when quoting poetry.)

          undef $/;
          $_ = <FH>; 		# whole file now here
          s/\n[ \t]+/ /g;

autoflush HANDLE EXPR
$OUTPUT_AUTOFLUSH
$|
     If set to nonzero, forces a flush after every write or print on the
     currently selected output channel.  Default is 0.  Note that STDOUT
     will typically be line buffered if output is to the terminal and block
     buffered otherwise.  Setting this variable is useful primarily when
     you are outputting to a pipe, such as when you are running a Perl
     script under rsh and want to see the output as it's happening.
     (Mnemonic: when you want your pipes to be piping hot.)

output_field_separator HANDLE EXPR
$OUTPUT_FIELD_SEPARATOR
$OFS
$,
     The output field separator for the print operator.  Ordinarily the
     print operator simply prints out the comma separated fields you
     specify.  In order to get behavior more like *awk*, set this variable
     as you would set *awk*'s OFS variable to specify what is printed
     between fields.  (Mnemonic: what is printed when there is a , in your
     print statement.)

output_record_separator HANDLE EXPR
$OUTPUT_RECORD_SEPARATOR
$ORS
$\
     The output record separator for the print operator.  Ordinarily the
     print operator simply prints out the comma separated fields you
     specify, with no trailing newline or record separator assumed.  In
     order to get behavior more like *awk*, set this variable as you would
     set *awk*'s ORS variable to specify what is printed at the end of the
     print.  (Mnemonic: you set "$\" instead of adding \n at the end of the
     print.  Also, it's just like /, but it's what you get "back" from
     Perl.)

$LIST_SEPARATOR
$"
     This is like "$," except that it applies to array values interpolated
     into a double-quoted string (or similar interpreted string).  Default
     is a space.  (Mnemonic: obvious, I think.)

$SUBSCRIPT_SEPARATOR
$SUBSEP
$;
     The subscript separator for multi-dimensional array emulation.  If you
     refer to a hash element as

          $foo{$a,$b,$c}

     it really means

          $foo{join($;, $a, $b, $c)}

     But don't put

          @foo{$a,$b,$c}	# a slice--note the @

     which means

          ($foo{$a},$foo{$b},$foo{$c})

     Default is "\034", the same as SUBSEP in *awk*.  Note that if your
     keys contain binary data there might not be any safe value for "$;".
     (Mnemonic: comma (the syntactic subscript separator) is a
     semi-semicolon.  Yeah, I know, it's pretty lame, but "$," is already
     taken for something more important.)

     Consider using "real" multi-dimensional arrays in Perl 5.

$OFMT
$#
     The output format for printed numbers.  This variable is a
     half-hearted attempt to emulate *awk*'s OFMT variable.  There are
     times, however, when *awk* and Perl have differing notions of what is
     in fact numeric.  Also, the initial value is %.20g rather than %.6g,
     so you need to set "$#" explicitly to get *awk*'s value.  (Mnemonic:
     # is the number sign.)

     Use of "$#" is deprecated in Perl 5.

format_page_number HANDLE EXPR
$FORMAT_PAGE_NUMBER
$%
     The current page number of the currently selected output channel.
     (Mnemonic: % is page number in *nroff*.)

format_lines_per_page HANDLE EXPR
$FORMAT_LINES_PER_PAGE
$=
     The current page length (printable lines) of the currently selected
     output channel.  Default is 60.  (Mnemonic: = has horizontal lines.)

format_lines_left HANDLE EXPR
$FORMAT_LINES_LEFT
$-
     The number of lines left on the page of the currently selected output
     channel.  (Mnemonic: lines_on_page - lines_printed.)

format_name HANDLE EXPR
$FORMAT_NAME
$~
     The name of the current report format for the currently selected
     output channel.  Default is name of the filehandle.  (Mnemonic:
     brother to "$^".)

format_top_name HANDLE EXPR
$FORMAT_TOP_NAME
$^
     The name of the current top-of-page format for the currently selected
     output channel.  Default is name of the filehandle with _TOP
     appended.  (Mnemonic: points to top of page.)

format_line_break_characters HANDLE EXPR
$FORMAT_LINE_BREAK_CHARACTERS
$:
     The current set of characters after which a string may be broken to
     fill continuation fields (starting with ^) in a format.  Default is
     " \n-", to break on whitespace or hyphens.  (Mnemonic: a "colon" in
     poetry is a part of a line.)

format_formfeed HANDLE EXPR
$FORMAT_FORMFEED
$^L
     What formats output to perform a formfeed.  Default is \f.

$ACCUMULATOR
$^A
     The current value of the write() accumulator for format() lines.  A
     format contains formline() commands that put their result into $^A.
     After calling its format, write() prints out the contents of $^A and
     empties.  So you never actually see the contents of $^A unless you
     call formline() yourself and then look at it.  See *Note Perlform:
     (perl.info)perlform, and `formline()', *Note Perlfunc:
     (perl.info)perlfunc,.

$CHILD_ERROR
$?
     The status returned by the last pipe close, backtick (```') command,
     or system() operator.  Note that this is the status word returned by
     the wait() system call, so the exit value of the subprocess is
     actually (`$? >> 8').  Thus on many systems, `$? & 255' gives which
     signal, if any, the process died from, and whether there was a core
     dump.  (Mnemonic: similar to *sh* and *ksh*.)

$OS_ERROR
$ERRNO
$!
     If used in a numeric context, yields the current value of errno, with
     all the usual caveats.  (This means that you shouldn't depend on the
     value of "$!" to be anything in particular unless you've gotten a
     specific error return indicating a system error.)  If used in a string
     context, yields the corresponding system error string.  You can assign
     to "$!" in order to set errno if, for instance, you want "$!" to
     return the string for error n, or you want to set the exit value for
     the die() operator.  (Mnemonic: What just went bang?)

$EVAL_ERROR
$@
     The Perl syntax error message from the last eval() command.  If null,
     the last eval() parsed and executed correctly (although the
     operations you invoked may have failed in the normal fashion).
     (Mnemonic: Where was the syntax error "at"?)

     Note that warning messages are not collected in this variable.  You
     can, however, set up a routine to process warnings by setting
     $SIG{__WARN__} below.

$PROCESS_ID
$PID
$$
     The process number of the Perl running this script.  (Mnemonic: same
     as shells.)

$REAL_USER_ID
$UID
$<
     The real uid of this process.  (Mnemonic: it's the uid you came
     *FROM*, if you're running setuid.)

$EFFECTIVE_USER_ID
$EUID
$>
     The effective uid of this process.  Example:

          $< = $>;		# set real to effective uid
          ($<,$>) = ($>,$<);	# swap real and effective uid

     (Mnemonic: it's the uid you went TO, if you're running setuid.)  Note:
     "`$<'" and "`$>'" can only be swapped on machines supporting
     setreuid().

$REAL_GROUP_ID
$GID
$(
     The real gid of this process.  If you are on a machine that supports
     membership in multiple groups simultaneously, gives a space separated
     list of groups you are in.  The first number is the one returned by
     getgid(), and the subsequent ones by getgroups(), one of which may be
     the same as the first number.  (Mnemonic: parentheses are used to
     *GROUP* things.  The real gid is the group you *LEFT*, if you're
     running setgid.)

$EFFECTIVE_GROUP_ID
$EGID
$)
     The effective gid of this process.  If you are on a machine that
     supports membership in multiple groups simultaneously, gives a space
     separated list of groups you are in.  The first number is the one
     returned by getegid(), and the subsequent ones by getgroups(), one of
     which may be the same as the first number.  (Mnemonic: parentheses are
     used to *GROUP* things.  The effective gid is the group that's
     *RIGHT* for you, if you're running setgid.)

     Note: "`$<'", "`$>'", "$(" and "$)" can only be set on machines that
     support the corresponding *set[re][ug]id()* routine.  "$(" and "$)"
     can only be swapped on machines supporting setregid().

$PROGRAM_NAME

$0
     Contains the name of the file containing the Perl script being
     executed.  Assigning to "$0" modifies the argument area that the ps(1)
     program sees.  This is more useful as a way of indicating the current
     program state than it is for hiding the program you're running.
     (Mnemonic: same as *sh* and *ksh*.)

$[
     The index of the first element in an array, and of the first character
     in a substring.  Default is 0, but you could set it to 1 to make Perl
     behave more like *awk* (or Fortran) when subscripting and when
     evaluating the index() and substr() functions.  (Mnemonic: [ begins
     subscripts.)

     As of Perl 5, assignment to "$[" is treated as a compiler directive,
     and cannot influence the behavior of any other file.  Its use is
     discouraged.

$PERL_VERSION
$]
     The string printed out when you say `perl -v'.  It can be used to
     determine at the beginning of a script whether the perl interpreter
     executing the script is in the right range of versions.  If used in a
     numeric context, returns the version + patchlevel / 1000.  Example:

          # see if getc is available
          ($version,$patchlevel) =
          	     $] =~ /(\d+\.\d+).*\nPatch level: (\d+)/;
          print STDERR "(No filename completion available.)\n"
          	     if $version * 1000 + $patchlevel < 2016;

     or, used numerically,

          warn "No checksumming!\n" if $] < 3.019;

     (Mnemonic: Is this version of perl in the right bracket?)

$DEBUGGING
$^D
     The current value of the debugging flags.  (Mnemonic: value of -D
     switch.)

$SYSTEM_FD_MAX
$^F
     The maximum system file descriptor, ordinarily 2.  System file
     descriptors are passed to exec()ed processes, while higher file
     descriptors are not.  Also, during an open(), system file descriptors
     are preserved even if the open() fails.  (Ordinary file descriptors
     are closed before the open() is attempted.)  Note that the
     close-on-exec status of a file descriptor will be decided according
     to the value of $^F at the time of the open, not the time of the exec.

$INPLACE_EDIT
$^I
     The current value of the inplace-edit extension.  Use undef to disable
     inplace editing.  (Mnemonic: value of -i switch.)

$PERLDB
$^P
     The internal flag that the debugger clears so that it doesn't debug
     itself.  You could conceivable disable debugging yourself by clearing
     it.

$BASETIME
$^T
     The time at which the script began running, in seconds since the
     epoch (beginning of 1970).  The values returned by the -M, -A and -C
     filetests are based on this value.

$WARNING
$^W
     The current value of the warning switch, either TRUE or FALSE.
     (Mnemonic: related to the -w switch.)

$EXECUTABLE_NAME
$^X
     The name that the Perl binary itself was executed as, from C's
     `argv[0]'.

$ARGV
     contains the name of the current file when reading from <>.

@ARGV
     The array @ARGV contains the command line arguments intended for the
     script.  Note that `$#ARGV' is the generally number of arguments minus
     one, since `$ARGV[0]' is the first argument, *NOT* the command name.
     See "$0" for the command name.

@INC
     The array @INC contains the list of places to look for Perl scripts to
     be evaluated by the `do EXPR', require, or use constructs.  It
     initially consists of the arguments to any -I command line switches,
     followed by the default Perl library, probably "/usr/local/lib/perl",
     followed by ".", to represent the current directory.

%INC
     The hash %INC contains entries for each filename that has been
     included via do or require.  The key is the filename you specified,
     and the value is the location of the file actually found.  The
     require command uses this array to determine whether a given file has
     already been included.

$ENV{expr}
     The hash %ENV contains your current environment.  Setting a value in
     ENV changes the environment for child processes.

$SIG{expr}
     The hash %SIG is used to set signal handlers for various signals.
     Example:

          sub handler {	# 1st argument is signal name
          	local($sig) = @_;
          	print "Caught a SIG$sig--shutting down\n";
          	close(LOG);
          	exit(0);
          }

          $SIG{'INT'} = 'handler';
          $SIG{'QUIT'} = 'handler';
          ...
          $SIG{'INT'} = 'DEFAULT';	# restore default action
          $SIG{'QUIT'} = 'IGNORE';	# ignore SIGQUIT

     The %SIG array only contains values for the signals actually set
     within the Perl script.  Here are some other examples:

          $SIG{PIPE} = Plumber;       # SCARY!!
          $SIG{"PIPE"} = "Plumber";   # just fine, assumes main::Plumber
          $SIG{"PIPE"} = \&Plumber;   # just fine; assume current Plumber
          $SIG{"PIPE"} = Plumber();   # oops, what did Plumber() return??

     The one marked scary is problematic because it's a bareword, which
     means sometimes it's a string representing the function, and
     sometimes it's going to call the subroutine call right then and
     there!  Best to be sure and quote it or take a reference to it.
     *Plumber works too.  See `perlsubs' in this node.

     Certain internal hooks can be also set using the %SIG hash.  The
     routine indicated by $SIG{__WARN__} is called when a warning message
     is about to be printed.  The warning message is passed as the first
     argument.  The presence of a __WARN__ hook causes the ordinary
     printing of warnings to STDERR to be suppressed.  You can use this to
     save warnings in a variable, or turn warnings into fatal errors, like
     this:

          local $SIG{__WARN__} = sub { die $_[0] };
          eval $proggie;

     The routine indicated by $SIG{__DIE__} is called when a fatal
     exception is about to be thrown.  The error message is passed as the
     first argument.  When a __DIE__ hook routine returns, the exception
     processing continues as it would have in the absence of the hook,
     unless the hook routine itself exits via a goto, a loop exit, or a
     die.


