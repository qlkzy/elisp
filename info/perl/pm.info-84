This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: CGI/Request,  Next: CGI/Response,  Prev: CGI/QuickForm,  Up: Module List

Parse client request via a CGI interface
****************************************

NAME
====

   CGI::Request - Parse client request via a CGI interface

SYNOPSIS
========


     use CGI::Request;
     
     # Simple interface: (combines SendHeaders, new and import_names)
     
     $req = GetRequest($pkg);
     
     print FmtRequest();            # same as: print $req->as_string
     
     
     # Full Interface:
     
     $req = new CGI::Request;       # fetch and parse request
     
     $field_value = $req->param('FieldName');
     @selected    = $req->param('SelectMultiField');
     @keywords    = $req->keywords; # from ISINDEX
     
     print $req->as_string;         # format Form and CGI variables
     
     # import form fields into a package as perl variables!
     $req->import_names('R');
     print "$R::FieldName";
     print "@R::SelectMultiField";
     
     @value = $req->param_or($fieldname, $default_return_value);

     # Access to CGI interface (see CGI::Base)

     $cgi_obj = $req->cgi;
     $cgi_var = $req->cgi->var("REMOTE_ADDR");
     
     
     # Other Functions:
     
     CGI::Request::Interface($cgi);  # specify alternative CGI
     
     CGI::Request::Debug($level);    # log to STDERR (see CGI::Base)
     
     
     # Cgi-lib compatibility functions
     # use CGI::Request qw(:DEFAULT :cgi-lib); to import them
     
     &ReadParse(*input);
     &MethGet;
     &PrintHeader;
     &PrintVariables(%input);

DESCRIPTION
===========

   This module implements the CGI::Request object. This object represents
a single query / request / submission from a WWW user. The CGI::Request
class understands the concept of HTML forms and fields, specifically how
to parse a CGI QUERY_STRING.

SMALLEST EXAMPLE
----------------

   This is the smallest useful CGI::Request script:

     use CGI::Request;
     GetRequest();
     print FmtRequest();

SIMPLE EXAMPLE
--------------

   This example demonstrates a simple ISINDEX based query, importing
results into a package namespace and escaping of text:

     #!/usr/local/bin/perl  # add -T to test tainted behaviour

     use CGI::Base;
     use CGI::Request;

     GetRequest('R');       # get and import request into R::...

     # Just to make life more interesting add an ISINDEX.
     # Try entering: "aa bb+cc dd=ee ff&gg hh<P>ii"
     print "<ISINDEX>\r\n";

     print "<B>You entered:</B> ", # print results safely
           join(', ', CGI::Base::html_escape(@R::KEYWORDS))."\r\n";

     print FmtRequest();    # show formatted version of request

CGI
---

   A CGI::Request object contains a reference to a CGI::Base object (or an
object derived from CGI::Base). It uses the services of that object to get
the raw request information.

   Note that CGI::Request does not inherit from CGI::Base it just uses an
instance of a CGI::Base object.

   See the cgi method description for more information.

FEATURES
--------

   Is object oriented and sub-classable.

   Can export form field names as normal perl variables.

   Integrates with CGI::MiniSvr.

RECENT CHANGES
--------------

  1. Fixed bug in import_names().  Now works properly with both scalar and
     array elements.

  2. through 2.74 Minor changes to accomodate Forms interface.

  3. thru 2.3 Minor enhancements to documentation and debugging. Added
     notes about relationship with CGI and how to access CGI variables.

  4. Updates for changed CGI:Base export tags. No longer setting
     @CGI::Request::QUERY_STRING. Added param_or() method.

     The module file can be run as a cgi script to execute a demo/test. You
     may need to chmod +x this file and teach your httpd that it can
     execute *.pm files (or create a copy/symlink with another name).

  5. GetRequest now call SendHeaders (in CGI::Base) for you. This works
     *much* better than the old 'print PrintHeaders;'. PrintHeaders is no
     longer exported by default. as_string now uses the new html_escape
     method (in CGI::Base) to safely format strings with embedded html.
     Debugging now defaults to off. New Debug function added. Image map
     coords are automatically recognised and stored as parameters X and Y.
     Added a sequence number mechanism to assist debugging MiniSvr
     applications (does not impact/cost anything for non minisvr apps).

  6. Default package for import_names() removed, you must supply a package
     name. GetRequest() won't call import_names unless a package name has
     been given, thus GetRequest no longer defaults to importing names.
     Added as_string() method (which automatically calls cgi->as_string).
     param() will croak if called in a scalar context for a multi-values
     field.


FUTURE DEVELOPMENTS
-------------------

   None of this is perfect. All suggestions welcome.

   Note that this module is *not* the place to put code which generates
HTML.  We'll need separate modules for that (which are being developed).

AUTHOR, COPYRIGHT and ACKNOWLEDGEMENTS
--------------------------------------

   This code is Copyright (C) Tim Bunce 1995. All rights reserved.  This
code is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.

   The cgi-lib functions are based on cgi-lib.pl version 1.7 which is
Copyright 1994 Steven E. Brenner.

   IN NO EVENT SHALL THE AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OF THIS SOFTWARE AND ITS DOCUMENTATION (INCLUDING, BUT NOT LIMITED TO,
LOST PROFITS) EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

SEE ALSO
--------

   CGI::Base, URI::Escape

SUPPORT
-------

   Please use comp.infosystems.www.* and comp.lang.perl.misc for support.
Please do _NOT_ contact the author directly. I'm sorry but I just don't
have the time.

FUNCTIONS
=========

GetRequest
----------


     GetRequest();
     GetRequest($package_name);
     $req = GetRequest(...);

   GetRequest is the main entry point for simple (non-object oriented) use
of the CGI::Request module. It combines output (and flushing) of the
standard Content-Type header, request processing and optional importing of
the resulting values into a package (see import_names).

   This function also enables autoflush on stdout. This has a slight
efficiency cost but huge benefits in reduced frustration by novice users
wondering why, for example, the output of system("foo") appears before
their own output.

   See `new CGI::Request' for more details.

FmtRequest
----------


     print FmtRequest();

   Return a HTML string which describes the last (current) client request
parameters and the current raw CGI parameters.  Designed to be used for
debugging purposes.

Interface
---------


     $cgi = Interface();

   Return the default CGI interface object. Rarely used by applications.

   If no interface has been defined yet it will automatically create a new
CGI::Base object, set that as the default interface and return it. This is
the mechanism by which simple applications get to use the CGI::Base
interface without knowing anything about it.

   This function can also be use to define a new default interface (such
as CGI::MiniSvr) by passing a reference to a CGI::Base object or a object
derived from CGI::Base.

Debug
-----


     $old_level = CGI::Request::Debug();
     $old_level = CGI::Request::Debug($new_level);

   Set debug level for the CGI::Request module. Debugging info is logged
to STDERR (see CGI::Base for examples of how to redirect STDERR).

METHODS
=======

new
---


     $req = new CGI::Request;
     $req = new CGI::Request $cgi_interface;
     $req = new CGI::Request $cgi_interface, $timeout_in_seconds;

   CGI::Request object constructor. Only the first form listed above
should be used by most applications.

   Note that, unlike GetRequest, new CGI::Request does not call
SendHeaders for you. You have the freedom to control how you send your
headers and what headers to send.

   The returned $req CGI::Request object stores the request parameter
values. Parameters can be retrieved using the param method.

   Index keywords (ISINDEX) are automatically recognised, parsed and
stored as values of the 'KEYWORDS' parameter. The keywords method provides
an easy way to retrieve the list of keywords.

   Image Map (ISMAP) coordinates are automatically recognised, parsed and
stored as parameters 'X' and 'Y'.

as_string
---------


     print $req->as_string;

   Return an HTML string containing all the query parameters and CGI
parameters neatly and safely formatted. Very useful for debugging.

extract_values
--------------


     $req->extract_values($QUERY_STRING)

   This method extracts parameter name/value pairs from a string
(typically QUERY_STRING) and stores them in the objects hash.  Not
normally called by applications, new() calls it automatically.

   The parameter names and values are individually unescaped using the
uri_unescape() function in the URI::URL module.

   For ISINDEX keyword search requests (QUERY_STRING contains no '=' or
'&') the string is split on /+/ and the keywords are then individually
unescaped and stored.  Either the keywords() method (or param('KEYWORDS'))
can be used to recover the values.

keywords
--------


     @words = $req->keywords

   Return the keywords associated with an ISINDEX query.

params
------


     @names = $req->params

   Return a list of all known parameter names in the order in which
they're defined

param
-----


     $value  = $req->param('field_name1');
     @values = $req->param('field_name2');	# e.g. select multiple
     $req->param('field_name3', $new_value);
     $req->param('field_name4', @new_values);

   Returns the value(s) of a named parameter. Returns an empty list/undef
if the parameter name is not known. Returns " for a parameter which had no
value.

   If invoked in a list context param returns the list of values in the
same order they were returned by the client (typically from a select
multiple form field).

   Warning: If invoked in a scalar context and the parameter has more than
one value the param method will die. This catches badly constructed forms
where a field may have been copied but its name left unchanged.

   If more than one argument is provided, the second and subsequent
arguments are used to set the value of the parameter. The previous values,
if any, are returned. Note that setting a new value has no external effect
and is only included for completeness.

   Note that param does not return CGI variables (REMOTE_ADDR etc) since
those are CGI variables and not form parameters. To access CGI variables
see the cgi method in this module and the CGI::Base module documentation.

delete
------

     $req->delete('field_name1');

   Remove the specified field name from the parameter list

param_or
--------

     $value  = $req->param_or('field_name1', $default);
     @values = $req->param_or('field_name2', @defaults);

   If the current request was a query (QUERY_STRING defined) then this
method is identical to the param method with only one argument.

   If the current request was not a query (QUERY_STRING undefined) then
this method simply returns its second and subsequent parameters.

   The method is designed to be used as a form building utility.

import_names
------------


     $req->import_names('R')

   Convert all request parameters into perl variables in a specified
package. This avoids the need to use $req->param('name'), you can simply
sat $R::name ('R' is the recommended package names).

   Note: This is a convenience function for simple CGI scripts. It should
not be used with the MiniSvr since there is no way to reset or unimport
the values from one request before importing the values of the next.

cgi
---


     $cgi = $req->cgi;

   This method returns the current CGI::Request default CGI interface
object.  It is primarily intended as a handy shortcut for accessing
CGI::Base methods: $req->cgi->done(), $req->cgi->var("REMOTE_ADDR");


File: pm.info,  Node: CGI/Response,  Next: CGI/SSI,  Prev: CGI/Request,  Up: Module List

Respond to CGI requests
***********************

NAME
====

   *CGI::Response* - Respond to CGI requests

SYNOPSIS
========

Simple Interface
----------------

     use CGI::Response qw(:Simple);
     print ContentType;
     print "<html><head>\n"; # .....

Full Interface
--------------

     use CGI::Response;
     $response = new CGI::Response;
     $response->content_type;
     print $response->as_string;
     print "<html><head>\n"; # .....

DESCRIPTION
===========

   *CGI::Response* is a Perl5 module for constructing responses to Common
Gateway Interface (CGI) requests.  It is designed to be light-weight and
efficient for the most common tasks, and also to provide access to all
HTTP response features for more advanced CGI applications.

   There are two ways to use CGI::Response.  For basic applications, the
Simple Interface provides a number of plain functions that cover the most
commonly-used CGI response headers.  More advanced applications may employ
the Full Interface object methods to access any HTTP header, or to add
experimental or non-standard headers.  Both interfaces try to generate
reasonable defaults whenever possible.

   For efficiency, just the Simple Interface functions are compiled on
start-up.  Full Interface methods are compiled only when they are called.
This helps to make CGI::Response usable in a variety of applications.
[See *Note SelfLoader: SelfLoader, for more information.]

Simple Interface
----------------

   The Simple Interface methods are not exported by default.  In order to
use them, you must import them explicitly.  You can import all of the
methods at once by saying:

     use CGI::Response qw(:Simple);

   Or, you can import just one function by listing it by name, as in:

     use CGI::Response qw(ContentType);

   Only one Simple Interface function should be called in a response,
since all of these functions terminate the response header (that is, send
the blank line denoting the end of the header) immediately upon execution.
If you need to use a combination of headers not provided by the Simple
Interface, use the Full Interface instead.

   All of the Simple Interface functions force a flush on the
currently-selected output channel (that is, they set `$| = 1').  This is
done to prevent a common probelm in CGI scripts, where a `system()' or
exec() call causes output before the response header, and generates a
server error.  If you do not want `$| = 1', you should either set it back
to 0 after using the Simple Interface, or you should employ the Full
Interface, which does not have this side effect.

   For reference, below is a list of the headers sent by each function,
and the default header values, if any.  Arguments are listed in the order
they should appear.  Square brackets ([]) indicate optional arguments;
angled brackets (<>) indicate required arguments.

     Function      Argument(s)      Header(s)      Default(s)
     --------      -----------      ---------      ----------
     &ContentType  [content-type]   Content-Type   text/html

     &Redirect     <Location/URI>   Location       [none]
                   [permanent?]     URI            [none]
                                    Content-Type   text/html
                                    Status         302 Moved Temporarily

     &NoCache      [content-type]   Content-Type   text/html
                                    Pragma         no-cache
                                    Expires        [now]

     &NoContent                     Status         204 No Content

   Each of these functions is documented more completely below, and
examples for each are provided.

&ContentType
     This is the most commonly-used function.  It identifies the Internet
     Media Type of the entity that follows.  If you call it without an
     argument, it will send `text/html' as the content-type.

          use CGI::Response qw(:Simple);
          print &ContentType;   # defaults to text/html

     Otherwise, you can specify some other content-type:

          use CGI::Response qw(:Simple);
          print &ContentType('image/gif');

     This function should be called as early as possible to prevent server
     errors (see the note on $| above).

&Redirect
     A redirect causes the user-agent to make a follow-up request for some
     other resource.  Some user-agents will be better than others at
     complying with a redirect, so this function tries to be as explicit as
     possible.

     You are required to give one argument, specifying the URL which the
     user-agent should request.  A second argument is accepted as a Boolean
     value - if any second argument is present, the browser will be told
     that the requested resource has moved permanently to a new URL (that
     is, future requests for the document should be to the new URL, not to
     the one which was first requested).

          use CGI::Response qw(:Simple);
          print &Redirect('http://www.company.com/', 'permanent');
          # this resource has moved permanently, status 301

     If no second argument is given, the redirect will be specified as
     temporary.

          use CGI::Response qw(:Simple);
          print &Redirect('http://www.company.com/');
          # this resource has moved temporarily, status 302

     A brief HTML page is output after the header so that users whose
     user-agents fail to recognize the redirect will get an informative
     message with a link to the redirect.  Use the Full Interface to supply
     some other page or none at all.

&NoCache
     This function tries to inform user-agents and proxy servers that the
     included resource should not be cached.  It does so by sending both an
     `Expires' header, set for immediate expiration, and a `Pragma:
     no-cache' header, which older user-agents and servers might not
     recognize.

     Preventing caching is important to CGI applications which produce
     output based on some factor of the request (such as which user-agent
     made the request).  For instance, a shopping-basket application would
     not want to allow caching of an order information page, which may
     contain user-specific information.

     It must be noted, however, that caches prevent excess network load and
     cache-friendly applications are always preferable to use of the
     &NoCache function.  This function should only be used when there is no
     other alternative.

     &NoCache takes one optional argument, the content-type of the entity
     to follow.  Therefore, its call is nearly identical to the
     &ContentType function, and the two functions may be interchanged
     easily.  As with &ContentType, if you call &NoCache without an
     argument, it will send `text/html' as the content-type.

          use CGI::Response qw(:Simple);
          print &NoCache;   # defaults to text/html

     Otherwise, you can specify some other content-type:

          use CGI::Response qw(:Simple);
          print &NoCache('image/gif');

     As noted earlier, this function should be called as early as possible
     to prevent server errors (see the note on $| above).

&NoContent
     &NoContent allows a script to accept input without changing the
     current page in the user-agent's view.  This may be useful for a
     successful form input that requires no response, or for an imagemap
     click that does not have a defined link.

     A No Content response does not reset form fields after submission.
     HTTP/1.1 will include a `205 Reset Document' status for this purpose,
     and a future version of this module will provide a &Reset function to
     support this status.

     This function sends only one header, `Status: 204 No Content', and it
     takes no arguments.

          use CGI::Response qw(:Simple);
          print &NoContent;

Full Interface
--------------

   The Full Interface is still under development and is not currently
documented.

DEPENDENCIES
============

SEE ALSO
========

   CGI::Base(3pm), CGI::BasePlus(3pm), CGI::Request(3pm), CGI::Lite(3pm),
CGI(3pm), CGI::Form(3pm), LWP(3pm), SelfLoader(3pm)

NOTES
=====

   Please note that future versions are not guaranteed to be
backwards-compatible with this version.  The interface will be frozen at
version 0.1 (first beta release).

VERSION
=======

     Version:      0.03 (alpha release)
     Release date: 02 December 1995

AUTHOR
======

     Marc Hedlund <hedlund@best.com>
     Copyright 1995, All rights reserved


File: pm.info,  Node: CGI/SSI,  Next: CGI/SSI_Parser,  Prev: CGI/Response,  Up: Module List

Use SSI from CGI scripts
************************

NAME
====

     CGI::SSI - Use SSI from CGI scripts

SYNOPSIS
========

     # autotie STDOUT or any other open filehandle

     use CGI::SSI (autotie => STDOUT);

     print $shtml; # browser sees resulting HTML

     # or tie it yourself to any open filehandle

     use CGI::SSI;

     open(FILE,'+>'.$html_file) or die $!;
     $ssi = tie(*FILE, 'CGI::SSI', filehandle => 'FILE');
     print FILE $shtml; # HTML arrives in the file

     # or use the object-oriented interface

     use CGI::SSI;

     $ssi = CGI::SSI->new();

     $ssi->if('"$varname" =~ /^foo/');
        $html .= $ssi->process($shtml);
     $ssi->else();
        $html .= $ssi->include(file => $filename);
     $ssi->endif();

     print $ssi->exec(cgi => $url);
     print $ssi->flastmod(file => $filename);

     #
     # or roll your own favorite flavor of SSI
     #

     package CGI::SSI::MySSI;
     use CGI::SSI;
     @CGI::SSI::MySSI::ISA = qw(CGI::SSI);

     sub include {
        my($self,$type,$file_or_url) = @_;
        # my idea of include goes something like this...
        return $html;
     }
     1;
     __END__

DESCRIPTION
===========

   CGI::SSI is meant to be used as an easy way to filter shtml through CGI
scripts in a loose imitation of Apache's mod_include.  If you're using
Apache, you may want to use either mod_include or the Apache::SSI module
instead of CGI::SSI. Limitations in a CGI script's knowledge of how the
server behaves make some SSI directives impossible to imitate from a CGI
script.

   Most of the time, you'll simply want to filter shtml through STDOUT or
some other open filehandle. `autotie' is available for STDOUT, but in
general, you'll want to tie other filehandles yourself:

     $ssi = tie(*FH, 'CGI::SSI', filehandle => 'FH');
     print FH $shtml;

   Note that you'll need to pass the name of the filehandle to tie() as a
named parameter. Other named parameters are possible, as detailed below.
These parameters are the same as those passed to the new() method.
However, new() will not tie a filehandle for you.

   CGI::SSI has it's own flavor of SSI. Test expressions are Perlish.  You
may create and use multiple CGI::SSI objects; they will not step on each
others' variables.

   Object-Oriented methods use the same general format so as to imitate
SSI directives:

     <!--#include virtual="/foo/bar.footer" -->

     would be

     $ssi->include(virtual => '/foo/bar.footer');

   likewise,

     <!--#exec cgi="/cgi-bin/foo.cgi" -->

     would be

     $ssi->exec(cgi => '/cgi-bin/foo.cgi');

   Usually, if there's no chance for ambiguity, the first argument may be
left out:

     <!--#echo var="var_name" -->

     could be either

     $ssi->echo(var => 'var_name');

     or

     $ssi->echo('var_name');

   Likewise,

     $ssi->set(var => $varname, value => $value)

     is the same as

     $ssi->set($varname => $value)

$ssi->new([%args])
     Creates a new CGI::SSI object. The following are valid (optional)
     arguments:

          DOCUMENT_URI    => $doc_uri,
          DOCUMENT_NAME   => $doc_name,
          DOCUMENT_ROOT   => $doc_root,
          errmsg          => $oops,
          sizefmt         => ('bytes' || 'abbrev'),
          timefmt         => $time_fmt,

$ssi->config($type, $arg)
     $type is either 'sizefmt', 'timefmt', or 'errmsg'. $arg is similar to
     those of the SSI spec, referenced below.

$ssi->set($varname => $value)
     Sets variables internal to the CGI::SSI object. (Not to be confused
     with the normal variables your script uses!) These variables may be
     used in test expressions, and retreived using $ssi->echo($varname).

$ssi->echo($varname)
     Returns the value of the variable named $varname. Such variables may
     be set manually using the set() method. There are also several
     built-in variables:

          DOCUMENT_URI  - the URI of this document
          DOCUMENT_NAME - the name of the current document
          DATE_GMT      - the same as 'gmtime'
          DATE_LOCAL    - the same as 'localtime'
          FLASTMOD      - the last time this script was modified

$ssi->exec($type, $arg)
     $type is either 'cmd' or 'cgi'. $arg is similar to the SSI spec (see
     below).

$ssi->include($type, $arg)
     Similar to exec, but `virtual' and file are the two valid types.

$ssi->flastmod($type, $filename)
     Similar to include.

$ssi->fsize($type, $filename)
     Same as `flastmod'.

$ssi->printenv
     Returns the environment similar to Apache's mod_include.

FLOW-CONTROL METHODS
--------------------

   The following methods may be used to test expressions. During a block
where the test $expr is false, nothing will be returned (or printed, if
tied).

$ssi->if($expr)
     The expr can be anything Perl, but care should be taken. This causes
     problems:

          $ssi->set(varname => "foo");
          <!--#if expr="'\$varname' =~ /^foo$/" -->ok<!--#endif -->

     The $varname is expanded as you would expect. (We escape it so as to
     use the `$varname' within the CGI::SSI object, instead of that within
     our progam.) But the $/ inside the regex is also expanded. This is
     fixed by escaping the `$':

          <!--#if expr="'\$varname' =~ /^value\$/" -->ok<!--#endif -->

     The expressions used in if and elif tags/calls are tricky due to the
     number of escapes required. In some cases, you'll need to write
     `\\\\' to mean \.

$ssi->elif($expr)
$ssi->else
$ssi->endif
SEE ALSO
========

   `Apache::SSI' and the SSI spec at
http://www.apache.org/docs/mod/mod_include.html

COPYRIGHT
=========

   Copyright 2000 James Tolley   All Rights Reserved.

   This is free software. You may copy and/or modify it under the same
terms as perl itself.

AUTHOR
======

   James Tolley <james@jamestolley.com>


File: pm.info,  Node: CGI/SSI_Parser,  Next: CGI/Screen,  Prev: CGI/SSI,  Up: Module List

Implement SSI for Perl CGI
**************************

NAME
====

   CGI::SSI_Parser - Implement SSI for Perl CGI

SYNOPSIS
========

     use CGI::SSI_Parser;

     $CGI::SSI_Parser::recursive = 1;

     fssi($filename);
     sssi($string);

DESCRIPTION
===========

   CGI::SSI_Parser is used in CGI scripts for parsing SSI directives in
files or string variables, and fully implements the functionality of
apache's mod_include module.

   It is an alternative to famous Apache::SSI modules, but it doesn't
require mod_perl. This is an advantage to those who are using public
hosting services.  There is a disadvantage, however - the module consumes
much memory, and I don't recommend using it on heavy-loaded sites
(currently it's being used on a site with 10000 hits, and I consider this
as a limit). I hope to get rid of this disadvantage by the time the
release comes out (currently it's beta).

SSI Directives
--------------

   This module supports the same directives as mod_include. For methods
listed below but not documented, please see mod_include's online
documentation at http://httpd.apache.org/docs/mod/mod_include.html .

   * config

   * echo

     This directive is not fully supported in current version.

   * exec

   * fsize

   * flastmod

   * include

   * printenv

   * set

     This directive is not supported in current version.

   * perl

     This directive is not supported in current version.

   * if

   * elif

   * else

   * endif

     These four directives are not supported in current version.

Outline Usage
-------------

   First you need to load the CGI::SSI_Parser module:

     use CGI::SSI_Parser;

   You need to specify the following when processing of all nested
directives is needed (default value - 0):

     $CGI::SSI_Parser::recursive = 1;

   To parse file or string you need to use:

     fssi($filename);
     sssi($string);

   The result is printed to STDOUT.

TO DO
=====

   Full implementation of all SSI directives.

   Optimize memory consumption.

AUTHOR
======

   Vadim Y. Ponomarenko, vp@istc.kiev.ua

SEE ALSO
========

   mod_include, perl(1).


File: pm.info,  Node: CGI/Screen,  Next: CGI/State,  Prev: CGI/SSI_Parser,  Up: Module List

Perl extension for easy creation of multi screen CGI scripts
************************************************************

NAME
====

   CGI::Screen - Perl extension for easy creation of multi screen CGI
scripts

SYNOPSIS
========

     use CGI::Screen;
     use vars qw(@ISA);
     @ISA = qw(CGI::Screen);

     my $query = __PACKAGE__->new;

     $query->dispatch;

WARNING
=======

   This is *alpha* software. User visible changes can happen any time.

DESCRIPTION
===========

   *CGI::Screen* is a subclass of CGI which allows the esay(TM) creation
of simple multi screen CGI scripts. By 'multi screen' I mean scripts which
present different screens to the user when called with different
parameters. This is the common case for scripts linking to themselves.

   To use *CGI::Screen*, you have to subclass it. For each screen you want
to present to the user, you must create a method *screen_name*`screen_'.
This method has to produce the HTML code for the screen. CGI::Screen does
generate HTTP headers and an HTML framework for you. The HTML framework
already contains the FORM tags.  You can customize the HTTP headers and
the HTML framework by providing callback methods.

   CGI::Screen keeps track of the CGI parameters used in your screen and
passes old parameters which are not used in the current screen.

   It highjacks the parameters `screen_'* to dispatch the different
screens the script implements. The `screen_user' and `screen_passwd'
fields are used if you enable the builtin simple authentication.  In
general you should advice your HTTP server to do authentication. But
sometimes it is convenient to check the authentication at the script
level. Especially if you do not have access to your server's configuration.

The constructor new
-------------------

   If the first parameter of new is the string `-screen' the second
argument must be a hash reference specifying the options for the subclass.
Other parameters are passed to the constructor of CGI.

`-dont_cut_loops'
     Normaly the history of pages will not be extended if the current page
     is the same as the last page. So looping on a page will not change the
     result of the `last_screen' method. If the option `-dont_cut_loops'
     is provided and true, the page will recorded twice. A third visit will
     be interpreted as jump back to the first visit.

     *That sounds weird. Will have to figure out a way to recognize back
     jumps independent of the history.*

Adding Screens
--------------

   All applications should provide a main screen by defining a method
`main_screen'. This method is called if no (existing) screen is specified
in the parameters. The method is called with three arguments: The query
object, the screen name and the screen title (More precisely the third
parameter, if present, is the text on the button or anchor which caused
the jump to this page).

   So the minimal application looks like this:

     use CGI::Screen;
     use vars qw(@ISA);
     @ISA = qw(CGI::Screen);
     
     my $query = __PACKAGE__->new;
     
     $query->dispatch;
     
     sub main_screen {
       my $query = shift;
     
       print $query->p('This is the Main Screen');
     }

   That is not too exciting. Let us add a second screen and allow
navigation between the screens:

     sub main_screen {
       my $query = shift;
     
       print
         $query->p('This is the Main Screen'),
         $query->goto_screen('second', 'Another Screen');
     }
     sub second_screen {
       my $query = shift;
     
       print
         $query->p('This is the Other Screen'),
         $query->goto_screen('main', 'Back to Main Screen');

     }

Moving between screens
----------------------

   Use the method `goto_screen' to produce a button for switching to
another screen.  You can also produce an anchor instead of a button by
calling `link_to_screen' instead of `goto_screen'. You may pass additional
parameters to encode:

     for my $docid (keys %score) {
       print $query->link_to_screen('display', $title{$docid},
                                    'docid' => $docid,
                                    'score' => $score{$docid});
     }

   For convenience, CGI::Screen keeps track of the last screen for you so
that you can link to the previous page. Note that only the last seven
screens are saved:

     my $screen = $query->last_screen;
     print
       $query->p("You came from screen $screen. Press "),
       $query->goto_screen($query->last_screen),
       $query->p(" to go back");

   `last_screen' returns screen name and title in list context and screen
name in scalar context. Do not use the CGI parameters `screen_last_*'
since they are changed before you can get hold of them `;-P'

The callbacks
-------------

   All callbacks are called with three arguments: The query object, the
screen name and the screen title (= button/anchor text). Callbacks should
return a string.

application
     The application method returns a string which is used in the default
     title and headline callbacks. The Default method returns the string
     `"CGI::Screen Test"' and should definitely be overwritten by your
     application.

title
     The result of the method is used in the HTTP header and in the default
     headline. It defaults to the application.

headline
     The headline method should return a chunk of HTML code to start the
     Screen. It defaults to the title enclosed in `H1' tags.

Authentication
--------------

   To enable password authentication, define a method `check_auth_user'.
The dispatcher will call the method with the user and password entered by
the user. The method should return true if the authentication succeeded
and false otherwise. The dispatcher will present the `login_screen' if the
authentication failed.

     sub check_auth_user {
       my ($query, $user, $passwd) = @_;

     $user eq 'pfeifer';
       }

   For IP address based authentication define the method `check_auth_ip'.

     sub check_auth_ip {
       my ($query, $ipaddr) = @_;

     $ipaddr =~ /^(193\.96\.65\.|139\.4\.36\.)/;
       }

   If you do not like the default login screen, overwrite with your own
`login_screen'. Use the CGI parameters `screen_user' and `screen_passwd'.

Customizing the Title
---------------------

   You may provide a custom title method to generate a title for your
screens.

     sub title {
       my ($query, $screen)  = shift;
     
       $query->application . ': ' . $screen;
     }

Customizing the Headline
------------------------

   You may provide a custom headline method to generate a HTML chunk to
start your screens.

     sub headline { $_[0]->h1(title(@_)) }

   You should overwrite the application method if you use the default
title and headline.

     sub application { 'CGI::Screen Test' }

Customizing the Trailer
-----------------------

   For a custom Trailer, define the `trailer' method.

     sub trailer {
       my ($query, $screen)  = shift;
     
       "End of Screen $screen";
     }

Multiple Forms
--------------

   If you want to have multiple forms on one screen, call the method
`new_form'.

     sub multi_screen {
        my $query = shift;

     print
       $query->p('This is the Main Screen'),
       $query->textfield('foo'),
       $query->goto('First'),
       $query->new_form,
       $query->textfield('foo'),
       $query->goto('Second');
       }

Non HTML screens
----------------

   You can create non HTML screens by defining a name`_data' method
instead of a <name>`_screen' method. For data screens you have to generate
HTTP headers yourself.

     sub gif_data {
       my $query = shift;
     
       print $query->header(
                            -type    => 'image/gif',
                            -status  => '200 OK',
                            -expires => '+120s',
                           );
       my $font  = $query->param('font');
       my $w     = GD::Font->$font()->width;
       my $h     = GD::Font->$font()->height;
       my $im    = GD::Image->new((length($query->param('foo'))+2)*$w,$h);
       my $white = $im->colorAllocate(255,255,255);
       my $red   = $im->colorAllocate(255,0,0);
       my $black = $im->colorAllocate(0,0,0);
       $im->transparent($white);
       $im->arc(8,8,5,5,0,360,$red);
       $im->string(GD::Font->$font(),10,0,$query->param('foo'),$black);
       print $im->gif;
     }

Keeping parameter values
------------------------

   CGI::Screen keeps track of the CGI parameters used in the current form.
It simply looks at the first parameter in any call to a CGI method.  If
the first parameter is `-name', the second parameter is marked as *used
parameter*.  CGI::Screen passed all current parameter values not used in
hidden fields or in the query string of an anchor. So do not use old style
CGI calls to bypass this mechanism or you will end up with multiple values
for the parameters.

   If you want to get rid of a parameter, you must explicitly call the
delete method of CGI.

BUGS
====

   Support for importing from CGI.pm is incomplete.

AUTHOR
======

   Ulrich Pfeifer <`pfeifer@wait.de'>

SEE ALSO
========

   The CGI(3) manual and the demo CGI script `eg/screen' included in the
distribution.

ACKNOWLEDGEMENTS
================

   I wish to thank Andreas Koenig `koenig@kulturbox.de' for the fruitful
discussion about the design of this module.

Copyright
=========

   The *CGI::Screen* module is Copyright (c) 1997,1998 Ulrich Pfeifer.
Germany.  All rights reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.


File: pm.info,  Node: CGI/State,  Next: CGI/Switch,  Prev: CGI/Screen,  Up: Module List

Converts CGI parameters into a multi-dimensional hash
*****************************************************

NAME
====

   CGI::State - Converts CGI parameters into a multi-dimensional hash

SYNOPSIS
========

   First you make your HTML form to submit to your CGI script.  For
example:

     <form action="order.cgi">
       <input type="text" name="Contact.first_name" value="Dan" />
       <input type="text" name="Contact.email" value="dan@mealtips.com" />
       <input type="hidden" name="item[0].price" value="10.00" />
       <input type="hidden" name="item[0].description" value="Widget" />
       <input type="submit" value="Order Now!" />
     </form>

   Notice the names of the hidden and text fields? Keep this in mind.  Then
you create a CGI script to receive the form variables after they're
submitted:

     #!/usr/bin/perl -wT

     use strict;
     use CGI;
     use CGI::State;
     use Data::Dumper;

     #Simulate receiving CGI parameters
     my $cgi = CGI->new;

     #Un-Flatten the data structure
     my $state = CGI::State->state( $cgi );

     #Show us what the $state hashref now looks like...
     print $cgi->header('text/plain'), Data::Dumper->new([$state], [qw(state)])->Indent(3)->Quotekeys(0)->Dump;

     #Which would print out the following data structure:
     $state = {
                Contact => {
                             first_name => 'Dan',
                             email => 'dan@mealtips.com'
                           },
                item => [
                          #0
                          {
                            description => 'Widget',
                            price => '10.00'
                          }
                        ]
              };

     #Also, you can change $state back into the original query string:
     $cgi = CGI::State->cgi( $state );

     print $cgi->query_string;

     #Which would print out: (in no particular order)
     Contact.first_name=Dan&Contact.email=dan@mealtips.com&item[0].price=10.00&item[0].description=Widget

DESCRIPTION
===========

   This module takes incoming *CGI form variables*, and transforms them
into a *multi-dimensional data structure*.  It can recreate a hash of
hashes, a hash of lists, a hash of lists of hashes etc, any number of
levels deep.

   A limitation of CGI is it's inability to naturally group together
submitted variables.  For example, you can't have someone fill in an order
form and have all their contact and item information grouped separate from
each other in a perl data structure without specifically doing this in the
perl code.

   This module was originally written because I always hated receiving CGI
parameters, putting them into a hash, and have this hash contain 20 or
more elements.  I think it's messy, and very tedious writing code to group
related CGI parameters together.  I wanted parameters to be put into a
multi-dimensional data structure automatically for me.

METHODS
=======

$state = CGI::State->state( $cgi )
     This routine takes one argument, a CGI.pm object reference.

     It will return a hashref containing as many levels as specified in
     the input parameters.

     It allows you to logically group together form elements, so that when
     the CGI script receives them, it has to do no logic of it's own to
     group things together.

     This routine cycles through all the form variables and looks for the
     following format:

          $object_name[$index].$attribute <-- Multivalued

          OR

          $object_name.$attribute         <-- Single valued

          ...And translates them into the following:

          $hashref = {

          $object_name => [

          #$index = 0
          { $attribute => $value },

          #$index = 1
          { $attribute => $value },

          #...

          ],
            }

     It also puts all non-objects into the top-level of the hashref.

     The format I choose to describe the data structure closely resembles
     Javascript's style.  I know, I know. But the syntax is close to perl,
     and should be fairly simple for most perl programmers to pick up.  In
     the future I may change this module to allow you to specify different
     delimeters, to allow more perl-like syntax.

$cgi = CGI::State->cgi( $state )
     This routine takes one argument, a multi-dimensional hash.

     It will return a *flattened* CGI object based on the values
     referenced by $state.  Very useful for maintaining state across
     various CGI invocations.

EXAMPLES
========

   One major advantage to grouping parameters together in a
multi-dimensional data structure is that you have everything map into your
database cleanly.

   For example, let's say that we have a relational table called
*Contact*, which stores information about a customer.  Inside this table
there are three columns called first_name, last_name, and email.

   Imagine there is a form where customer information is collected, such
as the following:

     <form action="save_customer.cgi">
       <input type="text" name="Contact.first_name" />
       <input type="text" name="Contact.last_name" />
       <input type="text" name="Contact.email"  />
     </form>

   When this form is submitted, we create a CGI.pm object to capture the
data, then pass this object off to CGI::State->state, which returns a hash
reference:

     my $cgi   = CGI->new;           #Create the CGI Object
     my $state = CGI::State( $cgi ); #$state is a hash reference

   Assuming that we submit the form, the hash reference would look like
this, as shown by Data::Dumper:

     $state = {
                Contact => {
                             first_name => 'Dan',
                             last_name  => 'Kubb'
                             email      => 'dan@mealtips.com'
                           },
     };

   With this structure, it would be rather easy just to pass off
$state->{Contact} to a subroutine that inserts Contact information into a
database.  There's no sorting, grouping or hard-coding the column names
anywhere in your code!  I am a firm believer that the database table and
column names should dictate the HTML form parameter names, and perl hash
element names.  This module helps enforce that and make it easier to write
code that will "map" HTML forms into a database with minimal effort.

LIMITATIONS
===========

   Having the ability to manipulate the data with simple HTML can either
be seen as a benefit or a liability. I find it a benefit, but I can
imagine that others might not see it that way, especially when
non-programmers are responsible for constructing all web forms.

   Anything you expect to be a hash key should not be a number.

TODO
====

   * Add more security measures and error checking.

SEE ALSO
========

   *Note CGI: CGI,

AUTHOR
======

   Copyright 2001, Dan Kubb <dan@mealtips.com>

   This module is distributed under the same terms as Perl itself.  Feel
free to use, modify and redistribute it as long as you retain the correct
attribution.


File: pm.info,  Node: CGI/Switch,  Next: CGI/Util,  Prev: CGI/State,  Up: Module List

Backward compatibility module for defunct CGI::Switch
*****************************************************

NAME
====

   CGI::Switch - Backward compatibility module for defunct CGI::Switch

SYNOPSIS
========

   Do not use this module.  It is deprecated.

ABSTRACT
========

DESCRIPTION
===========

AUTHOR INFORMATION
==================

BUGS
====

SEE ALSO
========


File: pm.info,  Node: CGI/Util,  Next: CGI/Validate,  Prev: CGI/Switch,  Up: Module List

Internal utilities used by CGI module
*************************************

NAME
====

   CGI::Util - Internal utilities used by CGI module

SYNOPSIS
========

   none

DESCRIPTION
===========

   no public subroutines

AUTHOR INFORMATION
==================

   Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   Address bug reports and comments to: lstein@cshl.org.  When sending bug
reports, please provide the version of CGI.pm, the version of Perl, the
name and version of your Web server, and the name and version of the
operating system you are using.  If the problem is even remotely browser
dependent, please provide information about the affected browers as well.

SEE ALSO
========

   *Note CGI: CGI,


File: pm.info,  Node: CGI/Validate,  Next: CGI/WML,  Prev: CGI/Util,  Up: Module List

Advanced CGI form parser and type validation
********************************************

NAME
====

   CGI::Validate - Advanced CGI form parser and type validation

SYNOPSIS
========

     use CGI::Validate;                # GetFormData() only
     use CGI::Validate qw(:standard);  # Normal use
     use CGI::Validate qw(:subs);      # Just functions
     use CGI::Validate qw(:vars);      # Just exception vars

     ## If you don't want it to check that every requested
     ## element arrived you can use this.  But I don't recommend it
     ## for most users.
     $CGI::Validate::Complete = 0;

     ## If you don't care that some fields in the form don't
     ## actually match what you asked for. -I don't recommend
     ## this unless you REALLY know what you're doing because this
     ## normally meens you've got typo's in your HTML and we can't
     ## catch them if you set this.
     ## $CGI::Validate::IgnoreNonMatchingFields = 1;

     my $FieldOne    = 'Default String';
     my $FieldTwo    = 8;
     my $FieldThree  = 'some default string';
     my @FieldFour   = ();  ## For multi-select field
     my @FieldFive   = ();  ## Ditto
     my $EmailAddress= '';

     ## Try...
     my $Query = GetFormData (
         'FieldOne=s'  => \$FieldOne,     ## Required string
         'FieldTwo=i'  => \$FieldTwo,     ## Required int
         'FieldThree'  => \$FieldThree,   ## Auto converted to the ":s" type
         'FieldFour=s' => \@FieldFour,    ## Multi-select field of strings
         'FieldFive=f' => \@FieldFive,    ## Multi-select field of floats
         'Email=e'     => \$EmailAddress, ## Must 'look' like an email address
     ) or do {
         ## Catch... (wouldn't you just love a case statement here?)
         if (%Missing) {
             die "Missing form elements: " . join (' ', keys %Missing);
         } elsif (%Invalid) {
             die "Invalid form elements: " . join (' ', keys %Invalid);
         } elsif (%Blank) {
             die "Blank form elements: " . join (' ', keys %Blank);
         } elsif (%InvalidType) {
             die "Invalid data types for fields: " . join (' ', keys %InvalidType);
         } else {
             die "GetFormData() exception: $CGI::Validate::Error";
         }
     };

     ## If you only want to check the form data, but don't want to
     ## have CGI::Validate set anything use this. -You still have full
     ## access to the data via the normal B<CGI> object that is returned.

     use CGI::Validate qw(CheckFormData); # not exported by default
     my $Query = CheckFormData (
       'FieldOne=s',   'FieldTwo=i',   'FieldThree',   'FieldFour',
       'FieldFive',    'Email',
     ) or do {
         ... Same exceptions available as GetFormData above ...
     };

     ## Need some of your own validation code to be used?  Here is how you do it.
     addExtensions (
         myType   => sub { $_[0] =~ /test/ },
         fooBar   => \&fooBar,
         i_modify_the_actual_data => sub {
             if ($_[0] =~ /test/) {   ## data validation
                 $_[0] = 'whatever';  ## modify the data by alias
                 return 1;
             } else {
                 return 0;
             }
        },
     );
     my $Query = GetFormData (
         'foo=xmyType'    => \$foo,
         'bar=xfooBar'    => \$bar,
         'cat=xi_modify_the_actual_data' => \$cat,
     );

     ## Builtin data type checks available are:
     s    string     # Any non-zero length value
     w    word       # Must have at least one \w char
     i    integer    # Integer value
     f    float      # Float value
     e    email      # Must match m/^\s*<?[^@<>]+@[^@.<>]+(?:\.[^@.<>]+)+>?\s*$/
     x    extension  # User extension type.  See EXTENSIONS below.

DESCRIPTION
===========

   Basicly a blending of the CGI and Getopt::Long modules, and requires
the CGI module to function.

   The basic concept of this module is to combine the best features of the
CGI and Getopt::Long modules.  The CGI module is great for parsing,
building, and rebuilding forms, however it lacks any real error checking
abilitys such as misspelled form input names, the data types received from
them, missing values, etc.  This however, is something that the
Getopt::Long module is vary good at doing.  So, basicly this module is a
layer that collects the data using the CGI module and passes it to
routines to do type validation and name consistency checks all in one
clean try/catch style block.

   The syntax of GetFormData() is mostly the same as the GetOptions() of
Getopt::Long, with a few exceptions (namely, the handling of exceptions) .
See the VALUE TYPES section for detail of the available types, and the
EXCEPTIONS section for exception handling options.  If given without a
type, fields are assumed to be type ":s" (optional string), which is
normally correct.

   If successful, GetFormData() returns the CGI object that it used to
parse the data incase you want to use it for anything else, and undef
otherwise.

   If you only want to do value type and name validation, use
CheckFormData() instead with a field=type list. -See the SYNOPSIS for an
example.

VALUE TYPES
===========

   All types are prefixed with either a ":" or "=".

   Just like in Getopt::Long, the ":" prefix meens that the value is
optional, but still much match the type that is defined if it is given.
The "=" prefix meens that the value is required for this field, and of
course much match the type given.  If you just want to make sure that some
value is there but don't care about the type, use the required string type
"=s", or required word type "=w".

s
     String type.  Any string will do if the field is optional.  If the
     field is required, then this checks to see if the value length is
     greater then 0.

w
     Word type.  Value must contain at least one \w char to be valid.
     Similar to a s (string) type, but oftin more useful.

i
     Integer type.

f
     Real number (float) type.  Data must be in '1.2' or '12' format.

e
     Email type.  Must look like a valid email address.  White space on
     either end (but not in the middle) is permitted.

          The regex used currently is m/\s*^<?[^@<>]+@[^@.<>]+(\.[^@.<>]+)+>?\s*$/.

xTYPE
     User defined type.  See the EXTENSIONS section below.  This is where
     you get to make up your own tests for this module to use.

EXCEPTIONS
==========

   Exceptions are handled by returning undef, and setting one or more of
five different package global variables.  Think of them first as exception
objects if you must. -They aren't, but they kinda act like it, kinda...
We must use this method until Perl ever gets a real exception system
(eval/die doesn't quite cut it here because we need more information and
with a cleaner way to access it).

   The exceptions are:

%Missing
     Contains all field names we were asked to check for, but the form
     didn't send us at all.  This is not the same as a field that did get
     sent but had no data.  Oftin this is from GetFormData() being given a
     misspelled field name, or the form being sent in an odd manor such as
     an alternate 'submit' button, or just hitting the enter key while in
     the last (probably only) field.

     Probably code bug generated exception.  Check for typos.

%Invalid
     All fields that were not asked to be checked for, but the form sent
     them along anyway.  Most likely these are misspelled field names in
     the HTML form page.

     Probably code bug generated exception.  Check for typos.

%Blank
     All valid fields that were sent with no value AND the type given was
     set to '=' to require the field to be filled in.  The user probably
     just didn't fill in the field(s) at all.  It's not a bad practice to
     make all required fields in form with the word '(required)' next to
     them.  Some users will try many times to fill in a form with as
     little information as they can, as lame as such practice really is.

     Probably a lazy user error generated exception.  Kick the lazy user.

*%InvalidType*.
     The type passed did not match the type asked for.  Such as the value
     'foo' being sent as the value for a field that was marked as being an
     integer, or 'I hate spam' being sent as the value for an email field.

     Probably a user error generated exception.  Kick the lazy user.

$CGI::Validate::Error
     End all, be all dumping ground for exceptions.  If any of the above
     exceptions occurs, the *long messages* are added here.  If any usage
     errors are found, they are added here.  If the moon shifts off it's
     orbit, it's added here.  Use this if you just want to do a simple one
     shot test like:

          GetFormData (foo => \$foo) or die "Parse error: $CGI::Validate::Error";

     Think of it as my version of *$@* if I were to throw "real"
     exceptions. :-)

     This is also used for internal (non-data) error reporting, such as
     not giving me a valid reference type to dump the data into, an
     unbalanced validation list, etc.

   The four hash exceptions have the same format.  The keys are all the
fields that had that kind of exception, and the values are much longer
error messages that give further details that can be useful for debugging.
Generally however, if you need such detail it's much easier to just use
the $CGI::Validate::Error bucket that contains all of the error messages
from all of the exceptions in one place.

EXTENSIONS
==========

   User validation types can be defined using the addExtensions()
function.  addExtensions() takes a hash of extension names and code refs
to use.  All extension names will automatically have an 'x' prepended to
them, so that myType would be xmyType.  Validation code is expected to
return true for valid types, and false/undef for invalid.  Validation code
is passed a single value of the form value.  This value is an alias to the
real data variable so "filters" can be implemented as well that actually
change the data.  Some examples for a Social Security Number checker, and
an amount checker that looks for a number or the string "max" doing a
conversion of "max" to it's own max amount constant:

     my $MAX_AMOUNT = 100;

     addExtensions (
         SSNumber  => sub { $_[0] =~ /^\d{9}$/ },  # SSN must be 9 digit number
         Amount    => sub {
             if ($_[0] =~ /max/i) {
                 $_[0] = $MAX_AMOUNT;  # modify value to be max amount
                 return 1;
             } elsif (($_[0] =~ /^\d+$/) {
                 return 1;
             } else {
                 return 0;
             }
         },
     );
     GetFormData (
         'ssn=xSSNumber'   => \$ssn,
         'amount=xAmount'  => \$amount,
     );

   As such, if the field "amount" were to contain the string "max", it
would be auto-converted to the value of the constant $MAX_AMOUNT (100)
before being assigned to $amount so that no further data changes or checks
are needed.

   All normal exception variables apply.

BUGS
====

   Not tested much with mod_perl, but it should work since each Apache
connection runs in it's own space as it's own process.  Be carful to
manually set your two global config values ($CGI::Validate::Complete and
$CGI::Validate::IgnoreNonMatchingFields) however, even if you use the
"default" values.  This is because as globals they will be recycled on the
next use under mod_perl.

   Email address can never be fully tested (see the Perl FAQ for reasons
why).  The regexp I use is also pretty lame, although I use a better one in
version 1.11+.	This is mainly do to the fact that I don't use it
myself, and don't have much reason to research better methods/checks.  If
you need more extensive testing, feel free to add an extension via
addExtension().

SEE ALSO
========

   perl(1), CGI(3), mod_perl(1)

HISTORY
=======

     $Log: Validate.pm,v $
     Revision 2.0  1998/05/28 10:24:58  byron
     	-Version handling code.
     	-Export symbol names.
     	-How we handle the CGI object data.  Towit, we do some direct internal access for speed
     	 reasons.  Yes, I'm walking into CGI.pm's house without asking, so shoot me.  CGI.pm's
     	 data access methods are so needlessly slow it isn't even funny, but to change them
     	 would break the "documented" interface.  If this proves to be a problem later, I'll probably
     	 just bypass CGI.pm alltogether and do it myself.

     Revision 1.11  1998/05/23 11:16:54  byron
     	-Changed CheckEmail regexp
     	-Better docs
     	-Probably something else...

     Revision 1.10  1998/05/13 21:37:22  byron
     	-Fixed bug from changes in the CGI module interface.

     Revision 1.9  1998/05/11 13:16:48  byron
     	-Added thankyous

     Revision 1.8  1998/05/11 13:06:32  byron
     	-Added CheckFormData()
     	-Added more docs

     Revision 1.7  1998/05/11 12:45:21  byron
     	-Doc changes

     Revision 1.6  1998/05/11 12:36:01  byron
     	-Almost everything
     	-Added user defined types

     Revision 1.5  1998/05/07 13:04:41  byron
     	-Changed float to match /^\d+.?\d*$/ so that ints are ok too

     Revision 1.4  1998/05/07 10:51:23  byron
     	-Changed CGI module access to use ReadParse for speed?
     	-Some doc changes.

     Revision 1.3  1998/03/30 12:12:09  byron
     	-Complete overhaul of the exception handling code.
     	 The old $Error code will still work the same, but there now are much
     	 cleaner ways to figure out exactly what happended and do something
     	 about it.
     	-Changed my email address to match my new account. :-)

     Revision 1.2  1997/12/19 03:46:30  byron
     	-Documentation changes/updates

AUTHOR
======

   Zenin <zenin@archive.rhps.org>

   aka Byron Brummer <byron@omix.com>

   With input from Earl Hood <ehood@geneva.acs.uci.edu>, and Lloyd Zusman
<ljz@asfast.com>, and the email regex from Elijah <http://www.qz.to/~eli/>.

COPYRIGHT
=========

   Copyright (c) 1997,1998 OMIX, Inc.  All rights reserved

   Use is granted under the same terms of Perl.


