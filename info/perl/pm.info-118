This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: DBIx/TextIndex,  Next: DBIx/Tree,  Prev: DBIx/Table,  Up: Module List

Perl extension for full-text searching in SQL databases
*******************************************************

NAME
====

   DBIx::TextIndex - Perl extension for full-text searching in SQL
databases

SYNOPSIS
========

   use DBIx::TextIndex;

   my $index = DBIx::TextIndex->new({     document_dbh => $document_dbh,
 document_table => 'document_table',     document_fields => ['column_1',
'column_2'],     document_id_field => 'primary_key',     index_dbh =>
$index_dbh,     collection => 'collection_1', });

   $index->initialize;

   $index->add_document(\@document_ids);

   my $results = $index->search({     column_1 => '"a phrase" +and -not
or',     column_2 => 'more words', });

   foreach my $document_id     (sort {$$results{$b} <=> $$results{$a}}
keys %$results ) {     print "DocumentID: $document_id Score:
$$results{$document_id} \n"; }

   $index->delete;

DESCRIPTION
===========

   DBIx::TextIndex was developed for doing full-text searches on BLOB
columns stored in a MySQL database.  Almost any database with BLOB and DBI
support should work with minor adjustments to SQL statements in the module.

   Implements a crude parser for tokenizing a user input string into
phrases, can-include words, must-include words, and must-not-include words.

   The following methods are available:

$index = DBIx::TextIndex->new(\%args)
-------------------------------------

   Constructor method.  The first time an index is created, the following
arguments must be passed to new():

   my $index = DBIx::TextIndex->new({     document_dbh => $document_dbh,
 document_table => 'document_table',     document_fields => ['column_1',
'column_2'],     document_id_field => 'primary_key',     index_dbh =>
$index_dbh,     collection => 'collection_1', });

document_dbh
     DBI connection handle to database containing text documents

document_table
     Name of database table containing text documents

document_fields
     Reference to a list of column names to be indexed from document_table

document_id_field
     Name of a unique integer key column in document_table

index_dbh
     DBI connection handle to database containing TextIndex tables.  I
     recommend using a separate database for your TextIndex, because the
     module creates and drops tables without warning.

collection
     A name for the index.  Should contain only alpha-numeric characters or
     underscores [A-Za-z0-9_]

   After creating a new TextIndex for the first time, and after calling
initialize(), only the index_dbh, document_dbh, and collection arguments
are needed to create subsequent instances of a TextIndex.

$index->initialize
------------------

   This method creates all the inverted tables for the TextIndex in the
database specified by document_dbh.  This method should be called only
once when creating a new index!  It drops all the inverted tables before
creating new ones.

   initialize() also stores the document_table, document_fields, and
document_id_field attributes in a special table called "collection," so
subsequent calls to new() for a given collection do not need those
arguments.

$index->add_document(\@document_ids)
------------------------------------

   Add all the @documents_ids from document_id_field to the TextIndex.
@document_ids must be sorted from lowest to highest.  All further calls to
add_document() must use @document_ids higher than those previously added
to the index.  Reindexing previously-indexed documents will yield
unpredictable results!

$index->search(\%search_args)
-----------------------------

   search() returns $results, a reference to a hash.  The keys of the hash
are document ids, and the values are the relative scores of the documents.
If an error occured while searching, $results will be a scalar variable
containing an error message.

   $results = $index->search({     first_field => '+andword -notword
orword "phrase words"',     second_field => ...      ...  });

   if (ref $results) {     print "The score for $document_id is
$results->{$document_id}\n"; } else {     print "Error: $results\n"; }

$index->delete
--------------

   delete() removes the tables associated with a TextIndex from index_dbh.

CHANGES
=======

   0.04 Bug fix: add_document() will return if passed empty array ref
instead of producing error.

     Changed _boolean_compare() and _phrase_search() so and_words and
     phrases behave better in multiple-field searches. Result set for each
     field is calculated first, then union of all fields is taken for
     final result set.

     Scores are scaled lower in _search().

   0.03 Added example scripts in examples/.

   0.02 Added or_mask_set.

   0.01 Initial public release.  Should be considered beta, and methods
may be added or changed until the first stable release.

AUTHOR
======

   Daniel Koch, dkoch@amcity.com

COPYRIGHT
=========

   Copyright 1997, 1998, 1999 by Daniel Koch.  All rights reserved.

LICENSE
=======

   This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself, i.e., under the terms of the "Artistic
License" or the "GNU General Public License".

DISCLAIMER
==========

   This package is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.

   See the "GNU General Public License" for more details.

ACKNOWLEDGEMENTS
================

   Thanks to Ulrich Pfeifer for ideas and code from Man::Index module in
"Information Retrieval, and What pack 'w' Is For" article from The Perl
Journal vol. 2 no. 2.

   Thanks to Steffen Beyer for the Bit::Vector module, which enables fast
set operations in this module. Version 5.3 or greater of Bit::Vector is
required by DBIx::TextIndex.

BUGS
====

   Uses quite a bit of memory.

   MySQL-specific SQL is used.

   Parser is not very good.

   Documentation is not complete.

   Phrase searching relies on full-table scan.  Any suggestions for adding
word-proximity information to the index would be much appreciated.

   No facility for deleting documents from an index.  Work-around: create
a new index.

   Please feel free to email me (dkoch@amcity.com) with any questions or
suggestions.

SEE ALSO
========

   perl(1).


File: pm.info,  Node: DBIx/Tree,  Next: DBIx/UserDB,  Prev: DBIx/TextIndex,  Up: Module List

Perl module for generating a tree from a self-referential table
***************************************************************

NAME
====

   DBIx::Tree - Perl module for generating a tree from a self-referential
table

SYNOPSIS
========

     use DBIx::Tree;
     my $tree = new DBIx::Tree(connection => $dbh,
                               table      => $table,
                               method     => sub { disp_tree(@_) },
                               columns    => [$id_col, $label_col, $parent_col],
                               start_id   => $start_id);
     $tree->do_query;
     $tree->tree;

DESCRIPTION
===========

   When you've got one of those nasty self-referential tables that you want
to bust out into a tree, this is the module to check out.  Assuming there
are no horribly broken nodes in your tree and (heaven forbid) any circular
references, this module will turn something like:

     food                food_id   parent_id
     ==================  =======   =========
     Food                001       NULL
     Beans and Nuts      002       001
     Beans               003       002
     Nuts                004       002
     Black Beans         005       003
     Pecans              006       004
     Kidney Beans        007       003
     Red Kidney Beans    008       007
     Black Kidney Beans  009       007
     Dairy               010       001
     Beverages           011       010
     Whole Milk          012       011
     Skim Milk           013       011
     Cheeses             014       010
     Cheddar             015       014
     Stilton             016       014
     Swiss               017       014
     Gouda               018       014
     Muenster            019       014
     Coffee Milk         020       011

   into:

     Food (001)
       Dairy (010)
         Beverages (011)
           Coffee Milk (020)
           Whole Milk (012)
           Skim Milk (013)
         Cheeses (014)
           Cheddar (015)
           Stilton (016)
           Swiss (017)
           Gouda (018)
           Muenster (019)
       Beans and Nuts (002)
         Beans (003)
           Black Beans (005)
           Kidney Beans (007)
             Red Kidney Beans (008)
             Black Kidney Beans (009)
         Nuts (004)
           Pecans (006)

   There are examples in the examples directory - one plain text example,
and two Tk examples.

Constructor arguments
=====================

     my $tree = new DBIx::Tree(connection => $dbh,
                               table      => $table,
                               method     => sub { disp_tree(@_) },
                               columns    => [$id_col, $label_col, $parent_col],
                               start_id   => $start_id,
                               match_data => $match_data,
                               limit      => $limit);

connection
     A DBI connection handle.

table
     The database table containing the hierarchical data.

method
     A callback method to be invoked each time a tree item is encountered.
     This method will be given a hashtable as a parameter, containing the
     following elements:

          item:        the name of the item
          level (0-n): the nesting level of the item.
          id:          the unique id of the item.

columns:
     A list of three columns from the table:

          id_col:     The unique id.
          label_col:  The textual data of the row, like a name.
          parent_col: The id of the row's parent.

start_id
     The unique id of the root item.

match_data
     The value of a partial match to look for - if this is supplied, only
     rows whose label_col matches (match_data + '%') this will be
     selected. This feature was supplied by Ilia Lobsanov
     <ilia@lobsanov.com>

limit
     Limit the number of rows using an SQL LIMIT clause - not all SQL
     servers support this. This feature was supplied by Ilia Lobsanov
     <ilia@lobsanov.com>

TODO
====

   Graceful handling of circular references.  Better docs.  Rewrite the
algorithm.  Separate data acquisition from data formatting.

AUTHOR
======

   Brian Jepson, bjepson@ids.net

   This module was inspired by the Expanding Hierarchies example that I
stumbled across in the Microsoft SQL Server Database Developer's Companion
section of the Microsoft SQL Server Programmer's Toolkit.

   Jan Mach <machj@ders.cz> contributed substantial performance
improvements, ordering handling for tree output, and other bug fixes.

SEE ALSO
========

   perl(1).  DBI(3).  Tk(3).


File: pm.info,  Node: DBIx/UserDB,  Next: DBIx/XMLMessage,  Prev: DBIx/Tree,  Up: Module List

Module to manage a user database using DBIx::SearchProfiles
***********************************************************

NAME
====

   DBIx::UserDB - Module to manage a user database using
DBIx::SearchProfiles

SYNOPSIS
========

     use DBIx::UserDB;
     use DBIx::SearchProfiles;

     my $db     = new DBIx::SearchProfiles( ... );
     my $userdb = new DBIx::UserDB( $db );

     my $user   = { username => $username, password => $password };
     $user      = $userdb->user_create( $user );

     # Later on
     my $user   = $userdb->login( $user, $password );
     die "Login failed" unless $user;

     # Much later
     if ( $userdb->allowed( $user, $target, "DELETE" ) ) {
     	...
     }

DESCRIPTION
===========

   The DBIx::UserDB uses DBIx::SearchProfiles to manage a user and group
database and may be also used to manage complex ACL. The user and group
schema may be modified for application specific data since only a few
fields are required by the UserDB. This is possible thanks to
DBIx::SearchProfiles.

CONCEPTS
========

Users and Groups
----------------

   Users are represented as hash and as one SQL table. They have a unique
username and a unique uid. Group have also a unique name and a unique gid.
A user may be a members of many groups.

ACLs
----

   UserDB can also be used to manage complex ACL (Acccess Control Lists).
Access to resources is determined by the tuple (user,target,privilege)
which determines if a user has the required *privilege* on target.
*Privilege* and target are treated as application specific character
strings.

CONFIGURATION
=============

   In order to use DBIx::UserDB you will need to create a few tables in
your DMBS and to create the approriate DBIx::SearchProfiles.

   Here is the minimal schema required in your DBMS :

     CREATE TABLE userdb (
     	uid	    SERIAL PRIMARY KEY,
     	username    CHAR(32) UNIQUE,
     	password    CHAR(32)
     );

     CREATE TABLE groupdb (
     	gid	    SERIAL PRIMARY KEY,
     	groupname   CHAR(32) UNIQUE
     );

     CREATE TABLE groupmembers (
     	gid	    INT REFERENCES groupdb,
     	uid	    INT REFERENCES userdb,
     	PRIMARY KEY (gid,uid)
     );

     CREATE TABLE user_acl (
     	uid	    INT REFERENCES userdb,
     	target	    CHAR(128),
     	privilege   CHAR(32),
     	negated	    BOOL DEFAULT 0,
     	PRIMARY KEY (uid,target,privilege)
     );

     CREATE TABLE group_acl (
     	gid	    INT REFERENCES groupdb,
     	target	    CHAR(128),
     	privilege   CHAR(32),
     	negated	    BOOL DEFAULT 0,
     	PRIMARY KEY (gid,target,privilege)
     );

     CREATE TABLE default_acl (
     	target	    CHAR(128),
     	privilege   CHAR(32),
     	negated	    BOOL DEFAULT 0,
     	PRIMARY KEY (target,privilege)
     );

   This SQL was tested with PostgreSQL, modify according to your RDBMS.
And here is its related DBIx::SearchProfiles profile :

     {
     userdb	 =>
       {
        fields	 => [qw( username password ) ],
        keys	 => [qw( uid )],
        table	 => "userdb",
       },
     groupdb	 =>
       {
        query	 => q{ SELECT m.gid,uid,groupname FROM groupdb, groupmembers m
     		       WHERE  uid = ? },
        params	 => [ qw( uid ) ],
        fields	 => [ qw( groupname ) ],
        keys	 => [ qw( gid )],
        table	 => "groupdb",
       }	,
     }

   You may add any fields to the groupdb and userdb tables as long as you
add them to the profiles. The *userdb* profile should be a record profile
(see DBIx::SearchProfiles(3)) and *groupdb* should contains both template
profile's information (for finding the users associated with a group) and
record profile's information (for inserting and updating group's
information). Additionaly you may change the fields length of all required
fields.

   Passwords are uuencoded for storage (for minimal privacy not for
security), so take this into account when setting the password field's
length. If you want to store password in plaintext, use the
`scramble_password' method.

INITIALIZATION
==============

   Initializing the DBIx::UserDB is as simple as

     my $userdb = new DBIx::UserDB( $DB, "userdb", "groupdb" );

   The first parameter is a DBIx::SearchProfiles object which will be used
to access the database. The second parameter is the name of the profile
that should be used to access the users' information (defaults to
"userdb"). The third parameter is the name of the profile to use for group
access (defaults to "groupdb").

scramble_password ( [new_setting] )
-----------------------------------

   Return the scramble password setting. You may also change the setting
by giving the method a new value. If scramble password is true, user's
password will be uuencoded before being stored in the database.

USER METHODS
============

   Here are the methods for managing users in the database.

user_create ( \%user )
----------------------

   This method creates a user with the information specified in the hash
reference in the database. In the user's hash, at least the fields
username and password should be set.

   The methods return true on success and false if there is already a
username with that name in the database. Exception are thrown on database
errors. Additionally, on return, the method will add the UID of the newly
created user.

user_search ( \%params )
------------------------

   This method will return users matching the DBIx::SearchProfiles query
specification in a reference to an array.

user_get ( $uid_or_name )
-------------------------

   This method takes a UID or username and return the corresponding user
(as an hash reference) or undef if there is no such user.

   The key groups in the user's hash contains the names of the groups of
which this user is a member.

user_login ( $username, $password )
-----------------------------------

   This method will return the user which have the corresponding username
and password or undef if the username or password is invalid.

user_delete ( \%user )
----------------------

   This method removes the given user from the database.

user_update ( \%user )
----------------------

   This method updates database information of the given user. This method
has no effects on the group information. Use the `group_add_user' and
`group_remove_user' methods for modifying the groups associated with a
user.

GROUP METHODS
=============

   Here are the methods to manage group information

group_create ( \%group )
------------------------

   This method creates a new group in the database. At least the
*groupname* key should be set in the hash.

   This methods returns false if there is already a group with the same
groupname. It returns true if the creation succeeded. Additionnaly, on
return, the key gid will be set in the original group's hash.

group_search ( \%params )
-------------------------

   This method will search the database for groups matching the
DBIx::SearchProfiles record search and will return its results as a
reference to an hash.

group_get ( $gid_or_name )
--------------------------

   This method takes a gid or groupname and will fetch the corresponding
group. It returns the corresponding group or undef if there is no such
group. Additionnaly there is a key members defined in the resulting hash
which contains in an array the name of all members of the group.

group_delete ( \%group )
------------------------

   This methods removes the given group from the database.

group_update ( \%group )
------------------------

   This methods updates the information associated with the given group in
that database. This methods doesn't modify the list of members of this
group. User `group_add_user' and `group_remove_user' for that.

group_add_user ( \%group, \%user )
----------------------------------

   Adds the user to that group.

group_remove_user ( \%group, \%user )
-------------------------------------

   Removes the user from that group.

ACL METHODS
===========

   Here are the methods to access the ACL information :

grant ( \%user_or_group, $target, $privilege )
----------------------------------------------

   Grant the specified *privilege* on target to that group or user.  If
you want to set the default policy regarding that target and privilege,
use undef as the user parameter.

deny ( \%user_or_group, $target, $privilege )
---------------------------------------------

   Deny the specific *privilege* on target to that group or user. Use undef
if you want the default policy to be deny.

revoke ( \%user_or_group, $target, $privilege )
-----------------------------------------------

   Removes the specified *privilege* on target associated with user or
group. If you want to remove the default policy, use undef as the user
parameter.

   NOTE: Revoking is not the same as denying. Revoking removes the entry
from the ACL which means that the resulting policy will be determined by
other entry in the ACL (i.e: group or default). When using deny, you are
explicitely determining the level of access.

allowed ( \%user, $target, $privilege )
---------------------------------------

   Determine if user has *prilivege* on target. This how the access is
determined :

  1. Determine if there is an entry (user,target,privilege). If an entry is
     found, true or false will be returned depending whether that privilege
     was granted or denied.

  2. Check for an entry (group,target,privilege) for each group of which
     the user is a member. For the group policy to apply, all group must
     share the same result.

     For example, if user A is member of group A and B and group A is
     granted the requested privilege and group B is denied, the group
     policy doesn't apply to that particular user. Schematically :

          Group A Granted + Group B Granted = User Granted
          Group A Granted + Group B Denied  = Default policy will apply
          Group A Denied  + Group B Denied  = User Denied

  3. A entry (target,privilege) will be lookup in the default policy. If
     one is found, that policy will apply.

  4. Access is denied.


BUGS AND LIMITATIONS
====================

   Please report bugs, suggestions, patches and thanks to <bugs@iNsu.COM>.

   Authentication is limited to clear text password authentication.

   User and group data structure is restricted to single level hash.

AUTHOR
======

   Copyright (c) 1999 Francis J. Lacoste and iNsu Innovations Inc.  All
rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms as perl itself.

SEE ALSO
========

   DBIx::SearchProfiles(3) Apache::UserDBAuthen(3) Apache::UserDBAuthz(3)


File: pm.info,  Node: DBIx/XMLMessage,  Next: DBIx/XML_RDB,  Prev: DBIx/UserDB,  Up: Module List

XML Message exchange between DBI data sources
*********************************************

NAME
====

   DBIx::XMLMessage - XML Message exchange between DBI data sources

SYNOPSIS
========

OUTBOUND MESSAGE
----------------

     #!/usr/bin/perl

     use DBI;
     use DBIx::XMLMessage;

     # Template string
     my $tpl_str =<< "_EOT_";
     <?xml version="1.0" encoding="UTF-8" ?>
     <TEMPLATE NAME='SysLogins' TYPE='XML' VERSION='1.0' TABLE='syslogins'>
     <KEY NAME='suid' DATATYPE='NUMERIC' PARENT_NAME='OBJECT_ID' />
     <COLUMN NAME='LoginId' EXPR='suid' DATATYPE='NUMERIC' />
     <COLUMN NAME='PasswordDate' EXPR='pwdate' DATATYPE='DATETIME'
         BLTIN="fix_gmdatetime" />
     <CHILD NAME='SysUsers' TABLE='sysusers'>
         <KEY NAME='suid' PARENT_NAME='LoginId' DATATYPE='NUMERIC' />
         <COLUMN NAME='UserId' EXPR='uid' DATATYPE='NUMERIC' />
         <COLUMN NAME='UserName' EXPR='name' />
     </CHILD>
     </TEMPLATE>
     _EOT_
     my $msg = new DBIx::XMLMessage ('TemplateString' => $tpl_str);
     my $ghash = { 'OBJECT_ID' => [ 1, 2 ] };
     my $dbh = DBI->connect('dbi:Sybase:server=x;database=master','sa','secret');
     $msg->rexec ($dbh, $ghash);

     print "\n\n", $msg->output_xml(0,0);
     print "\n\n", $msg->output_xml(0,1);

INBOUND MESSAGE
---------------

     #!/usr/bin/perl

     use DBI;
     use DBIx::XMLMessage;

     my $template_xml =<< "_EOD1_";
     <?xml version="1.0" encoding="UTF-8" ?>
     <TEMPLATE NAME='SysLogins' TYPE='XML' VERSION='1.0' TABLE='syslogins'
         ACTION='SAVE'>
     <KEY NAME='suid' DATATYPE='NUMERIC' PARENT_NAME='OBJECT_ID' />
     <COLUMN NAME='LoginId' EXPR='suid' DATATYPE='NUMERIC' />
     <COLUMN NAME='PasswordDate' EXPR='pwdate' DATATYPE='DATETIME'
         BLTIN="fix_gmdatetime" />
     <CHILD NAME='SysUsers' TABLE='sysusers'>
         <KEY NAME='suid' PARENT_NAME='LoginId' DATATYPE='NUMERIC' />
         <COLUMN NAME='UserId' EXPR='uid' DATATYPE='NUMERIC' />
         <COLUMN NAME='UserName' EXPR='name' />
     </CHILD>
     </TEMPLATE>
     _EOD1_

     my $message_xml =<< "_EOD2_";
     <?xml version="1.0" encoding="UTF-8"?>
     <SysLogins>
     <LoginId>1</LoginId>
     <PasswordDate>1999/08/17 08:31</PasswordDate>
     <SysUsers>
         <UserId>1</UserId>
         <UserName>sa</UserName>
     </SysUsers>
     </SysLogins>
     _EOD2_

     my $xmlmsg = new DBIx::XMLMessage ('TemplateString' => $template_xml);
     my $msgtype = $xmlmsg->input_xml($message_xml);
     my $ghash = {
         'OBJECT_ID' => [ 1 ]
     };
     $xmlmsg->populate_objects ($ghash);

     my $dbh = DBI->connect('dbi:Sybase:server=x;database=master','sa','secret');
     $xmlmsg->rexec ($dbh, $ghash);
     print $xmlmsg->output_message();

DESCRIPTION
===========

   The package maintains simple XML templates that describe object
structure.

   The package is capable of generating SQL statements based on these
templates and executing them against DBI data sources. After executing the
SQL, the package formats the data results into XML strings. E.g. the
following simple template

     <TEMPLATE NAME='SysLogins' TYPE='XML' VERSION='1.0' TABLE='syslogins'
         ACTION='SAVE'>
     <KEY NAME='suid' DATATYPE='NUMERIC' PARENT_NAME='OBJECT_ID' />
     <COLUMN NAME='LoginId' EXPR='suid' DATATYPE='NUMERIC' />
     </TEMPLATE>

   being executed with key value = 1, will be tranlated into this SQL:

   SELECT suid LoginId FROM syslogins where suid = 1

   and the result will be formatted into this XML string:

     <SysLogins>
         <LoginId>1<LoginId>
     </SysLogins>

   Inbound messages can be processed according to the same kind of
templates and the database is updated accordingly. Templates are capable
of defining the SQL operators, plus new SAVE operation which is basically
a combination of SELECT and either INSERT or UPDATE depending on whether
the record was found by the compound key value or not.

SALES PITCH
===========

   This package allows for objects exchange between different databases.
They could be from different vendors, as long as they both have DBD
drivers. In certain cases it is even possible to exchange objects between
databases with different data models. Publishing of databases on the web
could potentially be one of the applications as well.

TEMPLATE TAGS
=============

TEMPLATE
--------

   This is manadatory top-level tag. It can correspond to a certain table
and be processed just like table-level REFERENCE and CHILD attributes
described below. Some of TEMPLATE attributes are related to the whole
template (e.g.  TYPE or VERSION) while others desribe the table ti's based
on (e.g. TABLE)

   If the TABLE attribute is defined, the generated SQL is going to run
against some table. Otherwise a SQL with no table will be generated. This
only makes sense for outbound messages and only possible on certain
engines, like Sybase. Also, the immediate child columns should contain
constants only for apparent reasons.

REFERENCE
---------

   REFERENCE is a table-level tag. It's meant to represent a single record
from another table that's retrieved by unique key. E.g. if my current
table is EMPL then DEPARTMENT would be a REFERENCE since employee can have
no more than one departament.

CHILD
-----

   This tag meant to represent a number of child records usually retrieved
by a foreign key value (probably primary key of the current table). Right
now there's no difference in processing between CHILD and REFERENCE, but
it may appear in the future releases.

COLUMN
------

   This tag is pretty self-explanatory. Each COLUMN tag will appear on the
SELECT, INSERT or UPDATE list of the generated SQL.

KEY
---

   Key represents linkage of this table's records to the parent table. All
KEY's will appear on the WHERE clause as AND components. This way of
linkage is typical for most of relational systems and considered to be a
good style.  I guess it shouldn't be much of a restriction anyway. If it
gets that, you could try tweak up the WHERE_CLAUSE attribute..

PARAMETER
---------

   This tag represents a parameter that will be passsed to a stored
procedure.  Currently, only Sybase-style stored procedures are supported,
i.e.

   exec proc_name @param_name = 'param_value', ...

   Fixes for Oracle, DB2 and Informix are welcome..

TEMPLATE TAG ATTRIBUTES
=======================

NAME
----

     Applicable to:  All template tags
     Required for:   All template tags

   NAME is the only required attribute for all of the template tags. The
main purpose of it is to specify the tag name as it will appear in the
resulting XML document. Also, depending on the template tag type (COLUMN,
PARAMETER and KEY) it may serve as default value for EXPR discussed below.
Here's a small example of how it works. If my column is represented in the
template like this:

     <COLUMN NAME='ObjectId' />

   the resulting SQL will contain

     SELECT ObjectID, ...

   whereas if I have

     <COLUMN NAME='ObjectId' EXPR='igObjectId' />

   it will generate the following SQL:

     SELECT igObjectId ObjectID, ...

   I.e. in the latter example, NAME used as an alias and EXPR as a real
database column name. The column in the first example has no alias.

ACTION
------

     Applicable to:  TEMPLATE, REFERENCE, CHILD
     Required for:   None

   Possible values for this attibute are SELECT, INSERT, UPDATE, EXEC and
SAVE.  If action is not provided, it is assumed that t he action should be
SELECT.  The first 4 values correspond to SQL data management operators
(EXEC is vendor-specific and represents execution of a stored procedure).
The fifth value, SAVE, is basically a combination of SELECT and either
INSERT or UPDATE, depending on whether the record was found by the
compound key value or not. This often helps to avoid usage of complicated
stored procedures with primary key generation and keep things generic and
scalable. Primary key generation issue is addressed separately by using of
the GENERATE_PK attribute (see below).

BLTIN
-----

     Applicable to:  COLUMN
     Required for:   None

   Represents a perl built-in function. before invocation of this
subroutine the package prepares array @_ and makes it visible to the
built-in function.  The 3 arguments received by the built-in are:
$self   -  DBIx::XMLMessage object     $node   -  Correspondent
DBIx::XMLMessage::COLUMN object. You                can use it to obtain
other column attributes, e.g.                 $node->{DATATYPE}     $value
-  The column value

   Meaning of the value depends on direction of the message, i.e. whether
the message is inbound or outbound. In case of inbound message, this is the
value received by the package from outside world; if the message is inbound
then this is the value selected from database. There's one built-in
function that comes with the package - fix_gmdatetime. It converts date
and time to GMT for outbound messages and from GMT to the database
date/time for inbound messages. Just add one attribute to your datetime
column:

     ... BLTIN="fix_gmdatetime" ...

CARDINALITY
-----------

     Applicable to:   KEY, PARAMETER, REFERENCE, CHILD
     Required for:    None
     Possible values: REQUIRED, OPTIONAL
     Default:         REQUIRED

   This parameter has different meaning for different element types.
Optional KEYs and PARAMETERs allow to proceed execution if the value for
it was not found at some point of execution. Optional CHILDs and
REFERENCEs will be skipped from execution, and hence from output, if the
package failed to collect all the key values.

DATATYPE
--------

     Applicable to:   KEY, PARAMETER, COLUMN
     Required for:    None
     Possible values: CHAR, VARCHAR, VARCHAR2, DATE, DATETIME, NUMERIC
     Default:         CHAR

   This attribute loosely corresponds to the database column type. The only
processing difference in the core package is quoting of the non-numeric
datatypes, particularly those containign substrings CHAR, DATE or TIME.
The built-in fix_gmdatetime utilizes this attribute more extensively.

DEBUG
-----

   Recognized but not currently supported

DEFAULT
-------

     Applicable to:   PARAMETER, COLUMN
     Required for:    None
     Possible values: Any string or number

   This attribute allows to provide a default value for COLUMNs and
PARAMETERS.  Please note that default values are not being formatted, so
they have to represent the literal value. E.g. if you want to provide a
string DEFAULT it would look somewhat like this:     ... DEFAULT =
"'UNKNOWN'"

EXPR
----

     Applicable to:  All template tags
     Required for:   None

   For COLUMN and KEY this attribute represents the actual database column
name or a constant. For PARAMETER

FACE
----

     Applicable to:   COLUMN
     Required for:    None
     Possible values: ATTRIBUTE, TAG
     Default:         TAG

   This attribute allows to output certain columns as attributes, as
opposed to the default TAG-fasion output. Since it's not supported for
inbound messages yet, usage of this feature is not recommended.

GENERATE_PK
-----------

     Applicable to:   COLUMN
     Required for:    None
     Possible values: HASH, SQL returning one value or name

   This attribute allows you to specify how to generate primary key
values. You have 2 options here:

   1. You can write your own Perl function, put its reference to the global
hash under the name of the table for which you intend to generate primary
key values and provide the value of 'HASH' as the GENERATE_PK value

   2. You can put the generating SQL block/statement into the GENERATE_PK
value

HIDDEN
------

     Applicable to:   COLUMN

   Indicates that the column will be excluded from the output. This
attribute only makes sense for outbound messages.

MAXROWS
-------

   Currently not supported. In future, intends to limits the number of
selected rows.

PARENT_NAME
-----------

     Applicable to:   KEY

   Indicates the name of the tag one level up to which this one tag is
corresponding. E.g.

     ...
     <COLUMN NAME='OBJECT_ID'/>
     <REFERENCE ...>
         <KEY NAME='nOrderId' PARENT_NAME='OBJECT_ID'/>
     </REFERENCE>

   This feature is a workaround allowing to have two columns descending
from the same parent column at the same level. There was some other prolem
it was helping to resolve, but I forgot what it was ;^)

PROC
----

     Applicable to:   TEMPLATE, REFERENCE, CHILD

   Used in conjunction with ACTION='PROC'. Defines the name of the stored
procedure to invoke.

RTRIMTEXT
---------

   Currently not supported. The package does automatic right-trimming for
all the character data.

TABLE
-----

   Name of the table against which the SQL will be run.

TOLERANCE
---------

     Applicable to:   TEMPLATE, REFERENCE, CHILD
     Possible values: IGNORE, CREATE, REJECT
     Default:         IGNORE

   Allows to adjust package behaviour when SQL execution produces
unexpected result columns. E.g. if there's a stored procedure that will
return the results for your message, you can omit describing of all the
resulting COLUMNS in the template and instead specify     ...
TOLERANCE='CREATE' Whatever columns are returned by the stored procedure
(Sybase & MS SQL) will be added on-the-fly and available for the output.

WHERE_CLAUSE
------------

   Additional where clause. Added as an AND component at the end of
generated where clause.

METHODS
=======

new
---

     my $xmsg = new DBIx::XMLMessage (
         [ _OnError => $err_coderef, ]
         [ _OnTrace => $trace_coderef, ]
         [ _OnDebug => $debug_coderef, ]
         [ Handlers => $expat_handlers_hashref, ]
         [ TemplateString => $xml_template_as_a_string, ]
         [ TemplateFile => $xml_template_file_name, ]
     )

   You can specify either TemplateString or TemplateFile, but not both. If
any of those specified, the template will be parsed.

set_handlers
------------

     $xmsg->set_handlers ($expat_handlers_hashref)

   Set additional expat handlers, see XML::Parser::Expat. Normally you
won't use this. The only case I could think of is processing of encoding..

prepare_template
----------------

     $xmsg->prepare_template ($template_xml_string)

   This method can be invoked if the template was not specified in the
'new' method invocation.

prepare_template_from_file
--------------------------

     $xmsg->prepare_template_from_file ($template_file_name)

   Same as above, but template is read from file here.

input_xml
---------

     $xmsg->input_xml ($inbound_xml_message_content)

   Parse an inbound XML message. The values form this message will be used
to fill in COLUMNS and PARAMETERS. The structure of this message should
comply with template. Uses Tree parsing style.

input_xml_file
--------------

     $xmsg->input_xml_file ($inbound_xml_message_file_name)

   Same as above, but the XML message is read from a file.

populate_objects
----------------

     $xmsg->populate_objects ($global_hash_ref [, $matching_object
         [, $tag_name [, $tag_content, [$parameter_index]]]])

   This method is trying to stuff the existing template with the inbound
message previously parsed by one of the 'input_xml' methods. The only
mandatory attribute is global hash reference, which has to contain key
values for the topmost tag TEMPLATE.

rexec
-----

     $xmsg->rexec ($dbh, $global_hash_ref)

   This method is running the created query against a DBI/DBD source and
fills in the template with results in order to make them available for
subsequent output_message call. In case of INSERT/UPDATE operations only
key values will be filled in.

output_message
--------------

   This method returns a string with query results in XML format suitable
for printing or whatever manupulations seem appropriate.

SEE ALSO
========

     XML::Parser
     XML::Parser::Expat

AUTHORS
=======

     Andrei Nossov <andrein@andrein.com>

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: DBIx/XML_RDB,  Next: DBM/DBass,  Prev: DBIx/XMLMessage,  Up: Module List

Perl extension for creating XML from existing DBI datasources
*************************************************************

NAME
====

   DBIx::XML_RDB - Perl extension for creating XML from existing DBI
datasources

SYNOPSIS
========

     use DBIx::XML_RDB;
     my $xmlout = DBIx::XML_RDB->new($datasource,
     		"ODBC", $userid, $password, $dbname) || die "Failed to make new xmlout";
     $xmlout->DoSql("select * from MyTable");
     print $xmlout->GetData;

DESCRIPTION
===========

   This module is a simple creator of XML data from DBI datasources. It
allows you to easily extract data from a database, and manipulate later
using XML::Parser.

   One use of this module might be (and will be soon from me) to extract
data on the web server, and send the raw data (in XML format) to a
client's browser, and then use either XML::Parser from PerlScript, or
MSXML from VBScript/JavaScript on the client's machine to generate HTML
(obviously this relies upon using MS IE for their Active Scripting Engine,
and MSXML comes with IE5beta).

   Another use is a simple database extraction tool, which is included,
called sql2xml.  This tool simply dumps a table in a database to an XML
file. This can be used in conjunction with xml2sql (part of the
XML::DBI(?) package) to transfer databases from one platform or database
server to another.

   Binary data is encoded using UTF-8. This is automatically decoded when
parsing with XML::Parser.

   Included with the distribution is a "Scriptlet" - this is basically a
Win32 OLE wrapper around this class, allowing you to call this module from
any application that supports OLE. To install it, first install the
scriptlets download from microsoft at http://msdn.microsoft.com/scripting.
Then right-click on XMLDB.sct in explorer and select "Register". Create
your object as an instance of "XMLDB.Scriptlet".

FUNCTIONS
=========

new
---

     new ( $datasource, $dbidriver, $userid, $password [, $dbname] )

   See the DBI documentation for what each of these means, except for
$dbname which is for support of Sybase and MSSQL server database names
(using "use $dbname").

DoSql
-----

     DoSql ( $sql )

   Takes a simple Sql command string (either a select statement or on some
DBMS's can be a stored procedure call that returns a result set - Sybase
and MSSql support this, I don't know about others).

   This doesn't do any checking if the sql is valid, if it fails, the
procedure will "die", so if you care about that, wrap it in an eval{}
block.

   The result set will be appended to the output. Subsequent calls to
DoSql don't overwrite the output, rather they append to it. This allows
you to call DoSql multiple times before getting the output (via GetData()).

GetData
-------

   Simply returns the XML generated from this SQL call. Unfortunately it
doesn't stream out as yet. I may add this in sometime in the future (this
will probably mean an IO handle being passed to new()).

   The format of the XML output is something like this:

     <?xml version="1.0"?>
     <DBI driver="dbi:Sybase:database=foo">
     	<RESULTSET statement="select * from Table">
     		<ROW>
     		<Col1Name>Data</Col1Name>
     		<Col2Name>Data</Col2Name>
     		...
     		</ROW>
     		<ROW>
     		...
     		</ROW>
     	</RESULTSET>
     	<RESULTSET statement="select * from OtherTable">
     	...
     	</RESULTSET>
     </DBI>

   This is quite easy to parse using XML::Parser.

AUTHOR
======

   Matt Sergeant, matt@sergeant.org

SEE ALSO
========

   XML::Parser


File: pm.info,  Node: DBM/DBass,  Next: DBO,  Prev: DBIx/XML_RDB,  Up: Module List

DBM with associative arrays, file locking and XML records
*********************************************************

NAME
====

   `DBM::DBass' - DBM with associative arrays, file locking and XML records

SYNOPSIS
========

     use DBM::DBass;

     die unless DBM::DBass::gestalt (-api => 'neo');
     my $db = DBM::DBass->new (
         -api  => 'neo',
         -file => '+<file.dbm',
         -lock => 'file.lock',
         -mode => 0644
     );

DESCRIPTION
===========

   This module provides methods to read, write and delete associative
arrays in DBM files, with file locking and XML records.

   It uses a named argument `-api' for class methods new and `gestalt' to
try to prevent later versions of the module from breaking preexisting APIs.

METHODS
=======

`gestalt'
     This method checks for the existence of an API:

          die 'no API neo' unless DBM::DBass::gestalt (-api => 'neo');

     `-api' is the calling API to check for.  One should use this method
     only for development or testing, and not in frequently used
     applications.

new
     This method creates a new DBass object, and should be the first one
     called:

          my $db = DBM::DBass->new (
              '-api'  => 'neo',
              '-file' => '+<file.dbm',
              '-lock' => 'file.lock',
              '-mode' => 0644
          );

     `-api' is the calling API to use.  `-file' is the read/write mode
     (default is read-only) and DBM filename.  `-lock' is the lock
     filename.  `-mode' is the file permissions mode of the DBM file.

     If the DBM file is opened for read-only access, the lock file must
     preexist, but can be empty.  In MacOS, one can create an empty file
     with SimpleText.  In *nix, one can create an empty file with touch:

          touch file.lock

     This version of the module has APIs `xeen' and X<neo>.  The `xeen'
     API is deprecated and provided for backward compatibility only, and
     the `neo' API should be used when possible.

close
     This method releases various resources in the DBass object, to allow
     other processes to access the DBM file:

          $db->close;

     Normally this method should not be used, as it renders the object
     useless for the remainder of the program execution (and is
     automatically called when the object is destroyed).

delete
     This method deletes records from the DBM file:

          $db->delete ('-keys' => \@keys);
          $db->delete ('-keys' => \%keys);
          $db->delete ('-keys' =>  $key );

     *Be careful.*  It can also delete all records:

          $db->delete;

keys
     This method returns record keys:

          my @keys = $db->keys;

read
     This method returns a hash reference pointing to records in the DBM
     file:

          my $smallerhashref = $db->read ('-keys' => \@keys, '-root' => $root);
          my $smallerhashref = $db->read ('-keys' => \%keys, '-root' => $root);
          my $smallhashref   = $db->read ('-keys' =>  $keys, '-root' => $root);
          my $entirehashref  = $db->read ('-root' =>  $root);

     `-keys' are the keys to match against.  `-root' is the XML root tag
     name used in storing the records.

write
     This method writes key-value pairs to the DBM file:

          $db->write (-hash => \%hash, -root => $root);

     `-hash' is the hash reference pointing to the key-value pairs
     (records).  `-root' is the XML root tag name to use in storing the
     records.

KNOWN ISSUES
============

   The `xeen' API is deprecated and provided for backward compatibility
only, and the `neo' API should be used when possible.  The main reason for
the API name change is that the `neo' record format is significantly
different from that of `xeen'.

   On platforms other than MacOS, *nix or Windows NT, flock will probably
cause the module to crash and burn.

   The module should be pronounced `/di'bas/'.

   The `xeen' API is not named after the IBM alphaWorks `Xeena' XML editor.

CHANGES
=======

     0.54  2000.01.19  renamed package to DBM::DBass, as per Tim Bunce

     0.53  2000.01.11  fixed Makefile.PL (oops!)

     0.52  1999.10.30  added check for _OBJ
                       added check for _HASHREF
                       fixed neo_read handling of _UNTAGGED
                       fixed neo_read to check for _HASHREF
                       fixed neo_write to check for _OBJ
                       fixed xeen_delete to check for _OBJ
                       fixed xeen_destroy to check for _OBJ
                       fixed xeen_new die preparation
                       fixed xeen_new to include _UNTAGGED
                       fixed xeen_read handling of _UNTAGGED
                       fixed xeen_read to check for _HASHREF
                       fixed xeen_write to check for _OBJ

     0.51  1999.10.26  fixed gestalt for wantarray
                       fixed neo_read to accept hash references as -keys
                       fixed xeen_delete to accept hash references as -keys
                       fixed xeen_read to accept hash references as -keys

     0.50  1999.10.06  added neo API (valid XML tags and lists of lists)

     0.40  1999.09.20  fixed DBM file locking bug in xeen_destroy
                       fixed DBM file locking bug in xeen_new
                       fixed xeen_delete to accept scalars as -keys
                       fixed xeen_read to accept scalars as -keys

AUTHOR
======

   Copyright 1999, 2000 Nguon Hao Ching (`spiderboy@spiderboy.net').

   This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

CREDITS
=======

   Thanks to Tom Christiansen for Perl Cookbook recipe 14.5.

   Thanks to Mark-Jason Dominus for the Perl Monger tutorial on file
locking.

   Thanks to David Harris and Paul Marquess for the recipe bug report.

   Thanks to Chris Nandor for `perlport'.

   Thanks to James Wismer for feedback on the initial, unreleased version.

   Thanks to Jay Trolley for her patience and understanding.

   Thanks to xeenie for everything else.


File: pm.info,  Node: DBO,  Next: DBZ_File,  Prev: DBM/DBass,  Up: Module List

Database Objects
****************

NAME
====

   `DBO' - Database Objects

SYNOPSIS
========

     use DBO ':constructors';

     $dbh = DBO::Handle::DBI::mysql->connect
       ('dbi:mysql:database:host', 'larry', 'camel');

     $schema = Database
       ( tables =>
         [ Table
     	( name => 'person',
     	  columns =>
     	  [ Char(name => 'name', max_length => 100 ),
     	    Text(name => 'address'),
               Char(name => 'phone', max_length => 30 )])]);

     $dbo = DBO->new
     ( handle => $dbh,
       schema => $schema );

     use DBO::Visitor::Create;
     $dbo->apply_to_database('DBO::Visitor::Create');

DESCRIPTION
===========

   `DBO' is an object-oriented database abstraction layer.

   `DBO' is designed to be flexibly extensible in a number of directions -
adding new operations on the database, adding new kinds of tables or
columns, and applying to new database systems.  All extensions can be
carried out by creating new classes that inherit from the classes `DBO'
defines, and by defining new multimethod instances for those classes.

   `DBO' defines three class hierarchies:

Database operations
     An operation on a database is represented by an object belonging to
     the class `DBO::Visitor'.  `DBO' provides a number of operations
     including Create, Insert and Select.

Schema elements
     The structure of the database is represented by an object belonging to
     the class `DBO::Database', which contains a number of tables
     represented by `DBO::Table', each of which contains a number of
     columns represented by `DBO::Column'.  `DBO' defines many column
     types, including `Char', Text, `Unsigned', Integer and Time.

     Additional features of columns in the schema - such as the values in
     the column being restricted to a set of options, or the column being
     one of the keys of the table - are represented by wrapping the column
     with a `Modifier' class.  `DBO' defines the modifier classes Key,
     Option and `ForeignKey'.  Each column object belonging to the
     modifier class has a reference to another column object that describes
     the underlying type of the column.

     (This design allows a `ForeignKey' column to be implemented by a
     `Char' or Integer or whatever, as the designer wishes, without
     needing extra classes `ForeignKey_Char', `ForeignKey_Integer' and so
     on.)

Database handles
     The database itself is represented by an object belong to the class
     `DBO::Handle'.  `DBO' defines the class `DBO::Handle::DBI' as a thin
     wrapper around DBI, but the facility is there for `DBO' to be applied
     to other kinds of database (or to define more sophisticated wrappers
     around DBI such as "virtual databases" - views that include data from
     more than one database).

   The application of an operation to an element of the schema is
represented by a multimethod instance.  DBO uses three multimethods:

visit_database($visitor, $database, $handle)
visit_table($visitor, $table, $handle)
visit_column($visitor, $column, $handle)
   When $visitor is the generic visitor `DBO::Visitor', `visit_database'
visits all the tables in the database; `visit_table' visits all the
columns in the table, `visit_column' visits the base column when $column
is a `Modifier' column, and does nothing otherwise.

   See *Note Class/Multimethods: Class/Multimethods, for the full details
of the multimethod implementation.

PACKAGE OPTION
==============

   By default, the `DBO' package exports no names and expects you to use a
purely object-oriented interface.

   However, a number of constructor functions simplify the building of
schemas, and these can be imported by passing the `:constructors' key to
the `use DBO' statement.  Then you can write

     Text(name => 'address')

   as a shorthand for

     DBO::Column::Text->new(name => 'address')

THE DBO OBJECT
==============

   The `DBO' class packages up the database schema and the database handle
into one object, with a couple of convenience functions for creating and
applying operations.  (You don't need to use a `DBO' object if you don't
want to.)

   `DBO->new' takes a list of keys and values.  The following keys are
required:

schema
     A database schema, represented by an object of class `DBO::Database'.

handle
     A database handle, represented by an object of class `DBO::Handle'.

SCHEMA ELEMENTS
===============

   All constructors for schema elements are called new, and take a list of
keys and values.

`DBO::Database'
---------------

   A database.  The following key is defined:

tables
     A reference to an array of the tables in the database (each
     represented by a `DBO::Table' object).  Required.

`DBO::Table'
------------

   A table; or more specifically a view onto a table (you can have many
views onto the same table).  The following keys are defined:

id
     An identifying name for this object.  The tables belonging to a
     particular database must have different ids (this only matters when
     there is more than one view onto the same table).  If not supplied,
     the value for the name key is used instead.

name
     The name of the table in the database.  Required.

columns
     A reference to an array of the columns in the table (each represented
     by a `DBO::Column' object).  Required.

`DBO::Column'
-------------

   A generic column.

`DBO::Column::Base'
-------------------

   A column implementation in a table in the database.  The following keys
are defined:

name
     The name of the column in the table.  Required.

`not_null'
     True iff entries in the column are allowed to be NULL.

`DBO::Column::Number'
---------------------

   A column whose values are numbers.

`DBO::Column::Integer'
----------------------

   A column whose values are integers.

`DBO::Column::Unsigned'
-----------------------

   A column whose values are non-negative integers.

`DBO::Column::String'
---------------------

   A column whose values are strings.

`DBO::Column::Char'
-------------------

   A column whose values are fixed-length strings.  The following key is
defined:

max_length
     The maximum length of a value for the column.  Defaults to 10.

`DBO::Column::Text'
-------------------

   A column whose values are variable-length strings.  The following keys
are defined:

`avg_length'
     The average length of a value for the column.  Defaults to 100.  This
     is a performance hint for some databases (e.g. mSQL) and ignored
     elsewhere.

max_length
     The maximum length of a value for the column.  Defaults to 1000.  For
     databases that support arbitrarily long strings, this is ignored.

RATIONALE
=========

SEE ALSO
========

   See *Note Class/Multimethods: Class/Multimethods, (Damian Conway) for
the implementation of multimethods in Perl.

   See `DBI' in this node (Tim Bunce) for Perl's database independent
interface.

   "Design patterns: elements of reusable object-oriented software" by
Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides
(Addison-Wesley 1995) describes the Visitor pattern.

AUTHOR
======

   Gareth Rees `garethr@cre.canon.co.uk'.

COPYRIGHT
=========

   Copyright (c) 1999 Canon Research Centre Europe Ltd.  All rights
reserved.


