This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: LiveGeez/Cgi,  Next: LiveGeez/File,  Prev: LiveGeez/CacheAsSERA,  Up: Module List

Parse a LiveGe'ez CGI Query
***************************

NAME
====

   LiveGeez::Request - Parse a LiveGe'ez CGI Query

SYNOPSIS
========

     use LiveGeez::Request;
     use LiveGeez::Services;

     main:
     {

     my $r = LiveGeez::Request->new;

     ProcessRequest ( $r ) || $r->DieCgi ( "Unrecognized Request." );

     exit (0);

     }

DESCRIPTION
===========

   Request.pm instantiates an object that contains a parsed LiveGe'ez
query.  Upon instantiation the environment is checked for CGI info and
cookie data is read and used.  This does *NOT* happen if a populated hash
table is passed (in which case the hash data is applied) or if "0" is
passed as an arguement.  The request object is required by any other
LiveGe'ez function of object.

AUTHOR
======

   Daniel Yacob,
`LibEth@EthiopiaOnline.Net|mailto:LibEth@EthiopiaOnline.Net' in this node

SEE ALSO
========

   perl(1).  Ethiopic(3).  `http:' in this node


File: pm.info,  Node: LiveGeez/File,  Next: LiveGeez/HTML,  Prev: LiveGeez/Cgi,  Up: Module List

File Openning and Caching for LiveGe'ez
***************************************

NAME
====

   LiveGeez::File - File Openning and Caching for LiveGe'ez

SYNOPSIS
========

     use LiveGeez::Request;
     use LiveGeez::File;

     main:
     {

     my $r = LiveGeez::Request->new;

     my $f = LiveGeez::File->new ( $r );

     $f->Display;

     exit (0);

     }

DESCRIPTION
===========

   File.pm instantiates an object for processing an Ethiopic text or HTML
document.  The constructor requires a LiveGeez::Request object as an
argument.

AUTHOR
======

   Daniel Yacob,
`LibEth@EthiopiaOnline.Net|mailto:LibEth@EthiopiaOnline.Net' in this node

SEE ALSO
========

   perl(1).  Ethiopic(3).  `http:' in this node


File: pm.info,  Node: LiveGeez/HTML,  Next: LiveGeez/Local,  Prev: LiveGeez/File,  Up: Module List

HTML Conversions for LiveGe'ez
******************************

NAME
====

   LiveGeez::HTML - HTML Conversions for LiveGe'ez

SYNOPSIS
========

   FileBuffer ( $f );  # Where $f is a File.pm object.

DESCRIPTION
===========

   HTML.pm contains the routines for conversion of HTML document content
between Ethiopic encoding systems and for pre-interpretation of HTML
markups for compliance with the LiveGe'ez Remote Processing Protocol.

AUTHOR
======

   Daniel Yacob,
`LibEth@EthiopiaOnline.Net|mailto:LibEth@EthiopiaOnline.Net' in this node

SEE ALSO
========

   perl(1).  Ethiopic(3).  `http:' in this node


File: pm.info,  Node: LiveGeez/Local,  Next: LiveGeez/Request,  Prev: LiveGeez/HTML,  Up: Module List

Site Specific Settings for Your LiveGe'ez Installation
******************************************************

NAME
====

   Local - Site Specific Settings for Your LiveGe'ez Installation

SYNOPSIS
========

   use LiveGeez::Local;

DESCRIPTION
===========

   Local.pm is a required module by all other LiveGe'ez modules.  Local.pm
contains site specific settings for default encoding systems, language,
and paths:

'$webRoot'
     Full file system path to where you publish HTML documents.

'$cgiDir'
     Full file system path to where you keep CGI files.

'$scriptURL'
     Complete URL to your Zobel front end script.

'$scriptBase'
     The same front end script with respect to the server root.

'$URLCacheDir'
     Directory where to cache converted documents downloaded by URL.  The
     path may be absolute or relative to where Zobel executes.

'$FileCacheDir'
     Directory where to cache local converted documents.  The path may be
     absolute or relative to where Zobel executes.

'$defaultLang'
     Assumed language for processing transliterated documents and
     performing date conversions.

'$defaultSysIn'
     Assume local files are in this system for conversion input.

'$defaultSysOut'
     The font system for outputting converted documents when no system has
     been specified.

'$processURLs'
     A 0 or 1 value to permit the processing of remote documents.  "1" is a
     friendly value but heavy usage by external websites can impact your
     bandwidth costs and may slow down the processing of local documents
     as more Perl modules are loaded.  "0" restricts Zobel to processing
     only local documents.

'$checkFileDates'
     A 0 or 1 value to force Zobel to compare cached file dates to the
     original documents.  "1" makes Zobel compare dates, slightly
     impacting performance.  "0" prevents Zobel from checking file dates
     -you will then have to delete cache by hand or use the "no-cache"
     pragma to refresh cached documents.

'$iPath'
     Path with respect to the $webRoot where "Image" fidels are stored, if
     any.

'$defaultBGColor'
     The font system for outputting converted documents when no system has
     been specified.

'$cookieDomain'
     Your site name or domain for setting cookies.  Ethiopia Online uses
     ".ethiopiaonline.net".

'$cookieExpires'
     Date when domain cookie should expire.  Such as Menasse Zaudou's
     birthday "Thu, 11-Nov-99 00:00:00 GMT".

AUTHOR
======

   Daniel Yacob,
`LibEth@EthiopiaOnline.Net|mailto:LibEth@EthiopiaOnline.Net' in this node

SEE ALSO
========

   perl(1).  Ethiopic(3).  `http:' in this node


File: pm.info,  Node: LiveGeez/Request,  Next: LiveGeez/Services,  Prev: LiveGeez/Local,  Up: Module List

Parse a LiveGe'ez CGI Query
***************************

NAME
====

   LiveGeez::Request - Parse a LiveGe'ez CGI Query

SYNOPSIS
========

     use LiveGeez::Request;
     use LiveGeez::Services;

     main:
     {

     my $r = LiveGeez::Request->new;

     ProcessRequest ( $r ) || $r->DieCgi ( "Unrecognized Request." );

     exit (0);

     }

DESCRIPTION
===========

   Request.pm instantiates an object that contains a parsed LiveGe'ez
query.  Upon instantiation the environment is checked for CGI info and
cookie data is read and used.  This does *NOT* happen if a populated hash
table is passed (in which case the hash data is applied) or if "0" is
passed as an arguement.  The request object is required by any other
LiveGe'ez function of object.

AUTHOR
======

   Daniel Yacob,
`LibEth@EthiopiaOnline.Net|mailto:LibEth@EthiopiaOnline.Net' in this node

SEE ALSO
========

   perl(1).  Ethiopic(3).  `http:' in this node


File: pm.info,  Node: LiveGeez/Services,  Next: LoadWorm,  Prev: LiveGeez/Request,  Up: Module List

Request Processing Services for LiveGe'ez
*****************************************

NAME
====

   LiveGeez::Services - Request Processing Services for LiveGe'ez

SYNOPSIS
========

     use LiveGeez::Request;
     use LiveGeez::Services;

     main:
     {

     my $r = LiveGeez::Request->new;

     ProcessRequest ( $r ) || $r->DieCgi ( "Unrecognized Request." );

     exit (0);

     }

DESCRIPTION
===========

   Services.pm provides request processing services for a LiveGe'ez query
as specified in the LiveGe'ez Remote Processing Protocol.  "ProcessRequest"
takes a LiveGe'ez LiveGeez::Request object and performs the appropriate
service.

AUTHOR
======

   Daniel Yacob,
`LibEth@EthiopiaOnline.Net|mailto:LibEth@EthiopiaOnline.Net' in this node

SEE ALSO
========

   perl(1).  Ethiopic(3).  `http:' in this node


File: pm.info,  Node: LoadWorm,  Next: Locale/Constants,  Prev: LiveGeez/Services,  Up: Module List

WebSite Stress and Validation Tool
**********************************

NAME
====

   LoadWorm - WebSite Stress and Validation Tool

DESCRIPTION
===========

   The LoadWorm is a tool to load a website with requests, and to record
the resultant performance, from a web client's perspective.  It can also
be used for various investigative purposes, such as validation of the
website, or discovering all the referrers to a page, etc.

   It consists of two main parts -


     LoadWorm - traverses a website, pushing all the buttons, and entering
     data according to specific input instructions.  It will ignore
     specified URL's, limit the number of times a single page is visited,
     and limit the depth of the entire search.  The amount of processing
     required to perform all these tricks makes it too slow to act directly
     as a web-loading tool, so the LoadMaster/Slave was invented to handle
     that job.


     LoadMaster/Slave - Takes a list of URL's (such as that produced by
     the LoadWorm), and directs several "slaves", usually on seperate host
     computers, to make hits on these URL's at a tunable rate.  The
     "slaves" collect data on the response times (and successes/fails),
     which can be harvested and analyzed by the LoadMaster.

   The LoadWorm's operation is controlled by a configuration file.  The
LoadMaster/Slave reads the same configuration file for some of it's
configurables (proxy, verbosity, etc), but is controlled mainly through a
Tk based GUI.

   The LoadWorm and LoadMaster/Slave works on Windows NT and Unix (tested
on Solaris and Linux), or any combination of these systems.

WEBSITE TRAVERSAL
=================

   The LoadWorm takes one or more URLs as input (specified in its
configuration file, `loadworm.cfg').

   * It follows all links, down to a configurable depth.  You may specify
     a different depth limit for different branches of the website(s).

   * Ignores specific links, as specified by matching the URL to regular
     expressions in the configuration file.

   * Generates INPUT data for FORMs, and traverses every possible 'SELECT'
     option and 'SUBMIT' button (filterable by the 'ignore' statements in
     the configuration file).  (Non-multiple type of SELECT, only, in
     version 1.0).

   * The user may specify lists of values for each INPUT field of any of
     the FORMs.  (Text type, only, in version 1.0).

   * A check for a valid response can be customized for each URL (selected
     by a regular expression).  The validation routine can be written by
     the user, in Perl, and is automatically embedded into the process.

   * The results of a LoadWorm session are recorded in a Perl accessible
     database, including a list of all links (child to parent(s)), all
     errors encountered, all links that were ignored, all images that were
     downloaded, and the timings for every download.  The user's
     validation routine may also write to any of these tables.

   * A seperate program (LoadMaster/Slave) is a high intensity web loader
     that will take the route charted by the LoadWorm and repeat the whole
     route, performing the request, response and validation steps without
     the overhead of the route calculations inherent in the LoadWorm's
     configuration.

   * For known bugs and limitations, see `NOTES' in this node, at the
     bottom of this document.

WEBSITE LOADING
===============

   Website loading is performed by the LoadMaster program. The LoadMaster
runs on a master computer.  One or more LoadSlaves may run on the same
computer, or different computers on the same network.  The operator can
control all LoadSlaves from the LoadMaster.  He can start them, pause them,
and tune the loading rate (e.g., total hits per second).

   Which URL's are actually loaded by the LoadSlaves is specified in a
file named `visits.txt'.  This is simply a list of fully specified URL's,
with CGI parameters, such as the one generated by the LoadWorm.  (The PUT
method is not yet implemented here).

   The LoadMaster also reads some parameters from the same configuration
file that serves the LoadWorm.  It conveys these parameters to all the
LoadSlaves, as well as transmitting to them the visits list.

   Each LoadSlave can be configured with a simple rewrite mechanism to
replace specified parameters in each URL with a value received from a
previous response.  Thus, if the website supports it's session state via a
CGI parameter, each slave can log itself in as a seperate session.  This
simple mechanism can be enhanced by working over the Perl code.

   Since it does not need to do any special calculations for laying down
the route, the LoadSlave can perform its operations quickly, utilizing
less memory, than the LoadWorm.  This makes it possible to run several
slaves on the same host computer.  Each LoadSlave must be started manually
on each of the several hosts.  This simplifies the security situation, as
the LoadMaster does not need to directly control anyone else's computer.
Give each LoadSlave the IP address of the LoadMaster when you start each
LoadSlave.  You can start the LoadMaster first, or all the LoadSlaves
first, or in any combination.

   Thus, on the master host computer, use the command:


     `perl loadmaster.pl'

   and on each slave computer, use the command:


     `perl loadslave.pl {IP_ADDR:port_number of LoadMaster}'

   The IP_ADDR and port number of the LoadMaster is displayed on the
LoadMaster GUI when you start it up.  The default port number of the
LoadMaster is 9676 ("WORM" on a phone pad), but it's possible to come up
differently, especially if you're running two LoadMasters on the same
computer.

   If the LoadMaster crashes, or is turned off, the LoadSlaves will wait
patiently for it to come back up, and each will reconnect when it does.
To finish a test, you can terminate all the LoadSlaves from the LoadMaster
GUI, then terminate the LoadMaster.  The owners of the host computers
you've borrowed for the load test might want to terminate the test on
their computer.  They can do that by closing the LoadSlave on their
computer, with no ill effect on your test except for the lost data and
load.

THE CONFIGURATION FILE
======================

   The process of the LoadWorm is controlled by its configuration file.
This file is named `loadworm.cfg', and is found in the current working
directory.  It is structured like a profile.ini file, with [section]
specifying seperate sections, and with parameters and attribute=value
pairs within each section.  The sections include:

[Mode]
     Various modes are set here; depth, timeouts, printing, error
     management, etc.  See `"[Mode]"' in this node.

[Traverse]
     URLs listed here are the anchor(s) of the target website.  See
     `"[Traverse]"' in this node.

[Ignore]
     URLs listed here will be ignored in the traversal.  See `"[Ignore]"'
     in this node.

[Input]
     The user may specify values to be tried as input to each INPUT field
     in each FORM.  See `"[Input]"' in this node.

[Limit]
     To prevent infinite recursion, each page is visited a limited number
     of times (see "Recurse" in `"[Mode]"' in this node).  In the section
     you can specify different limits for different pages.  See
     `"[Limit]"' in this node.

[ReferersReport]
     The webpages that link to the URLs listed here will be recorded as
     such in a "links" database.  See `"[ReferersReport]"' in this node.

[Validation]
     User customizable routines to validate the data that is returned for
     each URL requested.  See `"[Validation]"' in this node.

[Proxy]
     A URL specifying the location of the proxy for web access, if any.
     See `"[Proxy]"' in this node.

[NoProxy]
     Domain names for which the proxy is not to be used.  See
     `"[NoProxy]"' in this node.

[Credentials]
     Authentication credentials for different net locations and realms.
     See `"[Credentials]"' in this node.

[Mode]
------

Depth = n
     The loadworm will go to a maximum of 'n' links down from the anchor
     URL.  Depth=1 would load only the anchor page, and none of its links.

Random = {0,1}
     If non-zero, then links will be traversed in random order, rather
     than in the order that they appear in the visits file.  A value of 1
     will traverse all links in random order.

Recurse = n
     Each URL will be traversed only once, unless the Recurse value is
     more than one.  Then each URL will be traversed the number of times
     specified by Recurse.

Timeout = secs
     Specifies the timeout period for all links (in seconds).  If a link
     does not download completely within the time specified by this value,
     then it is considered a timeout error.  Default = 120 seconds.

NoImages = {0,1}
     If non-zero, ignores all image links.

Verbose = {0,1}
     Controls the verbosity of standard output as the loadworm processes.
     Use 0 for the greatest degree of quiet. Reports on the actual
     performance of the loadworm are created from a database the loadworm
     creates.

Harvest = {0,1}
     Turns off/on the option to harvest the results from the loadslaves.
     Turning it off improves managability, since the slaves then do not
     need to maintain a record of the results.  This also reduces disk
     thrashing when multiple loadslaves are running on a host.  Harvest=0
     is useful if you are monitoring the load on the server's side.

[Traverse]
----------

   Specifies the URL(s) that are the anchor(s) of this test.  These are
the URL(s) that are the anchor(s) of the website to be tested by this
loadworm execution.

[Ignore]
--------

   A list of regular expressions which, if matching a generated URL, will
cause that URL to be ignored.  For instance, .*\.netscape\.com would
prevent the loadworm from traversing any link to the websites of Netscape.
Note that if the URL is explicitly listed in the [Traverse] section, then
any [Ignore] match will, in its turn, be ignored.

[ReferersReport]
----------------

   A list of regular expressions which, when they match a generated URL,
will record in a database all webpages that link to that URL.

[Validation]
------------

   Each link can be validated with a custom Perl subroutine.  The
subroutine is selected by matching the URL to a regex.  The subroutine is
given the URL and the resultant webpage.  The validation routine can then
verify the accuracy of the response, and can write to the loadworm
database files to record successes and/or errors.  Particularly, the
checks table is reserved for this.  It is tied to the hash
`%main::Checks', which is conventionally a hash whose keys are the URLs,
and whose values are whatever string the validation routine wishes to
report about this URL/response pair.  A zero returned from the validation
routine will tell the loadworm to ignore all links within this page.  A
non-zero return will allow normal processing to continue.  For example:


     `.*=AnyURL.pm::Check'

   This will match any URL, and will call your subroutine, "Check", in
your package "AnyURL.pm".  AnyURL.pm must be in the @INC path, and must
include a package statement (e.g. package AnyURL).  See the example,
AnyURL.pm. for details.

[Proxy]
-------

   A URL specifying the location of the proxy for web access, if any.

[NoProxy]
---------

   Domain names for which the proxy is not to be used.

[Credentials]
-------------

   Specifies a list of user ids and passwords for each of the realms that
may require authentication.  The "net location" and "realm" are seperated
by a slash, then "user id" and "password" are seperated by a comma.
"Netlocation/realm" and "userid,password" are then associated with an
equals sign, as in:


     webdev.savesmart.com/Test Server=MyID,twi9y

   "webdev.savemart.com" is the net location, "Test Server" is the realm,
"MyID" is the user id, and "twi9y" is the password.

[Input]
-------

   Each line specifies a list of values to be iterated across whenever a
URL and INPUT line name match the specified regular expression.  The list
is specified as a Perl statement suitable for eval.  This feature will
later allow more elaborate input generation, but for now it allows the
specification of a list of values via qw(list).  For example:


     `login.get, name = qw(test1)'


     `login.get, cardnumber = qw(test1234)'


     `login.get, email = NULL'

   The URL is matched to the first regex (before the comma), then the NAME
of the INPUT field is matched to the second regex (following the comma).
Then the list of values specified by the perl statement (following the
equals sign) is iterated on the matched URL.  The special syntax of NULL
is provided to allow the field to have a null value.

[Limit]
-------

   Each line specifies a regex that will match a URL, and the number of
times that that URL should be visited in a LoadWorm traversal.  Thus,


     `owa/categories\.get=50'


     `owa/favorite\.get=10'


     `owa/cart\.get=5'


     `owa/specials\.get=10'


     `owa/search\.get=10'

   The *owa/categories.get* CGI script will be called only 50 times in the
traversal, *owa/favorite.get* only 10, *owa/cart.get* only 5, etc.  The
count is for all URLs that match these regular expressions.  Thus, it
doesn't matter what the CGI parameters might be to these CGI scripts, the
scripts themselves will be called only as many times as the [Limit]
section specifies.

Example of a Configuration File
-------------------------------

     [Mode]
     Harvest=1
     Depth=10
     Random=1
     Recurse=
     Timeout=30
     Verbose=0
     NoImages=0
     UserAgent=Mozilla/4.01 [en] (WinNT; I)
     Editor="C:\Program Files\TextPad\TxtPad32.exe"
     
     [Traverse]
     http://webdev.savesmart.com
     
     [Credentials]
     webdev.savesmart.com/Test Server=MyID,twi9y
     
     [Ignore]
     www\.
     www6\.
     maps\.
     justgo\.com
     netscape\.com
     /owa/go_home\.get.*
     
     [Limit]
     owa/categories\.get=50
     owa/favorite\.get=10
     owa/cart\.get=5
     owa/specials\.get=10
     owa/search\.get=10
     
     [ReferersReport]
     \.savesmart\.com:900\/
     favorite\.get
     
     [Validation]
     
     [Proxy]
     http://ssgw.savesmart.com
     
     [NoProxy]
     admin
     webdev.savesmart.com
     
     [Input]
     login.get,name=qw(test1)
     login.get,cardnumber=qw(test1234)
     login.get,email=NULL

THE RESULTS DATABASE
====================

   *NOTE: This information is not current, but it gives you the general
idea of what is possible once we tie up a few loose ends.*

   The results of a session of LoadWorm are recorded in a Perl accessible
database.  Although some information is printed to standard output as the
session progresses, the most interesting results should be discovered by
scanning the LoadWorm database for that session.  The database consists of
several hash-tied tables.  Each table is keyed by the URL associated with
it, and the value will be a string representing the result.  For some of
these tables, the result is an array of strings representing several
interactions with that URL.  Unfortunately, Perl's built-in Tie::Hash will
not record arrays in a tied table.  For these tables, the data is
converted to ASCII text data and written to a sequential file.  The Perl
code listed below can be used to pull this sequential file back into a
hashed array in your Perl report generator.

referers
     This relates URLs of the website to the parent pages that contain
     them.  @referers{$childURL} is an array of URLs of pages that link to
     $childURL.  (This table does not include images.  These are recorded
     in the images table.  It does include all ignored URLs.)  Note: this
     file is not a hash-tied database file, but a sequential file
     containing data that can be imported into a hashed table with the
     Perl code listed below (tbl2hash.pl).

errors
     This is a list of all the URLs that failed to download.
     $errors{$URL} is the error message associated with the attempt to
     download $URL.

ignores
     This is a list of all URLs that were encountered in the website, but
     were ignored because they match some regular expression in the
     [Ignore] section of the configuration file.  $ignore{$URL} is the
     regular expression that caused $URL to be included in this list.

timings
     This text file records the time of each request, and the time of
     completion of that request.  Each record consists of two (or more)
     lines.  The first line contains the URL.  The second line contains
     the start time, the finish time, and the size in a string like
     (hh:mm:ss.hh,hh:mm:ss.hh size).  The size might be the string
     "FAILED", instead, indicating that the request failed.  Then, the
     following lines will contain the reason for the failure, until a line
     containing a copy of the original "FAILED" line.  Thus, timings
     includes the time for failed downloads as well as successful ones.

checks
     This table is written by the user-customized validation routine(s).

          tbl2hash.pl

          %Linkages = ();
          open TBL, "<linkages";
          while ( <TBL> )  {
          	if ( $_ !~ /^\s/ )  {
          		$ky = $_;
          	}
          	else {
          		s/^\s*//;
          		push @{  $Linkages{$ky}  }, $_;
          	}
          }

NOTES
=====

   * Watch for #tag in CGI function names.

   * To specify an image click position, define the key as the image name,
     and the value as "image.x=x&image.y=y".

   * Due to our as yet incomplete control of the TCP/IP layer in this
     program, we can not actually duplicate the conditions of modem (or
     any other low data rate) access to the website.  Some conditions of
     our multiple client, high speed data transfers will be different than
     when many clients are accessing the website at lower speeds.

   * Each loadslave is limited to twenty-three simultaneous connections.
     Subsequent connections fail when trying to register (or is it when
     trying to connect?).  This is a limitation imposed by the operating
     system when the Perl executable was compiled.  We have hard-coded a
     governor at 20 connections to avoid this limit.  Multiple instances
     may be run on a single host, but each one has the same limit.

   * The LoadMaster can not accept connections from more that 28
     LoadSlaves (for the same reason).

   * Consequently, the upper limit to the loadtest is 28x23, or 644
     simultaneous connections to the web-server.  Is there anyway to
     increase this?  We can run multiple loadmasters, I suppose; does it
     make sense, then, to have a super-loadmaster, or perhaps loadslave
     monitors, so that the load master talks to one slave monitor, which
     deals with the (up to twenty-eight) loadslaves on it's own NT?  Etc.

PREREQUESITES
=============

   These are the versions of Perl modules under which LoadWorm is known to
work.  It may be just fine with earlier or later versions.

   * Perl 5.004 (thanks, Larry!)

   * `LWP' from libwww-perl-5_20

   * `LWP::Parallel' from ParallelUserAgent-v2_31 (a special thanks to
     Marc Langheinrich!)

   * Tk from Tk402_003

   * Time::Local and `Time::HiRes' for Unix OS.

   * Win32 for Win32 OS.

   * And various core Perl modules, including English, File::Path,
     File::Copy, Socket, Carp, FileHandle, and Sys::Hostname.

AUTHOR
======

   Glenn Wood, Glenn.Wood@SaveSmart.com

   Copyright 1997-1998 SaveSmart, Inc.

   Released under the Perl Artistic License.

   $Id: loadworm.pm 1.26 1998/07/01 05:17:24 Glenn dev $


File: pm.info,  Node: Locale/Constants,  Next: Locale/Country,  Prev: LoadWorm,  Up: Module List

constants for Locale codes
**************************

NAME
====

   Locale::Constants - constants for Locale codes

SYNOPSIS
========

     use Locale::Constants;
     
     $codeset = LOCALE_CODE_ALPHA_2;

DESCRIPTION
===========

   *Locale::Constants* defines symbols which are used in the three modules
from the Locale-Codes distribution:

     Locale::Language
     Locale::Country
     Locale::Currency

   Note: at the moment only Locale::Country supports more than one code
set.

   The symbols defined are used to specify which codes you want to be used:

     LOCALE_CODE_ALPHA_2
     LOCALE_CODE_ALPHA_3
     LOCALE_CODE_NUMERIC

   You shouldn't have to use this module directly yourself - it is used by
the three Locale modules, which in turn export the symbols.

KNOWN BUGS AND LIMITATIONS
==========================

   None at the moment.

SEE ALSO
========

Locale::Language
     Codes for identification of languages.

Locale::Country
     Codes for identification of countries.

Locale::Currency
     Codes for identification of currencies and funds.

AUTHOR
======

   Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (C) 2001, Canon Research Centre Europe (CRE).

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Locale/Country,  Next: Locale/Currency,  Prev: Locale/Constants,  Up: Module List

ISO codes for country identification (ISO 3166)
***********************************************

NAME
====

   Locale::Country - ISO codes for country identification (ISO 3166)

SYNOPSIS
========

     use Locale::Country;
     
     $country = code2country('jp');               # $country gets 'Japan'
     $code    = country2code('Norway');           # $code gets 'no'
     
     @codes   = all_country_codes();
     @names   = all_country_names();
     
     # add "uk" as a pseudo country code for United Kingdom
     Locale::Country::_alias_code('uk' => 'gb');

DESCRIPTION
===========

   The Locale::Country module provides access to the ISO codes for
identifying countries, as defined in ISO 3166.  You can either access the
codes via the `conversion routines' in this node (described below), or
with the two functions which return lists of all country codes or all
country names.

   There are three different code sets you can use for identifying
countries:

alpha-2
     Two letter codes, such as 'tv' for Tuvalu.  This code set is
     identified with the symbol `LOCALE_CODE_ALPHA_2'.

alpha-3
     Three letter codes, such as 'brb' for Barbados.  This code set is
     identified with the symbol `LOCALE_CODE_ALPHA_3'.

numeric
     Numeric codes, such as 064 for Bhutan.  This code set is identified
     with the symbol `LOCALE_CODE_NUMERIC'.

   All of the routines take an optional additional argument which
specifies the code set to use.  If not specified, it defaults to the
two-letter codes.  This is partly for backwards compatibility (previous
versions of this module only supported the alpha-2 codes), and partly
because they are the most widely used codes.

   The alpha-2 and alpha-3 codes are not case-dependent, so you can use
'BO', 'Bo', 'bO' or 'bo' for Bolivia.  When a code is returned by one of
the functions in this module, it will always be lower-case.

CONVERSION ROUTINES
===================

   There are three conversion routines: `code2country()', `country2code()',
and `country_code2code()'.

code2country( CODE, [ CODESET ] )
     This function takes a country code and returns a string which
     contains the name of the country identified.  If the code is not a
     valid country code, as defined by ISO 3166, then undef will be
     returned:

          $country = code2country('fi');

country2code( STRING, [ CODESET ] )
     This function takes a country name and returns the corresponding
     country code, if such exists.  If the argument could not be
     identified as a country name, then undef will be returned:

          $code = country2code('Norway', LOCALE_CODE_ALPHA_3);
          # $code will now be 'nor'

     The case of the country name is not important.  See the section
     `KNOWN BUGS AND LIMITATIONS' in this node below.

country_code2code( CODE, CODESET, CODESET )
     This function takes a country code from one code set, and returns the
     corresponding code from another code set.

          $alpha2 = country_code2code('fin',
          		 LOCALE_CODE_ALPHA_3 => LOCALE_CODE_ALPHA_2);
          # $alpha2 will now be 'fi'

     If the code passed is not a valid country code in the first code set,
     or if there isn't a code for the corresponding country in the second
     code set, then undef will be returned.

QUERY ROUTINES
==============

   There are two function which can be used to obtain a list of all codes,
or all country names:

`all_country_codes( [ CODESET ] )'
     Returns a list of all two-letter country codes.  The codes are
     guaranteed to be all lower-case, and not in any particular order.

`all_country_names( [ CODESET ] )'
     Returns a list of all country names for which there is a corresponding
     country code in the specified code set.  The names are capitalised,
     and not returned in any particular order.

     Not all countries have alpha-3 and numeric codes - some just have an
     alpha-2 code, so you'll get a different number of countries depending
     on which code set you specify.

CODE ALIASING
=============

   This module supports a semi-private routine for specifying two letter
code aliases.

     Locale::Country::_alias_code( ALIAS => CODE [, CODESET ] )

   This feature was added as a mechanism for handling a "uk" code. The ISO
standard says that the two-letter code for "United Kingdom" is "gb",
whereas domain names are all .uk.

   By default the module does not understand "uk", since it is implementing
an ISO standard. If you would like 'uk' to work as the two-letter code for
United Kingdom, use the following:

     use Locale::Country;
     
     Locale::Country::_alias_code('uk' => 'gb');

   With this code, both "uk" and "gb" are valid codes for United Kingdom,
with the reverse lookup returning "uk" rather than the usual "gb".

EXAMPLES
========

   The following example illustrates use of the `code2country()' function.
The user is prompted for a country code, and then told the corresponding
country name:

     $| = 1;   # turn off buffering
     
     print "Enter country code: ";
     chop($code = <STDIN>);
     $country = code2country($code, LOCALE_CODE_ALPHA_2);
     if (defined $country)
     {
         print "$code = $country\n";
     }
     else
     {
         print "'$code' is not a valid country code!\n";
     }

DOMAIN NAMES
============

   Most top-level domain names are based on these codes, but there are
certain codes which aren't.  If you are using this module to identify
country from hostname, your best bet is to preprocess the country code.

   For example, *edu*, *com*, *gov* and friends would map to *us*; *uk*
would map to *gb*. Any others?

KNOWN BUGS AND LIMITATIONS
==========================

   * When using `country2code()', the country name must currently appear
     exactly as it does in the source of the module. For example,

          country2code('United States')

     will return *us*, as expected. But the following will all return
     undef:

          country2code('United States of America')
          country2code('Great Britain')
          country2code('U.S.A.')

     If there's need for it, a future version could have variants for
     country names.

   * In the current implementation, all data is read in when the module is
     loaded, and then held in memory.  A lazy implementation would be more
     memory friendly.

SEE ALSO
========

Locale::Language
     ISO two letter codes for identification of language (ISO 639).

Locale::Currency
     ISO three letter codes for identification of currencies and funds
     (ISO 4217).

ISO 3166
     The ISO standard which defines these codes.

http://www.din.de/gremien/nas/nabd/iso3166ma/
     Official home page for ISO 3166

http://www.egt.ie/standards/iso3166/iso3166-1-en.html
     Another useful, but not official, home page.

http://www.cia.gov/cia/publications/factbook/docs/app-f.html
     An appendix in the CIA world fact book which lists country codes as
     defined by ISO 3166, FIPS 10-4, and internet domain names.

AUTHOR
======

   Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Locale/Currency,  Next: Locale/Language,  Prev: Locale/Country,  Up: Module List

ISO three letter codes for currency identification (ISO 4217)
*************************************************************

NAME
====

   Locale::Currency - ISO three letter codes for currency identification
(ISO 4217)

SYNOPSIS
========

     use Locale::Currency;

     $curr = code2currency('usd');     # $curr gets 'US Dollar'
     $code = currency2code('Euro');    # $code gets 'eur'

     @codes   = all_currency_codes();
     @names   = all_currency_names();

DESCRIPTION
===========

   The Locale::Currency module provides access to the ISO three-letter
codes for identifying currencies and funds, as defined in ISO 4217.  You
can either access the codes via the `conversion routines' in this node
(described below), or with the two functions which return lists of all
currency codes or all currency names.

   There are two special codes defined by the standard which aren't
understood by this module:

XTS
     Specifically reserved for testing purposes.

XXX
     For transactions where no currency is involved.

CONVERSION ROUTINES
===================

   There are two conversion routines: code2currency() and currency2code().

code2currency()
     This function takes a three letter currency code and returns a string
     which contains the name of the currency identified. If the code is
     not a valid currency code, as defined by ISO 4217, then undef will be
     returned.

          $curr = code2currency($code);

currency2code()
     This function takes a currency name and returns the corresponding
     three letter currency code, if such exists.  If the argument could
     not be identified as a currency name, then undef will be returned.

          $code = currency2code('French Franc');

     The case of the currency name is not important.  See the section
     `KNOWN BUGS AND LIMITATIONS' in this node below.

QUERY ROUTINES
==============

   There are two function which can be used to obtain a list of all
currency codes, or all currency names:

`all_currency_codes()'
     Returns a list of all three-letter currency codes.  The codes are
     guaranteed to be all lower-case, and not in any particular order.

`all_currency_names()'
     Returns a list of all currency names for which there is a
     corresponding three-letter currency code. The names are capitalised,
     and not returned in any particular order.

EXAMPLES
========

   The following example illustrates use of the code2currency() function.
The user is prompted for a currency code, and then told the corresponding
currency name:

     $| = 1;    # turn off buffering

     print "Enter currency code: ";
     chop($code = <STDIN>);
     $curr = code2currency($code);
     if (defined $curr)
     {
         print "$code = $curr\n";
     }
     else
     {
         print "'$code' is not a valid currency code!\n";
     }

KNOWN BUGS AND LIMITATIONS
==========================

   * In the current implementation, all data is read in when the module is
     loaded, and then held in memory.  A lazy implementation would be more
     memory friendly.

   * This module also includes the special codes which are not for a
     currency, such as Gold, Platinum, etc.  This might cause a problem if
     you're using this module to display a list of currencies.  Let Neil
     know if this does cause a problem, and we can do something about it.

   * ISO 4217 also defines a numeric code for each currency.  Currency
     codes are not currently supported by this module.

   * There are three cases where there is more than one code for the same
     currency name.  Kwacha has two codes: mwk for Malawi, and zmk for
     Zambia.  The Russian Ruble has two codes: rub and rur.  The
     Belarussian Ruble has two codes: byr and byb.  The currency2code()
     function only returns one code, so you might not get back the code
     you expected.

SEE ALSO
========

Locale::Country
     ISO codes for identification of country (ISO 3166).  Supports
     alpha-2, alpha-3, and numeric codes.  The currency codes use the
     alpha-2 codeset.

ISO 4217:1995
     Code for the representation of currencies and funds.

http://www.bsi-global.com/iso4217currency
     Official web page for the ISO 4217 maintenance agency.  This has the
     latest list of codes, in MS Word format. Boo.

AUTHOR
======

   Michael Hennecke <hennecke@rz.uni-karlsruhe.de> and Neil Bowers
<neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 2001 Michael Hennecke and Canon Research Centre Europe
(CRE).

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Locale/Language,  Next: Locale/Maketext,  Prev: Locale/Currency,  Up: Module List

ISO two letter codes for language identification (ISO 639)
**********************************************************

NAME
====

   Locale::Language - ISO two letter codes for language identification
(ISO 639)

SYNOPSIS
========

     use Locale::Language;
     
     $lang = code2language('en');        # $lang gets 'English'
     $code = language2code('French');    # $code gets 'fr'
     
     @codes   = all_language_codes();
     @names   = all_language_names();

DESCRIPTION
===========

   The Locale::Language module provides access to the ISO two-letter codes
for identifying languages, as defined in ISO 639. You can either access
the codes via the `conversion routines' in this node (described below), or
with the two functions which return lists of all language codes or all
language names.

CONVERSION ROUTINES
===================

   There are two conversion routines: code2language() and language2code().

code2language()
     This function takes a two letter language code and returns a string
     which contains the name of the language identified. If the code is
     not a valid language code, as defined by ISO 639, then undef will be
     returned.

          $lang = code2language($code);

language2code()
     This function takes a language name and returns the corresponding two
     letter language code, if such exists.  If the argument could not be
     identified as a language name, then undef will be returned.

          $code = language2code('French');

     The case of the language name is not important.  See the section
     `KNOWN BUGS AND LIMITATIONS' in this node below.

QUERY ROUTINES
==============

   There are two function which can be used to obtain a list of all
language codes, or all language names:

`all_language_codes()'
     Returns a list of all two-letter language codes.  The codes are
     guaranteed to be all lower-case, and not in any particular order.

`all_language_names()'
     Returns a list of all language names for which there is a
     corresponding two-letter language code. The names are capitalised,
     and not returned in any particular order.

EXAMPLES
========

   The following example illustrates use of the code2language() function.
The user is prompted for a language code, and then told the corresponding
language name:

     $| = 1;    # turn off buffering
     
     print "Enter language code: ";
     chop($code = <STDIN>);
     $lang = code2language($code);
     if (defined $lang)
     {
         print "$code = $lang\n";
     }
     else
     {
         print "'$code' is not a valid language code!\n";
     }

KNOWN BUGS AND LIMITATIONS
==========================

   * In the current implementation, all data is read in when the module is
     loaded, and then held in memory.  A lazy implementation would be more
     memory friendly.

   * Currently just supports the two letter language codes - there are
     also three-letter codes, and numbers.  Would these be of any use to
     anyone?

SEE ALSO
========

Locale::Country
     ISO codes for identification of country (ISO 3166).  Supports
     2-letter, 3-letter, and numeric country codes.

Locale::Currency
     ISO three letter codes for identification of currencies and funds
     (ISO 4217).

ISO 639:1988 (E/F)
     Code for the representation of names of languages.

http://lcweb.loc.gov/standards/iso639-2/langhome.html
     Home page for ISO 639-2

AUTHOR
======

   Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Locale/Maketext,  Next: Locale/Msgcat,  Prev: Locale/Language,  Up: Module List

framework for software localization
***********************************

NAME
====

   Locale::Maketext - framework for software localization

SYNOPSIS
========

     [to be written]

DESCRIPTION
===========

   Locale::Maketext is a base class providing a framework for
inheritance-based lexicons for software localization.

   Further documentation is forthcoming.

Methods You May Override
========================

   These are all simple methods you should feel welcome to override as you
like.

the method $LH->encoding
     [to be written]

the method $LH->fallback_languages
     [to be written]

the method $LH->sprintf(FORMAT, PARAMS)
     Just a wrapper for the normal Perl builtin function sprintf - it's
     here so you can use sprintf in bracketish notation.

the method $LH->quant
     [to be written]

the method $LH->numerate
     [to be written]

the method $LH->numf(NUMBER)
     This returns NUMBER formatted appropriately for the conventions of
     $LH's language.  The default behavior for this is just to get
     sprintf("%g", NUMBER), then to tr/,./.,/ it if $LH->{'numf_comma'} is
     true, and then to return it.

the method CLASS->new
     This is used by CLASS->get_handle to actually perform the
     instantiation of each language-handle object into its class.
     Currently it just creates and blesses an empty hashref, and calls
     $LH->init on it.

the method $LH->init
     This is used by CLASS->new to initialize newly instantiated
     language-handle objects.  Currently this is a no-op.

STUFF
-----

the method $LH->maketext(TEXT, PARAMS)
     This looks up the entry for TEXT in the the lexicon for $LH's class
     and its superclasses (via $LH->lookup(TEXT)), and, assuming it's a
     coderef, returns the return value of &$coderef($LH, PARAMS), which is
     presumably a single scalar.

     If $LH->lookup(TEXT) failed (i.e., returned undef), then `maketext'
     fails according to whatever mechanism is set in $LH's "fail" attribute
     - if the 'fail' attribute is set to a coderef, maketext returns the
     output of `&{$fail_coderef}($LH, TEXT, PARAMS)'.  If $LH's "fail"
     attribute is set to a contentful string (i.e., not undef or ""),
     that's considered to be a method name, and maketext returns the output
     of $handle->methodname(TEXT, PARAMS).  Otherwise, maketext returns
     undef.

     (Actually, in all the cases above where maketext passes values to
     other subs, it passes *copies* of TEXT and/or PARAMS, so that the
     actual values passed to maketext can't be altered in-place.  This is
     to parallel the way Perl copies @_ for method calls.)

the constructor CLASS->get_handle(LANGUAGES)
     Constructs a language handle based on the list of locale IDs and/or
     language tags in the list LANGUAGES.

the method $LH->fail_with(FAILSPEC)
     This sets the "fail" attribute of a given language handle.  See the
     docs for $LH->maketext(TEXT, PARAMS).

the method $LH->fail_with
     This returns the value of $LH's "fail" attribute.

the method 'failure_handler_auto'
     [to be written]

the method $LH->lookup(TEXT)
     This looks up the entry TEXT in the lexicons for the handle $LH.  This
     is used by $LH->maketext(TEXT).

     If $LH->lookup(TEXT) looks across the lexicons for $LH (which are
     gotten via $LH->lex_refs), this returns undef.  Otherwise:

     For the first lexicon containing an entry for TEXT, if that entry is a
     coderef (presumably thru being an anonymous sub, but it doesn't
     matter), it's returned.

     If, however, the entry for TEXT is a string, that entry is *replaced*
     with the contents of $LH->compile($that_lexicon{TEXT}), and that value
     is returned.

     Magic happens when lookup looks in a lexicon where you have set
     $Lexicon{'_AUTO'} = 1.  This `_AUTO' flag means that a lookup in that
     lexicon can't really fail - if there is no entry for TEXT,
     $LH->lookup(TEXT) will set $Lexicon{TEXT} = $LH->compile(TEXT), and
     return that value.  This is generally useful only in base classes, as
     a way to mitigate lookup failures.

the method $LH->compile(TEXT) or CLASS->compile(TEXT)
     This takes text in bracketish notation (presumably just retrieved via
     a lexicon returned from $LH->lex_refs), and returns an anonymous sub
     that is that text compiled into Perl.

     Used by $LH->lookup(TEXT).

the method $LH->lex_refs
     This returns a list of hashrefs which are the lexicons for the class
     that this handle belongs to.  This is figured out by looking in the
     package for $LH's class, and the packages of the classes in its @ISA
     tree.  The results of this are memoized for each class.  This assumes
     that no class's @ISA will change after you've started calling maketext
     methods.  I think this is a sane assumption, but in the *very*
     surprising case of you modifying @ISAs dynamically, you can call
     clear_isa_scan to clear all the memoization.

     You should not override this method.

the routine Locale::Maketext::clear_isa_scan
also: the routine $LH->clear_isa_scan
also: the routine CLASS->clear_isa_scan
     This clears all of `lex_ref''s memoization of all @ISA trees.

     You should not override this method.

COPYRIGHT
=========

   Copyright 1999-2000, Sean M. Burke `sburke@cpan.org', all rights
reserved.  This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

AUTHOR
======

   Sean M. Burke, `sburke@cpan.org'


File: pm.info,  Node: Locale/Msgcat,  Next: Locale/PGetText,  Prev: Locale/Maketext,  Up: Module List

Perl extension for blah blah blah
*********************************

NAME
====

   Locale::Msgcat - Perl extension for blah blah blah

SYNOPSIS
========

     use Locale::Msgcat;
     
     $cat = new Locale::Msgcat;

     $rc  = $cat->catopen(name, oflag);
     $msg = $cat->catgets(set_number, message_number, string);
     $rc  = $cat->catclose();

DESCRIPTION
===========

   The *Locale::Msgcat* module allows access to the message catalog
functions which are available on some systems. A new Locale::Msgcat object
must first be created for each catalog which has to be open at a given
time.

   The *catopen* operation opens the catalog whose name is given as
argument.  The oflag can be either 0 or NL_CAT_LOCALE (usually 1) which is
the recommended value.

   The *catgets* message retrieves message_number for the set_number
message set, and if not found returns string.

   The *catclose* function should be used when access to a catalog is not
needed anymore.

EXAMPLES
========

     use Locale::Msgcat;

     $cat = new Locale::Msgcat;
     unless ($cat->catopen("whois.cat", 1)) {
         print STDERR "Can't open whois catalog.\n";
         exit(1);
     }
     printf "First message, first set : %s\n", $cat->catgets(1, 1, "not found");
     unless ($cat->catclose()) {
         print STDERR "Can't close whois catalog.\n";
         exit(1);
     }

   The above example would print the first message from the first message
set found in the whois catalog, or if not found it would print "not found".

AUTHOR
======

   Christophe Wolfhugel, wolf@pasteur.fr

SEE ALSO
========

   catopen(3), catclose(3), catgets(3), perl(1).


