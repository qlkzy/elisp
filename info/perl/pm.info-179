This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: HTML/Subtext,  Next: HTML/Summary,  Prev: HTML/Stream,  Up: Module List

Perform text substitutions on an HTML template
**********************************************

NAME
====

   HTML::Subtext - Perform text substitutions on an HTML template

SYNOPSIS
========

     use HTML::Subtext;
     %context = ( ... ); # Hash of names to substitution text
     $p = HTML::Subtext->new('CONTEXT' => \%context);
     $p->parse_file("template.html");

DESCRIPTION
===========

   `HTML::Subtext' is a package for performing text substitutions on a
specially formatted HTML template. The template uses normal HTML markup,
but includes links of the form:

     <a href="subtext:foo/bar">This text will be replaced</a>

   The URI in this link tells `HTML::Subtext' to check in the provided
hash `'CONTEXT'' for a key named `'foo/bar''. If this lookup succeeds in
producing a string value, the text in the body of the link is replaced by
that value.

EXAMPLES
========

   This example performs substitutions into a template embedded into the
Perl code as a *here-document*.

     use HTML::Subtext;
     
     %context = (
       'author/name' => 'Kaelin Colclasure',
       'author/email' => '<a href="mailto:kaelin@acm.org">kaelin@acm.org</a>'
     );
     
     $p = HTML::Subtext->new('CONTEXT' => \%context);
     $p->parse(<<EOT);
     <html><head><title>example</title></head><body>
     <a href=\"subtext:author/name\">Author's name here</a>
     <a href=\"subtext:author/email\">mailto: link here</a>
     </body></html>
     EOT

   When run, the example produces the following output:

     <html><head><title>example</title></head><body>
     Kaelin Colclasure
     <a href="mailto:kaelin@acm.org">kaelin@acm.org</a>
     </body></html>

SEE ALSO
========

   *Note HTML/Filter: HTML/Filter,, *Note HTML/Parser: HTML/Parser,

COPYRIGHT
=========

   Copyright 1999 Kaelin Colclasure.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTML/Summary,  Next: HTML/Table,  Prev: HTML/Subtext,  Up: Module List

module for generating a summary from a web page.
************************************************

NAME
====

   HTML::Summary - module for generating a summary from a web page.

SYNOPSIS
========

     use HTML::Summary;
     use HTML::TreeBuilder;

     my $tree = new HTML::TreeBuilder;
     $tree->parse( $document );

     my $summarizer = new HTML::Summary(
         LENGTH      => 200,
         USE_META    => 1,
     );

     $summary = $summarizer->generate( $tree );
     $summarizer->option( 'USE_META' => 1 );
     $length = $summarizer->option( 'LENGTH' );
     if ( $summarizer->meta_used( ) )
     {
         do something
     }

DESCRIPTION
===========

   The `HTML::Summary' module produces summaries from the textual content
of web pages. It does so using the location heuristic, which determines
the value of a given sentence based on its position and status within the
document; for example, headings, section titles and opening paragraph
sentences may be favoured over other textual content. A LENGTH option can
be used to restrict the length of the summary produced.

CONSTRUCTOR
===========

new( $attr1 => $value1 [, $attr2 => $value2 ] )
-----------------------------------------------

   Possible attributes are:

VERBOSE
     Generate verbose messages to STDERR.

LENGTH
     Maximum length of summary (in bytes). Default is 500.

USE_META
     Flag to tell summarizer whether to use the content of the `<META'> tag
     in the page header, if one is present, instead of generating a
     summary from the body text. *Note that* if the USE_META flag is set,
     this overrides the LENGTH flag - in other words, the summary provided
     by the `<META'> tag is returned in full, even if it is greater than
     LENGTH bytes. Default is 0 (no).

     my $summarizer = new HTML::Summary LENGTH => 200;

METHODS
=======

option( )
---------

   Get / set HTML::Summary configuration options.

     my $length = $summarizer->option( 'LENGTH' );
     $summarizer->option( 'USE_META' => 1 );

generate( $tree )
-----------------

   Takes an HTML::Element object, and generates a summary from it.

     my $tree = new HTML::TreeBuilder;
     $tree->parse( $document );
     my $summary = $summarizer->generate( $tree );

meta_used( )
------------

   Returns 1 if the META tag description was used to generate the summary.

     if ( $summarizer->meta_used() )
     {
         # do something ...
     }

SEE ALSO
========

     HTML::TreeBuilder
     Text::Sentence
     Lingua::JA::Jcode
     Lingua::JA::Jtruncate

AUTHORS
=======

     Ave Wrigley <wrigley@cre.canon.co.uk>
     Tony Rose <tgr@cre.canon.co.uk>
     Neil Bowers <neilb@cre.canon.co.uk>

COPYRIGHT
=========

   Copyright (c) 1997 Canon Research Centre Europe (CRE). All rights
reserved.  This script and any associated documentation or files cannot be
distributed outside of CRE without express prior permission from CRE.


File: pm.info,  Node: HTML/Table,  Next: HTML/TableExtract,  Prev: HTML/Summary,  Up: Module List

produces HTML tables
********************

NAME
====

   HTML::Table - produces HTML tables

SYNOPSIS
========

     use HTML::Table;

     $table1 = new HTML::Table($rows, $cols);
       or
     $table1 = new HTML::Table(-rows=>26,
                               -cols=>2,
                               -border=>1,
                               -bgcolor=>"blue",
                               -width=>"50\%",
                               -spacing=>1,
                               -padding=>1);

     $table1->setCell($cellrow, $cellcol, 'This is Cell 1');
     $table1->setCellBGColor('blue');
     $table1->setCellColSpan(1, 1, 2);
     $table1->setRowHead(1);
     $table1->setColHead(1);

     $table1->print;

     $table2 = new HTML::Table;
     $table2->addRow(@cell_values);
     $table2->addCol(@cell_values2);

     $table1->setCell(1,1, "$table2->getTable");
     $table1->print;

REQUIRES
========

   Perl5.002

EXPORTS
=======

   Nothing

DESCRIPTION
===========

   HTML::Table is used to generate HTML tables for CGI scripts.  By using
the methods provided fairly complex tables can be created, manipulated,
then printed from Perl scripts.  The module also greatly simplifies
creating tables within tables from Perl.  It is possible to create an
entire table using the methods provided and never use an HTML tag.

   HTML::Table also allows for creating dynamically sized tables via its
addRow and addCol methods.  These methods automatically resize the table
if passed more cell values than will fit in the current table grid.

   Methods are provided for nearly all valid table, row, and cell tags
specified for HTML 3.0.

   A Japanese translation of the documentation is available at:

     http://member.nifty.ne.jp/hippo2000/perltips/html/table.htm

METHODS
=======

     [] indicate optional parameters. default value will
        be used if no value is specified

Creation
--------

new HTML::Table([num_rows, num_cols])
     Creates a new HTML table object.  If rows and columns are specified,
     the table will be initialized to that size.  Row and Column numbers
     start at 1,1.  0,0 is considered an empty table.

new HTML::Table([-rows=>num_rows,  		 -cols=>num_cols,  		 -border=>border_width,  		 -bgcolor=>back_colour,  		 -width=>table_width,  		 -spacing=>cell_spacing,  		 -padding=>cell_padding])
     Creates a new HTML table object.  If rows and columns are specified,
     the table will be initialized to that size.  Row and Column numbers
     start at 1,1.  0,0 is considered and empty table.

Table Level Methods
-------------------

setBorder([pixels])
     Sets the table Border Width

setWidth([pixels|percentofscreen])
     Sets the table width Remember to escape percent symbol if used

setCellSpacing([pixels])
setCellPadding([pixels])
setCaption("CaptionText" [, TOP|BOTTOM])
setBGColor([colorname|colortriplet])

autoGrow([1|true|on|anything|0|false|off|no|disable])
     Switches on (default) or off automatic growing of the table if row or
     column values passed to setCell exceed current table size.

Cell Level Methods
------------------

setCell(row_num, col_num, "content")
     Sets the content of a table cell.  This could be any string, even
     another table object via the getTable method.  If the row and/or
     column numbers are outside the existing table boundaries extra rows
     and/or columns are created automatically.

setCellAlign(row_num, col_num, [CENTER|RIGHT|LEFT])
     Sets the horizontal alignment for the cell.

setCellVAlign(row_num, col_num, [CENTER|TOP|BOTTOM])
     Sets the vertical alignment for the cell.

setCellWidth(row_num, col_num, [pixels|percentoftable])
     Sets the width of the cell.

setCellHeight(row_num, col_num, [pixels])
     Sets the height of the cell.

setCellHead(row_num, col_num)
     Sets cell to be of type head (Ie <TH></TH>)

setCellNoWrap(row_num, col_num, [0|1])
     Sets the NoWrap attribute of the cell.

setCellBGColor(row_num, col_num, [colorname|colortriplet])
     Sets the background colour for the cell

setCellRowSpan(row_num, col_num, num_cells)
     Causes the cell to overlap a number of cells below it.  If the
     overlap number is greater than number of cells below the cell, a
     false value will be returned.

setCellColSpan(row_num, col_num, num_cells)
     Causes the cell to overlap a number of cells to the right.  If the
     overlap number is greater than number of cells to the right of the
     cell, a false value will be returned.

setCellSpan(upleft_row_num, up_left_col_num,         lowright_row_num, lowrigt_col_num)
     Joins the block of cells with the corners specified.  If the values
     specified are greater than the number of rows or columns, a false
     value will be returned.

setCellFormat(row_num, col_num, start_string, end_string)
     Start_string should be a string of valid HTML, which is output before
     the cell contents, end_string is valid HTML that is output after the
     cell contents.  This enables formatting to be applied to the cell
     contents.

          $table->setCellFormat(1, 2, '<B>', '</B>');

getCell(row_num, col_num)
     Returns the contents of the specified cell as a string.

Column Level Methods
--------------------

addCol("cell 1 content" [, "cell 2 content",  ...])
     Adds a column to the right end of the table.  Assumes if you pass
     more values than there are rows that you want to increase the number
     of rows.

setColAlign(col_num, [CENTER|RIGHT|LEFT])
     Applies setCellAlign over the entire column.

setColVAlign(col_num, [CENTER|TOP|BOTTOM])
     Applies setCellVAlign over the entire column.

setColWidth(col_num, [pixels|percentoftable])
     Applies setCellWidth over the entire column.

setColHeight(col_num, [pixels])
     Applies setCellHeight over the entire column.

setColHead(col_num)
     Applies setCellHead over the entire column.

setColNoWrap(col_num, [0|1])
     Applies setCellNoWrap over the entire column.

setColBGColor(row_num, [colorname|colortriplet])
     Applies setCellBGColor over the entire column.

setColFormat(col_num, start_string, end_sting)
     Applies setCellFormat over the entire column.

Row Level Methods
-----------------

addRow("cell 1 content" [, "cell 2 content",  ...])
     Adds a row to the bottom of the table.  Assumes if you pass more
     values than there are columns that you want to increase the number of
     columns.

setRowAlign(row_num, [CENTER|RIGHT|LEFT])
     Applies setCellAlign over the entire row.

setRowVAlign(row_num, [CENTER|TOP|BOTTOM])
     Applies setCellVAlign over the entire row.

setRowWidth(row_num, [pixels|percentoftable])
     Applies setCellWidth over the entire row.

setRowHeight(row_num, [pixels])
     Applies setCellHeight over the entire row.

setRowHead(row_num)
     Applies setCellHead over the entire row.

setRowNoWrap(col_num, [0|1])
     Applies setCellNoWrap over the entire row.

setRowBGColor(row_num, [colorname|colortriplet])
     Applies setCellBGColor over the entire row.

setRowFormat(row_num, start_string, end_string)
     Applies setCellFormat over the entire row.

Output Methods
--------------

getTable
     Returns a string containing the HTML representation of the table.

     The same effect can also be achieved by using the object reference in
     a string scalar context.

     For example...

          This code snippet:

          $table = new HTML::Table(2, 2);
          print '<P>Start</P>';
          print $table->getTable;
          print '<P>End</P>';

          would produce the same output as:

          $table = new HTML::Table(2, 2);
          print "<P>Start</P>$table<P>End</P>";

print
     Prints HTML representation of the table to STDOUT

CLASS VARIABLES
===============

HISTORY
=======

   This module was originally created in 1997 by Stacy Lacy and whose last
version was uploaded to CPAN in 1998.  The module was adopted in July 2000
by Anthony Peacock in order to distribute a revised version.  This adoption
took place without the explicit consent of Stacy Lacy as it proved
impossible to contact them at the time.  Although explicit consent was not
obtained at the time, there was some evidence that Stacy Lacy was looking
for somebody to adopt the module in 1998.

AUTHOR
======

   Anthony Peacock, a.peacock@chime.ucl.ac.uk Stacy Lacy (Original author)

CONTRIBUTIONS
=============

   Jay Flaherty, fty@mediapulse.com For ROW, COL & CELL HEAD methods.
Modified the new method to allow hash of values.

   John Stumbles, john@uk.stumbles.org For autogrow behaviour of setCell,
and allowing alignment specifications to be case insensitive

COPYRIGHT
=========

   Copyright (c) 1998-2001 Anthony Peacock, CHIME.  Copyright (c) 1997
Stacy Lacy

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   perl(1), CGI(3)


File: pm.info,  Node: HTML/TableExtract,  Next: HTML/TableLayout,  Prev: HTML/Table,  Up: Module List

Perl extension for extracting the text contained in tables within an HTML document.
***********************************************************************************

NAME
====

   HTML::TableExtract - Perl extension for extracting the text contained
in tables within an HTML document.

SYNOPSIS
========

     # Matched tables are returned as "table state" objects; tables can be
     # matched using column headers, depth, count within a depth, or some
     # combination of the three.

     # Using column header information. Assume an HTML document with
     # tables that have "Date", "Price", and "Cost" somewhere in a
     # row. The columns beneath those headings are what you want to
     # extract. They will be returned in the same order as you specified
     # the headers since 'automap' is enabled by default.

     use HTML::TableExtract;
     $te = new HTML::TableExtract( headers => [qw(Date Price Cost)] );
     $te->parse($html_string);

     # Examine all matching tables
     foreach $ts ($te->table_states) {
       print "Table (", join(',', $ts->coords), "):\n";
       foreach $row ($ts->rows) {
          print join(',', @$row), "\n";
       }
     }

     # Old style, using top level methods rather than table state objects.
     foreach $table ($te->tables) {
       print "Table (", join(',', $te->table_coords($table)), "):\n";
       foreach $row ($te->rows($table)) {
         print join(',', @$row), "\n";
       }
     }

     # Shorthand...top level rows() method assumes the first table found
     # in the document if no arguments are supplied.
     foreach $row ($te->rows) {
        print join(',', @$row), "\n";
     }

     # Using depth and count information. Every table in the document has
     # a unique depth and count tuple, so when both are specified it is a
     # unique table. Depth and count both begin with 0, so in this case we
     # are looking for a table (depth 2) within a table (depth 1) within a
     # table (depth 0, which is the top level HTML document). In addition,
     # it must be the third (count 2) such instance of a table at that
     # depth.

     $te = new HTML::TableExtract( depth => 2, count => 2 );
     $te->parse($html_string);
     foreach $ts ($te->table_states) {
        print "Table found at ", join(',', $ts->coords), ":\n";
        foreach $row ($ts->rows) {
           print "   ", join(',', @$row), "\n";
        }
     }

DESCRIPTION
===========

   HTML::TableExtract is a subclass of HTML::Parser that serves to extract
the textual information from tables of interest contained within an HTML
document. The text from each extracted table is stored in tabe state
objects which hold the information as an array of arrays that represent
the rows and cells of that table.

   There are three constraints available to specify which tables you would
like to extract from a document: Headers, Depth, and Count.

   Headers, the most flexible and adaptive of the techniques, involves
specifying text in an array that you expect to appear above the data in
the tables of interest. Once all headers have been located in a row of
that table, all further cells beneath the columns that matched your
headers are extracted. All other columns are ignored: think of it as
vertical slices through a table. In addition, TableExtract automatically
rearranges each row in the same order as the headers you provided. If you
would like to disable this, set automap to 0 during object creation, and
instead rely on the column_map() method to find out the order in which the
headers were found. Furthermore, TableExtract will automatically
compensate for cell span issues so that columns are really the same
columns as you would visually see in a browser. This behavior can be
disabled by setting the gridmap parameter to 0. HTML is stripped from the
entire textual content of a cell before header matches are attempted.

   Depth and Count are more specific ways to specify tables in relation to
one another. Depth represents how deeply a table resides in other tables.
The depth of a top-level table in the document is 0. A table within a
top-level table has a depth of 1, and so on. Each depth can be thought of
as a layer; tables sharing the same depth are on the same layer. Within
each of these layers, Count represents the order in which a table was seen
at that depth, starting with 0. Providing both a depth and a count will
uniquely specify a table within a document.

   Each of the Headers, Depth, and Count specifications are cumulative in
their effect on the overall extraction. For instance, if you specify only
a Depth, then you get all tables at that depth (note that these could very
well reside in separate higher-level tables throughout the document since
depth extends across tables). If you specify only a Count, then the tables
at that Count from all depths are returned (i.e., the nth occurrence of a
table at each depth). If you only specify Headers, then you get all tables
in the document containing those column headers. If you have specified
multiple constraints of Headers, Depth, and Count, then each constraint
has veto power over whether a particular table is extracted.

   If no Headers, Depth, or Count are specified, then all tables match.

   Text that is gathered from the tables is decoded with HTML::Entities by
default; this can be disabled by setting the decode parameter to 0.

Chains
------

   Make sure you fully understand the notions of depth and count before
proceeding, because it is about to become a bit more involved.

   Table matches using Headers, Depth, or Count can be chained together in
order to further specify tables relative to one another. Links in chains
are successively applied to tables within tables. Top level constraints
(i.e., header, depth, and count parameters for the TableExtract object)
behave as the first link in the chain. Additional links are specified
using the chain parameter. Each link in the chain has its own set of
constraints. For example:

     $te = new HTML::TableExtract
       (
        headers => [qw(Summary Region)],
        chain   => [
                    { depth => 0, count => 2 },
                    { headers => [qw(Part Qty Cost)] }
                   ],
       );

   The matching process in this case will start with all tables in the
document that have "Summary" and "Region" in their headers. For now,
assume that there was only one table that matched these headers. Each
table contained within that table will be compared to the first link in
the chain. Depth 0 means that a matching table must be immediately
contained within the current table; count 2 means that the matching table
must also be the third at that depth (counts and depths start at 0). In
other words, the next link of the chain will match on the third table
immediately contained within our first matched table. Once this link
matches, then all further tables beneath that table that have "Part",
"Qty", and "Cost" in their headers will match. By default, it is only
tables at the end of the chains that are returned to the application, so
these tables are returned.

   Each time a link in a chain matches a table, an additional context for
depth and count is established. It is perhaps easiest to visualize a
context as a brand-new HTML document, with new depths and counts to
compare to the remaining links in the chain. The top level HTML document
is the first context. Each table in the document establishes a new
context. Depth in a chain link is relative to the context that the
matching table creates (i.e., a link depth of 0 would be a table
immediately contained within the table that matched the prior link in the
chain). Likewise, that same context keeps track of *counts* within the new
depth scheme for comparison to the remaining links in the chain. Headers
still apply if they are present in a link, but they are always independent
of context.

   As it turns out, specifying a depth and count provides a unique address
for a table within a context. For non-unique constraints, such as just a
depth, or headers, there can be multiple matches for a given link. In
these cases the chain "forks" and attempts to make further matches within
each of these tables.

   By default, chains are elastic. This means that when a particular link
does not match on a table, it is passed down to subtables unchanged. For
example:

     $te = new HTML::TableExtract
       (
        headers => [qw(Summary Region)],
        chain   => [
                    { headers => [qw(Part Qty Cost)] }
                   ],
       );

   If there are intervening tables between the two header queries, they
will be ignored; this query will extract all tables with "Part", "Qty",
and "Cost" in the headers that are contained in any table with "Summary"
and "Region" in its headers, regardless of how embedded the inner tables
are. If you want a chain to be inelastic, you can set the elastic
parameter to 0 for the whole TableExtract object. Using the same example:

     $te = new HTML::TableExtract
       (
        headers => [qw(Summary Region)],
        chain   => [
                    { headers => [qw(Part Qty Cost)] }
                   ],
        elastic => 0,
       );

   In this case, the inner table (Part, Qty, Cost) must be *immediately*
contained within the outer table (Summary, Region) in order for the match
to take place. This is equivalent to specifying a depth of 0 for each link
in the chain; if you only want particular links to be inelastic, then
simply set their depths to 0.

   By default, only tables that match at the end of the chains are
retained. The intermediate matches along the chain are referred to as
*waypoints*, and are not extracted by default. A waypoint may be retained,
however, by specifiying the keep parameter in that link of the chain. This
parameter may be specified at the top level as well if you want to keep
tables that match the first set of constraints in the object. If you want
to keep all tables that match along the chain, the specify the keepall
parameter at the top level.

   Are chains overkill? Probably. In reality, nested HTML tables tend not
to be very deep, so there will usually not be much need for lots of links
in a chain. Theoretically, however, chains offer precise targeting of
tables relative to one another, no matter how deeply nested they are.

Pop Quiz
--------

   What happens with the following table extraction?

     $te = new HTML::TableExtract(
                                  chain => [ { depth => 0 } ],
                                 );

   Answer: All tables that are contained in another table are extracted
from the document. In this case, there were no top-level constraints
specified, which if you recall means that all tables match the first set
of constraints (or non-constraints, in this case!). A depth of 0 in the
next link of the chain means that the matching table must be immediately
contained within the table from a prior match.

   The following is equivalent:

     $te = new HTML::TableExtract(
                                  depth     => 1,
                                  subtables => 1,
                                 )

   The subtables parameter tells TableExtract to scoop up all tables
contained within the matching tables. In conjunction with a depth of 1,
this has the affect of discarding all top-level tables in the document,
which is exactly what occurred in the prior example.

Advice
------

   The main point of this module was to provide a flexible method of
extracting tabular information from HTML documents without relying to
heavily on the document layout. For that reason, I suggest using Headers
whenever possible - that way, you are anchoring your extraction on what
the document is trying to communicate rather than some feature of the HTML
comprising the document (other than the fact that the data is contained in
a table).

   HTML::TableExtract is a subclass of HTML::Parser, and as such inherits
all of its basic methods. In particular, start(), end(), and text() are
utilized. Feel free to override them, but if you do not eventually invoke
them in the SUPER class with some content, results are not guaranteed.

METHODS
=======

   The following are the top-level methods of the HTML::TableExtract
object. Tables that have matched a query are actually returned as separate
objects of type HTML::TableExtract::TableState. These table state objects
have their own methods, documented further below. There are some top-level
methods that are present for convenience and backwards compatibility that
are nothing more than front-ends for equivalent table state methods.

Constructor
-----------

new()
     Return a new HTML::TableExtract object. Valid attributes are:

    headers
          Passed as an array reference, headers specify strings of
          interest at the top of columns within targeted tables. These
          header strings will eventually be passed through a non-anchored,
          case-insensitive regular expression, so regexp special
          characters are allowed. The table row containing the headers is
          not returned. Columns that are not beneath one of the provided
          headers will be ignored. Columns will, by default, be rearranged
          into the same order as the headers you provide (see the automap
          parameter for more information). Additionally, by default
          columns are considered what you would see visually beneath that
          header when the table is rendered in a browser. See the gridmap
          parameter for more information.

    depth
          Specify how embedded in other tables your tables of interest
          should be. Top-level tables in the HTML document have a depth of
          0, tables within top-level tables have a depth of 1, and so on.

    count
          Specify which table within each depth you are interested in,
          beginning with 0.

    chain
          List of additional constraints to be matched sequentially from
          the top level constraints. This is a reference to an array of
          hash references. Each hash is a link in the chain, and can be
          specified in terms of depth, count, and headers. Further
          modifiers include keep, which means to retain the table if it
          would normally be dropped as a waypoint.

    automap
          Automatically applies the ordering reported by column_map() to
          the rows returned by rows(). This only makes a difference if you
          have specified Headers and they turn out to be in a different
          order in the table than what you specified. Automap will
          rearrange the columns in the same order as the headers appear.
          To get the original ordering, you will need to take another
          slice of each row using column_map(). automap is enabled by
          default.

    gridmap
          Controls whether the table contents are returned as a grid or a
          tree. ROWSPAN and COLSPAN issues are compensated for, and columns
          really are columns. Empty phantom cells are created where they
          would have been obscured by ROWSPAN or COLSPAN settings. This
          really becomes an issue when extracting columns beneath headers.
          Enabled by default.

    keepall
          Keep all tables that matched along a chain, including tables
          matched by top level contraints. By default, waypoints are
          dropped and only the matches at the end of the chain are
          retained. To retain a particular waypoint along a chain, use the
          keep parameter in that link.

    elastic
          When set to 0, all links in chains will be treated as though
          they had a depth of 0 specified, which means there can be no
          intervening unmatched tables between matches on links.

    subtables
          Extract all tables within matched tables.

    decode
          Automatically decode retrieved text with
          HTML::Entities::decode_entities(). Enabled by default.

    br_translate
          Translate <br> tags into newlines. Sometimes the remaining text
          can be hard to parse if the <br> tag is simply dropped. Enabled
          by default.

    debug
          Prints some debugging information to STDOUT, more for higher
          values.

Regular Methods
---------------

depths()
     Returns all depths that contained matched tables in the document.

counts($depth)
     For a particular depth, returns all counts that contained matched
     tables.

table_state($depth, $count)
     For a particular depth and count, return the table state object for
     the table found, if any.

table_states()
     Return table state objects for all tables that matched.

first_table_state_found()
     Return the table state object for the first table matched in the
     document.

TABLE STATE METHODS
-------------------

   The following methods are invoked from an
HTML::TableExtract::TableState object, such as those returned from the
table_states() method.

rows()
     Return all rows within a matched table. Each row returned is a
     reference to an array containing the text of each cell.

depth()
     Return the (absolute) depth at which this table was found.

count()
     Return the count for this table within the depth it was found.

coords()
     Return depth and count in a list.

column_map()
     Return the order (via indices) in which the provided headers were
     found. These indices can be used as slices on rows to either order the
     rows in the same order as headers or restore the rows to their natural
     order, depending on whether the rows have been pre-adjusted using the
     automap parameter.

lineage()
     Returns the path of matched tables that led to matching this table.
     Lineage only makes sense if chains were used. Tables that were not
     matched by a link in the chain are not included in lineage. The
     lineage path is a list of array refs containing depth and count values
     for each table involved.

Procedural Methods
------------------

   The following top level methods are alternatives to invoking methods in
a table state object. If you do not want to deal with table state objects,
then these methods are for you. The "tables" they deal in are actually
just arrays of arrays, which happen to be the current internal data
structure of the table state objects. They are here for backwards
compatibility.

table($depth, $count)
     Same as `table_state()', but returns the internal data structure
     rather than the table state object.

tables()
     Same as table_states(), but returns the data structures rather than
     the table state objects.

first_table_found()
     Same as first_table_state_found(), except returns the data structure
     for first table that matched.

table_coords($table)
     Returns the depth and count for a particular table data structure. See
     the coords() method provided by table state objects.

rows()
rows($table)
     Return a lsit of the rows for a particular table data structure (first
     table found by default). See the rows() method provided by table
     state objects.

column_map()
column_map($table)
     Return the column map for a particular table data structure (first
     found by default). See the column_map() method provided by table
     state objects.

REQUIRES
========

   HTML::Parser(3), HTML::Entities(3)

AUTHOR
======

   Matthew P. Sisk, <`sisk@mojotoad.com'>

COPYRIGHT
=========

   Copyright (c) 2000 Matthew P. Sisk.  All rights reserved. All wrongs
revenged. This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

SEE ALSO
========

   HTML::Parser(3), perl(1).


File: pm.info,  Node: HTML/TableLayout,  Next: HTML/Tagset,  Prev: HTML/TableExtract,  Up: Module List

Layout Manager for cgi-based web applications
*********************************************

NAME
====

   HTML::TableLayout - Layout Manager for cgi-based web applications

DESCRIPTION
===========

   This is a HTML-generating package for making graphical user interfaces
via a web browser using a "Layout Manager" paradigm such as in Tk/Tcl or
Java.  It includes a component heirarchy for making new "widgets".

EXPORT
======

DEFAULT
     `parameters window table cell header text image link list pre'

FORM
     `form choice button hidden input_text password submit radio'

SYNOPSIS
========

     use HTML::TableLayout;
     	$w = window(undef,"Hello World");
     	$w->insert(table()->insert("hello world"));
     	# ...
     	$w->print();

WARNING: DOCUMENTATION INCOMPLETE AND SOMETIMES WRONG.
------------------------------------------------------

   This documentation is incomplete and occassionally wrong.  As always,
the source is the best reference (and, in fact, is relatively well
commented in this case).  This documentation will improve as the API
stabilizes.

   On the other hand, some effort was made to bring it up-to-date with
release 1.1.4.

Weird OO Syntax
---------------

   I thought that "new" was too noisy and took up too much space, so I do
not use it in the API.  When you call, for example,

     window($x,$y,$z),

   you are really doing

     HTML::TableLayout::Window->new($x,$y,$z).

   (but isn't it a whole lot nicer looking?)

User API
========

parameters
     Constructor for default parameters.  This is used for setting up
     application-wide defaults for parameters of various objects.  It takes
     no arguments but has the following methods:

          $p->set($obj, %p);	# destructive
          $p->insert($obj, %p);	# non-destructive
          $p->delete(@tags);

     Where the $obj is any instance of any component.

     The hash %p is a hash of parameters.  In all but a few cases these
     parameters are passed directly through as HTML parameters.  E.g., if I
     write

     $p->set(table(),width=>"100%",border=>undef,foo=>"bar"),

     then all tables will look like

     <TABLE width="100%" border foo="bar">

     (plus other parameters you add later).  Note that it blindly passes
     through what is presumably a meaningless HTML flag-"foo".

     Now, you might find the first argument (an instance of the object)
     passed in a little odd, to say the least.  Once you pass in any
     instance of any object, it "recognizes" that kind of object in the
     future.  This way, it works not only for built-in classes, but also
     any that you choose to derive yourself.  (NOTE: this will change
     w/1.2.x, but it will probably still work this way for backwards
     compatibility)

     One place that this is very useful is a trivial case.  Let's say that
     I want to define a focused table-i.e., a table that I use
     consistently to guide the users attention.  I can make a class like
     such:

          package FocusedTable;
          @ISA=qw(HTML::TableLayout::ComponentTable);

          ## EOF

     and then I can add a setting:

          $p->set(FocusedTable->new(), %focustable_settings);

     Now, whenever you use a FocusedTable, it will use these settings, even
     though in reality it is the same as a table.

     Hmm... you're thinking, but what if I derive a special Checkbox, but I
     want it to get the parameters for a regular checkbox.  I've provided
     for this as well.  In your constructor for this new checkbox (or an
     init() method):

          package myCheckbox;
          @ISA=qw(HTML::TableLayout::FormComponent::Checkbox);

          sub new {
          	my ($class, %params) = @_;
          	my  = {};
          	bless , $class;
          	->tl_inheritParamsFrom(checkbox());
          	return ;
          }

     And the mechanism that sets the parameters will think it is really
     just a Checkbox.

     (It might be nice if instead of having to set this explicitely, the
     mechanism (_obj2tag(), actually) could check based upon inheritance
     and use the settings from the closest parent.  The thing is (a) I
     don't know how to do this efficiently (b) I want to have this
     tl_inheritParamsFrom() anyway so that one can force whichever behavior
     she wants.)

     NOTE: This is one of the things that will probably change/improve for
     version 1.2.x...

window
     Constructor for a window.  The first argument is a parameters object,
     while the third argument is the parameters specific to that window
     instance.

          window($parameters, $title, %params)

`win_header'
     Constructor for a window header.  The first argument is the number of
     the header, as in:

          win_header(2,"some text")

     will produce:

          <H2>some text</H2>

     Similarly,

          win_header(undef,"some text")

     will produce

          some text

     but will place it up at the top of the window.

table
     Constructor for a table.  Other than a few special cases (such as
     scripts and headers) everything is layed out via tables.  Tables can
     be nested inside other tables.  It takes a hash of parameters as an
     argument-these parameters will only be used for this table.  One
     salient example would be "columns".  If you want to have a
     15-columned table, you'd say:

          $t=table(columns=>15);

     This parameter is passed directly out to the HTML, but this layout
     manager also pays attention to it internally.

     Tables have one external method:

          $t->insert($some_component);

     This something can be pretty much anything derived from
     HTML::TableLayout::Component.  It can also be a form-as a general
     rule the table just does the right thing with whatever you stick in
     it.  If it does not, it is a bug (please let me know!)

`cell'
     Constructor for a cell.  You will be using a lot of these-these
     correspond to <TD></TD> in HTML.  (Rows are handled magically by this
     layout manger).  Tables create default cells when you stick something
     in them which is not a cell (or form).  If you want to put more than
     one thing in a cell, or if you want to made a special cell (e.g., with
     some non-default alignment), then you need to create a cell
     explicitely.  You insert "stuff" into cells much like you do into
     tables.  In fact, when you stick something into a table that the table
     does not recognize, it just passes it along to a (new) cell.

`cell_header'
     Constructor for a cell header.  The first argument is the contents
     (usually text), and the next arguments are a hash of parameters. You
     can set the orientation of such with the "Orientation" pseudo-tag.
     E.g., Orientation=>"left" will make the header appear to the left of
     the cell.

text
     Constructor for text.  It looks like:

          $c->insert(text($text,%params));

     The parameters are a bit special-if you put in stuff like bold=>undef
     or size=>"+2", then it will do the following:

          <FONT size=+2><b>whatever</b></FONT>

     Like everything else here, this is supposed to "just work" as you
     expect it to, so I had to do some funky translations of HTML tags
     since HTML is pretty screwed up with this stuff.

image
     Constructor for an image.  Use it like

          $c->insert(image($url,%params));

     Where the url can be relative or absolute (straight HTML story).

link
     Constructor for a link.  Use it like

          $c->insert(link($url,$anchor,%params));

     Note that $anchor might be something interesting, like an image, so:

          $c->insert(link("whatever.html",image("image.gif")));

     should work like a charm.

list
     Constructor for a list.  A list sets up a list environment in HTML.
     Unlike a lot of other components here, it takes two rigid arguments,
     and not just parameters which get passed to HTML and maybe noticed by
     the layout manager.

          $l=list($numbered, $delimited);
          $l->insert("first element");
          $l->insert(text("second element",bold=>undef));
          $l->insert(link($url,"third element"));

pre
     Sets up a preformatted environment in HTML.  Just give it some text;
     it prints it out raw.

`script'
     Sets up an appropriate environment for a script.  Put the script in
     the window if you want it to appear in the preamble; otherwise it will
     appear whereever you call it in the table.



   NOTE there are other classes... see the source for now to find these.

BUGS
====

   See comments in code, particular TODO in TLCore.pm

AUTHOR
======

   Stephen Farrell <stephen@farrell.org>-feel free to write email with any
questions.


File: pm.info,  Node: HTML/Tagset,  Next: HTML/Template,  Prev: HTML/TableLayout,  Up: Module List

data tables useful in parsing HTML
**********************************

NAME
====

   HTML::Tagset - data tables useful in parsing HTML

SYNOPSIS
========

     use HTML::Tagset;
     # Then use any of the items in the HTML::Tagset package
     #  as need arises

DESCRIPTION
===========

   This module contains several data tables useful in various kinds of
HTML parsing operations.

   Note that all tag names used are lowercase.

   In the following documentation, a "hashset" is a hash being used as a
set - the hash conveys that its keys are there, and the actual values
associated with the keys are not significant.  (But what values are there,
are always true.)

hashset %HTML::Tagset::emptyElement
     This hashset has as values the tag-names (GIs) of elements that cannot
     have content.  (For example, "base", "br", "hr".)  So
     `$HTML::Tagset::emptyElement{'hr'}' exists and is true.
     `$HTML::Tagset::emptyElement{'dl'}' does not exist, and so is not
     true.

hashset %HTML::Tagset::optionalEndTag
     This hashset lists tag-names for elements that can have content, but
     whose end-tags are generally, "safely", omissible.  Example:
     `$HTML::Tagset::emptyElement{'li'}' exists and is true.

hash %HTML::Tagset::linkElements
     Values in this hash are tagnames for elements that might contain
     links, and the value for each is a reference to an array of the names
     of attributes whose values can be links.

hash %HTML::Tagset::boolean_attr
     This hash (not hashset) lists what attributes of what elements can be
     printed without showing the value (for example, the "noshade"
     attribute of "hr" elements).  For elements with only one such
     attribute, its value is simply that attribute name.  For elements
     with many such attributes, the value is a reference to a hashset
     containing all such attributes.

hashset %HTML::Tagset::isPhraseMarkup
     This hashset contains all phrasal-level elements.

hashset %HTML::Tagset::is_Possible_Strict_P_Content
     This hashset contains all phrasal-level elements that be content of a
     P element, for a strict model of HTML.

hashset %HTML::Tagset::isHeadElement
     This hashset contains all elements that elements that should be
     present only in the 'head' element of an HTML document.

hashset %HTML::Tagset::isList
     This hashset contains all elements that can contain "li" elements.

hashset %HTML::Tagset::isTableElement
     This hashset contains all elements that are to be found only in/under
     a "table" element.

hashset %HTML::Tagset::isFormElement
     This hashset contains all elements that are to be found only in/under
     a "form" element.

hashset %HTML::Tagset::isBodyMarkup
     This hashset contains all elements that are to be found only in/under
     the "body" element of an HTML document.

hashset %HTML::Tagset::isHeadOrBodyElement
     This hashset includes all elements that I notice can fall either in
     the head or in the body.

hashset %HTML::Tagset::isKnown
     This hashset lists all known HTML elements.

hashset %HTML::Tagset::canTighten
     This hashset lists elements that might have ignorable whitespace as
     children or siblings.

array @HTML::Tagset::p_closure_barriers
     This array has a meaning that I have only seen a need for in
     HTML::TreeBuilder, but I include it here on the off chance that
     someone might find it of use:

     When we see a "<p>" token, we go lookup up the lineage for a p
     element we might have to minimize.  At first sight, we might say that
     if there's a p anywhere in the lineage of this new p, it should be
     closed.  But that's wrong.  Consider this document:

          <html>
            <head>
              <title>foo</title>
            </head>
            <body>
              <p>foo
                <table>
                  <tr>
                    <td>
                       foo
                       <p>bar
                    </td>
                  </tr>
                </table>
              </p>
            </body>
          </html>

     The second p is quite legally inside a much higher p.

     My formalization of the reason why this is legal, but this:

          <p>foo<p>bar</p></p>

     isn't, is that something about the table constitutes a "barrier" to
     the application of the rule about what p must minimize.

     So `@HTML::Tagset::p_closure_barriers' is the list of all such
     barrier-tags.

hashset %isCDATA_Parent
     This hashset includes all elements whose content is CDATA.

CAVEATS
=======

   You may find it useful to alter the behavior of modules (like
`HTML::Element' or HTML::TreeBuilder) that use `HTML::Tagset''s data
tables by altering the data tables themselves.  You are welcome to try,
but be careful; and be aware that different modules may or may react
differently to the data tables being changed.

   Note that it may be inappropriate to use these tables for *producing*
HTML - for example, `%isHeadOrBodyElement' lists the tagnames for all
elements that can appear either in the head or in the body, such as
"script".  That doesn't mean that I am saying your code that produces HTML
should feel free to put script elements in either place!  If you are
producing programs that spit out HTML, you should be *intimately* familiar
with the DTDs for HTML or XHTML (available at `http://www.w3.org/'), and
you should slavishly obey them, not the data tables in this document.

SEE ALSO
========

   *Note HTML/Element: HTML/Element,, *Note HTML/TreeBuilder:
HTML/TreeBuilder,, *Note HTML/LinkExtor: HTML/LinkExtor,

COPYRIGHT
=========

   Copyright 1995-2000 Gisle Aas; copyright 2000 Sean M. Burke.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Current maintainer: Sean M. Burke, <sburke@cpan.org>

   Most of the code/data in this module was adapted from code written by
Gisle Aas <gisle@aas.no> for `HTML::Element', HTML::TreeBuilder, and
HTML::LinkExtor.


File: pm.info,  Node: HTML/Template,  Next: HTML/Testing,  Prev: HTML/Tagset,  Up: Module List

Perl module to use HTML Templates from CGI scripts
**************************************************

NAME
====

   HTML::Template - Perl module to use HTML Templates from CGI scripts

SYNOPSIS
========

   First you make a template - this is just a normal HTML file with a few
extra tags, the simplest being <TMPL_VAR>

   For example, test.tmpl:

     <HTML>
     <HEAD><TITLE>Test Template</TITLE>
     <BODY>
     My Home Directory is <TMPL_VAR NAME=HOME>
     <P>
     My Path is set to <TMPL_VAR NAME=PATH>
     </BODY>
     </HTML>

   Now create a small CGI program:

     use HTML::Template;

     # open the html template
     my $template = HTML::Template->new(filename => 'test.tmpl');

     # fill in some parameters
     $template->param(
         HOME => $ENV{HOME},
         PATH => $ENV{PATH},
     );

     # send the obligatory Content-Type
     print "Content-Type: text/html\n\n";

     # print the template
     print $template->output;

   If all is well in the universe this should show something like this in
your browser when visiting the CGI:

   My Home Directory is /home/some/directory My Path is set to
/bin;/usr/bin

DESCRIPTION
===========

   This module attempts to make using HTML templates simple and natural.
It extends standard HTML with a few new HTML-esque tags - <TMPL_VAR>,
<TMPL_LOOP>, <TMPL_INCLUDE>, <TMPL_IF> and <TMPL_ELSE>.  The file written
with HTML and these new tags is called a template.  It is usually saved
separate from your script - possibly even created by someone else!  Using
this module you fill in the values for the variables, loops and branches
declared in the template.  This allows you to separate design - the HTML -
from the data, which you generate in the Perl script.

   A Japanese translation of the documentation is available at:

     http://member.nifty.ne.jp/hippo2000/perltips/html/template.htm

   This module is licensed under the GPL.  See the LICENSE section below
for more details.

MOTIVATION
==========

   It is true that there are a number of packages out there to do HTML
templates.  On the one hand you have things like HTML::Embperl which
allows you freely mix Perl with HTML.  On the other hand lie home-grown
variable substitution solutions.  Hopefully the module can find a place
between the two.

   One advantage of this module over a full HTML::Embperl-esque solution
is that it enforces an important divide - design and programming.  By
limiting the programmer to just using simple variables and loops in the
HTML, the template remains accessible to designers and other non-perl
people.  The use of HTML-esque syntax goes further to make the format
understandable to others.  In the future this similarity could be used to
extend existing HTML editors/analyzers to support HTML::Template.

   An advantage of this module over home-grown tag-replacement schemes is
the support for loops.  In my work I am often called on to produce tables
of data in html.  Producing them using simplistic HTML templates results
in CGIs containing lots of HTML since the HTML itself cannot represent
loops.  The introduction of loop statements in the HTML simplifies this
situation considerably.  The designer can layout a single row and the
programmer can fill it in as many times as necessary - all they must agree
on is the parameter names.

   For all that, I think the best thing about this module is that it does
just one thing and it does it quickly and carefully.  It doesn't try to
replace Perl and HTML, it just augments them to interact a little better.
And it's pretty fast.

The Tags
========

   Note: even though these tags look like HTML they are a little different
in a couple of ways.  First, they must appear entirely on one line.
Second, they're allowed to "break the rules".  Something like:

     <IMG SRC="<TMPL_VAR NAME=IMAGE_SRC>">

   is not really valid HTML, but it is a perfectly valid use and will work
as planned.

   The "NAME=" in the tag is optional, although for extensibility's sake I
recommend using it.  Example - "<TMPL_LOOP LOOP_NAME>" is acceptable.

   If you're a fanatic about valid HTML and would like your templates to
conform to valid HTML syntax, you may optionally type template tags in the
form of HTML comments. This may be of use to HTML authors who would like
to validate their templates' HTML syntax prior to HTML::Template
processing, or who use DTD-savvy editing tools.

     <!-- TMPL_VAR NAME=PARAM1 -->

   In order to realize a dramatic savings in bandwidth, the standard
(non-comment) tags will be used throughout the rest of this documentation.

<TMPL_VAR NAME="PARAMETER_NAME">
--------------------------------

   The <TMPL_VAR> tag is very simple.  For each <TMPL_VAR> tag in the
template you call $template->param(PARAMETER_NAME => "VALUE").  When the
template is output the <TMPL_VAR> is replaced with the VALUE text you
specified.  If you don't set a parameter it just gets skipped in the
output.

   Optionally you can use the "ESCAPE=HTML" option in the tag to indicate
that you want the value to be HTML-escaped before being returned from
output (the old ESCAPE=1 syntax is still supported).  This means that the
", <, >, and & characters get translated into &quot;, &lt;, &gt; and &amp;
respectively.  This is useful when you want to use a TMPL_VAR in a context
where those characters would cause trouble.  Example:

     <INPUT NAME=param TYPE=TEXT VALUE="<TMPL_VAR NAME="param">">

   If you called param() with a value like sam"my you'll get in trouble
with HTML's idea of a double-quote.  On the other hand, if you use
ESCAPE=HTML, like this:

     <INPUT NAME=param TYPE=TEXT VALUE="<TMPL_VAR ESCAPE=HTML NAME="param">">

   You'll get what you wanted no matter what value happens to be passed in
for param.  You can also write ESCAPE="HTML", ESCAPE='HTML' and ESCAPE='1'.
Substitute a 0 for the HTML and you turn off escaping, which is the default
anyway.

   There is also the "ESCAPE=URL" option which may be used for VARs that
populate a URL.  It will do URL escaping, like replacing ' ' with '+' and
'/' with '%2F'.

<TMPL_LOOP NAME="LOOP_NAME"> </TMPL_LOOP>
-----------------------------------------

   The <TMPL_LOOP> tag is a bit more complicated.  The <TMPL_LOOP> tag
allows you to delimit a section of text and give it a name.  Inside the
<TMPL_LOOP> you place <TMPL_VAR>s.  Now you pass to param() a list (an
array ref) of parameter assignments (hash refs).  The loop iterates over
this list and produces output from the text block for each pass.  Unset
parameters are skipped.  Here's an example:

     In the template:

     <TMPL_LOOP NAME=EMPLOYEE_INFO>
           Name: <TMPL_VAR NAME=NAME> <P>
           Job: <TMPL_VAR NAME=JOB> <P>
          <P>
     </TMPL_LOOP>

     In the script:

     $template->param(EMPLOYEE_INFO => [
                                         { name => 'Sam', job => 'programmer' },
                                         { name => 'Steve', job => 'soda jerk' },
                                       ]
                     );
     print $template->output();

     The output:

     Name: Sam <P>
     Job: programmer <P>
     <P>
     Name: Steve <P>
     Job: soda jerk <P>
     <P>

   As you can see above the <TMPL_LOOP> takes a list of variable
assignments and then iterates over the loop body producing output.

   Often you'll want to generate a <TMPL_LOOP>'s contents
programmatically.  Here's an example of how this can be done (many other
ways are possible!):

     # a couple of arrays of data to put in a loop:
     my @words = qw(I Am Cool);
     my @numbers = qw(1 2 3);

     my @loop_data = ();  # initialize an array to hold your loop

     while (@words and @numbers) {
       my %row_data;  # get a fresh hash for the row data

     # fill in this row
     $row_data{WORD} = shift @words;
     $row_data{NUMBER} = shift @numbers;
     
     # the crucial step - push a reference to this row into the loop!
     push(@loop_data, \%row_data);
        }

     # finally, assign the loop data to the loop param, again with a
     # reference:
     $template->param(THIS_LOOP => \@loop_data);

   The above example would work with a template like:

     <TMPL_LOOP NAME="THIS_LOOP">
        Word: <TMPL_VAR NAME="WORD"><BR>
        Number: <TMPL_VAR NAME="NUMBER"><P>
     </TMPL_LOOP>

   It would produce output like:

     Word: I
     Number: 1

     Word: Am
     Number: 2

     Word: Cool
     Number: 3

   <TMPL_LOOP>s within <TMPL_LOOP>s are fine and work as you would expect.
If the syntax for the param() call has you stumped, here's an example of
a param call with one nested loop:

     $template->param('ROW',[
                             { name => 'Bobby',
                               nicknames => [
                                             { name => 'the big bad wolf' },
                                             { name => 'He-Man' },
                                            ],
                             },
                            ],
                     );

   Basically, each <TMPL_LOOP> gets an array reference.  Inside the array
are any number of hash references.  These hashes contain the name=>value
pairs for a single pass over the loop template.

   Inside a <TMPL_LOOP>, the only variables that are usable are the ones
from the <TMPL_LOOP>.  The variables in the outer blocks are not visible
within a template loop.  For the computer-science geeks among you, a
<TMPL_LOOP> introduces a new scope much like a perl subroutine call.  If
you want your variables to be global you can use 'global_vars' option to
new described below.

<TMPL_INCLUDE NAME="filename.tmpl">
-----------------------------------

   This tag includes a template directly into the current template at the
point where the tag is found.  The included template contents are used
exactly as if its contents were physically included in the master template.

   The file specified can be a full path - beginning with a '/'.  If it
isn't a full path, the path to the enclosing file is tried first.  After
that the path in the environment variable HTML_TEMPLATE_ROOT is tried
next, if it exists.  Next, the "path" new() option is consulted.  As a
final attempt, the filename is passed to open() directly.  See below for
more information on HTML_TEMPLATE_ROOT and the "path" option to new().

   As a protection against infinitly recursive includes, an arbitary limit
of 10 levels deep is imposed.  You can alter this limit with the
"max_includes" option.  See the entry for the "max_includes" option below
for more details.

<TMPL_IF NAME="CONTROL_PARAMETER_NAME"> </TMPL_IF>
--------------------------------------------------

   The <TMPL_IF> tag allows you to include or not include a block of the
template based on the value of a given parameter name.  If the parameter
is given a value that is true for Perl - like '1' - then the block is
included in the output.  If it is not defined, or given a false value -
like '0' - then it is skipped.  The parameters are specified the same way
as with TMPL_VAR.

   Example Template:

     <TMPL_IF NAME="BOOL">
       Some text that only gets displayed if BOOL is true!
     </TMPL_IF>

   Now if you call $template->param(BOOL => 1) then the above block will
be included by output.

   <TMPL_IF> </TMPL_IF> blocks can include any valid HTML::Template
construct - VARs and LOOPs and other IF/ELSE blocks.  Note, however, that
intersecting a <TMPL_IF> and a <TMPL_LOOP> is invalid.

     Not going to work:
     <TMPL_IF BOOL>
        <TMPL_LOOP SOME_LOOP>
     </TMPL_IF>
        </TMPL_LOOP>

   If the name of a TMPL_LOOP is used in a TMPL_IF, the IF block will
output if the loop has at least one row.  Example:

     <TMPL_IF LOOP_ONE>
       This will output if the loop is not empty.
     </TMPL_IF>

     <TMPL_LOOP LOOP_ONE>
       ....
     </TMPL_LOOP>

   WARNING: Much of the benefit of HTML::Template is in decoupling your
Perl and HTML.  If you introduce numerous cases where you have TMPL_IFs
and matching Perl if()s, you will create a maintenance problem in keeping
the two synchronized.  I suggest you adopt the practice of only using
TMPL_IF if you can do so without requiring a matching if() in your Perl
code.

<TMPL_ELSE>
-----------

   You can include an alternate block in your TMPL_IF block by using
TMPL_ELSE.  NOTE: You still end the block with </TMPL_IF>, not
</TMPL_ELSE>!

   Example:

     <TMPL_IF BOOL>
       Some text that is included only if BOOL is true
     <TMPL_ELSE>
       Some text that is included only if BOOL is false
     </TMPL_IF>

<TMPL_UNLESS NAME="CONTROL_PARAMETER_NAME"> </TMPL_UNLESS>
----------------------------------------------------------

   This tag is the opposite of <TMPL_IF>.  The block is output if the
CONTROL_PARAMETER is set false or not defined.  You can use <TMPL_ELSE>
with <TMPL_UNLESS> just as you can with <TMPL_IF>.

     Example:

     <TMPL_UNLESS BOOL>
       Some text that is output only if BOOL is FALSE.
     <TMPL_ELSE>
       Some text that is output only if BOOL is TRUE.
     </TMPL_UNLESS>

   If the name of a TMPL_LOOP is used in a TMPL_UNLESS, the UNLESS block
output if the loop has zero rows.

     <TMPL_UNLESS LOOP_ONE>
       This will output if the loop is empty.
     </TMPL_UNLESS>
     
     <TMPL_LOOP LOOP_ONE>
       ....
     </TMPL_LOOP>

Methods
=======

new()
-----

   Call new() to create a new Template object:

     my $template = HTML::Template->new( filename => 'file.tmpl',
                                         option => 'value'
                                       );

   You must call new() with at least one name => value pair specifying how
to access the template text.  You can use "filename => 'file.tmpl'" to
specify a filename to be opened as the template.  Alternately you can use:

     my $t = HTML::Template->new( scalarref => $ref_to_template_text,
                                  option => 'value'
                                );

   and

     my $t = HTML::Template->new( arrayref => $ref_to_array_of_lines ,
                                  option => 'value'
                                );

   These initialize the template from in-memory resources.  In almost
every case you'll want to use the filename parameter.  If you're worried
about all the disk access from reading a template file just use mod_perl
and the cache option detailed below.

   The three new() calling methods can also be accessed as below, if you
prefer.

     my $t = HTML::Template->new_file('file.tmpl', option => 'value');

     my $t = HTML::Template->new_scalar_ref($ref_to_template_text,
                                           option => 'value');

     my $t = HTML::Template->new_array_ref($ref_to_array_of_lines,
                                          option => 'value');

   And as a final option, for those that might prefer it, you can call new
as:

     my $t = HTML::Template->new(type => 'filename',
                                 source => 'file.tmpl');

   Which works for all three of the source types.

   If the environment variable HTML_TEMPLATE_ROOT is set and your filename
doesn't begin with /, then the path will be relative to the value of
$HTML_TEMPLATE_ROOT.  Example - if the environment variable
HTML_TEMPLATE_ROOT is set to "/home/sam" and I call HTML::Template->new()
with filename set to "sam.tmpl", the HTML::Template will try to open
"/home/sam/sam.tmpl" to access the template file.  You can also affect the
search path for files with the "path" option to new() - see below for more
information.

   You can modify the Template object's behavior with new.  These options
are available:

   * die_on_bad_params - if set to 0 the module will let you call
     $template->param(param_name => 'value') even if 'param_name' doesn't
     exist in the template body.  Defaults to 1.

   * strict - if set to 0 the module will allow things that look like they
     might be TMPL_* tags to get by without dieing.  Example:

          <TMPL_HUH NAME=ZUH>

     Would normally cause an error, but if you call new with strict => 0,
     HTML::Template will ignore it.  Defaults to 1.

   * cache - if set to 1 the module will cache in memory the parsed
     templates based on the filename parameter and modification date of the
     file.  This only applies to templates opened with the filename
     parameter specified, not scalarref or arrayref templates.  Caching
     also looks at the modification times of any files included using
     <TMPL_INCLUDE> tags, but again, only if the template is opened with
     filename parameter.

     This is mainly of use in a persistent environment like
     Apache/mod_perl.  It has absolutely no benefit in a normal CGI
     environment since the script is unloaded from memory after every
     request.  For a cache that does work for normal CGIs see the
     'shared_cache' option below.

     Note that different new() parameter settings do not cause a cache
     refresh, only a change in the modification time of the template will
     trigger a cache refresh.  For most usages this is fine.  My simplistic
     testing shows that using cache yields a 90% performance increase under
     mod_perl.  Cache defaults to 0.

   * shared_cache - if set to 1 the module will store its cache in shared
     memory using the IPC::SharedCache module (available from CPAN).  The
     effect of this will be to maintain a single shared copy of each parsed
     template for all instances of HTML::Template to use.  This can be a
     significant reduction in memory usage in a multiple server
     environment.  As an example, on one of our systems we use 4MB of
     template cache and maintain 25 httpd processes - shared_cache results
     in saving almost 100MB!  Of course, some reduction in speed versus
     normal caching is to be expected.  Another difference between normal
     caching and shared_cache is that shared_cache will work in a CGI
     environment - normal caching is only useful in a persistent
     environment like Apache/mod_perl.

     By default HTML::Template uses the IPC key 'TMPL' as a shared root
     segment (0x4c504d54 in hex), but this can be changed by setting the
     'ipc_key' new() parameter to another 4-character or integer key.
     Other options can be used to affect the shared memory cache correspond
     to IPC::SharedCache options - ipc_mode, ipc_segment_size and
     ipc_max_size.  See *Note IPC/SharedCache: IPC/SharedCache, for a
     description of how these work - in most cases you shouldn't need to
     change them from the defaults.

     For more information about the shared memory cache system used by
     HTML::Template see *Note IPC/SharedCache: IPC/SharedCache,.

   * double_cache - if set to 1 the module will use a combination of
     shared_cache and normal cache mode for the best possible caching.  Of
     course, it also uses the most memory of all the cache modes.  All the
     same ipc_* options that work with shared_cache apply to double_cache
     as well.  By default double_cache is off.

   * blind_cache - if set to 1 the module behaves exactly as with normal
     caching but does not check to see if the file has changed on each
     request.  This option should be used with caution, but could be of use
     on high-load servers.  My tests show blind_cache performing only 1 to
     2 percent faster than cache under mod_perl.

     NOTE: Combining this option with shared_cache can result in stale
     templates stuck permanently in shared memory!

   * file_cache - if set to 1 the module will store its cache in a file
     using the Storable module.  It uses no additional memory, and my
     simplistic testing shows that it yields a 50% performance advantage.
     Like shared_cache, it will work in a CGI environment. Default is 0.

     If you set this option you must set the "file_cache_dir" option.  See
     below for details.

     NOTE: Storable using flock() to ensure safe access to cache files.
     Using file_cache on a system or filesystem (NFS) without flock()
     support is dangerous.

   * file_cache_dir - sets the directory where the module will store the
     cache files if file_cache is enabled.  Your script will need write
     permissions to this directory.  You'll also need to make sure the
     sufficient space is available to store the cache files.

   * file_cache_dir_mode - sets the file mode for newly created file_cache
     directories and subdirectories.  Defaults to 0700 for security but
     this may be inconvenient if you do not have access to the account
     running the webserver.

   * double_file_cache - if set to 1 the module will use a combination of
     file_cache and normal cache mode for the best possible caching.  The
     file_cache_* options that work with file_cache apply to
     double_file_cache as well.  By default double_file_cache is 0.

   * associate - this option allows you to inherit the parameter values
     from other objects.  The only requirement for the other object is that
     it have a param() method that works like HTML::Template's param().  A
     good candidate would be a CGI.pm query object.  Example:

          my $query = new CGI;
          my $template = HTML::Template->new(filename => 'template.tmpl',
                                             associate => $query);

     Now, $template->output() will act as though

          $template->param('FormField', $cgi->param('FormField'));

     had been specified for each key/value pair that would be provided by
     the $cgi->param() method.  Parameters you set directly take precedence
     over associated parameters.

     You can specify multiple objects to associate by passing an anonymous
     array to the associate option.  They are searched for parameters in
     the order they appear:

          my $template = HTML::Template->new(filename => 'template.tmpl',
                                             associate => [$query, $other_obj]);

     The old associateCGI() call is still supported, but should be
     considered obsolete.

     NOTE: The parameter names are matched in a case-insensitve manner.  If
     you have two parameters in a CGI object like 'NAME' and 'Name' one
     will be chosen randomly by associate.  This behavior can be changed by
     the following option.

   * case_sensitive - setting this option to true causes HTML::Template to
     treat template variable names case-sensitively.  The following example
     would only set one parameter without the "case_sensitive" option:

          my $template = HTML::Template->new(filename => 'template.tmpl',
                                             case_sensitive => 1);
          $template->param(
            FieldA => 'foo',
            fIELDa => 'bar',
          );

     This option defaults to off.

   * loop_context_vars - when this parameter is set to true (it is false by
     default) four loop context variables are made available inside a loop:
     __FIRST__, __LAST__, __INNER__, __ODD__.  They can be used with
     <TMPL_IF>, <TMPL_UNLESS> and <TMPL_ELSE> to control how a loop is
     output.  Example:

          <TMPL_LOOP NAME="FOO">
             <TMPL_IF NAME="__FIRST__">
               This only outputs on the first pass.
             </TMPL_IF>

          <TMPL_IF NAME="__ODD__">
            This outputs every other pass, on the odd passes.
          </TMPL_IF>

          <TMPL_UNLESS NAME="__ODD__">
            This outputs every other pass, on the even passes.
          </TMPL_IF>

          <TMPL_IF NAME="__INNER__">
            This outputs on passes that are neither first nor last.
          </TMPL_IF>

          <TMPL_IF NAME="__LAST__">
            This only outputs on the last pass.
          <TMPL_IF>
             </TMPL_LOOP>

     One use of this feature is to provide a "separator" similar in effect
     to the perl function join().  Example:

          <TMPL_LOOP FRUIT>
             <TMPL_IF __LAST__> and </TMPL_IF>
             <TMPL_VAR KIND><TMPL_UNLESS __LAST__>, <TMPL_ELSE>.</TMPL_UNLESS>
          </TMPL_LOOP>

     Would output (in a browser) something like:

          Apples, Oranges, Brains, Toes, and Kiwi.

     Given an appropriate param() call, of course.  NOTE: A loop with only
     a single pass will get both __FIRST__ and __LAST__ set to true, but
     not __INNER__.

   * path - you can set this variable with a list of paths to search for
     files specified with the "filename" option to new() and for files
     included with the <TMPL_INCLUDE> tag.  This list is only consulted
     when the filename is relative.  The HTML_TEMPLATE_ROOT environment
     variable is always tried first if it exists.  In the case of a
     <TMPL_INCLUDE> file, the path to the including file is also tried
     before path is consulted.

     Example:

          my $template = HTML::Template->new( filename => 'file.tmpl',
                                              path => [ '/path/to/templates',
                                                        '/alternate/path'
                                                      ]
                                             );

     NOTE: the paths in the path list must be expressed as UNIX paths,
     separated by the forward-slash character ('/').

   * no_includes - set this option to 1 to disallow the <TMPL_INCLUDE> tag
     in the template file.  This can be used to make opening untrusted
     templates *slightly* less dangerous.  Defaults to 0.

   * max_includes - set this variable to determine the maximum depth that
     includes can reach.  Set to 10 by default.  Including files to a depth
     greater than this value causes an error message to be displayed.  Set
     to 0 to disable this protection.

   * search_path_on_include - if set to a true value the module will search
     from the top of the array of paths specified by the path option on
     every <TMPL_INCLUDE> and use the first matching template found.  The
     normal behavior is to look only in the current directory for a
     template to include.  Defaults to 0.

   * global_vars - normally variables declared outside a loop are not
     available inside a loop.  This option makes <TMPL_VAR>s like global
     variables in Perl - they have unlimited scope.  This option also
     affects <TMPL_IF> and <TMPL_UNLESS>.

     Example:

          This is a normal variable: <TMPL_VAR NORMAL>.<P>

          <TMPL_LOOP NAME=FROOT_LOOP>
             Here it is inside the loop: <TMPL_VAR NORMAL><P>
          </TMPL_LOOP>

     Normally this wouldn't work as expected, since <TMPL_VAR NORMAL>'s
     value outside the loop is not available inside the loop.

   * filter - this option allows you to specify a filter for your template
     files.  A filter is a subroutine that will be called after
     HTML::Template reads your template file but before it starts parsing
     template tags.

     In the most simple usage, you simply assign a code reference to the
     filter parameter.  This subroutine will recieve a single arguement - a
     reference to a string containing the template file text.  Here is an
     example that accepts templates with tags that look like "!!!ZAP_VAR
     FOO!!!" and transforms them into HTML::Template tags:

          my $filter = sub {
            my $text_ref = shift;
            $$text_ref =~ s/!!!ZAP_(.*?)!!!/<TMPL_$1>/g;
          }

          # open zap.tmpl using the above filter
          my $template = HTML::Template->new(filename => 'zap.tmpl',
                                             filter => $filter);

     More complicated usages are possible.  You can request that your
     filter receieve the template text as an array of lines rather than as
     a single scalar.  To do that you need to specify your filter using a
     hash-ref.  In this form you specify the filter using the "sub" key and
     the desired argument format using the "format" key.  The available
     formats are "scalar" and "array".

          my $template = HTML::Template->new(filename => 'zap.tmpl',
                                             filter => { sub => $filter,
                                                         format => 'array' });

     Using the 'array' format is likely to be more efficient since this is
     how HTML::Template stores the template text internally.  This may
     change in the future.

     You may also have multiple filters.  This allows simple filters to be
     combined for more elaborate functionality.  To do this you specify an
     array of filters.  The filters are applied in the order they are
     specified.

          my $template = HTML::Template->new(filename => 'zap.tmpl',
                                             filter => [
                                                  { sub => \&decompress,
                                                    format => 'scalar' },
                                                  { sub => \&remove_spaces,
                                                    format => 'array' }
                                               ]);

     The specified filters will be called for any TMPL_INCLUDEed files just
     as they are for the main template file.

   * vanguard_compatibility_mode - if set to 1 the module will expect to
     see <TMPL_VAR>s that look like %NAME% in addition to the standard
     syntax.  Also sets die_on_bad_params => 0.  If you're not at Vanguard
     Media trying to use an old format template don't worry about this one.
     Defaults to 0.

   * debug - if set to 1 the module will write random debugging information
     to STDERR.  Defaults to 0.

   * stack_debug - if set to 1 the module will use Data::Dumper to print
     out the contents of the parse_stack to STDERR.  Defaults to 0.

   * cache_debug - if set to 1 the module will send information on cache
     loads, hits and misses to STDERR.  Defaults to 0.

   * shared_cache_debug - if set to 1 the module will turn on the debug
     option in IPC::SharedCache - see *Note IPC/SharedCache:
     IPC/SharedCache, for details. Defaults to 0.

   * memory_debug - if set to 1 the module will send information on cache
     memory usage to STDERR.  Requires the GTop module.  Defaults to 0.

param
-----

   param() can be called in a number of ways

   1) To return a list of parameters in the template :

     my @parameter_names = $self->param();

   2) To return the value set to a param :

     my $value = $self->param('PARAM');

   3) To set the value of a parameter :

     # For simple TMPL_VARs:
     $self->param(PARAM => 'value');

     # with a subroutine reference that gets called to get the value of
     # the scalar.
     $self->param(PARAM => sub { return 'value' });

     # And TMPL_LOOPs:
     $self->param(LOOP_PARAM =>
                  [
                   { PARAM => VALUE_FOR_FIRST_PASS, ... },
                   { PARAM => VALUE_FOR_SECOND_PASS, ... }
                   ...
                  ]
                 );

   4) To set the value of a a number of parameters :

     # For simple TMPL_VARs:
     $self->param(PARAM => 'value',
                  PARAM2 => 'value'
                 );

     # And with some TMPL_LOOPs:
     $self->param(PARAM => 'value',
                  PARAM2 => 'value',
                  LOOP_PARAM =>
                  [
                   { PARAM => VALUE_FOR_FIRST_PASS, ... },
                   { PARAM => VALUE_FOR_SECOND_PASS, ... }
                   ...
                  ],
                  ANOTHER_LOOP_PARAM =>
                  [
                   { PARAM => VALUE_FOR_FIRST_PASS, ... },
                   { PARAM => VALUE_FOR_SECOND_PASS, ... }
                   ...
                  ]
                 );

   5) To set the value of a a number of parameters using a hash-ref :

     $self->param(
                  {
                     PARAM => 'value',
                     PARAM2 => 'value',
                     LOOP_PARAM =>
                     [
                       { PARAM => VALUE_FOR_FIRST_PASS, ... },
                       { PARAM => VALUE_FOR_SECOND_PASS, ... }
                       ...
                     ],
                     ANOTHER_LOOP_PARAM =>
                     [
                       { PARAM => VALUE_FOR_FIRST_PASS, ... },
                       { PARAM => VALUE_FOR_SECOND_PASS, ... }
                       ...
                     ]
                   }
                  );

clear_params()
--------------

   Sets all the parameters to undef.  Useful internally, if nowhere else!

output()
--------

   output() returns the final result of the template.  In most situations
you'll want to print this, like:

     print $template->output();

   When output is called each occurrence of <TMPL_VAR NAME=name> is
replaced with the value assigned to "name" via param().  If a named
parameter is unset it is simply replaced with ".  <TMPL_LOOPS> are
evaluated once per parameter set, accumlating output on each pass.

   Calling output() is guaranteed not to change the state of the Template
object, in case you were wondering.  This property is mostly important for
the internal implementation of loops.

   You may optionally supply a filehandle to print to automatically as the
template is generated.  This may improve performance and lower memory
consumption.  Example:

     $template->output(print_to => *STDOUT);

   The return value is undefined when using the "print_to" option.

query()
-------

   This method allow you to get information about the template structure.
It can be called in a number of ways.  The simplest usage of query is
simply to check whether a parameter name exists in the template, using the
name option:

     if ($template->query(name => 'foo')) {
       # do something if a varaible of any type
       # named FOO is in the template
     }

   This same usage returns the type of the parameter.  The type is the
same as the tag minus the leading 'TMPL_'.  So, for example, a TMPL_VAR
parameter returns 'VAR' from query().

     if ($template->query(name => 'foo') eq 'VAR') {
       # do something if FOO exists and is a TMPL_VAR
     }

   Note that the variables associated with TMPL_IFs and TMPL_UNLESSs will
be identified as 'VAR' unless they are also used in a TMPL_LOOP, in which
case they will return 'LOOP'.

   query() also allows you to get a list of parameters inside a loop (and
inside loops inside loops).  Example loop:

     <TMPL_LOOP NAME="EXAMPLE_LOOP">
       <TMPL_VAR NAME="BEE">
       <TMPL_VAR NAME="BOP">
       <TMPL_LOOP NAME="EXAMPLE_INNER_LOOP">
         <TMPL_VAR NAME="INNER_BEE">
         <TMPL_VAR NAME="INNER_BOP">
       </TMPL_LOOP>
     </TMPL_LOOP>

   And some query calls:

   # returns 'LOOP'   $type = $template->query(name => 'EXAMPLE_LOOP');

   # returns ('bop', 'bee', 'example_inner_loop')   @param_names =
$template->query(loop => 'EXAMPLE_LOOP');

     # both return 'VAR'
     $type = $template->query(name => ['EXAMPLE_LOOP', 'BEE']);
     $type = $template->query(name => ['EXAMPLE_LOOP', 'BOP']);

     # and this one returns 'LOOP'
     $type = $template->query(name => ['EXAMPLE_LOOP',
                                       'EXAMPLE_INNER_LOOP']);
     
     # and finally, this returns ('inner_bee', 'inner_bop')
     @inner_param_names = $template->query(loop => ['EXAMPLE_LOOP',
                                                    'EXAMPLE_INNER_LOOP']);

     # for non existent parameter names you get undef
     # this returns undef.
     $type = $template->query(name => 'DWEAZLE_ZAPPA');

     # calling loop on a non-loop parameter name will cause an error.
     # this dies:
     $type = $template->query(loop => 'DWEAZLE_ZAPPA');

   As you can see above the loop option returns a list of parameter names
and both name and loop take array refs in order to refer to parameters
inside loops.  It is an error to use loop with a parameter that is not a
loop.

   Note that all the names are returned in lowercase and the types are
uppercase.

   Just like param(), query() with no arguements returns all the parameter
names in the template at the top level.

FREQUENTLY ASKED QUESTIONS
==========================

   In the interest of greater understanding I've started a FAQ section of
the perldocs.  Please look in here before you send me email.

   1) Is there a place to go to discuss HTML::Template and/or get help?

   There's a mailing-list for HTML::Template at htmltmpl@lists.vm.com.
Send a blank message to htmltmpl-subscribe@lists.vm.com to join!

   2) I want support for <TMPL_XXX>!  How about it?

   Maybe.  I definitely encourage people to discuss their ideas for
HTML::Template on the mailing list.  Please be ready to explain to me how
the new tag fits in with HTML::Template's mission to provide a fast,
lightweight system for using HTML templates.

   NOTE: Offering to program said addition and provide it in the form of a
patch to the most recent version of HTML::Template will definitely have a
softening effect on potential opponents!

   3) I found a bug, can you fix it?

   That depends.  Did you send me the VERSION of HTML::Template, a test
script and a test template?  If so, then almost certainly.

   If you're feeling really adventurous, HTML::Template has a publically
available CVS server.  See below for more information in the PUBLIC CVS
SERVER section.

   4) <TMPL_VAR>s from the main template aren't working inside a
<TMPL_LOOP>!  Why?

   This is the intended behavior.  <TMPL_LOOP> introduces a separate scope
for <TMPL_VAR>s much like a subroutine call in Perl introduces a separate
scope for "my" variables.

   If you want your <TMPL_VAR>s to be global you can set the 'global_vars'
option when you call new().  See above for documentation of the
'global_vars' new() option.

   5) Why do you use /[Tt]/ instead of /t/i?  It's so ugly!

   Simple - the case-insensitive match switch is very inefficient.
According to _Mastering_Regular_Expressions_ from O'Reilly Press, /[Tt]/
is faster and more space efficient than /t/i - by as much as double
against long strings.  //i essentially does a lc() on the string and keeps
a temporary copy in memory.

   When this changes, and it is in the 5.6 development series, I will
gladly use //i.  Believe me, I realize [Tt] is hideously ugly.

   6) How can I pre-load my templates using cache-mode and mod_perl?

   Add something like this to your startup.pl:

     use HTML::Template;
     use File::Find;

     print STDERR "Pre-loading HTML Templates...\n";
     find(
          sub {
            return unless /\.tmpl$/;
            HTML::Template->new(
                                filename => "$File::Find::dir/$_",
                                cache => 1,
                               );
          },
          '/path/to/templates',
          '/another/path/to/templates/'
        );

   Note that you'll need to modify the "return unless" line to specify the
extension you use for your template files - I use .tmpl, as you can see.
You'll also need to specify the path to your template files.

   One potential problem: the "/path/to/templates/" must be EXACTLY the
same path you use when you call HTML::Template->new().  Otherwise the
cache won't know they're the same file and will load a new copy - instead
getting a speed increase, you'll double your memory usage.  To find out if
this is happening set cache_debug => 1 in your application code and look
for "CACHE MISS" messages in the logs.

   7) What characters are allowed in TMPL_* NAMEs?

   Numbers, letters, '.', '/', '+', '-' and '_'.

   8) How can I execute a program from inside my template?

   Short answer: you can't.  Longer answer: you shouldn't since this
violates the fundamental concept behind HTML::Template - that design and
code should be seperate.

   But, inevitably some people still want to do it.  At times it has even
seemed that HTML::Template development might split over this issue, so I
will attempt a compromise.  Here is a method you can use to allow your
template authors to evaluate arbitrary perl scripts from within the
template.

   First, tell all your designers that when they want to run a perl script
named "program.pl" they should use a tag like:

     <TMPL_VAR NAME="__execute_program.pl__">

   Then, have all your programmers call this subroutine instead of calling
HTML::Template::new directly.  They still use the same parameters, but
they also get the program execution.

     sub new_template {
       # get the template object
       my $template = HTML::Template->new(@_);
     
       # find program parameters and fill them in
       my @params = $template->param();
       for my $param (@params) {
          if ($param =~ /^__execute_(.*)__$/) {
            $template->param($param, do($1));
          }
       }

     # return the template object
     return $template;
       }

   The programs called in this way should return a string containing their
output.  A more complicated subroutine could be written to capture STDOUT
from the scripts, but this one is simple enough to include in the FAQ.
Another improvement would be to use query() to enable program execution
inside loops.

   9) Can I get a copy of these docs in Japanese?

   Yes you can.  See Kawai Takanori's translation at:

     http://member.nifty.ne.jp/hippo2000/perltips/html/template.htm

BUGS
====

   I am aware of no bugs - if you find one, join the mailing list and tell
us about it (htmltmpl@lists.vm.com).  You can join the HTML::Template
mailing-list by sending a blank email to htmltmpl-subscribe@lists.vm.com.
Of course, you can still email me directly (sam@tregar.com) with bugs, but
I reserve the right to forward bug reports to the mailing list.

   When submitting bug reports, be sure to include full details, including
the VERSION of the module, a test script and a test template demonstrating
the problem!

   If you're feeling really adventurous, HTML::Template has a publically
available CVS server.  See below for more information in the PUBLIC CVS
SERVER section.

CREDITS
=======

   This module was the brain child of my boss, Jesse Erlbaum
(jesse@vm.com) here at Vanguard Media.  The most original idea in this
module - the <TMPL_LOOP> - was entirely his.

   Fixes, Bug Reports, Optimizations and Ideas have been generously
provided by:

     Richard Chen
     Mike Blazer
     Adriano Nagelschmidt Rodrigues
     Andrej Mikus
     Ilya Obshadko
     Kevin Puetz
     Steve Reppucci
     Richard Dice
     Tom Hukins
     Eric Zylberstejn
     David Glasser
     Peter Marelas
     James William Carlson
     Frank D. Cringle
     Winfried Koenig
     Matthew Wickline
     Doug Steinwand
     Drew Taylor
     Tobias Brox
     Michael Lloyd
     Simran Gambhir
     Chris Houser <chouser@bluweb.com>
     Larry Moore
     Todd Larason
     Jody Biggs
     T.J. Mather
     Martin Schroth
     Dave Wolfe
     uchum
     Kawai Takanori
     Peter Guelich
     Chris Nokleberg
     Ralph Corderoy
     William Ward
     Ade Olonoh
     Mark Stosberg

   Thanks!

PUBLIC CVS SERVER
=================

   HTML::Template now has a publicly accessible CVS server provided by
SourceForge (www.sourceforge.net).  You can access it by going to
http://sourceforge.net/cvs/?group_id=1075.  Give it a try!

AUTHOR
======

   Sam Tregar, sam@tregar.com (you can also find me on the mailing list at
htmltmpl@lists.vm.com - join it by sending a blank message to
htmltmpl-subscribe@lists.vm.com).

LICENSE
=======

   HTML::Template : A module for using HTML Templates with Perl Copyright
(C) 2000 Sam Tregar (sam@tregar.com)

   This module is free software; you can redistribute it and/or modify it
under the terms of either:

   a) the GNU General Public License as published by the Free Software
Foundation; either version 1, or (at your option) any later version, or

   b) the "Artistic License" which comes with this module.

   This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See either the GNU General Public
License or the Artistic License for more details.

   You should have received a copy of the Artistic License with this
module, in the file ARTISTIC.  If not, I'll be glad to provide one.

   You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc., 59
Temple Place, Suite 330, Boston, MA 02111-1307 USA


