This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Template/Service,  Next: Template/Stash,  Prev: Template/Provider,  Up: Module List

custom template processing service
**********************************

NAME
====

   Template::Service - custom template processing service

SYNOPSIS
========

     use Template::Service;

     my $service = Template::Service->new({
     	PRE_PROCESS  => [ 'config', 'header' ],
     	POST_PROCESS => 'footer',
     	ERROR        => {
     	    user     => 'user/index.html',
     	    dbi      => 'error/database',
     	    default  => 'error/default',
     	},
     });

     my $output = $service->process($template_name, \%replace)
     	|| die $service->error(), "\n";

DESCRIPTION
===========

   The Template::Service module implements an object class for providing a
consistent template processing service.

   Standard header (PRE_PROCESS) and footer (POST_PROCESS) templates may
be specified which are prepended and appended to all templates processed
by the service (but not any other templates or blocks INCLUDEd or
PROCESSed from within).  An ERROR hash may be specified which redirects
the service to an alternate template file in the case of uncaught
exceptions being thrown.  This allows errors to be automatically handled
by the service and a guaranteed valid response to be generated regardless
of any processing problems encountered.

   A default Template::Service object is created by the Template module.
Any Template::Service options may be passed to the Template new()
constructor method and will be forwarded to the Template::Service
constructor.

     use Template;
     
     my $template = Template->new({
     	PRE_PROCESS  => 'header',
     	POST_PROCESS => 'footer',
     });

   Similarly, the Template::Service constructor will forward all
configuration parameters onto other default objects (e.g.
Template::Context) that it may need to instantiate.

   A Template::Service object (or subclass/derivative) can be explicitly
instantiated and passed to the Template new() constructor method as the
SERVICE item.

     use Template;
     use Template::Service;

     my $service = Template::Service->new({
     	PRE_PROCESS  => 'header',
     	POST_PROCESS => 'footer',
     });

     my $template = Template->new({
     	SERVICE => $service,
     });

   The Template::Service module can be sub-classed to create custom service
handlers.

     use Template;
     use MyOrg::Template::Service;

     my $service = MyOrg::Template::Service->new({
     	PRE_PROCESS  => 'header',
     	POST_PROCESS => 'footer',
     	COOL_OPTION  => 'enabled in spades',
     });

     my $template = Template->new({
     	SERVICE => $service,
     });

   The Template module uses the Template::Config service() factory method
to create a default service object when required.  The
$Template::Config::SERVICE package variable may be set to specify an
alternate service module.  This will be loaded automatically and its new()
constructor method called by the service() factory method when a default
service object is required.  Thus the previous example could be written as:

     use Template;

     $Template::Config::SERVICE = 'MyOrg::Template::Service';

     my $template = Template->new({
     	PRE_PROCESS  => 'header',
     	POST_PROCESS => 'footer',
     	COOL_OPTION  => 'enabled in spades',
     });

METHODS
=======

new(\%config)
-------------

   The new() constructor method is called to instantiate a
Template::Service object.  Configuration parameters may be specified as a
HASH reference or as a list of (name => value) pairs.

     my $service1 = Template::Service->new({
     	PRE_PROCESS  => 'header',
     	POST_PROCESS => 'footer',
     });

     my $service2 = Template::Service->new( ERROR => 'error.html' );

   The new() method returns a Template::Service object (or sub-class) or
undef on error.  In the latter case, a relevant error message can be
retrieved by the error() class method or directly from the
$Template::Service::ERROR package variable.

     my $service = Template::Service->new(\%config)
     	|| die Template::Service->error();

     my $service = Template::Service->new(\%config)
     	|| die $Template::Service::ERROR;

   The following configuration items may be specified:

PRE_PROCESS, POST_PROCESS
     These values may be set to contain the name(s) of template files
     (relative to INCLUDE_PATH) which should be processed immediately
     before and/or after each template.  These do not get added to
     templates processed into a document via directives such as INCLUDE,
     PROCESS, WRAPPER etc.

          my $service = Template::Service->new({
          	PRE_PROCESS  => 'header',
          	POST_PROCESS => 'footer',
          };

     Multiple templates may be specified as a reference to a list.  Each is
     processed in the order defined.

          my $service = Template::Service->new({
          	PRE_PROCESS  => [ 'config', 'header' ],
          	POST_PROCESS => 'footer',
          };

     The PRE_PROCESS and POST_PROCESS templates are evaluated in the same
     variable context as the main document and may define or update
     variables for subseqent use.

     config:     [% # set some site-wide variables        bgcolor =
     '#ffffff'        version = 2.718     %]

     header:     [% DEFAULT title = 'My Funky Web Site' %]     <html>
     <head>     <title>[% title %]</title>     </head>     <body
     bgcolor="[% bgcolor %]">

     footer:     <hr>     Version [% version %]     </body>     </html>

     The Template::Document object representing the main template being
     processed is available within PRE_PROCESS and POST_PROCESS templates
     as the 'template' variable.  Metadata items defined via the META
     directive may be accessed accordingly.

          $service->process('mydoc.html', $vars);

     mydoc.html:     [% META title = 'My Document Title' %]     blah blah
     blah     ...

     header:     <html>     <head>     <title>[% template.title
     %]</title></head>     <body bgcolor="[% bgcolor %]">

PROCESS
     The PROCESS option may be set to contain the name(s) of template files
     (relative to INCLUDE_PATH) which should be processed instead of the
     main template passed to the Template::Service process() method.  This
     can be used to apply consistent wrappers around all templates,
     similar to the use of PRE_PROCESS and POST_PROCESS templates.

          my $service = Template::Service->new({
          	PROCESS  => 'content',
          };

          # processes 'content' instead of 'foo.html'
          $service->process('foo.html');

     A reference to the original template is available in the 'template'
     variable.  Metadata items can be inspected and the template can be
     processed by specifying it as a variable reference (i.e. prefixed by
     '$') to an INCLUDE, PROCESS or WRAPPER directive.

     content:     <html>     <head>     <title>[% template.title %]</title>
        </head>

     <body>     [% PROCESS $template %]     <hr>     &copy; Copyright [%
     template.copyright %]     </body>     </html>

     foo.html:     [% META        title     = 'The Foo Page'        author
       = 'Fred Foo'        copyright = '2000 Fred Foo'     %]     <h1>[%
     template.title %]</h1>     Welcome to the Foo Page, blah blah blah

     output:

ERROR
     The ERROR (or ERRORS if you prefer) configuration item can be used to
     name a single template or specify a hash array mapping exception types
     to template names, to be used for error handling.  If an uncaught
     exception is raised from within a template then the appropriate error
     template will instead be processed.

     If specified as a single value then that template will be processed
     for all uncaught exceptions.

          my $service = Template::Service->new({
          	ERROR => 'error.html'
          });

     If the ERROR item is a hash reference the keys are assumed to be
     exception types and the relevant template for a given exception will
     be selected.  A 'default' template may be provided for the general
     case.  Note that 'ERROR' can be pluralised to 'ERRORS' if you find it
     more appropriate in this case.

          my $service = Template::Service->new({
          	ERRORS => {
          	    user     => 'user/index.html',
          	    dbi      => 'error/database',
          	    default  => 'error/default',
          	},
          });

     In this example, any 'user' exceptions thrown will cause the
     'user/index.html' template to be processed, 'dbi' errors are handled
     by 'error/database' and all others by the 'error/default' template.
     Any PRE_PROCESS and/or POST_PROCESS templates will also be applied to
     these error templates.

     Note that exception types are hierarchical and a 'foo' handler will
     catch all 'foo.*' errors (e.g. foo.bar, foo.bar.baz) if a more
     specific handler isn't defined.  Be sure to quote any exception types
     that contain periods to prevent Perl concatenating them into a single
     string (i.e. `user.passwd' is parsed as 'user'.'passwd').

          my $service = Template::Service->new({
          	ERROR => {
          	    'user.login'  => 'user/login.html',
          	    'user.passwd' => 'user/badpasswd.html',
          	    'user'        => 'user/index.html',
          	    'default'     => 'error/default',
          	},
          });

     In this example, any template processed by the $service object, or
     other templates or code called from within, can raise a 'user.login'
     exception and have the service redirect to the 'user/login.html'
     template.  Similarly, a 'user.passwd' exception has a specific
     handling template, 'user/badpasswd.html', while all other 'user' or
     'user.*' exceptions cause a redirection to the 'user/index.html' page.
     All other exception types are handled by 'error/default'.

     Exceptions can be raised in a template using the THROW directive,

          [% THROW user.login 'no user id: please login' %]

     or by calling the throw() method on the current Template::Context
     object,

          $context->throw('user.passwd', 'Incorrect Password');
          $context->throw('Incorrect Password');    # type 'undef'

     or from Perl code by calling die() with a Template::Exception object,

          die Template::Exception->new('user.denied', 'Invalid User ID');

     or by simply calling die() with an error string.  This is
     automagically caught and converted to an  exception of 'undef' type
     which can then be handled in the usual way.

          die "I'm sorry Dave, I can't do that";

AUTO_RESET
     The AUTO_RESET option is set by default and causes the local BLOCKS
     cache for the Template::Context object to be reset on each call to the
     Template process() method.  This ensures that any BLOCKs defined
     within a template will only persist until that template is finished
     processing.  This prevents BLOCKs defined in one processing request
     from interfering with other independant requests subsequently
     processed by the same context object.

     The BLOCKS item may be used to specify a default set of block
     definitions for the Template::Context object.  Subsequent BLOCK
     definitions in templates will over-ride these but they will be
     reinstated on each reset if AUTO_RESET is enabled (default), or if
     the Template::Context reset() method is called.

process($input, \%replace)
--------------------------

   The process() method is called to process a template specified as the
first parameter, $input.  This may be a file name, file handle (e.g. GLOB
or IO::Handle) or a reference to a text string containing the template
text.  An additional hash reference may be passed containing template
variable definitions.

   The method processes the template, adding any PRE_PROCESS or
POST_PROCESS templates defined, and returns the output text.  An uncaught
exception thrown by the template will be handled by a relevant ERROR
handler if defined.  Errors that occur in the PRE_PROCESS or POST_PROCESS
templates, or those that occur in the main input template and aren't
handled, cause the method to return undef to indicate failure.  The
appropriate error message can be retrieved via the error() method.

     $service->process('myfile.html', { title => 'My Test File' })
     	|| die $service->error();

context()
---------

   Returns a reference to the internal context object which is, by
default, an instance of the Template::Context class.

error()
-------

   Returns the most recent error message.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

     http://www.template-toolkit.org/
     http://www.kfs.org/~abw/

REVISION
========

   $Revision: 1.2 $

COPYRIGHT
=========

     Copyright (C) 1996-2000 Andy Wardley.  All Rights Reserved.
     Copyright (C) 1998-2000 Canon Research Centre Europe Ltd.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   L<Template|Template


File: pm.info,  Node: Template/Stash,  Next: Template/Test,  Prev: Template/Service,  Up: Module List

magical storage for template variables
**************************************

NAME
====

   Template::Stash - magical storage for template variables

SYNOPSIS
========

     use Template::Stash;

     my $stash = Template::Stash->new(\%vars);

     # get variable values
     $value = $stash->get($variable);
     $value = $stash->get(\@compound);

     # set variable value
     $stash->set($variable, $value);
     $stash->set(\@compound, $value);

     # default variable value
     $stash->set($variable, $value, 1);
     $stash->set(\@compound, $value, 1);

     # set variable values en masse
     $stash->update(\%new_vars)

     # methods for (de-)localising variables
     $stash = $stash->clone(\%new_vars);
     $stash = $stash->declone();

DESCRIPTION
===========

   The Template::Stash module defines an object class which is used to
store variable values for the runtime use of the template processor.
Variable values are stored internally in a hash reference (which itself is
blessed to create the object) and are accessible via the get() and set()
methods.

   Variables may reference hash arrays, lists, subroutines and objects as
well as simple values.  The stash automatically performs the right magic
when dealing with variables, calling code or object methods, indexing into
lists, hashes, etc.

   The stash has clone() and declone() methods which are used by the
template processor to make temporary copies of the stash for localising
changes made to variables.

PUBLIC METHODS
==============

new(\%params)
-------------

   The new() constructor method creates and returns a reference to a new
Template::Stash object.

     my $stash = Template::Stash->new();

   A hash reference may be passed to provide variables and values which
should be used to initialise the stash.

     my $stash = Template::Stash->new({ var1 => 'value1',
     				       var2 => 'value2' });

get($variable)
--------------

   The get() method retrieves the variable named by the first parameter.

     $value = $stash->get('var1');

   Dotted compound variables can be retrieved by specifying the variable
elements by reference to a list.  Each node in the variable occupies two
entries in the list.  The first gives the name of the variable element,
the second is a reference to a list of arguments for that element, or 0 if
none.

     [% foo.bar(10).baz(20) %]

     $stash->get([ 'foo', 0, 'bar', [ 10 ], 'baz', [ 20 ]);

set($variable, $value, $default)
--------------------------------

   The set() method sets the variable name in the first parameter to the
value specified in the second.

     $stash->set('var1', 'value1');

   Dotted compound variables may be specified as per get() above.

     [% foo.bar = 30 %]

     $stash->set([ 'foo', 0, 'bar', 0 ], 30);

   The magical variable 'IMPORT' can be specified whose corresponding
value should be a hash reference.  The contents of the hash array are
copied (i.e. imported) into the current namespace.

     # foo.bar = baz, foo.wiz = waz
     $stash->set('foo', { 'bar' => 'baz', 'wiz' => 'waz' });

     # import 'foo' into main namespace: foo = baz, wiz = waz
     $stash->set('IMPORT', $stash->get('foo'));

clone(\%params)
---------------

   The clone() method creates and returns a new Template::Stash object
which represents a localised copy of the parent stash.  Variables can be
freely updated in the cloned stash and when declone() is called, the
original stash is returned with all its members intact and in the same
state as they were before clone() was called.

   For convenience, a hash of parameters may be passed into clone() which
is used to update any simple variable (i.e. those that don't contain any
namespace elements like 'foo' and 'bar' but not 'foo.bar') variables while
cloning the stash.  For adding and updating complex variables, the set()
method should be used after calling clone().  This will correctly resolve
and/or create any necessary namespace hashes.

   A cloned stash maintains a reference to the stash that it was copied
from in its '_PARENT' member.

declone()
---------

   The declone() method returns the '_PARENT' reference and can be used to
restore the state of a stash as described above.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

     http://www.template-toolkit.org/
     http://www.kfs.org/~abw/

REVISION
========

   $Revision: 1.1 $

COPYRIGHT
=========

     Copyright (C) 1996-2000 Andy Wardley.  All Rights Reserved.
     Copyright (C) 1998-2000 Canon Research Centre Europe Ltd.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Template|Template' in this node, L<Template::Context|Template::Context


File: pm.info,  Node: Template/Test,  Next: Template/Tutorial,  Prev: Template/Stash,  Up: Module List

module for automating test scripts for the Template Toolkit
***********************************************************

NAME
====

   Template::Test - module for automating test scripts for the Template
Toolkit

SYNOPSIS
========

     use Template::Test;
     
     $Template::Test::DEBUG = 0;   # set this true to see each test running
     $Template::Test::EXTRA = 2;   # 2 extra tests follow test_expect()...

     # ok() can be called any number of times before test_expect
     ok( $true_or_false )

     # test_expect() splits $input into individual tests, processes each
     # and compares generated output against expected output
     test_expect($input, $template, \%replace );

     # $input is text or filehandle (e.g. DATA section after __END__)
     test_expect( $text );
     test_expect( \*DATA );

     # $template is a Template object or configuration hash
     my $template_cfg = { ... };
     test_expect( $input, $template_cfg );
     my $template_obj = Template->new($template_cfg);
     test_expect( $input, $template_obj );

     # $replace is a hash reference of template variables
     my $replace = {
     	a => 'alpha',
     	b => 'bravo'
     };
     test_expect( $input, $template, $replace );

     # ok() called after test_expect should be declared in $EXTRA (2)
     ok( $true_or_false )
     ok( $true_or_false )

DESCRIPTION
===========

   The Template::Test module defines the test_expect() and other related
subroutines which can be used to automate test scripts for the Template
Toolkit.  See the numerous tests in the 't' sub-directory of the
distribution for examples of use.

   The test_expect() subroutine splits an input document into a number of
separate tests, processes each one using the Template Toolkit and then
compares the generated output against an expected output, also specified
in the input document.  It generates the familiar "ok/not ok" output
compatible with Test::Harness.

   The test input should be specified as a text string or a reference to a
filehandle (e.g. GLOB or IO::Handle) from which it can be read.  In
particular, this allows the test input to be placed after the __END__
marker and read via the DATA filehandle.

     use Template::Test;

     test_expect(\*DATA);

     __END__
     # this is the first test (this is a comment)
     -- test --
     blah blah blah [% foo %]
     -- expect --
     blah blah blah value_of_foo

     # here's the second test (no surprise, so is this)
     -- test --
     more blah blah [% bar %]
     -- expect --
     more blah blah value_of_bar

   Blank lines between test sections are generally ignored.  Any line
starting with '#' is treated as a comment and is ignored.

   The second and third parameters to test_expect() are optional.  The
second may be either a reference to a Template object which should be used
to process the template fragments, or a reference to a hash array
containing configuration values which should be used to instantiate a new
Template object.

     # pass reference to config hash
     my $config = {
     	INCLUDE_PATH => '/here/there:/every/where',
     	POST_CHOMP   => 1,
     };
     test_expect(\*DATA, $config);

     # or create Template object explicitly
     my $template = Template->new($config);
     test_expect(\*DATA, $template);

   The third parameter may be used to reference a hash array of template
variable which should be defined when processing the tests.  This is
passed to the Template process() method.

     my $replace = {
     	a => 'alpha',
     	b => 'bravo',
     };

     test_expect(\*DATA, $config, $replace);

   The second parameter may be left undefined to specify a default Template
configuration.

     test_expect(\*DATA, undef, $replace);

   For testing the output of different Template configurations, a
reference to a list of named Template objects also may be passed as the
second parameter.

     my $tt1 = Template->new({ ... });
     my $tt2 = Template->new({ ... });
     my @tts = [ one => $tt1, two => $tt1 ];
     
     The first object in the list is used by default.  Other objects may be
     switched in with the '-- use $name --' marker.  This should immediately
     follow a '-- test --' line.  That object will then be used for the rest
     of the test, or until a different object is selected.

     -- test --
     -- use one --
     [% blah %]
     -- expect --
     blah, blah

     -- test --
     still using one...
     -- expect --
     ...

     -- test --
     -- use two --
     [% blah %]
     -- expect --
     blah, blah, more blah

   The test_expect() sub counts the number of tests, and then calls
ntests() to generate the familiar "1..$ntests\n" test harness line.  Each
test defined generates two test numbers.  The first indicates that the
input was processed without error, and the second that the output matches
that expected.

   Additional test may be run before test_expect() by calling ok().  These
test results are cached until ntests() is called and the final number of
tests can be calculated.  Then, the "1..$ntests" line is output, along
with "ok $n" / "not ok $n" lines for each of the cached test result.
Subsequent calls to ok() then generate an output line immediately.

     my $something = SomeObject->new();
     ok( $something );
     
     my $other = AnotherThing->new();
     ok( $other );

     test_expect(\*DATA);

   If any tests are to follow after test_expect() is called then these
should be pre-declared by setting the $EXTRA package variable.  This value
(default: 0) is added to the grand total calculated by ntests().  The
results of the additional tests are also registered by calling ok().

     $Template::Test::EXTRA = 2;

     # can call ok() any number of times before test_expect()
     ok( $did_that_work );
     ok( $make_sure );
     ok( $dead_certain );

     # <some> number of tests...
     test_expect(\*DATA, $config, $replace);
     
     # here's those $EXTRA tests
     ok( defined $some_result && ref $some_result eq 'ARRAY' );
     ok( $some_result->[0] eq 'some expected value' );

   If you don't want to call test_expect() at all then you can call
ntests($n) to declare the number of tests and generate the test header
line.  After that, simply call ok() for each test passing a true or false
values to indicate that the test passed or failed.

     ntests(2);
     ok(1);
     ok(0);

   If you're really lazy, you can just call ok() and not bother declaring
the number of tests at all.  All tests results will be cached until the
end of the script and then printed in one go before the program exits.

     ok( $x );
     ok( $y );

   You can identify only a specific part of the input file for testing
using the '- start -' and '- stop -' markers.  Anything before the first
'- start -' is ignored, along with anything after the next '- stop -'
marker.

     -- test --
     this is test 1 (not performed)
     -- expect --
     this is test 1 (not performed)

     -- start --

     -- test --
     this is test 2
     -- expect --
     this is test 2
     
     -- stop --

     ...

   For historical reasons and general utility, the module also defines a
'callsign' subroutine which returns a hash mapping a..z to their phonetic
alphabet equivalent (e.g. radio callsigns).  This is used by many of the
test scripts as a "known source" of variable values.

     test_expect(\*DATA, $config, callsign());

   A banner() subroutine is also provided which prints a simple banner
including any text passed as parameters, if $DEBUG is set.

     banner('Testing something-or-other');

   example output:

     #------------------------------------------------------------
     # Testing something-or-other (27 tests completed)
     #------------------------------------------------------------

   The $DEBUG package variable can be set to enable debugging mode.

   The $PRESERVE package variable can be set to stop the test_expect()
from converting newlines in the output and expected output into the
literal strings '\n'.

HISTORY
=======

   This module started its butt-ugly life as the t/texpect.pl script.  It
was cleaned up to became the Template::Test module some time around
version 0.29.  It underwent further cosmetic surgery for version 2.00 but
still retains some rear-end resemblances.

BUGS / KNOWN "FEATURES"
=======================

   Imports all methods by default.  This is generally a Bad Thing, but
this module is only used in test scripts (i.e. at build time) so a) we
don't really care and b) it saves typing.

   The line splitter may be a bit dumb, especially if it sees lines like -
this - that aren't supposed to be special markers.  So don't do that.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

     http://www.template-toolkit.org/
     http://www.kfs.org/~abw/

REVISION
========

   $Revision: 1.1 $

COPYRIGHT
=========

     Copyright (C) 1996-2000 Andy Wardley.  All Rights Reserved.
     Copyright (C) 1998-2000 Canon Research Centre Europe Ltd.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   L<Template|Template


File: pm.info,  Node: Template/Tutorial,  Next: Template/Utils,  Prev: Template/Test,  Up: Module List

a tutorial on using and abusing the Perl Template Toolkit
*********************************************************

NAME
====

   Template Tutorial - a tutorial on using and abusing the Perl Template
Toolkit

DESCRIPTION
===========

   This tutorial document provides a introduction to the Template Toolkit
and demonstrates some of the typical ways it may be used.  It covers the
generation of static pages from templates using the `tpage' and `ttree'
scripts and then goes on to show dynamic content generation using CGI
scripts and Apache/mod_perl handlers.

   Various features of the Template Toolkit are introduced and described
briefly and explained by use of example.  For a complete reference and
guide to the template directives, features and options, consult the
Template documentation.  e.g.

     perldoc Template

INTRODUCTION
============

   The Template Toolkit is a set of Perl modules which collectively
implement a template processing system.  In this context, a template is a
text document containing special markup tags called 'directives'.  A
directive is an instruction for the template processor to perform some
action and substitute the result into the document in place of the
original directive.  Directives include those to define or insert a
variable value, iterate through a list of values (FOREACH), declare a
conditional block (IF/UNLESS/ELSE), include and process another template
file (INCLUDE) and so on.

   In all other respects, the document is a plain text file and may
contain any other content (e.g. HTML, XML, RTF, LaTeX, etc).  Directives
are inserted in the document within the special markup tags which are '[%'
and '%]' by default, but can be changed via the module configuration
options.  Here's an example of an HTML document with additional Template
Toolkit directives.

     [% INCLUDE header
        title = 'This is an HTML example'
     %]

     <h1>Some Interesting Links</h1>

     [% webpages = [
           { url => 'http://foo.org', title => 'The Foo Organsiation' }
           { url => 'http://bar.org', title => 'The Bar Organsiation' }
        ]
     %]

     Links:
     <ul>
     [% FOREACH link = webpages %]
        <li><a href="[% link.url %]">[% link.title %]</a>
     [% END %]
     </ul>

     [% INCLUDE footer %]

   This example shows how the INCLUDE directive is used to load and process
separate 'header' and 'footer' template files, including the output in the
current document.  These files might look like this:

   header:     <html>     <head>     <title>[% title %]</title>     </head>

   <body bgcolor="#ffffff">

   footer:     <hr>

     <center>
     &copy; Copyright 2000 Me, Myself, I
     </center>

     </body>
     </html>

   The example also uses the FOREACH directive to iterate through the
'webpages' list to build a table of links.  In this example, we have
defined this list within the template to contain a number of hash
references, each containing a 'url' and 'title' member.  The FOREACH
directive iterates through the list, aliasing 'link' to each item (hash
ref).  The *[% link.url %]* and *[% link.title %]* directives then access
the individual values in the hash and insert them into the document.

   The following sections show other ways in which data can be defined for
use in a template.

GENERATING STATIC PAGES
=======================

   Having created a template file we can now process it to generate some
real output.  The quickest and easiest way to do this is to use the
`tpage' script.  This is provided as part of the Template Toolkit and
should be installed in your usual Perl bin directory.

   Assuming you saved your template file as 'mypage.html', you would run
the command:

     tpage mypage.html

   This will process the template file, sending the output to STDOUT (i.e.
whizzing past you on the screen).  You may want to redirect the output to
a file but be careful not to specify the same name as the template file,
or you'll overwrite it.  You may want to use one prefix for your templates
such as '.atml' (for 'Another Template Markup Language', perhaps?) and the
regular '.html' for the output files (assuming you're creating HTML, that
is).  Alternatively, you might redirect the output to another directory.
e.g.

     tpage mypage.atml > mypage.html
     tpage templates/mypage.html > html/mypage.html

   The *tpage* script is very basic and only really intended to give you
an easy way to process a template without having to write any Perl code.
A much more flexible tool is *ttree*, described below, but for now let's
look at the output generated by processing the above example (some
whitespace removed for brevity):

     <html>
     <head>
     <title>This is an HTML example</title>
     </head>
     
     <body bgcolor="#ffffff">
     
     <h1>Some Interesting Links</h1>
     
     Links:
     <ul>
        <li><a href="http://foo.org">The Foo Organsiation</a>
        <li><a href="http://bar.org">The Bar Organsiation</a>
     </ul>
     
     <hr>
     
     <center>
     &copy; Copyright 2000 Me, Myself, I
     </center>
     
     </body>
     </html>

   The header and footer template files have been included (assuming you
created them and they're in the current directory) and the link data has
been built into an HTML list.

   The `ttree' script, also distributed as part of the Template Toolkit,
provides a more flexible way to process template documents.  The first
time you run the script, it will ask you if it should create a
configuration file, usually called '.ttreerc' in your home directory.
Answer 'y' to have it create the file.

   The `ttree' documentation describes how you can change the location of
this file and also explains the syntax and meaning of the various options
in the file.  Comments are written to the sample configuration file which
should also help.

     perldoc ttree
     ttree -h

   In brief, the configuration file describes the directories in which
template files are to be found (src), where the corresponding output
should be written to (dest), and any other directories (lib) that may
contain template files that you plan to INCLUDE into your source
documents.  You can also specify processing options (such as 'verbose' and
'recurse') and provide regular expression to match files that you don't
want to process (ignore, accept) or should be copied instead of processed
(copy).

   An example `.ttreerc' file is shown here:

   $HOME/.ttreerc:     verbose     recurse

     # this is where I keep other ttree config files
     cfg = ~/.ttree

     src  = ~/websrc/src
     lib  = ~/websrc/lib
     dest = ~/public_html/test

     ignore = \b(CVS|RCS)\b
     ignore = ^#

   You can create many different configuration files and store them in the
directory specified in the 'cfg' option, shown above.  You then add the
`-f filename' option to `ttree' to have it read that file.

   When you run the script, it compares all the files in the 'src'
directory (including those in sub-directories if the 'recurse' option is
set), with those in the 'dest' directory.  If the destination file doesn't
exist or has an earlier modification time than the corresponding source
file, then the source will be processed with the output written to the
destination file.  The -a option forces all files to be processed,
regardless of modification times.

   The script *doesn't* process any of the files in the 'lib' directory,
but it does add it to the INCLUDE_PATH for the template processor so that
it can locate these files via an INCLUDE or PROCESS directive.  Thus, the
'lib' directory is an excellent place to keep template elements such as
header, footers, etc., that aren't complete documents in their own right.

   You can also specify various Template Toolkit options from the
configuration file.  Consult the *ttree* documentation and help summary
(`ttree -h') for full details.  e.g.

   $HOME/.ttreerc:     pre_process = config     interpolate     post_chomp

   The 'pre_process' option allows you to specify a template file which
should be processed before each file.  Unsurprisingly, there's also a
'post_process' option to add a template after each file.  In the fragment
above, we have specified that the 'config' template should be used as a
prefix template.  We can create this file in the 'lib' directory and use
it to define some common variables, including those web page links we
defined earlier and might want to re-use in other templates.  We could
also include an HTML header, title, or menu bar in this file which would
then be prepended to each and every template file, but for now we'll keep
all that in a separate 'header' file.

   $lib/config:     [% root     = '~/abw'        home     =
"$root/index.html"        images   = "$root/images"        email    =
'abw@kfs.org'        graphics = 1        webpages = [          { url =>
'http://foo.org', title => 'The Foo Organsiation' }          { url =>
'http://bar.org', title => 'The Bar Organsiation' }        ]     %]

   Assuming you've created or copied the 'header' and 'footer' files from
the earlier example into your 'lib' directory, you can now start to create
web pages like the following in your 'src' directory and process them with
`ttree'.

   $src/newpage.html:     [% INCLUDE header        title = 'Another
Template Toolkit Test Page'     %]

     <a href="[% home %]">Home</a>
     <a href="mailto:[% email %]">Email</a>

     [% IF graphics %]
     <img src="[% images %]/logo.gif" align=right width=60 height=40>
     [% END %]

     [% INCLUDE footer %]

   Here we've shown how pre-defined variables can be used as flags to
enable certain feature (e.g. 'graphics') and to specify common items such
as an email address and URL's for the home page, images directory and so
on.  This approach allows you to define these values once so that they're
consistent across all pages and can easily be changed to new values.

   When you run *ttree*, you should see output similar to the following
(assuming you have the verbose flag set).

     ttree 1.14 (Template Toolkit version 1.02a)

     Source: /home/abw/websrc/src
        Destination: /home/abw/public_html/test
       Include Path: [ /home/abw/websrc/lib ]
     Ignore: [ \b(CVS|RCS)\b, ^# ]
       Copy: [  ]
     Accept: [ * ]

     + newpage.html

   The '+' before 'newpage.html' shows that the file was processed, with
the output being written to the destination directory.  If you run the
same command again, you'll see the following line displayed instead
showing a '-' and giving a reason why the file wasn't processed.

     - newpage.html                     (not modified)

   It has detected a 'newpage.html' in the destination directory which is
more recent than that in the source directory and so hasn't bothered to
waste time re-processing it.  To force all files to be processed, use the
-a option.  You can also specify one or more filenames as command line
arguments to `ttree':

     tpage newpage.html

   This is what the destination page looks like.

   $dest/newpage.html:     <html>     <head>     <title>Another Template
Toolkit Test Page</title>     </head>

   <body bgcolor="#ffffff">

   <a href="~/abw/index.html">Home</a>     <a
href="mailto:abw@kfs.org">Email me</a>

     <img src="~/abw/images/logo.gif" align=right width=60 height=40>
     
     <hr>
     
     <center>
     &copy; Copyright 2000 Me, Myself, I
     </center>
     
     </body>
     </html>

   You can add as many documents as you like to the 'src' directory and
`ttree' will apply the same process to them all.  In this way, it is
possible to build an entire tree of static content for a web site with a
single command.  The added benefit is that you can be assured of
consistency in links, header style, or whatever else you choose to
implement in terms of common templates elements or variables.

DYNAMIC CONTENT GENERATION VIA CGI SCRIPT
=========================================

   The Template modules provides a simple front-end to the Template
Toolkit for use in CGI scripts and Apache/mod_perl handlers.  Simply 'use'
the Template module, create an object instance with the new() method and
then call the process() method on the object, passing the name of the
template file as a parameter.  The second parameter passed is a reference
to a hash array of variables that we want made available to the template:

     #!/usr/bin/perl -w

     use strict;
     use Template;

     my $file = 'src/greeting.html';
     my $vars = {
        message  => "Hello World\n"
     };

     my $template->new();

     $template->process($file, $vars)
     	|| die "Template process failed: ", $template->error(), "\n";

   So that our scripts will work with the same template files as our
earlier examples, we'll can add some configuration options to the
constructor to tell it about our environment:

     my $template->new({
     	# where to find template files
     	INCLUDE_PATH => '/home/abw/websrc/src:/home/abw/websrc/lib',
     	# pre-process lib/config to define any extra values
     	PRE_PROCESS  => 'config',
     });

   Note that here we specify the 'config' file as a PRE_PROCESS option.
This means that the templates we process can use the same global variables
defined earlier for our static pages.  We don't have to replicate their
definitions in this script.  However, we can supply additional data and
functionality specific to this script via the hash of variables that we
pass to the process() method.

   These entries in this hash may contain simple text or other values,
references to lists, others hashes, sub-routines or objects.  The Template
Toolkit will automatically apply the correct procedure to access these
different types when you use the variables in a template.

   Here's a more detailed example to look over.  Amongst the different
template variables we define in `$vars', we create a reference to a CGI
object and a 'get_user_projects' sub-routine.

     #!/usr/bin/perl -w

     use strict;
     use Template;
     use CGI;

     $| = 1;
     print "Content-type: text/html\n\n";

     my $file = 'userinfo.html';
     my $vars = {
         'version'  => 3.14,
     	'days'     => [ qw( mon tue wed thu fri sat sun ) ],
     	'worklist' => \&get_user_projects,
         'cgi'      => CGI->new(),
     	'me'       => {
             'id'     => 'abw',
             'name'   => 'Andy Wardley',
     	},
     };

     sub get_user_projects {
     	my $user = shift;
     	my @projects = ...   # do something to retrieve data
     	return \@projects;
     }

     my $template = Template->new({
     	INCLUDE_PATH => '/home/abw/websrc/src:/home/abw/websrc/lib',
     	PRE_PROCESS  => 'config',
     });

     $template->process($userinfo, $vars)
     	|| die $template->error();

   Here's a sample template file that we might create to build the output
for this script.

   $src/userinfo.html:     [% INCLUDE header        title = 'Template
Toolkit CGI Test'     %]

     <a href="mailto:[% email %]">Email [% me.name %]</a>

     <p>This is version [% version %]</p>

     <h3>Projects</h3>
     <ul>
     [% FOREACH project = worklist(me.id) %]
        <li> <a href="[% project.url %]">[% project.name %]</a>
     [% END %]
     </ul>

     [% INCLUDE footer %]

   This example shows how we've separated the Perl implementation (code)
from the presentation (HTML) which not only makes them easier to maintain
in isolation, but also allows the re-use of existing template elements
such as headers and footers, etc.  By using template to create the output
of your CGI scripts, you can give them the same consistency as your static
pages built via `ttree' or other means.

   Furthermore, we can modify our script so that it processes any one of a
number of different templates based on some condition.  A CGI script to
maintain a user database, for example, might process one template to
provide an empty form for new users, the same form with some default
values set for updating an existing user record, a third template for
listing all users in the system, and so on.  You can use any Perl
functionality you care to write to implement the logic of your application
and then choose one or other template to generate the desired output for
the application state.

DYNAMIC CONTENT GENERATION VIA APACHE/MOD_PERL HANDLER
======================================================

   The Template module can be used in a similar way from an Apache/mod_perl
handler.  Here's an example of a typical Apache httpd.conf file:

     PerlModule CGI;
     PerlModule Template
     PerlModule MyOrg::Apache::User

     PerlSetVar websrc_root   /home/abw/websrc

     <Location /user/bin>
         SetHandler     perl-script
         PerlHandler    MyOrg::Apache::User
     </Location>

   This defines a location called '/user/bin' to which all requests will
be forwarded to the handler() method of the MyOrg::Apache::User module.
That module might look something like this:

     package MyOrg::Apache::User;
     
     use strict;
     use vars qw( $VERSION );
     use Apache::Constants qw( :common );
     use Template qw( :template );
     use CGI;
     
     $VERSION = 1.59;
     
     sub handler {
     	my $r = shift;
     
     	my $websrc = $r->dir_config('websrc_root')
     	    or return fail($r, SERVER_ERROR,
     			   "'websrc_root' not specified");
     
     	my $template = Template->new({
     	    INCLUDE_PATH  => "$websrc/src/user:$websrc/lib",
     	    PRE_PROCESS   => 'config',
     	    OUTPUT        => $r,     # direct output to Apache request
     	});
     
     	my $params = {
     	    uri     => $r->uri,
     	    cgi     => CGI->new,
     	};
     
     	# use the path_info to determine which template file to process
     	my $file = $r->path_info;
     	$path =~ s[^/][];
     
     	$r->content_type('text/html');
     	$r->send_http_header;
     
     	$template->process($path, $params)
     	    || return fail($r, SERVER_ERROR, $template->error());
     
     	return OK;
     }
     
     sub fail {
     	my ($r, $status, $message) = @_;
     	$r->log_reason($message, $r->filename);
     	return $status;
     }

   The handler accepts the request and uses it to determine the
'websrc_root' value from the config file.  This is then used to define an
INCLUDE_PATH for a new Template object.  The URI is extracted from the
request and a CGI object is created.  These are both defined as template
variables.

   The name of the template file itself is taken from the PATH_INFO element
of the request.  In this case, it would comprise the part of the URL
coming after '/user/bin',  e.g for '/user/bin/edit', the template file
would be 'edit' located in "$websrc/src/user".  The headers are sent and
the template file is processed.  All output is sent directly to the
print() method of the Apache request object.

USING PLUGINS TO EXTEND FUNCTIONALITY
=====================================

   As we've already shown, it is possible to bind Perl data and functions
to template variables when creating dynamic content via a CGI script or
Apache/mod_perl process.  The Template Toolkit also supports a plugin
interface which allows you define such additional data and/or
functionality in a separate module and then load and use it as required
with the USE directive.

   The main benefit to this approach is that you can load the extension
into any template document, even those that are processed "statically" by
`tpage' or `ttree'.  You *don't* need to write a Perl wrapper to
explicitly load the module and make it available via the stash.

   Let's demonstrate this principle using the DBI plugin written by Simon
Matthews <sam@knowledgepool.com>.  You can create this template in your
'src' directory and process it using `ttree' to see the results.  Of
course, this example relies on the existence of the appropriate SQL
database but you should be able to adapt it to your own resources, or at
least use it as a demonstrative example of what's possible.

     [% INCLUDE header
        title = 'User Info'
     %]
     
     [% USE DBI('dbi:mSQL:mydbname') %]
     
     <table border=0 width="100%">
     <tr>
       <th>User ID</th>
       <th>Name</th>
       <th>Email</th>
     </tr>
     
     [% FOREACH user = DBI.query('SELECT * FROM user ORDER BY id') %]
     <tr>
       <td>[% user.id %]</td>
       <td>[% user.name %]</td>
       <td>[% user.email %]</td>
     </tr>
     [% END %]
     
     </table>
     
     [% INCLUDE footer %]

   A plugin is simply a Perl module in a known location and conforming to
a known standard such that the Template Toolkit can find and load it
automatically.  You can create your own plugin by inheriting from the
`Template::Plugin' module.

   Here's an example which defines some data items ('foo' and 'people')
and also an object method ('bar').  We'll call the plugin 'FooBar' for
want of a better name and create it in the
'MyOrg::Template::Plugin::FooBar' package.  We've added a 'MyOrg' to the
regular 'Template::Plugin::*' package to avoid any conflict with existing
plugins.

   You can create a module stub using the Perl utlity h2xs:

     h2xs -A -X -n MyOrg::Template::Plugin::FooBar

   This will create a directory structure representing the package name
along with a set of files comprising your new module.  You can then edit
FooBar.pm to look something like this:

     package MyOrg::Template::Plugin::FooBar;

     use Template::Plugin;
     use vars qw( $VERSION @ISA );

     @ISA = qw( Template::Plugin );
     $VERSION = 1.23;

     sub new {
         my ($class, $context, @params) = @_;

     bless {
         _CONTEXT => $context,
                 foo      => 25,
                 people   => [ 'tom', 'dick', 'harry' ],
     }, $class;
         }

     sub bar {
     	my ($self, @params) = @_;
         # ...do something...
     	return $some_value;
     }

   The plugin constructor new() receives the class name as the first
parameter, as is usual in Perl, followed by a reference to something
called a Template::Context object.  You don't need to worry too much about
this at the moment, other than to know that it's the main processing
object for the Template Toolkit.  It provides access to the functionality
of the processor and some plugins may need to communicate with it.  We
don't at this stage, but we'll save the reference anyway in the '_CONTEXT'
member.  The leading underscore is a convention which indicates that this
item is private and the Template Toolkit won't attempt to access this
member.  The other members defined, 'foo' and 'people' are regular data
items which will be made available to templates using this plugin.
Following the context reference are passed any additional parameters
specified with the USE directive, such as the data source parameter,
'dbi:mSQL:mydbname', that we used in the earlier DBI example.

   If you used h2xs to create the module stub then you'll already have a
Makefile.PL and you can incite the familiar incantation to build and
install it.  Don't forget to add some tests to test.pl!

     perl Makefile.PL
     make
     make test
     make install

   If you don't or can't install it to the regular place for your Perl
modules (perhaps because you don't have the required privileges) then you
can set the PERL5LIB environment variable to specify another location.  If
you're using `ttree' then you can add the following line to your
configuration file instead.  This has the effect of add '/path/to/modules'
to the @INC array to a similar end.

   $HOME/.ttreerc:     perl5lib = /path/to/modules

   One further configuration item must be added to inform the toolkit of
the new package name we have adopted for our plugins:

   $HOME/.ttreerc:     plugin_base = 'MyOrg::Template::Plugin'

   If you're writing Perl code to control the Template modules directly,
then this value can be passed as a configuration parameter when you create
the module.

     use Template;

     my $template = Template->new({
     	PLUGIN_BASE => 'MyOrg::Template::Plugin'
     });

   Now we can create a template which uses this plugin:

     [% INCLUDE header
        title = 'FooBar Plugin Test'
     %]

     [% USE FooBar %]

     Some values available from this plugin:
       [% FooBar.foo %] [% FooBar.bar %]

     The users defined in the 'people' list:
     [% FOREACH uid = FooBar.people %]
       * [% uid %]
     [% END %]

     [% INCLUDE footer %]

   The 'foo', 'bar' and 'people' items of the FooBar plugin are
automatically resolved to the appropriate data items or method calls on
the underlying object.

   Using this approach, it is possible to create application functionality
in a single module which can then be loaded and used on demand in any
template.  The simple interface between template directives and plugin
objects allows complex, dynamic content to be built from a few simple
template documents without knowing anything about the underlying
implementation.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

     http://www.template-toolkit.org/
     http://www.kfs.org/~abw/

REVISION
========

   $Revision: 2.0 $

COPYRIGHT
=========

     Copyright (C) 1996-2000 Andy Wardley.  All Rights Reserved.
     Copyright (C) 1998-2000 Canon Research Centre Europe Ltd.

   This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

SEE ALSO
========

   `Template|Template' in this node, `tpage|tpage' in this node,
L<ttree|ttree


