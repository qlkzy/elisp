This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Tiger,  Next: Time/Avail,  Prev: Tie/Watch,  Up: Module List

Perl interface to the Tiger Hash Algorithm
******************************************

NAME
====

   Tiger - Perl interface to the Tiger Hash Algorithm

SYNOPSIS
========

     use Tiger;

     $context = new Tiger;
     $context->reset();

     $context->add(LIST);
     $context->addfile(HANDLE);

     $digest = $context->digest();
     $string = $context->hexdigest();

     $digest = $context->hash($string);
     $string = $context->hexhash($string);

DESCRIPTION
===========

   The *Tiger* module allows you to use the Tiger hash algorithm developed
by Ross Anderson and Eli Biham in Perl programs.

   A new Tiger context object is created with the new operation.  Multiple
simultaneous digest context can be maintained if desired.  The context is
updated with the add operation which adds the strings contained in the
LIST parameter.

   The final message digest value is returned by the digest operation as a
24-byte binary string. This operation delivers the result of operations
since the last new or reset operation. Once the operation has been
performed, the context must be reset before being used to calculate
another digest value.

   Several convenience functions are also provided. The *addfile*
operation takes an open file-handle and reads it until end-of file in
8192-byte blocks adding the contents to the context. The *hexdigest*
operation calls digest and returns the result as a printable string of
hexadecimal digits in eight-digit groups. The hash operation performs the
complete series of steps: reset, add, digest on the supplied scalar value,
and returns the result as a 24-byte binary string. The *hexhash* operation
does the same thing, but returns the result in the format of the
*hexdigest* operation.

NOTE
====

   The Tiger extension may be redistributed either under the GPL or the
Perl Artistic License.  The Tiger code has been appropriated from the GNU
Privacy Guard, and slightly modified to interface with Perl.

AUTHOR
======

   The Tiger interface was written by Rafael Sevilla
(`dido@pacific.net.ph'), shamelessly stealing from the SHA interface
written by Uwe Hollerbach (`uh@alumni.caltech.edu').

   For more information on Tiger see:

   http://www.cs.technion.ac.il/~biham/Reports/Tiger/


File: pm.info,  Node: Time/Avail,  Next: Time/Beat,  Prev: Tiger,  Up: Module List

A Perl module to calculate time availability.
*********************************************

NAME
====

   Time::Avail - A Perl module to calculate time availability.

SYNOPSIS
========

   `use Time::Avail;'

   `$minRemaining = timeAvailable( $timeStartStr, $timeEndStr, $dayMask );'

DESCRIPTION
===========

   The *timeAvailable* function compares the time interval specified by
*timeStartStr*, *timeEndStr*, and *dayMask* with the current day and time.
*timeAvailable* returns *0 * if the current day and time do not fall within
the specified time interval, otherwise the number of minutes remaining is
returned.  *timeStartStr* and *timeEndStr* are string parameters that must
adhere to a *HH:MM 24 hour* format, where *HH* represents a two digit hour
value and *MM* represents a two digit minute value.  *dayMask* is a
bitmask which specifies the valid days for the time interval.

   The *dayMask* parameter is constructed by OR'ing together one or more
of the following dayMask constants:

   * Time::Avail::DAY_MONDAY

   * Time::Avail::DAY_TUESDAY

   * Time::Avail::DAY_WEDNESDAY

   * Time::Avail::DAY_THURSDAY

   * Time::Avail::DAY_FRIDAY

   * Time::Avail::DAY_SATURDAY

   * Time::Avail::DAY_SUNDAY

   * Time::Avail::DAY_WEEKDAY

   * Time::Avail::DAY_WEEKEND

   * Time::Avail::DAY_EVERYDAY

EXAMPLES
--------

   To calculate the time remaining given a starting time of 5am and an
ending time of 5pm for Sunday and Monday, the call to *timeAvailable* can
be coded as follows:

   `$minRemaining = timeAvailable( "05:00", "17:00",
Time::Avail::DAY_SUNDAY | Time::Avail::DAY_MONDAY );'

   To calculate the time remaining given a starting time of 10:30am and an
ending time of 7:45pm for Saturday, Sunday, and Monday, the call to
*timeAvailable* can be coded as follows:

   `$minRemaining = timeAvailable( "10:30", "19:45",
Time::Avail::DAY_SATURDAY |  Time::Avail::DAY_SUNDAY
|Time::Avail::DAY_MONDAY );'

   or

   `$minRemaining = timeAvailable( "10:30", "19:45",
Time::Avail::DAY_WEEKEND | Time::Avail::DAY_MONDAY );'

   To calculate the time remaining given a starting time of 7am and an
ending time of 7pm for everyday but Saturday and Sunday, the call to
*timeAvailable* can be coded as follows:

   `$minRemaining = timeAvailable( "07:00", "19:00",
Time::Avail::DAY_WEEKDAY );'

   To calculate the time remaining given a starting time of 10pm and an
ending time of 2am for everyday, the call to *timeAvailable* can be coded
as follows:

   `$minRemaining = timeAvailable( "22:00", "02:00",
Time::Avail::DAY_EVERYDAY );'

VERSION
=======

   1.00

HISTORY
=======

     Version 1.00
     ------------
     	- Released.

AUTHOR
======

   Peter Santoro peter@pscomp.com

COPYRIGHT
=========

   Copyright (c) 1998 Peter Santoro.  All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself; however, you must leave this copyright statement
intact.

DATE
====

   December 19, 1998

SOURCE
======

   This distribution can be also be found at the author's web site:

     http://www.connix.com/~psantoro/


File: pm.info,  Node: Time/Beat,  Next: Time/CTime,  Prev: Time/Avail,  Up: Module List

Module to convert from standard time to swatch 'beat' time.
***********************************************************

NAME
====

   Time::Beat - Module to convert from standard time to swatch 'beat' time.

SYNOPSIS
========

   use Time::Beat qw ( beattime );

   my $time_in_beats = beattime(time());

DESCRIPTION
===========

   `Time::Beat' is a module to provide you with the time in beats.  It
takes a `time()' formatted string, and outputs the time in beats.  The
basic algorithm for doing this is to take time in GMT+1 hour, convert it
into seconds, and divide by 86.4.  Hopefully I'll get it converting
backwards at some point.

FUNCTIONS
=========

beattime [time string]
     beattime is the one and only function in Time::Beat.  It will give you
     the current time in beats if you do not specify a time string.  If you
     specify a time string it will return that particular time in beats.

CHANGES
=======

   If gmtime.hours == 23 before then problems were caused because the hour
became 24 - it should have been 0.  The problem has now been fixed.

AUTHOR
======

   James A. Duncan <j@mesduncan.co.uk>

SEE ALSO
========

   perl(1)


File: pm.info,  Node: Time/CTime,  Next: Time/DaysInMonth,  Prev: Time/Beat,  Up: Module List

format times ala POSIX asctime
******************************

NAME
====

   Time::CTime - format times ala POSIX asctime

SYNOPSIS
========

     use Time::CTime
      	print ctime(time);
     print asctime(localtime(time));
     print strftime(template, localtime(time));

strftime conversions
--------------------

     %%	PERCENT
     %a	day of the week abbr
     %A	day of the week
     %b	month abbr
     %B 	month
     %c 	ctime format: Sat Nov 19 21:05:57 1994
     %d 	DD
     %D 	MM/DD/YY
     %e 	numeric day of the month
     %f 	floating point seconds (milliseconds): .314
     %F 	floating point seconds (microseconds): .314159
     %h 	month abbr
     %H 	hour, 24 hour clock, leading 0's)
     %I 	hour, 12 hour clock, leading 0's)
     %j 	day of the year
     %k 	hour
     %l 	hour, 12 hour clock
     %m 	month number, starting with 1
     %M 	minute, leading 0's
     %n 	NEWLINE
     %o	ornate day of month -- "1st", "2nd", "25th", etc.
     %p 	AM or PM
     %r 	time format: 09:05:57 PM
     %R 	time format: 21:05
     %S 	seconds, leading 0's
     %t 	TAB
     %T 	time format: 21:05:57
     %U 	week number, Sunday as first day of week
     %w 	day of the week, numerically, Sunday == 0
     %W 	week number, Monday as first day of week
     %x 	date format: 11/19/94
     %X 	time format: 21:05:57
     %y	year (2 digits)
     %Y	year (4 digits)
     %Z 	timezone in ascii. eg: PST

DESCRIPTION
===========

   This module provides routines to format dates.  They correspond to the
libc routines.  &strftime() supports a pretty good set of coversions -
more than most C libraries.

   strftime supports a pretty good set of conversions.

   The POSIX module has very similar functionality.  You should consider
using it instead if you do not have allergic reactions to system libraries.

GENESIS
=======

   Written by David Muir Sharnoff <muir@idiom.com>.

   The starting point for this package was a posting by Paul Foley
<paul@ascent.com>

   Copyright (C) 1996-1999 David Muir Sharnoff.  All Rights Reserved.  Use
and redistribution allowed at user's own risk.


File: pm.info,  Node: Time/DaysInMonth,  Next: Time/HiRes,  Prev: Time/CTime,  Up: Module List

simply report the number of days in a month
*******************************************

NAME
====

   Time::DaysInMonth - simply report the number of days in a month

SYNOPSIS
========

     use Time::DaysInMonth;
     $days = days_in($year, $month_1_to_12);
     $leapyear = is_leap($year);

DESCRIPTION
===========

   DaysInMonth is simply a package to report the number of days in a
month.  That's all it does.  Really!

AUTHOR
======

   David Muir Sharnoff <muir@idiom.com>

   Copyright (C) 1996-1999 David Muir Sharnoff.  All Rights Reserved.  Use
and redistribution allowed at user's own risk.


File: pm.info,  Node: Time/HiRes,  Next: Time/JulianDay,  Prev: Time/DaysInMonth,  Up: Module List

High resolution ualarm, usleep, and gettimeofday
************************************************

NAME
====

   Time::HiRes - High resolution ualarm, usleep, and gettimeofday

SYNOPSIS
========

     use Time::HiRes qw( usleep ualarm gettimeofday tv_interval );

     usleep ($microseconds);

     ualarm ($microseconds);
     ualarm ($microseconds, $interval_microseconds);

     $t0 = [gettimeofday];
     ($seconds, $microseconds) = gettimeofday;

     $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
     $elapsed = tv_interval ( $t0, [gettimeofday]);
     $elapsed = tv_interval ( $t0 );

     use Time::HiRes qw ( time alarm sleep );
     $now_fractions = time;
     sleep ($floating_seconds);
     alarm ($floating_seconds);
     alarm ($floating_seconds, $floating_interval);

DESCRIPTION
===========

   The `Time::HiRes' module implements a Perl interface to the usleep,
ualarm, and gettimeofday system calls. See the EXAMPLES section below and
the test scripts for usage; see your system documentation for the
description of the underlying gettimeofday, usleep, and ualarm calls.

   If your system lacks gettimeofday(2) you don't get gettimeofday() or the
one-arg form of tv_interval().  If you don't have usleep(3) or select(2)
you don't get usleep() or sleep().  If your system don't have ualarm(3) or
setitimer(2) you don't get ualarm() or alarm().  If you try to import an
unimplemented function in the use statement it will fail at compile time.

   The following functions can be imported from this module.  No functions
are exported by default.

gettimeofday ()
     In array context it returns a 2 element array with the seconds and
     microseconds since the epoch.  In scalar context it returns floating
     seconds like Time::HiRes::time() (see below).

usleep ( $useconds )
     Issues a usleep for the number of microseconds specified. See also
     Time::HiRes::sleep() below.

ualarm ( $useconds [, $interval_useconds ] )
     Issues a ualarm call; interval_useconds is optional and will be 0 if
     unspecified, resulting in alarm-like behaviour.

tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )
     Returns the floating seconds between the two times, which should have
     been returned by gettimeofday(). If the second argument is omitted,
     then the current time is used.

time ()
     Returns a floating seconds since the epoch. This function can be
     imported, resulting in a nice drop-in replacement for the time
     provided with perl, see the EXAMPLES below.

sleep ( $floating_seconds )
     Converts $floating_seconds to microseconds and issues a usleep for the
     result.  This function can be imported, resulting in a nice drop-in
     replacement for the sleep provided with perl, see the EXAMPLES below.

alarm ( $floating_seconds [, $interval_floating_seconds ] )
     Converts $floating_seconds and $interval_floating_seconds and issues a
     ualarm for the results.  The $interval_floating_seconds argument is
     optional and will be 0 if unspecified, resulting in alarm-like
     behaviour.  This function can be imported, resulting in a nice drop-in
     replacement for the alarm provided with perl, see the EXAMPLES below.

EXAMPLES
========

     use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);

     $microseconds = 750_000;
     usleep $microseconds;

     # signal alarm in 2.5s & every .1s thereafter
     ualarm 2_500_000, 100_000;

     # get seconds and microseconds since the epoch
     ($s, $usec) = gettimeofday;

     # measure elapsed time
     # (could also do by subtracting 2 gettimeofday return values)
     $t0 = [gettimeofday];
     # do bunch of stuff here
     $t1 = [gettimeofday];
     # do more stuff here
     $t0_t1 = tv_interval $t0, $t1;
     
     $elapsed = tv_interval ($t0, [gettimeofday]);
     $elapsed = tv_interval ($t0);	# equivalent code

     #
     # replacements for time, alarm and sleep that know about
     # floating seconds
     #
     use Time::HiRes;
     $now_fractions = Time::HiRes::time;
     Time::HiRes::sleep (2.5);
     Time::HiRes::alarm (10.6666666);
     
     use Time::HiRes qw ( time alarm sleep );
     $now_fractions = time;
     sleep (2.5);
     alarm (10.6666666);

C API
=====

   In addition to the perl API described above, a C API is available for
extension writers.  The following C functions are available in the
modglobal hash:

     name             C prototype
     ---------------  ----------------------
     Time::NVtime     double (*)()
     Time::U2time     void (*)(UV ret[2])

   Both functions return equivalent information (like gettimeofday) but
with different representations.  The names `NVtime' and `U2time' were
selected mainly because they are operating system independent.
(gettimeofday is Un*x-centric.)

   Here is an example of using NVtime from C:

     double (*myNVtime)();
     SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
     if (!svp)         croak("Time::HiRes is required");
     if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
     myNVtime = (double(*)()) SvIV(*svp);
     printf("The current time is: %f\n", (*myNVtime)());

AUTHORS
=======

   D. Wegscheid <wegscd@whirlpool.com> R. Schertler <roderick@argon.org>
J. Hietaniemi <jhi@iki.fi> G. Aas <gisle@aas.no>

REVISION
========

   $Id: HiRes.pm,v 1.20 1999/03/16 02:26:13 wegscd Exp $

   $Log: HiRes.pm,v $ Revision 1.20  1999/03/16 02:26:13  wegscd Add
documentation for NVTime and U2Time.

   Revision 1.19  1998/09/30 02:34:42  wegscd No changes, bump version.

   Revision 1.18  1998/07/07 02:41:35  wegscd No changes, bump version.

   Revision 1.17  1998/07/02 01:45:13  wegscd Bump version to 1.17

   Revision 1.16  1997/11/13 02:06:36  wegscd version bump to accomodate
HiRes.xs fix.

   Revision 1.15  1997/11/11 02:17:59  wegscd POD editing, courtesy of
Gisle Aas.

   Revision 1.14  1997/11/06 03:14:35  wegscd Update version # for
Makefile.PL and HiRes.xs changes.

   Revision 1.13  1997/11/05 05:36:25  wegscd change version # for
Makefile.pl and HiRes.xs changes.

   Revision 1.12  1997/10/13 20:55:33  wegscd Force a new version for
Makefile.PL changes.

   Revision 1.11  1997/09/05 19:59:33  wegscd New version to bump version
for README and Makefile.PL fixes.  Fix bad RCS log.

   Revision 1.10  1997/05/23 01:11:38  wegscd Conditional compilation;
EXPORT_FAIL fixes.

   Revision 1.2  1996/12/30 13:28:40  wegscd Update documentation for what
to do when missing ualarm() and friends.

   Revision 1.1  1996/10/17 20:53:31  wegscd Fix =head1 being next to
__END__ so pod2man works

   Revision 1.0  1996/09/03 18:25:15  wegscd Initial revision

COPYRIGHT
=========

   Copyright (c) 1996-1997 Douglas E. Wegscheid.  All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Time/JulianDay,  Next: Time/Local,  Prev: Time/HiRes,  Up: Module List

Julian calendar manipulations
*****************************

NAME
====

   Time::JulianDay - Julian calendar manipulations

SYNOPSIS
========

     use Time::JulianDay

     $jd = julian_day($year, $month_1_to_12, $day)
     $jd = local_julian_day($seconds_since_1970);
     $jd = gm_julian_day($seconds_since_1970);
     ($year, $month_1_to_12, $day) = inverse_julian_day($jd)
     $dow = day_of_week($jd)

     print (Sun,Mon,Tue,Wed,Thu,Fri,Sat)[$dow];

     $seconds_since_jan_1_1970 = jd_secondslocal($jd, $hour, $min, $sec)
     $seconds_since_jan_1_1970 = jd_secondsgm($jd, $hour, $min, $sec)
     $seconds_since_jan_1_1970 = jd_timelocal($sec,$min,$hours,$mday,$month_0_to_11,$year)
     $seconds_since_jan_1_1970 = jd_timegm($sec,$min,$hours,$mday,$month_0_to_11,$year)

DESCRIPTION
===========

   JulianDay is a package that manipulates dates as number of days since
some time a long time ago.  It's easy to add and subtract time using
julian days...

   The day_of_week returned by day_of_week() is 0 for Sunday, and 6 for
Saturday and everything else is in between.

GENESIS
=======

   Written by David Muir Sharnoff <muir@idiom.com> with help from previous
work by Kurt Jaeger aka PI <zrzr0111@helpdesk.rus.uni-stuttgart.de>  	based
on postings from: Ian Miller <ian_m@cix.compulink.co.uk>; Gary Puckering
<garyp%cognos.uucp@uunet.uu.net> 	based on Collected Algorithms of the ACM
?; and the unknown-to-me author of Time::Local.


File: pm.info,  Node: Time/Local,  Next: Time/Object,  Prev: Time/JulianDay,  Up: Module List

efficiently compute time from local and GMT time
************************************************

NAME
====

   Time::Local - efficiently compute time from local and GMT time

SYNOPSIS
========

     $time = timelocal($sec,$min,$hours,$mday,$mon,$year);
     $time = timegm($sec,$min,$hours,$mday,$mon,$year);

DESCRIPTION
===========

   These routines are the inverse of built-in perl fuctions localtime()
and gmtime().  They accept a date as a six-element array, and return the
corresponding time(2) value in seconds since the Epoch (Midnight, January
1, 1970).  This value can be positive or negative.

   It is worth drawing particular attention to the expected ranges for the
values provided.  While the day of the month is expected to be in the
range 1..31, the month should be in the range 0..11.  This is consistent
with the values returned from localtime() and gmtime().

   The timelocal() and timegm() functions perform range checking on the
input $sec, $min, $hours, $mday, and $mon values by default.  If you'd
rather they didn't, you can explicitly import the timelocal_nocheck() and
timegm_nocheck() functions.

     use Time::Local 'timelocal_nocheck';

     {
         # The 365th day of 1999
         print scalar localtime timelocal_nocheck 0,0,0,365,0,99;

     # The twenty thousandth day since 1970
     print scalar localtime timelocal_nocheck 0,0,0,20000,0,70;

     # And even the 10,000,000th second since 1999!
     print scalar localtime timelocal_nocheck 10000000,0,0,1,0,99;
     	}

   Your mileage may vary when trying these with minutes and hours, and it
doesn't work at all for months.

   Strictly speaking, the year should also be specified in a form
consistent with localtime(), i.e. the offset from 1900.  In order to make
the interpretation of the year easier for humans, however, who are more
accustomed to seeing years as two-digit or four-digit values, the
following conventions are followed:

   * Years greater than 999 are interpreted as being the actual year,
     rather than the offset from 1900.  Thus, 1963 would indicate the year
     Martin Luther King won the Nobel prize, not the year 2863.

   * Years in the range 100..999 are interpreted as offset from 1900, so
     that 112 indicates 2012.  This rule also applies to years less than
     zero (but see note below regarding date range).

   * Years in the range 0..99 are interpreted as shorthand for years in the
     rolling "current century," defined as 50 years on either side of the
     current year.  Thus, today, in 1999, 0 would refer to 2000, and 45 to
     2045, but 55 would refer to 1955.  Twenty years from now, 55 would
     instead refer to 2055.  This is messy, but matches the way people
     currently think about two digit dates.  Whenever possible, use an
     absolute four digit year instead.

   The scheme above allows interpretation of a wide range of dates,
particularly if 4-digit years are used.

   Please note, however, that the range of dates that can be actually be
handled depends on the size of an integer (time_t) on a given platform.
Currently, this is 32 bits for most systems, yielding an approximate range
from Dec 1901 to Jan 2038.

   Both timelocal() and timegm() croak if given dates outside the supported
range.

IMPLEMENTATION
==============

   These routines are quite efficient and yet are always guaranteed to
agree with localtime() and gmtime().  We manage this by caching the start
times of any months we've seen before.  If we know the start time of the
month, we can always calculate any time within the month.  The start times
themselves are guessed by successive approximation starting at the current
time, since most dates seen in practice are close to the current date.
Unlike algorithms that do a binary search (calling gmtime once for each
bit of the time value, resulting in 32 calls), this algorithm calls it at
most 6 times, and usually only once or twice.  If you hit the month cache,
of course, it doesn't call it at all.

   timelocal() is implemented using the same cache.  We just assume that
we're translating a GMT time, and then fudge it when we're done for the
timezone and daylight savings arguments.  Note that the timezone is
evaluated for each date because countries occasionally change their
official timezones.  Assuming that localtime() corrects for these changes,
this routine will also be correct.  The daylight savings offset is
currently assumed to be one hour.

BUGS
====

   The whole scheme for interpreting two-digit years can be considered a
bug.

   Note that the cache currently handles only years from 1900 through 2155.

   The proclivity to croak() is probably a bug.


File: pm.info,  Node: Time/Object,  Next: Time/ParseDate,  Prev: Time/Local,  Up: Module List

Object Oriented time objects
****************************

NAME
====

   Time::Object - Object Oriented time objects

SYNOPSIS
========

     use Time::Object;
     
     my $t = localtime;
     print "Time is $t\n";
     print "Year is ", $t->year, "\n";

DESCRIPTION
===========

   This module replaces the standard localtime and gmtime functions with
implementations that return objects. It does so in a backwards compatible
manner, so that using localtime/gmtime in the way documented in perlfunc
will still return what you expect.

   The module actually implements most of an interface described by Larry
Wall on the perl5-porters mailing list here:
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html

USAGE
=====

   After importing this module, when you use localtime or gmtime in a
scalar context, rather than getting an ordinary scalar string representing
the date and time, you get a Time::Object object, whose stringification
happens to produce the same effect as the localtime and gmtime functions.
There is also a new() constructor provided, which is the same as
localtime(), except when passed a Time::Object object, in which case it's
a copy constructor. The following methods are available on the object:

     $t->sec               # also available as $t->second
     $t->min               # also available as $t->minute
     $t->hour
     $t->mday              # also available as $t->day_of_month
     $t->mon               # based at 1
     $t->_mon              # based at 0
     $t->monname           # February
     $t->month             # same as $t->monname
     $t->year              # based at 0 (year 0 AD is, of course 1 BC).
     $t->_year             # year minus 1900
     $t->yr                # 2 digit year
     $t->wday              # based at 1 = Sunday
     $t->_wday             # based at 0 = Sunday
     $t->day_of_week       # based at 0 = Sunday
     $t->wdayname          # Tuesday
     $t->day               # same as wdayname
     $t->yday              # also available as $t->day_of_year
     $t->isdst             # also available as $t->daylight_savings
     $t->hms               # 01:23:45
     $t->ymd               # 2000/02/29
     $t->mdy               # 02/29/2000
     $t->dmy               # 29/02/2000
     $t->date              # Tue Feb 29 01:23:45 2000
     "$t"                  # same as $t->date
     $t->epoch             # seconds since the epoch
     $t->tzoffset          # timezone offset in a Time::Seconds object
     $t->strftime(FORMAT)  # same as POSIX::strftime (without POSIX.pm)

Date Calculations
-----------------

   It's possible to use simple addition and subtraction of objects:

     use Time::Seconds;
     
     	my $seconds = $t1 - $t2;
     	$t1 += ONE_DAY; # add 1 day (constant from Time::Seconds)

   The following are valid ($t1 and $t2 are Time::Object objects):

     $t1 - $t2; # returns Time::Seconds object
     $t1 - 42; # returns Time::Object object
     $t1 + 533; # returns Time::Object object

   However adding a Time::Object object to another Time::Object object
will cause a runtime error.

   Note that the first of the above returns a Time::Seconds object, so
while examining the object will print the number of seconds (because of
the overloading), you can also get the number of minutes, hours, days,
weeks and years in that delta, using the Time::Seconds API.

Date Comparisons
----------------

   Date comparisons are also possible, using the full suite of "<", ">",
"<=", ">=", "<=>", "==" and "!=".

Global Overriding
-----------------

   Finally, it's possible to override localtime and gmtime everywhere, by
including the 'overrideGlobally' tag in the import list:

     use Time::Object 'overrideGlobally';

   I'm not too keen on this name yet - suggestions welcome...

AUTHOR
======

   Matt Sergeant, matt@sergeant.org

License
-------

   This module is free software, you may distribute it under the same terms
as Perl.

Bugs
----

   The test harness leaves much to be desired. Patches welcome.


File: pm.info,  Node: Time/ParseDate,  Next: Time/Period,  Prev: Time/Object,  Up: Module List

date parsing both relative and absolute
***************************************

NAME
====

   Time::ParseDate - date parsing both relative and absolute

SYNOPSIS
========

     use Time::ParseDate;
     $seconds_since_jan1_1970 = parsedate("12/11/94 2pm", NO_RELATIVE => 1)
     $seconds_since_jan1_1970 = parsedate("12/11/94 2pm", %options)

OPTIONS
=======

   Date parsing can also use options.  The options are as follows:

     FUZZY	-> it's okay not to parse the entire date string
     NOW	-> the "current" time for relative times (defaults to time())
     ZONE	-> local timezone (defaults to $ENV{TZ})
     WHOLE	-> the whole input string must be parsed
     GMT	-> input time is assumed to be GMT, not localtime
     UK	-> prefer UK style dates (dd/mm over mm/dd)
     DATE_REQUIRED -> do not default the date
     TIME_REQUIRED -> do not default the time
     NO_RELATIVE -> input time is not relative to NOW
     TIMEFIRST -> try parsing time before date [not default]
     PREFER_PAST -> when year or day of week is ambigueous, assume past
     PREFER_FUTURE -> when year or day of week is ambigueous, assume future
     SUBSECOND -> parse fraction seconds
     VALIDATE -> only accept normal values for HHMMSS, YYMMDD.  Otherwise
     	days like -1 might give the last day of the previous month.

DATE FORMATS RECOGNIZED
=======================

Absolute date formats
---------------------

     Dow, dd Mon yy
     Dow, dd Mon yyyy
     Dow, dd Mon
     dd Mon yy
     dd Mon yyyy
     Month day{st,nd,rd,th}, year
     Month day{st,nd,rd,th}
     Mon dd yyyy
     yyyy/mm/dd
     yyyy/mm
     mm/dd/yy
     mm/dd/yyyy
     mm/yy
     yy/mm      (only if year > 12, or > 31 if UK)
     yy/mm/dd   (only if year > 12 and day < 32, or year > 31 if UK)
     dd/mm/yy   (only if UK, or an invalid mm/dd/yy or yy/mm/dd)
     dd/mm/yyyy (only if UK, or an invalid mm/dd/yyyy)
     dd/mm      (only if UK, or an invalid mm/dd)

Relative date formats:
----------------------

     count "days"
     count "weeks"
     count "months"
     count "years"
     Dow "after next"
     Dow 			(requires PREFER_PAST or PREFER_FUTURE)
     "next" Dow
     "tomorrow"
     "today"
     "yesterday"
     "last" dow
     "last week"
     "now"
     "now" "+" count units
     "now" "-" count units
     "+" count units
     "-" count units

Absolute time formats:
----------------------

     hh:mm:ss[.ddd]
     hh:mm
     hh:mm[AP]M
     hh[AP]M
     hhmmss[[AP]M]
     "noon"
     "midnight"

Relative time formats:
----------------------

     count "minuts"
     count "seconds"
     count "hours"
     "+" count units
     "+" count
     "-" count units
     "-" count

Timezone formats:
-----------------

     [+-]dddd
     GMT[+-]d+
     [+-]dddd (TZN)
     TZN

Special formats:
----------------

     [ d]d/Mon/yyyy:hh:mm:ss [[+-]dddd]
     yy/mm/dd.hh:mm

DESCRIPTION
===========

   This module recognizes the above date/time formats.   Usually a date
and a time are specified.  There are numerous options for controlling what
is recognized and what is not.

   The return code is always the time in seconds since January 1st, 1970
or undef if it was unable to parse the time.

   If a timezone is specified it must be after the time.  Year
specifications can be tacked onto the end of absolute times.

   If `parsedate()' is called from array contect, then it will return two
elements.  On sucessful parses, it will return the seconds and what
remains of its input string.  On unsucessful parses, it will return undef
and an error string.

EXAMPLES
========

     $seconds = parsedate("Mon Jan  2 04:24:27 1995");
     $seconds = parsedate("Tue Apr 4 00:22:12 PDT 1995");
     $seconds = parsedate("04.04.95 00:22", ZONE => PDT);
     $seconds = parsedate("Jan 1 1999 11:23:34.578", SUBSECOND => 1);
     $seconds = parsedate("122212 950404", ZONE => PDT, TIMEFIRST => 1);
     $seconds = parsedate("+3 secs", NOW => 796978800);
     $seconds = parsedate("2 months", NOW => 796720932);
     $seconds = parsedate("last Tuesday");

     ($seconds, $remaining) = parsedate("today is the day");
     ($seconds, $error) = parsedate("today is", WHOLE=>1);

AUTHOR
======

   David Muir Sharnoff <muir@idiom.com>.  Copyright (C) 1996-1999 All
Rights Reserved.  Use and redistribution allowed at user's own risk.


File: pm.info,  Node: Time/Period,  Next: Time/Seconds,  Prev: Time/ParseDate,  Up: Module List

A Perl module to deal with time periods.
****************************************

NAME
====

   Time::Period - A Perl module to deal with time periods.

SYNOPSIS
========

   `use Time::Period;'

   `$result = inPeriod($time, $period);'

DESCRIPTION
===========

   The *inPeriod* function determines if a given time falls within a given
period.  *inPeriod* returns 1 if the time does fall within the given
period, 0 if not, and *-1* if *inPeriod* detects a malformed time or
period.

   The time is specified as per the `time()' function, which is assumed to
be the number of non-leap seconds since January 1, 1970.

   The period is specified as a string which adheres to the format

     sub-period[, sub-period...]

   or the string "none" or whitespace.  The string "none" is not case
sensitive.

   If the period is blank, then any time period is assumed because the time
period has not been restricted.  In that case, *inPeriod* returns 1.  If
the period is "none", then no time period applies and *inPeriod* returns 0.

   A sub-period is of the form

     scale {range [range ...]} [scale {range [range ...]}]

   Scale must be one of nine different scales (or their equivalent codes):

     Scale  | Scale | Valid Range Values
            | Code  |
     *******|*******|************************************************
     year   |  yr   | n     where n is an integer 0<=n<=99 or n>=1970
     month  |  mo   | 1-12  or  jan, feb, mar, apr, may, jun, jul,
            |       |           aug, sep, oct, nov, dec
     week   |  wk   | 1-6
     yday   |  yd   | 1-365
     mday   |  md   | 1-31
     wday   |  wd   | 1-7   or  su, mo, tu, we, th, fr, sa
     hour   |  hr   | 0-23  or  12am 1am-11am 12noon 12pm 1pm-11pm
     minute |  min  | 0-59
     second |  sec  | 0-59

   The same scale type may be specified multiple times.  Additional scales
simply extend the range defined by previous scales of the same type.

   The range for a given scale must be a valid value in the form of

     v

   or

     v-v

   For the range specification v-v, if the second value is larger than the
first value, the range wraps around unless the scale specification is year.

   Year does not wrap because the year is never really reset, it just
increments.  Ignoring that fact has lead to the dreaded year 2000
nightmare.  When the year rolls over from 99 to 00, it has really rolled
over a century, not gone back a century.  *inPeriod* supports the
dangerous two digit year notation because it is so rampant.  However,
*inPeriod* converts the two digit notation to four digits by prepending
the first two digits from the current year.  In the case of 99-1972, the
99 is translated to whatever current century it is (probably 20th), and
then range 99-1972 is treated as 1972-1999.  If it were the 21st century,
then the range would be 1972-2099.

   Anyway, if v-v is 9-2 and the scale is month, September, October,
November, December, January, and February are the months that the range
specifies.  If v-v is 2-9, then the valid months are February, March,
April, May, Jun, July, August, and September.  9-2 is the same as Sep-Feb.

   v isn't a point in time.  In the context of the hour scale, 9 specifies
the time period from 9:00:00 am to 9:59:59 am.  This is what most people
would call 9-10.  In other words, v is discrete in its time scale.  9
changes to 10 when 9:59:59 changes to 10:00:00, but it is 9 from 9:00:00
to 9:59:59.  Just before 9:00:00, v was 8.

   Note that whitespace can be anywhere and case is not important.  Note
also that scales must be specified either in long form (year, month, week,
etc.) or in code form (yr, mo, wk, etc.).  Scale forms may be mixed in a
period statement.

   Furthermore, when using letters to specify ranges, only the first two
for week days or the first three for months are significant.  January is a
valid specification for jan, and Sunday is a valid specification for su.
Sun is also valid for su.

PERIOD EXAMPLES
---------------

   To specify a time period from Monday through Friday, 9am to 5pm, use a
period such as

     wd {Mon-Fri} hr {9am-4pm}

   When specifing a range by using -, it is best to think of - as meaning
through.  It is 9am through 4pm, which is just before 5pm.

   To specify a time period from Monday through Friday, 9am to 5pm on
Monday, Wednesday, and Friday, and 9am to 3pm on Tuesday and Thursday, use
a period such as

     wd {Mon Wed Fri} hr {9am-4pm}, wd{Tue Thu} hr {9am-2pm}

   To specify a time period that extends Mon-Fri 9am-5pm, but alternates
weeks in a month, use a period such as

     wk {1 3 5} wd {Mon Wed Fri} hr {9am-4pm}

   Or how about a period that specifies winter?

     mo {Nov-Feb}

   This is equivalent to the previous example:

     mo {Jan-Feb Nov-Dec}

   As is

     mo {jan feb nov dec}

   And this is too:

     mo {Jan Feb}, mo {Nov Dec}

   Wait!  So is this:

     mo {Jan Feb} mo {Nov Dec}

   To specify a period that describes every other half-hour, use something
like

     minute { 0-29 }

   To specify the morning, use

     hour { 12am-11am }

   Remember, 11am is not 11:00:00am, but rather 11:00:00am - 11:59:59am.

   Hmmmm, 5 second blocks could be a fun period...

     sec {0-4 10-14 20-24 30-34 40-44 50-54}

   To specify every first half-hour on alternating week days, and the
second half-hour the rest of the week, use the period

     wd {1 3 5 7} min {0-29}, wd {2 4 6} min {30-59}

VERSION
=======

   1.20

HISTORY
=======

     Version 1.20
     ------------
     	- Added the ability to specify no time period.

     Version 1.13
     ------------
     	- Cleaned up the error checking code.

     Version 1.12
     ------------
     	- Updated email and web space information.

     Version 1.11
     ------------
     	- Minor bug fix in 1.10.

     Version 1.10
     ------------
     	- Released.

AUTHOR
======

   Patrick Ryan <pgryan@geocities.com>

COPYRIGHT
=========

   Copyright (c) 1997 Patrick Ryan.  All rights reserved.  This Perl module
uses the conditions given by Perl.  This module may only be distributed
and or modified under the conditions given by Perl.

DATE
====

   August 26, 1997

SOURCE
======

   This distribution can be found at

     http://www.geocities.com/SiliconValley/Lakes/8456/

   or

     http://www.perl.com/CPAN/modules/by-module/Time/


File: pm.info,  Node: Time/Seconds,  Next: Time/SoFar,  Prev: Time/Period,  Up: Module List

a simple API to convert seconds to other date values
****************************************************

NAME
====

   Time::Seconds - a simple API to convert seconds to other date values

SYNOPSIS
========

     use Time::Object;
     use Time::Seconds;
     
     my $t = localtime;
     $t += ONE_DAY;
     
     my $t2 = localtime;
     my $s = $t - $t2;
     
     print "Difference is: ", $s->days, "\n";

DESCRIPTION
===========

   This module is part of the Time::Object distribution. It allows the user
to find out the number of minutes, hours, days, weeks or years in a given
number of seconds. It is returned by Time::Object when you delta two
Time::Object objects.

   Time::Seconds also exports the following constants:

     ONE_DAY
     ONE_WEEK
     ONE_HOUR
     ONE_MINUTE
     	ONE_MONTH
     	ONE_YEAR
     	ONE_FINANCIAL_MONTH
     LEAP_YEAR
     NON_LEAP_YEAR

   Since perl does not (yet?) support constant objects, these constants
are in seconds only, so you cannot, for example, do this: `print
ONE_WEEK->minutes;'

METHODS
=======

   The following methods are available:

     my $val = Time::Seconds->new(SECONDS)
     $val->seconds;
     $val->minutes;
     $val->hours;
     $val->days;
     $val->weeks;
     	$val->months;
     	$val->financial_months; # 30 days
     $val->years;

   The methods make the assumption that there are 24 hours in a day, 7
days in a week, 365.24225 days in a year and 12 months in a year.  (from
The Calendar FAQ at http://www.tondering.dk/claus/calendar.html)

AUTHOR
======

   Matt Sergeant, matt@sergeant.org

   Tobias Brox, tobiasb@tobiasb.funcom.com

LICENSE
=======

   Please see Time::Object for the license.

Bugs
====

   Currently the methods aren't as efficient as they could be, for reasons
of clarity. This is probably a bad idea.


File: pm.info,  Node: Time/SoFar,  Next: Time/Stopwatch,  Prev: Time/Seconds,  Up: Module List

Perl module to calculate run time
*********************************

NAME
====

   Time::SoFar - Perl module to calculate run time

SYNOPSIS
========

     use Time::SoFar qw( runtime runinterval figuretimes );

     # [...] denotes optional arguments
     $times = runtime( [$no_optimize] );
     @times = runtime( [$no_optimize] );

     $times = runinterval( [$no_optimize] );
     @times = runinterval( [$no_optimize] );

     $times = figuretimes( $seconds [, $no_optimize] );
     @times = figuretimes( $seconds [, $no_optimize] );

SAMPLES
=======

     my $elapsed = runtime();
     print "Elapsed time $elapsed\n";
     # prints, eg, "Elapsed time 17:34\n"

     my $sincethen = runinterval(1);
     print "Time since then $sincethen\n";
     # prints, eg, "Time since then 0:00:00:51\n"

     ($day, $hour, $min, $sec) = figuretimes(86400 + 2*3600 + 3*60 + 4, 1);
     # $day = 1; $hour = 2; $min = 3; $sec = 4;
     
     @times = figuretimes(2*3600 + 3*60 + 4);
     # @times = (2, 3, 4)
     
     @times = figuretimes(17,1);
     # @times = (0, 0, 0, 17)
     
     $times = figuretimes(2*3600 + 3*60 + 4, 1);
     # $times = '0:02:03:04';

DESCRIPTION
===========

   *Time::SoFar* has two functions for calculating how long a script has
been running. `runtime()' always works from the time the script was
started (using $^T). `runinterval()' works from the last time `runtime()'
or `runinterval()' was called (or since the start of the script).

   Both `runtime()' and `runinterval()' use `figuretimes()' to render a
raw number of seconds into component time units. Both take an optional
boolean argument that gets passed to `figuretimes()' to influence its
output.

   In an array context `figuretimes()' returns the timecomponents as an
array, in a scalar context it returns those components as a : delimited
string. The default behaviour is to optimize away 0 output from the longer
period end of the output, leaving a minimum of minutes:seconds. This is
good for arrays that will be passed to `join()', but not so good for a
list of variables, so this behaviour can be disabled by using a true value
for *$no_optimize*.

INHERITANCE
===========

   Time::SoFar inherits only from Exporter.

CAVEATS
=======

   Time::SoFar has a granularity of seconds, and is therefore not so
useful for small elapsed times.

PREREQUISITES
=============

   Only stock perl modules are used.

OSNAMES
=======

   So long as $^T and `time()' are calculated using the same epoch there
should be no operating system dependence.

SEE ALSO
========

   $^T in *Note Perlvar: (perl.info)perlvar,.

COPYRIGHT
=========

   Copyright 2000 by Eli the Bearded / Benjamin Elijah Griffin.  Released
under the same license(s) as Perl.

AUTHOR
======

   Eli the Bearded wrote this to do away with all the $^T one liners at
the end of his batch processing scripts.


File: pm.info,  Node: Time/Stopwatch,  Next: Time/Storable,  Prev: Time/SoFar,  Up: Module List

Use tied scalars as timers
**************************

NAME
====

   Time::Stopwatch - Use tied scalars as timers

SYNOPSIS
========

     use Time::Stopwatch;
     tie my $timer, 'Time::Stopwatch';

     do_something();
     print "Did something in $timer seconds.\n";

     my @times = map {
         $timer = 0;
         do_something_else();
         $timer;
     } 1 .. 5;

DESCRIPTION
===========

   The `Time::Stopwatch' module provides a convenient interface to timing
functions through tied scalars.  From the point of view of the user,
scalars tied to the module simply increase their value by one every second.

   Using the module should mostly be obvious from the synopsis.  You can
provide an initial value for the timers either by assigning to them or by
passing the value as a third argument to tie().

   If you have the module `Time::HiRes' installed, the timers created by
`Time::Stopwatch' will automatically count fractional seconds.  Do not
assume that the values of the timers are always integers.  You may test
the constant `Time::Stopwatch::HIRES' to find out whether high resolution
timing is enabled.

CHANGE LOG
==========

  1. (27 Feb 2001) Modified tests to give more information, reduced
     subsecond accuracy test to 1/10 seconds to allow for inaccurate
     select() implementations.  Tweaked synopsis and README.


SEE ALSO
========

   `Time::HiRes', tie()

AUTHORS
=======

   Copyright 2000-2001, Ilmari Karonen.  All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   Address bug reports and comments to: perl@itz.pp.sci.fi


File: pm.info,  Node: Time/Storable,  Next: Time/Timezone,  Prev: Time/Stopwatch,  Up: Module List

Store times in a portable format
********************************

NAME
====

   Time::Storable - Store times in a portable format

SYNOPSIS
========

     use Time::Storable;

DESCRIPTION
===========

   The idea is to provide some format for storing dates - particularly
dates that fall outside of the epoch - that is, either before 1970, or
after 2038. This is a combination of Time::JulianDay type dates, and
regular epoch time type time stamps.

   The time is stored in a single format, rather than in two numbers, for
simplicity of putting this in a database. This module provides a full set
of tools for getting useful information out of this time storage format,
so that it is not a burden to put it in this format.

   The time format used here is just experimental. I'm not sure if this is
the best way do to things or not. It's susceptible to rounding error if
you treat it like a number. But the whole point of making it look like a
number was specifically so that you can put it in numerical database
fields, rather than having to put it in a string field.

   Please let me know what you think about this, and I'll incorporate
ideas into the next version.

   Eventually there will be convenient ways to get seconds, minutes,
hours, days, months, years out of a Time::Storable string. Perhaps even
this evening.

AUTHOR
======

   Rich Bowen <rbowen@rcbowen.com>

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Time/Timezone,  Next: Time/Unix,  Prev: Time/Storable,  Up: Module List

miscellaneous timezone manipulations routines
*********************************************

NAME
====

   Time::Timezone - miscellaneous timezone manipulations routines

SYNOPSIS
========

     use Time::Timezone;
     print tz2zone();
     print tz2zone($ENV{'TZ'});
     print tz2zone($ENV{'TZ'}, time());
     print tz2zone($ENV{'TZ'}, undef, $isdst);
     $offset = tz_local_offset();
     $offset = tz_offset($TZ);

DESCRIPTION
===========

   This is a collection of miscellaneous timezone manipulation routines.

   `tz2zone()' parses the TZ environment variable and returns a timezone
string suitable for inclusion in `date' in this node-like output.  It
opionally takes a timezone string, a time, and a is-dst flag.

   `tz_local_offset()' determins the offset from GMT time in seconds.  It
only does the calculation once.

   `tz_offset()' determines the offset from GMT in seconds of a specified
timezone.

   `tz_name()' determines the name of the timezone based on its offset

AUTHORS
=======

   Graham Barr <bodg@tiuk.ti.com> David Muir Sharnoff <muir@idiom.com>
Paul Foley <paul@ascent.com>


File: pm.info,  Node: Time/Unix,  Next: Time/Warp,  Prev: Time/Timezone,  Up: Module List

Force time() to return seconds since UNIX epoch
***********************************************

NAME
====

   Time::Unix - Force time() to return seconds since UNIX epoch

SYNOPSIS
========

     use Time::Unix;     # time() now returns UNIX epoch seconds

DESCRIPTION
===========

   This module does one thing: It imports a new version of time() that
returns seconds since the UNIX epoch on ALL platforms.  It is intended
mainly as a proof-of-concept for the below Perl 6 RFC.

   In addition to importing a time() function, it also imports a systime()
function which gives you direct access to the system's native epoch (i.e.,
what time() would return if you hadn't used this module).

   This doesn't do anything useful on UNIX platforms, so don't do that.

REFERENCES
==========

   See http://dev.perl.org/rfc/99.html for a complete description.

AUTHOR
======

   Copyright (c) 2000, Nathan Wiger <nate@sun.com>. All Rights Reserved.

   This module is free software; you may copy this under the terms of the
GNU General Public License, or the Artistic License, copies of which
should have accompanied your Perl kit.


File: pm.info,  Node: Time/Warp,  Next: Time/Zone,  Prev: Time/Unix,  Up: Module List

control over the flow of time
*****************************

NAME
====

   Time::Warp - control over the flow of time

SYNOPSIS
========

     use Time::Warp qw(scale to time);

     to(time + 5);  # 5 seconds ahead
     scale(2);      # make time flow twice normal

DESCRIPTION
===========

   Our external experience unfolds in 3 1/2 dimensions (time has a
dimensionality of 1/2).  The Time::Warp module offers developers control
over the measurement of time.

API
===

   * to($desired_time)

     The theory of relativity asserts that all physical laws are enforced
     relative to the observer.  Since the starting point of time is
     arbitrary, it is permissable to change it.  This has the effect of
     making it appear as if time is moving forwards or backward
     instanteously.  For example, on some types of operating systems time
     starts at Wed Dec 31 19:00:00 1969 (this will likely change as we
     approach 2030 and with the acceptance of 64-bit CPUs).

          to(time + 60*60);       # 1 hour ahead

   * scale($factor)

     Changes the speed at which time is progressing.

          scale(scale * 2);   # double the speed of time

     Note that it is not possible to stop time or cause it to reverse since
     this is forbidden by the second law of thermodynamics.

ALSO SEE
========

   *Note Time/HiRes: Time/HiRes, and *Note Event: Event,.

SUPPORT
=======

   Please direct your insights or complaints to perl-loop@perl.org.

DISCLAIMER
==========

   THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THIS IS NOT A TIME
MACHINE.  THIS MODULE CANNOT BE USED TO VIOLATE THE SECOND LAW OF
THERMODYNAMICS.

COPYRIGHT
=========

   Copyright  1999, 2000 Joshua Nathaniel Pritikin.  All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


