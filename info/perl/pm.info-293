This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: PDL/Slices,  Next: PDL/Tests,  Prev: PDL/Slatec,  Up: Module List

Stupid index tricks
*******************

NAME
====

   PDL::Slices - Stupid index tricks

SYNOPSIS
========

     use PDL;
     $a = ones(3,3);
     $b = $a->slice('-1:0,(1)');
     $c = $a->dummy(2);

DESCRIPTION
===========

   This package provides many of the powerful PerlDL core index
manipulation routines. These routines are usually two-way so you can get a
unit matrix by

     $a = zeroes(1000,1000);
     $a->diagonal(0,1) ++;

   which is usually fairly efficient. See *Note PDL/Indexing:
PDL/Indexing, and *Note PDL/Tips: PDL/Tips, for more examples.

   These functions are usually two-way:

     $b = $a->slice("1:3");
     $b += 5;   		# $a is changed!

   If you want to force a copy and no "flow" backwards, you need

     $b = $a->slice("1:3")->copy;
     $b += 5;		# $a is not changed.

   alternatively, you can use

     $b = $a->slice("1:3")->sever;

   which does not copy the struct but beware that after

     $b = $a->slice("1:3");
     $c = $b->sever;

   the variables $b and $c point to the same object but with `->copy' they
do not.

   The fact that there is this kind of flow makes PDL a very powerful
language in many ways: since you can alter the original data by altering
some easier-to-use representation of it, many things are much easier to
accomplish, just like making the above unit matrix.

FUNCTIONS
=========

index
-----

   It would be useful to have a more complete function for this at some
point, or at least a perl wrapper, that allows

     $c = $a->islice("1:2",$ind1,"3:4",$ind2);

   with many dimensions.

   This function is two-way, i.e. after

     $c = $a->index(pdl[0,5,8]);
     $c .= pdl [0,2,4];

   the changes in $c will flow back to `$a'.

index2d
-------

   It would be useful to have a more complete function for this at some
point, or at least a perl wrapper, that allows

     $c = $a->islice("1:2",$ind1,"3:4",$ind2);

   with many dimensions.

   This function is two-way, i.e. after

     $c = $a->index(pdl[0,5,8]);
     $c .= pdl [0,2,4];

   the changes in $c will flow back to `$a'.

rld
---

   Given a vector `$a' of the numbers of instances of values $b, run-length
decode to $c.

rle
---

   Given vector $c, generate a vector `$a' with the number of each element,
and a vector $b of the unique values.  Only the elements up to the first
instance of `0' in `$a' should be considered.

clump
-----

   If, for example, `$a' has dimensions `(5,3,4)' then after

   the variable $b will have dimensions `(15,4)' and the element
`$b->at(7,3)' refers to the element `$a->at(1,2,3)'.

   Use `clump(-1)' to flatten a piddle. The method `flat|PDL::Core' in
this node is provided as an alias for this functionality.

xchg
----

   Negative dimension indices count from the end.

   The command

   creates $b to be like `$a' except that the dimensions 2 and 3 are
exchanged with each other i.e.

     $b->at(5,3,2,8) == $a->at(5,3,8,2)

reorder
-------

   Similar to the `xchg|' in this node method, this method re-orders the
dimensions of a PDL. While the `xchg|' in this node method swaps the
position of two dimensions, the reorder method can change the positions of
many dimensions at once.

   The argument to reorder is an array representing where the current
dimensions should go in the new array. In the above usage, the argument to
reorder `(5,4,3,2,1,0)' indicates that the old dimensions (`$pdl''s dims)
should be re-arranged to make the new pdl (`$reOrderPDL') according to the
following:

     Old Position   New Position
     ------------   ------------
     5              0
     4              1
     3 		  2
     2		  3
     1		  4
     0		  5

     perldl> $a = sequence(5,3,2);	  # Create a 3-d Array
     perldl> p $a
     [
      [
       [ 0  1  2  3  4]
       [ 5  6  7  8  9]
       [10 11 12 13 14]
      ]
      [
       [15 16 17 18 19]
       [20 21 22 23 24]
       [25 26 27 28 29]
      ]
     ]
     perldl> p $a->reorder(2,1,0); # Reverse the order of the 3-D PDL
     [
      [
       [ 0 15]
       [ 5 20]
       [10 25]
      ]
      [
       [ 1 16]
       [ 6 21]
       [11 26]
      ]
      [
       [ 2 17]
       [ 7 22]
       [12 27]
      ]
      [
       [ 3 18]
       [ 8 23]
       [13 28]
      ]
      [
       [ 4 19]
       [ 9 24]
       [14 29]
      ]
     ]

   The above is a simple example that could be duplicated by calling
`$a->xchg(0,2)', but it demonstrates the basic functionality of reorder.

   As this is an index function, any modifications to the result PDL will
change the parent.

mv
--

   The command

   creates $b to be like `$a' except that the dimension 4 is moved to the
place 1, so:

     $b->at(1,2,3,4,5,6) == $a->at(1,5,2,3,4,6);

   The other dimensions are moved accordingly.  Negative dimension indices
count from the end.

oneslice
--------

   This is not for public use currently. See the source if you have to.
This function can be used to accomplish run-time changing of
transformations i.e. changing the size of some piddle at run-time.

   However, the mechanism is not yet finalized and this is just a
demonstration.

slice
-----

   The argument string is a comma-separated list of what to do for each
dimension. The current formats include the following, where a, b and c are
integers and can take legal array index values (including -1 etc):

:
     takes the whole dimension intact.

"
     (nothing) is a synonym for ":" (This means that `$a->slice(':,3')' is
     equal to `$a->slice(',3')').

a
     slices only this value out of the corresponding dimension.

(a)
     means the same as "a" by itself except that the resulting dimension
     of length one is deleted (so if `$a' has dims `(3,4,5)' then
     `$a->slice(':,(2),:')' has dimensions `(3,5)' whereas
     `$a->slice(':,2,:')' has dimensions `(3,1,5))'.

a:b
     slices the range a to b inclusive out of the dimension.

a:b:c
     slices the range a to b, with step c (i.e. `3:7:2' gives the indices
     `(3,5,7)'). This may be confusing to Matlab users but several other
     packages already use this syntax.


     inserts an extra dimension of width 1 and


     inserts an extra (dummy) dimension of width a.

   An extension is planned for a later stage allowing
`$a->slice('(=1),(=1|5:8),3:6(=1),4:6')' to express a multidimensional
diagonal of `$a'.

using
-----

   Plot, as a line, column 1 of `$pdl' vs. column 2

diagonalI
---------

   The diagonal is placed at the first (by number) dimension that is
diagonalized.  The other diagonalized dimensions are removed. So if `$a'
has dimensions `(5,3,5,4,6,5)' then after

   the piddle $b has dimensions `(5,3,4,6)' and `$b->at(2,1,0,1)' refers
to `$a->at(2,1,2,0,1,2)'.

   NOTE: diagonal doesn't handle threadids correctly. XXX FIX

lags
----

   I.e. if `$a' contains

     [0,1,2,3,4,5,6,7]

   then

   is a (5,2) matrix

     [2,3,4,5,6,7]
     [0,1,2,3,4,5]

   This order of returned indices is kept because the function is called
"lags" i.e. the nth lag is n steps behind the original.

splitdim
--------

   After

   the expression

     $b->at(6,4,x,y,3,6) == $a->at(6,4,x+3*y)

   is always true (x has to be less than 3).

rotate
------

threadI
-------

   Put some dimensions to a threadid.

identvaff
---------

   Mainly for internal use.

unthread
--------

   See [TBD Doc] for details and examples.

dice
----

   This function can be used to extract irregular subsets along many
dimension of a PDL, e.g. only certain rows in an image, or planes in a
cube. This can of course be done with the usual dimension tricks but this
saves having to figure it out each time!

   This method is similar in functionality to the `slice|' in this node
method, but `slice|' in this node requires that contiguous ranges or ranges
with constant offset be extracted. ( i.e. `slice|' in this node requires
ranges of the form `1,2,3,4,5' or `2,4,6,8,10'). Because of this
restriction, `slice|' in this node is more memory efficient and slightly
faster than dice

   The arguments to dice are arrays (or 1D PDLs) for each dimension in the
PDL. These arrays are used as indexes to which rows/columns/cubes,etc to
dice-out (or extract) from the $data PDL.

   Use X to select all indices along a given dimension (compare also
`mslice|PDL::Core' in this node). As usual (in slicing methods) trailing
dimensions can be omitted implying X'es for those.

   As this is an index function, any modifications to the slice change the
parent (use the `.=' operator).

dice_axis
---------

   This function can be used to extract irregular subsets along any
dimension, e.g. only certain rows in an image, or planes in a cube. This
can of course be done with the usual dimension tricks but this saves
having to figure it out each time!

   The trick to using this is that the index selects elements along the
dimensions specified, so if you have a 2D image `axis=0' will select
certain X values - i.e. extract columns

   As this is an index function, any modifications to the slice change the
parent.

AUTHOR
======

   Copyright (C) 1997 Tuomas J. Lukka.  All rights reserved. There is no
warranty. You are allowed to redistribute this software / documentation
under certain conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution, the
copyright notice should be included in the file.


File: pm.info,  Node: PDL/Tests,  Next: PDL/Tips,  Prev: PDL/Slices,  Up: Module List

tests for some PP features
**************************

NAME
====

   PDL::Tests - tests for some PP features

SYNOPSIS
========

     use PDL::Tests;

     <test code>

DESCRIPTION
===========

   This module provides some PP defined test functions that are supposed
to test some features/bugs of PDL::PP.

   Strictly speaking this module shouldn't be installed with a 'make
install' but I haven't yet worked out how to do it.


File: pm.info,  Node: PDL/Tips,  Next: PDL/Types,  Prev: PDL/Tests,  Up: Module List

Small tidbits of useful arcana. Programming tidbits and such.
*************************************************************

NAME
====

   PDL::Tips - Small tidbits of useful arcana. Programming tidbits and
such.

SYNOPSIS
========

     use PDL;

     # Whatever happens here.

DESCRIPTION
===========

   This page documents useful idioms, helpful hints and tips for using
Perl Data Language v2.0.

Help
----

   Use `help help' within *perldl* or the `pdldoc' program from the
command line for access to the PerlDL documentation.  HTML versions of the
pages should also be present, in the `HtmlDocs/PDL' directory of the PDL
distribution. To find this directory, try the following

     perldl> foreach ( map{"$_/PDL/HtmlDocs"}@INC ) { p "$_\n" if -d $_ }

Indexing idioms
---------------

   The following code normalizes a bunch of vectors in $a.  This works
regardless of the dimensionality of $a.

     $a /= $a->sumover->dummy(0);

What is actually happening?
---------------------------

   If you want to see what the code is actually doing, try the command

     PDL::Core::set_debugging(1);

   somewhere. This spews out a huge amount of debug info for PDL into
STDOUT. It is planned to eventually make this redirectable and the
messages selectable more accurately.

   Many of the messages come from `Basic/Core/pdlapi.c' and you can look
at the source to see what is going on.

   If you have any extra time to work on these mechanisms, infrom the
pdl-porters mailing list.

Memory savings
--------------

   If you are running recursively something that selects certain indices
of a large piddle, like

     while(1) {
     	$inds = where($a>0);
     	$a = $a->index($inds);
     	$b = $b->index($inds);
     	func($b,$a);
     }

   If you are not writing to $b, it saves a lot of memory to change this to

     $b = $b->index($inds)->sever;

   The new method sever is a causes the write-back relation to be
forgotten. It is like copy except it changes the original piddle and
returns it).

   Of course, the probably best way to do the above is

     $inds = xvals ($a->long);
     while(1) {
     	$inds0 = where($a>0);
     	$inds1 = $inds->index($inds)->sever;
     	$a = $a0->index($inds1);
     	$b = $b->index($inds1)->sever;
     	func($b,$a);
     }

   which doesn't save all the temporary instances of $a in memory.  See
`mandel.pl' in the Demos subdirectory of the PerlDL distribution for an
example.

PP speed
--------

   If you really want to write speedy PP code, the first thing you need to
do is to make sure that your C compiler is allowed to do the necessary
optimizations.

   What this means is that you have to allow as many variables as possible
to go into registers:

     loop(a) %{
     	$a() += $COMP(foo_member) * $b()
     %}

   expands to

     for(i=0; i<10000; i++) {
     	a[i] += __privtrans->foo_member * b[i];
     }

   is about the worst you can do, since your C compiler is not allowed to
assume that a doesn't clobber `foo_member' which completely inhibits
vectorization. Instead, do

     float foo = $COMP(foo_member);
     loop(a) %{
     	$a() += foo * $b();
     %}

   This is not a restriction caused by PP but by ANSI C semantics.  Of
course, we could copy the struct into local varibles and back but that
could cause very strange things sometimes.

   There are many other issues on organizing loops.

   We are currently planning to make PP able to do fixed-width things as
well as physical piddles (where looping over the first dimensions would be
cheaper as there are less distinct increments, which might make a
difference on machines with a small number of registers).

AUTHOR
======

   Copyright (C) Tuomas J. Lukka 1997. All rights reserved.  Duplication
in the same form and printing a copy for yourself allowed.


File: pm.info,  Node: PDL/Types,  Next: PDL/Ufunc,  Prev: PDL/Tips,  Up: Module List

define fundamental PDL Datatypes
********************************

NAME
====

   PDL::Types - define fundamental PDL Datatypes

SYNOPSIS
========

     use PDL::Types;

     $pdl = ushort( 2.0, 3.0 );
     print "The actual c type used to store ushort's is '" .
        $pdl->type->realctype() . "'\n";
     The actual c type used to store ushort's is 'unsigned short'

DESCRIPTION
===========

   Internal module - holds all the PDL Type info.  This can be accessed
using the `PDL::Type' object returned by the `type|PDL::Core' in this node
method.

OBJECTS
=======

   This module contains one object - `PDL::Type' - that is returned by the
`type|PDL::Core' in this node method of a piddle.  It has several methods,
listed below, which provide an easy way to access type infotmation:

enum
     Returns the number representing this datatype (see
     `get_datatype|PDL::Core' in this node).

symbol
     Returns one of 'PDL_B', 'PDL_S', 'PDL_US', 'PDL_L', 'PDL_F' or
     'PDL_D'.

ctype
     Returns the macro used to represent this type in C code (eg
     'PDL_Long').

ppsym
     The letter used to represent this type in PP code code (eg 'U' for
     `ushort|PDL::Core' in this node).

realctype
     The actual C type used to store this type.

shortctype
     The value returned by ctype without the 'PDL_'.


File: pm.info,  Node: PDL/Ufunc,  Next: PDL/pdldoc,  Prev: PDL/Types,  Up: Module List

primitive ufunc operations for pdl
**********************************

NAME
====

   PDL::Ufunc - primitive ufunc operations for pdl

DESCRIPTION
===========

   This module provides some primitive and useful functions defined using
PDL::PP based on functionality of what are sometimes called *ufuncs* (for
example NumPY and Mathematica talk about these).  It collects all the
functions generally used to reduce or `accumulate' along a dimension.
These all do their job across the first dimension but by using the slicing
functions you can do it on any dimension.

   The `PDL::Reduce|PDL::Reduce' in this node module provides an
alternative interface to many of the functions in this module.

SYNOPSIS
========

     use PDL::Ufunc;

FUNCTIONS
=========

prodover
--------

   This function reduces the dimensionality of a piddle by one by taking
the product along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

dprodover
---------

   This function reduces the dimensionality of a piddle by one by taking
the product along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   Unlike `prodover|' in this node, the calculations are performed in
double precision.

cumuprodover
------------

   This function calculates the cumulative product along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   The sum is started so that the first element in the cumulative product
is the first element of the parameter.

dcumuprodover
-------------

   This function calculates the cumulative product along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   The sum is started so that the first element in the cumulative product
is the first element of the parameter.

   Unlike `cumuprodover|' in this node, the calculations are performed in
double precision.

sumover
-------

   This function reduces the dimensionality of a piddle by one by taking
the sum along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

dsumover
--------

   This function reduces the dimensionality of a piddle by one by taking
the sum along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   Unlike `sumover|' in this node, the calculations are performed in double
precision.

cumusumover
-----------

   This function calculates the cumulative sum along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   The sum is started so that the first element in the cumulative sum is
the first element of the parameter.

dcumusumover
------------

   This function calculates the cumulative sum along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   The sum is started so that the first element in the cumulative sum is
the first element of the parameter.

   Unlike `cumusumover|' in this node, the calculations are performed in
double precision.

andover
-------

   This function reduces the dimensionality of a piddle by one by taking
the and along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

zcover
------

   This function reduces the dimensionality of a piddle by one by taking
the == 0 along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

orover
------

   This function reduces the dimensionality of a piddle by one by taking
the or along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

borover
-------

   This function reduces the dimensionality of a piddle by one by taking
the bitwise or along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

bandover
--------

   This function reduces the dimensionality of a piddle by one by taking
the bitwise and along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

intover
-------

   This function reduces the dimensionality of a piddle by one by taking
the integral along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   Notes:

   For `n > 3', these are all `O(h^4)' (like Simpson's rule), but are
integrals between the end points assuming the pdl gives values just at
these centres: for such `functions', sumover is correct to `O(h)', but is
the natural (and correct) choice for binned data, of course.

average
-------

   This function reduces the dimensionality of a piddle by one by taking
the average along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

daverage
--------

   This function reduces the dimensionality of a piddle by one by taking
the average along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   Unlike `average|' in this node, the calculation is performed in double
precision.

medover
-------

   This function reduces the dimensionality of a piddle by one by taking
the median along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

oddmedover
----------

   This function reduces the dimensionality of a piddle by one by taking
the oddmedian along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

   The median is sometimes not a good choice as if the array has an even
number of elements it lies half-way between the two middle values - thus
it does not always correspond to a data value. The lower-odd median is
just the lower of these two values and so it ALWAYS sits on an actual data
value which is useful in some circumstances.

pctover
-------

   Project via percentile to N-1 dimensions

   This function reduces the dimensionality of a piddle by one by finding
the specified percentile (p) along the 1st dimension.  The specified
percentile must be between 0.0 and 1.0.  When the specified percentile
falls between data points, the result is interpolated.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

oddpctover
----------

   Project via percentile to N-1 dimensions

   This function reduces the dimensionality of a piddle by one by finding
the specified percentile along the 1st dimension.  The specified
percentile must be between 0.0 and 1.0.  When the specified percentile
falls between two values, the nearest data value is the result.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

pct
---

oddpct
------

avg
---

sum
---

prod
----

davg
----

dsum
----

dprod
-----

zcheck
------

and
---

band
----

or
--

bor
---

min
---

max
---

median
------

oddmedian
---------

any
---

   Useful in conditional expressions:

all
---

   Useful in conditional expressions:

minmax
------

   This routine does not thread over the dimensions of `$pdl'; it returns
the minimum and maximum values of the whole array.  See `minmaximum|' in
this node if this is not what is required.

qsort
-----

qsorti
------

minimum
-------

   This function reduces the dimensionality of a piddle by one by taking
the minimum along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

minimum_ind
-----------

minimum_n_ind
-------------

maximum
-------

   This function reduces the dimensionality of a piddle by one by taking
the maximum along the 1st dimension.

   By using `xchg|PDL::Slices' in this node etc. it is possible to use any
dimension.

maximum_ind
-----------

maximum_n_ind
-------------

minmaximum
----------

   See also `minmax|' in this node, which clumps the piddle together.

AUTHOR
======

   Copyright (C) Tuomas J. Lukka 1997 (lukka@husc.harvard.edu).
Contributions by Christian Soeller (c.soeller@auckland.ac.nz) and Karl
Glazebrook (kgb@aaoepp.aao.gov.au).  All rights reserved. There is no
warranty. You are allowed to redistribute this software / documentation
under certain conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution, the
copyright notice should be included in the file.


File: pm.info,  Node: PDL/pdldoc,  Next: PGP/Sign,  Prev: PDL/Ufunc,  Up: Module List


File: pm.info,  Node: PGP/Sign,  Next: PGPLOT,  Prev: PDL/pdldoc,  Up: Module List

Create detached PGP signatures for data, securely
*************************************************

NAME
====

   PGP::Sign - Create detached PGP signatures for data, securely

SYNOPSIS
========

     use PGP::Sign;
     ($signature, $version) = pgp_sign ($keyid, $passphrase, @data);
     $signer = pgp_verify ($signature, $version, @data);
     @errors = PGP::Sign::pgp_error;

DESCRIPTION
===========

   This module is designed to do one and only one thing securely and well;
namely, generate and check detached PGP signatures for some arbitrary data.
It doesn't do encryption, it doesn't manage keyrings, it doesn't verify
signatures, it just signs things.  This is ideal for applications like
PGPMoose or control message generation that just need a fast signing
mechanism.  It supports versions 2.6, 5.0, and 6.5.2 of PGP, as well as
GnuPG, and therefore supports any of the signature types understood by
those programs provided they are installed.

   The interface is very simple; just call pgp_sign() with a key ID, a pass
phrase, and some data, or call pgp_verify() with a signature (in the form
generated by pgp_sign()), a version number (which can be undef if you don't
want to give a version), and some data.  The data can be specified in
pretty much any form you can possibly consider data and a few you might
not.  Scalars and arrays are passed along to PGP; references to arrays are
walked and passed one element at a time (to avoid making a copy of the
array); file handles, globs, or references to globs are read a line at a
time and passed to PGP; and references to code are even supported (see
below).  About the only thing that we don't handle are references to
references (which are just printed to PGP, which probably isn't what you
wanted) and hashes (which are treated like arrays, which doesn't make a
lot of sense).

   If you give either function a reference to a sub, it will repeatedly
call that sub, sending the results to PGP to be signed, until the sub
returns undef.  What this lets you do is pass the function an anonymous
sub that walks your internal data and performs some manipulations on it a
line at a time, thus allowing you to sign a slightly modified form of your
data (with initial dashes escaped, for example) without having to use up
memory to make an internal copy of it.

   In a scalar context, pgp_sign() returns the signature as an
ASCII-armored block with embedded newlines (but no trailing newline).  In
a list context, it returns a two-element list consisting of the signature
as above and the PGP version that signed it (if that information was
present in the signature).  Warning:  It's expected that in the future
this interface will change, and pgp_sign() will instead return a list
consisting of the ASCII-armored block and all headers found in the armor.

   If you're using GnuPG, pgp_sign() will pass it the option
*-force-v3-sigs* so that it will generate PGP 5.0-compatible signatures.

   pgp_sign() will return undef in the event of any sort of error.

   pgp_verify() returns the signer of the message in the case of a good
signature, the empty string in the case of a bad signature, and undef in
the event of some error.  It takes the same sort of data sources as
pgp_sign().

   pgp_error() (which isn't exported by default) returns the error
encountered by the last pgp_sign() or pgp_verify(), or undef if there was
no error.  In a list context, a list of lines is returned; in a scalar
context, a long string with embedded newlines is returned.

   Six global variables can be modified (note that these will likely
eventually be partially or completely replaced with an interface via a
PGP::Sign::config() call):

$PGP::Sign::PGPS
     The path to the program to use to generate signatures.  This is set
     at the time of installation, but can be overridden.

$PGP::Sign::PGPV
     The path to the program to use to verify signatures.  This is set at
     the time of installation, but can be overridden.  There are two
     separate variables since PGP 5.0 uses two separate program names for
     signing and verifying; for PGP 2.6, 6.5.2, or GnuPG, just set both
     this and $PGP::Sign::PGPS to the same value.

$PGP::Sign::PGPPATH
     The path to a directory containing the PGP key rings that should be
     used.  If this isn't set, all versions of PGP will use the value of
     the environment variable PGPPATH or `$HOME/.pgp' (the default).
     GnuPG will use the value of the environment variable GNUPGHOME or
     `$HOME/.gnupg'.  Note that PGP when signing may want to write
     `randseed.bin' (or `randseed.rnd') in this directory if there isn't
     already a random seed there, so if you're encountering problems with
     signing, make sure the directory PGP is using is writeable by the
     user doing the signing.  Note also that if you're using GnuPG and the
     Entropy Gathering Daemon (egd), the entropy socket or a link to it
     must be located in this directory.

$PGP::Sign::PGPSTYLE
     What style of command line arguments and responses to expect from
     PGP.  The only three valid values for this variable are "PGP2" for
     PGP 2.6 behavior, "PGP5" for PGP 5.0 behavior, "PGP6" for PGP 6.5
     behavior, and "GPG" for GnuPG behavior.  What command line arguments
     PGP::Sign uses when running PGP are entirely determined by this
     variable.  It is set at the time of installation, but can be
     overridden.

$PGP::Sign::TMPDIR
     The directory in which temporary files are created.  Defaults to
     TMPDIR if set, and `/tmp' if not.

$PGP::Sign::MUNGE
     If this variable is set to a true value, PGP::Sign will automatically
     strip trailing spaces when signing or verifying signatures.  This
     will make the resulting signatures and verification compatible with
     programs that generate attached signatures (since PGP ignores
     trailing spaces when generating or checking attached signatures).
     See the more extensive discussion of whitespace below.

ENVIRONMENT
===========

PGPPATH
     If $PGP::Sign::PGPPATH is set and $PGP::Sign::PGPSTYLE is something
     other than "GPG", PGP::Sign sets PGPPATH to tell PGP where to find
     its key rings.  (GnuPG uses a command line argument instead.)

TMPDIR
     The directory in which to create temporary files.  Can be overridden
     by changing $PGP::Sign::TMPDIR.  If not set, defaults `/tmp'.

   In addition, all environment variables that PGP normally honors will be
passed along to PGP and will likely have their expected effects.  This
includes PGPPATH, unless it is overridden (see above).

DIAGNOSTICS
===========

   Mostly the contents of @PGP::Sign::ERROR (returned by pgp_error()) are
just the output of PGP.  The exceptions are:

Execution of %s failed: %s
     We couldn't fork off a PGP process for some reason, given (at least
     as the system reported it) after the colon.

No signature from PGP (command not found?)
     We tried to generate a signature but the output from the command we
     tried to run didn't contain anything that looked like a signature.
     One common explanation for this is that the path in $PGP::Sign::PGPS
     is invalid and that binary doesn't exist.

%s returned exit status %d
     Some command that we ran, or tried to run, returned a non-zero exit
     status.  %s will contain the exact binary name that PGP::Sign was
     attempting to run.

BUGS
====

   PGP::Sign does not currently work with binary data, as it
unconditionally forces text mode in PGP by using the -t option.  This is a
high priority to fix, but I'd like to implement some sort of generic way
of setting PGP options rather than just adding more entry points.

   There's no way of generating version four DSS signatures.  This will be
fixed by the same improvement that will fix the previous bug.

   PGP, all versions that I have available, behaves differently when
generating attached signatures than when generating detached signatures.
For attached signatures, trailing whitespace in lines of the data is not
significant, but for detached signatures it is.  This, combined with the
fact that there's no way that I can see to get PGP to verify a detached
signature without using files on disk, means that in order to maintain the
intended default semantics of this module (manipulating detached
signatures), I had to use temporary files in the implementation of
pgp_verify().  PGP::Sign sets its umask before creating those temporary
files and checks for race conditions, but files may be left behind in the
event that an application using pgp_verify() crashes unexpectedly.

   Also, because of this incompatibility, you need to be aware of what the
process checking the signatures you generate is expecting.  If that process
is going to turn your signature into an attached signature for verification
(as pgpverify does for Usenet control messages), then you need to pre-munge
your data to remove trailing whitespace at the ends of lines before feeding
it to PGP.  PGP::Sign will do that for you if you set $PGP::Sign::MUNGE to
a true value.

   To add even more confusion to the mix, earlier versions of GnuPG
followed an interpretation of RFC 2440 that specified text-mode signatures
are performed against data with canonicalized line endings and with
trailing whitespace removed (see section 5.2.1).  There is no difference
specified there between attached and detached signatures, and GnuPG
treated them both the same.  Versions of GnuPG at least after 1.0 appear
to have changed to follow the PGP behavior instead.

CAVEATS
=======

   This module is fairly good at what it does, but it doesn't as yet do
very much.  I intend to provide more options and more configurability in
the future, particularly the ability to handle binary data, but that may
mean API changes.  The interface to this module should not be considered
stable yet; you may have to change your application when you upgrade to a
newer version of this module.  The README will list API changes.

RESTRICTIONS
============

   PGP::Sign passes pass phrases to PGP via an open one-ended pipe, since
this is the only secure method (both command line switches and environment
variables can potentially be read by other users on the same machine using
ps).  This should be supported by any recent version of PGP; I have tested
it against 2.6.2, 2.6.3i, 5.0, 6.5.2, GnuPG 0.9.2, and GnuPG 1.0.1.
Implicit in this mechanism, though, is the requirement that the operating
system on which you're running this module supports passing an open pipe to
an exec()ed subprocess.  This may cause portability problems to certain
substandard operating systems.

SEE ALSO
========

   pgp(1), pgps(1), pgpv(1), gpg(1), RFC 2440

AUTHOR
======

   Russ Allbery <rra@stanford.edu>.

HISTORY
=======

   Based heavily on work by Andrew Gierth <andrew@erlenstar.demon.co.uk>
and benefitting greatly from input, comments, suggestions, and help from
him, this module came about in the process of implementing PGPMoose
signatures and control message signatures for Usenet.  PGPMoose is the
idea of Greg Rose <ggr@usenix.org>, and signcontrol and pgpverify are the
idea of David Lawrence <tale@isc.org>.

   Support for PGPPATH, the test suite, some bug fixes, and the impetus to
get another version released came from Andrew Ford
<A.Ford@ford-mason.co.uk>.  Thank you.

   Original support for GnuPG from Todd Underwood <todd@nm.net> and Monte
Mitzelfelt <monte@nm.net>.


File: pm.info,  Node: PGPLOT,  Next: PML,  Prev: PGP/Sign,  Up: Module List

allow subroutines in the PGPLOT graphics library to be called from Perl.
************************************************************************

NAME
====

   PGPLOT - allow subroutines in the PGPLOT graphics library to be called
from Perl.

SYNOPSIS
========

     use PGPLOT;

     pgbegin(0,"/xserve",1,1);
     pgenv(1,10,1,10,0,0);
     pglabel('X','Y','My plot');
     pgpoint(7,[2..8],[2..8],17);

     # etc...

     pgend;

DESCRIPTION
===========

   Originally developed in the olden days of Perl4 (when it was known as
'pgperl' due to the necessity of making a special perl executable) PGPLOT
is now a dynamically loadable perl module which interfaces to the FORTRAN
graphics library of the same name.

   PGPLOT, originally developed as a FORTRAN library, is now available with
C bindings (which the Perl module uses), though a FORTRAN compiler is
still required to build it.

   For every PGPLOT C/FORTRAN function the module provides an equivalent
Perl function with the same arguments. Thus the user of the module should
refer to the PGPLOT manual to learn all about how to use PGPLOT and for
the complete list of available functions.  This manual comes with the
PGPLOT distribution and is also available at the WWW address:

   http://astro.caltech.edu/~tjp/pgplot/

   Also refer to the extensive set of test scripts (`test*.p') included in
the module distribution for examples of usage of all kinds of PGPLOT
routines.

   How the FORTRAN/C function calls map on to Perl calls is detailed below.

ARGUMENT MAPPING - SIMPLE NUMBERS AND ARRAYS
--------------------------------------------

   This is more or less as you might expect - use Perl scalars and Perl
arrays in place of FORTRAN/C variables and arrays.

   Any FORTRAN REAL/INTEGER/CHARACTER* scalar variable maps to a Perl
scalar (Perl doesn't care about the differences between strings and
numbers and ints and floats).

   Thus you can say:

   To draw a line to point (42,$x):

     pgdraw(42,$x);

   To plot 10 points with data in Perl arrays `@x' and `@y' with plot
symbol no. 17. Note the Perl arrays are passed by reference:

     pgpoint(10, \@x, \@y, 17);

   You can also use the old Perl4 style:

     pgpoint(10, *x, *y, 17);

   but this is deprecated in Perl5.

   Label the axes:

     pglabel("X axis", "Data units", $label);

   Draw ONE point, see how when `N=1' `pgpoint()' can take a scalar as
well as a array argument:

     pgpoint(1, $x, $y, 17);

ARGUMENT MAPPING - IMAGES AND 2D ARRAYS
---------------------------------------

   Many of the PGPLOT commands (e.g. `pggray') take 2D arrays as
arguments. Several schemes are provided to allow efficient use from Perl:

  1. Simply pass a reference to a 2D array, e.g:

          # Create 2D array

          $x=[];
          for($i=0; $i<128; $i++) {
             for($j=0; $j<128; $j++) {
               $$x[$i][$j] = sqrt($i*$j);
             }
          }
          pggray( $x, 128, 128, ...);

  2. Pass a reference to a 1D array:

          @x=();
          for($i=0; $i<128; $i++) {
             for($j=0; $j<128; $j++) {
               $x[$i][$j] = sqrt($i*$j);
             }
          }
          pggray( \@x, 128, 128, ...);

     Here @x is a 1D array of 1D arrays. (Confused? - see perldata(1)).
     Alternatively @x could be a flat 1D array with 128x128 elements, 2D
     routines such as `pggray()' etc. are programmed to do the right thing
     as long as the number of elements match.

  3. If your image data is packed in raw binary form into a character
     string you can simply pass the raw string. e.g.:

          read(IMG, $img, 32768);
          pggray($img, $xsize, $ysize, ...);

     Here the read() function reads the binary data from a file and the
     `pggray()' function displays it as a grey-scale image.

     This saves unpacking the image data in to a potentially very large 2D
     perl array. However the types must match. The string must be packed
     as a `"f*"' for example to use `pggray'. This is intended as a
     short-cut for sophisticated users. Even more sophisticated users will
     want to download the `PDL' module which provides a wealth of
     functions for manipulating binary data.

     PLEASE NOTE: As PGPLOT is a Fortran library it expects it's images to
     be be stored in row order. Thus a 1D list is interpreted as a
     sequence of rows end to end. Perl is similar to C in that 2D arrays
     are arrays of pointers thus images end up stored in column order.

     Thus using perl multidimensional arrays the coordinate ($i,$j) should
     be stored in $img[$j][$i] for things to work as expected, e.g:

          $img = [];
          for $j (0..$nx-1) for $i (0..$ny-1) {
             $$img[$j][$i] = whatever();
          }}
          pggray($$img, $nx, $ny, ...);
          
          Also PGPLOT displays coordinate (0,0) at the bottom left (this is
          natural as the subroutine library was written by an astronomer!).


ARGUMENT MAPPING - FUNCTION NAMES
---------------------------------

   Some PGPLOT functions (e.g. `pgfunx') take functions as callback
arguments. In Perl simply pass a subroutine reference or a name, e.g.:

     # Anonymous code reference:

     pgfunx(sub{ sqrt($_[0]) },  500, 0, 10, 0);

     # Pass by ref:

     sub foo {
       my $x=shift;
       return sin(4*$x);
     }

     pgfuny(\&foo, 360, 0, 2*$pi, 0);

     # Pass by name:

     pgfuny("foo", 360, 0, 2*$pi, 0);

ARGUMENT MAPPING - GENERAL HANDLING OF BINARY DATA
--------------------------------------------------

   In addition to the implicit rules mentioned above PGPLOT now provides a
scheme for explictly handling binary data in all routines.

   If your scalar variable (e.g. $x) holds binary data (i.e. 'packed')
then simply pass PGPLOT a reference to it (e.g. `\$x'). Thus one can say:

     read(MYDATA, $wavelens, $n*4);
     read(MYDATA, $spectrum, $n*4);
     pgline($n, \$wavelens, \$spectrum);

   This is very efficient as we can be sure the data never gets copied and
will always be interpreted as binary.

   Again see the `PDL' module for sophisticated manipulation of binary
data. `PDL' takes great advantage of these facilities.

   Be VERY careful binary data is of the right size or your segments might
get violated.


File: pm.info,  Node: PML,  Next: PML/File,  Prev: PGPLOT,  Up: Module List

PML (PML Markup Lanuage)
************************

NAME
====

   PML (PML Markup Lanuage)

SYNOPSIS
========

   use PML;

   my $parser = new PML;

   $parser->parse('/path/to/somefile');

   my $output = $parser->execute;

DESCRIPTION
===========

   PML is a powerful text preprocessor. It supports such things as
variables, flow control and macros. After preprocessing a text file it
returns the result to your Perl script. The power comes from the fact that
you can even embed Perl code into the file that is getting processed.

   PML was originaly designed to seperate a Perl CGI script and the HTML
that it generates. What sets PML apart from other similar solutions is
that it is not just a web solution using mod_perl.  You can parse PML
files from the command line using the supplied pml script or from within
your Perl scripts using the PML Perl module.

   If you do have mod_perl, you can use the supplied mod_pml Apache module
to parse PML files from within the Apache web server.

EXAMPLE PML FILE
================

     <html>
     	<head>
     		<title>${title}</title>
     	</head>
     	<body>
     	@if(${title}) {
     		<h1>${title}</h1>
     	}
     	</body>
     </html>

DOCUMENTATION
=============

   Documentation is supplied with this module, in the doc directory.

     language.html: describes the language.

     pml-modules.html: tells you how to write a PML module

   pml-custom-app.html: tells you how to extend PML from
  within your application.

USAGE
=====

   The following is an overview of the PML API

METHOD new
----------

     Arguments:
     	1) Class or PML Object to clone
     	2) Hash Reference (Optional)

     Returns:
     	1) A PML Object

     Description:
     	new creates a new PML Object and returns the object
     	to the caller. You can optionaly pass in a hash
     	refernece, where the keys are PML variables to set
     	and the values are the values to set those variables
     	to.

METHOD parse
------------

     Arguments:
     	1) PML Object
     	2) Filename or a reference to an array of lines

     Returns:
     	1) True if parse was successful

     Description:
     	parse will parse the file or array that you give
     	it. If there is an error, such as a syntax error,
     	parse will throw an exception via die.  Therefore
     	if you want to catch the exception you should wrap
     	the call to parse in an eval block and check $@.
     	If $@ is true there was and error and the error
     	message can be found in $@.

METHOD execute
--------------

     Arguments:
     	1) PML Object
     	2) A Hash Reference (Optional)

     Returns:
     	1) The text in the file after processing it

     Description:
     	execute will process the file and return the
     	post-processed text.  You can optionaly pass in a
     	reference to a hash, where the keys are PML variables
     	to set and the values are the value to set them
     	to.  This is a good way so talk to your text file.

     You can call execute as many times as you wish.
     Each call will start afresh at the top of the parsed
     file.

METHOD v
--------

     Arguments:
     	1) PML Object

     -- or --
     
     2) Variable Name

     -- or --

     2) Variable Name
     3) New Value

     -- or --

     2) Hash Reference

     Returns:
     	1) Depends on Arguments, see below.

     Description:
     	The v method allows you to get and set PML variables.
     	There are a few different ways to use v, and we
     	will cover them all.

     Arguments:
     	1) PML Object

     In this case, you call v with only the object, no
     arguments. This will return an array of variable
     names. This is so you can see what variables are
     defined.

     Arguments:
     	1) PML Object
     	2) Variable Name

     This time you give a name of a variable. The v
     method will return the current value of that
     variable, or undef if it is not set.

     Arguments:
     	1) PML Object
     	2) Variable Name
     	3) Value

     Here, you give a variable name and the value to
     set it to. The v method will then set the give
     variable to the value you gave it. It should return
     the same value.

     Arguments:
     	1) PML Object
     	2) Hash Reference

     To limit method calls, you can give a hash reference
     where the keys are the variable to set and the
     values are the value to set those variables to.
     Returns 1.

METHOD parse_after
------------------

     Arguments:
     	1) PML Object
     	2) Regular Expression String or Object

     Returns:
     	1) Nothing

     Description:
     	Used before the call to parse, this method will
     	effect when parsing will start. When you call the
     	parse method, it will search for the given regex,
     	when that regex matches, parsing will begin on the
     	NEXT line.

CLASS METHOD register
---------------------

     Arguments:
     	1) Class ie PML->register(...)
     	2) A Hash, keys are described below

     Returns:
     	1) An ID number to refer to your token

     Description:
     	The register function is used to extend the PML
     	syntax. You register a callback for a new PML
     	function. When parsing the text, PML will call your
     	parser-callback to assist parsing. When executing,
     	PML will call your token-callback to process the
     	token created by your parser-callback.

     Here is what you should pass to register:

     parse => A callback. Defaults to using the
              builtin autoparser
     token => A callback. You must give this.
     name  => The name of the new PML function to add.
     type  => See Types below
     
     		Callbacks:

     A callback is a reference to a subroutine like this:
     	\&myfunc  -- or -- sub{}

     It can also be a reference to an array,
     where the first element is a reference to
     a subroutine and the remaining elements
     are passed to the subroutine as arguemnts
     after the standard arguments.

     Types:

     The types are constants in PML.pm.

     PML->ARG_ONLY   This means that your new
                     function will only take
                     arguments, just like the
                     builtin @set function.

     PML->BLOCK_ONLY This means that your new
                     function only takes a block
                     just like the builtin @perl
                     function.

     PML->ARG_BLOCK  This means that your new
                     function takes arguments
                     and a block, just like the
                     builtin @if function.

METHOD warning
--------------

     Arguments:
     	1) PML Object
     	2) Boolean Flag (Optional)

     Returns:
     	1) Current Warning Flag

     Description:
     	The warning method will set the warning flag to
     	the one given, if one was given. It always returns
     	the current value. If the flag is true, PML will
     	print warnings to STDERR.

METHOD use_stderr
-----------------

     Arguments:
     	1) PML Object
     	2) True to allow use of stderr, false to disallow

     Returns:
     	1) Nothing

     Description:
     	Sets the use_stderr flag for this object


File: pm.info,  Node: PML/File,  Next: PML/Headers,  Prev: PML,  Up: Module List

SYNOPSIS
========

   Quick Usage

DESCRIPTION
===========

   What does it do?

OPTIONS
=======

   Long Usage

EXAMPLES
========

   Example usage

SEE ALSO
========

   perl(1)

AUTHOR
======

   Peter J Jones pjones@cpan.org


File: pm.info,  Node: PML/Headers,  Next: PML/Storable,  Prev: PML/File,  Up: Module List

=head1 SYNOPSIS Quick Usage
***************************

NAME Headers.pm
===============

SYNOPSIS Quick Usage
====================

DESCRIPTION What does it do?
============================

OPTIONS Long Usage
==================

EXAMPLES Example usage
======================

SEE ALSO perl(1)
================

AUTHOR Peter J Jones pjones@cpan.org
====================================


File: pm.info,  Node: PML/Storable,  Next: PNGgraph,  Prev: PML/Headers,  Up: Module List

SYNOPSIS
========

   Quick Usage

DESCRIPTION
===========

   What does it do?

OPTIONS
=======

   Long Usage

EXAMPLES
========

   Example usage

SEE ALSO
========

   perl(1)

AUTHOR
======

   Peter J Jones pjones@cpan.org


