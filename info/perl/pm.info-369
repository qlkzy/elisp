This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Text/Filter/Chain,  Next: Text/FixedLength,  Prev: Text/Filter,  Up: Module List

object for chaining Text::Filter objects and running them sequentially, feeding the output of each filter to the input of the  next one.
****************************************************************************************************************************************

NAME
====

   Text::Filter::Chain - object for chaining Text::Filter objects and
running them sequentially, feeding the output of each filter to the input
of the next one.

SYNOPSIS
========

     use Text::Filter::Chain;

     # let's assume this is a filter which converts text to all lowercase
     $lc = new LowerCaser(input => 'foo.txt'); # reads from file foo.txt
     
     # and assume the following filter greps for a specified pattern
     $grep = new Grepper(pattern => '\bfoo\b',
                         output  => 'foo.out'); # writes to file foo.out

     # then these commands will read from foo.txt, convert the text to all
     # lowercase, filter out all lines with the word 'foo' and write to foo.out
     $chain = new Text::Filter::Chain(filters => [$lc,$grep]);
     $chain->run(); # this invokes the run() method on $lc and $grep

DESCRIPTION
===========

new()
     Returns a new empty `Text::Filter::Chain' object. Optionally, an
     ordered array of filters can be specified by passing a filters
     argument to new(). All filters are checked using is_valid_filter().

add_filter($filter)
     Adds the filter object $filter to the end of the array of filters.
     The filter is checked using is_valid_filter().

is_valid_filter($filter)
     Checks whether $filter is a valid filter for inclusion in a
     `Text::Filter::Chain'. The following requirements need to be met:


          a set_input() method must be available for setting the filter
          input;


          a set_output() method must be available for setting the filter
          output;


          a run() method must be available which runs the filter on its
          entire input.

     Note that $filter does not need to be a `Text::Filter' or derived
     object.  However, deriving at least the final filter in the chain
     from `Text::Filter' adds the benefit of automagical output buffer
     creation (see run()).

set_input()
     Sets the arguments which will be passed to the set_input() method of
     the first filter in the chain in run().

set_output()
     Sets the arguments which will be passed to the set_output() method of
     the final filter in the chain in run().

run()
     Runs all filters in the chain. This means that the run() method will
     be invoked on each filter object, and that the data will be buffered
     in between the filter: the output of the first filter is written to
     an array, which is used as the input of the 2nd filter, and so on.

     If set_input() was invoked on the chain, these arguments will be
     passed to the set_input() method of the first filter in the chain.
     If this is not the case, the input of the first filter must have been
     defined in some other way, or run() will fail during the processing
     of the first filter.

     If set_output() was invoked on the chain, these arguments will be
     passed to the set_output() method of the final filter in the chain.
     If this is not the case, the output of the final filter must have been
     defined in some other way, or run() will fail during the processing
     of the final filter.

     However, a fallback is provided for filters derived from the
     `Text::Filter' class. If no output is specified for the final filter,
     and no chain output is given, the chain output will default to an
     empty array before processing all filters.  This array is accessible
     as the 1st element in the ref to array kept in the output field of
     the chain.

SEE ALSO
========

   More info on text filters is found in *Note Text/Filter: Text/Filter,.

AUTHOR
======

   Wim Verhaegen <wim.verhaegen@ieee.org>

COPYRIGHT
=========

   Copyright (c) 2000 Wim Verhaegen. All rights reserved.  This program is
free software; you can redistribute and/or modify it under the same terms
as Perl itself.


File: pm.info,  Node: Text/FixedLength,  Next: Text/FixedLength/Extra,  Prev: Text/Filter/Chain,  Up: Module List

Parse and create fixed length field records
*******************************************

NAME
====

   Text::FixedLength - Parse and create fixed length field records

SYNOPSIS
========

     use Text::FixedLength;

     # -- get fixed length records from delimited text
     my @fL = qw(4L 4L 4L 4L); # -- left justified (which is default)
     my @fR = qw(4R 4R 4R 4R); # -- right justified (not default)
     my $str= join "\t", qw(1 2 3 4);
     my @a1 = delim2fixed([ $str ],"\t", \@fL);
     my @a2 = delim2fixed([ $str ],"\t", \@fR);
     # -- $a1[0] would now hold: '1   2   3   4   '
     # -- $a2[0] would now hold: '   1   2   3   4'

     # -- get delimited text from fixed length
     my @a1 = fixed2delim([ '2233344441' ], [qw(2 3 4 1)], ':');
     # -- $a1[0] would now hold: 22:333:4444:1

DESCRIPTION
===========

   Text::FixedLength was made to be able to manipulate fixed length field
records. You can manipulate arrays of data, or files of data.  This module
allows you to change between delimited and fixed length records.

   E.g. DELIM (with ':' as the delim) aaa:bbb:ccccc:dddddd      FIXED
'dion    almaer   mn55446'            where the format is left justified:
8 9 2 5 (SEE FORMATS)

FORMATS
=======

     You need to be familiar with the format array references used
     to create, and parse fixed length fields.
     The array reference holds the length of the field, and optionally
     holds either 'L' for left justified, or 'R' for right justified.
     By default fields are left justified (but you can change this
     default via the setJustify(L || R) functino)

     For example if you had the following fixed length record:

     1234567890123456789012345 <- place holder
     dion    almaer    mn55446

     The format (if all left justified) would be:
     $format = [ 8, 10, 2, 5 ];

FUNCTIONS
=========

   o *delim2fixed*($filename | $dataAREF, $delim,
$formatAREF,[$outfilename])

     delim2fixed returns fixed length field records from delimited records

     ARGUMENTS:
     1: Filename or an array reference holding delimited strings
     2: Delimiter for the data in arg 1
     3: Format array reference of the fixed lengths (see FORMATS)
     4: [OPTIONAL] Filename to write the fixed length data too

     RETURNS: Depending on wantarray it will return either an array of
              fixed length records, an array reference, or nothing
     e.g. @array = delim2fixed('file',':',[ qw(2 2 4 10) ]);
          $scalar = delim2fixed([ 'foo:bar:whee' ],':',[ qw(5 5 5) ]);
          delim2fixed('file',"\t",[ qw(6 10 4 1) ], 'outputfile');

   o *fixed2delim*($filename | $dataAREF, $formatAREF, $delim,
[$outfilename])

     fixed2delim returns delimited records from fixed length records

     ARGUMENTS:
     1. Filename or an array reference holding fixed length records
     2. Format array reference for the data in arg 1
     3. Delimiter for the output data
     4: [OPTIONAL] Filename to write the delimited data too

     RETURNS: Depending on wantarray it will return either an array of
              delimited records, an array reference, or nothing
     e.g. @array = fixed2delim('file',[ qw(2 2 4 10) ],':');
          $scalar = fixed2delim([ 'foo   bar whee' ],':',[ qw(6 4 4) ]);
          fixed2delim('file',[ qw(6 10 4 1) ],"\t",'outputfile');

     NOTE: The resulting strings are cleaned of whitespace at the
           beginning and the end. So '  foo  ' becomes 'foo'
           You do not need to worry about the justification of the
           text as the whitespace is cleaned

   o *setJustify*($justchar) [either 'L' or 'R'] [default: L]

     setJustify sets the default justification (originally set to left).
     
     ARGUMENTS: either L for left justified, or R for right justified

   o *setCrop*($bool) [either 1 or 0] [default: 1]

     setCrop sets whether records should be cropped to the size of the format
     or not.

     For example if you have a string 'whee' that is meant to be fit into
     a fixed format of 2 then if setCrop is true the record will be changed
     to 'wh' to constrain it


File: pm.info,  Node: Text/FixedLength/Extra,  Next: Text/Flowchart,  Prev: Text/FixedLength,  Up: Module List

various niceties for Text::FixedLength lovers.
**********************************************

NAME
====

   Text::FixedLength::Extra - various niceties for Text::FixedLength
lovers.

SYNOPSIS
========

     use Text::FixedLength::Extra; #automatically uses Text::FixedLength

     my %format        =   (record_type => '3L', total_orders => '5R');
     my @field_order   = qw(record_type total_orders);
     my %data          =   (record_type => 'F',  total_orders => 300);

     # Bonus One: Simplified API to Text::FixedLength !
     $x = fixedlength(\%format, \%data, \@field_order);

     # Bonus Two: Zero filling and processing of integers and floating points !
     my %format        =   (record_type => '3R', total_orders => '10R*F3');
     my @field_order   = qw(record_type total_orders);
     my %data          =   (record_type => 'F',  total_orders => 300.52894);

     $x = fixedlength(\%format, \%data, \@field_order);

DESCRIPTION
===========

   Right now, Text::FixedLength::Extra does two things for those who like
using Text::FixedLength - simpler API and extended number processing.

Simplified API to Text::FixedLength
-----------------------------------

   A function, fixedlength() has been created which should make it easier
to create fixed-width reports. Here is a sample of setting up data for use
with fixedlength:

     # the fields we will format and their formatting instructions
     my %format =
       (
        record_type => '3',
        upc => '13L',
        lcc_label => '5R',
        lcc_catalog => '7R',
        lcc_config => '1',
        artist_name => '30L',
        item_title => '30L',
        quoted_price => '6R',
        quantity => '4R',
        customer_title => '30L',
        customer_reference => '20L'
       );

     # how to order the fields in %format
     my @format =  qw(record_type   upc     lcc_label     lcc_catalog
     lcc_config     artist_name     item_title     quoted_price     quantity
     customer_title     customer_reference    );

     my %data = ( record_type => '23423' ... customer_reference => 'adfja;kdf');

     my $formatted_line = fixedlength(\%format, %data, \@format);

Number processing
-----------------

   The standard format instruction with Text::FixedLength is

     WIDTH JUSTIFICATION?

   E.g. 6L creates a left-justified field taking up 6 spaces, filling any
non-used spaces with a spaces.

   This module re-implements the Text::FixedLength::getFixed function to
handle additional optional syntax for formatting numbers. The new format
instruction is:

     WIDTH JUSTIFICATION? (ZERO_FILL? D)?
       or
     WIDTH JUSTIFICATION? (ZERO_FILL? F PLACES_AFTER_DECIMAL)?

   If you dont understand the above let me give you a nice set of examples:

     10R*F3 means uses 10 spaces, zero fill if necessary and allow 3 places after the decimal point.

     10R*D  means uses 10 spaces, zero fill if necessary.

     10RF3  means uses 10 spaces, space fill (not zero-fill, note there was no * in the specification) if necessary and allow 3 places after the decimal point.

EXPORT
------

   fixedlength()

OVERWRITTEN
-----------

   Text::FixedLength::getFixed()

AUTHOR
======

   T. M. Brannon, <TBONE@CPAN.ORG>

SEE ALSO
========

   perl(1). Parse::FixedLength


File: pm.info,  Node: Text/Flowchart,  Next: Text/Format,  Prev: Text/FixedLength/Extra,  Up: Module List

ASCII Flowchart maker
*********************

NAME
====

   Text::Flowchart - ASCII Flowchart maker

AUTHOR
======

   Jim Thomason, jim3@psynet.net

SYNOPSIS
========

     +-------+      +-------------+
     | BEGIN >---+  |             |
     +-------+   +--> Do you need |
                    | to make a   N------+
           +--------Y flowchart?  |      |
           |        |             |      |
           |        +-------------+      |
           |                             |
           |         +------------+      |
           |         |            |      |
     +-----V-------+ | So use it. |      |
     |             | |            |      |
     | Then my     | +--^---V-----+      |
     | module may  |    |   |            |
     | help.       |    |   |            |
     |             >----+   |            |
     +-------------+        |            |
                            |      +-----V-------+
                            |      |             |
                            |      | Then go do  |
                            +------> something   |
                                   | else.       |
                                   |             |
                                   +-------------+

DESCRIPTION
===========

   Text::Flowchart does what the synopsis implies, it makes ASCII
flowcharts.  It also (hopefully) makes it easy to make ASCII flowcharts.

REQUIRES
========

   Carp

OBJECT METHODS
==============

CREATION
--------

   New flowcharts are created with the new constructor.

   $object = Text::Flowchart->new();

   You can also initialize values at creation time, such as:

     $object = Text::Flowchart->new(
     			"width"	=>	120,
     			"debug"	=>	1
     		);

ACCESSORS
---------

   There aren't any.  Well, there aren't any that you really should use.

   Why's that, you ask?  Because that's how the module is written.  Once
an object is added into a flowchart, its appearance becomes set in stone.
And I mean totally set in stone, you cannot remove a box from a flowchart,
it sticks around until the flowchart is destroyed.  Even if you poked
around in the internals of the module and discovered that ->string is an
accessor in the box class, for instance, it wouldn't do you any good since
objects are immediately rendered upon their creation.  Even if you
re-render the object after fiddling with it, it's not going to work since
the objects are inserted into the flowchart's internal grid once they're
rendered.

   So basically, declare everything you need to declare about an object
when you create it, and make sure that that's the information you're going
to use when you print it out.  It's not *that* hard.  :)

Methods
-------

   There are several methods you are allowed to invoke upon your flowchart
object.

new (?width? ?height? ?pad? ?debug?)
     This is the object constructor that actually creates your flowchart
     object.  All parameters are optional and are passed in a hash.

    width
          Optional. Specifies the width of your flowchart object, or uses
          the module default (72).

          The width of a flowchart must be specified, it cannot grow to
          accomodate objects placed within it.  If you try to place an
          object beyond the edge of the flowchart, you'll die with an
          error.

    height
          Optional. Specifies the height of your flowchart object, or uses
          the module default (0).

          The default height of 0 means that your flowchart will grow in
          height as much as necessary to accomodate the height of whatever
          you insert into your flowchart.  You can also specify a specific
          height so that your flowchart will be no taller than 17 rows,
          for example.  If you try to place an object beyond the bottom of
          the flowchart, you'll die with an error.

    pad
          Optional. pad allows you to specify a padding character.  The
          padding character is what is used to fill in the space between
          boxes and lines.  The default padding character is a space
          (\040), but you can set it to anything else you'd like.  This is
          most useful when debugging, IMHO.  Very useful in combination
          with debug (see below).  Set to " " by default.

    debug
          Optional. debug will print out the x & y coordinates of the
          flowchart.  This should greatly help you place your boxes where
          you want them to be.  Off by default, set to 1 to enable.

    directed
          Optional. directed specifies that your flowchart is direction
          dependent.  This will add on arrows to all of your lines.
          Flowcharts are non-directed by default.  Set this to 1 to use a
          directed flowchart.

     For example:

          $flowchart = Text::Flowchart::new->();	#boring flowchart, no options
          
          $flowchart = Text::Flowchart::new->(	#flowchart specifying new width, a % as the padding character, and using the debugging option
          	"width" => 100,
          	"pad" 	=> "%",
          	"debug"	=> 1
          );
          
          $flowchart = Text::Flowchart::new(		#using periods as the padding character
          	"pad"	=> "."
          );

box (string x_coord y_coord ?x_pad? ?y_pad? ?width? ?height?)
     You use the box method to add a new box into your flowchart object.
     All parameters are passed in a hash.

     The text within a box is wrapped at word boundaries if possible, or
     at the appropriate width if not possible so that all of your text
     fits inside your box.

    string
          Required. string is the message that you'll see within the box.
          Want your box to say "Hi there!"?  "string" => "Hi there!";
          Easy as pie.

    x_coord
          Required. The x coordinate of the upper left corner of the box.
          Use the debug option to help you find your coordinates.

    y_coord
          Required. The y coordinate of the upper left corner of the box.
          Use the debug option to help you find your coordinates.

    x_pad
          Optional. x_pad allows you to specify the amount of horizontal
          white space between the edges of the box and the text within.
          If this option is not specified, it'll use the default of a
          single space.

    y_pad
          Optional. y_pad allows you to specify the amount of vertical
          white space between the edges of the box and the text within.
          If this option is not specified, it'll use the default of a
          single line of white space.

    width
          Optional. width allows you to specify the width of the box.  The
          narrowest possible box has a width of 3.  You must take into
          account your x_pad value, as well as the edges of the box when
          you specify a width.  If no width is specified, it will use the
          default of 15.

          If you specify a width of 0 (zero), then your box will grow
          horizontally to accomodate all of your text, or until it reaches
          the width of the flowchart, whichever is lesser.  Be careful!
          This will put all of your box message onto the same line.  You
          almost never want your width to be 0.

    height
          Optional. height allows you to specify the height of the box.
          The shortest possible box has a height of 3.  You must take into
          account your y_pad value, as well as the edges of the box when
          you specify a height.  If no height is specified, it will use
          the default of 0 (zero).

          If you specify a height of 0 (zero), then your box will grow
          vertically to accomodate all of your text, or until it reaches
          the height of the flowchart, whichever is lesser.  You most
          likely want a box width of some fixed value, and a box height of
          zero so it will grow to accomodate your message.

          If you specify a non-zero box height, then your string will be
          truncated once the box reaches the height that you specified.
          It will still be created, you just won't have all of your text
          in it.

          For example:

               $example_box = $flowchart->box(								#creates a box at (15,0)
               	"string" => "Do you need to make a flowchart?",
               	"x_coord" => 15,
               	"y_coord" => 0
               );

               Output:
               
                             +-------------+
                             |             |
                             | Do you need |
                             | to make a   |
                             | flowchart?  |
                             |             |
                             +-------------+

               $example_box2 = $flowchart->box(								#creates a box at (0,0), with new x_pad and y_pad values
               	"string"  => "Do you need to make a flowchart?",
               	"x_coord" => 0,
               	"y_coord" => 0,
               	"x_pad"	  => 0,
               	"y_pad"	  => 3
               );

               Output:
               
               +-------------+
               |             |
               |             |
               |             |
               |Do you need  |
               |to make a    |
               |flowchart?   |
               |             |
               |             |
               |             |
               +-------------+

               $example_box3 = $flowchart->box(								#creates a box at (0,0), with new x_pad and y_pad values
               	"string"  => "Do you need to make a flowchart?",
               	"x_coord" => 0,
               	"y_coord" => 0,
               	"x_pad"	  => 2,
               	"y_pad"	  => 0
               );
               
               Output:
               
               +-------------+
               |  Do you     |
               |  need to    |
               |  make a     |
               |  flowchart  |
               |  ?          |
               +-------------+

relate ([from, from side, ?on side?], [to, to side, ?on side?], ?reason?)
     the relate method connects boxes to each other.  Once two boxes are
     related, a line is automatically drawn between then, listing a reason
     if given, and arrows if it's a directed flowchart.  The relate method
     spares you the trouble of having to re-position your lines if you
     move your boxes around.  You may still have to do some fiddling (such
     as changing the sides that are connected), but it's much less trouble
     than re-arranging the boxes and the lines.

    (from or to)
          Required. This is the box that you're relating from or to, it's
          the first item in an anonymous array.

    (from or to) side
          Required. This is the side of the box that you're relating from
          or to.  This must be either "top", "bottom", "right", or "left".
          It's the second item in an anonymous array.

    ?on side?
          Optional. This optional item specifies where on the box side
          you'd like to draw the line from.  If zero, it will take the
          first available slot starting from the left (if drawing from the
          top or bottom) or from the top (it drawing from the right or
          left).  If -1, it will take the first available slot starting
          from the other side (right for top and bottom or bottom for
          right or left).  If any other number, it will draw the line at
          that position, along the side, again counting from the left or
          the top.

    reason
          Optional. reason is a name and value pair that specifies why you
          would take that route.  The value must be one character long,
          you'll die with an error if it isn't.  reasons only make sense
          in a directed flowchart, they don't appear in non-directed ones.
          Typical values are "Y" for yes and "N" for no.  If no reason is
          specified, the default direction character will be used.

          For example:

          $flowchart = Text::Flowchart->new( 	"width" => 50,
          "directed" => 1);

               $example_box = $flowchart->box(								#creates a box at (0,0)
               	"string" => "Do you need to make a flowchart?",
               	"x_coord" => 0,
               	"y_coord" => 2,
               );
               
                $example_box2 = $flowchart->box(								#creates a box at (15,0)
               	"string" => "Yes I do.",
               	"x_coord" => 19,
               	"y_coord" => 0,
               	"width"	  => 13
               );
               
                $example_box3 = $flowchart->box(								#creates a box at (15,0)
               	"string" => "No I don't.",
               	"x_coord" => 19,
               	"y_coord" => 7
               );
               
               $flowchart->relate(
               	[$example_box, "right"] => [$example_box2, "left"]
               );
               
                $flowchart->relate(
               	[$example_box, "right", -1] => [$example_box3, "left"]
               );
               
               $flowchart->draw();
               
               Output:

               +-----------+
                                +-->           |
                +-------------+ |  | Yes I do. |
                |             >-+  |           |
                | Do you need |    +-----------+
                | to make a   |
                | flowchart?  |
                |             >--+ +-------------+
                +-------------+  +->             |
               | No I don't. |
               |             |
               +-------------+

          $flowchart = Text::Flowchart->new( 	"width" => 50);	#A
          non-directed chart

               $example_box = $flowchart->box(	#creates a box at (0,0)
               	"string" => "Do you need to make a flowchart?",
               	"x_coord" => 0,
               	"y_coord" => 2,
               );
               
                $example_box2 = $flowchart->box(	#creates a box at (15,0)
               	"string" => "Yes I do.",
               	"x_coord" => 19,
               	"y_coord" => 0,
               	"width"	  => 13
               );
               
                $example_box3 = $flowchart->box(	#creates a box at (15,0)
               	"string" => "No I don't.",
               	"x_coord" => 19,
               	"y_coord" => 7
               );
               
               $flowchart->relate(
               	[$example_box, "right"] => [$example_box2, "left"]
               );
               
                $flowchart->relate(
               	[$example_box, "right", -1] => [$example_box3, "left"]
               );
               
               $flowchart->draw();
               
               Output:

               +-----------+
                                +--+           |
                +-------------+ |  | Yes I do. |
                |             +-+  |           |
                | Do you need |    +-----------+
                | to make a   |
                | flowchart?  |
                |             +--+ +-------------+
                +-------------+  +-+             |
               | No I don't. |
               |             |
               +-------------+

          $flowchart = Text::Flowchart->new( 	"width" => 50,
          "directed" => 1 );

               $example_box = $flowchart->box(	#creates a box at (0,0)
               	"string" => "Do you need to make a flowchart?",
               	"x_coord" => 0,
               	"y_coord" => 2,
               );
               
                $example_box2 = $flowchart->box(	#creates a box at (15,0)
               	"string" => "Yes I do.",
               	"x_coord" => 19,
               	"y_coord" => 0,
               	"width"	  => 13
               );
               
                $example_box3 = $flowchart->box(	#creates a box at (15,0)
               	"string" => "No I don't.",
               	"x_coord" => 19,
               	"y_coord" => 7
               );
               
               $flowchart->relate(
               	[$example_box, "right"] => [$example_box2, "left"],
               	"reason" => "Y"
               );
               
                $flowchart->relate(
               	[$example_box, "right", -1] => [$example_box3, "left"],
               	"reason" => "N"
               );
               
               $flowchart->draw();
               
               Output:

               +-----------+
                                +-->           |
                +-------------+ |  | Yes I do. |
                |             Y-+  |           |
                | Do you need |    +-----------+
                | to make a   |
                | flowchart?  |
                |             N--+ +-------------+
                +-------------+  +->             |
               | No I don't. |
               |             |
               +-------------+

    draw (?FILEHANDLE?)
               the draw method actuall outputs your flowchart.  You can optionally give it a glob to a filehandle to re-direct the output to that filehandle.

               For example:
               
               $flowchart->draw();	#draw your flowchart on STDOUT;
               
               $flowchart->draw(*FILE);	#send it to the FILE filehandle.

          Required. This is the box that you're relating from or to, it's
          the first item in an anonymous array.

HISTORY
=======

- 1.00 12/21/99
     First public release onto CPAN.

EXAMPLE
=======

   This code will print out the flowchart shown up in the SYNOPSIS.

   use Text::Flowchart;

   $flowchart = Text::Flowchart->new(  	"width" => 50,  	"directed" => 0);

   $begin = $flowchart->box(  	"string" => "BEGIN",
"x_coord" => 0,  	"y_coord" => 0,  	"width"   => 9,  	"y_pad"   => 0  );

   $start = $flowchart->box(  	"string" => "Do you need to make a
flowchart?",  	"x_coord" => 15,  	"y_coord" => 0  );

   $yes = $flowchart->box(  	"string" => "Then my module may help.",
	"x_coord" => 0,  	"y_coord" => 10  );

   $use = $flowchart->box(  	"string" => "So use it.",
"x_coord" => 16,  	"y_coord" => 8,  	"width"	  => 14  );

   $no = $flowchart->box(  	"string" => "Then go do something
else.",  	"x_coord" => 30,  	"y_coord" => 17  );

   $flowchart->relate(  	[$begin, "right"] => [$start, "left", 1]
);

   $flowchart->relate(  	[$start, "left", 3] => [$yes, "top", 5],
"reason" => "Y"  );

   $flowchart->relate(  	[$start, "right", 2] => [$no, "top", 5],
"reason" => "N"  );

   $flowchart->relate(  	[$yes, "right", 4] => [$use, "bottom", 2]
);

   $flowchart->relate(  	[$use, "bottom", 6] => [$no, "left", 2]  );

   $flowchart->draw();

FAQ
===

   *Why in the world did you write this thing?*

   There's a flowcharting-type program that a couple of people use at
work.  It is only available on PCs.  I got cranky about not being able to
use it, so I wrote my own.  Admittedly, mine isn't as powerful or as easy
to use as theirs is, but I'm quite pleased with it nonetheless.  Real
programmers don't use software tools.  Real programmers write software
tools.

   *Hey!  I created a box, and then I tried to change its string and it
didn't work!  What gives?*

   Boxes are rendered upon their creation.  You cannot change their
strings once their are created.  I may change this in a future release,
but for now just wait until you're U<sure> you know what you want in a box
before you create it, okay?  That way you won't have to change it later.

   *Hey!  I'm running a memory tracer, and even though I deleted a box,
the memory wasn't freed up.  Do you have a memory leak or what?*

   Nope.  Boxes are stored internally inside the flowchart object.  The
box variable that you get back from ->box is just a reference to the box
that lives inside the flowchart.  Since the flowchart still knows the box
exists (even if you don't), the memory is not freed up.  Naturally, it
will be freed once perl exits.  I may add in the ability to remove boxes
to a future release.

   *I want to draw lines from the left side of a box to the left side of
another box, but I get an error. Why?*

   Because you can't draw lines like that.  :)

   Basically, there are 10 types of lines that can be drawn (all of which
are done by the relate method, naturally). They look like:

     +---+  +--+        +--+  +  +        +  +-+  +-+  +        +
               |        |     |  |        |    |  |    |        |
               +--+  +--+     +  +--+  +--+    +  +    +--+  +--+
                                    |  |
                                    +  +
     
     Or horizontal, zig-zagging horizontal, vertical, zig-zagging vertical, and corners.  Connecting the same sides of boxes would require another type of line,
     (the "handle", FWIW), and Text::Flowchart can't draw those.  If I can think of a good way to implement them I will.  Incidentally, you can draw your own lines
     if you need to, using the ->line method.

     $flowchart->line(
     	"from"	=> [xfrom, yfrom],
     	"to"	=> [yfrom, yto],
     	"reason"=> "Y"
     );

   But you really should use relate and not connect the same sides of
boxes, it will make your life much simpler.

   *I made a flowchart, but all of the lines cross over each other and
make a mess.  Why?*

   Text::Flowchart has no collision detection.  If you try to place a box
where another box already was, it'll gladly be drawn over.  Whichever
boxes or lines are drawn last will take priority.  If things are being
over-written, then you need to change the coordinates of your boxes so
they stop over-writing each other, or change the box sides that are
related so they don't draw over boxes.

   *Squares and rectangles are boring.  Can I draw other shapes?*

   Not yet.  The module is actually numerous packages, heavily subclassing
each other.  Adding in additional shapes is quite easy, actually.  You'd
just need to define a subclass of the Text::Flowchart::Shape class and
define the necessary functions.  You'd have to declare a render method to
actually create the ASCII object, a relate method that knows how to draw
the lines between objects, a get_next_coord method to get the next
available coordinate on a given side, and make the necessary modifications
to your new constructor (calling ::Shape's init(), of course), and you're
done!

   It's actually much easier than it sounds, from a programming
standpoint.  Figuring out how to properly render and relate object, that's
tricky.  I will be adding more shapes into a future release.  If anyone
wants to add their own shapes, e-mail 'em to me and I may add them in in
the future.

   *So what is it with these version numbers anyway?*

   I'm going to try to be consistent in how I number the releases.

   The *hundredths* digit will indicate bug fixes, etc.

   The *tenths* digit will indicate new and/or better functionality, as
well as some minor new features.

   The ones digit will indicate a major new feature or re-write.

   Basically, if you have x.ab and x.ac comes out, you want to get it
guaranteed.  Same for x.ad, x.ae, etc.

   If you have x.ac and x.ba comes out, you'll probably want to get it.
Invariably there will be bug fixes from the last "hundredths" release, but
it'll also have additional features.  These will be the releases to be
sure to read up on to make sure that nothing drastic has changes.

   If you have x.ac and y.ac comes out, it will be the same as x.ac->x.ba
but on a much larger scale.

   *Anything else you want to tell me?*

   Sure, anything you need to know.  Just drop me a message.

MISCELLANEA
===========

   If there's something that you feel would be worthwhile to include,
please let me know and I'll consider adding it.

   How do you know what's a worthwhile addition?  Basically, if it would
make your life easier.  Am I definitely going to include it?  Nope.  No
way.  But I'll certainly consider it, all suggestions are appreciated.  I
may even be nice and fill you in on some of the ideas I have for a future
release, if you ask nicely.  :)

COPYRIGHT (again) and LICENSE
=============================

   Copyright (c) 1999 James A Thomason III (jim3@psynet.net). All rights
reserved.  This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.  *Except if you profit from
its distribution.  If this module or works based upon this module are
distributed in a way that makes you money, you must first contact me to
work out a licensing arrangement.  I'm just giving the thing away, but I'm
not going to allow people to make money off of it unless I get a cut.  :)
Amounts will be hammered out on an individual basis.  CPAN mirrors are
exempt from this stipulation.  If you're not sure if you're distributing
it in a way that makes you money, contact me with details and we'll make a
decision.*

CONTACT INFO
============

   So you don't have to scroll all the way back to the top, I'm Jim
Thomason (jim3@psynet.net) and feedback is appreciated.  Bug
reports/suggestions/questions/etc.  Hell, drop me a line to let me know
that you're using the module and that it's made your life easier.  :-)


File: pm.info,  Node: Text/Format,  Next: Text/German,  Prev: Text/Flowchart,  Up: Module List

Various subroutines to format text.
***********************************

NAME
====

   *Text::Format* - Various subroutines to format text.

SYNOPSIS
========

     use Text::Format;

     $text = Text::Format->new (
         {
             text           =>  [], # all
             columns        =>  72, # format, paragraphs, center
             leftMargin     =>   0, # format, paragraphs, center
             rightMargin    =>   0, # format, paragraphs, center
             firstIndent    =>   4, # format, paragraphs
             bodyIndent     =>   0, # format, paragraphs
             rightFill      =>   0, # format, paragraphs
             rightAlign     =>   0, # format, paragraphs
             justify        =>   0, # format, paragraphs
             extraSpace     =>   0, # format, paragraphs
             abbrevs        =>  {}, # format, paragraphs
             hangingIndent  =>   0, # format, paragraphs
             hangingText    =>  [], # format, paragraphs
             noBreak        =>   0, # format, paragraphs
             noBreakRegex   =>  {}, # format, paragraphs
             tabstop        =>   8, # expand, unexpand,  center
         }
     ); # these are the default values

     %abbr = (foo => 1, bar => 1);
     $text->abbrevs(\%abbr);
     $text->abbrevs();
     $text->abbrevs({foo => 1,bar => 1});
     $text->abbrevs(qw/foo bar/);
     $text->text(\@text);

     $text->columns(132);
     $text->tabstop(4);
     $text->extraSpace(1);
     $text->firstIndent(8);
     $text->bodyIndent(4);
     $text->config({tabstop => 4,firstIndent => 0});
     $text->rightFill(0);
     $text->rightAlign(0);

DESCRIPTION
===========

   The format routine will format under all circumstances even if the
width isn't enough to contain the longest words.  Text::Wrap will die
under these circumstances, although I am told this is fixed.  If columns
is set to a small number and words are longer than that and the leading
'whitespace' than there will be a single word on each line.  This will let
you make a simple word list which could be indented or right aligned.
There is a chance for croaking if you try to subvert the module.  If you
don't pass in text then the internal text is worked on, though not modfied.
*Text::Format* is meant for more powerful text formatting than Text::Wrap
allows.  I also have a module called *Text::NWrap* that is meant as a
direct replacement for Text::Wrap.  *Text::NWrap* requires *Text::Format*
since it uses *Text::Format->format* to do the actual wrapping but gives
you the interface of Text::Wrap.

   General setup should be explained with the below graph.

     columns
     <------------------------------------------------------------>
     <----------><------><---------------------------><----------->
      leftMargin  indent  text is formatted into here  rightMargin

   indent is firstIndent or bodyIndent depending on where we are in the
paragraph.

format @ARRAY || \@ARRAY || [<FILEHANDLE>] || NOTHING
     Allows to do some advanced formatting of text into a paragraph, with
     indent for first line and body set separately.  Can specify total
     width of text, right fill with spaces or right align or justify
     (align to both margins), right margin and left margin, non-breaking
     space, two spaces at end of sentence, hanging indents (tagged
     paragraphs).  Strips all leading and trailing whitespace before
     proceeding.  Text is first split into words and then reassembled.  If
     no text is passed in then the internal text in the object is
     formatted.

paragraphs @ARRAY || \@ARRAY || [<FILEHANDLE>] || NOTHING
     Considers each element of text as a paragraph and if the indents are
     the same for first line and the body then the paragraphs are
     separated by a single empty line otherwise they follow one under the
     other.  If hanging indent is set then a single empty line will
     separate each paragraph as well.  Calls format to do the actual
     formatting.  If no text is passed in then the internal text in the
     object is formatted, though not changed.

center @ARRAY || NOTHING
     Centers a list of strings in @ARRAY or internal text.  Empty lines
     appear as, you guessed it, empty lines.  Center strips all leading and
     trailing whitespace before proceeding.  Left margin and right margin
     can be set.  If no text is passed in then the internal text in the
     object is formatted.

expand @ARRAY || NOTHING
     Expand tabs in the list of text to tabstop number of spaces in @ARRAY
     or internal text.  Doesn't modify the internal text just passes back
     the modified text.  If no text is passed in then the internal text in
     the object is formatted.

unexpand @ARRAY || NOTHING
     Tabstop number of spaces are turned into tabs in @ARRAY or internal
     text.  Doesn't modify the internal text just passes back the modified
     text.  If no text is passed in then the internal text in the object is
     formatted.

new \%HASH || NOTHING
     Instantiates the object.  If you pass a reference to a hash, or an
     anonymous hash then it's used in setting attributes.

config \%HASH
     Allows the configuration of all object attributes at once.  Returns
     the object prior to configuration.  You can use it to make a clone of
     your object before you change attributes.

columns NUMBER || NOTHING
     Set width of text or retrieve width.  This is total width and includes
     indentation and the right and left margins.

tabstop NUMBER || NOTHING
     Set tabstop size or retrieve tabstop size, only used by expand,
     unexpand and center.

firstIndent NUMBER || NOTHING
     Set or get indent for the first line of paragraph.  This is the number
     of spaces to indent.

bodyIndent NUMBER || NOTHING
     Set or get indent for the body of paragraph.  This is the number of
     spaces to indent.

leftMargin NUMBER || NOTHING
     Set or get width of left margin.  This is the number of spaces used
     for the margin.

rightMargin NUMBER || NOTHING
     Set or get width of right margin.  This is the number of spaces used
     for the margin.

rightFill 0 || 1 || NOTHING
     Set right fill or retrieve its value.  The filling is done with
     spaces.  Keep in mind that if rightAlign is also set then both
     rightFill and rightAlign are ignored.

rightAlign 0 || 1 || NOTHING
     Set right align or retrieve its value.  Text is aligned with the right
     side of the margin.  Keep in mind that if rightFill is also set then
     both rightFill and rightAlign are ignored.

justify 0 || 1 || NOTHING
     Set justify or retrieve its value.  Text is aligned with both margins,
     adding extra spaces as necessary to align text with left and right
     margins.  Keep in mind that if either of rightAlign or rightFill are
     set then justify is ignored, even if both are set in which case they
     are all ignored.

text \@ARRAY || NOTHING
     Pass in a reference to your text, or an anonymous array of text that
     you want the routines to manipulate.  Returns the text held in the
     object.

hangingIndent 0 || 1 || NOTHING
     Use hanging indents in front of a paragraph, returns current value of
     attribute.  This is also called a tagged paragraph.

hangingText \@ARRAY || NOTHING
     The text that will be displayed in front of each paragraph, if you
     call format then only the first element is used, if you call
     paragraphs then paragraphs cycles through all of them.  If you have
     more paragraphs than elements in your array than the remainder of the
     paragraphs will not have a hanging indented text.  Pass a reference to
     your array.  This is also called a tagged paragraph.

noBreak 0 || 1 || NOTHING
     Set whether you want to use the non-breaking space feature.

noBreakRegex \%HASH || NOTHING
     Pass in a reference to your hash that would hold the regexes on which
     not to break.  Returns the hash.  eg.

          {'^Mrs?\.$' => '^\S+$','^\S+$' => '^(?:S|J)r\.$'}

     don't break names such as Mr. Jones, Mrs. Jones, Jones Jr.

     The breaking algorithm is simple.  If there should not be a break at
     the current end of sentence, then a backtrack is done till there are
     two words on which breaking is allowed.  If no two such words are
     found then the end of sentence is broken anyhow.  If there is a
     single word on current line then no backtrack is done and the word is
     stuck on the end.  This is so you can make a list of names for
     example.

extraSpace 0 || 1 || NOTHING
     Add extra space after end of sentence, normally format would add 1
     space after end of sentence, if this is set to 1 then 2 spaces are
     used.  Abbreviations are not followed by two spaces.  There are a few
     internal abbreviations and you can add your own to the object with
     abbrevs

abbrevs \%HASH || @ARRAY || NOTHING
     Add to the current abbreviations, takes a reference to your hash or an
     array of abbreviations, if called a second time the original reference
     is removed and replaced by the new one.  Returns the current INTERNAL
     abbreviations.

EXAMPLE
=======

     use Text::Format;

     $text = new Text::Format;
     $text->rightFill(1);
     $text->columns(65);
     $text->tabstop(4);
     print $text->format("a line to format to an indented regular
             paragraph using 65 character wide display");
     print $text->paragraphs("paragraph one","paragraph two");
     print $text->center("hello world","nifty line 2");
     print $text->expand("\t\thello world\n","hmm,\twell\n");
     print $text->unexpand("    hello world\n","    hmm");
     $text->config({columns => 132, tabstop => 4});

     $text = Text::Format->new();
     print $text->format(@text);
     print $text->paragraphs(@text);
     print $text->center(@text);
     print $text->format([<FILEHANDLE>]);
     print $text->format([$fh->getlines()]);
     print $text->paragraphs([<FILEHANDLE>]);
     print $text->expand(@text);
     print $text->unexpand(@text);

     $text = Text::Format->new
         ({tabstop => 4,bodyIndent => 4,text => \@text});
     print $text->format();
     print $text->paragraphs();
     print $text->center();
     print $text->expand();
     print $text->unexpand();

     print Text::Format->new({columns => 95})->format(@text);

BUGS
====

   Line length can exceed columns specified if columns is set to a small
number and long words plus leading whitespace exceed column length
specified.  Actually I see this as a feature since it can be used to make
up a nice word list.

AUTHOR
======

   Gabor Egressy *gabor@vmunix.com*

   Copyright (c) 1998 Gabor Egressy.  All rights reserved.  All wrongs
reversed.  This program is free software; you can redistribute and/or
modify it under the same terms as Perl itself.

ACKNOWLEDGMENTS
===============

   *Tom Phoenix* found bug with code for two spaces at end of sentence and
provided code fragment for a better solution, some preliminary suggestions
on design

   *Brad Appleton* suggesting and explanation of hanging indents,
suggestion for non-breaking whitespace, general suggestions with regard to
interface design

   *Byron Brummer* suggestion for better interface design and object
design, code for better implementation of getting abbreviations

   *H. Merijn Brand* suggestion for justify feature and original code for
doing the justification.  I changed the code to take into account the
extra space at end of sentence feature.

TODO
====


File: pm.info,  Node: Text/German,  Next: Text/Graphics,  Prev: Text/Format,  Up: Module List

German grundform reduction
**************************

NAME
====

   Text::German - German grundform reduction

SYNOPSYS
========

   `use Text::German;'

   `$stem = Text::German::reduce($word)'

DESCRIPTION
===========

   This is a rather incomplete implementaion of work done by Gudrun
Putze-Meier `<gudrun.pm@t-online.de>'. I have to confess that I never read
her original paper. So all credit belongs to her, all bugs are mine. I
tried to get some insight from an implementation of two students of mine.
They remain anonymous because their work was the wost piece of code I ever
saw. My code behaves mostly as their implementation did except it is about
75 times faster.

AUTHOR
======

   Ulrich Pfeifer `<pfeifer@ls6.informatik.uni-dortmund.de>'


File: pm.info,  Node: Text/Graphics,  Next: Text/Header,  Prev: Text/German,  Up: Module List

A text graphics rendering toolkit
*********************************

NAME
====

   Text::Graphics - A text graphics rendering toolkit

DESCRIPTION
===========

   This is a toolkit for rendering plain text via an API like that used
for graphics rendering in GUI toolkits.  This package might be used when
you want to do sophisticated rendering of plain text, e.g., for graphing,
creating of complex forms for email and fax, and so on.

SYNOPSIS
========

     use Text::Graphics;
     my $text = "A text graphics rendering toolkit.\n";
     my $page = Text::Graphics::Page->new( 20, 10);
     my $panel0 = Text::Graphics::BorderedPanel->new( 20, 10);
     my $panel1 =
      Text::Graphics::FilledBorderedTextPanel->new($text x 3, 25, 12);
     $panel0->setBackground("#");
     $panel1->setBackground(" ");
     $page->add($panel0);
     $page->add($panel1, 5, 2);
     $page->render();
     
     +-------------------+
     |###################|
     |####+--------------+
     |####|A text graphic|
     |####|rendering tool|
     |####|text graphics |
     |####|toolkit. A tex|
     |####|graphics rende|
     |####|toolkit.      |
     |####|              |
     +----+--------------+

User API
========

`Text::Graphics::Page'
----------------------

   Class to represent a page.

`new (width, height)'
     Construct a new page with the specified width and height.

`add (Panel, x_offset, y_offset)'
     Add a Panel at the specified offset.

`render ( [ scalar_reference ] )'
     Render the page.  If an argument is given, it is assumed to be a
     SCALAR REFERENCE, and rendering will be done to such reference.  e.g.,
     if you want to render to $buf, you might do

          $w->render(\ $buf);

     If no argument to render() is provided, then rendering is simply done
     to STDOUT using print.

`Text::Graphics::Panel'
-----------------------

   Class to represent a panel.

`new (width, height)'
     Construct a new panel with the specified width and height.

`add (Panel, x_offset, y_offset)'
     Add a Panel at the specified offset.  This child panel is contained
     within its parent and will not extend beyond the parents boundaries.

`setBackground ( background )'
     Set the background on the panel to the specified char.

`getSize ()'
     Get the size of a panel.  This method is a hook for layout managers.
     E.g., If you set up a wrapped text panel with height 0, then call
     getSize(), then it will return the same width but the new "desired"
     height.  (If you are interested in how to write a layout manager on
     top of this code, please contact me (SF) as I have done so but have
     not released it.)

`setSize (width, height)'
     Set the size of a panel.  This method is a hook for layout managers.

`getOffset ()'
     get the offset of a panel.  This method is a hook for layout managers.

`setOffset (x_offset, y_offset)'
     set the offset of a panel.  This method is a hook for layout managers.

Subclassing
===========

   Most of the work you might do with this module will be by subclassing
panel.  The idea is you make a new panel, like LinePanel, that has a
constructor setting character to draw and the start and end coordinates
for the line.  Then, in the LinePanels `_drawSelf(gc)' routine, it calls
on the gc to draw a line:

     package LinePanel;
     use vars qw (@ISA);
     @ISA = qw (Panel);

     sub new {
      my $this = {};
      bless $this, shift;
      $this->{char} = shift;
      $this->{startx} = shift;
      $this->{starty} = shift;
      $this->{endx} = shift;
      $this->{endy} = shift;
      return $this;
     }

     sub _drawSelf {
      my $this = shift;
      my $gc = shift;

     $gc->drawLine($this->{char},
                   $this->{startx}, $this->{starty},
     		$this->{endx}, $this->{endy});

     }

   There are some other subclasses included, particularly those for text
handling.

   Actually the `drawLine()' method for the GraphicsContext is not
included b/c I just do not need it, though I have a mostly working version
if anyone is interested (it is not complicated =).

   GraphicsContext does include the following methods, however:

`drawBorder(x_offset, y_offset, width, height)'
     Draw a border with the specified coordinates.

`fillRect(char, x_offset, y_offset, width, height)'
     Fill the specified rectangle with the specified character.  Note that
     filling with " " is a good way to get an "opaque" panel.

`drawString(string, x_offset, y_offset)'
     Draw the specified string at the specified offset.  If you want to
     control the width then you probably want to look at FilledTextPanel.

AUTHORS
=======

     Stephen Farrell <stephen@farrell.org>
     Jeremy Mayes


