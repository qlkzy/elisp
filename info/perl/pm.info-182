This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: HTTP/File,  Next: HTTP/Headers,  Prev: HTTP/Date,  Up: Module List

Routines to deal with HTML input type file.
*******************************************

NAME
====

   HTTP::File - Routines to deal with HTML input type file.

SYNOPSIS
========

CGI.pm example
--------------

   `savepage.html' looks like this:

   <H1>Upload a webpage</H1>

   <FORM METHOD=POST ENCTYPE="multipart/form-data"
action="/cgi-bin/webplugin/savepage.cgi">

   <INPUT TYPE=file name=FILE_UPLOAD size=35>

   <INPUT TYPE=submit NAME=Action VALUE="Upload Ahoy!">

   </FORM>

   `savepage.cgi' looks like this:

   #!/usr/bin/perl

   use CGI; use HTTP::File;

   $cgi = new CGI;

   $upload_path='/tmp';

   $raw_file = $cgi->param('FILE_UPLOAD'); $basename =
HTTP::File::upload($raw_file,$upload_path);

   print $cgi->header; print $cgi->start_html;

   print "$basename upload successfully.<BR>Upload path: "; print
$upload_path ? $upload_path : '/tmp';

   print $cgi->end_html;

HTML::Mason example
-------------------

   <FORM METHOD=POST ENCTYPE="multipart/form-data"
action="receive-upload.html"> <INPUT TYPE=file name=PHOTO_FILE size=35>
</FORM>

   ... then in receive-upload.html

   <%init>     use HTTP::File; </%init>

   <%perl> $output_path="/var/spool"; $raw_file=$ARGS{PHOTO_FILE};
HTTP::File::upload($raw_file, $output_path); </%perl>

DESCRIPTION
===========

   HTTP::File is a module to facilitate file uploads from HTML file
input.It detects the basename of the raw file across MacOS, Windows, and
Unix/Linux platforms.

sub platform
------------

   Uses a subset of the functionality of HTTP::Headers::UserAgent to
determine the type of machine that uploaded the file.

sub upload
----------

   Upload RAW_FILE to the local disk to a specified PATH, or to /tmp if
PATH is not specified.

     Returns the basename of the uploaded file;

   As of version 3.1, there are two new args to upload():

   * $debug

     A third argument, $debug, if non-zero will send debugging information
     to STDERR.

   * $kludge

     A fourth argument, `$kludge', if non-zero, will also write the read
     data to a file in the temp directory.

AUTHOR
======

   Terrence Brannon tbone@cpan.org


File: pm.info,  Node: HTTP/Headers,  Next: HTTP/Headers/UserAgent,  Prev: HTTP/File,  Up: Module List

Class encapsulating HTTP Message headers
****************************************

NAME
====

   HTTP::Headers - Class encapsulating HTTP Message headers

SYNOPSIS
========

     require HTTP::Headers;
     $h = new HTTP::Headers;

DESCRIPTION
===========

   The `HTTP::Headers' class encapsulates HTTP-style message headers.  The
headers consist of attribute-value pairs, which may be repeated, and which
are printed in a particular order.

   Instances of this class are usually created as member variables of the
HTTP::Request and `HTTP::Response' classes, internal to the library.

   The following methods are available:

$h = new HTTP::Headers
     Constructs a new `HTTP::Headers' object.  You might pass some initial
     attribute-value pairs as parameters to the constructor.  *E.g.*:

          $h = new HTTP::Headers
              Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
              Content_Type => 'text/html; version=3.2',
              Content_Base => 'http://www.sn.no/';

$h->header($field [=> $value],...)
     Get or set the value of a header.  The header field name is not case
     sensitive.  To make the life easier for perl users who wants to avoid
     quoting before the => operator, you can use '_' as a synonym for '-'
     in header names (this behaviour can be suppressed by setting
     $HTTP::Headers::TRANSLATE_UNDERSCORE to a FALSE value).

     The header() method accepts multiple ($field => $value) pairs, so you
     can update several fields with a single invocation.

     The optional $value argument may be a scalar or a reference to a list
     of scalars. If the $value argument is undefined or not given, then the
     header is not modified.

     The old value of the last of the $field values is returned.
     Multi-valued fields will be concatenated with "," as separator in
     scalar context.

          $header->header(MIME_Version => '1.0',
          		 User_Agent   => 'My-Web-Client/0.01');
          $header->header(Accept => "text/html, text/plain, image/*");
          $header->header(Accept => [qw(text/html text/plain image/*)]);
          @accepts = $header->header('Accept');

$h->scan(\&doit)
     Apply a subroutine to each header in turn.  The callback routine is
     called with two parameters; the name of the field and a single value.
     If the header has more than one value, then the routine is called once
     for each value.  The field name passed to the callback routine has
     case as suggested by HTTP Spec, and the headers will be visited in the
     recommended "Good Practice" order.

$h->as_string([$endl])
     Return the header fields as a formatted MIME header.  Since it
     internally uses the scan() method to build the string, the result
     will use case as suggested by HTTP Spec, and it will follow
     recommended "Good Practice" of ordering the header fieds.  Long header
     values are not folded.

     The optional parameter specifies the line ending sequence to use.  The
     default is `"\n"'.  Embedded "\n" characters in the header will be
     substitued with this line ending sequence.

$h->push_header($field, $val)
     Add a new field value of the specified header.  The header field name
     is not case sensitive.  The field need not already have a value.
     Previous values for the same field are retained.  The argument may be
     a scalar or a reference to a list of scalars.

          $header->push_header(Accept => 'image/jpeg');

$h->remove_header($field,...)
     This function removes the headers with the specified names.

$h->clone
     Returns a copy of this HTTP::Headers object.

CONVENIENCE METHODS
===================

   The most frequently used headers can also be accessed through the
following convenience methods.  These methods can both be used to read and
to set the value of a header.  The header value is set if you pass an
argument to the method.  The old header value is always returned.

   Methods that deal with dates/times always convert their value to system
time (seconds since Jan 1, 1970) and they also expect this kind of value
when the header value is set.

$h->date
     This header represents the date and time at which the message was
     originated. *E.g.*:

          $h->date(time);  # set current date

$h->expires
     This header gives the date and time after which the entity should be
     considered stale.

$h->if_modified_since
$h->if_unmodified_since
     This header is used to make a request conditional.  If the requested
     resource has (not) been modified since the time specified in this
     field, then the server will return a `"304 Not Modified"' response
     instead of the document itself.

$h->last_modified
     This header indicates the date and time at which the resource was last
     modified. *E.g.*:

          # check if document is more than 1 hour old
          if ($h->last_modified < time - 60*60) {
          	...
          }

$h->content_type
     The Content-Type header field indicates the media type of the message
     content. *E.g.*:

          $h->content_type('text/html');

     The value returned will be converted to lower case, and potential
     parameters will be chopped off and returned as a separate value if in
     an array context.  This makes it safe to do the following:

          if ($h->content_type eq 'text/html') {
             # we enter this place even if the real header value happens to
             # be 'TEXT/HTML; version=3.0'
             ...
          }

$h->content_encoding
     The Content-Encoding header field is used as a modifier to the media
     type.  When present, its value indicates what additional encoding
     mechanism has been applied to the resource.

$h->content_length
     A decimal number indicating the size in bytes of the message content.

$h->content_language
     The natural language(s) of the intended audience for the message
     content.  The value is one or more language tags as defined by RFC
     1766.  Eg. "no" for Norwegian and "en-US" for US-English.

$h->title
     The title of the document.  In libwww-perl this header will be
     initialized automatically from the <TITLE>...</TITLE> element of HTML
     documents.  *This header is no longer part of the HTTP standard.*

$h->user_agent
     This header field is used in request messages and contains information
     about the user agent originating the request.  *E.g.*:

          $h->user_agent('Mozilla/1.2');

$h->server
     The server header field contains information about the software being
     used by the originating server program handling the request.

$h->from
     This header should contain an Internet e-mail address for the human
     user who controls the requesting user agent.  The address should be
     machine-usable, as defined by RFC822.  E.g.:

          $h->from('Gisle Aas <aas@sn.no>');

$h->referer
     Used to specify the address (URI) of the document from which the
     requested resouce address was obtained.

$h->www_authenticate
     This header must be included as part of a "401 Unauthorized" response.
     The field value consist of a challenge that indicates the
     authentication scheme and parameters applicable to the requested URI.

$h->proxy_authenticate
     This header must be included in a "407 Proxy Authentication Required"
     response.

$h->authorization
$h->proxy_authorization
     A user agent that wishes to authenticate itself with a server or a
     proxy, may do so by including these headers.

$h->authorization_basic
     This method is used to get or set an authorization header that use the
     "Basic Authentication Scheme".  In array context it will return two
     values; the user name and the password.  In scalar context it will
     return *"uname:password"* as a single string value.

     When used to set the header value, it expects two arguments.  *E.g.*:

          $h->authorization_basic($uname, $password);

     The method will croak if the $uname contains a colon ':'.

$h->proxy_authorization_basic
     Same as authorization_basic() but will set the "Proxy-Authorization"
     header instead.

COPYRIGHT
=========

   Copyright 1995-1998 Gisle Aas.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/Headers/UserAgent,  Next: HTTP/Headers/Util,  Prev: HTTP/Headers,  Up: Module List

Routine to detect web browser platform from User-Agent HTTP Header
******************************************************************

NAME
====

   HTTP::Headers::UserAgent - Routine to detect web browser platform from
User-Agent HTTP Header

SYNOPSIS
========

     use HTTP::Headers::UserAgent;
     $Platform = new HTTP::Headers::UserAgent::GetPlatform ($ENV{HTTP_USER_AGENT});

DESCRIPTION
===========

   The route will parse parameter string, which must be in HTTP User-Agent
header form, and return the browser platform. The returned value is string
with one of the following values:

     Win95, Win98, WinNT, UNIX, MAC, Win3x, OS2, Linux

   If the platform is not one of these (i.e. one of the robots), the
returned string is empty.

NOTES
=====

   Part of "WWW Cyrillic Encoding Suite" Get docs and newest version from
http://www.neystadt.org/cyrillic/

   Copyright (c) 1997-98, John Neystadt <http://www.neystadt.org/john/>.
You may install this script on your web site for free. To obtain permision
for or any other usage contact john@neystadt.org.

   Drop me a line if you deploy this script on your site.

AUTHOR
======

   Leonid Neishtadt <leonid@neystadt.org>, John Neystadt
<john@neystadt.org>

SEE ALSO
========

   perl(1).


File: pm.info,  Node: HTTP/Headers/Util,  Next: HTTP/Lite,  Prev: HTTP/Headers/UserAgent,  Up: Module List

Header value parsing utility functions
**************************************

NAME
====

   HTTP::Headers::Util - Header value parsing utility functions

SYNOPSIS
========

     use HTTP::Headers::Util qw(split_header_words);
     @values = split_header_words($h->header("Content-Type"));

DESCRIPTION
===========

   This module provides a few functions that helps parsing and
construction of valid HTTP header values.  None of the functions are
exported by default.

   The following functions are available:

split_header_words( @header_values )
     This function will parse the header values given as argument into a
     list of anonymous arrays containing key/value pairs.  The function
     knows how to deal with ",", ";" and "=" as well as quoted values after
     "=".  A list of space separated tokens are parsed as if they were
     separated by ";".

     If the @header_values passed as argument contains multiple values,
     then they are treated as if they were a single value separated by
     comma ",".

     This means that this function is useful for parsing header fields that
     follow this syntax (BNF as from the HTTP/1.1 specification, but we
     relax the requirement for tokens).

          headers           = #header
          header            = (token | parameter) *( [";"] (token | parameter))

          token             = 1*<any CHAR except CTLs or separators>
          separators        = "(" | ")" | "<" | ">" | "@"
                            | "," | ";" | ":" | "\" | <">
                            | "/" | "[" | "]" | "?" | "="
                            | "{" | "}" | SP | HT

          quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
          qdtext            = <any TEXT except <">>
          quoted-pair       = "\" CHAR

          parameter         = attribute "=" value
          attribute         = token
          value             = token | quoted-string

     Each header is represented by an anonymous array of key/value pairs.
     The value for a simple token (not part of a parameter) is undef.
     Syntactically incorrect headers will not necessary be parsed as you
     would want.

     This is easier to describe with some examples:

          split_header_words('foo="bar"; port="80,81"; discard, bar=baz')
          split_header_words('text/html; charset="iso-8859-1");
          split_header_words('Basic realm="\"foo\\bar\""');

     will return

          [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
          ['text/html' => undef, charset => 'iso-8859-1']
          [Basic => undef, realm => '"foo\bar"']

join_header_words( @arrays )
     This will do the opposite of the conversion done by
     split_header_words().  It takes a list of anonymous arrays as
     arguments (or a list of key/value pairs) and produces a single header
     value.  Attribute values are quoted if needed.

     Example:

          join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
          join_header_words("text/plain" => undef, charset => "iso-8859/1");

     will both return the string:

          text/plain; charset="iso-8859/1"

COPYRIGHT
=========

   Copyright 1997-1998, Gisle Aas

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/Lite,  Next: HTTP/Message,  Prev: HTTP/Headers/Util,  Up: Module List

Lightweight HTTP implementation
*******************************

NAME
====

   HTTP::Lite - Lightweight HTTP implementation

SYNOPSIS
========

     use HTTP::Lite;
     $http = new HTTP::Lite;
     $req = $http->request("http://www.cpan.org/")
         or die "Unable to get document: $!";
     print $http->body();

DESCRIPTION
===========

     HTTP::Lite is a stand-alone lightweight HTTP/1.1
     implementation for perl.  It is not intended to replace LWP,
     but rather is intended for use in situations where it is
     desirable to install the minimal number of modules to
     achieve HTTP support, or where LWP is not a good candidate
     due to CPU overhead, such as slower processors.

     HTTP::Lite is ideal for CGI (or mod_perl) programs or for
     bundling for redistribution with larger packages where only
     HTTP GET and POST functionality are necessary.

     HTTP::Lite supports basic POST and GET operations only.  As
     of 0.2.1, HTTP::Lite supports HTTP/1.1 and is compliant with
     the Host header, necessary for name based virtual hosting.
     Additionally, HTTP::Live now supports Proxies.

     If you require more functionality, such as FTP or HTTPS,
     please see libwwwperl (LWP).  LWP is a significantly better
     and more comprehensive package than HTTP::Lite, and should
     be used instead of HTTP::Lite whenever possible.

CONSTRUCTOR
===========

new
     This is the constructor for HTTP::Lite.  It presently takes no
     arguments.  A future version of HTTP::Lite might accept parameters.

METHODS
=======

request ( URL )
     Initiates a request to the specified URL.

     Returns undef if an I/O error is encountered, otherwise the HTTP
     status code will be returned.  200 series status codes represent
     success, 300 represent temporary errors, 400 represent permanent
     errors, and 500 represent server errors.

     See `http://www.w3.org/Protocols/HTTP/HTRESP.html' for detailled
     information about HTTP status codes.

prepare_post
add_req_header ( $header, $value ) =item get_req_header ( $header ) =item delete_req_header ( $header )
     Add, Delete, or a HTTP header(s) for the request.  These functions
     allow you to override any header.  Presently, Host, User-Agent,
     Content-Type, Accept, and Connection are pre-defined by the
     HTTP::Lite module.  You may not override Host, Connection, or Accept.

     To provide (proxy) authentication or authorization, you would use:

          use HTTP::Lite;
          use MIME::Base64;
          $http = new HTTP::Lite;
          $encoded = encode_base64('username:password');
          $http->add_req_header("Authorization", $encoded);

     NOTE: The present implementation limits you to one instance of each
     header.

body
     Returns the body of the document retured by the remote server.

headers_array
     Returns an array of the HTTP headers returned by the remote server.

headers_string
     Returns a string representation of the HTTP headers returned by the
     remote server.

get_header ( $header )
     Returns an array of values for the requested header.

     NOTE: HTTP requests are not limited to a single instance of each
     header.  As a result, there may be more than one entry for every
     header.

protocol
     Returns the HTTP protocol identifier, as reported by the remote
     server.  This will generally be either HTTP/1.0 or HTTP/1.1.

proxy ( $proxy_server )
     The URL or hostname of the proxy to use for the next request.

status
     Returns the HTTP status code returned by the server.  This is also
     reported as the return value of request().

status_message
     Returns the textual description of the status code as returned by the
     server.  The status string is not required to adhere to any
     particular format, although most HTTP servers use a standard set of
     descriptions.

response
     Returns the entire unparsed HTTP response as returned by the server.

reset
     You must call this prior to re-using an HTTP::Lite handle, otherwise
     the results are undefined.

EXAMPLES
========

     # Get and print out the headers and body of the CPAN homepage
     use HTTP::Lite;
     $http = new HTTP::Lite;
     $req = $http->request("http://www.cpan.org/")
         or die "Unable to get document: $!";
     die "Request failed ($req): ".$http->status_message()
       if $req ne "200";
     @headers = $http->headers_array();
     $body = $http->body();
     foreach $header (@headers)
     {
       print "$header$CRLF";
     }
     print "$CRLF";
     print "$body$CRLF";

     # POST a query to the dejanews USENET search engine
     use HTTP::Lite;
     $http = new HTTP::Lite;
     %vars = (
              "QRY" => "perl",
              "ST" => "MS",
              "svcclass" => "dncurrent",
              "DBS" => "2"
             );
     $http->prepare_post(\%vars);
     $req = $http->request("http://www.deja.com/dnquery.xp")
       or die "Unable to get document: $!";
     print "req: $req\n";
     print $http->body();

UNIMPLEMENTED
=============

     - FTP
     - HTTPS (SSL)
     - Authenitcation/Authorizaton/Proxy-Authorization
       are not directly supported, and require MIME::Base64.
     - Redirects (Location) are not automatically followed
     - multipart/form-data POSTs are not supported (necessary for
       File uploads).
     
     =head1 BUGS

     Some bugs likely still exist.  This is a beta version.
     
     Large requests are stored in ram, potentially more than once
     due to HTTP/1.1 chunked transfer mode support.  A future
     version of this module may support writing requests to a
     filehandle to avoid excessive disk use.

ACKNOWLEDGEMENTS
================

     Marcus I. Ryan	shad@cce-7.cce.iastate.edu
     michael.kloss@de.adp.com

AUTHOR
======

   Roy Hooper <rhooper@thetoybox.org>

SEE ALSO
========

   *Note LWP: LWP, RFC 2068 - HTTP/1.1 -http://www.w3.org/

COPYRIGHT
=========

   Copyright (c) 2000 Roy Hooper.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/Message,  Next: HTTP/Monkeywrench,  Prev: HTTP/Lite,  Up: Module List

Class encapsulating HTTP messages
*********************************

NAME
====

   HTTP::Message - Class encapsulating HTTP messages

SYNOPSIS
========

     package HTTP::Request;  # or HTTP::Response
     require HTTP::Message;
     @ISA=qw(HTTP::Message);

DESCRIPTION
===========

   A `HTTP::Message' object contains some headers and a content (body).
The class is abstract, i.e. it only used as a base class for HTTP::Request
and `HTTP::Response' and should never instantiated as itself.

   The following methods are available:

$mess = new HTTP::Message;
     This is the object constructor.  It should only be called internally
     by this library.  External code should construct HTTP::Request or
     `HTTP::Response' objects.

$mess->clone()
     Returns a copy of the object.

$mess->protocol([$proto])
     Sets the HTTP protocol used for the message.  The protocol() is a
     string like "HTTP/1.0" or "HTTP/1.1".

$mess->content([$content])
     The content() method sets the content if an argument is given.  If no
     argument is given the content is not touched.  In either case the
     previous content is returned.

$mess->add_content($data)
     The add_content() methods appends more data to the end of the previous
     content.

$mess->content_ref
     The content_ref() method will return a reference to content string.
     It can be more efficient to access the content this way if the content
     is huge, and it can be used for direct manipulation of the content,
     for instance:

          ${$res->content_ref} =~ s/\bfoo\b/bar/g;

$mess->headers;
     Return the embedded HTTP::Headers object.

$mess->headers_as_string([$endl])
     Call the HTTP::Headers->as_string() method for the headers in the
     message.

   All unknown `HTTP::Message' methods are delegated to the
`HTTP::Headers' object that is part of every message.  This allows
convenient access to these methods.  Refer to *Note HTTP/Headers:
HTTP/Headers, for details of these methods:

     $mess->header($field => $val);
     $mess->scan(\&doit);
     $mess->push_header($field => $val);
     $mess->remove_header($field);

     $mess->date;
     $mess->expires;
     $mess->if_modified_since;
     $mess->if_unmodified_since;
     $mess->last_modified;
     $mess->content_type;
     $mess->content_encoding;
     $mess->content_length;
     $mess->content_language
     $mess->title;
     $mess->user_agent;
     $mess->server;
     $mess->from;
     $mess->referer;
     $mess->www_authenticate;
     $mess->authorization;
     $mess->proxy_authorization;
     $mess->authorization_basic;
     $mess->proxy_authorization_basic;

COPYRIGHT
=========

   Copyright 1995-1997 Gisle Aas.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/Monkeywrench,  Next: HTTP/Negotiate,  Prev: HTTP/Message,  Up: Module List

Web testing application
***********************

NAME
====

   HTTP::Monkeywrench - Web testing application

SYNOPSIS
========

     use HTTP::Monkeywrench;
      $session = [
        {
        name  =Greater_Than_Special_Sequence 'URL Name',
        url   =Greater_Than_Special_Sequence 'http://url',
        }
      ];
      HTTP::Monkeywrench-Greater_Than_Special_Sequencetest($session);

REQUIRES
========

     CGI
     Net::SMTP
     HTTP::Cookies
     LWP::UserAgent
     Time::HiRes
     Data::Dumper

EXPORTS
=======

   None

DESCRIPTION
===========

   HTTP::Monkeywrench is a test-harness application to test the integrity
of a user's path through a web site.

   To run HTTP::Monkeywrench->test(), first set up a Perl script that
contains sessions (described below), settings if desired (also described
below), and a call to HTTP::Monkeywrench->test(), passing it the settings
hashref first, followed by the desired session hashrefs you want to test.
HTTP::Monkeywrench->test($settings, $session1,... $sessionN)

   HTTP::Monkeywrench can also be used in an object-oriented fashion -
simply take the result of HTTP::Monkeywrench->new (optionally passing the
settings hashref) and call the test() method against it as above
(optionally omitting the settings hashref.)

   Each session arrayref contains one or more hashrefs, called clicks,
which contain descriptive elements of a specific web page to be tested.
The elements are described below under SESSION.

SESSION
=======

`$session1' (ARRAYREF of HASHREFS)
     A session is an arrayref of complex hashrefs that can be sent to the
     `HTTP::Monkeywrench->test' application to perform tests on a website
     as a virtual user.

     The following keys can be in each 'Click' hashref.  Fields with a "*"
     are required:

name (SCALAR)
     A name to visually reference that 'click' in the reports

(SCALAR)
     The url for Monkeywrench to test for that click.

params (HASHREF)
     The params to send to dynamic pages and cgi's.  Params should be set
     up as such: { username => 'joe', password => 'blow' }

method (SCALAR)
     'method' should be either 'POST' or 'GET'. If method is left blank,
     method will default to 'GET'.

auth (ARRAYREF)
     'auth' is the username and password if the site your are testing is
     password protected. 'auth' params must be passed to each element of a
     session that is accessing the same site.  Example:
     ['username','password']

success_res (ARRAYREF)
     An arrayref of items for Monkeywrench to test for their existence.
     Each element of the array can either be a text string or a regexp
     object.  If a string from success_res is not found in the page,
     Monkeywrench will report an error.  EXAMPLE:
     ['string',qr/regexp_object/,'etc']

error_res (ARRAYREF)
     The same as success_res, except that an error will only be reported
     if strings in error_res ARE found on the page being tested.

cookies (ARRAYREF of ARRAYREFS)
     A preset cookie can be sent to a page. In order to send a cookie to a
     page the following elements should be included as an arrayref:

     [$version, $key, $val, $path, $domain, $port, $path_spec, $secure,
     $maxage, $discard, \%rest]

     An example cookie would look like:

     [['0', 'sessnum', 'expires&2592000&type&consumer',
     '/','cookiemonster.org', '8014', ", ", '2000-09-11 16:15:15Z', "]],

acceptcookie (BIT)
     A numeric flag set to 1 or 0 to tell Monkeywrench if it should accept
     and save a cookie passed from a server.  Default is 0, cookies will
     not be accepted.

sendcookie (BIT)
     A numeric flag set to 1 or 0 to tell Monkeywrench to send a saved or
     pre made cookie back to the server. Default is 0, cookies will not be
     sent.

showhtml (BIT)
     A numeric flag set to 1 or 0 to have the source html of a page
     displayed within the report. When set to 1 the reports can get messy
     if the page is heavy on html.

SETTINGS HASH
=============

$settings (HASHREF)
     The settings hash is optional as are each of the elements of
     $settings.  Elements that are not declared or set are defaulted to 0
     (off).

match_detail (BIT)
     A numeric flag set to 1 or 0. If set to 1 Match detail shows all of
     the reports of success_res and error_res no matter if they pass or
     fail.

show_cookies (BIT)
     A numeric flag set to 1 or 0. If set to 1 show_cookies will show all
     the cookies in the report, either passed from the session or sent
     from the server.

smtp_server (SCALAR)
     The SMTP server to be used by Net::SMTP. Only required if user wants
     output of Monkeywrench to be sent to an email address.

send_mail (ARRAYREF)
     The send_mail arrayref is also only required if user plans on sending
     output to one or more email addresses.

send_if_err (BIT)
     The send_if_err bit is a flag that should be set to either 1 or 0 and
     is only used if the user wants the Monkeywrench output sent via email.
     If set to 1 the output will only be sent to the email address(es) in
     the event of a failure in the success or error checking or any result
     code other than 200.

print_results (BIT)
     If set to 1, the results will be printed to the screen. If set to 0
     nothing will be printed to the screen. The default setting is 1.

METHODS
=======

new ( [ \%settings ] )
     Returns a new Monkeywrench object.  Optionally takes a settings hash.

`settings' ( $self, [ \%settings ] )
     Returns settings hash.  Passing hashref will change settings in
     object.

test ( [ \%settings ], \@session [ , \@session, ... ] )
     Usable as both a static method and object method.  Runs a series
     Monkeywrench tests on a web server using the parameters set forth in
     the sessions you pass.

`get_response' ($click)
     get_response is a recursive method that loops through all possible
     redirects until a final response is returned, which is then returned
     to the caller.

`send_monkeymail' ( $content, \$smtp_server \@address )
     send_monkeymail is called if the config script has an email address
     and depending on how send_if_err is setup.  $content is the output of
     the session(s) called by the config script and the \@address arrayref
     contains the address(es) that the output will be sent to. $smtp_server
     is the smtp server for Net::SMTP to connect to and is also required
     in order for send_monkeymail to be called.

REVISION HISTORY  $Log: Monkeywrench.pm,v $  Revision 1.13  2000/09/12 00:14:54  david  More POD fixes.
=======================================================================================================

     Revision 1.12  2000/09/08 01:40:23  greg
     removed C<> surrounding SYNOPSIS as it was breaking pod2html.

     Revision 1.10  2000/09/08 01:01:10  greg
     fixed POD

     Revision 1.9  2000/09/08 00:37:49  david
      - Moved and rearranged some POD.

     Revision 1.8  2000/09/07 22:26:26  derek
      - Removed _init method and incoporated code into new method.
      - Added a return obj that is populated during the test method and is returned
        at the end of the test method.
      - Other misc code changes for efficiency and readability.
      - Fixed minor POD problems and added documentation for new settings.

     Revision 1.7  2000/09/06 21:49:35  david
      - Changed POD formatting (looks better in a POD reader, not in an editor.)
      - added some extra sanity to send_monkeymail()

     Revision 1.6  2000/09/01 23:10:51  derek
      - Documentation fixes, additions.

     Revision 1.5  2000/08/23 21:25:37  derek
      - Added send_monkeymail method to handle sending reports via email.
      - Modified test method to put all output data into $content variable instead
        of printing each chunk separately.
      - Added documentation for send_monkeymail method, new oop features, and new
        settings options for the config files.

     Revision 1.4  2000/08/03 01:03:34  david
      now uses strict (no change required)
     OO enhancements
      - initialization portion of test() method moved to methods new(), _init(),
        and settings(), test() works as an object method, but still works as a
        static method. Objects are reusable (you can call test any number of times.)
      - settings(), cgi(), cookie_jar(), and ua() access methods set up to make
        more extensible

     Revision 1.3  2000/02/28 23:52:07  derek
      - Added and changed lots of POD
      - Added new report element, Code, to display the response code of the page

     Revision 1.2  2000/02/18 03:36:18  derek
      - Fixed logic problem in reading the settings from what user passes
      - Fixed minor display issue

     Revision 1.1.1.1  2000/02/17 21:04:05  derek
      - Start

SEE ALSO
========

   perl(1).

KNOWN BUGS
==========

   None

TODO
====

   * *Recorder Utility*

   * *Recorder Utility* - Currently, scenarios must be created
     painstakenly by editing complex conf files.  A better solution would
     be a CGI or mod_perl handler which 'watches' you surf a site and
     creates the  configuration script for you.

   * *Link checking ability* (checks integrity of all links on the pages
     it checks)

   * *HTML checking* - Checks the HTML on pages for HTML compliance (you
     can optionally specify the HTML w3c spec you want to comply to).  We
     might integrate WebLINT or other packages which do this  (they may
     even check links).

   * *Load Testing* - Most load testing tools hit one page over and over
     measuring how many simultaneous requests per second a site can
     handle. This approach is highly flawed since it does not approximate
     true traffic on your site where lots of people might be performing
     different actions on your site at the same time (not just pounding
     one page.)  Monkeywrench is well suited to being a true load testing
     tool where multiple sessions,  mimicking actual users doing lots of
     different things on your site, are run  simultaneously to see how
     many requests a second your site can handle under more realistic
     conditions.  We envision adding a client server componant to the load
     balancing tool that would let you run Monkeywrench clients on lots of
     machines all hitting the same site.  Then a Monkeywrench server would
     collect and report on the results.

   * Configuration - Currently, the test scenarios reside in configuration
     scripts which you run directly.  It would be better if the
     configuration information was separated from the script which reads
     and runs the configuration information.  One idea is to store
     configuration/session info into XML files which you could just pass
     to Monkeywrench at the command line. 		 =item * Write more,
     longer TODOs.

COPYRIGHT
=========

   Copyright (c) 2000, Cnation Inc. All Rights Reserved. This program is
free software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

   You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc., 59
Temple Place - Suite 330, Boston, MA  02111-1307, USA.

AUTHORS
=======

     Derek Cline 	<derek@cnation.com>
     Adam Pisoni	<adam@cnation.com>
     David Pisoni	<david@cnation.com>


File: pm.info,  Node: HTTP/Negotiate,  Next: HTTP/Request,  Prev: HTTP/Monkeywrench,  Up: Module List

choose a variant of a document to serve (HTTP content negotiation)
******************************************************************

NAME
====

   choose - choose a variant of a document to serve (HTTP content
negotiation)

SYNOPSIS
========

     use HTTP::Negotiate;

     #  ID       QS     Content-Type   Encoding Char-Set        Lang   Size
     $variants =
      [['var1',  1.000, 'text/html',   undef,   'iso-8859-1',   'en',   3000],
       ['var2',  0.950, 'text/plain',  'gzip',  'us-ascii',     'no',    400],
       ['var3',  0.3,   'image/gif',   undef,   undef,          undef, 43555],
      ];

     @prefered = choose($variants, $request_headers);
     $the_one  = choose($variants);

DESCRIPTION
===========

   This module provides a complete implementation of the HTTP content
negotiation algorithm specified in `draft-ietf-http-v11-spec-00.ps'
chapter 12.  Content negotiation allows for the selection of a preferred
content representation based upon attributes of the negotiable variants
and the value of the various Accept* header fields in the request.

   The variants are ordered by preference by calling the function choose().

   The first parameter is reference to an array of the variants to choose
among.  Each element in this array is an array with the values [$id, $qs,
$content_type, $content_encoding, $charset, $content_language,
$content_length] whose meanings are described below. The $content_encoding
and $content_language can be either a single scalar value or an array
reference if there are several values.

   The second optional parameter is either a HTTP::Headers or a
HTTP::Request object which is searched for "Accept*" headers.  If this
parameter is missing, then the accept specification is initialized from
the CGI environment variables HTTP_ACCEPT, HTTP_ACCEPT_CHARSET,
HTTP_ACCEPT_ENCODING and HTTP_ACCEPT_LANGUAGE.

   In an array context, choose() returns a list of variant
identifier/calculated quality pairs.  The values are sorted by quality,
highest quality first.  If the calculated quality is the same for two
variants, then they are sorted by size (smallest first). *E.g.*:

     (['var1' => 1], ['var2', 0.3], ['var3' => 0]);

   Note that also zero quality variants are included in the return list
even if these should never be served to the client.

   In a scalar context, it returns the identifier of the variant with the
highest score or undef if none have non-zero quality.

   If the $HTTP::Negotiate::DEBUG variable is set to TRUE, then a lot of
noise is generated on STDOUT during evaluation of choose().

VARIANTS
========

   A variant is described by a list of the following values.  If the
attribute does not make sense or is unknown for a variant, then use undef
instead.

identifier
     This is a string that you use as the name for the variant.  This
     identifier for the preferred variants returned by choose().

qs
     This is a number between 0.000 and 1.000 that describes the "source
     quality".  This is what `draft-ietf-http-v11-spec-00.ps' says about
     this value:

     Source quality is measured by the content provider as representing the
     amount of degradation from the original source.  For example, a
     picture in JPEG form would have a lower qs when translated to the XBM
     format, and much lower qs when translated to an ASCII-art
     representation.  Note, however, that this is a function of the source
     - an original piece of ASCII-art may degrade in quality if it is
     captured in JPEG form.  The qs values should be assigned to each
     variant by the content provider; if no qs value has been assigned, the
     default is generally "qs=1".

content-type
     This is the media type of the variant.  The media type does not
     include a charset attribute, but might contain other parameters.
     Examples are:

          text/html
          text/html;version=2.0
          text/plain
          image/gif
          image/jpg

content-encoding
     This is one or more content encodings that has been applied to the
     variant.  The content encoding is generally used as a modifier to the
     content media type.  The most common content encodings are:

          gzip
          compress

content-charset
     This is the character set used when the variant contains text.  The
     charset value should generally be undef or one of these:

          us-ascii
          iso-8859-1 ... iso-8859-9
          iso-2022-jp
          iso-2022-jp-2
          iso-2022-kr
          unicode-1-1
          unicode-1-1-utf-7
          unicode-1-1-utf-8

content-language
     This describes one or more languages that are used in the variant.
     Language is described like this in `draft-ietf-http-v11-spec-00.ps': A
     language is in this context a natural language spoken, written, or
     otherwise conveyed by human beings for communication of information to
     other human beings.  Computer languages are explicitly excluded.

     The language tags are defined by RFC-1766.  Examples are:

          no               Norwegian
          en               International English
          en-US            US English
          en-cockney

content-length
     This is the number of bytes used to represent the content.

ACCEPT HEADERS
==============

   The following Accept* headers can be used for describing content
preferences in a request (This description is an edited extract from
`draft-ietf-http-v11-spec-00.ps'):

Accept
     This header can be used to indicate a list of media ranges which are
     acceptable as a reponse to the request.  The "*" character is used to
     group media types into ranges, with "*/*" indicating all media types
     and "type/*" indicating all subtypes of that type.

     The parameter q is used to indicate the quality factor, which
     represents the user's preference for that range of media types.  The
     parameter mbx gives the maximum acceptable size of the response
     content. The default values are: q=1 and mbx=infinity. If no Accept
     header is present, then the client accepts all media types with q=1.

     For example:

          Accept: audio/*;q=0.2;mbx=200000, audio/basic

     would mean: "I prefer audio/basic (of any size), but send me any audio
     type if it is the best available after an 80% mark-down in quality and
     its size is less than 200000 bytes"

Accept-Charset
     Used to indicate what character sets are acceptable for the response.
     The "us-ascii" character set is assumed to be acceptable for all user
     agents.  If no Accept-Charset field is given, the default is that any
     charset is acceptable.  Example:

          Accept-Charset: iso-8859-1, unicode-1-1

Accept-Encoding
     Restricts the Content-Encoding values which are acceptable in the
     response.  If no Accept-Encoding field is present, the server may
     assume that the client will accept any content encoding.  An empty
     Accept-Encoding means that no content encoding is acceptable.
     Example:

          Accept-Encoding: compress, gzip

Accept-Language
     This field is similar to Accept, but restricts the set of natural
     languages that are preferred in a response.  Each language may be
     given an associated quality value which represents an estimate of the
     user's comprehension of that language.  For example:

          Accept-Language: no, en-gb;q=0.8, de;q=0.55

     would mean: "I prefer Norwegian, but will accept British English (with
     80% comprehension) or German (with 55% comprehension).

COPYRIGHT
=========

   Copyright 1996, Gisle Aas.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Gisle Aas <aas@sn.no>


File: pm.info,  Node: HTTP/Request,  Next: HTTP/Request/Common,  Prev: HTTP/Negotiate,  Up: Module List

Class encapsulating HTTP Requests
*********************************

NAME
====

   HTTP::Request - Class encapsulating HTTP Requests

SYNOPSIS
========

     require HTTP::Request;
     $request = HTTP::Request->new(GET => 'http://www.oslonett.no/');

DESCRIPTION
===========

   HTTP::Request is a class encapsulating HTTP style requests, consisting
of a request line, some headers, and some (potentially empty) content.
Note that the LWP library also uses this HTTP style requests for non-HTTP
protocols.

   Instances of this class are usually passed to the request() method of
an `LWP::UserAgent' object:

     $ua = LWP::UserAgent->new;
     $request = HTTP::Request->new(GET => 'http://www.oslonett.no/');
     $response = $ua->request($request);

   HTTP::Request is a subclass of `HTTP::Message' and therefore inherits
its methods.  The inherited methods most often used are header(),
push_header(), remove_header(), headers_as_string() and content().  See
*Note HTTP/Message: HTTP/Message, for details.

   The following additional methods are available:

$r = HTTP::Request->new($method, $uri, [$header, [$content]])
     Constructs a new HTTP::Request object describing a request on the
     object $uri using method `$method'.  The $uri argument can be either
     a string, or a reference to a `URI' object.  The $header argument
     should be a reference to an `HTTP::Headers' object.

$r->method([$val])
$r->uri([$val])
     These methods provide public access to the attributes containing
     respectively the method of the request and the URI object of the
     request.

     If an argument is given the attribute is given that as its new value.
     If no argument is given the value is not touched. In either case the
     previous value is returned.

     The uri() method accept both a reference to a URI object and a string
     as its argument.  If a string is given, then it should be parseable
     as an absolute URI.

$r->as_string()
     Method returning a textual representation of the request.  Mainly
     useful for debugging purposes. It takes no arguments.

SEE ALSO
========

   *Note HTTP/Headers: HTTP/Headers,, *Note HTTP/Message: HTTP/Message,,
*Note HTTP/Request/Common: HTTP/Request/Common,

COPYRIGHT
=========

   Copyright 1995-1998 Gisle Aas.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/Request/Common,  Next: HTTP/Request/Form,  Prev: HTTP/Request,  Up: Module List

Construct common HTTP::Request objects
**************************************

NAME
====

   HTTP::Request::Common - Construct common HTTP::Request objects

SYNOPSIS
========

     use HTTP::Request::Common;
     $ua = LWP::UserAgent->new;
     $ua->request(GET 'http://www.sn.no/');
     $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);

DESCRIPTION
===========

   This module provide functions that return newly created HTTP::Request
objects.  These functions are usually more convenient to use than the
standard HTTP::Request constructor for these common requests.  The
following functions are provided.

GET $url, Header => Value,...
     The GET() function returns a HTTP::Request object initialized with the
     GET method and the specified URL.  Without additional arguments it is
     exactly equivalent to the following call

          HTTP::Request->new(GET => $url)

     but is less cluttered.  It also reads better when used together with
     the LWP::UserAgent->request() method:

          my $ua = new LWP::UserAgent;
          my $res = $ua->request(GET 'http://www.sn.no')
          if ($res->is_success) { ...

     You can also initialize header values in the request by specifying
     some key/value pairs as optional arguments.  For instance:

          $ua->request(GET 'http://www.sn.no',
          	           If_Match => 'foo',
                           From     => 'gisle@aas.no',
                      );

     A header key called 'Content' is special and when seen the value will
     initialize the content part of the request instead of setting a
     header.

HEAD $url, [Header => Value,...]
     Like GET() but the method in the request is HEAD.

PUT $url, [Header => Value,...]
     Like GET() but the method in the request is PUT.

POST $url, [$form_ref], [Header => Value,...]
     This works mostly like GET() with POST as the method, but this
     function also takes a second optional array or hash reference
     parameter ($form_ref).  This argument can be used to pass key/value
     pairs for the form content.  By default we will initialize a request
     using the `application/x-www-form-urlencoded' content type.  This
     means that you can emulate a HTML <form> POSTing like this:

          POST 'http://www.perl.org/survey.cgi',
               [ name   => 'Gisle Aas',
                 email  => 'gisle@aas.no',
                 gender => 'M',
                 born   => '1964',
                 perc   => '3%',
               ];

     This will create a HTTP::Request object that looks like this:

          POST http://www.perl.org/survey.cgi
          Content-Length: 66
          Content-Type: application/x-www-form-urlencoded

          name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25

     The POST method also supports the `multipart/form-data' content used
     for *Form-based File Upload* as specified in RFC 1867.  You trigger
     this content format by specifying a content type of `'form-data'' as
     one of the request headers.  If one of the values in the $form_ref is
     an array reference, then it is treated as a file part specification
     with the following interpretation:

          [ $file, $filename, Header => Value... ]

     The first value in the array ($file) is the name of a file to open.
     This file will be read and its content placed in the request.  The
     routine will croak if the file can't be opened.  Use an undef as $file
     value if you want to specify the content directly.  The $filename is
     the filename to report in the request.  If this value is undefined,
     then the basename of the $file will be used.  You can specify an empty
     string as $filename if you don't want any filename in the request.

     Sending my `~/.profile' to the survey used as example above can be
     achieved by this:

          POST 'http://www.perl.org/survey.cgi',
               Content_Type => 'form-data',
               Content      => [ name  => 'Gisle Aas',
                                 email => 'gisle@aas.no',
                                 gender => 'M',
                                 born   => '1964',
                                 init   => ["$ENV{HOME}/.profile"],
                               ]

     This will create a HTTP::Request object that almost looks this (the
     boundary and the content of your `~/.profile' is likely to be
     different):

          POST http://www.perl.org/survey.cgi
          Content-Length: 388
          Content-Type: multipart/form-data; boundary="6G+f"

          --6G+f
          Content-Disposition: form-data; name="name"
          
          Gisle Aas
          --6G+f
          Content-Disposition: form-data; name="email"
          
          gisle@aas.no
          --6G+f
          Content-Disposition: form-data; name="gender"
          
          M
          --6G+f
          Content-Disposition: form-data; name="born"
          
          1964
          --6G+f
          Content-Disposition: form-data; name="init"; filename=".profile"
          Content-Type: text/plain
          
          PATH=/local/perl/bin:$PATH
          export PATH

          --6G+f--

     If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
     value, then you get back a request object with a subroutine closure as
     the content attribute.  This subroutine will read the content of any
     files on demand and return it in suitable chunks.  This allow you to
     upload arbitrary big files without using lots of memory.  You can even
     upload infinite files like `/dev/audio' if you wish; however, if the
     file is not a plain file, there will be no Content-Length header
     defined for the request.  Not all servers (or server applications)
     like this.  Also, if the file(s) change in size between the time the
     Content-Length is calculated and the time that the last chunk is
     delivered, the subroutine will `Croak'.

SEE ALSO
========

   *Note HTTP/Request: HTTP/Request,, *Note LWP/UserAgent: LWP/UserAgent,

COPYRIGHT
=========

   Copyright 1997-2000, Gisle Aas

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


