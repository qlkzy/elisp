This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Chemistry/Elements,  Next: Chess/Pgn,  Prev: Chatbot/Eliza,  Up: Module List

Perl extension for working with Chemical Elements
*************************************************

NAME
====

   Chemistry::Elements - Perl extension for working with Chemical Elements

SYNOPSIS
========

     use Chemistry::Elements qw(get_name get_Z get_symbol);

     # the constructor can use different input
     $element = new Chemistry::Elements $atomic_number;
     $element = new Chemistry::Elements $chemical_symbol;
     $element = new Chemistry::Elements $element_name;

     # you can make up your own attributes by specifying
     # a method (which is really AUTOLOAD)
           $element->molar_mass(22.989) #sets the attribute
     $MM = $element->molar_mass         #retrieves the value

DESCRIPTION
===========

   There are two parts to the module:  the object stuff and the exportable
functions for use outside of the object stuff.  The exportable functions
are discussed in EXPORTABLE FUNCTIONS.

   Chemistry::Elements provides an easy, object-oriented way to keep track
of your chemical data.  Using either the atomic number, chemical symbol,
or element name you can construct an Element object.  Once you have an
element object, you can associate your data with the object by making up
your own methods, which the AUTOLOAD function handles.  Since each chemist
is likely to want to use his or her own data, or data for some
unforesee-able property, this module does not try to be a repository for
chemical data.

   The Element object constructor tries to be as flexible as possible -
pass it an atomic number, chemical symbol, or element name and it tries to
create the object.

     # the constructor can use different input
     $element = new Chemistry::Elements $atomic_number;
     $element = new Chemistry::Elements $chemical_symbol;
     $element = new Chemistry::Elements $element_name;

   once you have the object, you can define your own methods simply by
using them.  Giving the method an argument (others will be ignored)
creates an attribute with the method's name and the argument's value.

     # you can make up your own attributes by specifying
     # a method (which is really AUTOLOAD)
           $element->molar_mass(22.989) #sets the attribute
     $MM = $element->molar_mass         #retrieves the value

   The atomic number, chemical symbol, and element name can be retrieved
in the same way.

     $atomic_number = $element->Z;
     $name          = $element->name;
     $symbol        = $element->symbol;

   These methods can also be used to set values, although changing any of
the three affects the other two.

     $element       = new Chemistry::Elements('Lead');

     $atomic_number = $element->Z;    # $atomic_number is 82

     $element->Z(79);

     $name          = $element->name; # $name is 'Gold'

EXPORTABLE FUNCTIONS
====================

   These functions can be exported.  They are not exported by default.

get_symbol()
------------

   This function attempts to return the symbol of the chemical element
given either the chemical symbol, element name, or atmoic number.  The
function does its best to interpret inconsistent input data (e.g.
chemcial symbols of mixed and single case).

     use Chemistry::Elements qw(get_symbol);

     $name = get_symbol('Fe');     #$name is 'Fe'
     $name = get_symbol('fe');     #$name is 'Fe'
     $name = get_symbol(26);       #$name is 'Fe'
     $name = get_symbol('Iron');   #$name is 'Fe'
     $name = get_symbol('iron');   #$name is 'Fe'

   If no symbol can be found, undef is returned.

   Since this function will return the symbol if it is given a symbol, you
can use it to test whether a string is a chemical symbol (although you
have to play some tricks with case since get_symbol will try its best
despite the case of the input data).

     if( lc($string) eq lc( get_symbol($string) ) )
     	{
     	#stuff
     	}
     
     You can modify the symbols (e.g. you work for UCal ;) ) by changing
     the data at the end of this module.

get_name()
----------

   This function attempts to return the name the chemical element given
either the chemical symbol, element name, or atomic number.  The function
does its best to interpret inconsistent input data (e.g.  chemcial symbols
of mixed and single case).

     $name = get_name('Fe');     #$name is 'Iron'
     $name = get_name('fe');     #$name is 'Iron'
     $name = get_name(26);       #$name is 'Iron'
     $name = get_name('Iron');   #$name is 'Iron'
     $name = get_name('iron');   #$name is 'Iron'

   If there is no Z can be found, undef is returned.

   Since this function will return the name if it is given a name, you can
use it to test whether a string is a chemical element name (although you
have to play some tricks with case since get_name will try its best
despite the case of the input data).

     if( lc($string) eq lc( get_name($string) ) )
     	{
     	#stuff
     	}

   You can modify the names (e.g. for different languages) by changing the
data at the end of this module.

get_Z()
-------

   This function attempts to return the atomic number of the chemical
element given either the chemical symbol, element name, or atomic number.
The function does its best to interpret inconsistent input data (e.g.
chemcial symbols of mixed and single case).

     $name = get_Z('Fe');     #$name is 26
     $name = get_Z('fe');     #$name is 26
     $name = get_Z(26);       #$name is 26
     $name = get_Z('Iron');   #$name is 26
     $name = get_Z('iron');   #$name is 26

   If there is no Z can be found, undef is returned.

   Since this function will return the Z if it is given a Z, you can use
it to test whether a string is an atomic number.  You might want to use
the string comparison in case the $string is not a number (in which case
the comparison will be false save for the case when $string is undefined).

     if( $string eq get_Z($string) )
     	{
     	#stuff
     	}

   The package constructor automatically finds the largest defined atomic
number (in case you add your own heavy elements).

AUTOLOADing methods
-------------------

   You can pseudo-define additional methods to associate data with objects.
For instance, if you wanted to add a molar mass attribute, you simply
pretend that there is a molar_mass method:

     $element->molar_mass($MM); #add molar mass datum in $MM to object

   Similiarly, you can retrieve previously set values by not specifying an
argument to your pretend method:

     $datum = $element->molar_mass();

     #or without the parentheses
     $datum = $element->molar_mass;

   If a value has not been associated with the pretend method and the
object, the pretend method returns undef.

   I had thought about providing basic data for the elements, but thought
that anyone using this module would probably have their own data.  If
there is an interest in canned data, perhaps I can provide mine :)

TO DO
=====

   I would like make this module easily localizable so that one could
specify other names or symbols for the elements (i.e. a different language
or a different perspective on the heavy elements).  If anyone should make
changes to the data, i would like to get a copy so that i can include it
in future releases :)

AUTHOR
======

   brian d foy <comdog@computerdog.com>


File: pm.info,  Node: Chess/Pgn,  Next: Circa/Indexer,  Prev: Chemistry/Elements,  Up: Module List

Perl extension for manipulation of chess PGN format. PGN is for  Portable Game Notation and follow the *Portable Game Notation Specification and Implementation Guide* revised 1994.03.12. You can find it at `http:' in this node.
***********************************************************************************************************************************************************************************************************************************

NAME
====

   Chess::Pgn - Perl extension for manipulation of chess PGN format. PGN
is for Portable Game Notation and follow the *Portable Game Notation
Specification and Implementation Guide* revised 1994.03.12. You can find
it at `http:' in this node.

   The goal of this module is not to play chess but to help to manipulate
PGN File.

   A PGN file is like this :

     [Event "?"]
     [Site "?"]
     [Date "????.??.??"]
     [Round "?"]
     [White "Greco"]
     [Black "NN"]
     [Result "1-0"]
     [ECO "C57"]
     [WhiteElo "2010"]
     [BlackElo "1620"]
     [PlyCount "17"]

     1.e4 e5 2.Nf3 Nc6 3.Bc4 Nf6 4.Ng5 d5 5.exd5 Nxd5 6.Nxf7 Kxf7 7.Qf3+ Ke6
     8.Nc3 Ne7 9.O-O c6 10.Re1 Bd7 11.d4 Kd6 12.Rxe5 Ng6 13.Nxd5 Nxe5
     14.dxe5+ Kc5 15.Qa3+ Kxc4 16.Qd3+ Kc5 17.b4# 1-0

     [Event "?"]
     [Site "corr CS ch 22 (FS"]
     [Date "????.??.??"]
     [Round "12.0"]
     [White "Rosenzweig V"]
     [Black "Necesany Z"]
     [Result "1/2-1/2"]
     [ECO "C55"]
     [WhiteElo "2410"]
     [BlackElo "2620"]
     [PlyCount "22"]

     1.e4 e5 2.Nf3 Nc6 3.Bc4 Nf6 4.O-O Be7 5.Nc3 Nxe4 6.Nxe4 d5 7.d4 dxc4
     8.d5 Nd4 9.Nxd4 Qxd5 10.Nf3 Qxe4 11.Re1 Qc6 12.Nxe5 Qf6 13.Bd2 O-O
     14.Bc3 Bc5 15.Re2 Qf5 16.Qd5 Bd6 17.Rae1 Be6 18.Qxb7 f6 19.Nc6 Bd5
     20.Rd2 Bxg2 21.Rxd6 Bxc6 22.Rxc6 Qg4+ 1/2-1/2

   With Chess:Pgn you will find a game by $game->date or $game->game.  For
our last example we will have

     $game->date : "????.??.??"
     $game->game : "1.e4 e5 2.Nf3 Nc6 3.Bc4 Nf6 4.Ng5 d5 5.exd5 Nxd5 6.Nxf7 Kxf7 7.Qf3+ Ke6
     8.Nc3 Ne7 9.O-O c6 10.Re1 Bd7 11.d4 Kd6 12.Rxe5 Ng6 13.Nxd5 Nxe5
     14.dxe5+ Kc5 15.Qa3+ Kxc4 16.Qd3+ Kc5 17.b4# 1-0"

   The module provide a good set of tools to modify PGN File but you will
have to make yourself the while :)

SYNOPSIS
========

     use Chess::Pgn;
     $p = new Chess::Pgn("2KTSDEF.PGN" ) || die "2KTSDEF.PGN not found";
     while ( $p->ReadGame )
      {
       print $p->white ,"<=>",$p->black, "\n";
      }
     $p->quit();
     
     $p->white(Kouatly);
     $p->black(Kasparov);

DESCRIPTION
===========

new
          $p= new Chess::Pgn ("name")
          
          open the file I<name> and if it doesn't exist return undef.

ReadGame
          $p->ReadGame
          
          This method read just one game and return undef at the end of file. You must use methods to read the game.

quit
          $p->quit
          
          Close the PGN file

Basic methods
          site, date, round, white, black, result, eco, whiteelo, blackelo, plycount, game :
          
          return the value of the current game.

          $p->black return Greco
          
          =item set a value

     You can change a value if you put a argument to the method.

     For example :

          $p->black("Gilles Maire")
          
          will change the value of the black opponent. But just in memory ! You will need to write of file to save it.

variable
     You can access to method value bye the hash

     $p->{Event}, $p->{Site} , $p->{Date}
     ,p->{Round},$p->{White},$p->{Black},   $p->{Result},
     $p->{ECO},$p->{Game}; $p->{WhiteElo}, $p{BlackElo}, $p->{PlyCount}

All in One method
          $p->PrintAll;

     return in a string all the lines concerning the current game. You can
     of course modify  some values before call this method.

EXPORT
------

   None by default.

AUTHOR
======

   Gilles Maire

   Gilles.Maire@ungi.net

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Circa/Indexer,  Next: Circa/Search,  Prev: Chess/Pgn,  Up: Module List

provide functions to administrate Circa,  a www search engine running with Mysql
********************************************************************************

NAME
====

   Circa::Indexer - provide functions to administrate Circa, a www search
engine running with Mysql

SYNOPSIS
========

     use Circa::Indexer;
     my $indexor = new Circa::Indexer;
     
     if (!$indexor->connect_mysql($user,$pass,$db))
     	{die "Erreur à la connection MySQL:$DBI::errstr\n";}
     
     $indexor->create_table_circa;
     
     $indexor->drop_table_circa;
     
     $indexor->addSite("http://www.alianwebserver.com/",
                       'alian@alianwebserver.com',
                       "Alian Web Server");
     
     my ($nbIndexe,$nbAjoute,$nbWords,$nbWordsGood) = $indexor->parse_new_url(1);
     print 	"$nbIndexe pages indexées,"
     	"$nbAjoute pages ajoutées,"
     	"$nbWordsGood mots indexés,"
     	"$nbWords mots lus\n";

     $indexor->update(30,1);

   Look in admin.pl,admin.cgi,admin_compte.cgi

DESCRIPTION
===========

   This is Circa::Indexer, a module who provide functions to administrate
Circa, a www search engine running with Mysql. Circa is for your Web site,
or for a list of sites.  It indexes like Altavista does. It can read, add
and parse all url's found in a page. It add url and word to MySQL for use
it at search.

   This module can:

Add url
Index words
Parse url, and so on.
Provide routine to administrate present url
   Remarques:

     - This file are not added : doc,zip,ps,gif,jpg,gz,pdf,eps,png,
       deb,xls,ppt,class,GIF,css,js,wav,mid
     - Weight for each word is in hash $ConfigMoteur

How it's work ?
---------------

   Circa parse html document. convert it to text. It count all word found
and put result in hash key. In addition of that, it read title, keywords,
description and add a weight to all word found.

   Example:

     my %ConfigMoteur=(
            'facteur_keyword'       =>15,
            'facteur_description'   =>10,
            'facteur_titre'         =>10,
            'facteur_full_text'     =>1,
            'niveau_max'		=>7,
            'nb_min_mots'           =>2
            );

     <html>
     <head>
     <meta name="KeyWords"
     CONTENT="informatique,computing,javascript,CGI,perl">
     <meta name="Description" CONTENT="Rubriques Informatique (Internet,Java,Javascript, CGI, Perl)">
     <title>Alian Web Server:Informatique,Société,Loisirs,Voyages,Expression</title>
     </head>
     <body>
     different word: cgi, perl, cgi
     </body>
     </html>

   After parsing I've a hash with that:

     $words{'informatique'}= 15 + 10 + 10 =35
     $words{'cgi'} = 15 + 10 +1
     $words{'different'} = 1

   Words is add to database if total found is >
$ConfigMoteur{'nb_min_mots'} (2 by default). But if you set to 1, database
will grow very quicly but allow you to perform very exact search with many
worlds so you can do phrase searches. But if you do that, think to take a
look at size of table relation.

   After page is read, it's look into html link. And so on. At each time,
the level grow to one. So if < to $Config{'niveau_max'}, url is added.

VERSION
=======

   $Revision: 1.8 $

Manipulation des attributs
==========================

size_max($size)
---------------

   Get or set size max of file read by indexer (For avoid memory pb).

set_agent
---------

port_mysql($port)
-----------------

   Get or set the MySQL port

host_indexed($host)
-------------------

   Get or set the host indexed.

proxy($adr_proxy)
-----------------

   Positionne le proxy a utiliser le cas écheant.

     $adr_proxy : Ex: 'http://proxy.sn.no:8001/'

prefix_table
------------

   Get or set the prefix for table name for use Circa with more than one
time on a same database

connect_mysql($user,$password,$db,$server)
------------------------------------------

     $user     : User MySQL
     $password : Password MySQL
     $db       : Database MySQL
     $server   : Adr IP MySQL

   Connect Circa to MySQL. Return 1 on succes, 0 else

close_connect
-------------

   Close connection to MySQL

Administrative globales methods
===============================

addSite($url,$email,$titre,$categorieAuto,$cgi,$rep,$file);
-----------------------------------------------------------

   Ajoute le site d'url $url, responsable d'adresse mail $email à la bd de
Circa

addLocalSite($url,$email,$titre,$local_url,$path,$urlRacine,$categorieAuto,$cgi,$rep,$file);
--------------------------------------------------------------------------------------------

   Add a local $url

updateUrl($compte,$id,$url,$urllocal,$titre,$description,$langue, 		 $categorie,$browse_categorie,$parse,$valide,$niveau,$last_check,$last_update)
--------------------------------------------------------------------------------------------------------------------------------------------------

   Update url $id on table $compte

parse_new_url($idp)
-------------------

   Parse les pages qui viennent d'être ajoutée. Le programme va analyser
toutes les pages dont la colonne 'parse' est égale à 0.

   Retourne le nombre de pages analysées, le nombre de page ajoutées, le
nombre de mots indexés.

update($xj,$idp)
----------------

   Reindexe les sites qui n'ont pas été mis à jour depuis plus de $xj jours

create_table_circa
------------------

   Cree la liste des tables necessaires à Circa:

     - categorie   : Catégories de sites
     - links       : Liste d'url
     - responsable : Lien vers personne responsable de chaque lien
     - relations   : Liste des mots / id site indexes
     - inscription : Inscriptions temporaires

drop_table_circa
----------------

   Detruit les tables de Circa

drop_table_circa_id
-------------------

   Detruit les tables de Circa pour l'utilisateur id

create_table_circa_id
---------------------

   Cree la liste des tables necessaires à Circa:

     - categorie   : Catégories de sites
     - links       : Liste d'url
     - relations   : Liste des mots / id site indexes
     - stats 	: Liste des requetes

Fonctions HTML
==============

start_classic_html
------------------

   Affiche le debut de document (<head></head>)

get_liste_liens($id)
--------------------

   Rend un buffer contenant une balise select initialisée avec les données
de la table links responsable $id

get_liste_liens_a_valider($id)
------------------------------

   Rend un buffer contenant une balise select initialisée avec les données
de la table links responsable $id liens non valides

get_liste_site
--------------

   Rend un buffer contenant une balise select initialisée avec les données
de la table responsable

get_liste_categorie($id)
------------------------

   Rend un buffer contenant une balise select initialisée avec les données
de la table categorie responsable $id

fill_template($masque,$vars)
----------------------------

     $masque : Chemin du template
     $vars : reference du hash des noms/valeurs à substituer dans le template

   Rend le template avec ses variables substituées.  Ex: si
$$vars{age}=12, et que le fichier $masque contient la chaine:

     J'ai <? $age ?> ans,

   la fonction rendra

     J'ai 12 ans,

Methode administration par compte
=================================

admin_compte($compte)
---------------------

   Retourne une liste d'elements se rapportant au compte $compte:

     $responsable	: Adresse mail du responsable
     $titre		: Titre du site pour ce compte
     $nb_page	: Nombre de page pour ce site
     $nb_words      : Nombre de mots indexés
     $last_index	: Date de la dernière indexation
     $nb_requetes	: Nombre de requetes effectuées sur ce site
     $racine	: 1ere page inscrite

most_popular_word($max,$id)
---------------------------

   Retourne la reference vers un hash representant la liste des $max mots
les plus présents dans la base de reponsable $id

delete_url($compte,$id_url)
---------------------------

   Supprime le lien $id_url de la table $compte/relation et $compte/links

valide_url($compte,$id_url)
---------------------------

   Supprime le lien $id_url de la table $compte/relation et $compte/links

delete_categorie($compte,$id)
-----------------------------

   Supprime la categorie $id pour le compte de responsable $compte et tous
les liens et relation qui sont dans cette categorie

rename_categorie($compte,$id,$nom)
----------------------------------

   Renomme la categorie $id pour le compte de responsable $compte en $nom

deplace_categorie($compte,$id1,$id2)
------------------------------------

   Move url from one categorie to another

inscription($email,$url,$titre)
-------------------------------

   Inscrit un site dans une table temporaire

Méthodes privées
================

look_at ($url,$idc,$idr,$lastModif,$url_local)
----------------------------------------------

   Ajoute les liens definis à l'URL $url à la base de donnée.  Indexe les
mots de chaque page

     $url : Url de la page à indexer
     $idc : Id de l'url dans la table links
     $idr : Id du responsable de cette url
     $lastModif : Ne parse pas la page si elle n'a pas été mis à jour
                  depuis cette date (facultatif)
     $url_local : Chemin local pour accéder au fichier (facultatif)

   Retourne (-1,0) si l'adresse est invalide, le nombre de liens trouvés
dans la page ainsi que le nombre de mots trouves sinon.

add_site($url,$idMan,[$local_url],[$browse_categorie],[$niveau],[$categorie])
-----------------------------------------------------------------------------

   Ajoute un site à la table links.

     $url   : Url de la page à ajouter
     $idMan : Id dans la table responsable du responsable de ce site

drop_site($id)
--------------

   Supprime un site de la table personne. Cela supprime egalement les
elements de la table links et relation qui appartiennent à ce site

     $id   : Id du site

get_meta($entete)
-----------------

   Parse et rend les meta-mots-clef et la meta-description de la page HTML
contenu dans $entete

analyse_data($data,$facteur,%l)
-------------------------------

   Recupere chaque mot du buffer $data et lui attribue une frequence
d'apparition.  Les resultats sont ranges dans le tableau associatif passé
en paramètre.  Les résultats sont rangés sous la forme
%l=('mots'=>facteur).

     $data : buffer à analyser
     $facteur : facteur à attribuer à chacun des mots trouvés
     %l : Tableau associatif où est rangé le résultat

   Retourne la référence vers le hash

getParent($id,%tab)
-------------------

   Rend la chaine correspondante à la catégorie $id avec ses rubriques
parentes

AUTHOR
======

   Alain BARBET alian@alianwebserver.com


File: pm.info,  Node: Circa/Search,  Next: Cisco/Conf,  Prev: Circa/Indexer,  Up: Module List

provide functions to perform search on Circa, a www search engine running with Mysql
************************************************************************************

NAME
====

   Circa::Search - provide functions to perform search on Circa, a www
search engine running with Mysql

SYNOPSIS
========

     use Circa::Search;
     my $search = new Circa::Search;
     
     # Connection à MySQL
     if (!$search->connect_mysql("aliansql","pass","my_database","localhost"))
     	{die "Erreur à la connection MySQL:$DBI::errstr\n";}

     # Affichage d'un formulaire minimum
     print 	header,
     	$search->start_classic_html,
     	$search->default_form;
     
     # Interrogation du moteur
     # Sites trouves, liens pages suivantes, nb pages trouvees
     my ($resultat,$links,$indice) = $search->search('informatique internet',0,1);

DESCRIPTION
===========

   This is Circa::Search, a module who provide functions to perform search
on Circa, a www search engine running with Mysql. Circa is for your Web
site, or for a list of sites.  It indexes like Altavista does. It can
read, add and parse all url's found in a page. It add url and word to
MySQL for use it at search.

   Remarques sur la recherche:

     - Accents are removed on search and when indexed
     - Search are cas unsensitive (mmmh what my english ? ;-)

VERSION
=======

   $Revision: 1.5 $

port_mysql
----------

   Get or set the MySQL port

prefix_table
------------

   Get or set the prefix for table name for use Circa with more than one
time on a same database

Méthodes publiques
==================

connect_mysql($user,$password,$db)
----------------------------------

   Connecte l'application à MySQL. Retourne 1 si succes, 0 sinon

     $user     : Utilisateur MySQL
     $password : Mot de passe MySQL
     $db       : Database MySQL
     $server   : Adr IP du serveur MySQL

search($template,$mot,$first,$id,$langue,$url,$create,$update,$catego)
----------------------------------------------------------------------

   Fonction permettant d'effectuer une recherche par mot dans Circa

   Paramètres :

     $template : Masque HTML pour le resultat de chaque lien. Si undef, le masque par defaut
     (defini en haut de ce module) sera utilise. La liste des variables définies au
     moment du eval sont : $indiceG,$titre,$description,$url,$facteur,$last_update,$langue
     
      Exemple de masque :
     
      '"<p>$indiceG - <a href=\"$url\">$titre</a> $description<br>
       <font class=\"small\"><b>Url:</b> $url <b>Facteur:</b> $facteur
       <b>Last update:</b> $last_update </font></p>\n"'
     
     $mot    : Séquence des mots recherchés tel que tapé par l'utilisateur
     first   : Indice du premier site affiché dans le résultat
     $id     : Id du site dans lequel effectué la recherche
     $langue : Restriction par langue (facultatif)
     $Url    : Restriction par url : les url trouvées commenceront par $Url (facultatif)
     $create : Restriction par date inscription. Format YYYY-MM-JJ HH:MM:SS (facultatif)
     $update : Restriction par date de mise à jour des pages. Format YYYY-MM-JJ HH:MM:SS (facultatif)
     $catego : Restriction par categorie (facultatif)
     
     Retourne ($resultat,$links,$indice)

     $resultat : Buffer HTML contenant la liste des sites trouves formaté en fonction
                 de $template et des mots present dans $mots
     $links    : Liens vers les pages suivantes / precedentes
     $indice   : Nombre de sites trouves

search_word($tab,$word,$idc,$langue,$Url,$create,$update,$categorie)
--------------------------------------------------------------------

   Construction de la requete SQL. Son exploitation est faite par search

     $tab    : Reference du hash où mettre le resultat
     $word   : Mot recherché
     $id     : Id du site dans lequel effectué la recherche
     $langue : Restriction par langue (facultatif)
     $Url    : Restriction par url
     $create : Restriction par date inscription
     $update : Restriction par date de mise à jour des pages
     $catego : Restriction par categorie

   Retourne la reference du hash avec le resultat de la recherche sur le
mot $word Le hash est constitué comme tel:

     $tab{$url}[0] : titre
     $tab{$url}[1] : description
     $tab{$url}[2] : facteur
     $tab{$url}[3] : langue
     $tab{$url}[4] : date de dernière modification
        @{$$tab{$url}[5]}: liste des mots trouves pour cet url

categories_in_categorie($id,$idr,$template)
-------------------------------------------

   Fonction retournant la liste des categories de la categorie $id dans le
site $idr

     $id       : Id de la categorie de depart. Si undef, 0 est utilisé (Considéré comme le "Home")
     $idr	   : Id du responsable
     $template : Masque HTML pour le resultat de chaque lien. Si undef, le masque par defaut
                 (defini en haut de ce module) sera utlise

   Retourne ($resultat,$nom_categorie) :

     $resultat : Buffer contenant la liste des sites formatées en ft de $template
     $nom_categorie : Nom court de la categorie

sites_in_categorie($id,$idr,$template)
--------------------------------------

   Fonction retournant la liste des pages de la categorie $id dans le site
$idr

     $id       : Id de la categorie de depart. Si undef, 0 est utilisé (Considéré comme le "Home")
     $idr	   : Id du responsable
     $template : Masque HTML pour le resultat de chaque lien. Si undef, le masque par defaut
                 (defini en haut de ce module) sera utlise

   Retourne le buffer contenant la liste des sites formatées en ft de
$template

getParent($id,$idr,%tab)
------------------------

   Rend la chaine correspondante à la catégorie $id avec ses rubriques
parentes

get_link($no_page)
------------------

   Retourne l'URL correspondant à la page no $no_page dans la recherche en
cours

get_link_categorie($no_categorie,$id)
-------------------------------------

   Retourne l'URL correspondant à la categorie no $no_categorie

start_classic_html
------------------

   Affiche le debut de document (<head></head>)

fill_template($masque,$vars)
----------------------------

     $masque : Chemin du template
     $vars : hash des noms/valeurs à substituer dans le template

   Rend le template avec ses variables substituées.  Ex: si
$$vars{age}=12, et que le fichier $masque contient la chaine:

     J'ai <? $age ?> ans,

   la fonction rendra

     J'ai 12 ans,

advanced_form($id)
------------------

   Affiche un formulaire minimum pour effectuer une recherche sur Circa

default_form
------------

   Affiche un formulaire minimum pour effectuer une recherche sur Circa

get_liste_langue
----------------

   Retourne le buffer HTML correspondant à la liste des langues disponibles

get_first($requete)
-------------------

   Retourne la premiere ligne du resultat de la requete $requete sous la
forme d'un tableau

get_masque
----------

get_name_site($id)
------------------

   Retourne le nom du site dans la table responsable correspondant à l'id
$id

get_liste_categorie_fils($id,$idr)
----------------------------------

     $id : Id de la categorie parent
     $idr : Site selectionne

   Retourne la liste des categories fils de $id dans le site $idr

AUTHOR
======

   Alain BARBET alian@alianwebserver.com


File: pm.info,  Node: Cisco/Conf,  Next: Cisco/Conf/Install,  Prev: Circa/Search,  Up: Module List

Perl module for configuring Cisco routers via TFTP
**************************************************

NAME
====

   Cisco::Conf - Perl module for configuring Cisco routers via TFTP

SYNOPSIS
========

     use Cisco::Conf;

     # Set the path of the main configuration file
     $configFile = '/usr/local/cisco/etc/config';

     # Add a new machine to the configuration file
     Cisco::Conf->Add($configFile,
     		   {'name' => 'myrouter',
     		    'description' => 'My Internet gateway',
     		    'users' => ['root', 'joe'],
     		    'host' => '192.168.1.1',
     		    'username' => 'itsme',
     		    'password' => 'secret',
     		    'enable_password' => undef  # Prompt password
     		   });

     # Remove a machine from the configuration file
     Cisco::Conf->Remove($configFile, 'myrouter');

     # Create a configuration object by reading it from the
     # configuration file
     $conf = Cisco::Conf->Read($configFile, 'myrouter');

     # Edit a machine's configuration (uses $ENV{'EDITOR'})
     $conf->Edit($editor, $file, $tmpDir);

     # Feed a machine's configuration into RCS
     $conf->RCS($file, "in");

     # Load a machine's configuration and save it in 'myfile'
     $conf->Load('myfile');

     # Strip comments from a machine configuration in $configuration
     $stripped = Cisco::Conf->Strip($configuration);

     # Read a configuration from 'myfile' and save it into the router
     $conf->Save('myfile', $write);

     # Return a list of all configurations that the current user may
     # access
     @list = Cisco::Conf->Info($configFile);

DESCRIPTION
===========

   This module offers a set of methods for creating and managing Cisco
configurations. Configurations are stored as plain text files, including
comments. Comments are indicated by an exclamation mark and may terminate
any line. Example:

     ! Here come the interfaces
     interface Ethernet 0   ! Local LAN
     ...

   All methods throw a Perl exception in case of errors, thus you should
encapsulate them with an eval, like this:

     $@ = '';
     eval {
         Cisco::Conf->Add('/usr/local/cisco/etc/configurations',
     			 {'name' => 'myrouter',
     			  ...
     			 });
     };
     if ($@) {
     	print STDERR "An error occurred: $@\n";
     	exit 1;
     }

   The following methods are offered by the module:

Add($configFile, \%attr)
------------------------

   (Class method) Adds a new configuration to the list of configurations
in the file `$configFile'. A configuration is represented by the hash ref
`\%attr' with a number of attributes, including

name
     A symbolic and short name for the configuration, unique in the list
     of configurations.

description
     A textual description of the configuration.

host
     The routers host name or IP address

username
password
enable_password
     The routers username, login and enable passwords. If these attributes
     are not present or have a value of undef, the methods will prompt for
     passwords.

file
     File name where the machine configuration is stored, for example
     `/usr/local/cisco/etc/mycisco.conf'.

   Only root may add or remove configurations.

Remove($configFile, $name)
--------------------------

   (Class method) Removes configuration $name from the list of
configurations in the file `$configFile'.

   Only root may add or remove configurations.

Read($configFile, $name)
------------------------

   (Class method) Reads the configuration of the host $name from the
configuration file `$configFile' and returns a *Cisco::Conf* instance
representing the host.

Edit($editor, $file, $tmpDir)
-----------------------------

   (Instance method) Invoke the editor `$editor' to edit the configuration
file. If $editor is not defined, use $ENV{'EDITOR'} or the first editor
from the list of editors in the configuration file. (The *editors*
attribute.)

   For security reasons valid editors are restricted to those from the
configuration file. Editing takes place in the directory $tmpDir, so that
we can change the EUID to the users.

   Example:

     $self->Edit('emacs', 'myrouter.conf', '/tmp');

RCS($file, $inout)
------------------

   (Instance method) Invoke the revision control system (RCS) by using the
ci attribute from the config file

   Example:

     $self->RCS($file, "in");

Strip($configuration)
---------------------

   (Class method) Strips comments and empty lines from the machine
configuration in the string `$configuration' and returns the resulting
string.

   Comments may appear on any line, beginning with an exclamation mark.
Example:

     ! This is a comment
     interface Ethernet 0  ! Another comment

Load($file)
-----------

   (Instance method) Loads the current configuration from the host and
saves it into the file $file. If such a file already exists, it will be
overwritten silently: It is the calling functions task to emit a warning
or do whatever appropriate.

   You cannot choose arbitrary file names for $file: The location depends
on the settings of your local TFTP server. In particular you have to
*have* a local TFTP server running. :-) See `tftpd(1)' in this node for
details.

   Note that the file mode of $file will be 0666, on other words, the file
is readable and writeable for the world! You should change this as soon as
possible.

Save($file, $write)
-------------------

   (Instance method) Reads a machines configuration from $file and save it
into the router. Like with the Load method, possible locations of $file
depend on your TFTP servers settings.

   Note that the file mode of $file will be changed to 0444, on other
words, the file is readable for the world! You should change this as soon
as possible.

   If the argument $write is TRUE, the configuration will be saved into
the non-volatile memory by executing the command

     write memory

Info($configFile)
-----------------

   (Class method) Read a list of all configurations in `$configFile' and
return those configurations that are accessible by the current user.

EtcFile($config)
----------------

   (Instance method) Returns a routers config file name.

TftpFile($config)
-----------------

   (Instance method) Returns a routers TFTP file name.

CREDITS
=======

Esfandiar Tabari <Esfandiar_Tabari@hugoboss.com>
     for giving me the contract that included the cisconf script. :-)

Tungning Cheng <cherng@bbn.com>
     for fixing the nasty open file bug ...

Mike Newton <mike@delusion.org>
     for adding the username and supporting the Rcs module.

AUTHOR AND COPYRIGHT
====================

   This module is

     Copyright (C) 1998    Jochen Wiedmann
                           Am Eisteich 9
                           72555 Metzingen
                           Germany

     Phone: +49 7123 14887
     Email: joe@ispsoft.de

   All rights reserved.

   You may distribute this module under the terms of either the GNU
General Public License or the Artistic License, as specified in the Perl
README file.

SEE ALSO
========

   `cisconf(1)' in this node


File: pm.info,  Node: Cisco/Conf/Install,  Next: Class/Accessor,  Prev: Cisco/Conf,  Up: Module List

Create a configuration file for the Cisco::Conf module
******************************************************

NAME
====

   Cisco::Conf::Install - Create a configuration file for the Cisco::Conf
module

SYNOPSIS
========

     use Cisco::Conf::Install;
     Cisco::Conf::Install->Install($file, $prefix);

DESCRIPTION
===========

   This module is used to create configuration files for the Cisco::Conf
module. It holds a single class method, *Install*, that attempts to guess
the system defaults and queries the user for all settings.

   The prefix `$prefix' is used as a default for certain directory
settings.  The configuration is saved as $file. A hash ref with all
configuration is returned, the method dies in case of errors.

   The configuration file initially holds an empty list of routers. Use
the Add method or the -a option of the *cisconf* script to add routers.

AUTHOR AND COPYRIGHT
====================

   This module is

     Copyright (C) 1998    Jochen Wiedmann
                           Am Eisteich 9
                           72555 Metzingen
                           Germany

     Phone: +49 7123 14887
     Email: joe@ispsoft.de

   All rights reserved.

   You may distribute this module under the terms of either the GNU
General Public License or the Artistic License, as specified in the Perl
README file.

SEE ALSO
========

   `cisconf(1)' in this node, `Cisco::Conf(3)' in this node


File: pm.info,  Node: Class/Accessor,  Next: Class/Accessor/Fast,  Prev: Cisco/Conf/Install,  Up: Module List

Automated accessor generation
*****************************

NAME
====

     Class::Accessor - Automated accessor generation

SYNOPSIS
========

     package Foo;

     use base qw(Class::Accessor);
     Foo->mk_accessors(qw(this that whatever));

     # Meanwhile, in a nearby piece of code!
     # Class::Accessor provides new().
     my $foo = Foo->new;

     my $whatever = $foo->whatever;    # gets $foo->{whatever}
     $foo->this('likmi');              # sets $foo->{this} = 'likmi'
     
     # Similar to @values = @{$foo}{qw(that whatever)}
     @values = $foo->get(qw(that whatever));
     
     # sets $foo->{that} = 'crazy thing'
     $foo->set('that', 'crazy thing');

DESCRIPTION
===========

   This module automagically generates accessor/mutators for your class.

   Most of the time, writing accessors is an exercise in cutting and
pasting.  You usually wind up with a series of methods like this:

     # accessor for $obj->{foo}
     sub foo {
         my($self) = shift;

     if(@_ == 1) {
         $self->{foo} = shift;
     }
     elsif(@_ > 1) {
         $self->{foo} = [@_];
     }

     return $self->{foo};
       }

     # accessor for $obj->{bar}
     sub bar {
         my($self) = shift;

     if(@_ == 1) {
         $self->{bar} = shift;
     }
     elsif(@_ > 1) {
         $self->{bar} = [@_];
     }

     return $self->{bar};
       }

     # etc...

   One for each piece of data in your object.  While some will be unique,
doing value checks and special storage tricks, most will simply be
exercises in repetition.  Not only is it Bad Style to have a bunch of
repetitious code, but its also simply not Lazy, which is the real tragedy.

   If you make your module a subclass of Class::Accessor and declare your
accessor fields with mk_accessors() then you'll find yourself with a set
of automatically generated accessors which can even be customized!

   The basic set up is very simple:

     package My::Class;
     use base qw(Class::Accessor);
     My::Class->mk_accessors( qw(foo bar car) );

   Done.  My::Class now has simple foo(), bar() and car() accessors
defined.

What Makes This Different?
--------------------------

   What makes this module special compared to all the other method
generating modules (`"SEE ALSO"' in this node)?  By overriding the get()
and set() methods you can alter the behavior of the accessors class-wide.
Also, the accessors are implemented as closures which should cost a bit
less memory than most other solutions which generate a new method for each
accessor.

Methods
-------

new
          my $obj = Class->new;
          my $obj = $other_obj->new;

          my $obj = Class->new(\%fields);
          my $obj = $other_obj->new(\%fields);

     Class::Accessor provides a basic constructor.  It generates a
     hash-based object and can be called as either a class method or an
     object method.

     It takes an optional %fields hash which is used to initialize the
     object (handy if you use read-only accessors).  The fields of the hash
     correspond to the names of your accessors, so...

          package Foo;
          use base qw(Class::Accessor);
          Foo->mk_accessors('foo');

          my $obj = Class->new({ foo => 42 });
          print $obj->foo;    # 42

     however %fields can contain anything, new() will shove them all into
     your object.  Don't like it?  Override it.

mk_accessors
          Class->mk_accessors(@fields);

     This creates accessor/mutator methods for each named field given in
     @fields.  Foreach field in @fields it will generate two accessors.
     One called "field()" and the other called "_field_accessor()".  For
     example:

          # Generates foo(), _foo_accessor(), bar() and _bar_accessor().
          Class->mk_accessors(qw(foo bar));

     See `CAVEATS AND TRICKS' in this node for details.

mk_ro_accessors
mk_readonly_accessors
          Class->mk_ro_accessors(@read_only_fields);

     Same as mk_accessors() except it will generate read-only accessors
     (ie. true accessors).  If you attempt to set a value with these
     accessors it will throw an exception.  It only uses get() and not
     set().

          package Foo;
          use base qw(Class::Accessor);
          Class->mk_ro_accessors(qw(foo bar));

          # Let's assume we have an object $foo of class Foo...
          print $foo->foo;  # ok, prints whatever the value of $foo->{foo} is
          $foo->foo(42);    # BOOM!  Naughty you.

mk_wo_accessors
          Class->mk_wo_accessors(@write_only_fields);

     Same as mk_accessors() except it will generate write-only accessors
     (ie. mutators).  If you attempt to read a value with these accessors
     it will throw an exception.  It only uses set() and not get().

     NOTE I'm not entirely sure why this is useful, but I'm sure someone
     will need it.  If you've found a use, let me know.  Right now its here
     for orthoginality and because its easy to implement.

          package Foo;
          use base qw(Class::Accessor);
          Class->mk_wo_accessors(qw(foo bar));

          # Let's assume we have an object $foo of class Foo...
          $foo->foo(42);      # OK.  Sets $self->{foo} = 42
          print $foo->foo;    # BOOM!  Can't read from this accessor.

   The rest is details.

DETAILS
=======

   An accessor generated by Class::Accessor looks something like this:

     # Your foo may vary.
     sub foo {
         my($self) = shift;
         if(@_) {    # set
             return $self->set('foo', @_);
         }
         else {
             return $self->get('foo');
         }
     }

   Very simple.  All it does is determine if you're wanting to set a value
or get a value and calls the appropriate method.  Class::Accessor provides
default get() and set() methods which your class can override.  They're
detailed later.

Modifying the behavior of the accessor
--------------------------------------

   Rather than actually modifying the accessor itself, it is much more
sensible to simply override the two key methods which the accessor calls.
Namely set() and get().

   If you -really- want to, you can override make_accessor().

set
          $obj->set($key, $value);
          $obj->set($key, @values);

     set() defines how generally one stores data in the object.

     override this method to change how data is stored by your accessors.

get
          $value  = $obj->get($key);
          @values = $obj->get(@keys);

     get() defines how data is retreived from your objects.

     override this method to change how it is retreived.

make_accessor
          $accessor = Class->make_accessor($field);

     Generates a subroutine reference which acts as an accessor for the
     given $field.  It calls get() and set().

     If you wish to change the behavior of your accessors, try overriding
     get() and set() before you start mucking with make_accessor().

make_ro_accessor
          $read_only_accessor = Class->make_ro_accessor($field);

     Generates a subroutine refrence which acts as a read-only accessor for
     the given $field.  It only calls get().

     Override get() to change the behavior of your accessors.

make_wo_accessor
          $read_only_accessor = Class->make_wo_accessor($field);

     Generates a subroutine refrence which acts as a write-only accessor
     (mutator) for the given $field.  It only calls set().

     Override set() to change the behavior of your accessors.

EFFICIENCY
==========

   Class::Accessor does not employ an autoloder, thus it is much faster
than you'd think.  Its generated methods incur no special penalty over
ones you'd write yourself.

   Here's the results of benchmarking Class::Accessor,
Class::Accessor::Fast, a hand-written accessor and direct hash access
(generated by examples/bench).

     Benchmark: timing 500000 iterations of By Hand - get, By Hand - set,
       C::A - get, C::A - set, C::A::Fast - get, C::A::Fast - set,
       Direct - get, Direct - set...

     By Hand - get:  4 wallclock secs ( 5.09 usr +  0.00 sys =  5.09 CPU)
                     @ 98231.83/s (n=500000)
     By Hand - set:  5 wallclock secs ( 6.06 usr +  0.00 sys =  6.06 CPU)
                     @ 82508.25/s (n=500000)
     C::A - get:  9 wallclock secs ( 9.83 usr +  0.01 sys =  9.84 CPU)
                  @ 50813.01/s (n=500000)
     C::A - set: 11 wallclock secs ( 9.95 usr +  0.00 sys =  9.95 CPU)
                  @ 50251.26/s (n=500000)
     C::A::Fast - get:  6 wallclock secs ( 4.88 usr +  0.00 sys =  4.88 CPU)
                        @ 102459.02/s (n=500000)
     C::A::Fast - set:  6 wallclock secs ( 5.83 usr +  0.00 sys =  5.83 CPU)
                        @ 85763.29/s (n=500000)
     Direct - get:  0 wallclock secs ( 0.89 usr +  0.00 sys =  0.89 CPU)
                    @ 561797.75/s (n=500000)
     Direct - set:  2 wallclock secs ( 0.87 usr +  0.00 sys =  0.87 CPU)
                    @ 574712.64/s (n=500000)

   So Class::Accessor::Fast is just as fast as one you'd write yourself
while Class::Accessor is twice as slow, a price paid for flexibility.
Direct hash access is about six times faster, but provides no
encapsulation and no flexibility.

   Of course, its not as simple as saying "Class::Accessor is twice as
slow as one you write yourself".  These are benchmarks for the simplest
possible accessor, if your accessors do any sort of complicated work (such
as talking to a database or writing to a file) the time spent doing that
work will quickly swamp the time spend just calling the accessor.  In that
case, Class::Accessor and the ones you write will tend to be just as fast.

EXAMPLES
========

   Here's an example of generating an accessor for every public field of
your class.

     package Altoids;
     
     use base qw(Class::Accessor Class::Fields);
     use fields qw(curiously strong mints);
     Altoids->mk_accessors( Altoids->show_fields('Public') );

     sub new {
         my $proto = shift;
         my $class = ref $proto || $proto;
         return fields::new($class);
     }

     my Altoids $tin = Altoids->new;

     $tin->curiously('Curiouser and curiouser');
     print $tin->{curiously};    # prints 'Curiouser and curiouser'

     # Subclassing works, too.
         package Mint::Snuff;
         use base qw(Altoids);

     my Mint::Snuff $pouch = Mint::Snuff->new;
     $pouch->strong('Fuck you up strong!');
     print $pouch->{strong};     # prints 'Fuck you up strong!'

   Here's a simple example of altering the behavior of your accessors.

     package Foo;
     use base qw(Class::Accessor);
     Foo->mk_accessor(qw(this that up down));

     sub get {
         my($self, @keys) = @_;

     # Note every time someone gets some data.
     print STDERR "Getting @keys\n";

     $self->SUPER::get(@keys);
         }

     sub set {
         my($self, $key, @values) = @_;

     # Note every time someone sets some data.
     print STDERR "Setting $key to @values\n";

     $self->SUPER::set($key, @values);
         }

CAVEATS AND TRICKS
==================

   Class::Accessor has to do some internal wackiness to get its job done
quickly and efficiently.  Because of this, there's a few tricks and traps
one must know about.

   Hey, nothing's perfect.

Don't make a field called DESTROY
---------------------------------

   This is bad.  Since DESTROY is a magical method it would be bad for us
to define an accessor using that name.  Class::Accessor will carp if you
try to use it with a field named "DESTROY".

Overriding autogenerated accessors
----------------------------------

   You may want to override the autogenerated accessor with your own, yet
have your custom accessor call the default one.  For instance, maybe you
want to have an accessor which checks its input.  Normally, one would
expect this to work:

     package Foo;
     use base qw(Class::Accessor);
     Foo->mk_accessors(qw(email this that whatever));

     # Only accept addresses which look valid.
     sub email {
         my($self) = shift;
         my($email) = @_;

     if( @_ ) {  # Setting
         require Email::Valid;
         unless( Email::Valid->address($email) ) {
             carp("$email doesn't look like a valid address.");
             return;
         }
     }

     return $self->SUPER::email(@_);
         }

   There's a subtle problem in the last example, and its in this line:

     return $self->SUPER::email(@_);

   If we look at how Foo was defined, it called mk_accessors() which stuck
email() right into Foo's namespace.  There *is* no SUPER::email() to
delegate to!  Two ways around this... first is to make a "pure" base class
for Foo.  This pure class will generate the accessors and provide the
necessary super class for Foo to use:

     package Pure::Organic::Foo;
     use base qw(Class::Accessor);
     Pure::Organic::Foo->mk_accessors(qw(email this that whatever));

     package Foo;
     use base qw(Pure::Organic::Foo);

   And now Foo::email() can override the generated
Pure::Organic::Foo::email() and use it as SUPER::email().

   This is probably the most obvious solution to everyone but me.
Instead, what first made sense to me was for mk_accessors() to define an
alias of email(), _email_accessor().  Using this solution, Foo::email()
would be written with:

     return $self->_email_accessor(@_);

   instead of the expected SUPER::email().

AUTHOR
======

   Michael G Schwern <schwern@pobox.com>

THANKS
======

   Thanks to Tels for his big feature request/bug report.

SEE ALSO
========

   *Note Class/Accessor/Fast: Class/Accessor/Fast,

   These are some modules which do similar things in different ways *Note
Class/Struct: Class/Struct,, `Class::Methodmaker' in this node, *Note
Class/Generate: Class/Generate,, *Note Class/Class: Class/Class,, *Note
Class/Contract: Class/Contract,

   *Note Class/DBI: Class/DBI, for an example of this module in use.


