This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: OS2/Focus,  Next: OS2/Proc,  Prev: OS2/Attrib,  Up: Module List

Perl extension to get and set focus on PM windows.
**************************************************

NAME
====

   OS2::Focus - Perl extension to get and set focus on PM windows.

SYNOPSIS
========

     use OS2::Focus ':short';
     $old_focus = QueryFocus;
     ...				# Say, create some Tk windows...
     SetFocus($old_focus) or warn "Cannot change focus, the error is $^E.\n".

DESCRIPTION
===========

EXPORT
------

   None by default.

Exportable constants
--------------------

   `HWND_DESKTOP' is exported with a tag `:win'.

Exportable functions
--------------------

   See `PMREF' documentation for the following functions:

     BOOL WinFocusChange (HWND hwndDesktop, HWND hwndSetFocus, ULONG flFocusChange)
     HWND WinQueryFocus (HWND hwndDesktop)
     BOOL WinSetFocus (HWND hwndDesktop, HWND hwndSetFocus)

   which are exported with a tag `:win'.  Use `HWND_DESKTOP' (exported with
the same tag) as the first argument for these functions.

   Prefix `Win' can be removed, the resulted functions omit the first
argument, and fill $! and $^E on error.  These functions are exported with
a tag `:short'.

AUTHOR
======

   Ilya Zakharevich, ilya@math.ohio-state.edu.

SEE ALSO
========

   perl(1).


File: pm.info,  Node: OS2/Proc,  Next: OS2/Process,  Prev: OS2/Focus,  Up: Module List

Perl extension for blah blah blah
*********************************

NAME
====

   OS2::Proc - Perl extension for blah blah blah

SYNOPSIS
========

     use OS2::Proc;
     blah blah blah

DESCRIPTION
===========

   Stub documentation for OS2::Proc was created by h2xs. It looks like the
author of the extension was negligent enough to leave the stub unedited.

   Blah blah blah.

AUTHOR
======

   A. U. Thor, a.u.thor@a.galaxy.far.far.away

SEE ALSO
========

   perl(1).


File: pm.info,  Node: OS2/Process,  Next: OS2/SoftInstaller,  Prev: OS2/Proc,  Up: Module List

exports constants for system() call on OS2.
*******************************************

NAME
====

   OS2::Process - exports constants for system() call on OS2.

SYNOPSIS
========

     use OS2::Process;
     $pid = system(P_PM+P_BACKGROUND, "epm.exe");

DESCRIPTION
===========

   the builtin function system() under OS/2 allows an optional first
argument which denotes the mode of the process. Note that this argument is
recognized only if it is strictly numerical.

   You can use either one of the process modes:

     P_WAIT (0)	= wait until child terminates (default)
     P_NOWAIT	= do not wait until child terminates
     P_SESSION	= new session
     P_DETACH	= detached
     P_PM		= PM program

   and optionally add PM and session option bits:

     P_DEFAULT (0)	= default
     P_MINIMIZE	= minimized
     P_MAXIMIZE	= maximized
     P_FULLSCREEN	= fullscreen (session only)
     P_WINDOWED	= windowed (session only)

     P_FOREGROUND	= foreground (if running in foreground)
     P_BACKGROUND	= background

     P_NOCLOSE	= don't close window on exit (session only)

     P_QUOTE		= quote all arguments
     P_TILDE		= MKS argument passing convention
     P_UNRELATED	= do not kill child when father terminates

Access to process properties
----------------------------

   Additionaly, subroutines my_type(), process_entry() and
`file_type(file)', get_title() and `set_title(newtitle)' are implemented.
my_type() returns the type of the current process (one of "FS", "DOS",
"VIO", "PM", "DETACH" and "UNKNOWN"), or undef on error.

`file_type(file)'
     returns the type of the executable file file, or dies on error.  The
     bits 0-2 of the result contain one of the values

    `T_NOTSPEC' (0)
          Application type is not specified in the executable header.

    `T_NOTWINDOWCOMPAT' (1)
          Application type is not-window-compatible.

    `T_WINDOWCOMPAT' (2)
          Application type is window-compatible.

    `T_WINDOWAPI' (3)
          Application type is window-API.

     The remaining bits should be masked with the following values to
     determine the type of the executable:

    `T_BOUND' (8)
          Set to 1 if the executable file has been "bound" (by the BIND
          command) as a Family API application. Bits 0, 1, and 2 still
          apply.

    `T_DLL' (0x10)
          Set to 1 if the executable file is a dynamic link library (DLL)
          module. Bits 0, 1, 2, 3, and 5 will be set to 0.

    `T_DOS' (0x20)
          Set to 1 if the executable file is in PC/DOS format. Bits 0, 1,
          2, 3, and 4 will be set to 0.

    `T_PHYSDRV' (0x40)
          Set to 1 if the executable file is a physical device driver.

    `T_VIRTDRV' (0x80)
          Set to 1 if the executable file is a virtual device driver.

    `T_PROTDLL' (0x100)
          Set to 1 if the executable file is a protected-memory dynamic
          link library module.

    `T_32BIT' (0x4000)
          Set to 1 for 32-bit executable files.

     file_type() may croak with one of the strings `"Invalid EXE
     signature"' or `"EXE marked invalid"' to indicate typical error
     conditions.  If given non-absolute path, will look on PATH, will add
     extention `.exe' if no extension is present (add extension .  to
     suppress).

process_entry()
     returns a list of the following data:


          Title of the process (in the `Ctrl-Esc' list);


          window handle of switch entry of the process (in the `Ctrl-Esc'
          list);


          window handle of the icon of the process;


          process handle of the owner of the entry in `Ctrl-Esc' list;


          process id of the owner of the entry in `Ctrl-Esc' list;


          session id of the owner of the entry in `Ctrl-Esc' list;


          whether visible in `Ctrl-Esc' list;


          whether item cannot be switched to (note that it is not actually
          grayed in the `Ctrl-Esc' list));


          whether participates in jump sequence;


          program type.  Possible values are:

               PROG_DEFAULT                       0
               PROG_FULLSCREEN                    1
               PROG_WINDOWABLEVIO                 2
               PROG_PM                            3
               PROG_VDM                           4
               PROG_WINDOWEDVDM                   7

          Although there are several other program types for WIN-OS/2
          programs, these do not show up in this field. Instead, the
          PROG_VDM or PROG_WINDOWEDVDM program types are used. For
          instance, for PROG_31_STDSEAMLESSVDM, PROG_WINDOWEDVDM is used.
          This is because all the WIN-OS/2 programs run in DOS sessions.
          For example, if a program is a windowed WIN-OS/2 program, it
          runs in a PROG_WINDOWEDVDM session. Likewise, if it's a
          full-screen WIN-OS/2 program, it runs in a PROG_VDM session.

`set_title(newtitle)'
     - does not work with some windows (if the title is set from the
     start).  This is a limitation of OS/2, in such a case $^E is set to
     372 (type

          help 372

     for a funny - and wrong  - explanation ;-).

get_title()
     is a shortcut implemented via process_entry().

AUTHOR
======

   Andreas Kaiser <ak@ananke.s.bawue.de>, Ilya Zakharevich
<ilya@math.ohio-state.edu>.

SEE ALSO
========

   `spawn*'() system calls.


File: pm.info,  Node: OS2/SoftInstaller,  Next: OS2/WinObject,  Prev: OS2/Process,  Up: Module List

Perl extension for generation of daughter packages for IBM's Software Installer.
********************************************************************************

NAME
====

   OS2::SoftInstaller - Perl extension for generation of daughter packages
for IBM's Software Installer.

SYNOPSIS
========

     use OS2::SoftInstaller;
     open PKG, '>my.pkg';
     select PKG;
     make_pkg toplevel => '.', zipfile => 'my.zip', packid => 'myzip',
       nozip => 0, exclude => undef, dirid => 'FILE', strip => 'emx/';
     select STDOUT;
     close PKG;

DESCRIPTION
===========

size_date_time_pkg(name)
------------------------

   Takes file name, returns an array `($size, $date,$time)', suitable for
`SIZE', DATE, and TIME entries of SoftInstaller.

make_pkg(...)
-------------

   The function make_pkg() takes a hash-like list of arguments. The
recognized keys are:

toplevel
     toplevel directory of the tree to duplicate.

zipfile
     name of the zipfile which corresponds to this directory in the
     distribution.

packid
     symbolic name for this zipfile, autogenerated if needed.

nozip
     Do not generate toplevel description of the ZIP file (useful if the
     same zipfile is used in multiple components).

exclude
     if defined, is a regexp for files to exclude from the generated
     package file.

dirid
     id of the directory to install to (eg, FILE or AUX7).

strip
     prefix in all the files in the ZIP file which should be removed. It is
     supposed that the default value for the directory to install to (eg,
     FILE or AUX7) already contains this prefix. (Useful to make the ZIP
     file appropriate for manual install as well.)

   We suppose that `%unzip%' has the value of something like `unzip -oj',
`%unzip_d%' is something like -d (directory to extract), and the output of
this script is included like this:

     FILE
       EXIT = 'setvar unzip=unzip -oj'

     FILE
       EXIT = 'setvar unzip_d=-d'

     INCLUDE
       NAME = 'my.pkg'

   into the parent package file.

AUTHOR
======

   Ilya Zakharevich, ilya@math.ohio-state.edu

SEE ALSO
========

   perl(1).


File: pm.info,  Node: OS2/WinObject,  Next: OS390/Stdio,  Prev: OS2/SoftInstaller,  Up: Module List

Perl extension for blah blah blah
*********************************

NAME
====

   OS2::WinObject - Perl extension for blah blah blah

SYNOPSIS
========

     use OS2::WinObject;
     blah blah blah

DESCRIPTION
===========

   Stub documentation for OS2::WinObject was created by h2xs. It looks
like the author of the extension was negligent enough to leave the stub
unedited.

   Blah blah blah.

EXPORT
------

   None by default.

Exportable constants
--------------------

     CO_FAILIFEXISTS
     CO_REPLACEIFEXISTS
     CO_UPDATEIFEXISTS
     OPEN_AUTO
     OPEN_BATTERY
     OPEN_CONTENTS
     OPEN_DEFAULT
     OPEN_DETAILS
     OPEN_HELP
     OPEN_PALETTE
     OPEN_PROMPTDLG
     OPEN_RUNNING
     OPEN_SETTINGS
     OPEN_STATUS
     OPEN_TREE
     OPEN_USER
     PMERR_INVALID_FLAG
     PMERR_INVALID_HPTR
     PMERR_INVALID_HWND
     PMERR_INV_HDC
     PMERR_WPDSERVER_IS_ACTIVE
     PMERR_WPDSERVER_NOT_STARTED
     SWP_ACTIVATE
     SWP_DEACTIVATE
     SWP_EXTSTATECHANGE
     SWP_FOCUSACTIVATE
     SWP_FOCUSDEACTIVATE
     SWP_HIDE
     SWP_MAXIMIZE
     SWP_MINIMIZE
     SWP_MOVE
     SWP_NOADJUST
     SWP_NOAUTOCLOSE
     SWP_NOREDRAW
     SWP_RESTORE
     SWP_SHOW
     SWP_SIZE
     SWP_ZORDER

Exportable functions
--------------------

   When accessing these functions from Perl, prefix `Win' should be
removed.

     HOBJECT WinCopyObject (HOBJECT hObjectofObject, HOBJECT hObjectofDest,
       ULONG ulReserved)
     HOBJECT WinCreateObject (PCSZ pszClassName, PCSZ pszTitle, PCSZ pszSetupString,
       PCSZ pszLocation, ULONG ulFlags)
     BOOL WinDeregisterObjectClass (PCSZ pszClassName)
     BOOL WinDestroyObject (HOBJECT hObject)
     BOOL WinEnumObjectClasses (POBJCLASS pObjClass, PULONG pulSize)
     BOOL WinFreeFileIcon (HPOINTER hptr)
     BOOL WinIsSOMDDReady (void )
     BOOL WinIsWPDServerReady (void )
     HPOINTER WinLoadFileIcon (PCSZ pszFileName, BOOL fPrivate)
     HOBJECT WinMoveObject (HOBJECT hObjectofObject, HOBJECT hObjectofDest,
       ULONG ulReserved)
     BOOL WinOpenObject (HOBJECT hObject, ULONG ulView, BOOL fFlag)
     BOOL WinQueryActiveDesktopPathname (PSZ pszPathName, ULONG ulSize)
     BOOL WinQueryDesktopBkgnd (HWND hwndDesktop, PDESKTOP pdsk)
     HWND WinQueryDesktopWindow (HAB hab, HDC hdc)
     HOBJECT WinQueryObject (PCSZ pszObjectID)
     BOOL WinQueryObjectPath (HOBJECT hobject, PSZ pszPathName, ULONG ulSize)
     HWND WinQueryObjectWindow (HWND hwndDesktop)
     BOOL WinQueryWindowPos (HWND hwnd, PSWP pswp)
     BOOL WinRegisterObjectClass (PCSZ pszClassName, PCSZ pszModName)
     BOOL WinReplaceObjectClass (PCSZ pszOldClassName, PCSZ pszNewClassName,
       BOOL fReplace)
     ULONG WinRestartSOMDD (BOOL fState)
     ULONG WinRestartWPDServer (BOOL fState)
     BOOL WinRestoreWindowPos (PCSZ pszAppName, PCSZ pszKeyName, HWND hwnd)
     BOOL WinSaveObject (HOBJECT hObject, BOOL fAsync)
     BOOL WinSaveWindowPos (HSAVEWP hsvwp, PSWP pswp, ULONG cswp)
     HBITMAP WinSetDesktopBkgnd (HWND hwndDesktop, __const__ DESKTOP *pdskNew)
     BOOL WinSetFileIcon (PCSZ pszFileName, __const__ ICONINFO *pIconInfo)
     BOOL WinSetMultWindowPos (HAB hab, __const__ SWP *pswp, ULONG cswp)
     BOOL WinSetObjectData (HOBJECT hObject, PCSZ pszSetupString)
     BOOL WinSetWindowPos (HWND hwnd, HWND hwndInsertBehind, LONG x, LONG y,
       LONG cx, LONG cy, ULONG fl)
     BOOL WinShutdownSystem (HAB hab, HMQ hmq)
     BOOL WinStoreWindowPos (PCSZ pszAppName, PCSZ pszKeyName, HWND hwnd)

AUTHOR
======

   A. U. Thor, a.u.thor@a.galaxy.far.far.away

SEE ALSO
========

   perl(1).


File: pm.info,  Node: OS390/Stdio,  Next: Object/Transaction,  Prev: OS2/WinObject,  Up: Module List

S/390 standard I/O functions via POSIX/XPG extensions
*****************************************************

NAME
====

   OS390::Stdio - S/390 standard I/O functions via POSIX/XPG extensions

SYNOPSIS
========

     use OS390::Stdio qw( &get_dcb &getname &pds_mem &sysdsnr
                          &mvsopen &mvswrite
                          &flush &forward &rewind &resetpos
                          &remove &tmpnam
                          &vsamdelrec &vsamlocate &vsamupdate
       # future dslist        &dsname_level &vol_ser
       # future SVC 99        &dynalloc &dynfree &svc99
                        );

     @dslist = dsname_level("FRED");
     $uniquename = tmpnam;
     $fh = mvsopen("//MY.STUFF","a recfm=F") or die $!;
     $name = getname($fh);
     print $fh "Hello, world!\n";
     flush($fh);
     rewind($fh);
     $line = <$fh>;
     undef $fh;  # closes data set
     $fh = mvsopen("dd:MYDD(MEM)", "recfm=U");
     sysread($fh,$data,128);
     close($fh);
     remove("dd:MYDD(MEM)");
     @members = pds_mem("//SYS1.SPECIAL");

DESCRIPTION
===========

   This package gives Perl scripts access via POSIX extensions to several
C stdio operations not available through Perl's CORE I/O functions.  The
specific routines are described below.  These functions are prototyped as
unary operators, with the exception of mvsopen which takes two arguments,
mvswrite which takes three arguments, dynalloc, svc99 which take several
arguments, and tmpnam which takes none.

   All of the routines are available for export, though none are exported
by default.  All of the constants used by vsamupdate to specify update
options are exported by default.  The routines are associated with the
Exporter tag FUNCTIONS, the experimental routines are associated with the
Exporter tag EXPERIMENAL, and the constants are associated with the
Exporter tag CONSTANTS, so you can more easily choose what you'd like to
import:

     # import constants, but not functions
     use OS390::Stdio;  # same as use OS390::Stdio qw( :DEFAULT );
     # import functions, but not constants
     use OS390::Stdio qw( !:CONSTANTS :FUNCTIONS );
     # import both
     use OS390::Stdio qw( :CONSTANTS :FUNCTIONS );
     # import neither
     use OS390::Stdio ();
     # import everything
     use OS390::Stdio (:CONSTANTS :FUNCTIONS :EXPERIMENTAL );

   Of course, you can also choose to import specific functions by name, as
usual.

   This package ISA IO::File, so that you can call *Note IO/File: IO/File,
methods on the handles returned by mvsopen.  The IO::File package is not
initialized, however, until you actually call a method that OS390::Stdio
doesn't provide.  This is done to save startup time for users who don't
wish to use the IO::File methods.

   In the following `DSH' refers to a data set handle such as returned by
the mvsopen routine.  For OS data sets NAME refers to either a double
slashed name such as `//BETTY.BAM', or members such as `//BETTY.BAM(BAM)';
or to dd names such as `dd:WILMA.PEBBLES'.

flush EXPR
     This function causes the contents of stdio buffers for the specified
     data set handle to be flushed.  If undef is used as the argument to
     flush, all currently open data set handles are flushed.  Like the CRTL
     fflush() routine, the buffering mode and file type can have an effect
     on when output data is flushed.  flush returns a true value if
     successful, and undef if not.

forward DSH
     forward resets the current position of the specified data set handle
     to the end of the data set.  It's really just a convenience method
     equivalent in effect to `fseek($fh,0L,SEEK_END)'.  It returns a true
     value if successful, and undef if it fails.  See also rewind and
     resetpos.

get_dcb DSH
     This function retrieves the data control block information for the
     data set handle passed to it and returns it in a hash with keys
     approximated by the names of the elements of the `fldata_t' struct
     (see the documentaton for the `fldata()' C RTL routine for further
     information).

     For example:

          use OS390::Stdio qw(mvsopen get_dcb);
          my $dshandle = mvsopen("//SEDIMENT.SLATE","r");
          my %slate_dcb = get_dcb($dshandle);
          close($dshandle);
          for (sort(keys(%slate_dcb))) {
              print "$_ = $slate_dcb{$_}\n";
          }

     For the inverse (i.e. setting data set attributes) use appropriate
     arguments with either mvsopen, dynalloc, or svc99.  For just the
     filename you can use getname in place of get_dcb.

getname DSH
     The getname function returns the data set filename associated with a
     Perl I/O handle (via `fldata()').  If an error occurs, it returns
     undef.

     As an example consider:

          $dshandle = mvsopen("//FOO.BAR","r");
          $fullname = getname($dshandle);
          $hlq = $fullname;
          $hlq =~ s/\'([^\.]+)\..*/$1/;  # strip leading ' and trailing DS names
          print "The high level qualifier (HLQ) is $hlq\n";

     or, assuming you are authorized to do so, in order to switch to a
     different HLQ:

          $mydshandle = mvsopen("//FOO.BAR","r");
          $myfullname = getname($mydshandle);
          $bobsuid = '214';
          setuid($bobsuid);
          $bobsdshandle = mvsopen("//FOO.BAR","r");
          $bobsfullname = getname($bobsdshandle);
          $bobshlq = $bobsfullname;
          $bobshlq =~ s/\'([^\.]+)\..*/$1/;
          print "Bob's pwname is ",(getpwuid($<))[0],"\n";
          print "Bob's high level qualifier (HLQ) is $bobshlq\n";

     Note that both of these examples assume that UIDs map directly to
     profile prefixes, whereas they may not in general.  To obtain more
     extensive information for a given data set handle see get_dcb.

mvsopen NAME MODE
     The mvsopen function enables you to specify optional arguments to the
     CRTL when opening a data set.  Its operation is similar to the
     built-in Perl open function (see *Note Perlfunc: (perl.info)perlfunc,
     for a complete description), but it will only open normal data sets;
     it cannot open pipes or duplicate existing I/O handles.  The MODE is
     typically taken from:

          qw(r w a r+ w+ a+ rb wb ab rt wt at rb+ wb+ ab+ rt+ wt+ at+)

     Additional MODE keyword parameters can be passed from:

          qw(acc= blksize= byteseek lrecl= recfm= type= asis password= noseek)

     (See the *C/C++ MVS Programming Guide* and the *C/C++ MVS Library
     Reference* descriptions of `fopen()' for detailed information on NAME
     and MODE arguments.)  If successful, mvsopen returns a data set
     handle; if an error occurs, it returns undef.

     You can use the data set handle returned by mvsopen just as you would
     any other Perl file handle.  The class OS390::Stdio ISA IO::File, so
     you can call IO::File methods using the handle returned by mvsopen.
     However, useing OS390::Stdio does not automatically use IO::File; you
     must do so explicitly in your program if you want to call IO::File
     methods.  This is done to avoid the overhead of initializing the
     IO::File package in programs which intend to use the handle returned
     by mvsopen as a normal Perl data set handle only.  When the scalar
     containing a OS390::Stdio data set handle is overwritten, undefd, or
     goes out of scope, the associated data set is closed automatically.

mvswrite DSH EXPR LEN
     The mvswrite function provides access to stdio's `fwrite()' function.
     For example:

          use OS390::Stdio qw(mvsopen mvswrite);
          my $dshandle = mvsopen("//BED.ROCK","w+");
          my $fred,$data,$chrs_written;
          $fred = 100.00;
          $data = sprintf("Fred's salary is \$%3.2f",$fred);
          $chrs_written = mvswrite($dshandle,$data,length($data));
          close($dshandle);

pds_mem NAME
     Returns a list of members for the named PDS directory.  A list with a
     single undef element is returned for PDS directories that have no
     members as well as for data set names that are not partitioned (in the
     latter case a warning may appear on STDERR depending on how
     OS390::Stdio was compiled on your system).  For example:

          use OS390::Stdio qw(pds_mem);
          my @member_list = pds_mem("//SLATE.PDS");
          foreach my $mem (@member_list) {
              print "PDS.SLATE($mem)\n";
          }

remove NAME
     This function deletes the data set (member) named in its argument,
     returning a true value if successful and undef if not.  It differs
     from the CORE Perl function unlink in that it does not try to reset
     DS access if you are not authorized to delete the data set.

resetpos DSH
     resetpos resets the current position of the specified data set handle
     to the current position.  This is useful for switching between input
     and output at a given location.  It's really just a convenience
     method equivalent in effect to `fseek($fh,0L,SEEK_CUR)'.  It returns a
     true value if successful, and undef if it fails.  See also forward
     and rewind or Perl's builtin seek.  (This was not called setpos to
     avoid namespace collision).

rewind DSH
     rewind resets the current position of the specified data set handle
     to the beginning of the data set.  It's really just a convenience
     method equivalent in effect to `seek($fh,0,0)'.  It returns a true
     value if successful, and undef if it fails.  See also forward and
     resetpos.

sysdsnr NAME
     Returns true if the named data set is available to `fopen()' in "r"
     mode.  Note that perl's built in stat() function as well as the
     various file test operators such as -r do not work with OS data sets.

tmpnam
     The tmpnam function returns a unique string which can be used as an
     HFS (POSIX) data set name when creating temporary storage.  If, for
     some reason, it is unable to generate a name, it returns undef.  Note
     that in order to ensure the creation of an OS data set try using
     mvsopen with a data set name of the form `//&&name'.

vsamdelrec DSH
     Deletes a record from a VSAM data set via the C RTL `fdelrec()'
     routine.  You must seek to the proper record before invoking
     vsamdelrec of course.  See also mvsopen, vsamlocate, and vsamupdate.

vsamlocate DSH, key, key_len, options
     Locates a record in a VSAM data set via the C RTL `flocate()' routine.
     See also mvsopen, vsamdelrec, and vsamupdate.

vsamupdate DSH, record, length
     Updates a record in a VSAM data set via the C RTL `fupdate()' routine.
     See also mvsopen, vsamdelrec, and vsamlocate.

   The following functions are experimental: V 0.001: Some are not
currently working and either produce fatal errors or simply do not work as
intended.

dsname_level
     This function returns a ds list for a given HLQ plus optional
     additional qualifiers.  It returns undef if it encounters an error.
     (The name was taken from the ISPF 3.4 panel entry).  See also vol_ser.

     V 0.003: This routine is not yet implemented and causes a fatal error.

     Until this is working properly you can from perl code things such as:

          @listcat = `tso listcat`;

dynalloc
     Dynamically allocates a data set via the C RTL `dynalloc()' routine.
     See also svc99.

     V 0.003: This routine is not yet implemented and causes a fatal error.

dynfree
     Deallocates a data set via the C RTL `dynfree()' routine.  See also
     svc99.

     V 0.003: This routine is not yet implemented and causes a fatal error.

svc99
     This function provides access to the SVC 99 system service via a C
     RTL `svc99()' call.  See the *C/C++ MVS Library Reference* for
     information on `svc99()'.

     V 0.003: This routine is not yet implemented and causes a fatal error.

vol_ser
     Returns a dslist for a given volume serial input.   (The name was
     taken from the ISPF 3.4 panel entry).

     V 0.003: This routine is not yet implemented and causes a fatal error.

REVISION
========

   This document was last revised on 13-Apr-1999, for Perl 5.005_03.

   31-Aug-1998, VERSION 0.002 for Perl 5.005_02.


File: pm.info,  Node: Object/Transaction,  Next: Ogg/Vorbis,  Prev: OS390/Stdio,  Up: Module List

Virtual base class for transactions on files containing serialized hash objects
*******************************************************************************

NAME
====

   Object::Transaction - Virtual base class for transactions on files
containing serialized hash objects

SYNOPSIS
========

     package Pkg;

     @ISA = qw(Object::Transaction);

     use Object::Transaction;

     $obj = sub new { ... }
     sub file($ref,$id) { ... }

     $obj = load Pkg $id;
     $obj->savelater();
     $obj->save();
     $obj->removelater();
     $obj->remove();
     $obj->commit();
     $obj->uncache();
     $obj->abandon();
     $oldobj = $obj->old();

     $id = sub id { ... }
     $restart_commit = sub precommit() { }
     @passby = sub presave($old) { ... }
     sub postsave($old,@passby) { ... }
     $newid = sub preload($id) { .... }
     sub postload() { ... }
     sub preremove() { ... }
     sub postremove() { ... }

DESCRIPTION
===========

   *Object::Transaction* provides transaction support for hash-based
objects that are stored one-per-file using Storable.  Multiuser access is
supported.  In the future, serializing methods other than Storable will be
supported.

   *Object::Transaction* is a virtual base class.  In order to use it, you
must inherit from it and override the new method and the file method.

   Optomistic locking is used: it is possible that a transaction will fail
because the data that is is based upon has changed out from under it.

EXAMPLE
=======

     package User;

     @ISA = qw(Object::Transaction);

     use Object::Transaction;

     my $top = "/some/path";

     sub new {
     	my ($package, $login) = @_;
     	die unless getpwnam($login);
     	return bless { 'UID' => getpwnam($login) };
     }

     sub file {
     	my ($ref, $id) = @_;
     	$id = $ref->id() unless $id;
     	return "$top/users/$id/data.storable";
     }

     sub id {
     	my ($this) = @_;
     	return $this->{'UID'};
     }

     sub preload
     {
     	my ($id) = @_;
     	return if getpwuid($id);
     	return getpwnam($id) if getpwnam($id);
     	die;
     }

     sub postload
     {
     	my ($this) = @_;
     	my ($name,$passwd,$uid,$gid,$quota,$comment,$gcos,$dir,
     		$shell,$expire) = getpwuid($this->{'UID'});
     	$this->{'SHELL'} = $shell;
     }

     sub presave
     {
     	my ($this, $old) = @_;
     	my $id = $this->{'UID'};
     	mkdir("$top/users/$id", 0700);
     	delete $this->{'SHELL'};
     }

     sub postsave
     {
     	goto &postload;
     }

     sub postremove
     {
     	delete from pw file...
     }

     my $joe = new User "joe";
     $joe->savelater();

     my $fred = new User "fred";
     $fred->savelater();

     $joe->commit();

METHODS PROVIDED
================

   *Object::Transaction* provides the following methods.

`load($id)'
     load is the way to bring an object into memory.   It is usually
     invoked as `my $obj = load MyObject $id'.

     There are two opporunities to customize the behavior of load:
     `preload' for things that should happen before loading and `postload'
     for things that should happen after loading.

     *Object::Transaction* caches objects that are loaded.  This is done
     both for performance reasons and to make sure that only one copy of
     an object is in memory at a time.  If caching is not desired, the
     uncache method must be invoked after loading.

     X<savelater>

`savelater()'
     `savelater' is the usual method of saving an object.  The object is
     not saved at the time that `savelater' is invoked.  It is actually
     saved when commit is invoked.

     There are two opporunities to customize the behavior of `savelater':
     `presave' for things that should happen before saving and `postsave'
     for things that should happen after saving.  These are invoked when
     the object is actually being saved.

save()
     Simply `savelater' combined with a commit.

     X<removelater>

`removelater()'
     `removelater' is the usual method of removing an object.  The object
     is not removed at the time that `removelater' is invoked.  It is
     actually removed when commit is invoked.

     There are two opporunities to customize the behavior of `removelater':
     `preremove' for things that should happen before removing and
     `postremove' for things that should happen after removing.  These are
     invoked when the object is actually being removed.

remove()
     Simply `removelater' combined with a commit

     X<commit>

commit()
     commit writes all pending changes to disk.   Either all changes will
     be saved or none of them will.  Deadlocks are avoided by locking
     files in order.

     *Object::Transaction* uses opportunistic locking.  Commit can fail.
     If it fails, it will die with a message that begins `DATACHANGE:
     file'.  It is advisable to wrap your entire transaction inside an
     eval so that it can be re-tried in the event that the data on disk
     changed between the time is was loaded and commited.

     In the event of a commit failure, the object cache will be reset.  Do
     not keep any old references to objects after such a failure.

`transaction($funcref,@args)'
     `transaction()' is a wrapper for a complete transaction.
     Transactions that fail due to opportunistic locking problems will be
     re-run automatically.  Beware side-effects!

     The first parameter is a reference to a function.  Any additional
     parameters will be passed as parameters to that function.  The return
     value of `transaction()' is the return value of `&$funcref()'.

     It is not necessary to use the `transaction()' method.  Just beware
     that commit(), save(), and remove() can fail.   `transaction()' will
     keep trying until it suceeds or it failes for a reason other than an
     opportunistic locking problem.

     X<abandon>

`abandon()'
     As an alternative to commit, all changes may be abandoned.  Calling
     `abandon()' does not undo changes made to the in-memory copies of
     objects.

     X<uncache>

`uncache()'
     *Object::Transaction* caches all objects.  To flush an object from
     *Object::Transaction*'s cache, invoke the uncache method on the
     object.

     Be careful when doing this - it makes it possible to have more than
     one copy of the same object in memory.

     `uncache()' can be invoked as a class method rather than an object
     method (`Object::Transaction-'uncache()>).  When invoked as a class
     method, the entire cache is flushed.

`readlock()'
     By default *Object::Transaction* does not lock objects unless they
     are being modified.

     The `readlock()' method insures that objects are properly locked and
     unchanged during a transaction even if they are not being modified.
     `savelater()' takes precedence over `readlock()' so they can be
     combined freely.

     Paranoid programmers should use `readlock()' on most objects.

`old()'
     Return the previous version of an object.  Previous is only loosely
     defined.

REQUIRED METHODS TO OVERRIDE
============================

   The following methods must be overriden.

new
     *Object::Transaction* does not provide a contructor.  You must
     provide one yourself.

`file($ref,$id)'
     You must provide a function that returns the filename that an object
     is stored in.  The file method can be invoked in two ways: as an
     object method call without an $id parameter; or as a class method
     call with an $id parameter.

OPTIONAL METHODS TO OVERRIDE
============================

   The following methods may be overridden.

   X<preload>

`preload($id)'
     `preload()' is invoked as nearly the first step of load.   It is
     generally used to make sure that the $id is valid.  `preload()' is a
     class method rather than an object method.

     The return value of `preload' is a replacement $id.  For example, it
     might be called as `preload("Joe")' to load the user named Joe, but
     if users are numbered rather than named it could return the number
     for Joe.  A return value of undef is ignored.

     No lock on the underlying file is present at the time `preload' is
     called.

     X<postload>

`postload($id)'
     `postload' is invoked after the object has been loaded into memory but
     before transaction completeness is checked.

     The underlying file is locked at the time that `postload' is invoked.

     If a transaction rollback is required, `postload' will be invoked
     again after the object has been reverted to its pre-transaction state.

     X<presave>

`presave($old)'
     `presave()' is invoked just before an object is written to disk.

     Objects are stored on disk in the file specified by the file method.
     The directory in which that file resides must exist by the time
     `presave()' finishes.   `presave' should make the directory if it
     isn't already made.

     The underlying file may or may not be locked at the time `presave' is
     invoked.

     `presave' can be invoked as a side-effect of load if the object must
     roll back to a previous version.

     The parameter `$old' is a copy of the object as of the time it was
     first loaded into memory.

     Any return values from `presave' will be remembered and passed to
     `postsave'.

     `presave' may not invoke save(), commit(), or `savelater()'.

     X<postsave>

`postsave($old,@psv)'
     `postsave' is invoked after an object has been written to disk.

     The underlying file is always locked at the time `postsave' is
     invoked.

     Invocations of `presave' and `postsave' are always paired.

     The parameter `$old' is a copy of the object as of the time it was
     first loaded into memory.

     The parameter `@psv' is the return value from `presave'.

     `postsave' may not invoke save(), commit(), or `savelater()'.

     X<precommit>

`precommit($old)'
     `precommit' is invoked just before files are locked in commit().
     This is before `presave()'.

     Unlike `presave()' and `postsave()', `precommit()' may use
     `savelater()' to add new objects to the transaction.  If it does so,
     it must return a true value.

     X<id>

id()
     *Object::Transaction* expect to be able to find the unique identifier
     (id) for each object as `$obj-'{'ID'}>.  If that isn't the case, you
     can override the id function to provide an alternative.

PUBLIC MEMBER DATA
==================

   The following data members are used by *Object::Transaction*.

ID
     *Object::Transaction* expect to find the id for an object in
     `$obj-'{'ID'}>.  This can be overridden by defining your own id
     function.

`OLD'
     When an object is loaded into memory a copy is made.  The copy can be
     found at `$obj-'{'OLD'}>.  The copy should not be modified.  The copy
     is explicitly passed in `presave' and `postsave'.

PRIVATE MEMBER DATA
===================

   *Object::Transaction* ads a few data members to each object for its own
internal use.

   These are:

     __frozen
     __transfollowers
     __transleader
     __rollback
     __removenow
     __toremove
     __transdata
     __readonly
     __trivial

   None of these should be touched.

BUGS
====

   A program or computer crash at just the wrong moment can allow an
object that should be deleted to escape deletion.  Any future attempt to
access such an object will cause it to self-destruct.

   In some situations objects will be saved even if niether save() nor
`savelater()' is invoked.  This happens if `readlock()' is used and the
transaction leader object (one per transaction) choosen turns out to be an
object for which only `readlock()' was called.

AUTHOR
======

   David Muir Sharnoff <muir@idiom.com>

COPYRIGHT
=========

   Copyright (C) 1999-2000, Internet Journals Corporation
<www.bepress.com>.  All rights reserved.  License hearby granted for
anyone to use this module at their own risk.   Please feed useful changes
back to David Muir Sharnoff <muir@idiom.com>.


File: pm.info,  Node: Ogg/Vorbis,  Next: Opcode,  Prev: Object/Transaction,  Up: Module List

Perl extension for Ogg Vorbis streams
*************************************

NAME
====

   Ogg::Vorbis - Perl extension for Ogg Vorbis streams

SYNOPSIS
========

     use Ogg::Vorbis;
     $ogg = Ogg::Vorbis->new;
     open(INPUT, "< file.ogg");
     open(OUTPUT, "> file.pcm");
     $ogg->open(INPUT);
     $info = $ogg->info;
     %comments = %{$ogg->comment};
     $buffer = '-' x 4096;
     $big_endian_p = Ogg::Vorbis::host_is_big_endian();
     while ($bytes = $ogg->read($buffer, 4096, $big_endian_p,
                                2, 1, $current_bitstream) > 0) {
       syswrite(OUTPUT, $buffer, $bytes);
     }
     $ogg->clear;
     close(OUTPUT);
     close(INPUT);

DESCRIPTION
===========

   This is an object-oriented interface to the Ogg Vorbis libvorbisfile
convenience library.  To create a vorbisfile object, call
Ogg::Vorbis->new.  You can then open it on input streams with the open()
method, read data from it with read() method, and clean up with clear().
Other methods for obtaining information are available as in libvorbisfile.

   The info() method returns an Ogg::Vorbis::Info object.  You can access
the various fields of the vorbis_info struct with methods of the same name.

   The comment() method returns a hash of comment name => value entries.

   Currently libvorbisfile does not support writing or encoding, so you
cannot change comment values or encode a new file, but the functionality
to do so will be added soon.

AUTHOR
======

   Alex Shinn, foof@debian.org

SEE ALSO
========

   Ao(3pm), ogg123(1), oggenc(1), perl(1).


File: pm.info,  Node: Opcode,  Next: OpenCA/CRL,  Prev: Ogg/Vorbis,  Up: Module List

Disable named opcodes when compiling perl code
**********************************************

NAME
====

   Opcode - Disable named opcodes when compiling perl code

SYNOPSIS
========

     use Opcode;

DESCRIPTION
===========

   Perl code is always compiled into an internal format before execution.

   Evaluating perl code (e.g. via "eval" or "do 'file'") causes the code
to be compiled into an internal format and then, provided there was no
error in the compilation, executed.  The internal format is based on many
distinct opcodes.

   By default no opmask is in effect and any code can be compiled.

   The Opcode module allow you to define an *operator mask* to be in
effect when perl next compiles any code.  Attempting to compile code which
contains a masked opcode will cause the compilation to fail with an error.
The code will not be executed.

NOTE
====

   The Opcode module is not usually used directly. See the ops pragma and
Safe modules for more typical uses.

WARNING
=======

   The authors make *no warranty*, implied or otherwise, about the
suitability of this software for safety or security purposes.

   The authors shall not in any case be liable for special, incidental,
consequential, indirect or other similar damages arising from the use of
this software.

   Your mileage will vary. If in any doubt *do not use it*.

Operator Names and Operator Lists
=================================

   The canonical list of operator names is the contents of the array
PL_op_name defined and initialised in file `opcode.h' of the Perl source
distribution (and installed into the perl library).

   Each operator has both a terse name (its opname) and a more verbose or
recognisable descriptive name. The opdesc function can be used to return a
list of descriptions for a list of operators.

   Many of the functions and methods listed below take a list of operators
as parameters. Most operator lists can be made up of several types of
element. Each element can be one of

an operator name (opname)
     Operator names are typically small lowercase words like enterloop,
     leaveloop, last, next, redo etc. Sometimes they are rather cryptic
     like gv2cv, i_ncmp and ftsvtx.

an operator tag name (optag)
     Operator tags can be used to refer to groups (or sets) of operators.
     Tag names always begin with a colon. The Opcode module defines several
     optags and the user can define others using the define_optag function.

a negated opname or optag
     An opname or optag can be prefixed with an exclamation mark, e.g.,
     !mkdir.  Negating an opname or optag means remove the corresponding
     ops from the accumulated set of ops at that point.

an operator set (opset)
     An opset as a binary string of approximately 43 bytes which holds a
     set or zero or more operators.

     The opset and opset_to_ops functions can be used to convert from a
     list of operators to an opset and *vice versa*.

     Wherever a list of operators can be given you can use one or more
     opsets.  See also Manipulating Opsets below.

Opcode Functions
================

   The Opcode package contains functions for manipulating operator names
tags and sets. All are available for export by the package.

opcodes
     In a scalar context opcodes returns the number of opcodes in this
     version of perl (around 340 for perl5.002).

     In a list context it returns a list of all the operator names.  (Not
     yet implemented, use @names = opset_to_ops(full_opset).)

opset (OP, ...)
     Returns an opset containing the listed operators.

opset_to_ops (OPSET)
     Returns a list of operator names corresponding to those operators in
     the set.

opset_to_hex (OPSET)
     Returns a string representation of an opset. Can be handy for
     debugging.

full_opset
     Returns an opset which includes all operators.

empty_opset
     Returns an opset which contains no operators.

invert_opset (OPSET)
     Returns an opset which is the inverse set of the one supplied.

verify_opset (OPSET, ...)
     Returns true if the supplied opset looks like a valid opset (is the
     right length etc) otherwise it returns false. If an optional second
     parameter is true then verify_opset will croak on an invalid opset
     instead of returning false.

     Most of the other Opcode functions call verify_opset automatically
     and will croak if given an invalid opset.

define_optag (OPTAG, OPSET)
     Define OPTAG as a symbolic name for OPSET. Optag names always start
     with a colon :.

     The optag name used must not be defined already (define_optag will
     croak if it is already defined). Optag names are global to the perl
     process and optag definitions cannot be altered or deleted once
     defined.

     It is strongly recommended that applications using Opcode should use a
     leading capital letter on their tag names since lowercase names are
     reserved for use by the Opcode module. If using Opcode within a module
     you should prefix your tags names with the name of your module to
     ensure uniqueness and thus avoid clashes with other modules.

opmask_add (OPSET)
     Adds the supplied opset to the current opmask. Note that there is
     currently no mechanism for unmasking ops once they have been masked.
     This is intentional.

opmask
     Returns an opset corresponding to the current opmask.

opdesc (OP, ...)
     This takes a list of operator names and returns the corresponding list
     of operator descriptions.

opdump (PAT)
     Dumps to STDOUT a two column list of op names and op descriptions.
     If an optional pattern is given then only lines which match the (case
     insensitive) pattern will be output.

     It's designed to be used as a handy command line utility:

          perl -MOpcode=opdump -e opdump
          perl -MOpcode=opdump -e 'opdump Eval'

Manipulating Opsets
===================

   Opsets may be manipulated using the perl bit vector operators & (and),
| (or), ^ (xor) and ~ (negate/invert).

   However you should never rely on the numerical position of any opcode
within the opset. In other words both sides of a bit vector operator
should be opsets returned from Opcode functions.

   Also, since the number of opcodes in your current version of perl might
not be an exact multiple of eight, there may be unused bits in the last
byte of an upset. This should not cause any problems (Opcode functions
ignore those extra bits) but it does mean that using the ~ operator will
typically not produce the same 'physical' opset 'string' as the
invert_opset function.

TO DO (maybe)
=============

     $bool = opset_eq($opset1, $opset2)	true if opsets are logically eqiv

     $yes = opset_can($opset, @ops)	true if $opset has all @ops set

     @diff = opset_diff($opset1, $opset2) => ('foo', '!bar', ...)

Predefined Opcode Tags
======================

:base_core
          null stub scalar pushmark wantarray const defined undef

          rv2sv sassign

          rv2av aassign aelem aelemfast aslice av2arylen

          rv2hv helem hslice each values keys exists delete

          preinc i_preinc predec i_predec postinc i_postinc postdec i_postdec
          int hex oct abs pow multiply i_multiply divide i_divide
          modulo i_modulo add i_add subtract i_subtract

          left_shift right_shift bit_and bit_xor bit_or negate i_negate
          not complement

          lt i_lt gt i_gt le i_le ge i_ge eq i_eq ne i_ne ncmp i_ncmp
          slt sgt sle sge seq sne scmp

          substr vec stringify study pos length index rindex ord chr

          ucfirst lcfirst uc lc quotemeta trans chop schop chomp schomp

          match split qr

          list lslice splice push pop shift unshift reverse

          cond_expr flip flop andassign orassign and or xor

          warn die lineseq nextstate scope enter leave setstate

          rv2cv anoncode prototype

          entersub leavesub leavesublv return method method_named -- XXX loops via recursion?

          leaveeval -- needed for Safe to operate, is safe without entereval

:base_mem
     These memory related ops are not included in :base_core because they
     can easily be used to implement a resource attack (e.g., consume all
     available memory).

          concat repeat join range

          anonlist anonhash

     Note that despite the existance of this optag a memory resource attack
     may still be possible using only :base_core ops.

     Disabling these ops is a *very* heavy handed way to attempt to prevent
     a memory resource attack. It's probable that a specific memory limit
     mechanism will be added to perl in the near future.

:base_loop
     These loop ops are not included in :base_core because they can easily
     be used to implement a resource attack (e.g., consume all available
     CPU time).

          grepstart grepwhile
          mapstart mapwhile
          enteriter iter
          enterloop leaveloop unstack
          last next redo
          goto

:base_io
     These ops enable filehandle (rather than filename) based input and
     output. These are safe on the assumption that only pre-existing
     filehandles are available for use.  To create new filehandles other
     ops such as open would need to be enabled.

          readline rcatline getc read

          formline enterwrite leavewrite

          print sysread syswrite send recv

          eof tell seek sysseek

          readdir telldir seekdir rewinddir

:base_orig
     These are a hotchpotch of opcodes still waiting to be considered

          gvsv gv gelem

          padsv padav padhv padany

          rv2gv refgen srefgen ref

          bless -- could be used to change ownership of objects (reblessing)

          pushre regcmaybe regcreset regcomp subst substcont

          sprintf prtf -- can core dump

          crypt

          tie untie

          dbmopen dbmclose
          sselect select
          pipe_op sockpair

          getppid getpgrp setpgrp getpriority setpriority localtime gmtime

          entertry leavetry -- can be used to 'hide' fatal errors

:base_math
     These ops are not included in :base_core because of the risk of them
     being used to generate floating point exceptions (which would have to
     be caught using a $SIG{FPE} handler).

          atan2 sin cos exp log sqrt

     These ops are not included in :base_core because they have an effect
     beyond the scope of the compartment.

          rand srand

:base_thread
     These ops are related to multi-threading.

          lock threadsv

:default
     A handy tag name for a *reasonable* default set of ops.  (The current
     ops allowed are unstable while development continues. It will change.)

          :base_core :base_mem :base_loop :base_io :base_orig :base_thread

     If safety matters to you (and why else would you be using the Opcode
     module?)  then you should not rely on the definition of this, or
     indeed any other, optag!

:filesys_read
          stat lstat readlink

          ftatime ftblk ftchr ftctime ftdir fteexec fteowned fteread
          ftewrite ftfile ftis ftlink ftmtime ftpipe ftrexec ftrowned
          ftrread ftsgid ftsize ftsock ftsuid fttty ftzero ftrwrite ftsvtx

          fttext ftbinary

          fileno

:sys_db
          ghbyname ghbyaddr ghostent shostent ehostent      -- hosts
          gnbyname gnbyaddr gnetent snetent enetent         -- networks
          gpbyname gpbynumber gprotoent sprotoent eprotoent -- protocols
          gsbyname gsbyport gservent sservent eservent      -- services

          gpwnam gpwuid gpwent spwent epwent getlogin       -- users
          ggrnam ggrgid ggrent sgrent egrent                -- groups

:browse
     A handy tag name for a *reasonable* default set of ops beyond the
     :default optag.  Like :default (and indeed all the other optags) its
     current definition is unstable while development continues. It will
     change.

     The :browse tag represents the next step beyond :default. It it a
     superset of the :default ops and adds :filesys_read the :sys_db.  The
     intent being that scripts can access more (possibly sensitive)
     information about your system but not be able to change it.

          :default :filesys_read :sys_db

:filesys_open
          sysopen open close
          umask binmode

          open_dir closedir -- other dir ops are in :base_io

:filesys_write
          link unlink rename symlink truncate

          mkdir rmdir

          utime chmod chown

          fcntl -- not strictly filesys related, but possibly as dangerous?

:subprocess
          backtick system

          fork

          wait waitpid

          glob -- access to Cshell via <`rm *`>

:ownprocess
          exec exit kill

          time tms -- could be used for timing attacks (paranoid?)

:others
     This tag holds groups of assorted specialist opcodes that don't
     warrant having optags defined for them.

     SystemV Interprocess Communications:

          msgctl msgget msgrcv msgsnd

          semctl semget semop

          shmctl shmget shmread shmwrite

:still_to_be_decided
          chdir
          flock ioctl

          socket getpeername ssockopt
          bind connect listen accept shutdown gsockopt getsockname

          sleep alarm -- changes global timer state and signal handling
          sort -- assorted problems including core dumps
          tied -- can be used to access object implementing a tie
          pack unpack -- can be used to create/use memory pointers

          entereval -- can be used to hide code from initial compile
          require dofile

          caller -- get info about calling environment and args

          reset

          dbstate -- perl -d version of nextstate(ment) opcode

:dangerous
     This tag is simply a bucket for opcodes that are unlikely to be used
     via a tag name but need to be tagged for completness and
     documentation.

          syscall dump chroot

SEE ALSO
========

   ops(3) - perl pragma interface to Opcode module.

   Safe(3) - Opcode and namespace limited execution compartments

AUTHORS
=======

   Originally designed and implemented by Malcolm Beattie,
mbeattie@sable.ox.ac.uk as part of Safe version 1.

   Split out from Safe module version 1, named opcode tags and other
changes added by Tim Bunce.


