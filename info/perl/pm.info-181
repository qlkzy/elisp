This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: HTML/Widgets/DateEntry,  Next: HTML/Widgets/Menu,  Prev: HTML/WWWTheme,  Up: Module List

creates date entry widgets for HTML forms.
******************************************

NAME
====

   HTML::Widgets::DateEntry - creates date entry widgets for HTML forms.

SYNOPSIS
========

     use HTML::Widgets::DateEntry;

     $de = new HTML::Widgets::DateEntry(
     				     year      => ['date_year',  $date_year],
     				     month     => ['date_month', $date_month],
     				     day       => ['date_day',   $date_day],
     				     separator => '/',
     				     pre_year  => 1,
     				     post_year => 1,
     				     -iso      => 1,
     				    );

     print $de->render_widget;

DESCRIPTION
===========

   HTML::Widgets::DateEntry is a simple module to generate HTML date entry
widgets.

   Currently generates widgets that look like:

     [YYYY]/[MM]/[DD]

   Will be able to generate

     [MM]/[DD]/[YYYY]

     [YYYY]/[MM]

     [MM]/[YYYY]

     [YYYY]

new(% );
     Use like     $de = new HTML::Widgets::DateEntry(year =>
     ['date_year',$year], month => ['date_month',$month], day =>
     ['date_day',$day]);

     returns a date entry widget object with the fields named as specified.

     if defaults are not provided, values from localtime will be used.

     this will get better :-)

render_widget()
     Use like     print $de->render_widget;

     returns a string representing an HTML date entry widget.  with the
     fields named as specified, and defaults set as specified when the
     object was created.

     this will get better :-)

COPYRIGHT
=========

     COPYRIGHT  2000 THE REGENTS OF THE UNIVERSITY OF MICHIGAN
     ALL RIGHTS RESERVED

     PERMISSION IS GRANTED TO USE, COPY, CREATE DERIVATIVE WORKS
     AND REDISTRIBUTE THIS SOFTWARE AND SUCH DERIVATIVE WORKS FOR
     NON-COMMERCIAL EDUCATION AND RESEARCH PURPOSES, SO LONG AS NO
     FEE IS CHARGED, AND SO LONG AS THE COPYRIGHT NOTICE ABOVE,
     THIS GRANT OF PERMISSION, AND THE DISCLAIMER BELOW APPEAR IN
     ALL COPIES MADE; AND SO LONG AS THE NAME OF THE UNIVERSITY
     OF MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY
     PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE
     WITHOUT SPECIFIC, WRITTEN PRIOR AUTHORIZATION.

     THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION AS
     TO ITS FITNESS FOR ANY PURPOSE,  AND WITHOUT WARRANTY OF ANY
     KIND,  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
     LIMITATION THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE. THE REGENTS OF THE
     UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE FOR ANY DAMAGES,
     INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
     DAMAGES, WITH RESPECT TO ANY CLAIM ARISING OUT OF OR IN
     CONNECTION WITH THE USE OF THE SOFTWARE, EVEN IF IT HAS BEEN
     OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

     ( This program is free software; you can redistribute it and/or
       modify it under the same terms as Perl itself. )

SEE ALSO
========

   perl(1)

AUTHOR
======

   Hugh Kennedy <kennedyh@engin.umich.edu>

     __|   \   __|  \ |
         (     _ \  _|  .  |
        \___|_/  Web Systems


File: pm.info,  Node: HTML/Widgets/Menu,  Next: HTML/Widgets/Search,  Prev: HTML/Widgets/DateEntry,  Up: Module List

Builds an HTML menu
*******************

NAME
====

   HTML::Widgets::Menu - Builds an HTML menu

SYNOPSIS
========

     use HTML::Widgets::Menu;
     my $main=HTML::Widgets::Menu->new(
            home	=> "/users/frankie/",

     format	=> {
        default=>{
             # default format options #
        },
        0=>{
           #level 0 format  options#
        }
        # more levels
     },

     menu=> [
        item1=>{
            url=>"url for item 1",
            menu=>[
                  item1_1=>'url for item 1_1'
            ]
        },
        item2=>"url for item 2"
        # more items
     ],
     
     # this is experimental

     allowed => sub {
         my ($url)=shift;
         my $user=$r->connection->user();
     			return 1 unless defined $user;
     			return ($user eq "frankie"  && $url =~/^intranet/);
     }
           );

     print "<h1>$menu->title</h1>",
     print "<h2>$menu->path</h2>",
         print $menu->html;

DESCRIPTION
===========

   This module will help you build a menu for your HTML site.  You can use
with CGI or any mod_perl module. I use it from HTML::Mason.  Every time
you request to show a menu it will return the HTML tags.  It's smart
enough it will highlight the current active items.

   You can see an example of this here: http://www.etsetb.upc.es/~frankie

   This software is more mature that latest version. It works fine for me
and is used in production sites. The very first version was almost unusable
if you didn't had very strict rules for creating the menu, now it's much
improved and useful. Tell me if you like it or not.

   You can send me patches, bugs or suggestions.

   This software is provided as is and you're using it at your own risk.
You agree to use it with the same license of perl itself.

   Drawing a menu is a matter of :     the items of the menu     the
format you want it to have

   You also must supply the home directory for all the web you want to add
this menu.

ITEMS
-----

   The items is a list.

   For example, a simple menu could be:

     my @menu=(
           homepage   =>'.',
           "my links" =>"links.html"
     );

   You can add depth to the menu:

     my @menu=(
         homepage   => '.',
         "my links" => {
                   url=>"links/",
                   menu=>[
                         perl  =>"perl_link.html",
                         "movies I like"=>'movies.html'
                   ],
          about=>"about.html"
      );

   For every level you add instead of the url you must supply a reference
to a hash with the url and the submenu.  Now you can get this menu printed
in html easily and get the list of active items.

   my $main=HTML::Widgets::Menu->new(menu=>\@menu,home=>"/users/frankie/");

   print $main->html(); # this renders the html my @active_items=
@{$main->active}; # list of active items

   If the url of the item is only the name of a directory (the final / is
not necessary), the path is added to the submenu. For the example above
you must write the files:     index.html     links/index.html
links/perl_link.thml     links/movies.html     about.html

   The format is the way you tell how to show the items of the menu It's a
hash where you define the options.  There should be a default entry and
numbered entries for every level, starting with 0.

   Options available (with defaults):   max_depth => 1,         # max
number of depth shown if items are not active   start => ", #html to put
at the start of the level   end => ", #html to add at the end of the level
 font=>'<FONT>',   active_item_start => '<B><I>',   active_item_end =>
'</B></I>',   inactive_item_start => ",   inactive_item_end => ",
text_placeholder => '<text>',            # example : <IMG SRC="<text>.gif"
ALT="<text>">            #                     -----           -----
link_args=>",            # put javascript options here or other args
    # for the <A HREF tag   indent => 8, 			# pixels for the
indentation

     auto_br => 1, # Adds a <br> at the end of every line [default 1]

   Example: my %format={    default=>{         max_depth=>2,
font=>"<FONT SIZE=2>\n",         active_item_start=>"<IMG
SRC=\"/users/frankie/img/blue_arrow.gif\"             BORDER=0
WIDTH=6><B><I><FONT COLOR=\"BLUE\">",
active_item_end=>"</FONT></I></B>\n",         indent=>20     },     0=>{
     inactive_item_start=>"<FONT SIZE=\"5\">",
inactive_item_end=>"</FONT>",         text_placeholder=>"<IMG
SRC=\"<text>.gif\".gif>",         link_args=>"onmouseover='javascript
thingie'",     },     1=>{         indent=>10     } };

   Try it like this:

   my $main=HTML::Widgets::Menu->new(format=>\%format
              menu=>\@menu,
home=>"/users/frankie");

   When you want to request the html that shows the menu you must call the
html method. It will build it using home, format and menu. The final links
will always be related to the current URL.

   The pixel indentation is done using the url /img/point.gif.

   If you define an active format with an image like this:
active_item_start=> ' <IMG SRC="arrow.gif" WIDTH="10">'

   this WIDTH is added to the indentation so it looks pretty cool in the
screen:

     not active
     another url
         => this is the active
     another one

     The other items have been indented the width of the image, in addition
     to the indent tag in the format.

   The activation of the items work automagically reading the environment
variable provided by the web server: $ENV{REQUEST_URI}

Active Items
------------

   The active method returns a usefull thing: the active items of the
menu. In the former example if the user is in the url:  "movies.html" it
will return a reference to a list like this: 	"my_links"=>"links"
"movies I like "=>"links/movies.html"

   What can I do with the active items ?

   once the menu is built you can retrieve its active items this way:

     $menu->active;

   This method returns an array with the items and links this way:

     item1 , link1 , item2, link2

   You can use it to build a title or path like this:

     print $menu->html; # that builds the menu

     my $title="Main Title";
     my $path="";
     my $item;
     foreach (@{$menu->active}) {
     	$item=$_ and next unless defined $item;

     $title.=" - $item";

     $path.="/" if length $path;
     $path.="<A HREF=\"$_\">$item</A>";

     undef $item;

     }
     # now I have a title and path variables

Experimental Features
---------------------

   * see test.pl file for a cool feature that lets you read menu data from
     a database !

   * There is another new feature that lets you do authorization. So you
     can have some users access some menus and other don't.

PLEASE
------

     Please, tell me you're using it. I'll accept requests, comments,
     suggestions, bug patches.

AUTHOR
======

   Francesc Guasch-Ortiz	 frankie@etsetb.upc.es

SEE ALSO
========

   perl(1).  mod_perl


File: pm.info,  Node: HTML/Widgets/Search,  Next: HTTP/BrowserDetect,  Prev: HTML/Widgets/Menu,  Up: Module List

Perl module for building searches returning HTML
************************************************

NAME
====

   HTML::Widgets::Search - Perl module for building searches returning HTML

SYNOPSIS
========

     <%perl>
     use HTML::Widgets::Search;
     my $search=HTML::Widgets::Search->new(
                query => "SELECT idCustomer,name               ".
                         " FROM customers WHERE name LIKE 'a%' ".
                         " ORDER BY name                       ",
             field_id => "idCustomer",
                limit => 10,
          form_fields => \%ARGS,
                  dbh => $dbh
     );
     </%perl>

     <% $search->n_found %> customers found
     <% $search->current_start %> to <% $search -> current_end %><BR>

     <% $search->head %>
         <TABLE WIDTH="90%">
             <%perl>
                  $search->render_table(
                      link=>"http://www.me.com/show_customer.html"
                  );
             </%perl>
         </TABLE>

     <A HREF="search_customer.html<% $search->next %>">next</A>

     <A HREF="search_customer.html<% $search->prev %>">previous</A>

     <% $search->prev(submit => '<INPUT 	TYPE="IMAGE"
                                 SRC="/img/prev.gif"
                                 NAME="previous" BORDER=0>')
     	%>
     %#################################################################3
     <TABLE>
     % while (my @row=$search->fetchrow) {
         <TR><TD>
             <% join "</TD><TD>", @row %>
         </TD></TR>
     % }
     </TABLE>

DESCRIPTION
===========

     The programmer designs a html form with some field values, then
     you can write a sql query using those fields.

     The constuctor requires a SQL statement and a valid DBI object.

     render_table returns a HTML table with the results , if a link
     is provided every field of the table has that link. If a field_id
     	is provided the link adds that field as a parameter. This field
     	must be the first field of the select query and is discarded in
     	the render.

     Supports native mysql limit clauses. For other DBs skips untill start
     and fetches until limit.

     Give it a try, the synopsis may help you start.
     Let me know if it's useful for or whatever you want to tell me.

TODO
====

     Improve the docs. You can help me !

AUTHOR
======

   Francesc Guasch  frankie@etsetb.upc.es

SEE ALSO
========

   perl(1) , DBI.


File: pm.info,  Node: HTTP/BrowserDetect,  Next: HTTP/Cookies,  Prev: HTML/Widgets/Search,  Up: Module List

Determine the Web browser, version, and platform from an HTTP user agent string
*******************************************************************************

NAME
====

   HTTP::BrowserDetect - Determine the Web browser, version, and platform
from an HTTP user agent string

SYNOPSIS
========

     use HTTP::BrowserDetect;

     my $browser = new HTTP::BrowserDetect($user_agent_string);

     # Detect operating system
     if ($browser->windows) {
       if ($browser->winnt) ...
       if ($brorwser->win95) ...
     }
     print $browser->mac;

     # Detect browser vendor and version
     print $browser->netscape;
     print $browser->ie;
     if (browser->major(4)) {
     	if ($browser->minor() > .5) {
     	    ...
     	}
     }
     if ($browser->version() > 4) {
       ...;
     }
     
     # Process a different user agent string
     $browser->user_agent($another_user_agent_string);

DESCRIPTION
===========

   The HTTP::BrowserDetect object does a number of tests on an HTTP user
agent string.  The results of these tests are available via methods of the
object.

   This module is based upon the JavaScript browser detection code
available at
*http://www.mozilla.org/docs/web-developer/sniffer/browser_type.html*.

CREATING A NEW BROWSER DETECT OBJECT AND SETTING THE USER AGENT STRING
----------------------------------------------------------------------

new HTTP::BrowserDetect($user_agent_string)
     The constructor may be called with a user agent string specified.
     Otherwise, it will use the value specified by $ENV{'HTTP_USER_AGENT'},
     which is set by the web server when calling a CGI script.

     You may also use a non-object-oriented interface.  For each method,
     you may call HTTP::BrowserDetect::method_name().  You will then be
     working with a default HTTP::BrowserDetect object that is created
     behind the scenes.

user_agent($user_agent_string)
     Returns the value of the user agent string.  When called with a
     parameter, it resets the user agent and reperforms all tests on the
     string.  This way you can process a series of user agent strings (from
     a log file, perhaps) without creating a new HTTP::BrowserDetect object
     each time.

DETECTING BROWSER VERSION
-------------------------

major($major)
     Returns the integer portion of the browser version.  If passed a
     parameter, returns true if it equals the browser major version.

minor($minor)
     Returns the decimal portion of the browser version as a
     *floating-point number* less than 1.  For example, if the version is
     4.05, this method returns .05; if the version is 4.5, this method
     returns .5.  *This is a change in behavior from previous versions of
     this module, which returned a string*.

     If passed a parameter, returns true if equals the minor version.

     On occasion a version may have more than one decimal point, such as
     'Wget/1.4.5'. The minor version does not include the second decimal
     point, or any further digits or decimals.

version($version)
     Returns the version as a floating-point number.  If passed a
     parameter, returns true if it is equal to the version specified by
     the user agent string.

beta($beta)
     Returns any the beta version, consisting of any non-numeric characters
     after the version number.  For instance, if the user agent string is
     'Mozilla/4.0 (compatible; MSIE 5.0b2; Windows NT)', returns 'b2'.  If
     passed a parameter, returns true if equal to the beta version.

DETECTING OS PLATFORM AND VERSION
---------------------------------

   The following methods are available, each returning a true or false
value.  Some methods also test for the operating system version.

     windows win16 win3x win31 win95 win98 winnt win32 win2k winme
     mac mac68k macppc
     os2
     unix
     sun sun4 sun5 suni86 irix irix5 irix6 hpux hpux9 hpux10
     aix aix1 aix2 aix3 aix4 linux sco unixware mpras reliant
     dec sinix freebsd bsd
     vms
     amiga

   It may not be possibile to detect Win98 in Netscape 4.x and earlier.
On Opera 3.0, the userAgent string includes "Windows 95/NT4" on all Win32,
so you can't distinguish between Win95 and WinNT.

os_string()
     Returns one of the following strings, or undef.  This method exists
     solely for compatibility with the *HTTP::Headers::UserAgent* module.

          Win95, Win98, WinNT, Mac, Win3x, OS2, Unix, Linux

DETECTING BROWSER VENDOR
------------------------

   The following methods are available, each returning a true or false
value.  Some methods also test for the browser version, saving you from
checking the version separately.

     netscape nav2 nav3 nav4 nav4up nav45 nav45up navgold nav6 nav6up
     gecko
     ie ie3 ie4 ie4up ie5 ie55
     neoplanet neoplanet2
     mosaic
     aol aol3 aol4 aol5 aol6
     webtv
     opera
     lynx
     emacs
     staroffice
     lotusnotes
     icab
     konqueror
     java

   Netscape 6, even though its called six, in the userAgent string has
version number 5.  The nav6 and nav6up methods correctly handle this quirk.

browser_string()
     Returns one of the following strings, or undef.

     Netscape, MSIE, WebTV, AOL Browser, Opera, Mosaic, Lynx

DETECTING OTHER DEVICES
-----------------------

   The following methods are available, each returning a true or false
value.

     wap
     audrey
     iopener
     palm
     avantgo

DETECTING ROBOTS
----------------

robot()
     Returns true if the user agent appears to be a robot, spider,
     crawler, or other automated Web client.

     The following additional methods are available, each returning a true
     or false value.  This is by no means a complete list of robots that
     exist on the Web.

          wget
          getright
          yahoo
          altavista
          lycos
          infoseek
          lwp
          webcrawler
          linkexchange
          slurp
          google

AUTHOR
======

   Lee Semel, lee@semel.net

SEE ALSO
========

   "The Ultimate JavaScript Client Sniffer, Version 3.0",
*http://www.mozilla.org/docs/web-developer/sniffer/browser_type.html*.

   perl(1), *Note HTTP/Headers: HTTP/Headers,, *Note
HTTP/Headers/UserAgent: HTTP/Headers/UserAgent,.

COPYRIGHT
=========

   Copyright 1999-2001 Lee Semel.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: HTTP/Cookies,  Next: HTTP/DAV,  Prev: HTTP/BrowserDetect,  Up: Module List

Cookie storage and management
*****************************

NAME
====

   HTTP::Cookies - Cookie storage and management

SYNOPSIS
========

     use HTTP::Cookies;
     $cookie_jar = HTTP::Cookies->new;

     $cookie_jar->add_cookie_header($request);
     $cookie_jar->extract_cookies($response);

DESCRIPTION
===========

   Cookies are a general mechanism which server side connections can use
to both store and retrieve information on the client side of the
connection.  For more information about cookies refer to
<URL:http://www.netscape.com/newsref/std/cookie_spec.html> and
<URL:http://www.cookiecentral.com/>.  This module also implements the new
style cookies described in *draft-ietf-http-state-man-mec-08.txt*.  The
two variants of cookies are supposed to be able to coexist happily.

   Instances of the class *HTTP::Cookies* are able to store a collection
of Set-Cookie2: and Set-Cookie: headers and are able to use this
information to initialize Cookie-headers in HTTP::Request objects.  The
state of a *HTTP::Cookies* object can be saved in and restored from files.

METHODS
=======

   The following methods are provided:

$cookie_jar = HTTP::Cookies->new;
     The constructor takes hash style parameters.  The following
     parameters are recognized:

          file:            name of the file to restore cookies from and save cookies to
          autosave:        save during destruction (bool)
          ignore_discard:  save even cookies that are requested to be discarded (bool)

     Future parameters might include (not yet implemented):

          max_cookies               300
          max_cookies_per_domain    20
          max_cookie_size           4096

          no_cookies   list of domain names that we never return cookies to

$cookie_jar->add_cookie_header($request);
     The add_cookie_header() method will set the appropriate Cookie:-header
     for the HTTP::Request object given as argument.  The $request must
     have a valid url attribute before this method is called.

$cookie_jar->extract_cookies($response);
     The extract_cookies() method will look for Set-Cookie: and
     Set-Cookie2: headers in the *HTTP::Response* object passed as
     argument.  Any of these headers that are found are used to update the
     state of the $cookie_jar.

$cookie_jar->set_cookie($version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, \%rest)
     The set_cookie() method updates the state of the $cookie_jar.  The
     $key, $val, $domain, $port and $path arguments are strings.  The
     $path_spec, $secure, $discard arguments are boolean values. The
     $maxage value is a number indicating number of seconds that this
     cookie will live.  A value <= 0 will delete this cookie.  %rest
     defines various other attributes like "Comment" and "CommentURL".

$cookie_jar->save( [$file] );
     This method file saves the state of the $cookie_jar to a file.  The
     state can then be restored later using the load() method.  If a
     filename is not specified we will use the name specified during
     construction.  If the attribute *ignore_discared* is set, then we
     will even save cookies that are marked to be discarded.

     The default is to save a sequence of "Set-Cookie3" lines.
     "Set-Cookie3" is a proprietary LWP format, not known to be compatible
     with any browser.  The *HTTP::Cookies::Netscape* sub-class can be
     used to save in a format compatible with Netscape.

$cookie_jar->load( [$file] );
     This method reads the cookies from the file and adds them to the
     $cookie_jar.  The file must be in the format written by the save()
     method.

$cookie_jar->revert;
     This method empties the $cookie_jar and re-loads the $cookie_jar from
     the last save file.

$cookie_jar->clear( [$domain, [$path, [$key] ] ]);
     Invoking this method without arguments will empty the whole
     $cookie_jar.  If given a single argument only cookies belonging to
     that domain will be removed.  If given two arguments, cookies
     belonging to the specified path within that domain are removed.  If
     given three arguments, then the cookie with the specified key, path
     and domain is removed.

$cookie_jar->scan( \&callback );
     The argument is a subroutine that will be invoked for each cookie
     stored in the $cookie_jar.  The subroutine will be invoked with the
     following arguments:

          0  version
          1  key
          2  val
          3  path
          4  domain
          5  port
          6  path_spec
          7  secure
          8  expires
          9  discard
           10  hash

$cookie_jar->as_string( [$skip_discard] );
     The as_string() method will return the state of the $cookie_jar
     represented as a sequence of "Set-Cookie3" header lines separated by
     "\n".  If $skip_discard is TRUE, it will not return lines for cookies
     with the *Discard* attribute.

SUB CLASSES
===========

   We also provide a subclass called *HTTP::Cookies::Netscape* which loads
and saves Netscape compatible cookie files.  You should be able to have
LWP share Netscape's cookies by constructing your $cookie_jar like this:

     $cookie_jar = HTTP::Cookies::Netscape->new(
                       File     => "$ENV{HOME}/.netscape/cookies",
                       AutoSave => 1,
                   );

   Please note that the Netscape cookie file format is not able to store
all the information available in the Set-Cookie2 headers, so you will
probably loose some information if you save in this format.

COPYRIGHT
=========

   Copyright 1997-1999 Gisle Aas

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/DAV,  Next: HTTP/DAV/Lock,  Prev: HTTP/Cookies,  Up: Module List

A WebDAV client library for Perl5
*********************************

NAME
====

   HTTP::DAV - A WebDAV client library for Perl5

SYNOPSIS
========

     use HTTP::DAV;

     $dav = HTTP::DAV->new;
     $dav->credentials( "pcollins", "mypass", "http://localhost/" );
     $resource = $dav->new_resource( -uri => "http://localhost/dav/myfile.txt" );

     $response = $resource->lock;
     $response = $resource->put("New file contents\n");
     print "BAD PUT\n" unless $response->is_success;
     $response = $resource->unlock;

     $resource->propfind;
     print "BAD PROPFIND\n" unless $response->is_success;
     $getlastmodified = $resource->get_property( "getlastmodified" );
     print "Last modified $getlastmodified\n";

     See HTTP::DAV::Resource for all of the operations allowed against a resource.

DESCRIPTION
===========

   This is DAV.pm (or HTTP::DAV), a Perl5 library for interacting and
modifying content on webservers using the WebDAV protocol. Now you can
LOCK, DELETE and PUT files and much more on a DAV-enabled webserver. Learn
more about WebDAV at http://www.webdav.org/

new
     Creates a new DAV client

          $dav = HTTP::DAV->new()

new_resource
     Creates a new resource object with which to play.

          $dav->new_resource( -uri => "http://..." );

as_string
     Method returning a textual representation of the request.  Mainly
     useful for debugging purposes. It takes no arguments.

          e.g.
          $dav->as_string()

COPYRIGHT
=========

   Copyright 2000, Patrick Collins.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/DAV/Lock,  Next: HTTP/DAV/Resource,  Prev: HTTP/DAV,  Up: Module List

Represents a WebDAV Lock.
*************************

NAME
====

   HTTP::DAV::Lock - Represents a WebDAV Lock.

SYNOPSIS
========

     Need example

DESCRIPTION
===========

SEE ALSO
========

   *Note HTTP/Headers: HTTP/Headers,, *Note HTTP/Message: HTTP/Message,,
*Note HTTP/Request/Common: HTTP/Request/Common,

COPYRIGHT
=========

   Copyright 2000 Patrick Collins.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/DAV/Resource,  Next: HTTP/Daemon,  Prev: HTTP/DAV/Lock,  Up: Module List

Represents and interfaces with WebDAV Resources
***********************************************

NAME
====

   HTTP::DAV::Resource - Represents and interfaces with WebDAV Resources

SYNOPSIS
========

   Sample

DESCRIPTION
===========

   Description here

CONSTRUCTORS
============

new
     Returns a new resource represented by the URI.

     $r = HTTP::DAV::Resource->new(         -uri => $uri,
     -LockedResourceList => $locks,         -Comms => $comms      );

     On creation a Resource object needs 2 other objects passed in:

     1. a `ResourceList' Object. This list will be added to if you lock
     this Resource.

     2. a `Comms' Object. This object will be used for HTTP communication.

METHODS
=======

get/GET
     Performs an HTTP GET and returns a DAV::Response object.

          $response = $resource->get;
          print $resource->get_content if ($response->is_success);

put/PUT
     Performs an HTTP PUT and returns a DAV::Response object.

     $response = $resource->put( $string );

     $string is be passed as the body.

          e.g.
          $response = $resource->put($string);
          print $resource->get_content if ($response->is_success);

     Will use a Lock header if this resource was previously locked.

copy
     Not implemented

move
     Not implemented

delete
     Performs an HTTP DELETE and returns a DAV::Response object.

          $response = $resource->delete;
          print "Delete successful" if ($response->is_success);

     Will use a Lock header if this resource was previously locked.

options
     Performs an HTTP OPTIONS and returns a DAV::Response object.

          $response = $resource->options;
          print "Yay for PUT!" if $resource->is_option("PUT");

mkcol
     Performs a WebDAV MKCOL request and returns a DAV::Response object.

          $response = $resource->mkcol;
          print "MKCOL successful" if ($response->is_success);

     Will use a Lock header if this resource was previously locked.

proppatch
     Not implemented

propfind
     Performs a WebDAV PROPFIND request and returns a DAV::Response object.

          $response = $resource->propfind;
          if ($response->is_success) {
             print "PROPFIND successful\n";
             print $resource->get_property("displayname") . "\n";
          }

     A successful PROPFIND fills the object with much data about the
     Resource.  Including:    displayname    ...     TODO

lock
     Performs a WebDAV LOCK request and returns a DAV::Response object.

          $resource->lock(
                 -owner   => "Patrick Collins",
                 -depth   => "Infinity"
                 -scope   => "exclusive",
                 -type    => "write"
                 -timeout => TIMEOUT',
              )

     lock takes the following arguments.

     owner - Indicates who locked this resource

     The default value is:  DAV.pm/v$DAV::VERSION ($$)

          e.g. DAV.pm/v0.1 (123)

     If you use a URL as the owner, the module will automatically indicate
     to the server that is is a URL (<D:href>http://...</D:href>)

     depth - Indicates the depth of the lock.

     Legal values are 0 or Infinity. (1 is not allowed).

     The default value is Infinity.

     A lock value of 0 on a collection will lock just the collection but
     not it's members, whereas a lock value of Infinity will lock the
     collection and all of it's members.

     scope - Indicates the scope of the lock.

     Legal DAV values are "exclusive" or "shared".

     The default value is exclusive.

     See section 6.1 of RFC2518 for a description of shared vs. exclusive
     locks.

     type - Indicates the type of lock (read, write, etc)

     The only legal DAV value currently is "write".

     The default value is write.

     timeout - Indicates when the lock will timeout

     The timeout value may be one of, an Absolute Date, a Time Offset from
     now, or the word "Infinity".

     The default value is "Infinity".

     The following are all valid timeout values:

     Time Offset:     30s          30 seconds from now     10m
     ten minutes from now     1h           one hour from now     1d
       tomorrow     3M           in three months     10y          in ten
     years time

     Absolute Date:

          timeout at the indicated time & date (UTC/GMT)
             2000-02-31 00:40:33

          timeout at the indicated date (UTC/GMT)
             2000-02-31

     You can use any of the Absolute Date formats specified in HTTP::Date
     (see perldoc HTTP::Date)

     Note: the DAV server may choose to ignore your specified timeout.

unlock
     Performs a WebDAV UNLOCK request and returns a DAV::Response object.

          $response = $resource->unlock()
          $response = $resource->unlock( -force => 1 )
          $response = $resource->unlock(
             -token => "opaquelocktoken:1342-21423-2323" )

     This method will automatically use the correct locktoken If: header
     if this resource was previously locked.

     force - Synonymous to calling $resource->forcefully_unlock_all.

forcefully_unlock_all
     Remove all locks from a resource and return the last DAV::Response
     object. This method take no arguments.

     $response = $resource->forcefully_unlock_all;

     This method will perform a lockdiscovery against the resource to
     determine all of the current locks. Then it will UNLOCK them one by
     one. unlock( -token => locktoken ).

     This unlock process is achievable because DAV does not enforce any
     security over locks.

     Note: this method returns the LAST unlock response (this is
     sufficient to indicate the success of the sequence of unlocks). If an
     unlock fails, it will bail and return that response.  For instance,
     In the event that there are 3 shared locks and the second unlock
     method fails, then you will get returned the unsuccessful second
     response. The 3rd unlock will not be attempted.

     Don't run with this knife, you could hurt someone (or yourself).

steal_lock
     Removes all locks from a resource, relocks it in your name and
     returns the DAV::Response object for the lock command. This method
     takes no arguments.

     $response = $resource->steal_lock;

     Synonymous to forcefully_unlock_all() and then lock().

lockdiscovery
     Discover the locks held against this resource and return a
     DAV::Response object. This method take no arguments.

          $response = $resource->lockdiscovery;
          @locks = $resource->get_locks if $response->is_success;

     This method is in fact a simplified version of propfind().

as_string
     Returns a string representation of the object. Mainly useful for
     debugging purposes. It takes no arguments.

     print $resource->as_string

ACCESSOR METHODS (get, set and is)
==================================

is_option
     Returns a boolean indicating whether this resource supports the
     option passed in as a string. The option match is case insensitive
     so, PUT and Put are should both work.

          if ($resource->is_option( "PUT" ) ) {
             $resource->put( ... )
          }

     Note: this routine automatically calls the options() routine which
     makes the request to the server. Subsequent calls to is_option will
     use the cached option list. To force a rerequest to the server call
     options()

is_locked
     Returns a boolean indicating whether this resource is locked.

          @lock = $resource->is_locked( -owned=>[0|1] );

     *owned* - this parameters is used to ask, locked by who?

     Note: You must have already called propfind() or lockdiscovery()

     e.g.  Is the resource locked at all?   print "yes" if
     $resource->is_locked();

     Is the resource locked by me?   print "yes" if $resource->is_locked(
     -owned=>1 );

     Is the resource locked by someone other than me?   print "yes" if
     $resource->is_locked( -owned=>0 );

is_collection
     Returns a boolean indicating whether this resource is a collection.

          print "Directory" if ( $resource->is_collection );

     You must first have performed a propfind.

get_uri
     Returns the URI object for this resource.

          print "URL is: " . $resource->get_uri()->as_string . "\n";

     See the URI manpage from the LWP libraries (perldoc URI)

get_property
     Returns a property value. Takes a string as an argument.

          print $resource->get_property( "displayname" );

     You must first have performed a propfind.

get_options
     Returns an array of options allowed on this resource.  Note: If
     $resource->options has not been called then it will return an empty
     array.

     @options = $resource->get_options

get_content
     Returns the resource's content/body as a string.  The content is
     typically the result of a GET.

     $content = $resource->get_content

get_content_ref
     Returns the resource's content/body as a reference to a string.  This
     is useful and more efficient if the content is large.

     ${$resource->get_content_ref} =~ s/\bfoo\b/bar/g;

     Note: You must have already called get()

get_lock
     Returns the DAV::Lock object if it exists. Requires opaquelocktoken
     passed as a parameter.

          $lock = $resource->get_lock( "opaquelocktoken:234214--342-3444" );

get_locks
     Returns a list of any DAV::Lock objects held against the resource.

          @lock = $resource->get_locks( -owned=>[0|1] );

     *owned* - this parameter indicates which locks you want.   - 1,
     requests any of my locks. (Locked by this DAV instance).   - 0
     ,requests any locks not owned by us.   - any other value or no value,
     requests ALL locks.

     Note: You must have already called propfind() or lockdiscovery()

     e.g.   Give me my locks   @lock = $resource->get_locks( -owned=>1 );

          Give me all locks
           @lock = $resource->get_locks();

get_lockedresourcelist
get_parentresourcelist
get_comms
set_parent_resourcelist
     $resource->set_parent_resourcelist( $resourcelist )

     Sets the parent resource list (ask the question, which collection am
     I a member of?). See `HTTP::DAV::ResourceList' in this node.


File: pm.info,  Node: HTTP/Daemon,  Next: HTTP/Date,  Prev: HTTP/DAV/Resource,  Up: Module List

a simple http server class
**************************

NAME
====

   HTTP::Daemon - a simple http server class

SYNOPSIS
========

     use HTTP::Daemon;
     use HTTP::Status;

     my $d = new HTTP::Daemon;
     print "Please contact me at: <URL:", $d->url, ">\n";
     while (my $c = $d->accept) {
         while (my $r = $c->get_request) {
     	  if ($r->method eq 'GET' and $r->url->path eq "/xyzzy") {
                 # remember, this is *not* recommened practice :-)
     	      $c->send_file_response("/etc/passwd");
     	  } else {
     	      $c->send_error(RC_FORBIDDEN)
     	  }
         }
         $c->close;
         undef($c);
     }

DESCRIPTION
===========

   Instances of the *HTTP::Daemon* class are HTTP/1.1 servers that listen
on a socket for incoming requests. The *HTTP::Daemon* is a sub-class of
IO::Socket::INET, so you can perform socket operations directly on it too.

   The accept() method will return when a connection from a client is
available. The returned value will be a reference to a object of the
*HTTP::Daemon::ClientConn* class which is another IO::Socket::INET
subclass. Calling the get_request() method on this object will read data
from the client and return an HTTP::Request object reference.

   This HTTP daemon does not fork(2) for you.  Your application, i.e. the
user of the *HTTP::Daemon* is reponsible for forking if that is desirable.
Also note that the user is responsible for generating responses that
conform to the HTTP/1.1 protocol.  The *HTTP::Daemon::ClientConn* class
provides some methods that make this easier.

METHODS
=======

   The following is a list of methods that are new (or enhanced) relative
to the IO::Socket::INET base class.

$d = new HTTP::Daemon
     The constructor takes the same parameters as the IO::Socket::INET
     constructor.  It can also be called without specifying any
     parameters. The daemon will then set up a listen queue of 5
     connections and allocate some random port number.  A server that wants
     to bind to some specific address on the standard HTTP port will be
     constructed like this:

          $d = new HTTP::Daemon
                LocalAddr => 'www.someplace.com',
                LocalPort => 80;

$c = $d->accept([$pkg])
     This method is the same as *IO::Socket::accept* but returns an
     *HTTP::Daemon::ClientConn* reference by default.  It returns undef if
     you specify a timeout and no connection is made within that time.

$d->url
     Returns a URL string that can be used to access the server root.

$d->product_tokens
     Returns the name that this server will use to identify itself.  This
     is the string that is sent with the Server response header.  The main
     reason to have this method is that subclasses can override it if they
     want to use another product name.

   The *HTTP::Daemon::ClientConn* is also a IO::Socket::INET subclass.
Instances of this class are returned by the accept() method of
*HTTP::Daemon*.  The following additional methods are provided:

$c->get_request([$headers_only])
     Read data from the client and turn it into an HTTP::Request object
     which is then returned.  It returns undef if reading of the request
     fails.  If it fails, then the *HTTP::Daemon::ClientConn* object ($c)
     should be discarded, and you should not call this method again.  The
     $c->reason method might give you some information about why
     $c->get_request returned undef.

     The $c->get_request method supports HTTP/1.1 request content bodies,
     including *chunked* transfer encoding with footer and self delimiting
     *multipart/** content types.

     The $c->get_request method will normally not return until the whole
     request has been received from the client.  This might not be what you
     want if the request is an upload of a multi-mega-byte file (and with
     chunked transfer encoding HTTP can even support infinite request
     messages - uploading live audio for instance).  If you pass a TRUE
     value as the $headers_only argument, then $c->get_request will return
     immediately after parsing the request headers and you are responsible
     for reading the rest of the request content.  If you are going to
     call $c->get_request again on the same connection you better read the
     correct number of bytes.

$c->read_buffer([$new_value])
     Bytes read by $c->get_request, but not used are placed in the *read
     buffer*.  The next time $c->get_request is called it will consume the
     bytes in this buffer before reading more data from the network
     connection itself.  The read buffer is invalid after $c->get_request
     has returned an undefined value.

     If you handle the reading of the request content yourself you need to
     empty this buffer before you read more and you need to place
     unconsumed bytes here.  You also need this buffer if you implement
     services like *101 Switching Protocols*.

     This method always return the old buffer content and can optionally
     replace the buffer content if you pass it an argument.

$c->reason
     When $c->get_request returns undef you can obtain a short string
     describing why it happened by calling $c->reason.

$c->proto_ge($proto)
     Return TRUE if the client announced a protocol with version number
     greater or equal to the given argument.  The $proto argument can be a
     string like "HTTP/1.1" or just "1.1".

$c->antique_client
     Return TRUE if the client speaks the HTTP/0.9 protocol.  No status
     code and no headers should be returned to such a client.  This should
     be the same as !$c->proto_ge("HTTP/1.0").

$c->force_last_request
     Make sure that $c->get_request will not try to read more requests off
     this connection.  If you generate a response that is not self
     delimiting, then you should signal this fact by calling this method.

     This attribute is turned on automatically if the client announces
     protocol HTTP/1.0 or worse and does not include a "Connection:
     Keep-Alive" header.  It is also turned on automatically when HTTP/1.1
     or better clients send the "Connection: close" request header.

$c->send_status_line( [$code, [$mess, [$proto]]] )
     Send the status line back to the client.  If $code is omitted 200 is
     assumed.  If $mess is omitted, then a message corresponding to $code
     is inserted.  If $proto is missing the content of the
     $HTTP::Daemon::PROTO variable is used.

$c->send_crlf
     Send the CRLF sequence to the client.

$c->send_basic_header( [$code, [$mess, [$proto]]] )
     Send the status line and the "Date:" and "Server:" headers back to
     the client.  This header is assumed to be continued and does not end
     with an empty CRLF line.

$c->send_response( [$res] )
     Write a *HTTP::Response* object to the client as a response.  We try
     hard to make sure that the response is self delimiting so that the
     connection can stay persistent for further request/response exchanges.

     The content attribute of the *HTTP::Response* object can be a normal
     string or a subroutine reference.  If it is a subroutine, then
     whatever this callback routine returns is written back to the client
     as the response content.  The routine will be called until it return
     an undefined or empty value.  If the client is HTTP/1.1 aware then we
     will use chunked transfer encoding for the response.

$c->send_redirect( $loc, [$code, [$entity_body]] )
     Send a redirect response back to the client.  The location ($loc) can
     be an absolute or relative URL. The $code must be one the redirect
     status codes, and defaults to "301 Moved Permanently"

$c->send_error( [$code, [$error_message]] )
     Send an error response back to the client.  If the $code is missing a
     "Bad Request" error is reported.  The $error_message is a string that
     is incorporated in the body of the HTML entity body.

$c->send_file_response($filename)
     Send back a response with the specified $filename as content.  If the
     file is a directory we try to generate an HTML index of it.

$c->send_file($fd);
     Copy the file to the client.  The file can be a string (which will be
     interpreted as a filename) or a reference to an IO::Handle or glob.

$c->daemon
     Return a reference to the corresponding *HTTP::Daemon* object.

SEE ALSO
========

   RFC 2068

   *Note IO/Socket: IO/Socket,, *Note Apache: Apache,

COPYRIGHT
=========

   Copyright 1996-1998, Gisle Aas

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTTP/Date,  Next: HTTP/File,  Prev: HTTP/Daemon,  Up: Module List

date conversion routines
************************

NAME
====

   HTTP::Date - date conversion routines

SYNOPSIS
========

     use HTTP::Date;

     $string = time2str($time);    # Format as GMT ASCII time
     $time = str2time($string);    # convert ASCII date to machine time

DESCRIPTION
===========

   This module provides functions that deal the date formats used by the
HTTP protocol (and then some more).  Only the first two functions,
time2str() and str2time(), are exported by default.

time2str( [$time] )
     The time2str() function converts a machine time (seconds since epoch)
     to a string.  If the function is called without an argument, it will
     use the current time.

     The string returned is in the format preferred for the HTTP protocol.
     This is a fixed length subset of the format defined by RFC 1123,
     represented in Universal Time (GMT).  An example of a time stamp in
     this format is:

          Sun, 06 Nov 1994 08:49:37 GMT

str2time( $str [, $zone] )
     The str2time() function converts a string to machine time.  It returns
     undef if the format of $str is unrecognized, or the time is outside
     the representable range.  The time formats recognized are the same as
     for parse_date().

     The function also takes an optional second argument that specifies the
     default time zone to use when converting the date.  This parameter is
     ignored if the zone is found in the date string itself.  If this
     parameter is missing, and the date string format does not contain any
     zone specification, then the local time zone is assumed.

     If the zone is not "`GMT'" or numerical (like "`-0800'" or
     "`+0100'"), then the `Time::Zone' module must be installed in order
     to get the date recognized.

parse_date( $str )
     This function will try to parse a date string, and then return it as a
     list of numerical values followed by a (possible undefined) time zone
     specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
     returned will not have the number 1900 subtracted from it and the
     $month numbers start with 1.

     In scalar context the numbers are interpolated in a string of the
     "YYYY-MM-DD hh:mm:ss TZ"-format and returned.

     If the date is unrecognized, then the empty list is returned.

     The function is able to parse the following formats:

          "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
          "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
          "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
          "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
          "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format

          "03/Feb/1994:17:03:55 -0700"   -- common logfile format
          "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
          "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
          "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)

          "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
          "1994-02-03 14:15:29"          -- zone is optional
          "1994-02-03"                   -- only date
          "1994-02-03T14:15:29"          -- Use T as separator
          "19940203T141529Z"             -- ISO 8601 compact format
          "19940203"                     -- only date

          "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
          "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
          "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
          "03/Feb/1994"       -- common logfile format     (no time, no offset)

          "Feb  3  1994"      -- Unix 'ls -l' format
          "Feb  3 17:03"      -- Unix 'ls -l' format

          "11-15-96  03:52PM" -- Windows 'dir' format

     The parser ignores leading and trailing whitespace.  It also allow the
     seconds to be missing and the month to be numerical in most formats.

     If the year is missing, then we assume that the date is the first
     matching date before current month.  If the year is given with only 2
     digits, then parse_date() will select the century that makes the year
     closest to the current date.

time2iso( [$time] )
     Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
     string representing time in the local time zone.

time2isoz( [$time] )
     Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
     string representing Universal Time.

SEE ALSO
========

   `time', *Note Perlfunc: (perl.info)perlfunc,, `time', *Note Time/Zone:
Time/Zone,

COPYRIGHT
=========

   Copyright 1995-1999, Gisle Aas

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


