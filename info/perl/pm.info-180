This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: HTML/Testing,  Next: HTML/TipsAndTricks,  Prev: HTML/Template,  Up: Module List

Test module to make test files simpler.
***************************************

NAME
====

   HTML::Testing - Test module to make test files simpler.

SYNOPSIS
========

   A test file, simple.t may be created as follows:

     print "1..1\n";
     use strict;

     require HTML::FormatNroff;
     use HTML::Parse;
     require HTML::Testing;

     my $man_date = '20 Dec 97';
     my $name = "simple";

     my $html_source =<<END_INPUT;
     <HTML>
     <BODY>This is the body.</BODY>
     </HTML>
     END_INPUT

     my $expected = ".TH \"$name\" \"1\" \"$man_date\" \"FormatNroff\"  \n";
     $expected .=<<END_EXPECTED;
     .PP
     This is the body.
     END_EXPECTED

     my $tester = new HTML::Testing(name => $name,
     			        man_date => $man_date,
     			        project => 'FormatNroff',
     			        man_header => 1,
     			        expected => $expected,
     			        html_source => $html_source
     				output => 'TestOutput',
     			        );
     $tester->run_test();
     1;

DESCRIPTION
===========

   Running the test harness with this will result in the creation of the
files simple_expected.out, simple_actual.out and an html file
corresponding to the html_source (simple.html). In addition, the test will
return 'ok' if they are the same, and 'not ok' if not.

   If the attribute html_file is specified, then html will be sourced from
that file instead of html_source, and no html file will be created.

$testing = new HTML::Testing();
-------------------------------

   Create new test.

$testing->directory($value);
----------------------------

   Set the directory for output (HTML, actual and expected output files)
to $value.

$testing->run_test();
---------------------

   Run the test.

COPYRIGHT
=========

   Copyright (c) 1997 Frederick Hirsch. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Frederick Hirsch <f.hirsch@opengroup.org>


File: pm.info,  Node: HTML/TipsAndTricks,  Next: HTML/TokeParser,  Prev: HTML/Testing,  Up: Module List

Contents
========

Tips and Tricks
Alternative Way To Do Global Variables, using __PACKAGE__
Global Variables Via Namespaces
Handling Queries in DBI
Handling Exits
Handling Errors
Development and Production Websites
Tips and Tricks
===============

   This document follows on from the Embperl/EmbperlObject introductory
tutorial. As you can see from that, Embperl/EmbperlObject enables extremely
powerful websites to be built using a very intuitive object-oriented
structure. Now, we'll look at some additional, "unofficial" techniques
which may also be useful in certain circumstances.

   This is a small collection of personal tricks which I have developed
over the course of months using EmbperlObject in my own websites. I hope
they are useful, or at least spur you on to develop your own frameworks
and share these with others.

   If you have any Tips & Tricks you want to share with the public please
send them to richter@dev.ecos.de .

Alternative Way To Do Global Variables, using __PACKAGE__
=========================================================

   In the process of developing a large website I have found it can be a
little onerous at times to use the Request object to pass around global
data. I would like to just create variables like $xxx rather than typing
$req->{xxx} all the time. It may not seem like much, but after a while
your code can start looking a lot more complex because of all the extra
brackets and suchlike. As a typical lazy programmer, I looked for a way to
simplify this.

   The method I am going to describe should be used with caution, because
it can increase memory useage rather dramatically if you're not careful.
The way I use it, no extra memory is used, but you do need to be aware of
the issues.

   Basically, you change the way you include files from `/base.html', so
that they are included into the same package as `/base.html':

     [- Execute ({inputfile => '*', package => __PACKAGE__}) -]

   You should only do this with HTML files which are included from
`/base.html', not with the files such as `subs.html' - those files have to
be in their own packages in order for Perl inheritance to work. You can't
use this technique with any files which are accessed via method calls.

   So how does this make things better? Well, since all these files now
share the same package, any variables which are created in one of the
files is accessible to any of the other files. This means that if you
create $xxx in `/init.html', then you can access $xxx in `/head.html' or
any other file. This effectively gives you global variables across all the
files which are included from `/base.html' into the same package as
`/base.html'.

   The thing you need to be careful of here is that if one of these files
is included more than once elsewhere on the website, then it will be
seperately compiled for that instance - thus taking up more memory. This
is the big caveat. As a rule, if your files are all just included once by
`/base.html', then you should be fine. Note that you'll also need to
change any calls to parent files, for example:

   `/contact/init.html'

     [- Execute ({inputfile => '../init.html', package => __PACKAGE__}) -]

     [-
     	# Do some setup specific to this subdirectory
     -]

   This is ok, since `../init.html' will still be compiled into the same
package as the rest of the files included from `/base.html', and so only
one version of it will exist in the Embperl cache. Thus memory usage is
not increased.

   I like this technique because it simplifies the look of my code, which
is important for projects containing complex algorithms. It is not the
"official" way to implement globals though, and should be used with care.

Global Variables Via Namespaces
===============================

   The previous section described a way to share variables between
different files which are included from `/base.html', by using the same
package across all the files. However this doesn't help us much when
dealing with the method files such as `subs.html', because these files
have to have their own packages - so we are back to square one.

   There is another way to share variables across even different packages,
and that is by using namespaces. For variables that need to be accessible
even from `subs.html', you could use a namespace which is specific to your
website. For example, if your website domain is mydomain.com, then you
could create variables using the form

     $mydomain::xxx = "hello";

   As long as you then make sure that you only use this namespace on this
website (and other websites on the same Apache web server use their own
namespaces), then you shouldn't get any conflicts. Once again, use this
with caution, since you introduce the possibility of inadvertently sharing
variables between completely different websites. For example, if you cut
and paste some useful code from one website to another, you will need to
make sure you change the namespace of any globals. Otherwise, you could
get some very obscure bugs, since different requests to the various
websites could conflict.

   You also need to be careful about variable initialization, since these
globals will now exist between different requests. So, it's possible that
if you don't re-initialize a global variable, then it may contain some
random value from a previous request. This can result in obscure bugs.
Just be careful to initialize all variables properly and you'll be fine.

   Finally, note that Embperl will only clean up variables which don't
have an explicit package (i.e. are in one of the packages automatically
set up by Embperl). Variables in other namespaces are not automatically
cleaned up. As a result, you need to pay closer attention to cleaning up
if you use your own namespaces. The safe way to clean up a variable is
simply to 'undef' it.

Handling Queries in DBI
=======================

   If you are like me, you probably use DBI extensively to enable your
dynamic websites. I have found the cleanup of queries to be onerous - e.g.
calling finish() on queries. If you don't do that, then you tend to get
warnings in your error log about unfinished queries.

   What I do these days is use a global hash, called e.g. %domain::query
(see the previous section for using namespaces to safely implement global
variables). Then, whenever I create a query, I use this variable. For
example:

     $domain::query{first_page} = $domain::dbh->prepare (qq{
     	SELECT *
     	FROM pages
     	WHERE page = 1
     	});
     $domain::query{first_page}->execute();
     my $first_page = $domain::query{first_page}->fetchrow_hashref();

   This little pattern, I find, makes all my queries easier to read and
keep track of. You give each one a name in the %domain::query hash that
makes sense. Then, at the end of each request, in the `/cleanup.html'
file, you can do something like this:

     while (($name, $query) = each (%domain::query))
     {
     	$query->finish();
     }
     $domain::dbh->disconnect();

   Once again, this method is not really the "official" way of doing
things in Embperl. You should use the Request object to pass around global
variables if you're not comfortable with the risks involved with
namespaces (e.g. conflicting websites on the same web server).

Handling Exits
==============

   You will often find that you want to terminate a page before the end.
This doesn't necessarily indicate an error condition; it can be just that
you've done all you want to do. When you do this, it is good to first
clean up, otherwise you can get annoying warnings showing up in your error
logs.

   I use the following framework. `/cleanup.html' is Executed from
`/base.html', and it is the last thing that is done. It calls the
cleanup() function in the `/subs.html' file:

   `/cleanup.html'

     [-
     	$subs->cleanup ();
     -]

   `/subs.html'

     [!
     	sub cleanup
     	{
     		while (($name, $query) = each (%domain::query))
     		{
     			$query->finish();
     		}
     		$domain::dbh->disconnect();
     	}

     sub clean_exit
     {
     	cleanup();
     	exit();
     }
     	!]

   Now, whenever I want to exit prematurely, I use a call to
$subs->clean_exit() rather than just exit(). This makes sure that the
queries and database connections are shut down nicely.

Handling Errors
===============

   The EMBPERL_OBJECT_FALLBACK directive in httpd.conf allows you to set a
file which will be loaded in the event that the requested file is not
found. This file should be relative to the same directory as `base.html'.

   I have found that making a special /errors/ directory is useful,
because it enables that special subdirectory to define its own `head.html'
file, `init.html' and so on.  So, I then just put this in `/notfound.html':

     [-
     	$http_headers_out{'Location'} = "/errors/";
     	clean_exit();
     -]

   See the previous section, "Handling Exits" for more on clean_exit().

Development and Production Websites
===================================

   When I am developing a website, I usually use at least two machines. I
have a workstation where I do developing and testing, and a separate
production server, which is accessed by the public. When I am finished
making changes to the development version of the website, I move it over
to the production server for testing there. However when I do this, I
usually don't copy it immediately over the existing production version,
because there are sometimes issues with Perl modules which haven't been
installed on the server, or other issues which break the code on a
different machine. So I use a separate virtual server and subdomain (which
is easy if you run your own DNS) to test the new version. For example if
the production version of the server is at www.mydomain.com, then I might
do testing on the production server under test.mydomain.com, or beta. or
whatever subdomain you like. This means you have to create a new virtual
server in the httpd.conf file. You also obviously create a new directory
for the test server (see below for an example).

   When you do all this, you end up with a very nice, isolated testing
environment on the same server as production. Obviously you hopefully did
all your major testing on your workstation, where you can crash the
machine and it doesn't matter too much. The production server testbed is a
last staging area before production, to get rid of any lingering glitches
or omissions. When you're sure it's all working correctly you just copy
the files from one directory tree (test) to another (production) on the
same machine. This test server can also be used as a beta of the new
production version. Friendly users can be given access to the new version,
while the old version is still running.

   One issue that comes up when you do this is that of databases. It is
very likely that you will be using a special test database rather than the
live one to test your new version. It would be very unwise to use a
production database for testing. So your production database might be
called "mydatabase", and the test one called "mydatabase_test". This is
fine, but it means that you have to remember to change the database name
in your code when you copy the files over to production. This is very
error prone. The solution is to set variables like the database name in
httpd.conf, by setting an environment variable. You just add it to the
virtual server section.

   Here is a real example of two virtual servers on the same production
machine, which use two different directories, separate log files and
different databases. The website is crazyguyonabike.com, which is a
journal of a bicycle ride I did across America in 1998. I decided to
expand the site to allow other cyclists to upload their own journals,
which resulted in substantial changes to the code. I wanted to keep the
original site up while testing the new version, which I put under
new.crazyguyonabike.com. Here are the relevant apache settings:

   `/etc/apache/httpd.conf'

     # The production server
     <VirtualHost 10.1.1.2:80>
     	ServerName www.crazyguyonabike.com
     	SSLDisable
     	ServerAdmin neil@nilspace.com
     	DocumentRoot /www/crazyguyonabike/com/htdocs
     	DirectoryIndex index.html
     	ErrorLog /www/crazyguyonabike/com/logs/error_log
     	TransferLog /www/crazyguyonabike/com/logs/access_log
     	ErrorDocument 403 /
     	ErrorDocument 404 /
     	PerlSetEnv WEBSITE_DATABASE crazyguyonabike
     	PerlSetEnv WEBSITE_ROOT /www/crazyguyonabike/com/htdocs
     	PerlSetEnv EMBPERL_DEBUG 0
     	PerlSetEnv EMBPERL_ESCMODE 0
     	PerlSetEnv EMBPERL_OPTIONS 16
     	PerlSetEnv EMBPERL_MAILHOST mail.nilspace.com
     	PerlSetEnv EMBPERL_OBJECT_BASE base.html
     	PerlSetEnv EMBPERL_OBJECT_FALLBACK notfound.html
     </VirtualHost>

     <VirtualHost 10.1.1.2:80>
     	ServerName crazyguyonabike.com
     	Redirect / http://www.crazyguyonabike.com
     </VirtualHost>

     # Set EmbPerl handler for main directory
     <Directory "/www/crazyguyonabike/com/htdocs/">
     	<FilesMatch ".*\.html$">
     		SetHandler  perl-script
     		PerlHandler HTML::EmbperlObject
     		Options     ExecCGI
     	</FilesMatch>
     </Directory>

     # The test server
     <VirtualHost 10.1.1.2:80>
     	ServerName new.crazyguyonabike.com
     	SSLDisable
     	ServerAdmin neil@nilspace.com
     	DocumentRoot /www/crazyguyonabike/com/new
     	Alias /pics /www/crazyguyonabike/com/pics
     	DirectoryIndex index.html
     	ErrorLog /www/crazyguyonabike/com/logs/new_error_log
     	TransferLog /www/crazyguyonabike/com/logs/new_access_log
     	ErrorDocument 401 /user/register/
     	ErrorDocument 403 /
     	ErrorDocument 404 /
     	PerlSetEnv WEBSITE_DATABASE crazyguyonabike_new
     	PerlSetEnv WEBSITE_ROOT /www/crazyguyonabike/com/new
     	PerlSetEnv EMBPERL_DEBUG 0
     	PerlSetEnv EMBPERL_ESCMODE 0
     	PerlSetEnv EMBPERL_OPTIONS 16
     	PerlSetEnv EMBPERL_MAILHOST mail.nilspace.com
     	PerlSetEnv EMBPERL_OBJECT_BASE base.html
     	PerlSetEnv EMBPERL_OBJECT_FALLBACK notfound.html
     </VirtualHost>

     # Set EmbPerl handler for new directory
     <Directory "/www/crazyguyonabike/com/new/">
     	<FilesMatch ".*\.html$">
     		SetHandler  perl-script
     		PerlHandler HTML::EmbperlObject
     		Options     ExecCGI
     	</FilesMatch>
     </Directory>

     # Restrict access to test server
     <Directory /www/crazyguyonabike/com/new>
     	AuthType Basic
     	AuthName CrazyTest
     	Auth_MySQL_DB http_auth
     	Auth_MySQL_Encryption_Types Plaintext
     	require valid-user
     	PerlSetEnv EMBPERL_OPTIONS 16
     	PerlSetEnv EMBPERL_MAILHOST mail.nilspace.com
     </Directory>

   Note that the test and production servers each get their own databases,
directories and log files.

   You can also see that I restrict access to the test server (which is
generally wise, unless you actually like hackers potentially screwing with
your head while testing). For basic authentication I use mod_auth_mysql,
which is available from the MySQL website. It is nice because it allows
you to authenticate based on a MySQL database.

   When you use PerlSetEnv to pass in variables, you access these
variables in your code as follows:

     $db_name = $ENV{WEBSITE_DATABASE};

   If you move those constants which differ between the test and
production versions of the same code into the httpd.conf file, then you
can just copy the files over from the test directories to the production
directory without any alterations. This cuts down on editing errors and
also documents specific constants in one place.

Author
======

   Neil Gunton neil@nilspace.com


File: pm.info,  Node: HTML/TokeParser,  Next: HTML/Tree,  Prev: HTML/TipsAndTricks,  Up: Module List

Alternative HTML::Parser interface
**********************************

NAME
====

   HTML::TokeParser - Alternative HTML::Parser interface

SYNOPSIS
========

     require HTML::TokeParser;
     $p = HTML::TokeParser->new("index.html") || die "Can't open: $!";
     while (my $token = $p->get_token) {
         #...
     }

DESCRIPTION
===========

   The HTML::TokeParser is an alternative interface to the HTML::Parser
class.  It basically turns the HTML::Parser inside out.  You associate a
file (or any IO::Handle object or string) with the parser at construction
time and then repeatedly call $parser->get_token to obtain the tags and
text found in the parsed document.

   Calling the methods defined by the HTML::Parser base class will be
confusing, so don't do that.  Use the following methods instead:

$p = HTML::TokeParser->new( $file_or_doc );
     The object constructor argument is either a file name, a file handle
     object, or the complete document to be parsed.

     If the argument is a plain scalar, then it is taken as the name of a
     file to be opened and parsed.  If the file can't be opened for
     reading, then the constructor will return an undefined value and $!
     will tell you why it failed.

     If the argument is a reference to a plain scalar, then this scalar is
     taken to be the literal document to parse.  The value of this scalar
     should not be changed before all tokens have been extracted.

     Otherwise the argument is taken to be some object that the
     `HTML::TokeParser' can read() from when it needs more data.  Typically
     it will be a filehandle of some kind.  The stream will be read() until
     EOF, but not closed.

$p->get_token
     This method will return the next token found in the HTML document, or
     undef at the end of the document.  The token is returned as an array
     reference.  The first element of the array will be a (mostly) single
     character string denoting the type of this token: "S" for start tag,
     "E" for end tag, "T" for text, "C" for comment, "D" for declaration,
     and "PI" for process instructions.  The rest of the array is the same
     as the arguments passed to the corresponding HTML::Parser v2
     compatible callbacks (see *Note HTML/Parser: HTML/Parser,).  In
     summary, returned tokens look like this:

          ["S",  $tag, $attr, $attrseq, $text]
          ["E",  $tag, $text]
          ["T",  $text, $is_data]
          ["C",  $text]
          ["D",  $text]
          ["PI", $token0, $text]

     where $attr is a hash reference, $attrseq is an array reference and
     the rest is plain scalars.

$p->unget_token($token,...)
     If you find out you have read too many tokens you can push them back,
     so that they are returned the next time $p->get_token is called.

$p->get_tag( [$tag, ...] )
     This method returns the next start or end tag (skipping any other
     tokens), or undef if there are no more tags in the document.  If one
     or more arguments are given, then we skip tokens until one of the
     specified tag types is found.  For example:

          $p->get_tag("font", "/font");

     will find the next start or end tag for a font-element.

     The tag information is returned as an array reference in the same form
     as for $p->get_token above, but the type code (first element) is
     missing. A start tag will be returned like this:

          [$tag, $attr, $attrseq, $text]

     The tagname of end tags are prefixed with "/", i.e. end tag is
     returned like this:

          ["/$tag", $text]

$p->get_text( [$endtag] )
     This method returns all text found at the current position. It will
     return a zero length string if the next token is not text.  The
     optional $endtag argument specifies that any text occurring before the
     given tag is to be returned.  Any entities will be converted to their
     corresponding character.

     The $p->{textify} attribute is a hash that defines how certain tags
     can be treated as text.  If the name of a start tag matches a key in
     this hash then this tag is converted to text.  The hash value is used
     to specify which tag attribute to obtain the text from.  If this tag
     attribute is missing, then the upper case name of the tag enclosed in
     brackets is returned, e.g. "[IMG]".  The hash value can also be a
     subroutine reference.  In this case the routine is called with the
     start tag token content as its argument and the return value is
     treated as the text.

     The default $p->{textify} value is:

          {img => "alt", applet => "alt"}

     This means that <IMG> and <APPLET> tags are treated as text, and that
     the text to substitute can be found in the ALT attribute.

$p->get_trimmed_text( [$endtag] )
     Same as $p->get_text above, but will collapse any sequences of white
     space to a single space character.  Leading and trailing white space
     is removed.

EXAMPLES
========

   This example extracts all links from a document.  It will print one
line for each link, containing the URL and the textual description between
the <A>...</A> tags:

     use HTML::TokeParser;
     $p = HTML::TokeParser->new(shift||"index.html");

     while (my $token = $p->get_tag("a")) {
         my $url = $token->[1]{href} || "-";
         my $text = $p->get_trimmed_text("/a");
         print "$url\t$text\n";
     }

   This example extract the <TITLE> from the document:

     use HTML::TokeParser;
     $p = HTML::TokeParser->new(shift||"index.html");
     if ($p->get_tag("title")) {
         my $title = $p->get_trimmed_text;
         print "Title: $title\n";
     }

SEE ALSO
========

   *Note HTML/Parser: HTML/Parser,

COPYRIGHT
=========

   Copyright 1998-2000 Gisle Aas.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: HTML/Tree,  Next: HTML/TreeBuilder,  Prev: HTML/TokeParser,  Up: Module List

Tree - overview of HTML::TreeBuilder et al
******************************************

NAME
====

   HTML-Tree - overview of HTML::TreeBuilder et al

SYNOPSIS
========

     use HTML::TreeBuilder;
     my $tree = HTML::TreeBuilder->new();
     $tree->parse_file($filename);
      #
      # Then do something with the tree, using HTML::Element
      # methods -- for example $tree->dump
      #
      # Then:
     $tree->delete;

DESCRIPTION
===========

   HTML-Tree is a suite of Perl modules for making parse trees out of HTML
source.  It consists of mainly two modules, whose documentation you should
refer to: *Note HTML/TreeBuilder: HTML/TreeBuilder, and *Note
HTML/Element: HTML/Element,.

   HTML::TreeBuilder is the module builds the parse trees.  (It uses
HTML::Parser to do the work of breaking the HTML up into tokens.)

   The tree that TreeBuilder builds for you is made up of objects of the
class HTML::Element.

   If you find that you do not properly understand the documentation for
HTML::TreeBuilder and HTML::Element, it may be because you are unfamiliar
with tree-shaped data structures, or with object-oriented modules in
general.  I have written some articles for *The Perl Journal*
(`www.tpj.com') that seek to provide that background: my article "Scanning
HTML" in TPJ19; my article "Trees" in TPJ18, and my article "A User's View
of Object-Oriented Modules" in TPJ17.  The full text of those articles
will likely appear in a later version of this HTML-Tree module
distribution.

SEE ALSO
========

   *Note HTML/TreeBuilder: HTML/TreeBuilder,, *Note HTML/Element:
HTML/Element,, *Note HTML/Tagset: HTML/Tagset,, *Note HTML/Parser:
HTML/Parser,

   *Note HTML/DOMbo: HTML/DOMbo,

COPYRIGHT
=========

   Copyright 1995-1998 Gisle Aas; copyright 1999-2001 Sean M. Burke.

   The whole HTML-Tree distribution, of which this file is a part, is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.

AUTHOR
======

   Original HTML-Tree author Gisle Aas <gisle@aas.no>; current maintainer
Sean M. Burke, <sburke@cpan.org>


File: pm.info,  Node: HTML/TreeBuilder,  Next: HTML/Validator,  Prev: HTML/Tree,  Up: Module List

Parser that builds a HTML syntax tree
*************************************

NAME
====

   HTML::TreeBuilder - Parser that builds a HTML syntax tree

SYNOPSIS
========

     foreach my $file_name (@ARGV) {
       my $tree = HTML::TreeBuilder->new; # empty tree
       $tree->parse_file($file_name);
       print "Hey, here's a dump of the parse tree of $file_name:\n";
       $tree->dump; # a method we inherit from HTML::Element
       print "And here it is, bizarrely rerendered as HTML:\n",
         $tree->as_HTML, "\n";
     
       # Now that we're done with it, we must destroy it.
       $tree = $tree->delete;
     }

DESCRIPTION
===========

   This class is for HTML syntax trees that get built out of HTML source.
The way to use it is to:

   1. start a new (empty) HTML::TreeBuilder object,

   2. then use one of the methods from HTML::Parser (presumably with
$tree->parse_file($filename) for files, or with
$tree->parse($document_content) and $tree->eof if you've got the content
in a string) to parse the HTML document into the tree $tree.

   3. do whatever you need to do with the syntax tree, presumably
involving traversing it looking for some bit of information in it,

   4. and finally, when you're done with the tree, call $tree->delete to
erase the contents of the tree from memory.  This kind of thing usually
isn't necessary with most Perl objects, but it's necessary for TreeBuilder
objects.  See *Note HTML/Element: HTML/Element, for a more verbose
explanation of why this is the case.

METHODS AND ATTRIBUTES
======================

   Objects of this class inherit the methods of both HTML::Parser and
HTML::Element.  The methods inherited from HTML::Parser are used for
building the HTML tree, and the methods inherited from HTML::Element are
what you use to scrutinize the tree.  Besides this (HTML::TreeBuilder)
documentation, you must also carefully read the HTML::Element
documentation, and also skim the HTML::Parser documentation - probably
only its parse and parse_file methods are of interest.

   The following methods native to HTML::TreeBuilder all control how
parsing takes place; they should be set before you try parsing into the
given object.  You can set the attributes by passing a TRUE or FALSE value
as argument.  E.g., $root->implicit_tags returns the current setting for
the implicit_tags option, $root->implicit_tags(1) turns that option on,
and $root->implicit_tags(0) turns it off.

$root->implicit_tags(value)
     Setting this attribute to true will instruct the parser to try to
     deduce implicit elements and implicit end tags.  If it is false you
     get a parse tree that just reflects the text as it stands, which is
     unlikely to be useful for anything but quick and dirty parsing.
     (And, in current versions, $root-> Default is true.

     Implicit elements have the implicit() attribute set.

$root->implicit_body_p_tag(value)
     This controls an aspect of implicit element behavior, if implicit_tags
     is on:  If a text element (PCDATA) or a phrasal element (such as
     "<em>") is to be inserted under "<body>", two things can happen: if
     implicit_body_p_tag is true, it's placed under a new, implicit "<p>"
     tag.  (Past DTDs suggested this was the only correct behavior, and
     this is how past versions of this module behaved.)  But if
     implicit_body_p_tag is false, nothing is implicated - the PCDATA or
     phrasal element is simply placed under "<body>".  Default is false.

$root->ignore_unknown(value)
     This attribute controls whether unknown tags should be represented as
     elements in the parse tree, or whether they should be ignored.
     Default is true (to ignore unknown tags.)

$root->ignore_text(value)
     Do not represent the text content of elements.  This saves space if
     all you want is to examine the structure of the document.  Default is
     false.

$root->ignore_ignorable_whitespace(value)
     If set to true, TreeBuilder will try to avoid creating ignorable
     whitespace text nodes in the tree.  Default is true.  (In fact, I'd
     be interested in hearing if there's ever a case where you need this
     off, or where leaving it on leads to incorrect behavior.)

$root->p_strict(value)
     If set to true (and it defaults to false), TreeBuilder will take a
     narrower than normal view of what can be under a "p" element; if it
     sees a non-phrasal element about to be inserted under a "p", it will
     close that "p".  Otherwise it will close p elements only for other
     "p"'s, headings, and "form" (altho the latter may be removed in
     future versions).

     For example, when going thru this snippet of code,

          <p>stuff
          <ul>

     TreeBuilder will normally (with `p_strict' false) put the "ul" element
     under the "p" element.  However, with `p_strict' set to true, it will
     close the "p" first.

     In theory, there should be strictness options like this for other/all
     elements besides just "p"; but I treat this as a specal case simply
     because of the fact that "p" occurs so frequently and its end-tag is
     omitted so often; and also because application of strictness rules at
     parse-time across all elements often makes tiny errors in HTML coding
     produce drastically bad parse-trees, in my experience.

     If you find that you wish you had an option like this to enforce
     content-models on all elements, then I suggest that what you want is
     content-model checking as a stage after TreeBuilder has finished
     parsing.

$root->store_comments(value)
     This determines whether TreeBuilder will normally store comments found
     while parsing content into $root.  Currently, this is off by default.

$root->store_declarations(value)
     This determines whether TreeBuilder will normally store markup
     declarations found while parsing content into $root.  Currently, this
     is off by default.

     It is somewhat of a known bug (to be fixed one of these days, if
     anyone needs it?) that declarations in the preamble (before the "html"
     start-tag) end up actually *under* the "html" element.

$root->store_pis(value)
     This determines whether TreeBuilder will normally store processing
     instructions found while parsing content into $root - assuming a
     recent version of HTML::Parser (old versions won't parse PIs
     correctly).  Currently, this is off (false) by default.

     It is somewhat of a known bug (to be fixed one of these days, if
     anyone needs it?) that PIs in the preamble (before the "html"
     start-tag) end up actually *under* the "html" element.

$root->warn(value)
     This determines whether syntax errors during parsing should generate
     warnings, emitted via Perl's warn function.

     This is off (false) by default.

HTML AND ITS DISCONTENTS
========================

   HTML is rather harder to parse than people who write it generally
suspect.

   Here's the problem: HTML is a kind of SGML that permits "minimization"
and "implication".  In short, this means that you don't have to close
every tag you open (because the opening of a subsequent tag may implicitly
close it), and if you use a tag that can't occur in the context you seem
to using it in, under certain conditions the parser will be able to
realize you mean to leave the current context and enter the new one, that
being the only one that your code could correctly be interpreted in.

   Now, this would all work flawlessly and unproblematically if: 1) all
the rules that both prescribe and describe HTML were (and had been)
clearly set out, and 2) everyone was aware of these rules and wrote their
code in compliance to them.

   However, it didn't happen that way, and so most HTML pages are
difficult if not impossible to correctly parse with nearly any set of
straightforward SGML rules.  That's why the internals of HTML::TreeBuilder
consist of lots and lots of special cases - instead of being just a
generic SGML parser with HTML DTD rules plugged in.

BUGS
====

   * Hopefully framesets behave correctly now.  Email me if you find a
strange parse of documents with framesets.

   * Bad HTML code will, often as not, make for a bad parse tree.
Regrettable, but unavoidably true.

   * If you're running with implicit_tags off (God help you!), consider
that $tree->content_list probably contains the tree or grove from the
parse, and not $tree itself (which will, oddly enough, be an implicit
'html' element).  This seems counter-intuitive and problematic; but seeing
as how almost no HTML ever parses correctly with implicit_tags off, this
interface oddity seems the least of your problems.

BUG REPORTS
===========

   When a document parses in a way different from how you think it should,
I ask that you report this to me as a bug.  The first thing you should do
is copy the document, trim out as much of it as you can while still
producing the bug in question, and *then* email me that mini-document and
the code you're using to parse it, at `sburke@cpan.org'.  Include a note
as to how it parses (presumably including its $tree->dump output), and
then a *careful and clear* explanation of where you think the parser is
going astray, and how you would prefer that it work instead.

SEE ALSO
========

   *Note HTML/Parser: HTML/Parser,, *Note HTML/Element: HTML/Element,,
*Note HTML/Tagset: HTML/Tagset,

   *Note HTML/DOMbo: HTML/DOMbo,

COPYRIGHT
=========

   Copyright 1995-1998 Gisle Aas; copyright 1999, 2000 Sean M. Burke.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Original author Gisle Aas <gisle@aas.no>; current maintainer Sean M.
Burke, <sburke@cpan.org>


File: pm.info,  Node: HTML/Validator,  Next: HTML/WWWTheme,  Prev: HTML/TreeBuilder,  Up: Module List

HTML validation by using nsgmls
*******************************

NAME
====

   HTML::Validator - HTML validation by using nsgmls

SYNOPSIS
========

     use HTML::Validator;
     $doc = new HTML::Validator($file);
     $doc->validate;
     print "Document is valid\n" if $doc->is_valid;

DESCRIPTION
===========

   This module can be used to validate HTML (or SGML) documents. For the
validation itself, it uses nsgmls and a set of document type definition
files (aka DTDs).

   HTML::Validator uses *libwww-perl* to validate remote files.

$doc->open($file)
     The file or url will be used as the document to validate. This method
     will be called implicitely if the constructor is called with an
     argument.

$doc->doctype
     Returns the document type.

     The return value is undefined if no filename has been passed to the
     object via the constructor or the open method.

     If the file has not been retrieved yet, it will be done.

     If you want to replace the document type, you must do so with the
     first call to this method. The document types are defined in
     $doc->{dtdmap}.

$doc->checkdtd
     Finds out the actual name of document type definition file that is
     used.  The return value is the name of the file, or undefined if the
     document type is not defined.

$doc->validate
     Validates the document. The return value is a reference to an array
     containing the modified output from nsgmls.

$doc->get_file
     Internal method to get the file and process the doctype information.

$doc->substitute_dtd_url
     If there is an URL in the doctype, it will be replaced to support
     nsgmls binaries that do not support URLs

$doc->replace_dtd
     Replaces the document type definition on the file. The new dtd is the
     first argument, or the default dtd if no argument is supplied.

$doc->errors
     Returns an error from nsgmls error output queue.

$doc->parse_errors
     Internal method to parse the raw nsgmsl output to a more readable
     form.  If you want to call this method more than once per object,
     purge the error output queue with $doc->errors first.

     This method will call a parser method to do the actual parsing, which
     is $doc->parser() by default. It can overriden by setting
     $doc->{parser}.

$doc->parser
     The default nsgmls output parser. This is called from parse_errors.
     If the return value is undef, then to parser is assumed to have found
     no errors. Otherwise the parser will return a reference to an array
     containing the errors.

$doc->is_valid
     Returns 1 if document is valid, 0 if document is invalid and undef if
     document hasn't been validated yet.

$doc->source
     Contains the source of the HTML file as a scalar.

$doc->message
     Contains the message queue. If called with an argument, places a new
     message to the queue, without an argument a message (if any) is
     removed.

     If the argument is '-1', the last message on the queue is returned.

$doc->reset
     Resets the object to original state so we can reuse it

VARIABLES
=========

$doc->{nsgmls}
     The used nsgmls binary

$doc->{catalog}
     The used catalog file

$doc->{message}
     Array of messages

$doc->{maxerr}
     The maximum number of errors. This is passed to nsgmls with the -E
     option

$doc->{doctype}
     The document type for the document

$doc->{defaultdtd}
     The default type for the document. By default this is 'html4'.

$doc->{dtdfile}
     The dtd used for the document

$doc->{dtdmap}
     The mapping for document types and the explicit document type
     definition strings

$doc->{parser}
     The custom parser to use. See the information for the parser method.

REQUIREMENTS
============

     HTML::Validator requires that

   * nsgmls is installed. It comes with James Clark's *sp* SGML toolkit,
     *http://www.jclark.com/sp/howtoget.htm*

   * you have a reasonable set of document type files. For this purpose,
     you can use W3C's sgml library at
     *http://validator.w3.org/sgml-lib.tar.gz*

SEE ALSO
========

   *Note LWP: LWP,, `nsgmls' in this node

ACKNOWLEDGEMENTS
================

   Thanks go to:

     - Heikki Kantola <hezu@iki.fi>, for his help in the early testing
       phases and his excellent knowledge about HTML standards.

AVAILABILITY
============

   The latest version of HTML::Validator can be found from
*http://www.iki.fi/si/HTML-Validator/*.

   It is also available from CPAN (*http://www.perl.com/CPAN/*).

COPYRIGHT
=========

   HTML::Validator is (c) 1997-1999 Sami Itkonen <si@iki.fi>

   HTML::Validator is distributed under the GNU General Public License.


File: pm.info,  Node: HTML/WWWTheme,  Next: HTML/Widgets/DateEntry,  Prev: HTML/Validator,  Up: Module List

Standard theme generation, including sidebars and navigation bars
*****************************************************************

NAME
====

   HTML::WWWTheme - Standard theme generation, including sidebars and
navigation bars

SYNOPSIS
========

     use HTML::WWWTheme;
     my $Theme = new HTML::WWWTheme(@args);

REQUIREMENTS
============

   Nothing special - Perl 5 or newer.

DESCRIPTION
===========

   HTML::WWWTheme is a module that creates a standard sidebar and
implements local colour conventions.  It is used by the
Apache::SetWWWTheme module to enforce this through the server.  In fact,
the code in this module was originally contained within the SetWWWTheme
module, but at the suggestion of Tim Jenness, I separated this module to
allow CGI programs to create standard pages that would fit in with the
static pages that are automatically rewritten by the Apache module.  So,
static pages in the web tree are filtered through Apache::SetWWWTheme, and
CGI-generated pages are generated with the help of HTML::WWWTheme.  In
this manner, a consistent look and feel can be maintained in all pages.
Any changes in the structure of WWWTheme are automatically reflected in
both the CGI-generated and static pages.

   The new() function will return a reference to a Theme object.  It will
accept an array of arbitrary length as arguments.  Each element of this
array must be a fully qualified path to a configuration file.

   Configuration is accomplished in three ways.  First, one may pass
arguments to the new() function.  These arguments must be fully qualified
paths to a configuration file.  The syntax of the directives in this file
is simple:

     @DIRECTIVE=value;
     
     for example,

     @BGCOLOR=#FFFFFF;

   or, in the case of a directive that accepts a list, the values are
comma-separated and semi-colon terminated.  Escaped semi-colons will be
transformed into semi-colons, and will not terminate the directive.

     @DIRECTIVE=value1, value2, value3;

     @DIRECTIVE=value1, value2\; still going, value3;

   In the second example, the value2\; will be replaced with value2; in
the parsed text.

   for example,

     @INFO=<A HREF="here.html">Here</a>, <A HREF="there.html">There</a>;

   Second, the GetConfiguration() function may be passed a list of
full-paths to configuration files.  The GetConfiguration() function will
parse these files and set the appropriate values.

   Finally, one may use methods to directly change the settings of the
page before it is produced.  This is the recommended method, because it is
the most intuitive and the easiest to figure out when you're trying to
figure out someone else's code.  I use these methods extensively in my
Apache::SetWWWTheme module.

METHODS
-------

   The following are all the methods that may be used to control the
behaviour of the module.

GetConfiguration()
     This method takes the names of configuration files as arguments, and
     parses them one by one.  The configuration files contain a series of
     directives of the form

          @DIRECTIVE=value;

     or, in the case of a list-value (for example, with the infolinks that
     make up the links on the sidebar under "More Links" or "More Info")

          @DIRECTIVE=value1, value2, value3;

     Valid directives are listed, along with the corresponding method that
     performs the same method:

          @BLANKGIF          (see SetBlankGif() )
          @NAVBAR            (see SetUseNavBar() )
          @NEXTLINK          (see SetNextLink() )
          @LASTLINK          (see SetLastLink() )
          @UPLINK            (see SetUpLink() )
          @BGCOLOR           (see SetBGColor() )
          @BGPICTURE         (see SetBGPicture() )
          @BACKGROUND        (see SetBGPicture() )
          @ALINK             (see SetALink() )
          @LINK              (see SetLink() )
          @VLINK             (see SetVLink() )
          @SIDEBARTOP        (see SetSideBarTop() )
          @SIDEBARMENUTITLE  (see SetSidebarMenuTitle() )
          @SIDEBARSEARCHBOX  (see SetSideBarSearchBox() )
          @SIDEBARCOLOR      (see SetSideBarColor() )
          @SIDEBARWIDTH      (see SetSideBarWidth() )
          @NOSIDEBAREXTRAS   (see SetNoSideBarExtras() )
          @MORELINKSTITLE    (see SetMoreLinksTitle() )
          @INFO              (see SetInfoLinks() )
          @SIDEBARMENULINKS  (see SetSideBarMenuLinks() )

MakeFooter()
     Returns a footer to end the document.  Should be the last part of a
     dynamically generated HTML page.  See the example.

MakeHeader()
     Returns the header to the page.  Should be the first part of a
     dynamically generated HTML page.  See the example.

MakeNavBar()
     Returns a "previous/up/next" navigation bar.  This bar is designed to
     be sandwiched between the Header and the main body, and then later on
     between the end of the main body and the Footer.  See the example.

SetNextLink()
     Sets the "Next" link on the top/bottom nav bars.  Valid entries must
     be in the form of an HTML link,

          $Theme->SetNextLink('<A HREF="http://somewhere.com">somewhere</a>');

SetLastLink()
     Sets the "Last" or "Previous" link on the top/bottom nav bars.  Valid
     entries must be in the form of an HTML link,

          $Theme->SetLastLink('<A HREF="http://here.com">here</a>');

SetUpLink()
     Sets the "Up" link on the top/bottom nav bars.  Valid entries must be
     in the form of an HTML link,

          $Theme->SetUpLink('<A HREF="http://there.com">there</a>');

SetBGColor()
     Sets the background color for the page generated.  Valid entries must
     be in the form of a hex color code,

          $Theme->SetBGColor("#CCFFFF");

SetBGPicture()
     Sets the background image for the page generated.  Valid entries must
     be in the form of an absolute URL or URI.

          $Theme->SetBGPicture("/WWW/images/wallpaper.gif");

SetALink(), SetLink(), SetVLink()
     Sets the [a|v]link color for the <BODY> tag.  Valid entries must be
     in the form of a hex color code.

          $Theme->SetALink("#FFCCFF");
          $Theme->SetVLink("#FFCCFF");
          $Theme->SetLink ("#FFCCFF");

SetMoreLinksTitle()
     Sets the "More links" title on the sidebar.  By default it says "More
     links", but you may want to change it something else.

          $Theme->SetMoreLinksTitle("More useful links");

SetNoSideBarExtras()
     If this is true, it turns off the sidebar extras - those parts of the
     sidebar that aren't in the "SidebarMenuLinks" bit.

          $Theme->SetNoSideBarExtras("1");

SetHTMLStartString()
     Sets the HTML starting string.  This string should include the <HTML>
     opening tag, the <HEAD></HEAD> tags (and anything inbetween).
     Essentially, it should contain everything before the <BODY> tag.  If
     you are using this module for a CGI program, you should probably
     include the usual Content-Type: text/html sort of thing.

          $Theme->SetHTMLStartString("<HTML><HEAD><TITLE>This is my page.</TITLE></HEAD>");

SetHTMLEndString()
     Sets the HTML ending string.  This string should contain everything
     after the </BODY> tag, including such things as </HTML>.

          $Theme->SetHTMLEndString("</HTML>");

SetPrintableName()
     Sets the URL that is used to produce a printable version of the page.
     This is used to generate the small "click here to produce a printable
     version" link on the themed page.  How this is implemented is left to
     the caller.  Apache::SetWWWTheme produces an un-themed page, with all
     the link tags stripped out to discourage people from browsing in the
     printable pages and thus subverting the theming.

          $Theme->SetPrintableName("/printable/path/to/file.html");

SetText()
     Sets the text color for the <BODY> tag.  Valid entries must be in the
     form of a hex color code.

          $Theme->SetText("#000000");

SetSideBarColor()
     Sets the color of the generated sidebar.  Valid entries must be in
     the form of a hex color code.

          $Theme->SetSideBarColor("#FFCCFF");

SetSideBarWidth()
     Sets the width of the sidebar in pixels.  The default is 150.

          $Theme->SetSideBarWidth("120");

SetBlankGif()
     Sets the location of the blank gif.  A blank gif (blank.gif) is
     included in the distribution of this package.  Valid entries must be
     in the form of a URL or URI pointing to this file.

          $Theme->SetBlankGif("/WWW/images/blank.gif");

SetInfoLinks()
     Sets the value of the "info links".  Info links are designed to be
     user-configurable and fall under the "More Links" or "More
     information" section of the sidebar.  Valid entries must be in the
     form of a reference to an array of valid links.

          @array = ('<a href="here.html">here</a>', '<a href="there.html">there</a>');
          $Theme->SetInfoLinks(\@array);

SetSideBarTop()
     Sets the name appearing at the top of the sidebar.  This may be a
     link, if desired. Valid entries are strings.

          $Theme->SetSideBarTop('<A HREF="/">My Webserver</a>');

SetSearchTemplate()
     Sets the template to insert into the HTML for the side searchbox.  It
     should be self-contained HTML with the appropriate form methods etc.
     to interface with your local search engine.  Here is an example of a
     template:

          <B>Search JAC</B><BR><HR>
          <DIV align="center">
          <form method="POST" action="/cgi-bin/isearch">
          <input name="SEARCH_TYPE" type=hidden  value="ADVANCED">
          <input name="HTTP_PATH" type=hidden value="/WWW">
          <input name="DATABASE" type=hidden value="webindex">
          <input name="FIELD_1" type=hidden value="FULLTEXT">
          <input name="WEIGHT_1" type=hidden value= "1">
          <input name="ELEMENT_SET" type=hidden value="TITLE">
          <input name="MAXHITS" type=hidden value="50">
          <input name="ISEARCH_TERM" size="14" border="0">
          </form>
          </DIV>
          <H6><a href="http://www.yoursite.edu/search.html">More searching....</a></h6>

     Your template must be customized as appropriate for your engine, of
     course.  This template should be passed to the SetSearchTemplate
     function as one big string.

SetSideBarMenuLinks()
     Sets the value of the main sidebar links.  Valid entries must be in
     the form of a reference to an array of valid links.

          @array = ('<a href="here.html">here</a>', '<a href="there.html">there</a>');
          $Theme->SetSideBarMenuLinks(\@array);

SetSideBarMenuTitle()
     Sets the name of the main sidebar links.  Valid entries must be in
     the form of a string,

          $Theme->SetSideBarMenuTitle("Main Sections");

SetSideBarSearchBox()
     Sets the state of the sidebar searchbox.  If this value is set to
     anything true (in the perl sense), the searchbox will appear on the
     sidebar.

          $Theme->SetSideBarSearchBox("1");

SetUseNavBar()
     Sets the state of the top/bottom navbars.  If this value is set to
     anything true (in the perl sense), the top/bottom navbars will be
     place on the page.  These navbars will be created with the values set
     in the Set__Link() methods.

          $Theme->SetUseNavBar("1");

SetTopBottomLinks()
     Sets the links used in the top/bottom link bars.  It takes an array
     reference as data.

          @array = ('<a href="here.html">here</a>', '<a href="there.html">there</a>');
          $Theme->SetTopBottomLinks(\@array);

StartHTML()
     Returns the contents of the string set in SetHTMLStartString.  This
     is mostly just a placeholder for some time in the future when I get
     around to fully implementing this module to mimic the abilities of
     some other well-known modules.

          print $Theme->StartHTML();

EndHTML()
     Returns the contents of the string set in SetHTMLEndString.  This is
     mostly just a placeholder for some time in the future when I get
     around to fully implementing this module to mimic the abilities of
     some other well-known modules.

          print $Theme->EndHTML();

     The MakeNavBar() function may be used to create the top/bottom
     navigation bar.  This bar contains the previous/up/next links.  It
     takes no arguments, but uses the [next|last|up]link keys in the hash.

     Finally, the MakeFooter() function is used to end the html file.
     This function is absolutely necessary, as the page won't render
     without it!  The tables will not be finished, and very few browswers
     can deal with this.

     Here is a simple but functional example.  Notice that there are no
     <BODY> tags.  The header and footer take care of this.  Write your
     HTML as if you were writing between the <BODY> and </BODY> tags.:

          #!/usr/bin/perl -w

          use strict;
          use HTML::WWWTheme;

          # read in a few defaults
          my $Theme = new HTML::WWWTheme("/WWW/LookAndFeel", "/home/chogan/Lookandfeel");

          # set a few things by hand
          $Theme->SetBlankGif("/WWW/images/blank.gif");
          $Theme->SetBGColor("#FFFFFF");
          $Theme->SetHTMLStartString("<HTML><HEAD><TITLE>My Example.</TITLE></HEAD>");
          $Theme->SetHTMLEndString("</HTML>");

          # make the header, navbar, body, navbar, footer.
          print $Theme->StartHTML();
          print $Theme->MakeHeader();
          print $Theme->MakeTopBottomBar();
          print $Theme->MakeNavBar();
          print "This is the body of my file.  Isn't it groovy?";
          print $Theme->MakeNavBar();
          print $Theme->MakeTopBottomBar();
          print $Theme->MakeFooter();
          print $Theme->EndHTML();
          exit 0;

SEE ALSO
========

   *Note Apache/SetWWWTheme: Apache/SetWWWTheme,

AUTHOR
======

   Copyright (C) 2000 Chad Hogan (chogan@uvastro.phys.uvic.ca).  Copyright
(C) 2000 Joint Astronomy Centre

   All rights reserved.  HTML::WWWTheme is free software; you can
redistribute it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either version 2 or
(at your option) any later version.

   HTML::WWWTheme is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

   You should have received a copy of the GNU General Public License along
with HTML::WWWTheme; see the file gpl.txt.  If not, write to the Free
Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.


