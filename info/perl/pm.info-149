This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Fwctl/Services/ipsec,  Next: Fwctl/Services/lpd,  Prev: Fwctl/Services/ip_pkt,  Up: Module List

Fwctl module to handle the IPSec protocol.
******************************************

NAME
====

   Fwctl::Services::ipsec - Fwctl module to handle the IPSec protocol.

SYNOPSIS
========

     accept ipsec -src INT_NET -dst REMOTE_IPSEC

DESCRIPTION
===========

   This module will implements the rules to accept/block/account the IPSec
tunnelling protocol. In order to be able to masquerade that protocol, you
will need a kernel with the IPSec masquerade patch applied.

   See ftp://ftp.rubyriver.com/pub/jhardin/masquerade/ for informations.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/lpd,  Next: Fwctl/Services/name_service,  Prev: Fwctl/Services/ipsec,  Up: Module List

Fwctl module to handle the Berkeley Line Printer 		       protocol.
*******************************************************************

NAME
====

   Fwctl::Services::lpd - Fwctl module to handle the Berkeley Line Printer
      protocol.

SYNOPSIS
========

     accept   lpd -src INTERNAL_NET -dst PRINTER

DESCRIPTION
===========

   The lpd modules handles the LP protocol. It permits a tcp connection
from the privileged 512 through 1023 to the printer port (515). You can use
the local_port option to specifies another range of port.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/name_service,  Next: Fwctl/Services/netbios,  Prev: Fwctl/Services/lpd,  Up: Module List

Fwctl module to handle the DNS protocol.
****************************************

NAME
====

   Fwctl::Services::name_service - Fwctl module to handle the DNS protocol.

SYNOPSIS
========

     accept   name_service -src INTERNET -dst NAME_SERVER
     accept   name_service -src NAME_SERVER -dst INTERNET -query-port 5353

DESCRIPTION
===========

   The name_service module handles the DNS protocol. It can handle both
name server and resolver configuration. When using the server option, the
query can be from any ports. You can use the *query-port* option to
specify the client port.

   Default is to use only ports > 1023 as client port. (Usual resolver
situation.)

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/netbios,  Next: Fwctl/Services/ntp,  Prev: Fwctl/Services/name_service,  Up: Module List

Fwctl module to handle NetBIOS traffic.
***************************************

NAME
====

   Fwctl::Services::netbios - Fwctl module to handle NetBIOS traffic.

SYNOPSIS
========

     deny    netbios -nolog --account

DESCRIPTION
===========

   This module handle the NetBios-NS, NetBios-DGM and NetBios-SSN part of
the NetBIOS protocols. Its primary use is to reduce log clutter when
servicing a Windows Internal Network.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/ntp,  Next: Fwctl/Services/pcanywhere,  Prev: Fwctl/Services/netbios,  Up: Module List

Fwctl module to handle the NTP protocol.
****************************************

NAME
====

   Fwctl::Services::ntp - Fwctl module to handle the NTP protocol.

SYNOPSIS
========

     accept   ntp -src PROXY -dst NTP_SERVER
     accept   ntp -src PROXY -dst NTP_SERVER -client -masq #For ntpdate

DESCRIPTION
===========

   This module enable NTP traffic between two NTP servers. If you use the
client option, it will use UNPRIVILEGED_PORTS for the SourcePort to enable
ntp clients like *ntpdate*.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/pcanywhere,  Next: Fwctl/Services/ping,  Prev: Fwctl/Services/ntp,  Up: Module List

Fwctl module to handle the PC Anywhere protocol.
************************************************

NAME
====

   Fwctl::Services::pcanywhere - Fwctl module to handle the PC Anywhere
protocol.

SYNOPSIS
========

     accept    pcanywhere -src INT_NET -dst REMOTE -masq -account -name PCA

DESCRIPTION
===========

   This module encapsulates the different TCP and UDP connections used by
the PC Anywhere protocol. Use the -old option to use the older set of non
registered ports.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/ping,  Next: Fwctl/Services/portmap,  Prev: Fwctl/Services/pcanywhere,  Up: Module List

Fwctl module to handle the ping service.
****************************************

NAME
====

   Fwctl::Services::ping - Fwctl module to handle the ping service.

SYNOPSIS
========

     accept  ping -src INTERNAL_NET -dst INTERNET -masq
     deny    ping -dst BAD_GUYS_NET	--account
     account ping -src INTERNET -dst FIREWALL

DESCRIPTION
===========

   The ping module manages rules for the ICMP echo-request and echo-reply
types used by the ping program.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/portmap,  Next: Fwctl/Services/pptp,  Prev: Fwctl/Services/ping,  Up: Module List

Fwctl module to handle the portmapper service.
**********************************************

NAME
====

   Fwctl::Services::portmap - Fwctl module to handle the portmapper
service.

SYNOPSIS
========

     deny    portmap -src INTERNET	--account

DESCRIPTION
===========

   The portmapper handles portmap traffic.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/pptp,  Next: Fwctl/Services/redirect,  Prev: Fwctl/Services/portmap,  Up: Module List

Fwctl module to handle the PPTP service.
****************************************

NAME
====

   Fwctl::Services::pptp - Fwctl module to handle the PPTP service.

SYNOPSIS
========

     accept pptp -src INT_NET -dst REMOTE_PPTP --masq

DESCRIPTION
===========

   This module will implements the rules to accept/block/account the PPTP
tunnelling protocol. In order to be able to masquerade that protocol, you
will need a kernel with the generic protocol masquerade patch applied.

   See ftp://ftp.rubyriver.com/pub/jhardin/masquerade/ for informations.

   If you want to generates rules for a server behind the firewall, you
will have to use the -portfw option and starts manually the ipfwd daemon.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/redirect,  Next: Fwctl/Services/rsh,  Prev: Fwctl/Services/pptp,  Up: Module List

Fwctl module to handle ICMP redirect messages.
**********************************************

NAME
====

   Fwctl::Services::redirect - Fwctl module to handle ICMP redirect
messages.

SYNOPSIS
========

     accept  redirect -src INT_IP -dst INT_NET
     account redirect -src INTERNET

DESCRIPTION
===========

   The redirect module can be use to configure policies for ICMP Router
Redirect messages. This module takes no options.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/rsh,  Next: Fwctl/Services/snmp,  Prev: Fwctl/Services/redirect,  Up: Module List

Fwctl module to handle the rsh protocol.
****************************************

NAME
====

   Fwctl::Services::rsh - Fwctl module to handle the rsh protocol.

SYNOPSIS
========

     accept   rsh -src INTERNAL_NET -dst FIREWALL

DESCRIPTION
===========

   The rsh module handles the remote shell protocol.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/snmp,  Next: Fwctl/Services/syslog,  Prev: Fwctl/Services/rsh,  Up: Module List

Fwctl module to handle the snmp protocol.
*****************************************

NAME
====

   Fwctl::Services::snmp - Fwctl module to handle the snmp protocol.

SYNOPSIS
========

     accept   snmp -src INTERNAL_NET -dst PERIM_NET
     deny    snmp -src INTERNAL_NET -nolog
     account snmp

DESCRIPTION
===========

   This module handles the SNMP protocol. Its handles SNMP broadcast if
dst is in the same network as src, SNMP traffic between source and
destination, as well as snmp-trap from destination to source.

   Since I don't really know the internals of the SNMP protocol this could
be totally broken. Use only to reduce log file clutter.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/syslog,  Next: Fwctl/Services/tcp_service,  Prev: Fwctl/Services/snmp,  Up: Module List

Fwctl module to handle syslog UDP traffic.
******************************************

NAME
====

   Fwctl::Services::syslog - Fwctl module to handle syslog UDP traffic.

SYNOPSIS
========

     accept   syslog -src ROUTER -dst LOGGER

DESCRIPTION
===========

   This modules handles syslog traffic. Syslog traffic is unidirectional
UDP message from client to server.

OPTIONS
=======

   In addition to the standard options, it accepts the following ones.

-client
     This will accepts message coming from a syslog client not bound to
     port 514. The default is to accept messages only coming from port 514.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/tcp_service,  Next: Fwctl/Services/tftp,  Prev: Fwctl/Services/syslog,  Up: Module List

Fwctl module to handle simple TCP client/server communication.
**************************************************************

NAME
====

   Fwctl::Services::tcp_service - Fwctl module to handle simple TCP
client/server communication.

SYNOPSIS
========

     accept   tcp_service -src INTERNAL_NET -dst DATABASE_SERVER -port postgres
     # Same as
     accept   postgres -src INTERNAL_NET -dst DATABASE_SERVER
     account tcp_service -src INTERNET -port telnet
     # Same as
     account telnet  -src INTERNET

DESCRIPTION
===========

   This Fwctl module is used to handle single connection TCP
client/server. It takes as options port and *local_port* which are used to
set the destination and source port of the connection.

   This is the module used to auto generate TCP service.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/tftp,  Next: Fwctl/Services/timed,  Prev: Fwctl/Services/tcp_service,  Up: Module List

Fwctl module to handle tftp protocol.
*************************************

NAME
====

   Fwctl::Services::all - Fwctl module to handle tftp protocol.

SYNOPSIS
========

     deny   tftp

DESCRIPTION
===========

   Service module to handle tftp protocol.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/timed,  Next: Fwctl/Services/traceroute,  Prev: Fwctl/Services/tftp,  Up: Module List

Fwctl module to handle any IP traffic.
**************************************

NAME
====

   Fwctl::Services::timed - Fwctl module to handle any IP traffic.

SYNOPSIS
========

     accept   timed -src INTERNAL_NET -dst FIREWALL
     deny    timed -src INTERNET

DESCRIPTION
===========

   The timed module is used to handle the timed time synchronization
protocol. This modules takes care of the broadcast part of the protocol
and the ICMP part.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/traceroute,  Next: Fwctl/Services/traffic_control,  Prev: Fwctl/Services/timed,  Up: Module List

Fwctl module to handle traceroute service.
******************************************

NAME
====

   Fwctl::Services::traceroute - Fwctl module to handle traceroute service.

SYNOPSIS
========

     accept   traceroute -src INTERNAL_NET -dst INTERNET -masq
     deny    traceroute -src INTERNET	--account
     account traceroute -src INTERNET -dst PERIM_NET

DESCRIPTION
===========

   This module handle the usual UDP traffic used by the *traceroute*
program.  You can use the port option to set the range of port used if your
program isn't using the default 33434 and higher.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/traffic_control,  Next: Fwctl/Services/udp_pkt,  Prev: Fwctl/Services/traceroute,  Up: Module List

Fwctl module to handle the necessary  ICMP traffic.
***************************************************

NAME
====

   Fwctl::Services::traffic_control - Fwctl module to handle the necessary
ICMP traffic.

SYNOPSIS
========

     accept   traffic_control -src INTERNET --account
     accept   traffic_control

DESCRIPTION
===========

   This module handles rules for the necessary ICMP traffic control types:
destination-unreachable, source-quench, ttl-exceeded and parameter-problem.

   You should really accept this with any network you want to communicate.
Failure to do so, will hinder communication severly. YHBW.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/udp_pkt,  Next: Fwctl/Services/udp_service,  Prev: Fwctl/Services/traffic_control,  Up: Module List

Fwctl module to hande unidirectional UDP packets.
*************************************************

NAME
====

   Fwctl::Services::udp_pkt - Fwctl module to hande unidirectional UDP
packets.

SYNOPSIS
========

     accept   udp_pkt -src ROUTER -dst LOGGER --local_port 514 --port 514

DESCRIPTION
===========

   This module will add rules to the firewall for unidrectional UDP
traffic.

OPTIONS
=======

   In addition to the standard options, it accepts the following ones.

-local_port
     This is the source port of the udp packet.

-port
     This is the destination port of the udp packet.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: Fwctl/Services/udp_service,  Next: GD,  Prev: Fwctl/Services/udp_pkt,  Up: Module List

Fwctl module to handle bidirectional UDP traffic.
*************************************************

NAME
====

   Fwctl::Services::udp_service - Fwctl module to handle bidirectional UDP
traffic.

SYNOPSIS
========

     accept   udp_service -src INTERNAL_NET -dst FIREWALL -masq -port 2049

DESCRIPTION
===========

   This module is similar to the tcp_service one, in that it handles
simple bidirectional UDP communication between client and server.  Source
and destination ports are given using the *local_port* and port
respectively. Those defaults to UNPRIVILEGED_PORTS. Enough to shoot you in
the foot, I know.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999,2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

SEE ALSO
========

   fwctl(8) Fwctl(3) Fwctl::RuleSet(3)


File: pm.info,  Node: GD,  Next: GD/Barcode,  Prev: Fwctl/Services/udp_service,  Up: Module List

Interface to Gd Graphics Library
********************************

NAME
====

   GD.pm - Interface to Gd Graphics Library

SYNOPSIS
========

     use GD;
     
     # create a new image
     $im = new GD::Image(100,100);

     # allocate some colors
     $white = $im->colorAllocate(255,255,255);
     $black = $im->colorAllocate(0,0,0);
     $red = $im->colorAllocate(255,0,0);
     $blue = $im->colorAllocate(0,0,255);

     # make the background transparent and interlaced
     $im->transparent($white);
     $im->interlaced('true');

     # Put a black frame around the picture
     $im->rectangle(0,0,99,99,$black);

     # Draw a blue oval
     $im->arc(50,50,95,75,0,360,$blue);

     # And fill it with red
     $im->fill(50,50,$red);

     # make sure we are writing to a binary stream
     binmode STDOUT;

     # Convert the image to PNG and print it on standard output
     print $im->png;

DESCRIPTION
===========

   *GD.pm* is a port of Thomas Boutell's gd graphics library (see below).
GD allows you to create color drawings using a large number of graphics
primitives, and emit the drawings as PNG files.

   GD defines the following three classes:

`GD::Image'
     An image class, which holds the image data and accepts graphic
     primitive method calls.

`GD::Font'
     A font class, which holds static font information and used for text
     rendering.

`GD::Polygon'
     A simple polygon object, used for storing lists of vertices prior to
     rendering a polygon into an image.

   A Simple Example:

     #!/usr/local/bin/perl

     use GD;
     
     # create a new image
     $im = new GD::Image(100,100);

     # allocate some colors
     $white = $im->colorAllocate(255,255,255);
     $black = $im->colorAllocate(0,0,0);
     $red = $im->colorAllocate(255,0,0);
     $blue = $im->colorAllocate(0,0,255);

     # make the background transparent and interlaced
     $im->transparent($white);
     $im->interlaced('true');

     # Put a black frame around the picture
     $im->rectangle(0,0,99,99,$black);

     # Draw a blue oval
     $im->arc(50,50,95,75,0,360,$blue);

     # And fill it with red
     $im->fill(50,50,$red);

     # make sure we are writing to a binary stream
     binmode STDOUT;

     # Convert the image to PNG and print it on standard output
     print $im->png;

   Notes:

  1. To create a new, empty image, send a new() message to GD::Image,
     passing it the width and height of the image you want to create.  An
     image object will be returned.  Other class methods allow you to
     initialize an image from a preexisting PNG, GD or XBM file.

  2. Next you will ordinarily add colors to the image's color table.
     colors are added using a colorAllocate() method call.  The three
     parameters in each call are the red, green and blue (rgb) triples for
     the desired color.  The method returns the index of that color in the
     image's color table.  You should store these indexes for later use.

  3. Now you can do some drawing!  The various graphics primitives are
     described below.  In this example, we do some text drawing, create an
     oval, and create and draw a polygon.

  4. Polygons are created with a new() message to GD::Polygon.  You can
     add points to the returned polygon one at a time using the addPt()
     method. The polygon can then be passed to an image for rendering.

  5. When you're done drawing, you can convert the image into PNG format
     by sending it a png() message.  It will return a (potentially large)
     scalar value containing the binary data for the image.  Ordinarily
     you will print it out at this point or write it to a file.  To ensure
     portability to platforms that differentiate between text and binary
     files, be sure to call binmode() on the file you are writing the
     image to.

Object Constructors: Creating Images
====================================

   The following class methods allow you to create new GD::Image objects.

*$image = GD::Image->new([$width,$height])*
*$image = GD::Image->new(*FILEHANDLE)*
*$image = GD::Image->new($filename)*
*$image = GD::Image->new($data)*
     The new() method is the main constructor for the GD::Image class.
     Called with two integer arguments, it creates a new blank image of the
     specified width and height. For example:

          $myImage = new GD::Image(100,100) || die;

     This will create an image that is 100 x 100 pixels wide.  If you don't
     specify the dimensions, a default of 64 x 64 will be chosen.

     Alternatively, you may create a GD::Image object based on an existing
     image by providing an open filehandle, a filename, or the image data
     itself.  The image formats automatically recognized and accepted are:
     PNG, JPEG, XPM and GD2.  Other formats, including GIF, WBMP, and GD
     version 1, cannot be recognized automatically at this time.

     If something goes wrong (e.g. insufficient memory), this call will
     return undef.

*$image = GD::Image->newFromPng($file)*
*$image = GD::Image->newFromPngData($data)*
     The newFromPng() method will create an image from a PNG file read in
     through the provided filehandle or file path.  The filehandle must
     previously have been opened on a valid PNG file or pipe.  If
     successful, this call will return an initialized image which you can
     then manipulate as you please.  If it fails, which usually happens if
     the thing at the other end of the filehandle is not a valid PNG file,
     the call returns undef.  Notice that the call doesn't automatically
     close the filehandle for you.  But it does call `binmode(FILEHANDLE)'
     for you, on platforms where this matters.

     You may use any of the following as the argument:

          1) a simple filehandle, such as STDIN
          2) a filehandle glob, such as *PNG
          3) a reference to a glob, such as \*PNG
          4) an IO::Handle object
          5) the pathname of a file

     In the latter case, newFromPng() will attempt to open the file for you
     and read the PNG information from it.

          Example1:

          open (PNG,"barnswallow.png") || die;
          $myImage = newFromPng GD::Image(\*PNG) || die;
          close PNG;

          Example2:
          $myImage = newFromPng GD::Image('barnswallow.png');

     To get information about the size and color usage of the information,
     you can call the image query methods described below.

     The newFromPngData() method will create a new GD::Image initialized
     with the PNG format data contained in $data.

*$image = GD::Image->newFromJpeg($file)*
*$image = GD::Image->newFromJpegData($data)*
     These methods will create an image from a JPEG file.  They work just
     like newFromPng() and newFromPngData(), and will accept the same
     filehandle and pathname arguments.

     Bear in mind that JPEG is a 24-bit format, while GD is 8-bit.  This
     means that photographic images will become posterized.

*$image = GD::Image->newFromXbm($file)*
     This works in exactly the same way as `newFromPng', but reads the
     contents of an X Bitmap (black & white) file:

          open (XBM,"coredump.xbm") || die;
          $myImage = newFromXbm GD::Image(\*XBM) || die;
          close XBM;

     There is no newFromXbmData() function, because there is no
     corresponding function in the gd library.

*$image = GD::Image->newFromWMP($file)*
     This creates a new GD::Image object starting from a WBMP-format file
     or filehandle.  There is currently no newFromWMPData() method.

*$image = GD::Image->newFromGd($file)*
*$image = GD::Image->newFromGdData($data)*
     These methods initialize a GD::Image from a Gd file, filehandle, or
     data.  Gd is Tom Boutell's disk-based storage format, intended for the
     rare case when you need to read and write the image to disk quickly.
     It's not intended for regular use, because, unlike PNG or JPEG, no
     image compression is performed and these files can become *BIG*.

          $myImage = newFromGd GD::Image("godzilla.gd") || die;
          close GDF;

*$image = GD::Image->newFromGd2($file)*
*$image = GD::Image->newFromGd2Data($data)*
     This works in exactly the same way as `newFromGd()' and
     newFromGdData, but use the new compressed GD2 image format.

*$image = GD::Image->newFromGd2Part($file,srcX,srcY,width,height)*
     This class method allows you to read in just a portion of a GD2 image
     file.  In additionto a filehandle, it accepts the top-left corner and
     dimensions (width,height) of the region of the image to read.  For
     example:

          open (GDF,"godzilla.gd2") || die;
          $myImage = GD::Image->newFromGd2Part(\*GDF,10,20,100,100) || die;
          close GDF;

     This reads a 100x100 square portion of the image starting from
     position (10,20).

*$image = GD::Image->newFromXpm($filename)*
     This creates a new GD::Image object starting from a filename.  This
     is unlike the other newFrom() functions because it does not take a
     filehandle.  This difference comes from an inconsistency in the
     underlying gd library.

          $myImage = newFromXpm GD::Image('earth.xpm') || die;

     This function is only available if libgd was compiled with XPM
     support.

     NOTE: The libgd library is unable to read certain XPM files, returning
     an all-black image instead.

GD::Image Methods
=================

   Once a GD::Image object is created, you can draw with it, copy it, and
merge two images.  When you are finished manipulating the object, you can
convert it into a standard image file format to output or save to a file.

Image Data Output Methods
-------------------------

   The following methods convert the internal drawing format into standard
output file formats.

*$pngdata = $image->png*
     This returns the image data in PNG format.  You can then print it,
     pipe it to a display program, or write it to a file.  Example:

          $png_data = $myImage->png;
          open (DISPLAY,"| display -") || die;
          binmode DISPLAY;
          print DISPLAY $png_data;
          close DISPLAY;

     Note the use of binmode().  This is crucial for portability to DOSish
     platforms.

*$jpegdata = $image->jpeg([$quality])*
     This returns the image data in JPEG format.  You can then print it,
     pipe it to a display program, or write it to a file.  You may pass an
     optional quality score to jpeg() in order to control the JPEG quality.
     This should be an integer between 0 and 100.  Higher quality scores
     give larger files and better image quality.  If you don't specify the
     quality, jpeg() will choose a good default.

*$gddata = $image->gd*
     This returns the image data in GD format.  You can then print it,
     pipe it to a display program, or write it to a file.  Example:

          binmode MYOUTFILE;
          print MYOUTFILE $myImage->gd;

*$gd2data = $image->gd2*
     Same as gd(), except that it returns the data in compressed GD2
     format.

*$wbmpdata = $image->wbmp([$foreground])*
     This returns the image data in WBMP format, which is a black-and-white
     image format.  Provide the index of the color to become the foreground
     color.  All other pixels will be considered background.

Color Control
-------------

   These methods allow you to control and manipulate the GD::Image color
table.

*$index = $image->colorAllocate(red,green,blue)*
     This allocates a color with the specified red, green and blue
     components and returns its index in the color table, if specified.
     The first color allocated in this way becomes the image's background
     color.  (255,255,255) is white (all pixels on).  (0,0,0) is black (all
     pixels off).  (255,0,0) is fully saturated red.  (127,127,127) is 50%
     gray.  You can find plenty of examples in /usr/X11/lib/X11/rgb.txt.

     If no colors are allocated, then this function returns -1.

     Example:

          $white = $myImage->colorAllocate(0,0,0); #background color
          $black = $myImage->colorAllocate(255,255,255);
          $peachpuff = $myImage->colorAllocate(255,218,185);

*$image->colorDeallocate(colorIndex)*
     This marks the color at the specified index as being ripe for
     reallocation.  The next time colorAllocate is used, this entry will be
     replaced.  You can call this method several times to deallocate
     multiple colors.  There's no function result from this call.

     Example:

          $myImage->colorDeallocate($peachpuff);
          $peachy = $myImage->colorAllocate(255,210,185);

*$index = $image->colorClosest(red,green,blue)*
     This returns the index of the color closest in the color table to the
     red green and blue components specified.  If no colors have yet been
     allocated, then this call returns -1.

     Example:

          $apricot = $myImage->colorClosest(255,200,180);

*$index = $image->colorExact(red,green,blue)*
     This returns the index of a color that exactly matches the specified
     red green and blue components.  If such a color is not in the color
     table, this call returns -1.

          $rosey = $myImage->colorExact(255,100,80);
          warn "Everything's coming up roses.\n" if $rosey >= 0;

*$index = $image->colorResolve(red,green,blue)*
     This returns the index of a color that exactly matches the specified
     red green and blue components.  If such a color is not in the color
     table and there is room, then this method allocates the color in the
     color table and returns its index.

          $rosey = $myImage->colorResolve(255,100,80);
          warn "Everything's coming up roses.\n" if $rosey >= 0;

*$colorsTotal = $image->colorsTotal)* *object method*
     This returns the total number of colors allocated in the object.

          $maxColors = $myImage->colorsTotal;

*$index = $image->getPixel(x,y)* *object method*
     This returns the color table index underneath the specified point.
     It can be combined with rgb() to obtain the rgb color underneath the
     pixel.

     Example:

          $index = $myImage->getPixel(20,100);
          ($r,$g,$b) = $myImage->rgb($index);

*($red,$green,$blue) = $image->rgb($index)*
     This returns a list containing the red, green and blue components of
     the specified color index.

     Example:

          @RGB = $myImage->rgb($peachy);

*$image->transparent($colorIndex)*
     This marks the color at the specified index as being transparent.
     Portions of the image drawn in this color will be invisible.  This is
     useful for creating paintbrushes of odd shapes, as well as for making
     PNG backgrounds transparent for displaying on the Web.  Only one
     color can be transparent at any time. To disable transparency,
     specify -1 for the index.

     If you call this method without any parameters, it will return the
     current index of the transparent color, or -1 if none.

     Example:

          open(PNG,"test.png");
          $im = newFromPng GD::Image(PNG);
          $white = $im->colorClosest(255,255,255); # find white
          $im->transparent($white);
          binmode STDOUT;
          print $im->png;

Special Colors
--------------

   GD implements a number of special colors that can be used to achieve
special effects.  They are constants defined in the GD:: namespace, but
automatically exported into your namespace when the GD module is loaded.

*$image->setBrush($image)*
     You can draw lines and shapes using a brush pattern.  Brushes are just
     images that you can create and manipulate in the usual way. When you
     draw with them, their contents are used for the color and shape of the
     lines.

     To make a brushed line, you must create or load the brush first, then
     assign it to the image using setBrush().  You can then draw in that
     with that brush using the *gdBrushed* special color.  It's often
     useful to set the background of the brush to transparent so that the
     non-colored parts don't overwrite other parts of your image.

     Example:

          # Create a brush at an angle
          $diagonal_brush = new GD::Image(5,5);
          $white = $diagonal_brush->allocateColor(255,255,255);
          $black = $diagonal_brush->allocateColor(0,0,0);
          $diagonal_brush->transparent($white);
          $diagonal_brush->line(0,4,4,0,$black); # NE diagonal

          # Set the brush
          $myImage->setBrush($diagonal_brush);
          
          # Draw a circle using the brush
          $myImage->arc(50,50,25,25,0,360,gdBrushed);

*$image->setStyle(@colors)*
     Styled lines consist of an arbitrary series of repeated colors and are
     useful for generating dotted and dashed lines.  To create a styled
     line, use setStyle() to specify a repeating series of colors.  It
     accepts an array consisting of one or more color indexes.  Then draw
     using the gdStyled special color.  Another special color,
     *gdTransparent* can be used to introduce holes in the line, as the
     example shows.

     Example:

          # Set a style consisting of 4 pixels of yellow,
          # 4 pixels of blue, and a 2 pixel gap
          $myImage->setStyle($yellow,$yellow,$yellow,$yellow,
          		   $blue,$blue,$blue,$blue,
          		   gdTransparent,gdTransparent);
          $myImage->arc(50,50,25,25,0,360,gdStyled);

     To combine the gdStyled and `gdBrushed' behaviors, you can specify
     `gdStyledBrushed'.  In this case, a pixel from the current brush
     pattern is rendered wherever the color specified in setStyle() is
     neither gdTransparent nor 0.

gdTiled
     Draw filled shapes and flood fills using a pattern.  The pattern is
     just another image.  The image will be tiled multiple times in order
     to fill the required space, creating wallpaper effects.  You must call
     `setTile' in order to define the particular tile pattern you'll use
     for drawing when you specify the gdTiled color.  details.

gdStyled
     The gdStyled color is used for creating dashed and dotted lines.  A
     styled line can contain any series of colors and is created using the
     setStyled() command.

Drawing Commands
----------------

   These methods allow you to draw lines, rectangles, and elipses, as well
as to perform various special operations like flood-fill.

*$image->setPixel($x,$y,$color)*
     This sets the pixel at (x,y) to the specified color index.  No value
     is returned from this method.  The coordinate system starts at the
     upper left at (0,0) and gets larger as you go down and to the right.
     You can use a real color, or one of the special colors gdBrushed,
     gdStyled and gdStyledBrushed can be specified.

     Example:

          # This assumes $peach already allocated
          $myImage->setPixel(50,50,$peach);

*$image->line($x1,$y1,$x2,$y2,$color)*
     This draws a line from (x1,y1) to (x2,y2) of the specified color.  You
     can use a real color, or one of the special colors gdBrushed,
     gdStyled and gdStyledBrushed.

     Example:

          # Draw a diagonal line using the currently defind
          # paintbrush pattern.
          $myImage->line(0,0,150,150,gdBrushed);

*$image->dashedLine($x1,$y1,$x2,$y2,$color)*
     This draws a dashed line from (x1,y1) to (x2,y2) in the specified
     color.  A more powerful way to generate arbitrary dashed and dotted
     lines is to use the setStyle() method described below and to draw with
     the special color gdStyled.

     Example:

          $myImage->dashedLine(0,0,150,150,$blue);

GD::Image::rectangle($x1,$y1,$x2,$y2,$color)
     This draws a rectangle with the specified color.  (x1,y1) and (x2,y2)
     are the upper left and lower right corners respectively.  Both real
     color indexes and the special colors gdBrushed, gdStyled and
     gdStyledBrushed are accepted.

     Example:

          $myImage->rectangle(10,10,100,100,$rose);

*$image->filledRectangle($x1,$y1,$x2,$y2,$color)*
     This draws a rectangle filed with the specified color.  You can use a
     real color, or the special fill color gdTiled to fill the polygon
     with a pattern.

     Example:

          # read in a fill pattern and set it
          $tile = newFromPng GD::Image('happyface.png');
          $myImage->setTile($tile);

          # draw the rectangle, filling it with the pattern
          $myImage->filledRectangle(10,10,150,200,gdTiled);

*$image->polygon($polygon,$color)*
     This draws a polygon with the specified color.  The polygon must be
     created first (see below).  The polygon must have at least three
     vertices.  If the last vertex doesn't close the polygon, the method
     will close it for you.  Both real color indexes and the special
     colors gdBrushed, gdStyled and gdStyledBrushed can be specified.

     Example:

          $poly = new GD::Polygon;
          $poly->addPt(50,0);
          $poly->addPt(99,99);
          $poly->addPt(0,99);
          $myImage->polygon($poly,$blue);

*$image->filledPolygon($poly,$color)*
     This draws a polygon filled with the specified color.  You can use a
     real color, or the special fill color gdTiled to fill the polygon
     with a pattern.

     Example:

          # make a polygon
          $poly = new GD::Polygon;
          $poly->addPt(50,0);
          $poly->addPt(99,99);
          $poly->addPt(0,99);

          # draw the polygon, filling it with a color
          $myImage->filledPolygon($poly,$peachpuff);

*$image->arc($cx,$cy,$width,$height,$start,$end,$color)*
     This draws arcs and ellipses.  (cx,cy) are the center of the arc, and
     (width,height) specify the width and height, respectively.  The
     portion of the ellipse covered by the arc are controlled by start and
     end, both of which are given in degrees from 0 to 360.  Zero is at the
     top of the ellipse, and angles increase clockwise.  To specify a
     complete ellipse, use 0 and 360 as the starting and ending angles.  To
     draw a circle, use the same value for width and height.

     You can specify a normal color or one of the special colors
     *gdBrushed*, gdStyled, or *gdStyledBrushed*.

     Example:

          # draw a semicircle centered at 100,100
          $myImage->arc(100,100,50,50,0,180,$blue);

*$image->fill($x,$y,$color)*
     This method flood-fills regions with the specified color.  The color
     will spread through the image, starting at point (x,y), until it is
     stopped by a pixel of a different color from the starting pixel (this
     is similar to the "paintbucket" in many popular drawing toys).  You
     can specify a normal color, or the special color gdTiled, to
     flood-fill with patterns.

     Example:

          # Draw a rectangle, and then make its interior blue
          $myImage->rectangle(10,10,100,100,$black);
          $myImage->fill(50,50,$blue);

*$image->fillToBorder($x,$y,$bordercolor,$color)*
     Like fill, this method flood-fills regions with the specified color,
     starting at position (x,y).  However, instead of stopping when it
     hits a pixel of a different color than the starting pixel, flooding
     will only stop when it hits the color specified by bordercolor.  You
     must specify a normal indexed color for the bordercolor.  However, you
     are free to use the gdTiled color for the fill.

     Example:

          # This has the same effect as the previous example
          $myImage->rectangle(10,10,100,100,$black);
          $myImage->fillToBorder(50,50,$black,$blue);

Image Copying Commands
----------------------

   Two methods are provided for copying a rectangular region from one
image to another.  One method copies a region without resizing it.  The
other allows you to stretch the region during the copy operation.

   With either of these methods it is important to know that the routines
will attempt to flesh out the destination image's color table to match the
colors that are being copied from the source.  If the destination's color
table is already full, then the routines will attempt to find the best
match, with varying results.

*$image->copy($sourceImage,$dstX,$dstY,$srcX,$srcY,$width,$height)*
     This is the simplest of the several copy operations, copying the
     specified region from the source image to the destination image (the
     one performing the method call).  (srcX,srcY) specify the upper left
     corner of a rectangle in the source image, and (width,height) give the
     width and height of the region to copy.  (dstX,dstY) control where in
     the destination image to stamp the copy.  You can use the same image
     for both the source and the destination, but the source and
     destination regions must not overlap or strange things will happen.

     Example:

          $myImage = new GD::Image(100,100);
          ... various drawing stuff ...
          $srcImage = new GD::Image(50,50);
          ... more drawing stuff ...
          # copy a 25x25 pixel region from $srcImage to
          # the rectangle starting at (10,10) in $myImage
          $myImage->copy($srcImage,10,10,0,0,25,25);

*$image->clone()*
     Make a copy of the image and return it as a new object.  The new image
     will look identical.  However, it may differ in the size of the color
     palette and other nonessential details.

     Example:

          $myImage = new GD::Image(100,100);
          ... various drawing stuff ...
                  $copy = $myImage->clone;

*$image->copyMerge($sourceImage,$dstX,$dstY,$srcX,$srcY,$width,$height,$percent)*
     This copies the indicated rectangle from the source image to the
     destination image, merging the colors to the extent specified by
     percent (an integer between 0 and 100).  Specifying 100% has the same
     effect as copy() - replacing the destination pixels with the source
     image.  This is most useful for highlighting an area by merging in a
     solid rectangle.

     Example:

          $myImage = new GD::Image(100,100);
          ... various drawing stuff ...
          $redImage = new GD::Image(50,50);
          ... more drawing stuff ...
          # copy a 25x25 pixel region from $srcImage to
          # the rectangle starting at (10,10) in $myImage, merging 50%
          $myImage->copyMerge($srcImage,10,10,0,0,25,25,50);

*$image->copyMergeGray($sourceImage,$dstX,$dstY,$srcX,$srcY,$width,$height,$percent)*
     This is identical to copyMerge() except that it preserves the hue of
     the source by converting all the pixels of the destination rectangle
     to grayscale before merging.

*$image->copyResized($sourceImage,$dstX,$dstY,$srcX,$srcY,$destW,$destH,$srcW,$srcH)*
     This method is similar to copy() but allows you to choose different
     sizes for the source and destination rectangles.  The source and
     destination rectangle's are specified independently by (srcW,srcH) and
     (destW,destH) respectively.  copyResized() will stretch or shrink the
     image to accomodate the size requirements.

     Example:

          $myImage = new GD::Image(100,100);
          ... various drawing stuff ...
          $srcImage = new GD::Image(50,50);
          ... more drawing stuff ...
          # copy a 25x25 pixel region from $srcImage to
          # a larger rectangle starting at (10,10) in $myImage
          $myImage->copyResized($srcImage,10,10,0,0,50,50,25,25);

Character and String Drawing
----------------------------

   Gd allows you to draw characters and strings, either in normal
horizontal orientation or rotated 90 degrees.  These routines use a
GD::Font object, described in more detail below.  There are four built-in
fonts, available in global variables gdGiantFont, gdLargeFont,
gdMediumBoldFont, gdSmallFont and gdTinyFont.  Currently there is no way
of dynamically creating your own fonts.

*$image->string($font,$x,$y,$string,$color)*
     This method draws a string startin at position (x,y) in the specified
     font and color.  Your choices of fonts are gdSmallFont,
     gdMediumBoldFont, gdTinyFont, gdLargeFont and gdGiantFont.

     Example:

          $myImage->string(gdSmallFont,2,10,"Peachy Keen",$peach);

*$image->stringUp($font,$x,$y,$string,$color)*
     Just like the previous call, but draws the text rotated
     counterclockwise 90 degrees.

*$image->char($font,$x,$y,$char,$color)*
*$image->charUp($font,$x,$y,$char,$color)*
     These methods draw single characters at position (x,y) in the
     specified font and color.  They're carry-overs from the C interface,
     where there is a distinction between characters and strings.  Perl is
     insensible to such subtle distinctions.

*@bounds = $image->stringTTF($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)*
*@bounds = GD::Image->stringTTF($fgcolor,$fontname,$ptsize,$angle,$x,$y,$string)*
     This method uses TrueType to draw a scaled, antialiased string using
     the TrueType vector font of your choice.  It requires that libgd to
     have been compiled with TrueType support, and for the appropriate
     TrueType font to be installed on your system.

     The arguments are as follows:

          fgcolor    Color index to draw the string in
          fontname   An absolute or relative path to the TrueType (.ttf) font file
          ptsize     The desired point size (may be fractional)
          angle      The rotation angle, in radians
          x,y        X and Y coordinates to start drawing the string
          string     The string itself

     If successful, the method returns an eight-element list giving the
     boundaries of the rendered string:

          @bounds[0,1]  Lower left corner (x,y)
          @bounds[2,3]  Lower right corner (x,y)
          @bounds[4,5]  Upper right corner (x,y)
          @bounds[6,7]  Upper left corner (x,y)

     In case of an error (such as the font not being available, or TTF
     support not being available), the method returns an empty list and
     sets $@ to the error message.

     You may also call this method from the GD::Image class name, in which
     case it doesn't do any actual drawing, but returns the bounding box
     using an inexpensive operation.  You can use this to perform layout
     operations prior to drawing.

Miscellaneous Image Methods
---------------------------

   These are various utility methods that are useful in some circumstances.

*$image->interlaced([$flag])*
     This method sets or queries the image's interlaced setting.  Interlace
     produces a cool venetian blinds effect on certain viewers.  Provide a
     true parameter to set the interlace attribute.  Provide undef to
     disable it.  Call the method without parameters to find out the
     current setting.

*($width,$height) = $image->getBounds()*
     This method will return a two-member list containing the width and
     height of the image.  You query but not not change the size of the
     image once it's created.

*$flag = $image1->compare($image2)*
     Compare two images and return a bitmap describing the differenes
     found, if any.  The return value must be logically ANDed with one or
     more constants in order to determine the differences.  The following
     constants are available:

          GD_CMP_IMAGE             The two images look different
          GD_CMP_NUM_COLORS        The two images have different numbers of colors
          GD_CMP_COLOR             The two images' palettes differ
          GD_CMP_SIZE_X            The two images differ in the horizontal dimension
          GD_CMP_SIZE_Y            The two images differ in the vertical dimension
          GD_CMP_TRANSPARENT       The two images have different transparency
          GD_CMP_BACKGROUND        The two images have different background colors
          GD_CMP_INTERLACE         The two images differ in their interlace

     The most important of these is GD_CMP_IMAGE, which will tell you
     whether the two images will look different, ignoring differences in
     the order of colors in the color palette and other invisible changes.
     The constants are not imported by default, but must be imported
     individually or by importing the :cmp tag.  Example:

          use GD qw(:DEFAULT :cmp);
          # get $image1 from somewhere
          # get $image2 from somewhere
          if ($image1->compare($image2) & GD_CMP_IMAGE) {
             warn "images differ!";
          }

Polygons
========

   A few primitive polygon creation and manipulation methods are provided.
They aren't part of the Gd library, but I thought they might be handy to
have around (they're borrowed from my qd.pl Quickdraw library).

*$poly = GD::Polygon->new*
     Create an empty polygon with no vertices.

          $poly = new GD::Polygon;

*$poly->addPt($x,$y)*
     Add point (x,y) to the polygon.

          $poly->addPt(0,0);
          $poly->addPt(0,50);
          $poly->addPt(25,25);
          $myImage->fillPoly($poly,$blue);

*($x,$y) = $poly->getPt($index)*
     Retrieve the point at the specified vertex.

          ($x,$y) = $poly->getPt(2);

*$poly->setPt($index,$x,$y)*
     Change the value of an already existing vertex.  It is an error to set
     a vertex that isn't already defined.

          $poly->setPt(2,100,100);

*($x,$y) = $poly->deletePt($index)*
     Delete the specified vertex, returning its value.

          ($x,$y) = $poly->deletePt(1);

*$poly->toPt($dx,$dy)*
     Draw from current vertex to a new vertex, using relative (dx,dy)
     coordinates.  If this is the first point, act like addPt().

          $poly->addPt(0,0);
          $poly->toPt(0,50);
          $poly->toPt(25,-25);
          $myImage->fillPoly($poly,$blue);

*$vertex_count = $poly->length*
     Return the number of vertices in the polygon.

          $points = $poly->length;

*@vertices = $poly->vertices*
     Return a list of all the verticies in the polygon object.  Each member
     of the list is a reference to an (x,y) array.

          @vertices = $poly->vertices;
          foreach $v (@vertices)
             print join(",",@$v),"\n";
          }

*@rect = $poly->bounds*
     Return the smallest rectangle that completely encloses the polygon.
     The return value is an array containing the (left,top,right,bottom) of
     the rectangle.

          ($left,$top,$right,$bottom) = $poly->bounds;

*$poly->offset($dx,$dy)*
     Offset all the vertices of the polygon by the specified horizontal
     (dh) and vertical (dy) amounts.  Positive numbers move the polygon
     down and to the right.

          $poly->offset(10,30);

*$poly->map($srcL,$srcT,$srcR,$srcB,$destL,$dstT,$dstR,$dstB)*
     Map the polygon from a source rectangle to an equivalent position in a
     destination rectangle, moving it and resizing it as necessary.  See
     polys.pl for an example of how this works.  Both the source and
     destination rectangles are given in (left,top,right,bottom)
     coordinates.  For convenience, you can use the polygon's own bounding
     box as the source rectangle.

          # Make the polygon really tall
          $poly->map($poly->bounds,0,0,50,200);

*$poly->scale($sx,$sy)*
     Scale each vertex of the polygon by the X and Y factors indicated by
     sx and sy.  For example scale(2,2) will make the polygon twice as
     large.  For best results, move the center of the polygon to position
     (0,0) before you scale, then move it back to its previous position.

*$poly->transform($sx,$rx,$sy,$ry,$tx,$ty)*
     Run each vertex of the polygon through a transformation matrix, where
     sx and sy are the X and Y scaling factors, rx and ry are the X and Y
     rotation factors, and tx and ty are X and Y offsets.  See the Adobe
     PostScript Reference, page 154 for a full explanation, or experiment.

Font Utilities
==============

   The libgd library (used by the Perl GD library) has built-in support
for about half a dozen fonts, which were converted from public-domain X
Windows fonts.  For more fonts, compile libgd with TrueType support and
use the stringTTF() call.

   If you wish to add more built-in fonts, the directory bdf_scripts
contains two contributed utilities that may help you convert X-Windows
BDF-format fonts into the format that libgd uses internally.  However
these scripts were written for earlier versions of GD which included its
own mini-gd library.  These scripts will have to be adapted for use with
libgd, and the libgd library itself will have to be recompiled and linked!
Please do not contact me for help with these scripts: they are
unsupported.

   Each of these fonts is available both as an imported global (e.g.
gdSmallFont) and as a package method (e.g. *GD::Font->Small*).

gdSmallFont
*GD::Font->Small*
     This is the basic small font, "borrowed" from a well known public
     domain 6x12 font.

gdLargeFont
*GD::Font->Large*
     This is the basic large font, "borrowed" from a well known public
     domain 8x16 font.

gdMediumBoldFont
*GD::Font->MediumBold*
     This is a bold font intermediate in size between the small and large
     fonts, borrowed from a public domain 7x13 font;

gdTinyFont
*GD::Font->Tiny*
     This is a tiny, almost unreadable font, 5x8 pixels wide.

gdGiantFont
*GD::Font->Giant*
     This is a 9x15 bold font converted by Jan Pazdziora from a sans serif
     X11 font.

*$font->nchars*
     This returns the number of characters in the font.

          print "The large font contains ",gdLargeFont->nchars," characters\n";

*$font->offset*
     This returns the ASCII value of the first character in the font

*$width = $font->width*
*$height = $font->height*
height
     These return the width and height of the font.

          ($w,$h) = (gdLargeFont->width,gdLargeFont->height);

Obtaining the C-language version of gd
======================================

   libgd, the C-language version of gd, can be obtained at URL
http://www.boutell.com/gd/.  Directions for installing and using it can be
found at that site.  Please do not contact me for help with libgd.

AUTHOR
======

   The GD.pm interface is copyright 1995-2000, Lincoln D. Stein.  It is
distributed under the same terms as Perl itself.  See the "Artistic
License" in the Perl source code distribution for licensing terms.

   The latest versions of GD.pm are available at

     http://stein.cshl.org/WWW/software/GD

SEE ALSO
========

   Image::Magick


