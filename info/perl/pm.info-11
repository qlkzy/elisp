This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Ace/Local,  Next: Ace/Model,  Prev: Ace/Iterator,  Up: Module List

use giface, tace or gifaceclient to open a local connection to an Ace database
******************************************************************************

NAME
====

   Ace::Local - use giface, tace or gifaceclient to open a local
connection to an Ace database

SYNOPSIS
========

     use Ace::Local
     my $ace = Ace::Local->connect(-path=>'/usr/local/acedb/elegans');
     $ace->query('find author Se*');
     die "Query unsuccessful" unless $ace->status;
     $ace->query('show');
     while ($ace->encore) {
       print $ace->read;
     }

DESCRIPTION
===========

   This class is provided for low-level access to local (non-networked)
Ace databases via the *giface* program.  You will generally not need to
access it directly.  Use Ace.pm instead.

   For the sake of completeness, the method can also use the *aceclient*
program for its access.  However the Ace::AceDB class is more efficient
for this purpose.

METHODS
=======

connect()
---------

     $accessor = Ace::Local->connect(-path=>$path_to_database);

   Connect to the database at the indicated path using *giface* and return
a connection object (an "accessor").  *Giface* must be on the current
search path.  Multiple accessors may be open simultaneously.

   Arguments include:

*-path*
     Path to the database (location of the "wspec/" directory).

*-program*
     Used to indicate the location of the desired *giface* or
     *gifaceclient* executable.  You may also use *tace* or *aceclient*,
     but in that case the asGIF() functionality will nog work.  Can be used
     to override the search path.

*-host*
     Used when invoking *gifaceclient*.  Indicates the host to connect to.

*-port*
     Used when invoking *gifaceclient*.  Indicates the port to connect to.

*-nosync*
     Ordinarily Ace::Local synchronizes with the tace/giface prompt,
     throwing out all warnings and copyright messages.  If this is set,
     Ace::Local will not do so.  In this case you must call the low_read()
     method until it returns undef in order to synchronize.

query()
-------

     $status = $accessor->query('query string');

   Send the query string to the server and return a true value if
successful.  You must then call read() repeatedly in order to fetch the
query result.

read()
------

   Read the result from the last query sent to the server and return it as
a string.  ACE may return the result in pieces, breaking between whole
objects.  You may need to read repeatedly in order to fetch the entire
result.  Canonical example:

     $accessor->query("find Sequence D*");
     die "Got an error ",$accessor->error() if $accessor->status == STATUS_ERROR;
     while ($accessor->status == STATUS_PENDING) {
        $result .= $accessor->read;
     }

low_read()
----------

   Read whatever data's available, or undef if none.  This is only used by
the ace.pl replacement for giface/tace.

status()
--------

   Return the status code from the last operation.  Status codes are
exported by default when you use Ace.pm.  The status codes you may see are:

     STATUS_WAITING    The server is waiting for a query.
     STATUS_PENDING    A query has been sent and Ace is waiting for
                       you to read() the result.
     STATUS_ERROR      A communications or syntax error has occurred

error()
-------

   May return a more detailed error code supplied by Ace.  Error checking
is not fully implemented.

encore()
--------

   This method will return true after you have performed one or more
read() operations, and indicates that there is more data to read.
encore() is functionally equivalent to:

     $encore = $accessor->status == STATUS_PENDING;

   In fact, this is how it's implemented.

auto_save()
-----------

   Sets or queries the *auto_save* variable.  If true, the "save" command
will be issued automatically before the connection to the database is
severed.  The default is true.

   Examples:

     $accessor->auto_save(1);
     $flag = $accessor->auto_save;

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Object: Ace/Object,, *Note Ace/Iterator:
Ace/Iterator,, *Note Ace/Model: Ace/Model,

AUTHOR
======

   Lincoln Stein <lstein@w3.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1997-1998, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Ace/Model,  Next: Ace/Object,  Prev: Ace/Local,  Up: Module List

Get information about AceDB models
**********************************

NAME
====

   Ace::Model - Get information about AceDB models

SYNOPSIS
========

     use Ace;
     my $db = Ace->connect(-path=>'/usr/local/acedb/elegans');
     my $model = $db->model('Author');
     print $model;
     $name = $model->name;
     @tags = $model->tags;
     print "Paper is a valid tag" if $model->valid_tag('Paper');

DESCRIPTION
===========

   This class is provided for access to AceDB class models.  It provides
the model in human-readable form, and does some limited but useful parsing
on your behalf.

   Ace::Model objects are obtained either by calling an Ace database
handle's model() method to retrieve the model of a named class, or by
calling an Ace::Object's model() method to retrieve the object's
particular model.

METHODS
=======

new()
-----

     $model = Ace::Model->new($model_data);

   This is a constructor intended only for use by Ace and Ace::Object
classes.  It constructs a new Ace::Model object from the raw string data
in models.wrm.

name()
------

     $name = $model->name;

   This returns the class name for the model.

tags()
------

     @tags = $model->tags;

   This returns a list of all the valid tags in the model.

valid_tag()
-----------

     $boolean  = $model->valid_tag($tag);

   This returns true if the given tag is part of the model.

path()        @path = $model->path($tag)
----------------------------------------

   Returns the path to the indicated tag, returning a list of intermediate
tags.  For example, in the C elegans ?Locus model, the path for
'Compelementation_data" will return the list ('Type','Gene').

asString()
----------

     print $model->asString;

   asString() returns the human-readable representation of the model with
comments stripped out.  Internally this method is called to automatically
convert the model into a string when appropriate.  You need only to start
performing string operations on the model object in order to convert it
into a string automatically:

     print "Paper is unique" if $model=~/Paper ?Paper UNIQUE/;

SEE ALSO
========

   *Note Ace: Ace,

AUTHOR
======

   Lincoln Stein <lstein@w3.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1997-1998, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Ace/Object,  Next: Ace/Sequence,  Prev: Ace/Model,  Up: Module List

Manipulate  Ace Data Objects
****************************

NAME
====

   Ace::Object - Manipulate  Ace Data Objects

SYNOPSIS
========

     # open database connection and get an object
     use Ace;
     $db = Ace->connect(-host => 'beta.crbm.cnrs-mop.fr',
                        -port => 20000100);
     $sequence  = $db->fetch(Sequence => 'D12345');
     
     # Inspect the object
     $r    = $sequence->at('Visible.Overlap_Right');
     @row  = $sequence->row;
     @col  = $sequence->col;
     @tags = $sequence->tags;
     
     # Explore object substructure
     @more_tags = $sequence->at('Visible')->tags;
     @col       = $sequence->at("Visible.$more_tags[1]")->col;

     # Follow a pointer into database
     $r     = $sequence->at('Visible.Overlap_Right')->fetch;
     $next  = $r->at('Visible.Overlap_left')->fetch;

     # Classy way to do the same thing
     $r     = $sequence->Overlap_right;
     $next  = $sequence->Overlap_left;

     # Pretty-print object
     print $sequence->asString;
     print $sequence->asTabs;
     print $sequence->asHTML;

     # Update object
     $sequence->replace('Visible.Overlap_Right',$r,'M55555');
     $sequence->add('Visible.Homology','GR91198');
     $sequence->delete('Source.Clone','MBR122');
     $sequence->commit();

     # Rollback changes
     $sequence->rollback()

     # Get errors
     print $sequence->error;

DESCRIPTION
===========

   *Ace::Object* is the base class for objects returned from ACEDB
databases. Currently there is only one type of *Ace::Object*, but this may
change in the future to support more interesting object-specific behaviors.

   Using the *Ace::Object* interface, you can explore the internal
structure of an *Ace::Object*, retrieve its content, and convert it into
various types of text representation.  You can also fetch a representation
of any object as a GIF image.

   If you have write access to the databases, add new data to an object,
replace existing data, or kill it entirely.  You can also create a new
object de novo and write it into the database.

   For information on connecting to ACEDB databases and querying them, see
*Note Ace: Ace,.

ACEDB::OBJECT METHODS
=====================

   The structure of an Ace::Object is very similar to that of an Acedb
object.  It is a tree structure like this one (an Author object):

     Thierry-Mieg J->Full_name ->Jean Thierry-Mieg
                      |
                     Laboratory->FF
                      |
                     Address->Mail->CRBM duCNRS
                      |        |     |
                      |        |    BP 5051
                      |        |     |
                      |        |    34033 Montpellier
                      |        |     |
                      |        |    FRANCE
                      |        |
                      |       E_mail->mieg@kaa.cnrs-mop.fr
                      |        |
                      |       Phone ->33-67-613324
                      |        |
                      |       Fax   ->33-67-521559
                      |
                     Paper->The C. elegans sequencing project
                             |
                            Genome Project Database
                             |
                            Genome Sequencing
                             |
                             How to get ACEDB for your Sun
                             |
                            ACEDB is Hungry

   Each object in the tree has two pointers, a "right" pointer to the node
on its right, and a "down" pointer to the node beneath it.  Right pointers
are used to store hierarchical relationships, such as
Address->Mail->E_mail, while down pointers are used to store lists, such
as the multiple papers written by the Author.

   Each node in the tree has a type and a name.  Types include integers,
strings, text, floating point numbers, as well as specialized biological
types, such as "dna" and "peptide."  Another fundamental type is "tag,"
which is a text identifier used to label portions of the tree.  Examples
of tags include "Paper" and "Laboratory" in the example above.

   In addition to these built-in types, there are constructed types known
as classes.  These types are specified by the data model.  In the above
example, "Thierry-Mieg J" is an object of the "Author" class, and "Genome
Project Database" is an object of the "Paper" class.  An interesting
feature of objects is that you can follow them into the database,
retrieving further information.  For example, after retrieving the "Genome
Project Database" Paper from the Author object, you could fetch more
information about it, either by following *its* right pointer, or by using
one of the specialized navigation routines described below.

new() method
------------

     $object = new Ace::Object($class,$name,$database);
     $object = new Ace::Object(-class=>$class,
                               -name=>$name,
                               -db=>database);

   You can create a new Ace::Object from scratch by calling the new()
routine with the object's class, its identifier and a handle to the
database to create it in.  The object won't actually be created in the
database until you add() one or more tags to it and commit() it (see
below).  If you do not provide a database handle, the object will be
created in memory only.

   Arguments can be passed positionally, or as named parameters, as shown
above.

   This routine is usually used internally.  See also add_row(),
add_tree(), delete() and replace() for ways to manipulate this object.

name() method
-------------

     $name = $object->name();

   Return the name of the Ace::Object.  This happens automatically
whenever you use the object in a context that requires a string or a
number.  For example:

     $object = $db->fetch(Author,"Thierry-Mieg J");
     print "$object did not write 'Pride and Prejudice.'\n";

class() method
--------------

     $class = $object->class();

   Return the class of the object.  The return value may be one of
"float," "int," "date," "tag," "txt," "dna," "peptide," and "scalar."
(The last is used internally by Perl to represent objects created
programatically prior to committing them to the database.)  The class may
also be a user-constructed type such as Sequence, Clone or Author.  These
user-constructed types usually have an initial capital letter.

db() method
-----------

     $db = $object->db();

   Return the database that the object is associated with.

isClass() method
----------------

     $bool = $object->isClass();

   Returns true if the object is a class (can be fetched from the
database).

isTag() method
--------------

     $bool = $object->isTag();

   Returns true if the object is a tag.

tags() method
-------------

     @tags = $object->tags();

   Return all the top-level tags in the object as a list.  In the Author
example above, the returned list would be
('Full_name','Laboratory','Address','Paper').

   You can fetch tags more deeply nested in the structure by navigating
inwards using the methods listed below.

right() and down() methods
--------------------------

     $subtree = $object->right;
     $subtree = $object->right($position);
     $subtree = $object->down;
     $subtree = $object->down($position);

   *right()* and *down()* provide a low-level way of traversing the tree
structure by following the tree's right and down pointers.  Called without
any arguments, these two methods will move one step.  Called with a
numeric argument >= 0 they will move the indicated number of steps (zero
indicates no movement).

     $full_name = $object->right->right;
     $full_name = $object->right(2);

     $city = $object->right->down->down->right->right->down->down;
     $city = $object->right->down(2)->right(2)->down(2);

   If $object contains the "Thierry-Mieg J" Author object, then the first
series of accesses shown above retrieves the string "Jean Thierry-Mieg"
and the second retrieves "34033 Montpellier."  If the right or bottom
pointers are NULL, these methods will return undef.

   In addition to being somewhat awkard, you will probably never need to
use these methods.  A simpler way to retrieve the same information would
be to use the at() method described in the next section.

   The right() and down() methods always walk through the tree of the
current object.  They do not follow object pointers into the database.
Use fetch() (or the deprecated *pick()* or *follow()* methods) instead.

at() method
-----------

     $subtree    = $object->at($tag_path);
     @values     = $object->at($tag_path);

   at() is a simple way to fetch the portion of the tree that you are
interested in.  It takes a single argument, a simple tag or a path.  A
simple tag, such as "Full_name", must correspond to a tag in the column
immediately to the right of the root of the tree.  A path such as
"Address.Mail" is a dot-delimited path to the subtree.  Some examples are
given below.

     ($full_name)   = $object->at('Full_name');
     @address_lines = $object->at('Address.Mail');

   The second line above is equivalent to:

     @address = $object->at('Address')->at('Mail');

   Called without a tag name, at() just dereferences the object, returning
whatever is to the right of it, the same as $object->right

   If a path component already has a dot in it, you may escape the dot
with a backslash, as in:

     $s=$db->fetch('Sequence','M4');
     @homologies = $s->at('Homol.DNA_homol.yk192f7\.3';

   This also demonstrates that path components don't necessarily have to
be tags, although in practice they usually are.

   at() returns slightly different results depending on the context in
which it is called.  In a list context, it returns the column of values to
the right of the tag.  However, in a scalar context, it returns the
subtree rooted at the tag.  To appreciate the difference, consider these
two cases:

     $name1   = $object->at('Full_name');
     ($name2) = $object->at('Full_name');

   After these two statements run, $name1 will be the tag object named
"Full_name", and $name2 will be the text object "Jean Thierry-Mieg", The
relationship between the two is that $name1->right leads to $name2.  This
is a powerful and useful construct, but it can be a trap for the unwary.
If this behavior drives you crazy, use this construct:

   $name1   = $object->at('Full_name')->at();

   For finer control over navigation, path components can include optional
indexes to indicate navigation to the right of the current path component.
Here is the syntax:

     $object->at('tag1[index1].tag2[index2].tag3[index3]...');

   Indexes are zero-based.  An index of [0] indicates no movement relative
to the current component, and is the same as not using an index at all.
An index of [1] navigates one step to the right, [2] moves two steps to
the right, and so on.  Using the Thierry-Mieg object as an example again,
here are the results of various indexes:

     $object = $db->fetch(Author,"Thierry-Mieg J");
     $a = $object->at('Address[0]')   --> "Address"
     $a = $object->at('Address[1]')   --> "Mail"
     $a = $object->at('Address[2]')   --> "CRBM duCNRS"

   In an array context, the last index in the path does something very
interesting.  It returns the entire column of data K steps to the right of
the path, where K is the index.  This is used to implement so-called
"tag[2]" syntax, and is very useful in some circumstances.  For example,
here is a fragment of code to return the Thierry-Mieg object's full
address without having to refer to each of the intervening "Mail",
"E_Mail" and "Phone" tags explicitly.

     @address = $object->at('Address[2]');
     --> ('CRBM duCNRS','BP 5051','34033 Montpellier','FRANCE',
          'mieg@kaa.cnrs-mop.fr,'33-67-613324','33-67-521559')

   Similarly, "tag[3]" will return the column of data three hops to the
right of the tag.  "tag[1]" is identical to "tag" (with no index), and
will return the column of data to the immediate right.  There is no
special behavior associated with using "tag[0]" in an array context; it
will always return the subtree rooted at the indicated tag.

   Internal indices such as "Homol[2].BLASTN", do not have special
behavior in an array context.  They are always treated as if they were
called in a scalar context.

   Also see *col()* and get().

get() method
------------

     $subtree    = $object->get($tag);
     @values     = $object->get($tag);
     @values     = $object->get($tag, $position);
     @values     = $object->get($tag => $subtag, $position);

   The get() method will perform a breadth-first search through the object
(columns first, followed by rows) for the tag indicated by the argument,
returning the column of the portion of the subtree it points to.  For
example, this code fragment will return the value of the "Fax" tag.

     ($fax_no) = $object->get('Fax');
          --> "33-67-521559"

   The list versus scalar context semantics are the same as in at(), so if
you want to retrieve the scalar value pointed to by the indicated tag,
either use a list context as shown in the example, above, or a
dereference, as in:

     $fax_no = $object->get('Fax');
         --> "Fax"
     $fax_no = $object->get('Fax')->at;
         --> "33-67-521559"

   An optional second argument to get(), $position, allows you to navigate
the tree relative to the retrieved subtree.  Like the *at()* navigational
indexes, $position must be a number greater than or equal to zero.  In a
scalar context, $position moves rightward through the tree.  In an array
context, $position implements "tag[2]" semantics.

   For example:

     $fax_no = $object->get('Fax',0);
          --> "Fax"

     $fax_no = $object->get('Fax',1);
          --> "33-67-521559"

     $fax_no = $object->get('Fax',2);
          --> undef  # nothing beyond the fax number

     @address = $object->get('Address',2);
          --> ('CRBM duCNRS','BP 5051','34033 Montpellier','FRANCE',
               'mieg@kaa.cnrs-mop.fr,'33-67-613324','33-67-521559')

   It is important to note that get() only traverses tags.  It will not
traverse nodes that aren't tags, such as strings, integers or objects.
This is in keeping with the behavior of the Ace query language "show"
command.

   This restriction can lead to confusing results.  For example, consider
the following object:

     Clone: B0280  Position    Map            Sequence-III  Ends   Left   3569
                                                                   Right  3585
                               Pmap           ctg377        -1040  -1024
                   Positive    Positive_locus nhr-10
                   Sequence    B0280
                   Location    RW
                   FingerPrint Gel_Number     0
                               Canonical_for  T20H1
                                              K10E5
                               Bands          1354          18

   The following attempt to fetch the left and right positions of the
clone will fail, because the search for the "Left" and "Right" tags cannot
traverse "Sequence-III", which is an object, not a tag:

     my $left = $clone->get('Left');    # will NOT work
     my $right = $clone->get('Right');  # neither will this one

   You must explicitly step over the non-tag node in order to make this
query work.  This syntax will work:

     my $left = $clone->get('Map',1)->get('Left');   # works
     my $left = $clone->get('Map',1)->get('Right');  # works

   Or you might prefer to use the tag[2] syntax here:

     my($left,$right) = $clone->get('Map',1)->at('Ends[2]');

   Although not frequently used, there is a form of get() which allows you
to stack subtags:

     $locus = $object->get('Positive'=>'Positive_locus');

   Only on subtag is allowed.  You can follow this by a position if wish
to offset from the subtag.

     $locus = $object->get('Positive'=>'Positive_locus',1);

search() method
---------------

   This is a deprecated synonym for get().

Autogenerated Access Methods
----------------------------

     $scalar = $object->Name_of_tag;
     $scalar = $object->Name_of_tag($position);
     @array  = $object->Name_of_tag;
     @array  = $object->Name_of_tag($position);
     @array  = $object->Name_of_tag($subtag=>$position);

   The module attempts to autogenerate data access methods as needed.  For
example, if you refer to a method named "Fax" (which doesn't correspond to
any of the built-in methods), then the code will call the get() method to
find a tag named "Fax" and return its contents.

   Unlike get(), this method will *always step into objects*.  This means
that:

     $map = $clone->Map;

   will return the Sequence_Map object pointed to by the Clone's Map tag
and not simply a pointer to a portion of the Clone tree.  Therefore
autogenerated methods are functionally equivalent to the following:

     $map = $clone->get('Map')->fetch;

   The scalar context semantics are also slightly different.  In a scalar
context, the autogenerated function will *always* move one step to the
right.

   The list context semantics are identical to get().  If you want to
dereference all members of a multivalued tag, you have to do so manually:

     @papers = $author->Paper;
     foreach (@papers) {
       my $paper = $_->fetch;
       print  $paper->asString;
     }

   You can provide an optional positional index to rapidly navigate
through the tree or to obtain tag[2] behavior.  In the following examples,
the first two return the object's Fax number, and the third returns all
data two hops to the right of Address.

     $object   = $db->fetch(Author => 'Thierry-Mieg J');
     ($fax_no) = $object->Fax;
     $fax_no   = $object->Fax(1);
     @address  = $object->Address(2);

   You may also position at a subtag, using this syntax:

     $representative = $object->Laboratory('Representative');

   Both named tags and positions can be combined as follows:

     $lab_address = $object->Laboratory(Address=>2);

   ** Note that the semantics of the autogenerated methods have changed
subtly between version 1.57 (the last stable release) and version 1.62.
In earlier versions, calling an autogenerated method in a scalar context
returned the subtree rooted at the tag.  In the current version, an
implicit right() and dereference is performed.

fetch() method
--------------

     $new_object = $object->fetch;
     $new_object = $object->fetch($tag);

   Follow object into the database, returning a new object.  This is the
best way to follow object references.  For example:

     $laboratory = $object->at('Laboratory')->fetch;
     print $laboratory->asString;

   Because the previous example is a frequent idiom, the optional $tag
argument allows you to combine the two operations into a single one:

     $laboratory = $object->fetch('Laboratory');

follow() method
---------------

     @papers        = $object->follow('Paper');
     @filled_papers = $object->follow(-tag=>'Paper',-filled=>1);

   The follow() method will follow a tag into the database, dereferencing
the column to its right and returning the objects resulting from this
operation.  Beware!  If you follow a tag that points to an object, such as
the Author "Paper" tag, you will get a list of all the Paper objects.  If
you follow a tag that points to a scalar, such as "Full_name", you will
get an empty string.  In a scalar context, this method will return the
number of objects that would have been followed.

   The full named-argument form of this call accepts the arguments *-tag*
(mandatory) and *-filled* (optional).  The former points to the tag to
follow.  The latter accepts a boolean argument.  A true argument will
return "filled" objects, increasing network and memory usage, but possibly
boosting performance if you have a high database access latency.

   For backward compatability, if follow() is called without any
arguments, it will act like fetch().

pick() method
-------------

   Deprecated method.  This has the same semantics as fetch(), which
should be used instead.

col() method
------------

     @column = $object->col;
     @column = $object->col($position);

   *col()* flattens a portion of the tree by returning the column one hop
to the right of the current subtree. You can provide an additional
positional index to navigate through the tree using "tag[2]" behavior.
This example returns the author's mailing address:

     @mailing_address = $object->at('Address.Mail')->col();

   This example returns the author's entire address including mail, e-mail
and phone:

     @address = $object->at('Address')->col(2);

   It is equivalent to any of these calls:

     $object->at('Address[2]');
     $object->get('Address',2);
     $object->Address(2);

   Use whatever syntax is most comfortable for you.

   In a scalar context, *col()* returns the number of items in the column.

row() method
------------

     @row=$object->row();
     @row=$object->row($position);

   *row()* will return the row of data to the right of the object.  The
first member of the list will be the object itself.  In the case of the
"Thierry-Mieg J" object, the example below will return the list
('Address','Mail','CRBM duCNRS').

     @row = $object->Address->row();

   You can provide an optional position to move rightward one or more
places before retrieving the row.  This code fragment will return
('Mail','CRBM duCNRS'):

     @row = $object->Address->row(1);

   In a scalar context, *row()* returns the number of items in the row.

asString() method
-----------------

     $object->asString;

   asString() returns a pretty-printed ASCII representation of the object
tree.

asTable() method
----------------

     $object->asTable;

   asTable() returns the object as a tab-delimited text table.

asAce() method
--------------

     $object->asAce;

   asAce() returns the object as a tab-delimited text table in ".ace"
format.

asHTML() method
---------------

     $object->asHTML;
     $object->asHTML(\&tree_traversal_code);

   asHTML() returns an HTML 3 table representing the object, suitable for
incorporation into a Web browser page.  The callback routine, if provided,
will have a chance to modify the object representation before it is
incorporated into the table, for example by turning it into an HREF link.
The callback takes a single argument containing the object, and must
return a string-valued result.  It may also return a list as its result,
in which case the first member of the list is the string representation of
the object, and the second member is a boolean indicating whether to prune
the table at this level.  For example, you can prune large repetitive
lists.

   Here's a complete example:

     sub process_cell {
       my $obj = shift;
       return "$obj" unless $obj->isObject || $obj->isTag;

     my @col = $obj->col;
     my $cnt = scalar(@col);
     return ("$obj -- $cnt members",1);  # prune
            if $cnt > 10                 # if subtree to big

     # tags are bold
     return "<B>$obj</B>" if $obj->isTag;

     # objects are blue
     return qq{<FONT COLOR="blue">$obj</FONT>} if $obj->isObject;
        }

     $object->asHTML(\&process_cell);

asXML() method
--------------

     $result = $object->asXML;

   asXML() returns a well-formed XML representation of the object.  The
particular representation is still under discussion, so this feature is
primarily for demonstration.

asGIF() method
--------------

     ($gif,$boxes) = $object->asGIF();
     ($gif,$boxes) = $object->asGIF(-clicks=>[[$x1,$y1],[$x2,$y2]...]
     	                         -dimensions=>[$width,$height],
     				 -display => $display_type,
     				 -view    => $view_type
     	                         );

   asGIF() returns the object as a GIF image.  The contents of the GIF
will be whatever xace would ordinarily display in graphics mode, and will
vary for different object classes.

   You can optionally provide asGIF with a *-clicks* argument to simulate
the action of a user clicking on the image.  The click coordinates should
be formatted as an array reference that contains a series of two-element
subarrays, each corresponding to the X and Y coordinates of a single mouse
click.  There is currently no way to pass information about middle or
right mouse clicks, dragging operations, or keystrokes.  You may also
specify a *-dimensions* to control the width and height of the returned
GIF.  Since there is no way of obtaining the preferred size of the image
in advance, this is not usually useful.

   The optional *-display* argument allows you to specify an alternate
display for the object.  For example, Clones can be displayed either with
the PMAP display or with the TREE display.  If not specified, the default
display is used.

   The optional *-view* argument allows you to specify an alternative view
for MAP objects only.  If not specified, you'll get the default view.

   asGIF() returns a two-element array.  The first element is the GIF
data.  The second element is an array reference that indicates special
areas of the image called "boxes."  Boxes are rectangular areas that
surround buttons, and certain displayed objects.  Using the contents of
the boxes array, you can turn the GIF image into a client-side image map.
Unfortunately, not everything that is clickable is represented as a box.
You still have to pass clicks on unknown image areas back to the server
for processing.

   Each box in the array is a hash reference containing the following keys:

     'coordinates'  => [$left,$top,$right,$bottom]
     'class'        => object class or "BUTTON"
     'name'         => object name, if any
     'comment'      => a text comment of some sort

   *coordinates* points to an array of points indicating the top-left and
bottom-right corners of the rectangle.  class indicates the class of the
object this rectangle surrounds.  It may be a database object, or the
special word "BUTTON" for one of the display action buttons.  name
indicates the name of the object or the button.  comment is some piece of
information about the object in question.  You can display it in the
status bar of the browser or in a popup window if your browser provides
that facility.

asDNA() and asPeptide() methods
-------------------------------

     $dna = $object->asDNA();
     $peptide = $object->asPeptide();

   If you are dealing with a sequence object of some sort, these methods
will return strings corresponding to the DNA or peptide sequence in FASTA
format.

add_row() method
----------------

     $result_code = $object->add_row($tag=>$value);
     $result_code = $object->add_row($tag=>[list,of,values]);
     $result_code = $object->add(-path=>$tag,
     				-value=>$value);

   add_row() updates the tree by adding data to the indicated tag path.
The example given below adds the value "555-1212" to a new Address entry
named "Pager".  You may call add_row() a second time to add a new value
under this tag, creating multi-valued entries.

     $object->add_row('Address.Pager'=>'555-1212');

   You may provide a list of values to add an entire row of data.  For
example:

     $sequence->add_row('Assembly_tags'=>['Finished Left',38949,38952,'AC3']);

   Actually, the array reference is not entirely necessary, and if you
prefer you can use this more concise notation:

     $sequence->add_row('Assembly_tags','Finished Left',38949,38952,'AC3');

   No check is done against the database model for the correct data type
or tag path.  The update isn't actually performed until you call commit(),
at which time a result code indicates whether the database update was
successful.

   You may create objects that reference other objects this way:

     $lab = new Ace::Object('Laboratory','LM',$db);
     $lab->add_row('Full_name','The Laboratory of Medicine');
     $lab->add_row('City','Cincinatti');
     $lab->add_row('Country','USA');

     $author = new Ace::Object('Author','Smith J',$db);
     $author->add_row('Full_name','Joseph M. Smith');
     $author->add_row('Laboratory',$lab);

     $lab->commit();
     $author->commit();

   The result code indicates whether the addition was syntactically
correct.  add_row() will fail if you attempt to add a duplicate entry
(that is, one with exactly the same tag and value).  In this case, use
replace() instead.  Currently there is no checking for an attempt to add
multiple values to a single-valued (UNIQUE) tag.  The error will be
detected and reported at commit() time however.

   The add() method is an alias for add_row().

add_tree()
----------

     $result_code = $object->add_tree($tag=>$ace_object);
     $result_code = $object->add_tree(-tag=>$tag,-tree=>$ace_object);

   The add_tree() method will insert an entire Ace subtree into the object
to the right of the indicated tag.  This can be used to build up complex
Ace objects, or to copy portions of objects from one database to another.
The first argument is a tag path, and the second is the tree that you wish
to insert.  As with add_row() the database will only be updated when you
call commit().

   When inserting a subtree, you must be careful to remember that
everything to the *right* of the node that you are pointing at will be
inserted; not the node itself.  For example, given this Sequence object:

     Sequence AC3
       DB_info     Database    EMBL
       Assembly_tags   Finished Left   1   4   AC3
                       Clone left end      1   4   AC3
                       Clone right end     5512    5515    K07C5
                                           38949   38952   AC3
                       Finished Right      38949   38952   AC3

   If we use at('Assembly_tags') to fetch the subtree rooted on the
"Assembly_tags" tag, it is the tree to the right of this tag, beginning
with "Finished Left", that will be inserted.

   Here is an example of copying the "Assembly_tags" subtree from one
database object to another:

     $remote = Ace->connect(-port=>200005)  || die "can't connect";
     $ac3 = $remote->fetch(Sequence=>'AC3') || die "can't get AC7";
     my $assembly = $ac3->at('Assembly_tags');

     $local = Ace->connect(-path=>'~acedb') || die "can't connect";
     $AC3copy = Ace::Object->new(Sequence=>'AC3copy',$local);
     $AC3copy->add_tree('Assembly_tags'=>$tags);
     $AC3copy->commit || warn $AC3copy->error;

   Notice that this syntax will not work the way you think it should:

     $AC3copy->add_tree('Assembly_tags'=>$ac3->at('Assembly_tags'));

   This is because call at() in an array context returns the column to the
right of the tag, not the tag itself.

   Here's an example of building up a complex structure from scratch using
a combination of add() and add_tree():

     $newObj = Ace::Object->new(Sequence=>'A555',$local);
     my $assembly = Ace::Object->new(tag=>'Assembly_tags');
     $assembly->add('Finished Left'=>[10,20,'ABC']);
     $assembly->add('Clone right end'=>[1000,2000,'DEF']);
     $assembly->add('Clone right end'=>[8000,9876,'FRED']);
     $assembly->add('Finished Right'=>[1000,3000,'ETHEL']);
     $newObj->add_tree('Assembly_tags'=>$assembly);
     $newObj->commit || warn $newObj->error;

delete() method
---------------

     $result_code = $object->delete($tag_path,$value);
     $result_code = $object->delete(-path=>$tag_path,
                                    -value=>$value);

   Delete the indicated tag and value from the object.  This example
deletes the address line "FRANCE" from the Author's mailing address:

     $object->delete('Address.Mail','FRANCE');

   No actual database deletion occurs until you call commit().  The
delete() result code indicates whether the deletion was successful.
Currently it is always true, since the database model is not checked.

   =head2 replace() method

     $result_code = $object->replace($tag_path,$oldvalue,$newvalue);
     $result_code = $object->replace(-path=>$tag_path,
     				    -old=>$oldvalue,
     				    -new=>$newvalue);

   Replaces the indicated tag and value with the new value.  This example
changes the address line "FRANCE" to "LANGUEDOC" in the Author's mailing
address:

     $object->delete('Address.Mail','FRANCE','LANGUEDOC');

   No actual database changes occur until you call commit().  The delete()
result code indicates whether the replace was successful.  Currently is
true if the old value was identified.

commit() method
---------------

     $result_code = $object->commit;

   Commits all add(), replace() and delete() operations to the database.
It can also be used to write a completely new object into the database.
The result code indicates whether the object was successfully written.  If
an error occurred, further details can be found in the Ace->error() error
string.

rollback() method
-----------------

     $object->rollback;

   Discard all adds, deletions and replacements, returning the object to
the state it was in prior to the last commit().

   rollback() works by deleting the object from Perl memory and fetching
the object anew from AceDB.  If someone has changed the object in the
database while you were working with it, you will see this version, ot the
one you originally fetched.

   If you are creating an entirely new object, you must add at least one
tag in order to enter the object into the database.

kill() method
-------------

     $result_code = $object->kill;

   This will remove the object from the database immediately and
completely.  It does not wait for a commit(), and does not respond to a
rollback().  If successful, you will be left with an empty object that
contains just the class and object names.  Use with care!

   In the case of failure, which commonly happens when the database is not
open for writing, this method will return undef.  A description of the
problem can be found by calling the error() method.

date_style() method
-------------------

     $object->date_style('ace');

   This is a convenience method that can be used to set the date format
for all objects returned by the database.  It is exactly equivalent to

     $object->db->date_style('ace');

   Note that the text representation of the date will change for all
objects returned from this database, not just the current one.

isRoot() method
---------------

     print "Top level object" if $object->isRoot;

   This method will return true if the object is a "top level" object,
that is the root of an object tree rather than a subtree.

model() method
--------------

     $model = $object->model;

   This method will return the object's model as an Ace::Model object, or
undef if the object does not have a model. See *Note Ace/Model: Ace/Model,
for details.

timestamp() method
------------------

     $stamp = $object->timestamp;

   The *timestamp()* method will retrieve the modification time and date
from the object.  This works both with top level objects and with
subtrees.  Timestamp handling must be turned on in the database, or
*timestamp()* will return undef.

   The returned timestamp is actually a UserSession object which can be
printed and explored like any other object.  However, there is currently
no useful information in UserSession other than its name.

comment() method
----------------

     $comment = $object->comment;

   This returns the comment attached to an object or object subtree, if
any.  Comments are Comment objects and have the interesting property that
a single comment can refer to multiple objects.  If there is no comment
attached to the current subtree, this method will return undef.

   Currently you cannot create a new comment in AcePerl or edit an old one.

error() method          $error = $object->error;
------------------------------------------------

   Returns the error from the previous operation, if any.  As in
Ace::error(), this string will only have meaning if the previous operation
returned a result code indicating an error.

factory() method
----------------

   WARNING - THIS IS DEFUNCT AND NO LONGER WORKS.  USE THE Ace->class()
METHOD INSTEAD

     $package = $object->factory;

   When a root Ace object instantiates its tree of tags and values, it
creates a hierarchical structure of Ace::Object objects.  The factory()
method determines what class to bless these subsidiary objects into.  By
default, they are Ace::Object objects, but you can override this method in
a child class in order to create more specialized Ace::Object classes.
The method should return a string corresponding to the package to bless
the object into.  It receives the current Ace::Object as its first
argument.

debug() method
--------------

     $object->debug(1);

   Change the debugging mode.  A zero turns of debugging messages.
Integer values produce debug messages on standard error.  Higher integers
produce progressively more verbose messages.

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Model: Ace/Model,, *Note Ace/Object:
Ace/Object,, *Note Ace/Local: Ace/Local,, *Note Ace/Sequence:
Ace/Sequence,,*Note Ace/Sequence/Multi: Ace/Sequence/Multi,

AUTHOR
======

   Lincoln Stein <lstein@cshl.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Copyright (c) 1997-1998, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


File: pm.info,  Node: Ace/Sequence,  Next: Ace/Sequence/Feature,  Prev: Ace/Object,  Up: Module List

Examine ACeDB Sequence Objects
******************************

NAME
====

   Ace::Sequence - Examine ACeDB Sequence Objects

SYNOPSIS
========

     # open database connection and get an Ace::Object sequence
     use Ace::Sequence;

     $db  = Ace->connect(-host => 'stein.cshl.org',-port => 200005);
     $obj = $db->fetch(Predicted_gene => 'ZK154.3');

     # Wrap it in an Ace::Sequence object
     $seq = Ace::Sequence->new($obj);

     # Find all the exons
     @exons = $seq->features('exon');

     # Find all the exons predicted by various versions of "genefinder"
     @exons = $seq->features('exon:genefinder.*');

     # Iterate through the exons, printing their start, end and DNA
     for my $exon (@exons) {
       print join "\t",$exon->start,$exon->end,$exon->dna,"\n";
     }

     # Find the region 1000 kb upstream of the first exon
     $sub = Ace::Sequence->new(-seq=>$exons[0],
                               -offset=>-1000,-length=>1000);

     # Find all features in that area
     @features = $sub->features;

     # Print its DNA
     print $sub->dna;

     # Create a new Sequence object from the first 500 kb of chromosome 1
     $seq = Ace::Sequence->new(-name=>'CHROMOSOME_I',-db=>$db,
     			      -offset=>0,-length=>500_000);

     # Get the GFF dump as a text string
     $gff = $seq->gff;

     # Limit dump to Predicted_genes
     $gff_genes = $seq->gff(-features=>'Predicted_gene');

     # Return a GFF object (using optional GFF.pm module from Sanger)
     $gff_obj = $seq->GFF;

DESCRIPTION
===========

   *Ace::Sequence*, and its allied classes *Note Ace/Sequence/Feature:
Ace/Sequence/Feature, and *Note Ace/Sequence/FeatureList:
Ace/Sequence/FeatureList,, provide a convenient interface to the ACeDB
Sequence classes and the GFF sequence feature file format.

   Using this class, you can define a region of the genome by using a
landmark (sequenced clone, link, superlink, predicted gene), an offset
from that landmark, and a distance.  Offsets and distances can be positive
or negative.  This will return an *Ace::Sequence* object.  Once a region
is defined, you may retrieve its DNA sequence, or query the database for
any features that may be contained within this region.  Features can be
returned as objects (using the *Ace::Sequence::Feature* class), as GFF
text-only dumps, or in the form of the GFF class defined by the Sanger
Centre's GFF.pm module.

   This class builds on top of *Note Ace: Ace, and *Note Ace/Object:
Ace/Object,.  Please see their manual pages before consulting this one.

Creating New Ace::Sequence Objects, the new() Method
====================================================

     $seq = Ace::Sequence->new($object);

     $seq = Ace::Sequence->new(-source  => $object,
                               -offset  => $offset,
                               -length  => $length,
     			   -refseq  => $reference_sequence);

     $seq = Ace::Sequence->new(-name    => $name,
     			   -db      => $db,
                               -offset  => $offset,
                               -length  => $length,
     			   -refseq  => $reference_sequence);

   In order to create an *Ace::Sequence* you will need an active *Ace*
database accessor.  Sequence regions are defined using a "source"
sequence, an offset, and a length.  Optionally, you may also provide a
"reference sequence" to establish the coordinate system for all inquiries.
Sequences may be generated from existing *Ace::Object* sequence objects,
from other *Ace::Sequence* and *Ace::Sequence::Feature* objects, or from a
sequence name and a database handle.

   The class method named new() is the interface to these facilities.  In
its simplest, one-argument form, you provide new() with a
previously-created *Ace::Object* that points to Sequence or sequence-like
object (the meaning of "sequence-like" is explained in more detail below.)
The new() method will return an *Ace::Sequence* object extending from the
beginning of the object through to its natural end.

   In the named-parameter form of new(), the following arguments are
recognized:

-source
     The sequence source.  This must be an *Ace::Object* of the "Sequence"
     class, or be a sequence-like object containing the SMap tag (see
     below).

-offset
     An offset from the beginning of the source sequence.  The retrieved
     *Ace::Sequence* will begin at this position.  The offset can be any
     positive or negative integer.  Offets are *0-based*.

-length
     The length of the sequence to return.  Either a positive or negative
     integer can be specified.  If a negative length is given, the returned
     sequence will be complemented relative to the source sequence.

-refseq
     The sequence to use to establish the coordinate system for the
     returned sequence.  Normally the source sequence is used to establish
     the coordinate system, but this can be used to override that choice.
     You can provide either an *Ace::Object* or just a sequence name for
     this argument.  The source and reference sequences must share a common
     ancestor, but do not have to be directly related.  An attempt to use a
     disjunct reference sequence, such as one on a different chromosome,
     will fail.

-name
     As an alternative to using an *Ace::Object* with the *-source*
     argument, you may specify a source sequence using *-name* and *-db*.
     The *Ace::Sequence* module will use the provided database accessor to
     fetch a Sequence object with the specified name. new() will return
     undef is no Sequence by this name is known.

-db
     This argument is required if the source sequence is specified by name
     rather than by object reference.

   If new() is successful, it will create an *Ace::Sequence* object and
return it.  Otherwise it will return undef and return a descriptive
message in Ace->error().  Certain programming errors, such as a failure to
provide required arguments, cause a fatal error.

Reference Sequences and the Coordinate System
---------------------------------------------

   When retrieving information from an *Ace::Sequence*, the coordinate
system is based on the sequence segment selected at object creation time.
That is, the "+1" strand is the natural direction of the *Ace::Sequence*
object, and base pair 1 is its first base pair.  This behavior can be
overridden by providing a reference sequence to the new() method, in which
case the orientation and position of the reference sequence establishes
the coordinate system for the object.

   In addition to the reference sequence, there are two other sequences
used by *Ace::Sequence* for internal bookeeping.  The "source" sequence
corresponds to the smallest ACeDB sequence object that completely encloses
the selected sequence segment.  The "parent" sequence is the smallest
ACeDB sequence object that contains the "source".  The parent is used to
derive the length and orientation of source sequences that are not
directly associated with DNA objects.

   In many cases, the source sequence will be identical to the sequence
initially passed to the new() method.  However, there are exceptions to
this rule.  One common exception occurs when the offset and/or length
cross the boundaries of the passed-in sequence.  In this case, the ACeDB
database is searched for the smallest sequence that contains both
endpoints of the *Ace::Sequence* object.

   The other common exception occurs in Ace 4.8, where there is support
for "sequence-like" objects that contain the `SMap' ("Sequence Map") tag.
The `SMap' tag provides genomic location information for arbitrary object
- not just those descended from the Sequence class.  This allows ACeDB to
perform genome map operations on objects that are not directly related to
sequences, such as genetic loci that have been interpolated onto the
physical map.  When an `SMap'-containing object is passed to the
*Ace::Sequence* new() method, the module will again choose the smallest
ACeDB Sequence object that contains both end-points of the desired region.

   If an *Ace::Sequence* object is used to create a new *Ace::Sequence*
object, then the original object's source is inherited.

Object Methods
==============

   Once an *Ace::Sequence* object is created, you can query it using the
following methods:

asString()
----------

     $name = $seq->asString;

   Returns a human-readable identifier for the sequence in the form
*Source/start-end*, where "Source" is the name of the source sequence, and
"start" and "end" are the endpoints of the sequence relative to the source
(using 1-based indexing).  This method is called automatically when the
*Ace::Sequence* is used in a string context.

source_seq()
------------

     $source = $seq->source_seq;

   Return the source of the *Ace::Sequence*.

parent_seq()
------------

     $parent = $seq->parent_seq;

   Return the immediate ancestor of the sequence.  The parent of the
top-most sequence (such as the CHROMOSOME link) is itself.  This method is
used internally to ascertain the length of source sequences which are not
associated with a DNA object.

   NOTE: this procedure is a trifle funky and cannot reliably be used to
traverse upwards to the top-most sequence.  The reason for this is that it
will return an *Ace::Sequence* in some cases, and an *Ace::Object* in
others.  Use get_parent() to traverse upwards through a uniform series of
*Ace::Sequence* objects upwards.

refseq([$seq])
--------------

     $refseq = $seq->refseq;

   Returns the reference sequence, if one is defined.

     $seq->refseq($new_ref);

   Set the reference sequence. The reference sequence must share the same
ancestor with $seq.

start()
-------

     $start = $seq->start;

   Start of this sequence, relative to the source sequence, using 1-based
indexing.

end()
-----

     $end = $seq->end;

   End of this sequence, relative to the source sequence, using 1-based
indexing.

offset()
--------

     $offset = $seq->offset;

   Offset of the beginning of this sequence relative to the source
sequence, using 0-based indexing.  The offset may be negative if the
beginning of the sequence is to the left of the beginning of the source
sequence.

length()
--------

     $length = $seq->length;

   The length of this sequence, in base pairs.  The length may be negative
if the sequence's orientation is reversed relative to the source sequence.
Use abslength() to obtain the absolute value of the sequence length.

abslength()
-----------

     $length = $seq->abslength;

   Return the absolute value of the length of the sequence.

strand()
--------

     $strand = $seq->strand;

   Returns +1 for a sequence oriented in the natural direction of the
genomic reference sequence, or -1 otherwise.

reversed()
----------

   Returns true if the segment is reversed relative to the canonical
genomic direction.  This is the same as $seq->strand < 0.

dna()
-----

     $dna = $seq->dna;

   Return the DNA corresponding to this sequence.  If the sequence length
is negative, the reverse complement of the appropriate segment will be
returned.

   ACeDB allows Sequences to exist without an associated DNA object (which
typically happens during intermediate stages of a sequencing project.  In
such a case, the returned sequence will contain the correct number of "-"
characters.

name()
------

     $name = $seq->name;

   Return the name of the source sequence as a string.

get_parent()
------------

     $parent = $seq->parent;

   Return the immediate ancestor of this *Ace::Sequence* (i.e., the
sequence that contains this one).  The return value is a new
*Ace::Sequence* or undef, if no parent sequence exists.

get_children()
--------------

     @children = $seq->get_children();

   Returns all subsequences that exist as independent objects in the ACeDB
database.  What exactly is returned is dependent on the data model.  In
older ACeDB databases, the only subsequences are those under the catchall
Subsequence tag.  In newer ACeDB databases, the objects returned
correspond to objects to the right of the S_Child subtag using a tag[2]
syntax, and may include Predicted_genes, Sequences, Links, or other
objects.  The return value is a list of *Ace::Sequence* objects.

features()
----------

     @features = $seq->features;
     @features = $seq->features('exon','intron','Predicted_gene');
     @features = $seq->features('exon:GeneFinder','Predicted_gene:hand.*');

   features() returns an array of *Sequence::Feature* objects.  If called
without arguments, features() returns all features that cross the sequence
region.  You may also provide a filter list to select a set of features by
type and subtype.  The format of the filter list is:

     type:subtype

   Where type is the class of the feature (the "feature" field of the GFF
format), and subtype is a description of how the feature was derived (the
"source" field of the GFF format).  Either of these fields can be absent,
and either can be a regular expression.  More advanced filtering is not
supported, but is provided by the Sanger Centre's GFF module.

   The order of the features in the returned list is not specified.  To
obtain features sorted by position, use this idiom:

     @features = sort { $a->start <=> $b->start } $seq->features;

feature_list()
--------------

     my $list = $seq->feature_list();

   This method returns a summary list of the features that cross the
sequence in the form of a `Ace::Feature::List' in this node object.  From
the `Ace::Feature::List' in this node object you can obtain the list of
feature names and the number of each type.  The feature list is obtained
from the ACeDB server with a single short transaction, and therefore has
much less overhead than features().

   See `Ace::Feature::List' in this node for more details.

transcripts()
-------------

   This returns a list of Ace::Sequence::Transcript objects, which are
specializations of Ace::Sequence::Feature.  See *Note
Ace/Sequence/Transcript: Ace/Sequence/Transcript, for details.

clones()
--------

   This returns a list of Ace::Sequence::Feature objects containing
reconstructed clones.  This is a nasty hack, because ACEDB currently
records clone ends, but not the clones themselves, meaning that we will
not always know both ends of the clone.  In this case the missing end has
a synthetic position of -99,999,999 or +99,999,999.  Sorry.

gff()
-----

     $gff = $seq->gff();
     $gff = $seq->gff(-abs      => 1,
                      -features => ['exon','intron:GeneFinder']);

   This method returns a GFF file as a scalar.  The following arguments
are optional:

-abs
     Ordinarily the feature entries in the GFF file will be returned in
     coordinates relative to the start of the *Ace::Sequence* object.
     Position 1 will be the start of the sequence object, and the "+"
     strand will be the sequence object's natural orientation.  However if
     a true value is provided to *-abs*, the coordinate system used will
     be relative to the start of the source sequence, i.e. the native ACeDB
     Sequence object (usually a cosmid sequence or a link).

     If a reference sequence was provided when the *Ace::Sequence* was
     created, it will be used by default to set the coordinate system.
     Relative coordinates can be reenabled by providing a false value to
     *-abs*.

     Ordinarily the coordinate system manipulations automatically "do what
     you want" and you will not need to adjust them.  See also the abs()
     method described below.

-features
     The *-features* argument filters the features according to a list of
     types and subtypes.  The format is identical to the one described for
     the features() method.  A single filter may be provided as a scalar
     string.  Multiple filters may be passed as an array reference.

   See also the GFF() method described next.

GFF()
-----

     $gff_object = $seq->gff;
     $gff_object = $seq->gff(-abs      => 1,
                      -features => ['exon','intron:GeneFinder']);

   The GFF() method takes the same arguments as gff() described above, but
it returns a *GFF::GeneFeatureSet* object from the GFF.pm module.  If the
GFF module is not installed, this method will generate a fatal error.

absolute()
----------

     $abs = $seq->absolute;
     $abs = $seq->absolute(1);

   This method controls whether the coordinates of features are returned
in absolute or relative coordinates.  "Absolute" coordinates are relative
to the underlying source or reference sequence.  "Relative" coordinates
are relative to the *Ace::Sequence* object.  By default, coordinates are
relative unless new() was provided with a reference sequence.  This
default can be examined and changed using absolute().

automerge()
-----------

     $merge = $seq->automerge;
     $seq->automerge(0);

   This method controls whether groups of features will automatically be
merged together by the features() call.  If true (the default), then the
left and right end of clones will be merged into "clone" features,
introns, exons and CDS entries will be merged into
Ace::Sequence::Transcript objects, and similarity entries will be merged
into Ace::Sequence::GappedAlignment objects.

db()
----

     $db = $seq->db;

   Returns the *Note Ace: Ace, database accessor associated with this
sequence.

SEE ALSO
========

   *Note Ace: Ace,, *Note Ace/Object: Ace/Object,, *Note
Ace/Sequence/Feature: Ace/Sequence/Feature,, *Note
Ace/Sequence/FeatureList: Ace/Sequence/FeatureList,, `GFF' in this node

AUTHOR
======

   Lincoln Stein <lstein@cshl.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs-mop.fr>

   Many thanks to David Block <dblock@gene.pbi.nrc.ca> for finding and
fixing the nasty off-by-one errors.

   Copyright (c) 1999, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  See DISCLAIMER.txt for disclaimers
of warranty.


