This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Bit/Vector/Overload,  Next: Bleach,  Prev: Bit/Vector,  Up: Module List

Overloaded operators add-on for Bit::Vector
*******************************************

NAME
====

   Bit::Vector::Overload - Overloaded operators add-on for Bit::Vector

USAGE
=====

   Note that you do not need to "`use Bit::Vector;'" in addition to this
module.

   Simply "`use Bit::Vector::Overload;'" *INSTEAD* of "`use
Bit::Vector;'". You can still use all the methods from the "Bit::Vector"
module in addition to the overloaded operators and methods provided here
after that.

SYNOPSIS
========

     Configuration
         $config = Bit::Vector->Configuration();
         Bit::Vector->Configuration($config);
         $oldconfig = Bit::Vector->Configuration($newconfig);

     String Conversion
         $string = "$vector";             #  depending on configuration
         print "\$vector = '$vector'\n";

     Emptyness
         if ($vector)  #  if not empty (non-zero)
         if (! $vector)  #  if empty (zero)
         unless ($vector)  #  if empty (zero)

     Complement (one's complement)
         $vector2 = ~$vector1;
         $vector = ~$vector;

     Negation (two's complement)
         $vector2 = -$vector1;
         $vector = -$vector;

     Norm
         $norm = abs($vector);  #  depending on configuration

     Absolute
         $vector2 = abs($vector1);  #  depending on configuration

     Concatenation
         $vector3 = $vector1 . $vector2;
         $vector1 .= $vector2;
         $vector1 = $vector2 . $vector1;
         $vector2 = $vector1 . $scalar;  #  depending on configuration
         $vector2 = $scalar . $vector1;
         $vector .= $scalar;

     Duplication
         $vector2 = $vector1 x $factor;
         $vector x= $factor;

     Shift Left
         $vector2 = $vector1 << $bits;
         $vector <<= $bits;

     Shift Right
         $vector2 = $vector1 >> $bits;
         $vector >>= $bits;

     Union
         $vector3 = $vector1 | $vector2;
         $vector1 |= $vector2;
         $vector2 = $vector1 | $scalar;
         $vector |= $scalar;

     $vector3 = $vector1 + $vector2;  #  depending on configuration
     $vector1 += $vector2;
     $vector2 = $vector1 + $scalar;
     $vector += $scalar;

     Intersection
         $vector3 = $vector1 & $vector2;
         $vector1 &= $vector2;
         $vector2 = $vector1 & $scalar;
         $vector &= $scalar;

     $vector3 = $vector1 * $vector2;  #  depending on configuration
     $vector1 *= $vector2;
     $vector2 = $vector1 * $scalar;
     $vector *= $scalar;

     ExclusiveOr
         $vector3 = $vector1 ^ $vector2;
         $vector1 ^= $vector2;
         $vector2 = $vector1 ^ $scalar;
         $vector ^= $scalar;

     Set Difference
         $vector3 = $vector1 - $vector2;  #  depending on configuration
         $vector1 -= $vector2;
         $vector1 = $vector2 - $vector1;
         $vector2 = $vector1 - $scalar;
         $vector2 = $scalar - $vector1;
         $vector -= $scalar;

     Addition
         $vector3 = $vector1 + $vector2;  #  depending on configuration
         $vector1 += $vector2;
         $vector2 = $vector1 + $scalar;
         $vector += $scalar;

     Subtraction
         $vector3 = $vector1 - $vector2;  #  depending on configuration
         $vector1 -= $vector2;
         $vector1 = $vector2 - $vector1;
         $vector2 = $vector1 - $scalar;
         $vector2 = $scalar - $vector1;
         $vector -= $scalar;

     Multiplication
         $vector3 = $vector1 * $vector2;  #  depending on configuration
         $vector1 *= $vector2;
         $vector2 = $vector1 * $scalar;
         $vector *= $scalar;

     Division
         $vector3 = $vector1 / $vector2;
         $vector1 /= $vector2;
         $vector1 = $vector2 / $vector1;
         $vector2 = $vector1 / $scalar;
         $vector2 = $scalar / $vector1;
         $vector /= $scalar;

     Modulo
         $vector3 = $vector1 % $vector2;
         $vector1 %= $vector2;
         $vector1 = $vector2 % $vector1;
         $vector2 = $vector1 % $scalar;
         $vector2 = $scalar % $vector1;
         $vector %= $scalar;

     Exponentiation
         $vector3 = $vector1 ** $vector2;
         $vector1 **= $vector2;
         $vector2 = $vector1 ** $scalar;
         $vector2 = $scalar ** $vector1;
         $vector **= $scalar;

     Increment
         ++$vector;
         $vector++;

     Decrement
         --$vector;
         $vector--;

     Lexical Comparison (unsigned)
         $cmp = $vector1 cmp $vector2;
         if ($vector1 lt $vector2)
         if ($vector1 le $vector2)
         if ($vector1 gt $vector2)
         if ($vector1 ge $vector2)

     $cmp = $vector cmp $scalar;
     if ($vector lt $scalar)
     if ($vector le $scalar)
     if ($vector gt $scalar)
     if ($vector ge $scalar)

     Comparison (signed)
         $cmp = $vector1 <=> $vector2;
         if ($vector1 < $vector2)  #  depending on configuration
         if ($vector1 <= $vector2)
         if ($vector1 > $vector2)
         if ($vector1 >= $vector2)

     $cmp = $vector <=> $scalar;
     if ($vector < $scalar)  #  depending on configuration
     if ($vector <= $scalar)
     if ($vector > $scalar)
     if ($vector >= $scalar)

     Equality
         if ($vector1 eq $vector2)
         if ($vector1 ne $vector2)
         if ($vector eq $scalar)
         if ($vector ne $scalar)

     if ($vector1 == $vector2)
     if ($vector1 != $vector2)
     if ($vector == $scalar)
     if ($vector != $scalar)

     Subset Relationship
         if ($vector1 <= $vector2)  #  depending on configuration

     True Subset Relationship
         if ($vector1 < $vector2)  #  depending on configuration

     Superset Relationship
         if ($vector1 >= $vector2)  #  depending on configuration

     True Superset Relationship
         if ($vector1 > $vector2)  #  depending on configuration

IMPORTANT NOTES
===============

   * Boolean values

     Boolean values in this module are always a numeric zero ("0") for
     "false" and a numeric one ("1") for "true".

   * Negative numbers

     Numeric factors (as needed for the "`<<'", "`>>'" and "x" operators)
     and bit numbers are always regarded as being UNSIGNED.

     As a consequence, whenever you pass a negative number for such a
     factor or bit number, it will be treated as a (usually very large)
     positive number due to its internal two's complement binary
     representation, usually resulting in malfunctions or an "index out of
     range" error message and program abortion.

     Note that this does not apply to "big integer" decimal numbers, which
     are (usually) passed as strings, and which may of course be negative
     (see also the section "Big integers" a little further below).

   * Overloaded operators configuration

     Note that the behaviour of certain overloaded operators can be changed
     in various ways by means of the "`Configuration()'" method (for more
     details, see the description of this method further below).

     For instance, scalars (i.e., numbers and strings) provided as operands
     to overloaded operators are automatically converted to bit vectors,
     internally.

     These scalars are thereby automatically assumed to be indices or to be
     in hexadecimal, binary, decimal or enumeration format, depending on
     the configuration.

     Similarly, when converting bit vectors to strings using double quotes
     (""), the output format will also depend on the previously chosen
     configuration.

     Finally, some overloaded operators may have different semantics
     depending on the proper configuration; for instance, the operator "+"
     can be the "union" operator from set theory or the arithmetic "add"
     operator.

     In all cases (input, output and operator semantics), the defaults have
     been chosen in such a way so that the behaviour of the module is
     backward compatible with previous versions.

   * "Big integers"

     As long as "big integers" (for "big integer" arithmetic) are small
     enough so that Perl doesn't need scientific notation (exponents) to
     be able to represent them internally, you can provide these "big
     integer" constants to the overloaded operators of this module (or to
     the method "`from_Dec()'") in numeric form (i.e., either as a numeric
     constant or expression or as a Perl variable containing a numeric
     value).

     Note that you will get an error message (resulting in program
     abortion) if your "big integer" numbers exceed that limit.

     Because this limit is machine-dependent and not obvious to find out,
     it is strongly recommended that you enclose ALL your "big integer"
     constants in your programs in (double or single) quotes.

     Examples:

          $vector /= 10;  #  ok because number is small

          $vector /= -10;  #  ok for same reason

          $vector /= "10";  #  always correct

          $vector += "1152921504606846976";  #  quotes probably required here

     All examples assume

          Bit::Vector->Configuration("input=decimal");

     having been set beforehand.

     Note also that this module does not support scientific notation
     (exponents) for "big integer" decimal numbers because you can always
     make the bit vector large enough for the whole number to fit without
     loss of precision (as it would occur if scientific notation were
     used).

     Finally, note that the only characters allowed in "big integer"
     constant strings are the digits `0..9' and an optional leading sign
     ("+" or "-").

     All other characters produce a syntax error.

   * Valid operands for overloaded operators

     All overloaded operators expect at least one bit vector operand, in
     order for the operator to "know" that not the usual operation is to
     be carried out, but rather the overloaded variant.

     This is especially true for all unary operators:

          "$vector"
          if ($vector)
          if (!$vector)
          ~$vector
          -$vector
          abs($vector)
          ++$vector
          $vector++
          --$vector
          $vector--

     For obvious reasons the left operand (the "lvalue") of all assignment
     operators is also required to be a bit vector:

          .=
          x=
          <<=
          >>=
          |=
          &=
          ^=
          +=
          -=
          *=
          /=
          %=
                                 **=

     In the case of three special operators, namely "`<<'", "`>>'" and
     "x", as well as their related assignment variants, "`<<='", "`>>='"
     and "`x='", the left operand is *ALWAYS* a bit vector and the right
     operand is *ALWAYS* a number (which is the factor indicating how many
     times the operator is to be applied).

     In all truly binary operators, i.e.,

          .
          |
          &
          ^
          +
          -
          *
          /
          %
                                 **
                              <=>   cmp
                               ==    eq
                               !=    ne
                               <     lt
                               <=    le
                               >     gt
                               >=    ge

     one of either operands may be replaced by a Perl scalar, i.e., a
     number or a string, either as a Perl constant, a Perl expression or a
     Perl variable yielding a number or a string.

     The same applies to the right side operand (the "rvalue") of the
     remaining assignment operators, i.e.,

          .=
          |=
          &=
          ^=
          +=
          -=
          *=
          /=
          %=
                                 **=

     Note that this Perl scalar should be of the correct type, i.e.,
     numeric or string, for the chosen configuration, because otherwise a
     warning message will occur if your program runs under the "-w" switch
     of Perl.

     The acceptable scalar types for each possible configuration are the
     following:

          input = bit indices    (default)  :    numeric
          input = hexadecimal               :    string
          input = binary                    :    string
          input = decimal                   :    string     (in general)
          input = decimal                   :    numeric    (if small enough)
          input = enumeration               :    string

     NOTE ALSO THAT THESE SCALAR OPERANDS ARE CONVERTED TO BIT VECTORS OF
     THE SAME SIZE AS THE BIT VECTOR WHICH IS THE OTHER OPERAND.

     The only exception from this rule is the concatenation operator (".")
     and its assignment variant ("`.='"):

     If one of the two operands of the concatenation operator (".") is not
     a bit vector object but a Perl scalar, the contents of the remaining
     bit vector operand are converted into a string (the format of which
     depends on the configuration set with the "`Configuration()'" method),
     which is then concatenated in the proper order (i.e., as indicated by
     the order of the two operands) with the Perl scalar (in other words,
     a string is returned in such a case instead of a bit vector object!).

     If the right side operand (the "rvalue") of the assignment variant
     ("`.='") of the concatenation operator is a Perl scalar, it is
     converted internally to a bit vector of the same size as the left
     side operand provided that the configuration states that scalars are
     to be regarded as indices, decimal strings or enumerations.

     If the configuration states that scalars are to be regarded as
     hexadecimal or boolean strings, however, these strings are converted
     to bit vectors of a size matching the length of the input string,
     i.e., four times the length for hexadecimal strings (because each
     hexadecimal digit is worth 4 bits) and once the length for binary
     strings.

     If a decimal number ("big integer") is too large to be stored in a
     bit vector of the given size, a "numeric overflow error" occurs.

     If a bit index is out of range for the given bit vector, an "index
     out of range" error occurs.

     If a scalar operand cannot be converted successfully due to invalid
     syntax, a fatal "input string syntax error" is issued.

     If the two operands of the operator "`<<'", "`>>'" or "x" are
     reversed, a fatal "reversed operands error" occurs.

     If an operand is neither a bit vector nor a scalar, then a fatal
     "illegal operand type error" occurs.

   * Bit order

     Note that bit vectors are stored least order bit and least order word
     first internally.

     I.e., bit #0 of any given bit vector corresponds to bit #0 of word #0
     in the array of machine words representing the bit vector.

     (Where word #0 comes first in memory, i.e., it is stored at the least
     memory address in the allocated block of memory holding the given bit
     vector.)

     Note however that machine words can be stored least order byte first
     or last, depending on your system's implementation.

     Note further that whenever bit vectors are converted to and from
     (binary or hexadecimal) strings, the *RIGHTMOST* bit is always the
     *LEAST SIGNIFICANT* one, and the *LEFTMOST* bit is always the *MOST
     SIGNIFICANT* bit.

     This is because in our western culture, numbers are always
     represented in this way (least significant to most significant digits
     go from right to left).

     Of course this requires an internal reversion of order, which the
     corresponding conversion methods perform automatically (without any
     additional overhead, it's just a matter of starting the internal loop
     at the bottom or the top end).

   * Matching sizes

     In general, for methods involving several bit vectors at the same
     time, all bit vector arguments must have identical sizes (number of
     bits), or a fatal "size mismatch" error will occur.

     Exceptions from this rule are the methods "`Concat()'",
     "`Concat_List()'", "`Copy()'", "`Interval_Copy()'" and
     "`Interval_Substitute()'", where no conditions at all are imposed on
     the size of their bit vector arguments.

     In method "`Multiply()'", all three bit vector arguments must in
     principle obey the rule of matching sizes, but the bit vector in
     which the result of the multiplication is to be stored may be larger
     than the two bit vector arguments containing the factors for the
     multiplication.

     In method "`Power()'", the bit vector for the result must be the same
     size or greater than the base of the exponentiation term. The exponent
     can be any size.

     The same applies to the corresponding overloaded operators.

   * Index ranges

     All indices for any given bits must lie between "0" and
     "`$vector->Size()-1'", or a fatal "index out of range" error will
     occur.

DESCRIPTION
===========

   * `$config = Bit::Vector->Configuration();'

   * `Bit::Vector->Configuration($config);'

   * `$oldconfig = Bit::Vector->Configuration($newconfig);'

     This method serves to alter the semantics (i.e., behaviour) of certain
     overloaded operators (which are all implemented in Perl, by the way).

     It does not have any effect whatsoever on anything else. In
     particular, it does not affect the methods implemented in C.

     The method accepts an (optional) string as input in which certain
     keywords are expected, which influence some or almost all of the
     overloaded operators in several possible ways.

     The method always returns a string (which you do not need to take
     care of, i.e., to store, in case you aren't interested in keeping it)
     which is a complete representation of the current configuration
     (i.e., *BEFORE* any modifications are applied) and which can be fed
     back to this method later in order to restore the previous
     configuration.

     There are three aspects of the way certain overloaded operators
     behave which can be controlled with this method:

          +  the way scalar operands (replacing one of the two
             bit vector object operands) are automatically
             converted internally into a bit vector object of
             their own,

          +  the operation certain overloaded operators perform,
             i.e., an operation with sets or an arithmetic
             operation,

          +  the format to which bit vectors are converted
             automatically when they are enclosed in double
             quotes.

     The input string may contain any number of assignments, each of which
     controls one of these three aspects.

     Each assignment has the form "`<which>=<value>'".

     "`<which>'" and "`<value>'" thereby consist of letters (`[a-zA-Z]')
     and white space.

     Multiple assignments have to be separated by one or more comma (","),
     semi-colon (";"), colon (":"), vertical bar ("|"), slash ("/"),
     newline ("\n"), ampersand ("&"), plus ("+") or dash ("-").

     Empty lines or statements (only white space) are allowed but will be
     ignored.

     "`<which>'" has to contain one or more keywords from one of three
     groups, each group representing one of the three aspects that the
     "`Configuration()'" method controls:

          +  "^scalar", "^input", "^in$"

          +  "^operator", "^semantic", "^ops$"

          +  "^string", "^output", "^out$"

     The character "^" thereby denotes the beginning of a word, and "$"
     denotes the end. Case is ignored (!).

     Using these keywords, you can build any phrase you like to select one
     of the three aspects (see also examples given below).

     The only condition is that no other keyword from any of the other two
     groups may match - otherwise a syntax error will occur (i.e.,
     ambiguities are forbidden). A syntax error also occurs if none of the
     keywords matches.

     This same principle applies to "`<value>'":

     Depending on which aspect you specified for "`<which>'", there are
     different groups of keywords that determine the value the selected
     aspect will be set to:

          +  "<which>" = "^scalar", "^input", "^in$":

          "<value>" =

          *  "^bit$", "^index", "^indice"
          *  "^hex"
          *  "^bin"
          *  "^dec"
          *  "^enum"

          +  "<which>" = "^operator", "^semantic", "^ops$":

          "<value>" =

          *  "^set$"
          *  "^arithmetic"

          +  "<which>" = "^string", "^output", "^out$":

          "<value>" =

          *  "^hex"
          *  "^bin"
          *  "^dec"
          *  "^enum"

     Examples:

          "Any scalar input I provide should be considered to be = a bit index"

          "I want to have operator semantics suitable for = arithmetics"

          "Any bit vector in double quotes is to be output as = an enumeration"

     *SCALAR INPUT:*

     In the case of scalar input, "`^bit$'", "`^index'", or "`^indice'"
     all cause scalar input to be considered to represent a bit index,
     i.e., "`$vector ^= 5;'" will flip bit #5 in the given bit vector
     (this is essentially the same as "`$vector->bit_flip(5);'").

     Note that "bit indices" is the default setting for "scalar input".

     The keyword "`^hex'" will cause scalar input to be considered as
     being in hexadecimal, i.e., "`$vector ^= 5;'" will flip bit #0 and
     bit #2 (because hexadecimal "5" is binary "`0101'").

     (Note though that hexadecimal input should always be enclosed in
     quotes, otherwise it will be interpreted as a decimal number by Perl!
     The example relies on the fact that hexadecimal `0-9' and decimal
     `0-9' are the same.)

     The keyword "`^bin'" will cause scalar input to be considered as
     being in binary format. All characters except "0" and "1" are
     forbidden in this case (i.e., produce a syntax error).

     "`$vector ^= '0101';'", for instance, will flip bit #0 and bit #2.

     The keyword "`^dec'" causes scalar input to be considered as integers
     in decimal format, i.e., "`$vector ^= 5;'" will flip bit #0 and bit #2
     (because decimal "5" is binary "`0101'").

     (Note though that all decimal input should be enclosed in quotes,
     because for large numbers, Perl will use scientific notation
     internally for representing them, which produces a syntax error
     because scientific notation is neither supported by this module nor
     needed.)

     Finally, the keyword "`^enum'" causes scalar input to be considered
     as being a list ("enumeration") of indices and ranges of (contiguous)
     indices, i.e., "`$vector |= '2,3,5,7-13,17-23';'" will cause bits #2,
     #3, #5, #7 through #13 and #17 through #23 to be set.

     *OPERATOR SEMANTICS:*

     Several overloaded operators can have two distinct functions depending
     on this setting.

     The affected operators are: "+", "-", "*", "`<'", "`<='", "`>'" and
     "`>='".

     With the default setting, "set operations", these operators perform:

          +       set union                           ( set1  u   set2 )
          -       set difference                      ( set1  \   set2 )
          *       set intersection                    ( set1  n   set2 )
          <       true subset relationship            ( set1  <   set2 )
          <=      subset relationship                 ( set1  <=  set2 )
          >       true superset relationship          ( set1  >   set2 )
          >=      superset relationship               ( set1  >=  set2 )

     With the alternative setting, "arithmetic operations", these operators
     perform:

          +       addition                            ( num1  +   num2 )
          -       subtraction                         ( num1  -   num2 )
          *       multiplication                      ( num1  *   num2 )
          <       "less than" comparison              ( num1  <   num2 )
          <=      "less than or equal" comparison     ( num1  <=  num2 )
          >       "greater than" comparison           ( num1  >   num2 )
          >=      "greater than or equal" comparison  ( num1  >=  num2 )

     Note that these latter comparison operators ("`<'", "`<='", "`>'" and
     "`>='") regard their operands as being *SIGNED*.

     To perform comparisons with UNSIGNED operands, use the operators
     "lt", "le", "gt" and "ge" instead (in contrast to the operators
     above, these operators are *NOT* affected by the "operator semantics"
     setting).

     *STRING OUTPUT:*

     There are four methods which convert the contents of a given bit
     vector into a string: "`to_Hex()'", "`to_Bin()'", "`to_Dec()'" and
     "`to_Enum()'" (not counting "`Block_Read()'", since this method does
     not return a human-readable string).

     (For conversion to octal, see the description of the method
     "`Chunk_List_Read()'".)

     Therefore, there are four possible formats into which a bit vector can
     be converted when it is enclosed in double quotes, for example:

          print "\$vector = '$vector'\n";
          $string = "$vector";

     Hence you can set "string output" to four different values: To "hex"
     for hexadecimal format (which is the default), to "bin" for binary
     format, to "dec" for conversion to decimal numbers and to "enum" for
     conversion to enumerations (".newsrc" style sets).

     *BEWARE* that the conversion to decimal numbers is inherently slow;
     it can easily take up several seconds for a single large bit vector!

     Therefore you should store the decimal strings returned to you rather
     than converting a given bit vector again.

     *EXAMPLES:*

     The default setting as returned by the method "`Configuration()'" is:

          Scalar Input       = Bit Index
          Operator Semantics = Set Operators
          String Output      = Hexadecimal

     Performing a statement such as:

          Bit::Vector->Configuration("in=bin,ops=arithmetic,out=bin");
          print Bit::Vector->Configuration(), "\n";

     yields the following output:

          Scalar Input       = Binary
          Operator Semantics = Arithmetic Operators
          String Output      = Binary

     Note that you can always feed this output back into the
     "`Configuration()'" method to restore that setting later.

     This also means that you can enter the same given setting with almost
     any degree of verbosity you like (as long as the required keywords
     appear and no ambiguities arise).

     Note further that any aspect you do not specify is not changed, i.e.,
     the statement

          Bit::Vector->Configuration("operators = arithmetic");

     leaves all other aspects unchanged.

   * `"$vector"'

     Remember that variables enclosed in double quotes are always
     interpolated in Perl.

     Whenever a Perl variable containing the reference of a "Bit::Vector"
     object is enclosed in double quotes (either alone or together with
     other text and/or variables), the contents of the corresponding bit
     vector are converted into a printable string.

     Since there are several conversion methods available in this module
     (see the description of the methods "`to_Hex()'", "`to_Bin()'",
     "`to_Dec()'" and "`to_Enum()'"), it is of course desirable to be able
     to choose which of these methods should be applied in this case.

     This can actually be done by changing the configuration of this
     module using the method "`Configure()'" (see the previous chapter,
     immediately above).

     The default is conversion to hexadecimal.

   * `if ($vector)'

     It is possible to use a Perl variable containing the reference of a
     "Bit::Vector" object as a boolean expression.

     The condition above is true if the corresponding bit vector contains
     at least one set bit, and it is false if ALL bits of the corresponding
     bit vector are cleared.

   * `if (!$vector)'

     Since it is possible to use a Perl variable containing the reference
     of a "Bit::Vector" object as a boolean expression, you can of course
     also negate this boolean expression.

     The condition above is true if ALL bits of the corresponding bit
     vector are cleared, and it is false if the corresponding bit vector
     contains at least one set bit.

     Note that this is *NOT* the same as using the method "`is_full()'",
     which returns true if ALL bits of the corresponding bit vector are
     SET.

   * `~$vector'

     This term returns a new bit vector object which is the one's
     complement of the given bit vector.

     This is equivalent to inverting all bits.

   * `-$vector' (unary minus)

     This term returns a new bit vector object which is the two's
     complement of the given bit vector.

     This is equivalent to inverting all bits and incrementing the result
     by one.

     (This is the same as changing the sign of a number in two's complement
     binary representation.)

   * `abs($vector)'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this term either returns the
     number of set bits in the given bit vector (this is the same as
     calculating the number of elements which are contained in the given
     set) - which is the default behaviour, or it returns a new bit vector
     object which contains the absolute value of the number stored in the
     given bit vector.

   * `$vector1 . $vector2'

     This term usually returns a new bit vector object which is the result
     of the concatenation of the two bit vector operands.

     The left operand becomes the most significant, and the right operand
     becomes the least significant part of the new bit vector object.

     If one of the two operands is not a bit vector object but a Perl
     scalar, however, the contents of the remaining bit vector operand are
     converted into a string (the format of which depends on the
     configuration set with the "`Configuration()'" method), which is then
     concatenated in the proper order (i.e., as indicated by the order of
     the two operands) with the Perl scalar.

     In other words, a string is returned in such a case instead of a bit
     vector object!

   * `$vector x $factor'

     This term returns a new bit vector object which is the concatenation
     of as many copies of the given bit vector operand (the left operand)
     as the factor (the right operand) specifies.

     If the factor is zero, a bit vector object with a length of zero bits
     is returned.

     If the factor is one, just a new copy of the given bit vector is
     returned.

     Note that a fatal "reversed operands error" occurs if the two operands
     are swapped.

   * `$vector << $bits'

     This term returns a new bit vector object which is a copy of the given
     bit vector (the left operand), which is then shifted left (towards the
     most significant bit) by as many places as the right operand,
     "`$bits'", specifies.

     This means that the "`$bits'" most significant bits are lost, all
     other bits move up by "`$bits'" positions, and the "`$bits'" least
     significant bits that have been left unoccupied by this shift are all
     set to zero.

     If "`$bits'" is greater than the number of bits of the given bit
     vector, this term returns an empty bit vector (i.e., with all bits
     cleared) of the same size as the given bit vector.

     Note that a fatal "reversed operands error" occurs if the two operands
     are swapped.

   * `$vector >> $bits'

     This term returns a new bit vector object which is a copy of the given
     bit vector (the left operand), which is then shifted right (towards
     the least significant bit) by as many places as the right operand,
     "`$bits'", specifies.

     This means that the "`$bits'" least significant bits are lost, all
     other bits move down by "`$bits'" positions, and the "`$bits'" most
     significant bits that have been left unoccupied by this shift are all
     set to zero.

     If "`$bits'" is greater than the number of bits of the given bit
     vector, this term returns an empty bit vector (i.e., with all bits
     cleared) of the same size as the given bit vector.

     Note that a fatal "reversed operands error" occurs if the two operands
     are swapped.

   * `$vector1 | $vector2'

     This term returns a new bit vector object which is the result of a
     bitwise OR operation between the two bit vector operands.

     This is the same as calculating the union of two sets.

   * `$vector1 & $vector2'

     This term returns a new bit vector object which is the result of a
     bitwise AND operation between the two bit vector operands.

     This is the same as calculating the intersection of two sets.

   * `$vector1 ^ $vector2'

     This term returns a new bit vector object which is the result of a
     bitwise XOR (exclusive-or) operation between the two bit vector
     operands.

     This is the same as calculating the symmetric difference of two sets.

   * `$vector1 + $vector2'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this term either returns a new
     bit vector object which is the result of a bitwise OR operation
     between the two bit vector operands (this is the same as calculating
     the union of two sets) - which is the default behaviour, or it returns
     a new bit vector object which contains the sum of the two numbers
     stored in the two bit vector operands.

   * `$vector1 - $vector2'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this term either returns a new
     bit vector object which is the set difference of the two sets
     represented in the two bit vector operands - which is the default
     behaviour, or it returns a new bit vector object which contains the
     difference of the two numbers stored in the two bit vector operands.

   * `$vector1 * $vector2'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this term either returns a new
     bit vector object which is the result of a bitwise AND operation
     between the two bit vector operands (this is the same as calculating
     the intersection of two sets) - which is the default behaviour, or it
     returns a new bit vector object which contains the product of the two
     numbers stored in the two bit vector operands.

   * `$vector1 / $vector2'

     This term returns a new bit vector object containing the result of the
     division of the two numbers stored in the two bit vector operands.

   * `$vector1 % $vector2'

     This term returns a new bit vector object containing the remainder of
     the division of the two numbers stored in the two bit vector operands.

   * `$vector1 ** $vector2'

     This term returns a new bit vector object containing the result of the
     exponentiation of the left bit vector elevated to the right bit
     vector's power.

   * `$vector1 .= $vector2;'

     This statement "appends" the right bit vector operand (the "rvalue")
     to the left one (the "lvalue").

     The former contents of the left operand become the most significant
     part of the resulting bit vector, and the right operand becomes the
     least significant part.

     Since bit vectors are stored in "least order bit first" order, this
     actually requires the left operand to be shifted "up" by the length
     of the right operand, which is then copied to the now freed least
     significant part of the left operand.

     If the right operand is a Perl scalar, it is first converted to a bit
     vector of the same size as the left operand, provided that the
     configuration states that scalars are to be regarded as indices,
     decimal strings or enumerations.

     If the configuration states that scalars are to be regarded as
     hexadecimal or boolean strings, however, these strings are converted
     to bit vectors of a size matching the length of the input string,
     i.e., four times the length for hexadecimal strings (because each
     hexadecimal digit is worth 4 bits) and once the length for binary
     strings.

   * `$vector x= $factor;'

     This statement replaces the given bit vector by a concatenation of as
     many copies of the original contents of the given bit vector as the
     factor (the right operand) specifies.

     If the factor is zero, the given bit vector is resized to a length of
     zero bits.

     If the factor is one, the given bit vector is not changed at all.

   * `$vector <<= $bits;'

     This statement moves the contents of the given bit vector left by
     "`$bits'" positions (towards the most significant bit).

     This means that the "`$bits'" most significant bits are lost, all
     other bits move up by "`$bits'" positions, and the "`$bits'" least
     significant bits that have been left unoccupied by this shift are all
     set to zero.

     If "`$bits'" is greater than the number of bits of the given bit
     vector, the given bit vector is erased completely (i.e., all bits are
     cleared).

   * `$vector >>= $bits;'

     This statement moves the contents of the given bit vector right by
     "`$bits'" positions (towards the least significant bit).

     This means that the "`$bits'" least significant bits are lost, all
     other bits move down by "`$bits'" positions, and the "`$bits'" most
     significant bits that have been left unoccupied by this shift are all
     set to zero.

     If "`$bits'" is greater than the number of bits of the given bit
     vector, the given bit vector is erased completely (i.e., all bits are
     cleared).

   * `$vector1 |= $vector2;'

     This statement performs a bitwise OR operation between the two bit
     vector operands and stores the result in the left operand.

     This is the same as calculating the union of two sets.

   * `$vector1 &= $vector2;'

     This statement performs a bitwise AND operation between the two bit
     vector operands and stores the result in the left operand.

     This is the same as calculating the intersection of two sets.

   * `$vector1 ^= $vector2;'

     This statement performs a bitwise XOR (exclusive-or) operation
     between the two bit vector operands and stores the result in the left
     operand.

     This is the same as calculating the symmetric difference of two sets.

   * `$vector1 += $vector2;'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this statement either performs
     a bitwise OR operation between the two bit vector operands (this is
     the same as calculating the union of two sets) - which is the default
     behaviour, or it calculates the sum of the two numbers stored in the
     two bit vector operands.

     The result of this operation is stored in the left operand.

   * `$vector1 -= $vector2;'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this statement either
     calculates the set difference of the two sets represented in the two
     bit vector operands - which is the default behaviour, or it
     calculates the difference of the two numbers stored in the two bit
     vector operands.

     The result of this operation is stored in the left operand.

   * `$vector1 *= $vector2;'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this statement either performs
     a bitwise AND operation between the two bit vector operands (this is
     the same as calculating the intersection of two sets) - which is the
     default behaviour, or it calculates the product of the two numbers
     stored in the two bit vector operands.

     The result of this operation is stored in the left operand.

   * `$vector1 /= $vector2;'

     This statement puts the result of the division of the two numbers
     stored in the two bit vector operands into the left operand.

   * `$vector1 %= $vector2;'

     This statement puts the remainder of the division of the two numbers
     stored in the two bit vector operands into the left operand.

   * `$vector1 **= $vector2;'

     This statement puts the result of the exponentiation of the left
     operand elevated to the right operand's power into the left operand.

   * `++$vector', `$vector++'

     This operator performs pre- and post-incrementation of the given bit
     vector.

     The value returned by this term is a reference of the given bit
     vector object (after or before the incrementation, respectively).

   * `--$vector', `$vector--'

     This operator performs pre- and post-decrementation of the given bit
     vector.

     The value returned by this term is a reference of the given bit
     vector object (after or before the decrementation, respectively).

   * `($vector1 cmp $vector2)'

     This term returns "`-1'" if "`$vector1'" is less than "`$vector2'",
     "0" if "`$vector1'" and "`$vector2'" are the same, and "1" if
     "`$vector1'" is greater than "`$vector2'".

     This comparison assumes UNSIGNED bit vectors.

   * `($vector1 eq $vector2)'

     This term returns true ("1") if the contents of the two bit vector
     operands are the same and false ("0") otherwise.

   * `($vector1 ne $vector2)'

     This term returns true ("1") if the two bit vector operands differ
     and false ("0") otherwise.

   * `($vector1 lt $vector2)'

     This term returns true ("1") if "`$vector1'" is less than
     "`$vector2'", and false ("0") otherwise.

     This comparison assumes UNSIGNED bit vectors.

   * `($vector1 le $vector2)'

     This term returns true ("1") if "`$vector1'" is less than or equal to
     "`$vector2'", and false ("0") otherwise.

     This comparison assumes UNSIGNED bit vectors.

   * `($vector1 gt $vector2)'

     This term returns true ("1") if "`$vector1'" is greater than
     "`$vector2'", and false ("0") otherwise.

     This comparison assumes UNSIGNED bit vectors.

   * `($vector1 ge $vector2)'

     This term returns true ("1") if "`$vector1'" is greater than or equal
     to "`$vector2'", and false ("0") otherwise.

     This comparison assumes UNSIGNED bit vectors.

   * `($vector1 <=> $vector2)'

     This term returns "`-1'" if "`$vector1'" is less than "`$vector2'",
     "0" if "`$vector1'" and "`$vector2'" are the same, and "1" if
     "`$vector1'" is greater than "`$vector2'".

     This comparison assumes *SIGNED* bit vectors.

   * `($vector1 == $vector2)'

     This term returns true ("1") if the contents of the two bit vector
     operands are the same and false ("0") otherwise.

   * `($vector1 != $vector2)'

     This term returns true ("1") if the two bit vector operands differ
     and false ("0") otherwise.

   * `($vector1 < $vector2)'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this term either returns true
     ("1") if "`$vector1'" is a true subset of "`$vector2'" (and false
     ("0") otherwise) - which is the default behaviour, or it returns true
     ("1") if "`$vector1'" is less than "`$vector2'" (and false ("0")
     otherwise).

     The latter comparison assumes *SIGNED* bit vectors.

   * `($vector1 <= $vector2)'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this term either returns true
     ("1") if "`$vector1'" is a subset of "`$vector2'" (and false ("0")
     otherwise) - which is the default behaviour, or it returns true ("1")
     if "`$vector1'" is less than or equal to "`$vector2'" (and false
     ("0") otherwise).

     The latter comparison assumes *SIGNED* bit vectors.

   * `($vector1 > $vector2)'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this term either returns true
     ("1") if "`$vector1'" is a true superset of "`$vector2'" (and false
     ("0") otherwise) - which is the default behaviour, or it returns true
     ("1") if "`$vector1'" is greater than "`$vector2'" (and false ("0")
     otherwise).

     The latter comparison assumes *SIGNED* bit vectors.

   * `($vector1 >= $vector2)'

     Depending on the configuration (see the description of the method
     "`Configuration()'" for more details), this term either returns true
     ("1") if "`$vector1'" is a superset of "`$vector2'" (and false ("0")
     otherwise) - which is the default behaviour, or it returns true ("1")
     if "`$vector1'" is greater than or equal to "`$vector2'" (and false
     ("0") otherwise).

     The latter comparison assumes *SIGNED* bit vectors.

SEE ALSO
========

   Bit::Vector(3), Set::IntRange(3), Math::MatrixBool(3),
Math::MatrixReal(3), DFA::Kleene(3), Math::Kleene(3), Graph::Kruskal(3).

   perl(1), perlsub(1), perlmod(1), perlref(1), perlobj(1), perlbot(1),
perltoot(1), perlxs(1), perlxstut(1), perlguts(1), overload(3).

VERSION
=======

   This man page documents "Bit::Vector::Overload" version 6.0.

AUTHOR
======

     Steffen Beyer
     mailto:sb@engelschall.com
     http://www.engelschall.com/u/sb/download/

COPYRIGHT
=========

   Copyright (c) 1995 - 2000 by Steffen Beyer. All rights reserved.

LICENSE
=======

   This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself, i.e., under the terms of the
"Artistic License" or the "GNU General Public License".

   The C library at the core of this Perl module can additionally be
redistributed and/or modified under the terms of the "GNU Library General
Public License".

   Please refer to the files "Artistic.txt", "GNU_GPL.txt" and
"GNU_LGPL.txt" in this distribution for details!

DISCLAIMER
==========

   This package is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.

   See the "GNU General Public License" for more details.


File: pm.info,  Node: Bleach,  Next: BnP,  Prev: Bit/Vector/Overload,  Up: Module List

For *really* clean programs
***************************

NAME
====

   Bleach - For *really* clean programs

SYNOPSIS
========

     use Bleach;

     print "Hello world";

DESCRIPTION
===========

   The first time you run a program under `use Bleach', the module removes
all the unsightly printable characters from your source file.  The code
continues to work exactly as it did before, but now it looks like this:

     use Bleach;

DIAGNOSTICS
===========

`Can't bleach '%s''
     Bleach could not access the source file to modify it.

`Can't rebleach '%s''
     Bleach could not access the source file to execute it.

AUTHOR
======

   Damian Conway (as if you couldn't guess)

COPYRIGHT
=========

     Copyright (c) 2001, Damian Conway. All Rights Reserved.
      This module is free software. It may be used, redistributed
     and/or modified under the terms of the Perl Artistic License
       (see http://www.perl.com/perl/misc/Artistic.html)


File: pm.info,  Node: BnP,  Next: Bone/Easy,  Prev: Bleach,  Up: Module List

implements the automatic recovery mechanism of "Build'n'Play"
*************************************************************

NAME
====

   BnP - implements the automatic recovery mechanism of "Build'n'Play"

PREFACE
=======

   This module provides an automatic recovery mechanism for installation
scripts (for installing any kind of Unix software package) written in Perl.

   A special log file (called the "automatic recovery file") is used by
this module in which all the commands (i.e., method calls of command
methods provided by this module) are recorded which have been executed
successfully.

   When you restart your installation script later, the commands found in
this automatic recovery file will not be executed again.

   The module provides a comprehensive set of command methods for fetching
source distribution files automatically, for manipulating (e.g., unpacking
and building) them in every possible way (using "`system()'" calls), for
making and changing directories, for patching files (in a manner resembling
the Unix tool "`sed'"), for defining subsections in your installation
scripts and for commenting out certain parts, plus some functions of
general utility.

SYNOPSIS
========

     use BnP;

Functions:
----------

     info
         info "MESSAGE", ...;  #  print

     alert
         alert "MESSAGE", ...;  #  warn

     fatal
         fatal "MESSAGE", ...;  #  die

     find
         $path = find("FILENAME", "SEARCHPATH");

     indispensable
         indispensable("FILENAME", ...);

     normalize
         $file = normalize("FILENAME");

     follow
         $file = follow("FILENAME");

     absolute
         $file = absolute("FILENAME");

     expand
         $file = expand("FILENAME");

Methods:
--------

     new
         $BnP = BnP->new($target,$subset,$prefix,$homedir,$workspace);

     target
         $target = $BnP->target();

     subset
         $subset = $BnP->subset();

     prefix
         $prefix = $BnP->prefix();

     homedir
         $homedir = $BnP->homedir();

     workspace
         $workspace = $BnP->workspace();

     path
         [ @path = ] $BnP->path( @path );
         @path = $BnP->path();

     stub
         [ @stub = ] $BnP->stub( @stub );
         @stub = $BnP->stub();

     url
         [ @url = ] $BnP->url( @url );
         @url = $BnP->url();

     begin
         $BnP->begin();

     end
         $BnP->end();

     begin_section
         $BnP->begin_section("NAME", ...);

     end_section
         $BnP->end_section("NAME", ...);

     begin_must_section
         $BnP->begin_must_section();

     end_must_section
         $BnP->end_must_section();

     begin_lazy_section
         $BnP->begin_lazy_section("NAME", ...);

     end_lazy_section
         $BnP->end_lazy_section("NAME", ...);

     ignore
         $BnP->ignore();

     resume
         $BnP->resume();

     active
         $flag = $BnP->active();

     reset
         $BnP->reset();

     back
         $BnP->back();
         $BnP->back(COUNT);

     chdir
         $BnP->chdir("DIR");

     mkdir
         $BnP->mkdir("DIR");

     fetch
         $BnP->fetch("FILENAME", "RELPATH", "SOURCEDIR");

     system
         $BnP->system("COMMAND", ...);

     patch
         $BnP->patch("FILENAME", "PERLEXPR", ...);

DESCRIPTION
===========

Functions:
----------

   * `info "MESSAGE", ...;'  #  print

     This function can be used to print informational messages to STDOUT
     (or to whatever file handle your program has currently "select"ed).

     All parameters of this function are concatenated without any
     intervening characters (i.e., without adding any spaces).

     A prefix of "BnP:   " and a trailing "\n" is added automatically.

     Moreover, the output is written unbuffered, i.e., even if it is not
     sent to a terminal, the output should appear immediately in the
     corresponding file or pipe.

   * `alert "MESSAGE", ...;'  #  warn

     This function can be used to print warning messages to STDERR (using
     "warn", internally).

     All parameters of this function are concatenated without any
     intervening characters (i.e., without adding any spaces).

     A prefix of "BnP: ! " and a trailing "\n" is added automatically.

   * `fatal "MESSAGE", ...;'  #  die

     This function can be used to print an error message to STDERR, with
     immediately ensuing program abortion (using "die", internally).

     All parameters of this function are concatenated without any
     intervening characters (i.e., without adding any spaces).

     A prefix of "BnP: ! " and a trailing "\n" is added automatically.

   * `$path = find("FILENAME", "SEARCHPATH");'

     This function can be used to find any readable (operator "-r") and
     non-empty (operator "-s") file in a given searchpath (i.e., a list of
     directories concatenated with ":") whose filename is given.

     The function returns the absolute path of the requested file if the
     file was found in the given searchpath, or an empty string otherwise.

     For example:

          $shell = find('sh', $ENV{'PATH'});

     This should return "/bin/sh".

   * `indispensable("FILENAME", ...);'

     This function checks wether all the files whose filenames are given
     can be found in the current "`$PATH'" environment variable
     ("`$ENV{'PATH'}'") using the function "`find()'" (see above)
     internally.

     An error message is printed and program execution is aborted if any of
     the files in the list cannot be found.

     The function returns silently if all the files have been found.

   * `$file = normalize("FILENAME");'

     This function "normalizes" a given filename, i.e., it reduces
     consecutive slashes ("/") and consecutive terms of the form "`/./'"
     to a single slash, and removes a dot-slash ("`./'") at the beginning
     and a slash-dot ("`/.'")  or slash ("/") at the end.

     Moreover, terms of the form "`/dir/../'" (where "dir" is not an empty
     string, contains no slashes and is not equal to "`..'") are
     iteratively reduced to a single slash each, until no more terms of
     this kind can be found.

   * `$file = follow("FILENAME");'

     If the given filename (given as an absolute path or as a path
     relative to the current working directory) is a symbolic link, this
     function follows this symbolic link iteratively, as long as the
     resulting filename is also a symbolic link, until the end of the
     chain of symbolic links is reached.

     This last filename is then returned.

     If the given filename is not a symbolic link, it is simply
     "normalized" using the function "`normalize()'" (see above) and then
     returned.

   * `$file = absolute("FILENAME");'

     If the given filename is an absolute path, it is returned unchanged.

     Otherwise the output of "`/bin/pwd'" is prepended to it and the new
     filename is returned.

   * `$file = expand("FILENAME");'

     While the function "`follow()'" (see above) only expands the
     "basename" part of a given filename if it is a symbolic link (whereas
     the "dirname" part remains unchanged), this function expands ALL
     symbolic links encountered in a given filename, yielding the true
     physical (absolute) path of the file or directory in question.

     If the given filename is relative, it is first converted into an
     absolute path using the function "absolute()" (see above).

     If a file or directory of the given name does not exist, all symbolic
     links are expanded as far as possible (as far as the leading (left)
     part of the given filename matches existing directories and symbolic
     links).

Methods:
--------

   * `$BnP = BnP->new($target,$subset,$prefix,$homedir,$workspace);'

     This is the "Build'n'Play" installation project constructor method.

     In theory you can perform several installations simultaneously; each
     installation thereby has a variable space of its own, which is stored
     in the object returned by this method.

  -
     The parameter "$target" specifies a name for the installation project.
     This name has only informational character in this module, though.

  -
     The parameter "`$subset'" specifies a list of subtargets (as a single
     string, in which the different elements are concatenated with ".")
     which enable the corresponding sections in your installation script
     as defined by the "`begin_section()'", "`end_section()'",
     "`begin_lazy_section()'" and "`end_lazy_section()'" method calls in
     your script (see further below for a description of these methods).

  -
     The parameter "`$prefix'" specifies the installation prefix, e.g.
     "`/usr/local'", "`/opt/pkg/<target>'" etc.

     If this parameter is empty or contains only whitespace, the prefix is
     set to "`/usr/local'" by default.

  -
     The parameter "`$homedir'" specifies the home directory of the
     installation project, i.e., the directory where the automatic
     recovery file ("`recover.bnp'") for this project will be stored.

     A subdirectory named "src" in this directory is usually the place
     where all the necessary source distribution files are stored, but
     this is something controlled entirely by your installation script.

     Note that simultaneous installations must have different home
     directories, otherwise they will overwrite each other's automatic
     recovery file ("`recover.bnp'") in that directory.

  -
     The parameter "`$workspace'" specifies a directory where the source
     distribution files can be temporarily unpacked and compiled.

     This is also the directory the method "reset()" (see further below)
     performs a "chdir()" to.


     Note that it is technically possible to subclass the class implemented
     in this module and to inherit this constructor method.


     `$target = $BnP->target();'

     This method returns the name of the current installation project as
     defined in the call of the installation project constructor method
     "new()" (see above for details).


     `$subset = $BnP->subset();'

     This method returns the string containing the names of the sections in
     your installation script to be processed, as defined in the call of
     the installation project constructor method "new()" (see above for
     details).


     `$prefix = $BnP->prefix();'

     This method returns the prefix of the current installation project as
     defined in the call of the installation project constructor method
     "new()" (see above for details).


     `$homedir = $BnP->homedir();'

     This method returns the home directory of the current installation
     project as defined in the call of the installation project
     constructor method "new()" (see above for details).


     `$workspace = $BnP->workspace();'

     This method returns the directory used as a temporary workspace by the
     current installation project (several simultaneous installations may
     use the same workspace directory, unless they try to unpack
     distributions which result in a distribution directory of exactly the
     same name), as defined in the call of the installation project
     constructor method "new()" (see above for details).

     Note also that provisions need to be made (i.e., an appropriate
     subdirectory has to be created first) if you unpack any misbehaving
     distributions which do not create a distribution directory first
     themselves but simply spill their contents into the current working
     directory.


     `[ @path = ] $BnP->path( @path );'


     `@path = $BnP->path();'

     This method allows you to define a number of base directories where to
     search for source distribution files (see also the description of the
     method "fetch()" further below) in your local file system (e.g., on
     your hard disk, on a CD-ROM, etc.).

     Several directory names may be concatenated with ":" to form a single
     argument, or they can be passed as separate arguments. You can also
     mix these two forms.

     Note that any previous setting is REPLACED by the given arguments,
     i.e., this method is NOT accumulative.

     The method returns a list with all the directory names that have been
     passed to it (previously, or in the current call).

     If you call this method without parameters, the current setting is
     returned but not changed.

     Example:

          $BnP->path( '/mirrors:/cdrom', `pwd` );

     Trailing slashes ("/") will be removed automatically.

     Note that these directories must be given by their absolute path,
     because the current directory will usually change frequently over the
     course of your installation.

     Note also that these directories will always be searched in the given
     order (from left to right).

     Finally, note that this setting is cleared by the "`begin()'" and
     "end()" methods (see further below).

     (This setting is initialized to an empty list by the constructor
     method "new()".)


     `[ @stub = ] $BnP->stub( @stub );'


     `@stub = $BnP->stub();'

     This method allows you to define a number of subdirectories where to
     search for source distribution files (see also the description of the
     method "fetch()" further below) in your local file system (e.g., on
     your hard disk, on a CD-ROM, etc.).

     Several subdirectory names may be concatenated with blanks (" ") to
     form a single argument, or they can be passed as separate arguments.
     You can also mix these two forms.

     Note that any previous setting is REPLACED by the given arguments,
     i.e., this method is NOT accumulative.

     The method returns a list with all the subdirectory names that have
     been passed to it (previously, or in the current call).

     If you call this method without parameters, the current setting is
     returned but not changed.

     Example:

          $BnP->stub( 'CPAN', 'BnP/src', 'BnP', 'src' );

     Note that these subdirectories must be given as relative paths (any
     leading or trailing slash ("/") will be stripped anyway, however).

     Note also that these subdirectories will always be searched in the
     given order (from left to right) and that (moreover) the subdirectory
     "."  is always implicitly assumed to be at the beginning of this list.

     (As a consequence, if you don't need this feature of search
     subdirectories, you don't need to bother with this method at all,
     just leave this setting empty as it is initialized by the constructor
     method "new()".)

     When searching for a source distribution file, each of these
     subdirectories will in turn be appended to every base directory as
     defined by the "path()" method (see above) to form the list of actual
     directories to be searched (i.e., the search path is the set product
     of the directories defined with the "path()" method and the
     subdirectories defined with the "`stub()'" method).

     Finally, note that this setting is cleared by the "`begin()'" and
     "end()" methods (see further below).


     `[ @url = ] $BnP->url( @url );'


     `@url = $BnP->url();'

     This method allows you to define a number of URLs where to download
     source distribution files from which haven't been found in your local
     file system (see also the description of the method "fetch()" further
     below).

     Several URLs may be concatenated using blanks (" ") to form a single
     argument, or they can be passed as separate arguments. You can also
     mix these two forms.

     Note that any previous setting is REPLACED by the given arguments,
     i.e., this method is NOT accumulative.

     The method returns a list with all the URLs that have been passed to
     it (previously, or in the current call).

     If you call this method without parameters, the current setting is
     returned but not changed.

     Example:

          $BnP->url
          (
              'ftp://ftp.engelschall.com/pub/bnp ftp://ftp.netsw.org/netsw'
          );

     Note that these URLs should usually terminate in the name of a
     directory but should nevertheless NOT have a trailing slash!

     Note also that these URLs will always be searched in the given order
     (from left to right).

     Finally, note that this setting is cleared by the "`begin()'" and
     "end()" methods (see below).


     `$BnP->begin();'

     This method call starts the actual installation.

     A (possibly) still open automatic recovery file is closed, and all
     internal attributes of the current installation project (except the
     ones which contain the parameters passed to the installation project
     constructor method "new()") are reset to their default values (this
     is so that you can use the same installation project object several
     times in sequence).

     The method then checks wether an automatic recovery file
     "`recover.bnp'" already exists for the current installation project,
     and if so, reads it in.

     (The contents of the automatic recovery file are then stored in
     memory in the given installation project object for fastest possible
     access.)

     Moreover, if it exists, this automatic recovery file is renamed (its
     suffix "`.bnp'" is thereby replaced by a 3-digit number which is the
     smallest such number which hasn't been assigned yet, by starting at
     "`000'" and incrementing as necessary), and a new recovery file is
     created and opened for writing.

     A header line showing the name and version number of this module as
     well as a confirmation for some of your calling parameters is printed
     to the screen, and a "chdir()" is made via the method "reset()" (see
     also further below) to the directory "`$workspace'", as defined in
     the call of the installation project constructor method "new()" (see
     above for details).


     `$BnP->end();'

     This method call terminates the actual installation.

     First the automatic recovery file is closed (nothing is done if the
     file has already been closed before, for instance by a previous call
     of this method).

     Then all internal attributes of the current installation project
     (except the ones which contain the parameters passed to the
     installation project constructor method "new()") are reset to their
     default values (this is so that you can use the same installation
     project object several times in sequence).

     Finally, a message confirming the successful installation is printed
     to the screen.


     `$BnP->begin_section("NAME", ...);'

     This method call marks the beginning of a named section in your
     installation script.

     You can pass several names (or "labels") to this method, which will
     be treated as synonyms for the section in question.

     I.e., specifying ANY of these labels from this method call in the
     parameter "`$subset'" at runtime (via the "new()" constructor method
     - see above) will enable the commands in the corresponding section.

     If none of the subtargets specified in the parameter "`$subset'"
     matches any of the labels in this method call, then the commands in
     the corresponding section will be disabled - unless the parameter
     "`$subset'" is empty, in which case the "`begin_section()'" and
     "`end_section()'" (see below) method calls are simply ignored
     altogether.

     (An empty parameter "`$subset'" means "install ALL sections",
     therefore the "`begin_section()'" and "`end_section()'" method calls
     need not to be evaluated in such a case.)

     This way you can also define the section in question as being part of
     a set of sections forming a larger whole, or mark parts which are
     prerequisites of other sections, as in the following example:

          $BnP->begin_section("net","mail","news");
          # install net software (prerequisite for mail and news)
          $BnP->end_section("net","mail","news");
          ...
          $BnP->begin_section("mail");
          # install mail software
          $BnP->end_section("mail");
          ...
          $BnP->begin_section("news");
          # install news software
          $BnP->end_section("news");

     If the runtime parameter "`$subset'" contains "net", only the "net"
     portion will be installed. If it contains "mail", the "net" portion
     as well as the "mail" part itself will be installed. If it contains
     "mail" AND "news", all three parts will be installed, and so on.


     `$BnP->end_section("NAME", ...);'

     This method call marks the end of one or several named sections in
     your installation script.

     If any of the labels listed in this method call matches any of the
     subtargets given in the runtime parameter "`$subset'" - provided that
     the latter is not empty - then the execution of all commands
     following this method call is disabled.

     If there is no match, the commands following this method call will
     continue to be executed.

     If the runtime parameter "`$subset'" is empty, this method call is
     ignored altogether.

     This allows you to terminate different sections at different times,
     as in the following example:

          $BnP->begin_section("net","mail");
          # install net software (prerequisite for mail)
          $BnP->end_section("net");
          # install mail software
          $BnP->end_section("mail");

     If the runtime parameter "`$subset'" contains "net", only the "net"
     portion will be installed. If it contains "mail", the "net" portion
     as well as the "mail" part itself will be installed.


     `$BnP->begin_must_section();'

     This method call marks the beginning of a section in your installation
     script which is executed under all circumstances.

     This method takes no arguments; all arguments passed to it are
     ignored.

     This method call takes precedence over all other method calls
     defining the beginning or end of any overlapping section, but it
     doesn't impede their (invisible) working, as in the following example:

          $BnP->begin_section("a");
          # commands 1
          $BnP->begin_must_section();
          # commands 2
          $BnP->end_section("a");
          # commands 3
          $BnP->begin_section("b");
          # commands 4
          $BnP->end_must_section();
          # commands 5
          $BnP->end_section("b");

     In this example, the commands "2", "3" and "4" are ALWAYS executed,
     regardless of the contents of the runtime parameter "`$subset'".

     The commands "1" will be executed only if the runtime parameter
     "`$subset'" is empty or if it contains "a". The commands "5" will be
     executed only if the runtime parameter "`$subset'" is empty or if it
     contains "b".


     `$BnP->end_must_section();'

     This method call marks the end of a section in your installation
     script which is executed under all circumstances.

     This method takes no arguments; all arguments passed to it are
     ignored.


     `$BnP->begin_lazy_section("NAME", ...);'

     This method call marks the beginning of a section in your installation
     script which will be executed ONLY if you specify at least ONE of the
     labels listed in this method call EXPLICITLY as part of the runtime
     parameter "`$subset'", i.e., this is some kind of a "lazy" or
     "delayed" evaluation section.

     This method call takes precedence over any overlapping sections
     defined via the "`begin_section()'" and "`end_section()'" pair of
     methods, as shown in the following example:

          $BnP->begin_section("a");
          # commands 1
          $BnP->begin_lazy_section("x");
          # commands 2
          $BnP->end_section("a");
          # commands 3
          $BnP->begin_section("b");
          # commands 4
          $BnP->end_lazy_section("x");
          # commands 5
          $BnP->end_section("b");

     In this example, the commands "2", "3" and "4" are executed if and
     only if the runtime parameter "`$subset'" contains "x".

     The commands "1" will be executed only if the runtime parameter
     "`$subset'" is empty or if it contains "a". The commands "5" will be
     executed only if the runtime parameter "`$subset'" is empty or if it
     contains "b".

     Overlapping "lazy" sections behave sligthly differently, as
     illustrated in the following example:

          $BnP->begin_lazy_section("a","c");
          # commands 1
          $BnP->begin_lazy_section("b");
          # commands 2
          $BnP->end_lazy_section("a");
          # commands 3
          $BnP->end_lazy_section("b","c");

     In this example, the commands "1" and "2" are executed if the runtime
     parameter "`$subset'" contains "a" (or "c").

     The commands "2" and "3" are executed if the runtime parameter
     "`$subset'" contains "b" (or "c").

     None of these commands is executed if the runtime parameter
     "`$subset'" contains neither "a" nor "b" (nor "c"), and all of these
     commands are executed if "`$subset'" contains "a" as well as "b" (or
     just "c").


     `$BnP->end_lazy_section("NAME", ...);'

     This method call marks the end of one or several named "lazy" sections
     in your installation script.


     `$BnP->ignore();'

     This method call can be used to "comment out" all subsequent commands
     until the next occurrence of a "`resume()'" method call (see also
     below).

     This method call takes precedence over all others, even "must"
     sections and "lazy" sections (see also their corresponding
     descriptions above).

     This method call does not impede the "section" method calls from
     working, however, it just prevents any actions to be actually
     performed, as shown in the following example:

          $BnP->begin_section("a");
          # commands 1
          $BnP->ignore();
          # commands 2
          $BnP->end_section("a");
          # commands 3
          $BnP->begin_section("b");
          # commands 4
          $BnP->resume();
          # commands 5
          $BnP->end_section("b");

     In this example, the commands "2", "3" and "4" are NEVER executed,
     regardless of the contents of the runtime parameter "`$subset'".

     The commands "1" will be executed only if the runtime parameter
     "`$subset'" is empty or if it contains "a". The commands "5" will be
     executed only if the runtime parameter "`$subset'" is empty or if it
     contains "b".


     `$BnP->resume();'

     This method call ends a section of your installation script which has
     been "commented out".

     Normal operation of your installation script resumes after this
     method call.

     Note that you cannot nest "`ignore()'" and "`resume()'" method calls;
     the first "`ignore()'" method encountered will disable all following
     commands, and the first "`resume()'" method encountered will enable
     execution again:

          $BnP->ignore();
          # commands 1
          $BnP->ignore();
          # commands 2
          $BnP->resume();
          # commands 3
          $BnP->resume();
          # commands 4

     In this example, the commands "1" and "2" will never be executed, and
     execution resumes at commands "3", not "4" (which means that both
     commands "3" and "4" are executed, in this example).


     `$flag = $BnP->active();'

     This method returns "`true'" if it is called from within a section
     which is currently being executed (for instance, this method ALWAYS
     returns "`true'" when called from within a "must" section), or "false"
     otherwise.

     In particular, this method also reports "false" if called from within
     a part in your installation script that has been "commented out" with
     the "`ignore()'" and "`resume()'" pair of methods.


     `$BnP->reset();'

     This method does nothing but a "chdir()" (see below) to the directory
     "`$workspace'", as defined in the call of the installation project
     constructor method "new()" (see above for details).


     `$BnP->back();'

     This method is just a shorthand for "`$BnP->chdir('../');'".


     `$BnP->back(COUNT);'

     This method is just a shorthand for "`$BnP->chdir('../' x COUNT);'",
     where "`COUNT'" is replaced by "1" if it is less than one.


     `$BnP->chdir("DIR");'

     This method can be used to change the current working directory for
     all subsequent commands which implicitly act upon it (all Unix and
     Perl commands dealing with files and directories normally do, if no
     absolute paths are given).

     The parameter "DIR" may be an absolute or a relative path. In the
     latter case this path will be relative to the current working
     directory as defined previously.

     At the beginning of the installation, the method "`begin()'" sets the
     current working directory to "`$workspace'", as defined in the call
     of the installation project constructor method "new()" (see above for
     details), using the method "reset()" (see above).


     `$BnP->mkdir("DIR");'

     This method can be used to create a new directory.

     If the directory's path "DIR" is not absolute, it will be relative to
     the current working directory, as defined previously using the methods
     "reset()", "chdir()" and "`back()'" (see above for details).

     In contrast to the Unix or Perl "mkdir" commands, this method will
     also automatically and recursively create any missing intervening
     directories; i.e., if the directory "/tmp" does not contain any
     subdirectories, then the method call
     "`$BnP->mkdir('/tmp/bnp/hmtl/mod');'" will first create the directory
     "`/tmp/bnp'", then the directory "`/tmp/bnp/html'", and finally the
     directory "`/tmp/bnp/html/mod'".

     The method does nothing (and does NOT produce any error message) if
     the directory to be created already exists.


     `$BnP->fetch("FILENAME", "RELPATH", "SOURCEDIR");'

     This method fetches a distribution file from a predefined search path
     or (if necessary) a list of URLs and puts it into the specified source
     directory.

     The method does nothing if the distribution file is already found in
     the given source directory.

     Otherwise it searches the directories which have been specified
     previously by the "path()" and "`stub()'" methods (see further
     above), in their given order.

     The method thereby cycles through all the directories specified by
     "path()".  It first tests any such directory wether it contains the
     requested distribution file. If not, the method cycles through all
     the subdirectories as specified by "`stub()'" and tests each of these
     subdirectories in the currently examined directory. If the test fails
     for a subdirectory, the method also tests the subsubdirectory
     "RELPATH" in that subdirectory.

     If the requested distribution file is found in any of these
     directories or (sub-) subdirectories, the method first attempts to
     create a symbolic link in the given source directory which points to
     the location where the distribution file has been found.

     Should this fail for some reason (e.g. if your system does not support
     symbolic links), the method alternatively tries to copy the
     distribution file to the specified source directory.

     If this also fails (for instance in case of disk capacity overrun),
     the method gives up and throws a (fatal) exception.

     If the requested distribution file is not found in any of these
     directories, the method tries to find a tool for the automatic
     download.

     If none of the configured tools (currently "snarf" and "lynx") can be
     found on your system, a fatal exception follows.

     Otherwise the method searches the URLs which have been specified
     previously by the "`url()'" method (see further above), in the given
     order.

     The method thereby cycles through all the URLs specified by
     "`url()'", to each of which the relative path "RELPATH" and the
     filename "FILENAME" is appended (for this reason the given URLs
     should not end in as slash "/"!).

     If the requested distribution file cannot be downloaded successfully
     from any of these URLs, a corresponding error message is printed to
     the screen and program execution is aborted.

     Note that this may be due to a server being down temporarily, so
     sometimes you may just need to restart your installation script in
     order to succeed, or specify a different server.

     If the distribution file is found on one of the specified servers, it
     is downloaded into the given source directory "SOURCEDIR" and the
     method returns to the caller.


     `$BnP->system("COMMAND", ...);'

     This method allows you to use any (shell) commands you may need while
     still benefiting from the automatic recovery mechanism provided by
     this module.

     All the arguments to this method are concatenated using spaces, i.e.,
     you don't need to include spaces at the beginning and the end of
     these arguments, and you don't need to concatenate them with the
     "."-operator yourself (you will have to supply those spaces yourself
     if you do, however).

     Since all the arguments are concatenated, they form a single command
     line.

     In order to include several different commands on that same command
     line, use the semicolon ("`;'") to separate them, as usually.


     `$BnP->patch("FILENAME", "PERLEXPR", ...);'

     This method resembles the Unix tool "`sed'".

     It allows you to apply arbitrary Perl expressions (typically
     substitution commands like "s///" and "tr///") to the lines (or
     paragraphs or the entire file at once) of the given file.

     (The lines (or paragraphs or the entire file) of the file in question
     are thereby successively read into the Perl variable "$_".)

     Before actually applying any modifications, a new filename for the
     original file is generated (for later safeguarding), by appending
     ".000" to its name and increasing this number if a file of that name
     already exists, until a filename is found which doesn't exist yet.

     Another new (temporary) filename is generated (in the same manner)
     for the file which will hold the results of the "patch" operation, by
     using the number found in the previous step plus one, and again by
     incrementing this number if a file of that name already exists, until
     a filename is found which doesn't exist yet.

     Then the original file is read, all the commands given as arguments to
     this method are applied successively (in the given order) to each of
     the lines (or paragraphs or the entire file) being read, and the
     results are written to a new file with the (temporary) filename (the
     second of the two filenames generated above).

     Note that you can control the "line" vs. "paragraph" vs. "entire
     file" mode by setting the Perl variable "$/" appropriately (see
     `perlvar(1)' in this node for more details).

     (Don't forget to reset this variable to its default value in order to
     avoid unexpected results in the remaining part of your script,
     though.)

     After reading all of the original file, and only if no errors
     occurred, the original file is renamed to the first of the two new
     filenames generated above, and the file containing the results of the
     "patch" operation is renamed to the (original) filename of the
     original file.

     In case of an error (most likely a Perl syntax error in one of the
     expressions you supplied as arguments to this method), all files are
     closed, the temporary file containing the results (if any) is
     deleted, an appropriate error message is displayed and program
     execution is aborted.

MODERATED METHODS
=================

   The following methods are subject to be switched "off" and "on" by the
methods "`begin_section()'", "`end_section()'", "`begin_must_section()'",
"`end_must_section()'", "`begin_lazy_section()'", "`end_lazy_section()'",
"`ignore()'" and "`resume()'":

     -  reset()
     -  back()
     -  chdir()
     -  mkdir()
     -  fetch()
     -  system()
     -  patch()

   You can always determine wether these methods will currently (i.e., in
the current section of your installation script) be executed or ignored by
calling the method "`active()'", which returns "`true'" if the section in
question is "active" and "false" if the commands in that section will
currently be ignored.

SEE ALSO
========

   build(1), genopt(1), make(1), CPAN(3).

VERSION
=======

   This man page documents "BnP" version 2.1.0.

AUTHORS
=======

     Ralf S. Engelschall - original idea and first private versions

     rse@engelschall.com
     www.engelschall.com

     Steffen Beyer       - complete rewrite and documentation
                           (first public version)

     sb@engelschall.com
       www.engelschall.com/u/sb/download/

COPYRIGHT
=========

     Copyright (c) 1996 - 1998 by Ralf S. Engelschall.
     All rights reserved.

     Copyright (c) 1998 by Steffen Beyer.
     All rights reserved.

LICENSE
=======

   This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself, i.e., under the terms of the
"Artistic License" or the "GNU General Public License".

   Please refer to the files "Artistic.txt" and "GNU_GPL.txt" in this
distribution for details!

DISCLAIMER
==========

   This package is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.

   See the "GNU General Public License" for more details.


