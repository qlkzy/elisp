This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Net/IMAP/Simple,  Next: Net/IP,  Prev: Net/IMAP,  Up: Module List

Perl extension for simple IMAP account handling, mostly  compatible with Net::POP3.
***********************************************************************************

NAME
====

   Net::IMAP::Simple - Perl extension for simple IMAP account handling,
mostly compatible with Net::POP3.

SYNOPSIS
========

     use Net::IMAP::Simple;

     # open a connection to the IMAP server
     $server = new Net::IMAP::Simple( 'someserver' );

     # login
     $server->login( 'someuser', 'somepassword' );
     
     # select the desired folder
     $number_of_messages = $server->select( 'somefolder' );

     # go through all the messages in the selected folder
     foreach $msg ( 1..$number_of_messages ) {

     if ( $server->seen( $msg ) {
         print "This message has been read before...\n"
     }

     # get the message, returned as a reference to an array of lines
     $lines = $server->get( $msg );

     # print it
     print @$lines;

     # get the message, returned as a temporary file handle
     $fh = $server->getfh( $msg );
     print <$fh>;
     close $fh;

     }

     # the list of all folders
     @folders = $server->mailboxes();

     # create a folder
     $server->create_mailbox( 'newfolder' );

     # rename a folder
     $server->rename_mailbox( 'newfolder', 'renamedfolder' );

     # delete a folder
     $server->delete_mailbox( 'renamedfolder' );

     # copy a message to another folder
     $server->copy( $self, $msg, 'renamedfolder' );

     # close the connection
     $server->quit();

DESCRIPTION
===========

   This module is a simple way to access IMAP accounts. The API is mostly
equivalent to the Net::POP3 one, with some aditional methods for mailbox
handling.

BUGS
====

   I don't know how the module reacts to nested mailboxes.

   This module was only tested under the following servers:

   * Netscape IMAP4rev1 Service 3.6

   * MS Exchange 5.5.1960.6 IMAPrev1 (Thanks to Edward Chao)

   * Cyrus IMAP Server v1.5.19 (Thanks to Edward Chao)

   Expect some problems with servers from other vendors (then again, if
all of them are implementing the IMAP protocol, it should work - but we
all know how it goes).

AUTHOR
======

   Joao Fonseca, joao_g_fonseca@yahoo.com

SEE ALSO
========

   Net::IMAP(1), Net::POP3(1).

COPYRIGHT
=========

   Copyright (c) 1999 Joao Fonseca. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Net/IP,  Next: Net/IPv4Addr,  Prev: Net/IMAP/Simple,  Up: Module List

Perl extension for manipulating IPv4/IPv6 addresses
***************************************************

NAME
====

   IP - Perl extension for manipulating IPv4/IPv6 addresses

SYNOPSIS
========

     use Net::IP;
     
     my $ip = new IP ('193.0.1/24') or die (Net::IP::Error());
     print ("IP  : ".$ip->ip()."\n");
     print ("Sho : ".$ip->short()."\n");
     print ("Bin : ".$ip->binip()."\n");
     print ("Int : ".$ip->intip()."\n");
     print ("Mask: ".$ip->mask()."\n");
     print ("Last: ".$ip->last_ip()."\n");
     print ("Len : ".$ip->prefixlen()."\n");
     print ("Size: ".$ip->size()."\n");
     print ("Type: ".$ip->iptype()."\n");
     print ("Rev:  ".$ip->reverse_ip()."\n");

DESCRIPTION
===========

   This module provides functions to deal with *IPv4/IPv6* addresses. The
module can be used as a class, allowing the user to instantiate IP
objects, which can be single IP addresses, prefixes, or ranges of
addresses. There is also a procedural way of accessing most of the
functions. Most subroutines can take either *IPv4* or *IPv6* addresses
transparently.

OBJECT-ORIENTED INTERFACE
=========================

Object Creation
---------------

   A Net::IP object can be created from a single IP address:

   $ip = new Net::IP ('193.0.1.46') || die ...

   Or from a Classless Prefix (a /24 prefix is equivalent to a C class):

     $ip = new Net::IP ('195.114.80/24') || die ...

   Or from a range of addresses:

     $ip = new Net::IP ('20.34.101.207 - 201.3.9.99') || die ...
     
     The new() function accepts IPv4 and IPv6 addresses:

     $ip = new Net::IP ('dead:beef::/32') || die ...

   Optionnaly, the function can be passed the version of the IP.
Otherwise, it tries to guess what the version is (see *_is_ipv4()* and
*_is_ipv6()*).

     $ip = new IP ('195/8',4); # Class A

OBJECT METHODS
==============

   Most of these methods are front-ends for the real functions, which use a
procedural interface. Most functions return undef on failure, and a true
value on success. A detailed description of the procedural interface is
provided below.

set
---

   Set an IP address in an existing IP object. This method has the same
functionality as the new() method, except that it reuses an existing
object to store the new IP.

   `$ip->set('130.23.1/24',4);'

   Like new(), set() takes two arguments - a string used to build an IP
address, prefix, or range, and optionally, the IP version of the
considered address.

   It returns an IP object on success, and undef on failure.

error
-----

   Return the current object error string. The error string is set
whenever one of the methods produces an error. Also, a global, class-wide
*Error()* function is avaliable.

   `warn ($ip->error());'

errno
-----

   Return the current object error number. The error number is set
whenever one of the methods produces an error. Also, a global $ERRNO
variable is set when an error is produced.

   `warn ($ip->errno());'

ip
--

   Return the IP address (or first IP of the prefix or range) in quad
format, as a string.

   `print ($ip->ip());'

binip
-----

   Return the IP address as a binary string of 0s and 1s.

   `print ($ip->binip());'

prefixlen
---------

   Return the length in bits of the current prefix.

   `print ($ip->prefixlen());'

version
-------

   Return the version of the current IP object (4 or 6).

   `print ($ip->version());'

size
----

   Return the number of IP addresses in the current prefix or range.  Use
of this function requires Math::BigInt.

   `print ($ip->size());'

binmask
-------

   Return the binary mask of the current prefix, if applicable.

   `print ($ip->binmask());'

mask
----

   Return the mask in quad format of the current prefix.

   `print ($ip->mask());'

prefix
------

   Return the full prefix (ip+prefix length) in quad (standard) format.

   `print ($ip->prefix());'

intip
-----

   Convert the IP in integer format and return it as a Math::BigInt object.

   `print ($ip->intip());'

short
-----

   Return the IP in short format: IPv4 addresses are unchanged, but IPv6
addresses can be written in the '::' format (ex: ab32:f000::).

   `print ($ip->short());'

iptype
------

   Return the IP Type - this describes the type of an IP (Public, Private,
Reserved, etc.)

   `print ($ip->iptype());'

reverse_ip
----------

   Return the reverse IP for a given IP address (in.addr. format).

   `print ($ip->reserve_ip());'

last_bin
--------

   Return the last IP of a prefix/range in binary format.

   `print ($ip->last_bin());'

last_ip
-------

   Return the last IP of a prefix/range in quad format.

   `print ($ip->last_ip());'

find_prefixes
-------------

   This function finds all the prefixes that can be found between the two
addresses of a range. The function returns a list of prefixes.

   `@list = $ip->find_prefixes($other_ip));'

bincomp
-------

   Binary comparaison of two IP objects. The function takes an operation
and an IP object as arguments. It returns a boolean value.

   The operation can be one of: lt: less than (smaller than) lte: smaller
or equal to gt: greater than gte: greater or equal to

   `if ($ip->bincomp('lt',$ip2) {...}'

binadd
------

   Binary addition of two IP objects. The value returned is an IP object.

   `my $sum = $ip->binadd($ip2);'

aggregate
---------

   Aggregate 2 IPs - Append one range/prefix of IPs to another. The last
address of the first range must be the one immediately preceding the first
address of the second range. A new IP object is returned.

   `my $total = $ip->aggregate($ip2);'

overlaps
--------

   Check if two IP ranges/prefixes overlap each other. The value returned
by the function should be one of:      0  no overlap      1  ranges overlap
   -1  range2 is included in range1     -2  range1 is included in range2
undef  problem

   `if ($ip->overlaps($ip2)==1) {...};'

PROCEDURAL INTERFACE
====================

   These functions do the real work in the module. Like the OO methods,
most of these return undef on failure. In order to access error codes and
strings, instead of using $ip->error() and $ip->errno(), use the global
functions `Error()' and `Errno()'.

   The functions of the procedural interface are not exported by default.
In order to import these functions, you need to modify the use statement
for the module:

   `use Net::IP qw(:PROC);'

Error
-----

   Returns the error string corresponding to the last error generated in
the module. This is also useful for the OO interface, as if the new()
function fails, we cannot call $ip->error() and so we have to use Error().

   warn Error();

Errno
-----

   Returns a numeric error code corresponding to the error string returned
by Error.

ip_iptobin
----------

   Transform an IP address into a bit string.

     Params  : IP address, IP version
     Returns : binary IP string on success, undef otherwise

   `$binip = ip_iptobin ($ip,6);'

ip_bintoip
----------

   Transform a bit string into an IP address

     Params  : binary IP, IP version
     Returns : IP address on success, undef otherwise

   `$ip = ip_bintoip ($binip,6);'

ip_bintoint
-----------

   Transform a bit string into a BigInt.

     Params  : binary IP
     Returns : BigInt

   `$bigint = new Math::BigInt (ip_bintoint($binip));'

ip_inttobin
-----------

   Transform a BigInt into a bit string.  Warning: sets warnings (-w) off.
This is necessary because Math::BigInt is not compliant.

     Params  : BigInt, IP version
     Returns : binary IP

   `$binip = ip_inttobin ($bigint);'

ip_get_type
-----------

   Try to guess the IP version of an IP address.

     Params  : IP address
     Returns : 4, 6, 0(unable to determine)

   `$version = ip_get_type ($ip)'

ip_is_ipv4
----------

   Check if an IP address is of type 4.

     Params  : IP address
     Returns : 1 (yes) or 0 (no)

   `ip_is_ipv4($ip) and print "$ip is IPv4";'

ip_is_ipv6
----------

   Check if an IP address is of type 6.

     Params            : IP address
     Returns           : 1 (yes) or 0 (no)

   `ip_is_ipv6($ip) and print "$ip is IPv6";'

ip_expand_address
-----------------

   Expand an IP address from compact notation.

     Params  : IP address, IP version
     Returns : expanded IP address or undef on failure

   `$ip = ip_expand_address ($ip,4);'

ip_get_mask
-----------

   Get IP mask from prefix length.

     Params  : Prefix length, IP version
     Returns : Binary Mask

   `$mask = ip_get_mask ($len,6);'

ip_last_address_bin
-------------------

   Return the last binary address of a prefix.

     Params  : First binary IP, prefix length, IP version
     Returns : Binary IP

   C<$lastbin = ip_last_address_bin ($ip,$len,6);

ip_splitprefix
--------------

   Split a prefix into IP and prefix length.  If it was passed a simple
IP, it just returns it.

     Params  : Prefix
     Returns : IP, optionnaly length of prefix

   `($ip,$len) = ip_splitprefix ($prefix)'

ip_prefix_to_range
------------------

   Get a range of IPs from a prefix.

     Params  : Prefix, IP version
     Returns : First IP, last IP

   `($ip1,$ip2) = ip_prefix_to_range ($prefix,6);'

ip_bincomp
----------

   Compare binary Ips with <, >, <=, >=.   Operators are lt(<), lte(<=),
gt(>), and gte(>=)

   Params  : First binary IP, operator, Last binary IP     Returns : 1
(yes), 0 (no), or undef (problem)

   `ip_bincomp ($ip1,'lt',$ip2) == 1 or do {}'

ip_binadd
---------

   Add two binary IPs.

     Params  : First binary IP, Last binary IP
     Returns : Binary sum or undef (problem)

   `$binip = ip_binadd ($bin1,$bin2);'

ip_get_prefix_length
--------------------

   Get the prefix length for a given range of 2 IPs.

     Params  : First binary IP, Last binary IP
     Returns : Length of prefix or undef (problem)

   `$len = ip_get_prefix_length ($ip1,$ip2);'

ip_range_to_prefix
------------------

   Return all prefixes between two IPs.

     Params  : First IP, Last IP, IP version
     Returns : List of Prefixes or undef (problem)

   The prefixes returned have the form q.q.q.q/nn.

   `@prefix = ip_range_to_prefix ($ip1,$ip2,6);'

ip_compress_address
-------------------

   Compress an IPv6 address. Just returns the IP if it is an IPv4.

     Params  : IP, IP version
     Returns : Compressed IP or undef (problem)

   `$ip = ip_compress_adress ($ip);'

ip_is_overlap
-------------

   Check if two ranges of IPs overlap.

     Params  : Four binary IPs (begin of range 1,end1,begin2,end2), IP version
     Returns : 1    (ranges overlap)
               0    (no overlap)
              -1    (range1 includes range2)
              -2    (range2 includes range1)
     	     undef (problem)

   `ip_is_overlap($rb1,$re1,$rb2,$re2,4) and do {};'

ip_get_embedded_ipv4
--------------------

   Get an IPv4 embedded in an IPv6 address

     Params  : IPv6
     Returns : IPv4 string or undef (not found)

   `$ip4 = ip_get_embedded($ip6);'

ip_check_mask
-------------

   Check the validity of a binary IP mask

     Params  : Mask
     Returns : 1 or undef (invalid)

   `ip_check_mask($binmask) or do {};'

   Checks if mask has only 1s followed by 0s.

ip_aggregate
------------

   Aggregate 2 ranges of binary IPs

     Params  : 1st range (1st IP, Last IP), last range (1st IP, last IP), IP version
     Returns : prefix or undef (invalid)

   `$prefix = ip_aggregate ($bip1,$eip1,$bip2,$eip2) || die ...'

ip_iptype
---------

   Return the type of an IP (Public, Private, Reserved)

     Params  : IP to test, IP version
     Returns : type or undef (invalid)

   `$type = ip_iptype ($ip);'

ip_check_prefix
---------------

   Check the validity of a prefix

     Params  : binary IP, length of prefix, IP version
     Returns : 1 or undef (invalid)

   Checks if the variant part of a prefix only has 0s, and the length is
correct.

   `ip_check_prefix ($ip,$len,$ipv) or do {};'

ip_reverse
----------

   Get a reverse name from a prefix

     Params  : IP, length of prefix, IP version
     Returns : Reverse name or undef (error)

   `$reverse = ip_reverse ($ip);'

ip_normalize
------------

   Normalize data to a range/prefix of IP addresses

     Params  : Data String (Single IP, Range, Prefix)
     Returns : ip1, ip2 (if range/prefix) or undef (error)

   `($ip1,$ip2) = ip_normalize ($data);'

BUGS
====

   The Math::BigInt library is needed for functions that use integers.
These are ip_inttobin, ip_bintoint, and the size method. In a next version,
Math::BigInt will become optionnal.

AUTHORS
=======

   Manuel Valente <mvalente@ripe.net>.

   Original IPv4 code by Monica Cortes Sack <mcortes@ripe.net>.

   Original IPv6 code by Lee Wilmot <lee@ripe.net>.

BASED ON
========

   ipv4pack.pm, iplib.pm, iplibncc.pm.

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Net/IPv4Addr,  Next: Net/IRC,  Prev: Net/IP,  Up: Module List

Perl extension for manipulating IPv4 addresses.
***********************************************

NAME
====

   Net::IPv4Addr - Perl extension for manipulating IPv4 addresses.

SYNOPSIS
========

     use Net::IPv4Addr qw( :all );

     my ($ip,$cidr) = ipv4_parse( "127.0.0.1/24" );
     my ($ip,$cidr) = ipv4_parse( "192.168.100.10 / 255.255.255.0" );

     my ($net,$msk) = ipv4_network( "192.168.100.30" );

     my $broadcast  = ipv4_broadcast( "192.168.100.30/26" );

     if ( ipv4_in_network( "192.168.100.0", $her_ip ) ) {
       print "Welcome !";
     }

     etc.

DESCRIPTION
===========

   Net::IPv4Addr provides functions for parsing IPv4 addresses both in
traditional address/netmask format and in the new CIDR format.  There are
also methods for calculating the network and broadcast address and also to
see check if a given address is in a specific network.

ADDRESSES
=========

   All of Net::IPv4Addr functions accepts addresses in many format. The
parsing is very liberal.

   All these addresses would be accepted:

     127.0.0.1
     192.168.001.010/24
     192.168.10.10/255.255.255.0
     192.168.30.10 / 21
     10.0.0.0 / 255.0.0.0
     255.255.0.0

   Those wouldn't though:

     272.135.234.0
     192.168/16

   Most functions accepts the address and netmask or masklength in the
same scalar value or as separate values. That is either

     my($ip,$masklength) = ipv4_parse($cidr_str);
     my($ip,$masklength) = ipv4_parse($ip_str,$msk_str);

USING
=====

   No functions are exported by default. Either use the :all tag to import
them all or explicitly import those you need.

FUNCTIONS
=========

ipv4_parse
          my ($ip,$msklen) = ipv4_parse($cidr_str);
          my $cidr = ipv4_parse($ip_str,$msk_str);
          my ($ip) = ipv4_parse($ip_str,$msk_str);

     Parse an IPv4 address and in scalar context the address in CIDR
     format and in an array context the address and the mask length.

     If the parameters doesn't contains a netmask or a mask length, in
     scalar context only the IPv4 address is returned and in an array
     context the mask length is undefined.

     If the function cannot parse its input, it croaks. Trap it using eval
     if don't like that.

ipv4_network
          my $cidr = ipv4_network($ip_str);
          my $cidr = ipv4_network($cidr_str);
          my ($net,$msk) = ipv4_network( $net_str, $msk_str);

     In scalar context, this function returns the network in CIDR format in
     which the address is. In array context, it returns the network
     address and its mask length as a two elements array. If the input is
     an host without a netmask of mask length, the default netmask is
     assumed.

     Again, the function croak if the input is invalid.

ipv4_broadcast
          my ($broadcast) = ipv4_broadcast($ip_str);
          my $broadcast   = ipv4_broadcast($ip_str,$msk_str);

     This function returns the broadcast address. If the input doesn't
     contains a netmask or mask length, the default netmask is assumed.

     This function croaks if the input is invalid.

ipv4_network
          my $cidr = ipv4_network($net_str);
          my $cidr = ipv4_network($cidr_sstr);
          my ($net,$msk) = ipv4_network( $ip_str, $mask_str);

     In scalar context, this function returns the network in CIDR format in
     which the address is. In array context, it returns the network
     address and its mask length as a two elements array. If the input is
     an host without a netmask or mask length, the default netmask is
     assumed.

     Again, the function croak if the input is invalid.

ipv4_in_network
          print "Yes" if ipv4_in_network( $cidr_str1, $cidr_str2);
          print "Yes" if ipv4_in_network( $ip_str1, $mask_str1, $cidr_str2 );
          print "Yes" if ipv4_in_network( $ip1, $mask1, $ip2, $msk2 );

     This function checks if the second network is contained in the first
     one and it implements the following semantics :

          If net1 or net2 is a magic address (0.0.0.0 or 255.255.255.255)
          than this function returns true.

          If net1 is an host, net2 will be in the same net only if
          it is the same host.

          If net2 is an host, it will be contained in net1 only if
          it is part of net1.

          If net2 is only part of net1 if it is entirely contained in
          net1.

     Trap bad input with eval or else.

ipv4_checkip
          if ($ip = ipv4_checkip($str) ) {
          	# Do something
          }

     Return the IPv4 address in the string or undef if the input doesn't
     contains a valid IPv4 address.

ipv4_cidr2msk
          my $netmask = ipv4_cidr2msk( $cidr );

     Returns the netmask corresponding to the mask length given in input.
     As usual, croaks if it doesn't like your input (in this case a number
     between 0 and 32).

ipv4_msk2cidr
          my $masklen = ipv4_msk2cidr( $msk );

     Returns the mask length of the netmask in input. As usual, croaks if
     it doesn't like your input.

AUTHOR
======

   Francis J. Lacoste <francis.lacoste@iNsu.COM>

COPYRIGHT
=========

   Copyright (c) 1999, 2000 iNsu Innovations Inc.  All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms as perl itself.

SEE ALSO
========

   perl(1) ipv4calc(1).


File: pm.info,  Node: Net/IRC,  Next: Net/IRC/Connection,  Prev: Net/IPv4Addr,  Up: Module List

Perl interface to the Internet Relay Chat protocol
**************************************************

NAME
====

   Net::IRC - Perl interface to the Internet Relay Chat protocol

SYNOPSIS
========

     use Net::IRC;

     $irc = new Net::IRC;
     $conn = $irc->newconn(Nick    => 'some_nick',
                           Server  => 'some.irc.server.com',
     	                  Port    =>  6667,
     			  Ircname => 'Some witty comment.');
     $irc->start;

DESCRIPTION
===========

   Welcome to Net::IRC, a work in progress. First intended to be a quick
tool for writing an IRC script in Perl, Net::IRC has grown into a
comprehensive Perl implementation of the IRC protocol (RFC 1459),
supported and developed by several members of the EFnet IRC channel #perl.

   There are 4 component modules which make up Net::IRC:

   * Net::IRC

     The wrapper for everything else, containing methods to generate
     Connection objects (see below) and a connection manager which does an
     event loop on all available filehandles. Sockets or files which are
     readable (or writable, or whatever you want it to select() for) get
     passed to user-supplied handler subroutines in other packages or in
     user code.

   * Net::IRC::Connection

     The big time sink on this project. Each Connection instance is a
     single connection to an IRC server. The module itself contains
     methods for every single IRC command available to users (Net::IRC
     isn't designed for writing servers, for obvious reasons), methods to
     set, retrieve, and call handler functions which the user can set
     (more on this later), and too many cute comments. Hey, what can I
     say, we were bored.

   * Net::IRC::Event

     Kind of a struct-like object for storing info about things that the
     IRC server tells you (server responses, channel talk, joins and
     parts, et cetera). It records who initiated the event, who it
     affects, the event type, and any other arguments provided for that
     event. Incidentally, the only argument passed to a handler function.

   * Net::IRC::DCC

     The analogous object to Connection.pm for connecting, sending and
     retrieving with the DCC protocol. Instances of DCC.pm are invoked from
     `Connection->new_{send,get,chat}' in the same way that `IRC->newconn'
     invokes `Connection->new'. This will make more sense later, we
     promise.

   The central concept that Net::IRC is built around is that of handlers
(or hooks, or callbacks, or whatever the heck you feel like calling them).
We tried to make it a completely event-driven model, a la Tk - for every
conceivable type of event that your client might see on IRC, you can give
your program a custom subroutine to call. But wait, there's more! There are
3 levels of handler precedence:

   * Default handlers

     Considering that they're hardwired into Net::IRC, these won't do much
     more than the bare minimum needed to keep the client listening on the
     server, with an option to print (nicely formatted, of course) what it
     hears to whatever filehandles you specify (STDOUT by default). These
     get called only when the user hasn't defined any of his own handlers
     for this event.

   * User-definable global handlers

     The user can set up his own subroutines to replace the default
     actions for every IRC connection managed by your program. These only
     get invoked if the user hasn't set up a per-connection handler for
     the same event.

   * User-definable per-connection handlers

     Simple: this tells a single connection what to do if it gets an event
     of this type. Supersedes global handlers if any are defined for this
     event.

   And even better, you can choose to call your custom handlers before or
after the default handlers instead of replacing them, if you wish. In
short, it's not perfect, but it's about as good as you can get and still be
documentable, given the sometimes horrendous complexity of the IRC
protocol.

GETTING STARTED
===============

Initialization
--------------

   To start a Net::IRC script, you need two things: a Net::IRC object, and
a Net::IRC::Connection object. The Connection object does the dirty work of
connecting to the server; the IRC object handles the input and output for
it.  To that end, say something like this:

     use Net::IRC;

     $irc = new Net::IRC;

     $conn = $irc->newconn(Nick    => 'some_nick',
                           Server  => 'some.irc.server.com');

   ...or something similar. Acceptable parameters to newconn() are:

   * Nick

     The nickname you'll be known by on IRC, often limited to a maximum of
     9 letters. Acceptable characters for a nickname are `[\w{}[]\`^|-]'.
     If you don't specify a nick, it defaults to your username.

   * Server

     The IRC server to connect to. There are dozens of them across several
     widely-used IRC networks, but the oldest and most popular is EFNet
     (Eris Free Net), home to #perl. See http://www.irchelp.org/ for lists
     of popular servers, or ask a friend.

   * Port

     The port to connect to this server on. By custom, the default is 6667.

   * Username

     On systems not running identd, you can set the username for your
     user@host to anything you wish. Note that some IRC servers won't
     allow connections from clients which don't run identd.

   * Ircname

     A short (maybe 60 or so chars) piece of text, originally intended to
     display your real name, which people often use for pithy quotes and
     URLs. Defaults to the contents of your GECOS field.

   * Password

     If the IRC server you're trying to write a bot for is
     password-protected, no problem. Just say "`Password =' 'foo'>" and
     you're set.

     =back

Handlers
--------

   Once that's over and done with, you need to set up some handlers if you
want your bot to do anything more than sit on a connection and waste
resources.  Handlers are references to subroutines which get called when a
specific event occurs. Here's a sample handler sub:

     # What to do when the bot successfully connects.
     sub on_connect {
         my $self = shift;

     print "Joining #IRC.pm...";
     $self->join("#IRC.pm");
     $self->privmsg("#IRC.pm", "Hi there.");
         }

   The arguments to a handler function are always the same:

$_[0]:
     The Connection object that's calling it.

$_[1]:
     An Event object (see below) that describes what the handler is
     responding to.

   Got it? If not, see the examples in the irctest script that came with
this distribution. Anyhow, once you've defined your handler subroutines,
you need to add them to the list of handlers as either a global handler
(affects all Connection objects) or a local handler (affects only a single
Connection). To do so, say something along these lines:

     $self->add_global_handler('376', \&on_connect);     # global
     $self->add_handler('msg', \&on_msg);                # local

   376, incidentally, is the server number for "end of MOTD", which is an
event that the server sends to you after you're connected. See Event.pm
for a list of all possible numeric codes. The 'msg' event gets called
whenever someone else on IRC sends your client a private message. For a
big list of possible events, see the *Event List* section in the
documentation for Net::IRC::Event.

Getting Connected
-----------------

   When you've set up all your handlers, the following command will put
your program in an infinite loop, grabbing input from all open connections
and passing it off to the proper handlers:

     $irc->start;

   Note that new connections can be added and old ones dropped from within
your handlers even after you call this. Just don't expect any code below
the call to start() to ever get executed.

   If you're tying Net::IRC into another event-based module, such as
perl/Tk, there's a nifty `do_one_loop()' method provided for your
convenience. Calling `$irc->do_one_loop()' runs through the IRC.pm event
loop once, hands all ready filehandles over to the appropriate handler
subs, then returns control to your program.

METHOD DESCRIPTIONS
===================

   This section contains only the methods in IRC.pm itself. Lists of the
methods in Net::IRC::Connection, Net::IRC::Event, or Net::IRC::DCC are in
their respective modules' documentation; just `perldoc
Net::IRC::Connection' (or Event or DCC or whatever) to read them.
Functions take no arguments unless otherwise specified in their
description.

   By the way, expect Net::IRC to use AutoLoader sometime in the future,
once it becomes a little more stable.

   * addconn()

     Adds the specified object's socket to the select loop in
     `do_one_loop()'.  This is mostly for the use of Connection and DCC
     objects (and for pre-0.5 compatibility)... for most (read: all)
     purposes, you can just use `addfh()', described below.

     Takes at least 1 arg:

       1. An object whose socket needs to be added to the select loop

       2. *Optional:* A string consisting of one or more of the letters r,
          w, and e.  Passed directly to `addfh()'... see the description
          below for more info.


   * addfh()

     This sub takes a user's socket or filehandle and a sub to handle it
     with and merges it into `do_one_loop()''s list of select()able
     filehandles. This makes integration with other event-based systems
     (Tk, for instance) a good deal easier than in previous releases.

     Takes at least 2 args:

       1. A socket or filehandle to monitor

       2. A reference to a subroutine. When select() determines that the
          filehandle is ready, it passes the filehandle to this
          (presumably user-supplied) sub, where you can read from it,
          write to it, etc. as your script sees fit.

       3. *Optional:* A string containing any combination of the letters
          r, w or e (standing for read, write, and error, respectively)
          which determines what conditions you're expecting on that
          filehandle. For example, this line select()s $fh (a filehandle,
          of course) for both reading and writing:

               $irc->addfh( $fh, \&callback, "rw" );


   * do_one_loop()

     select()s on all open filehandles and passes any ready ones to the
     appropriate handler subroutines. Also responsible for executing
     scheduled events from `Net::IRC::Connection->schedule()' on time.

   * new()

     A fairly vanilla constructor which creates and returns a new Net::IRC
     object.

   * newconn()

     Creates and returns a new Connection object. All arguments are passed
     straight to `Net::IRC::Connection->new()'; examples of common
     arguments can be found in the Synopsis or *Getting Started* sections.

   * removeconn()

     Removes the specified object's socket from `do_one_loop()''s list of
     select()able filehandles. This is mostly for the use of Connection
     and DCC objects (and for pre-0.5 compatibility)... for most (read:
     all) purposes, you can just use `removefh()', described below.

     Takes 1 arg:

       1. An object whose socket or filehandle needs to be removed from
          the select loop


   * removefh()

     This method removes a given filehandle from `do_one_loop()''s list of
     selectable filehandles.

     Takes 1 arg:

       1. A socket or filehandle to remove


   * start()

     Starts an infinite event loop which repeatedly calls `do_one_loop()'
     to read new events from all open connections and pass them off to any
     applicable handlers.

   * timeout()

     Sets or returns the current select() timeout for the main event loop,
     in seconds (fractional amounts allowed). See the documentation for the
     select() function for more info.

     Takes 1 optional arg:

       1. *Optional:* A new value for the select() timeout for this IRC
          object.


AUTHORS
=======

   * Conceived and initially developed by Greg Bacon <gbacon@adtran.com>
     and Dennis Taylor <dennis@funkplanet.com>.

   * Ideas and large amounts of code donated by Nat "King" Torkington
     <gnat@frii.com>.

   * Currently being hacked on, hacked up, and worked over by the members
     of the Net::IRC developers mailing list. For details, see
     http://www.execpc.com/~corbeau/irc/list.html .

URL
===

   Up-to-date source and information about the Net::IRC project can be
found at http://netirc.betterbox.net/ .

SEE ALSO
========

   * perl(1).

   * RFC 1459: The Internet Relay Chat Protocol

   * http://www.irchelp.org/, home of fine IRC resources.


File: pm.info,  Node: Net/IRC/Connection,  Next: Net/IRC/DCC,  Prev: Net/IRC,  Up: Module List

Object-oriented interface to a single IRC connection
****************************************************

NAME
====

   Net::IRC::Connection - Object-oriented interface to a single IRC
connection

SYNOPSIS
========

   Hard hat area: This section under construction.

DESCRIPTION
===========

   This documentation is a subset of the main Net::IRC documentation. If
you haven't already, please "perldoc Net::IRC" before continuing.

   Net::IRC::Connection defines a class whose instances are individual
connections to a single IRC server. Several Net::IRC::Connection objects
may be handled simultaneously by one Net::IRC object.

METHOD DESCRIPTIONS
===================

   This section is under construction, but hopefully will be finally
written up by the next release. Please see the `irctest' script and the
source for details about this module.

AUTHORS
=======

   Conceived and initially developed by Greg Bacon <gbacon@adtran.com> and
Dennis Taylor <dennis@funkplanet.com>.

   Ideas and large amounts of code donated by Nat "King" Torkington
<gnat@frii.com>.

   Currently being hacked on, hacked up, and worked over by the members of
the Net::IRC developers mailing list. For details, see
http://www.execpc.com/~corbeau/irc/list.html .

URL
===

   Up-to-date source and information about the Net::IRC project can be
found at http://netirc.betterbox.net/ .

SEE ALSO
========

   * perl(1).

   * RFC 1459: The Internet Relay Chat Protocol

   * http://www.irchelp.org/, home of fine IRC resources.


File: pm.info,  Node: Net/IRC/DCC,  Next: Net/IRC/Event,  Prev: Net/IRC/Connection,  Up: Module List

Object-oriented interface to a single DCC connection
****************************************************

NAME
====

   Net::IRC::DCC - Object-oriented interface to a single DCC connection

SYNOPSIS
========

   Hard hat area: This section under construction.

DESCRIPTION
===========

   This documentation is a subset of the main Net::IRC documentation. If
you haven't already, please "perldoc Net::IRC" before continuing.

   Net::IRC::DCC defines a few subclasses that handle DCC CHAT, GET, and
SEND requests for inter-client communication. DCC objects are created by
`Connection->new_{chat,get,send}()' in much the same way that
`IRC->newconn()' creates a new connection object.

METHOD DESCRIPTIONS
===================

   This section is under construction, but hopefully will be finally
written up by the next release. Please see the `irctest' script and the
source for details about this module.

AUTHORS
=======

   Conceived and initially developed by Greg Bacon <gbacon@adtran.com> and
Dennis Taylor <dennis@funkplanet.com>.

   Ideas and large amounts of code donated by Nat "King" Torkington
<gnat@frii.com>.

   Currently being hacked on, hacked up, and worked over by the members of
the Net::IRC developers mailing list. For details, see
http://www.execpc.com/~corbeau/irc/list.html .

URL
===

   Up-to-date source and information about the Net::IRC project can be
found at http://netirc.betterbox.net/ .

SEE ALSO
========

   * perl(1).

   * RFC 1459: The Internet Relay Chat Protocol

   * http://www.irchelp.org/, home of fine IRC resources.


File: pm.info,  Node: Net/IRC/Event,  Next: Net/Ident,  Prev: Net/IRC/DCC,  Up: Module List

A class for passing event data between subroutines
**************************************************

NAME
====

   Net::IRC::Event - A class for passing event data between subroutines

SYNOPSIS
========

   None yet. These docs are under construction.

DESCRIPTION
===========

   This documentation is a subset of the main Net::IRC documentation. If
you haven't already, please "perldoc Net::IRC" before continuing.

   Net::IRC::Event defines a standard interface to the salient information
for just about any event your client may witness on IRC. It's about as
close as we can get in Perl to a struct, with a few extra nifty features
thrown in.

METHOD DESCRIPTIONS
===================

   This section is under construction, but hopefully will be finally
written up by the next release. Please see the `irctest' script and the
source for details about this module.

LIST OF EVENTS
==============

   Net::IRC is an entirely event-based system, which takes some getting
used to at first. To interact with the IRC server, you tell Net::IRC's
server connection to listen for certain events and activate your own
subroutines when they occur. Problem is, this doesn't help you much if you
don't know what to tell it to look for. Below is a list of the possible
events you can pass to Net::IRC, along with brief descriptions of each...
hope this helps.

Common events
-------------

   * nick

     The "nick" event is triggered when the client receives a NICK
     message, meaning that someone on a channel with the client has
     changed eir nickname.

   * quit

     The "quit" event is triggered upon receipt of a QUIT message, which
     means that someone on a channel with the client has disconnected.

   * join

     The "join" event is triggered upon receipt of a JOIN message, which
     means that someone has entered a channel that the client is on.

   * part

     The "part" event is triggered upon receipt of a PART message, which
     means that someone has left a channel that the client is on.

   * mode

     The "mode" event is triggered upon receipt of a MODE message, which
     means that someone on a channel with the client has changed the
     channel's parameters.

   * topic

     The "topic" event is triggered upon receipt of a TOPIC message, which
     means that someone on a channel with the client has changed the
     channel's topic.

   * kick

     The "kick" event is triggered upon receipt of a KICK message, which
     means that someone on a channel with the client (or possibly the
     client itself!) has been forcibly ejected.

   * public

     The "public" event is triggered upon receipt of a PRIVMSG message to
     an entire channel, which means that someone on a channel with the
     client has said something aloud.

   * msg

     The "msg" event is triggered upon receipt of a PRIVMSG message which
     is addressed to one or more clients, which means that someone is
     sending the client a private message. (Duh. :-)

   * notice

     The "notice" event is triggered upon receipt of a NOTICE message,
     which means that someone has sent the client a public or private
     notice. (Is that sufficiently vague?)

   * ping

     The "ping" event is triggered upon receipt of a PING message, which
     means that the IRC server is querying the client to see if it's
     alive. Don't confuse this with CTCP PINGs, explained later.

   * other

     The "other" event is triggered upon receipt of any number of
     unclassifiable miscellaneous messages, but you're not likely to see
     it often.

   * invite

     The "invite" event is triggered upon receipt of an INVITE message,
     which means that someone is permitting the client's entry into a +i
     channel.

   * kill

     The "kill" event is triggered upon receipt of a KILL message, which
     means that an IRC operator has just booted your sorry arse offline.
     Seeya!

   * disconnect

     The "disconnect" event is triggered when the client loses its
     connection to the IRC server it's talking to. Don't confuse it with
     the "leaving" event. (See below.)

   * leaving

     The "leaving" event is triggered just before the client deliberately
     closes a connection to an IRC server, in case you want to do anything
     special before you sign off.

   * umode

     The "umode" event is triggered when the client changes its personal
     mode flags.

   * error

     The "error" event is triggered when the IRC server complains to you
     about anything. Sort of the evil twin to the "other" event, actually.

CTCP Requests
-------------

   * cping

     The "cping" event is triggered when the client receives a CTCP PING
     request from another user. See the irctest script for an example of
     how to properly respond to this common request.

   * cversion

     The "cversion" event is triggered when the client receives a CTCP
     VERSION request from another client, asking for version info about
     its IRC client program.

   * csource

     The "csource" event is triggered when the client receives a CTCP
     SOURCE request from another client, asking where it can find the
     source to its IRC client program.

   * ctime

     The "ctime" event is triggered when the client receives a CTCP TIME
     request from another client, asking for the local time at its end.

   * cdcc

     The "cdcc" event is triggered when the client receives a DCC request
     of any sort from another client, attempting to establish a DCC
     connection.

   * cuserinfo

     The "cuserinfo" event is triggered when the client receives a CTCP
     USERINFO request from another client, asking for personal information
     from the client's user.

   * cclientinfo

     The "cclientinfo" event is triggered when the client receives a CTCP
     CLIENTINFO request from another client, asking for whatever the hell
     "clientinfo" means.

   * cerrmsg

     The "cerrmsg" event is triggered when the client receives a CTCP
     ERRMSG request from another client, notifying it of a protocol error
     in a preceding CTCP communication.

   * cfinger

     The "cfinger" event is triggered when the client receives a CTCP
     FINGER request from another client. How to respond to this should
     best be left up to your own moral stance.

   * caction

     The "caction" event is triggered when the client receives a CTCP
     ACTION message from another client. I should hope you're getting the
     hang of how Net::IRC handles CTCP requests by now...

CTCP Responses
--------------

   * crping

     The "crping" event is triggered when the client receives a CTCP PING
     response from another user. See the irctest script for an example of
     how to properly respond to this common event.

   * crversion

     The "crversion" event is triggered when the client receives a CTCP
     VERSION response from another client.

   * crsource

     The "crsource" event is triggered when the client receives a CTCP
     SOURCE response from another client.

   * crtime

     The "crtime" event is triggered when the client receives a CTCP TIME
     response from another client.

   * cruserinfo

     The "cruserinfo" event is triggered when the client receives a CTCP
     USERINFO response from another client.

   * crclientinfo

     The "crclientinfo" event is triggered when the client receives a CTCP
     CLIENTINFO response from another client.

   * crfinger

     The "crfinger" event is triggered when the client receives a CTCP
     FINGER response from another client. I'm not even going to consider
     making a joke about this one.

DCC Events
----------

   * dcc_open

     The "dcc_open" event is triggered when a DCC connection is
     established between the client and another client.

   * dcc_update

     The "dcc_update" event is triggered when any data flows over a DCC
     connection.  Useful for doing things like monitoring file transfer
     progress, for instance.

   * dcc_close

     The "dcc_close" event is triggered when a DCC connection closes,
     whether from an error or from natural causes.

   * chat

     The "chat" event is triggered when the person on the other end of a
     DCC CHAT connection sends you a message. Think of it as the private
     equivalent of "msg", if you will.

Numeric Events
--------------

   * There's a whole lot of them, and they're well-described elsewhere.
     Please see the IRC RFC (1495, at
     http://cs-ftp.bu.edu/pub/irc/support/IRC_RFC ) for a detailed
     description, or the Net::IRC::Event.pm source code for a quick list.

AUTHORS
=======

   Conceived and initially developed by Greg Bacon <gbacon@adtran.com> and
Dennis Taylor <dennis@funkplanet.com>.

   Ideas and large amounts of code donated by Nat "King" Torkington
<gnat@frii.com>.

   Currently being hacked on, hacked up, and worked over by the members of
the Net::IRC developers mailing list. For details, see
http://www.execpc.com/~corbeau/irc/list.html .

URL
===

   Up-to-date source and information about the Net::IRC project can be
found at http://netirc.betterbox.net/ .

SEE ALSO
========

   * perl(1).

   * RFC 1459: The Internet Relay Chat Protocol

   * http://www.irchelp.org/, home of fine IRC resources.


File: pm.info,  Node: Net/Ident,  Next: Net/Inet,  Prev: Net/IRC/Event,  Up: Module List

lookup the username on the remote end of a TCP/IP connection
************************************************************

NAME
====

   Net::Ident - lookup the username on the remote end of a TCP/IP
connection

SYNOPSIS
========

     use Net::Ident;
     
     $username = Net::Ident::lookup(SOCKET, $timeout);

     $username = Net::Ident::lookupFromInAddr($localsockaddr,
     					   $remotesockaddr, $timeout);
     
     $obj = Net::Ident->new(SOCKET, $timeout);
     $obj = Net::Ident->newFromInAddr($localsockaddr, $remotesockaddr,
     					$timeout);
     $status = $obj->query;
     $status = $obj->ready;
     $username = $obj->username;
     ($username, $opsys, $error) = $obj->username;
     $fh = $obj->getfh;
     $txt = $obj->geterror;
     
     use Net::Ident 'ident_lookup';
     
     $username = ident_lookup(SOCKET, $timeout);

     use Net::Ident 'lookupFromInAddr';

     $username = lookupFromInAddr($localsockaddr, $remotesockaddr, $timeout);

     use Net::Ident ':fh';

     $username = SOCKET->ident_lookup($timeout);

     use Net::Ident ':apache';

     # my Apache $r;
     $c = $r->connection;
     $username = $c->ident_lookup($timeout);

OVERVIEW
========

   *Net::Ident* is a module that looks up the username on the remote side
of a TCP/IP connection through the ident (auth/tap) protocol described in
RFC1413 (which supersedes RFC931). Note that this requires the remote site
to run a daemon (often called *identd*) to provide the requested
information, so it is not always available for all TCP/IP connections.

DESCRIPTION
===========

   You can either use the simple interface, which does one ident lookup at
a time, or use the asynchronous interface to perform (possibly) many
simultaneous lookups, or simply continue serving other things while the
lookup is proceeding.

Simple Interface
----------------

   The simple interface comes in four varieties. An object oriented method
call of a FileHandle object, an object oriented method of an
Apache::Connection object, and as one of two different simple subroutine
calls. Other than the calling method, these routines behave exactly the
same.

`Net::Ident::lookup (SOCKET' [`, $timeout'])
     *Net::Ident::lookup* is an exportable function. However, due to the
     generic name of the lookup function, it is recommended that you
     instead import the alias function *Net::Ident::ident_lookup*. Both
     functions are exported through `@EXPORT_OK', so you'll have to
     explicitly ask for it if you want the function *ident_lookup* to be
     callable from your program.

     You can pass the socket using either a string, which doesn't have to
     be qualified with a package name, or using the more modern FileHandle
     calling styles: as a glob or as a reference to a glob. The Socket has
     to be a connected TCP/IP socket, ie. something which is either
     connect()ed or accept()ed. The optional timeout parameter specifies a
     timeout in seconds. If you do not specify a timeout, or use a value
     of undef, there will be no timeout (apart from any default system
     timeouts like TCP connection timeouts).

`Net::Ident::lookupFromInAddr ($localaddr, $remoteaddr' [`, $timeout'])
     *Net::Ident::lookupFromInAddr* is an exportable function (via
     `@EXPORT_OK').  The arguments are the local and remote address of a
     connection, in packed "sockaddr" format (the kind of thing that
     getsockname returns). The optional timeout value specifies a timeout
     in seconds, see also the description of the timeout value in the
     `Net::Ident::lookup' section above.

     The given localaddr must have the IP address of a local interface of
     the machine you're calling this on, otherwise an error will occur.

     You can use this function whenever you have a local and remote socket
     address, but no direct access to the socket itself. For example,
     because you are parsing the output of "netstat" and extracting socket
     address, or because you are writing a mod_perl script under apache
     (in that case, also see the Apache::Connection method below).

`ident_lookup SOCKET' [$timeout]
     When you import the "magic" tag ':fh' using `use Net::Ident ':fh';',
     the *Net::Ident* module extends the FileHandle class with one extra
     method call, *ident_lookup*. It assumes that the object (a
     FileHandle) it is operating on, is a connected TCP/IP socket, ie.
     something which is either connect()ed or accept()ed. The optional
     parameter specifies the timeout in seconds, just like the timeout
     parameter of the function calls above.

      

     Some people do not like the way that "proper" object design is broken
     by letting one module add methods to another class. This is why,
     starting from version 1.20, you have to explicitly ask for this
     behaviour to occur.  Personally, I this it's a compromise: if you
     want an object-oriented interface, then either you make a derived
     class, like a FileHandleThatCanPerformIdentLookups, and make sure all
     appropriate internal functions get wrappers that do the necessary
     re-blessing. Or, you simply extend the FileHandle class. And since
     Perl doesn't object to this (pun intended :), I find this an
     acceptable solution. But you might think otherwise.

`ident_lookup Apache::Connection' [$timeout]
     When you import the "magic" tag ':apache' using `use Net::Ident
     ':apache';', the *Net::Ident* module extends the *Apache::Connection*
     class with one extra method call, *ident_lookup*. This method takes
     one optional parameter: a timeout value in seconds.

     This is a similar convenience function as the
     FileHandle::ident_lookup method, to be used with mod_perl scripts
     under Apache.

   What these functions return depends on the context:

scalar context
     In scalar context, these functions return the remote username on
     success, or undef on error. "Error" is rather broad, it might mean:
     some network error occurred, function arguments are invalid, the
     remote site is not responding (in time) or is not running an ident
     daemon, or the remote site ident daemon says there's no user
     connected with that particular connection.

     More precisely, the functions return whatever the remote daemon
     specified as the ID that belongs to that particular connection. This
     is often the username, but it doesn't necessarily have to be. Some
     sites, out of privacy and/or security measures, return an opaque ID
     that is unique for each user, but is not identical to the username.
     See *RFC1413* for more information.

array context
     In array context, these functions return: `($username, $opsys,
     $error)'.  The $username is the remote username or ID, as returned in
     the scalar context, or undef on error.

     The *$opsys* is the remote operating system as reported by the remote
     ident daemon, or undef on a network error, or *"ERROR"* when the
     remote ident daemon reported an error. This could also contain the
     character set of the returned username. See RFC1413.

     The $error is the error message, either the error reported by the
     remote ident daemon (in which case *$opsys* is *"ERROR"*), or the
     internal message from the *Net::Ident* module, which includes the
     system errno $! whenever possible. A likely candidate is *"Connection
     refused"* when the remote site isn't running an ident daemon, or
     *"Connection timed out"* when the remote site isn't answering our
     connection request.

     When $username has a value, $error is always undef, and vice versa.

EXAMPLE
-------

   The following code is a complete example, implementing a server that
waits for a connection on a port, tells you who you are and what time it
is, and closes the connection again. The majority of the code will look
very familiar if you just read *Note Perlipc: (perl.info)perlipc,.

   Excersize this server by telnetting to it, preferably from a machine
that has a suitable ident daemon installed.

     #!/usr/bin/perl -w

     use Net::Ident;
     # uncomment the below line if you want lots of debugging info
     # $Net::Ident::DEBUG = 2;
     use Socket;
     use strict;
     
     sub logmsg { print "$0 $$: @_ at ", scalar localtime, "\n" }
     
     my $port = shift || 2345;
     my $proto = getprotobyname('tcp');
     socket(Server, PF_INET, SOCK_STREAM, $proto) or die "socket: $!";
     setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) or
       die "setsockopt: $!";
     bind(Server, sockaddr_in($port, INADDR_ANY)) or die "bind: $!";
     listen(Server,SOMAXCONN) or die "listen: $!";
     
     logmsg "server started on port $port";
     
     my $paddr;
     
     for ( ; $paddr = accept(Client,Server); close Client) {
     	my($port,$iaddr) = sockaddr_in($paddr);
     	my $name = gethostbyaddr($iaddr,AF_INET) || inet_ntoa($iaddr);
     	logmsg "connection from $name [" . inet_ntoa($iaddr) .
     	  "] at port $port";
     
     	my $username = Client->ident_lookup(30) || "~unknown";
     	logmsg "User at $name:$port is $username";
     
     	print Client "Hello there, $username\@$name, it's now ",
     	   scalar localtime, "\n";
     }

Asynchronous Interface
----------------------

   The asynchronous interface is meant for those who know the ins and outs
of the select() call (the 4-argument version of select(), but I didn't
need saying that, did I?). This interface is completely object oriented.
The following methods are available:

`new Net::Ident SOCKET, $timeout'
     This constructs a new Net::Ident object, and initiates the connection
     to the remote ident daemon. The parameters are the same as described
     above for the *Net::Ident::lookup* subroutine. This method returns
     immediately, the supplied $timeout is only stored in the object and
     used in future methods.

     If you want to implement your own timeout, that's fine. Simply throw
     away the object when you don't want it anymore.

     The constructor will always succeed. When it detects an error,
     however, it returns an object that "has already failed" internally. In
     this case, all methods will return undef except for the `geterror'
     method, wich will return the error message.

     The timeout is not implemented using `alarm()'. In fact you can use
     `alarm()' completely independant of this library, they do not
     interfere.

`newFromInAddr $localaddr, $remoteaddr, $timeout'
     Alternative constructor, that takes two packed sockaddr structures.
     Otherwise behaves identical to the new constructor above.

`query $obj'
     This object method queries the remote rfc931 deamon, and blocks until
     the connection to the ident daemon is writable, if necessary (but you
     are supposed to make sure it is, of course). Returns true on success
     (or rather it returns the $obj itself), or undef on error.

`ready $obj' [`$blocking']
     This object method returns whether the data received from the remote
     daemon is complete (true or false). Returns undef on error. Reads any
     data from the connection.  If *$blocking* is true, it blocks and
     waits until all data is received (it never returns false when blocking
     is true, only true or undef). If *$blocking* is not true, it doesn't
     block at all (unless... see below).

     If you didn't call `query $obj' yet, this method calls it for you,
     which means it can block, regardless of the value of *$blocking*,
     depending on whether the connection to the ident is writable.

     Obviously, you are supposed to call this routine whenever you see that
     the connection to the ident daemon is readable, and act appropriately
     when this returns true.

     Note that once *ready* returns true, there are no longer checks on
     timeout (because the networking part of the lookup is over anyway).
     This means that even `ready $obj' can return true way after the
     timeout has expired, provided it returned true at least once before
     the timeout expired. This is to be construed as a feature.

`username $obj'
     This object method parses the return from the remote ident daemon, and
     blocks until the query is complete, if necessary (it effectively calls
     `ready $obj 1' for you if you didn't do it yourself). Returns the
     parsed username on success, or undef on error. In an array context,
     the return values are the same as described for the
     *Net::Ident::lookup* subroutine.

`getfh $obj'
     This object method returns the internal FileHandle used for the
     connection to the remote ident daemon. Invaluable if you want it to
     dance in your select() ring. Returns undef when an error has occurred.

`geterror $obj'
     This object method returns the error message in case there was an
     error. undef when there was no error.

   An asynchronous example implementing the above server in a
multi-threaded way via select, is left as an excersize for the interested
reader.

DISCLAIMER
==========

   I make NO WARRANTY or representation, either express or implied, with
respect to this software, its quality, accuracy, merchantability, or
fitness for a particular purpose.  This software is provided "AS IS", and
you, its user, assume the entire risk as to its quality and accuracy.

AUTHOR
======

   Jan-Pieter Cornet, <johnpc@xs4all.nl>

COPYRIGHT
=========

   Copyright (c) 1995, 1997, 1999 Jan-Pieter Cornet. All rights reserved.
You can distribute and use this program under the same terms as Perl
itself.

REVISION HISTORY
================

V1.20
     August 2, 1999. Finally implemented the long-asked-for
     lookupFromInAddr method. Other changes:

        * No longer imports ident_lookup into package FileHandle by
          default, unless you explicitly ask for it (or unless you
          installed it that way during compile time for compatibility
          reasons).

        * Allow adding an ident_lookup method to the Apache::Connection
          class, as a convenience for mod_perl script writers.

        * Rewritten tests, included test for the Apache::Connection method
          by actually launching apache and performing ident lookups from
          within mod_perl.

        * Moved selection of FileHandle/IO::Handle class out of the
          Makefile.PL.  PAUSE/CPAN didn't really like modules that weren't
          present in the distribution, and it didn't allow you to upgrade
          your perl version underneath.

V1.11
     Jan 15th, 1997. Several bugfixes, and some slight interface changes:

        * constructor now called new instead of `initconnect', constructor
          now always succeeds, if something has gone wrong in the
          constructor, all methods return undef (like getfh), except for
          `geterror', which returns the error message.

        * The recommended exported function is now `ident_lookup' instead
          of lookup

        * Fixed a bug: now chooses O_NDELAY or O_NONBLOCK from %Config,
          instead of hardcoding O_NDELAY (argh)

        * Adding a method to FileHandle would break in perl5.004, it
          should get added in IO::Handle. Added intelligence in
          Makefile.PL to detect that and choose the appropriate package.

        * Miscellaneous pod fixes.

        * Test script now actually tests multiple different things.

V1.10
     Jan 11th, 1997. Complete rewrite for perl5. Requires perl5.002 or up.

V1.02
     Jan 20th, 1995. Quite a big bugfix: "connection refused" to the ident
     port would kill the perl process with a SIGPIPE if the connect didn't
     immediately signal it (ie. almost always on remote machines). Also
     recognises the perl5 package separator :: now on fully qualified
     descriptors. This is still perl4-compatible, a perl5- only version
     would require a rewrite to make it neater.  Fixed the constants
     normally found in .ph files (but you shouldn't use those anyway).

     [this release wasn't called *Net::Ident*, of course, it was called
     *rfc931.pl*]

V1.01
     Around November 1994. Removed a spurious *perl5 -w* complaint. First
     public release.  Has been tested against *perl 5.000* and *perl
     4.036*.

V1.00
     Dunno, somewhere 1994. First neat collection of dusty routines put in
     a package.

SEE ALSO
========

   *Note Socket: Socket, RFC1413, RFC931


