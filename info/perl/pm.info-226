This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: MQSeries/QueueManager,  Next: MQSeries/Utils,  Prev: MQSeries/Queue,  Up: Module List

OO interface to the MQSeries Queue Manager
******************************************

NAME
====

   MQSeries::QueueManager - OO interface to the MQSeries Queue Manager

SYNOPSIS
========

     use MQSeries;
     use MQSeries::QueueManager;

     #
     # Simplest, trivial usage
     #
     my $qmgr = MQSeries::QueueManager->new( QueueManager => 'some.queue.manager' ) ||
       die("Unable to connect to queue manager\n");

     #
     # The best way to do error checking.  Handle the object
     # instantiation and connection to the queue manager independently.
     #
     my $qmgr = MQSeries::QueueMananer->new
       (
        QueueManager	=> 'some.queue.manager',
        NoAutoConnect	=> 1,
       ) || die "Unable to instantiate MQSeries::QueueManager object\n";

     $qmgr->Connect() ||
       die("Unable to connect to queue manager\n" .
     	"CompCode => " . $qmgr->CompCode() . "\n" .
     	"Reason => " . $qmgr->Reason() . "\n");

     #
     # Advanced usage.  Enable the connection timeout, and connection
     # retry logic.
     #
     my $qmgr = MQSeries::QueueManager->new
       (
        QueueManager 	=> 'some.queue.manager',
        NoAutoConnect	=> 1,
        ConnectTimeout	=> 120,
        RetryCount 	=> 60,
        RetrySleep 	=> 10,
       ) || die "Unable to instantiate MQSeries::QueueManager object\n";

     $qmgr->Connect() ||
       die("Unable to connect to queue manager\n" .
     	"CompCode => " . $qmgr->CompCode() . "\n" .
     	"Reason => " . $qmgr->Reason() . "\n");

DESCRIPTION
===========

   The MQSeries::QueueManager object is an OO mechanism for connecting to
an MQSeries queue manager, and/or opening and inquiring a queue manager
object.

   This module is used together with MQSeries::Queue and
MQSeries::Message, and the other MQSeries::* modules.  These objects
provide a simpler, higher level interface to the MQI.

   This module also provides special support for connect timeouts (for
interrupting MQCONN() calls that may hang forever), as well as connect
retry logic, which will retry failed MQCONN() calls for a specific list of
reason codes.

   See the "Special Considerations" section for a discussion of these
advanced, but powerful, features.

METHODS
=======

new
---

   The constructor takes a hash as an argument, with the following keys:

     Key            		Value
     ===            		=====
     QueueManager  		String
     Carp           		CODE reference
     NoAutoConnect			Boolean
     AutoCommit			Boolean
     ConnectTimeout		Numeric
     ConnectTimeoutSignal		String
     GetConvert     		CODE reference
     PutConvert     		CODE reference
     RetrySleep			Numeric
     RetryCount			Numeric
     RetryReasons			HASH Reference
     CompCode       		Reference to Scalar Variable
     Reason         		Reference to Scalar Variable

QueueManager
     This is simply the name of the Queue Manager to which to connect.
     This is passed directly to the MQCONN() call as-is.

     Normally, this is simply the name of the queue manager to which you
     wish to connect, but if the "default" queue manager is to be used,
     then this can either be the empty string "", or simply omitted
     entirely.

Carp
     This key specifies a code reference to a routine to replace all of the
     carp() calls in the API, allowing the user of the API to trap and
     handle all of the error message generated internally, or simply
     redirect how they get logged.

     For example, one might want everything to be logged via syslog:

          sub MyLogger {
              my $message = @_;
              foreach my $line ( split(/\n+/,$message) ) {
                  syslog("err",$message);
              }
          }

     Then, one tells the object to use this routine:

          my $qmgr = MQSeries::QueueManager->new
            (
             QueueManager 	=> 'some.queue.manager',
             Carp 		=> \&MyLogger,
            ) || die("Unable to connect to queue manager.\n");

     The default, as one might guess, is Carp::carp();

NoAutoConnect
     If the value of this argument is true, then the constructor will not
     automatically call the Connect() method, allowing the developer to
     call it explicitly, and thus independently error check object
     instantiation and the connection to the queue manager.  See the
     section on Error Handling in Special Considerations.

AutoCommit
     If the value of this argument is true, then pending transactions will
     be committed during object destruction.  If it is false, then pending
     transactions will be backed out before disconnecting from the queue
     manager during object destruction.

     See the section on "AutoCommit" in "Special Considerations".

ConnectTimeout
     If this value is given, it must be a positive integer.  This is the
     time, in seconds, in which an MQCONN() must complete before the MQI
     call will be interrupted.  The default value is zero, which means the
     MQCONN() call will not be interrupted.

     There are outage scenarios, in the experience of the author, where the
     MQCONN() call will block indefinetely and never return.  This happens
     when a queue manager is "hung", and completely unresponsive, in some
     cases.

     This feature should be used with caution, since it is implemented
     using a SIGALRM handler, and the alarm() system call.  See the section
     on "Connection Timeouts" in "Special Considerations".

     Attempts to use this feature on unsupported platforms that do not
     support signals will generate a warning, and be silently ignored.

ConnectTimeoutSignal
     By default, the ConnectTimeout mechanism is implemented using a signal
     handler for SIGUSR1, but the signal used to interrupt the MQCONN()
     call can be customized using this attribute.

     The signal handler installed by this API is done using local(), so the
     effects of the handler will only override the applications handler
     during the call to MQCONN().

     The string used for this attribute should be the short hand name of
     the signal, for example, to set the signal to SIGUSR2:

          my $qmgr = MQSeries::QueueManager->new
            (
             QueueManager		=> 'FOO',
             ConnectTimeout		=> 300,
             ConnectTimeoutSignal	=> 'USR2',
            ) || die;

RetryCount
     This is an integer value, and specifies the maximum number of times to
     retry the connection, before failing.  The default is 0.

RetrySleep
     This is an integer value, and specified the number of seconds to sleep
     between retries.  The maximum timeout for an outage is the product of
     the RetrySleep and RetryCount parameters.  The default is 0.

PutConvert, GetConvert
     These are CODE references to subroutines which are used to convert the
     data in a MQSeries::Message object prior to passing it to the MQPUT
     MQI call, or convert the data retreived from the queue by the MQGET
     MQI call before inserting it into a MQSeries::Message object.

     These must be CODE references, or the new() constructor will fail.  A
     properly written conversion routine will be passed a single scalar
     value and return a single scalar value.  In the event of an error, the
     conversion routine should return 'undef'.

     The example shown in the synopsis shows how one might use a pair of
     home grown encryption and decryption subroutines to keep data in clear
     text in core, but encrypted in the contents of the message on the
     queue.  This is probably not the most hi-tech way to encrypt MQSeries
     data, of course.

     The MQSeries::Message::Storable class provides an example of how to
     subclass MQSeries::Message to have this type of conversion handled
     transparently, in the class definition.

CompCode, Reason
     WARNING: These keys are deprecated, and their use no longer
     encouraged.  They are left in place only for backwards compabitility.

     See the docs for the NoAutoConnect argument, and the Connect() method.

     When the constructor encounters an error, it returns nothing, and you
     can not make method calls off of a non-existent object.  Thus, you do
     not have access to the CompCode() and Reason() method calls.  If you
     want to extract these values, you will have to pass a scalar reference
     value to the constructor, for example:

          my $CompCode = MQCC_FAILED;
          my $Reason = MQRC_UNEXPECTED_ERROR;

          my $qmgr = MQSeries::QueueManager->new
            (
             QueueManager		=> 'some.queue.manager',
             CompCode			=> \$CompCode,
             Reason			=> \$Reason,
            ) || die "Unable to open queue: CompCode => $CompCode, Reason => $Reason\n";

     But, this is ugly (authors opinion, but then, he gets to write the
     docs, too).

RetryCount
     The call to MQCONN() (implemented via the Connect() method), can be
     old to retry the failure for a specific list of reason codes.  This
     functionality is only enabled if the RetryCount is non-zero. By
     default, this value is zero, and thus retries are disabled.

RetrySleep
     This argument is the amount of time, in seconds, to sleep between
     subsequent retry attempts.

RetryReasons
     This argument is either an ARRAY or HASH reference indicating the
     specific reason code for which retries will be attempted.  If given as
     an ARRAY, the elements are simply the reason codes, and if given as a
     HASH, then the keys are the reason codes (and the values ignored).

Connect
-------

   This method takes no arguments, and merely calls MQCONN() to connect to
the queue manager.  The various options are all set via the
MQSeries::Queue constructor (see above).

   This method is called automatically by the constructor, unless the
NoAutoConnect argument is given.

   Note that this is a new method as of the 1.06 release, and is provided
to enable more fine grained error checking.  See the ERROR HANDLING
section.

Disconnect
----------

   This methodtakes no arguments, and merely calls MQDISC() to disconnect
from the queue manager.

   It is important to note that normally, this method need not be called,
since it is implicitly called via the object destructor.  If the
Disconnect() call errors need to be handled, then it can be done
explicitly.  See the ERROR HANDLING section.

Backout
-------

   This method takes no arguments, and merely calls MQBACK.  It returns
true on success, and false on failure.

Commit
------

   This method takes no arguments, and merely calls MQCMIT.  It returns
true on success, and false on failure.

Put1
----

   This method wraps the MQPUT1 call.  The arguments are a hash, with the
following key/value pairs (required keys are marked with a '*'):

     Key           Value
     ===           =====
     Message*      MQSeries::Message object
     Queue         String, or ARRAY reference (distribution list)
     QueueManager  String
     ObjDesc       HASH reference
     PutMsgOpts    HASH Reference
     PutMsgRecs    ARRAY Reference
     Sync          Boolean
     PutConvert    CODE reference

   The return value is true or false, depending on the success of the
underlying MQPUT1() call.  If the operation fails, then the Reason() and
CompCode() methods will return the appropriate error codes, if the error
was an MQSeries error.

   If a PutConvert() method failed before the actual MQPUT1() function was
called, then the Reason() code will be MQRC_UNEXPECTED_ERROR, and the
PutConvertReason() will be true.  All of the PutConvert() methods supplied
with the various MQSeries::Message subclasses in this distribution will
generate some form of error via carp (or the Carp attribute of the
objects, if overridden).

Message
     This argument is the message to be placed onto the queue.  The value
     must be an MQSeries::Message object.

Queue
     This is the queue, or list of queue if using a distribution list, to
     which to put the message.  If it is a single queue, then this value is
     a string, naming the queue.  If it is a distribution list, then this
     value is an ARRAY reference, listing the target queues.  There are
     three ways to specify the list.

     The list may be a simple array of strings:

          $qmgr->Put1(
                      Message => $message,
                      Queue => [qw( QUEUE1 QUEUE2 QUEUE3 )],
                     )

     or, it can be an array of arrays, each one specifying the queue and
     queue manager name of the target queue:

          $qmgr->Put1(
                      Message => $message,
                      Queue => [
                                [qw( QUEUE1 QM1 )],
                                [qw( QUEUE2 QM2 )],
                                [qw( QUEUE3 QM3 )],
                               ],
                     )

     or finally, it can be an array of hash references, each naming the
     queue and queue manager:

          $qmgr->Put1(
                      Message => $message,
                      Queue => [
          	                {
          			 ObjectName		=> 'QUEUE1',
          			 ObjectQMgrName		=> 'QM1',
          			},
          		        {
          			 ObjectName		=> 'QUEUE2',
          			 ObjectQMgrName		=> 'QM2',
          			},
          			{
          			 ObjectName		=> 'QUEUE3',
          			 ObjectQMgrName		=> 'QM3',
          			},
                               ],
                      )

     In the latter two cases, the queue manager names are optional.  Which
     method to use is largely a choice of style.

QueueManager
     Note that this key is *only* relevant when not using distribution
     lists.  This identifies the queue manager of the target queue, to
     which the message is being written.  This is an optional key.

ObjDesc
     The entire ObjDesc structure passed to the underlying MQPUT1() call
     can be specified via this key.  In this case, the Queue and/or
     QueueManager are simply ignored.  Use of this key would be considered
     somewhat non-conventional, as the OO API is attempting to hide the
     complexity of these underlying data structures.

     However, this allows the developer access to the entire ObjDesc, if
     necessary.

PutMsgOpts
     This argument forces the developer to specify the complete PutMsgOpts
     structure, and will override the use of convenience flags, such as
     Sync.  Similar to the use of ObjDesc, this is non-conventional, but
     provided to allow access to the complete API, if necessary.

PutMsgRecs
     This argument is relevant only when using distribution lists.

     The value is an ARRAY reference, specifying the put message records
     for the individual queues in the distribution list.  Normally, these
     are specified as part of the PutMsgOpts, but this API attempts to hide
     the complexity of the PutMsgOpts structure from the user.

     When using distribution lists, PutMsgRecs are often necessary to
     control how the MsgId, CorrelId, and three other specific fields in
     the MsgDesc are handled.

     For details, see the MQPUT() and MQPUT1() documentation in
     MQSeries(3).

Sync
     This is a flag to indicate that the Syncpoint option is to be used,
     and the message(s) not committed to the queue until an MQBACK or
     MQCOMM call is made.  These are both wrapped with the Backout() and
     Commit() methods respectively.

     The value is simply interpreted as true or false.

PutConvert
     See the new() constuctor documentation for the verbose details.  This
     can be specified for just the Put1() method in the event that a
     converted message format needs to be put to a queue on a
     MQSeries::QueueManager object for which default conversion routines
     have not been installed.

     If you have a QueueManager for which all of the Queue use the same
     message formats, then you can simply specify the PutConvert and
     GetConvert CODE references once, when the MQSeries::QueueManager
     object is instantiated.  Alternately, you may be specifying the
     conversion routined for only a few specific queues.  In the latter
     case, it is entirely possible that you will need to specify PutConvert
     when performing an MQPUT1 MQI call via the Put1() method.

CompCode
--------

   This method returns the MQI Completion Code for the most recent MQI
call attempted.

Reason
------

   This method returns the MQI Reason Code for the most recent MQI call
attempted.

PutConvertReason
----------------

   This method returns a true of false value, indicating if a PutConvert
method failed or not.  Similar to the MQRC reason codes, false indicates
success, and true indicates some form of error.  If there was no
PutConvert method called, this will always return false.

Reasons
-------

   This method call returns an array reference, and each member of the
array is a Response Record returned as a possible side effect of calling a
Put1() method to put a message to a distribution list.

   The individual records are hash references, with two keys: CompCode and
Reason.  Each provides the specific CompCode and Reason associated with
the put of the message to each individual queue in the distribution list,
respectively.

Open
----

   This method takes two optional (but typically not necessary) arguments,
and calls MQOPEN() on the Queue Manager, in order to enable the Inquire
method.  The arguments are a has, with the following keys:

     Key            		Value
     ===            		=====
     Options			MQOPEN 'Options' Values
     ObjDesc			HASH reference (MQOD structure)

   The Options default to MQOO_INQUIRE|MQOO_FAIL_IS_QUIESCING, which is
usually correct.  Note that you can not call MQSET() on a queue manager,
so MQOO_SET is meaningless, as are most of the other options.  Advanced
users can set this as they see fit.

   The ObjDesc argument is also not terribly interesting, as you most of
the values have reasonable defaults for a queue manager.  Again, the API
supports advanced users, so you can set this as you see fit.  The keys of
the ObjDesc hash are the fields in the MQOD structure.

   This method returns a true of false values depending on its success or
failure.  Investigate the CompCode() and Reason() for MQSeries-specific
error codes.

Close
-----

   This method takes no arguments, and merely calls MQCLOSE() to close the
actual queue manager object.  This is meaningful only if the queue manager
has been Open()ed for use by Inquire().

   It is important to note that normally, this method need not be called,
since it is implicitly called via the object destructor, if necessary.  If
the Close() call errors need to be handled, then it can be done
explicitly.  See the ERROR HANDLING section.

Inquire
-------

   This method is an interface to the MQINQ() API call, however, it takes
more convenient, human-readable strings in place of the C macros for the
selectors, as well as supports more readable strings for some of the data
values as well.

   For example, to query the Platform and DeadLetterQName of a queue
manager:

     my %qmgrattr = $qmgr->Inquire( qw(Platform DeadLetterQName) );

   The argument to this method is a list of "selectors", or QueueManager
attributes, to be queried.  The following table shows the complete set of
possible keys, and their underlying C macro.

   Note that this list is all-inclusive, and that many of these are not
supported on some of the MQSeries platforms.  Consult the IBM
documentation for such details.

     Key				Macro
     ===				=====
     AlterationDate              MQCA_ALTERATION_DATE
     AlterationTime              MQCA_ALTERATION_TIME
     AuthorityEvent              MQIA_AUTHORITY_EVENT
     ChannelAutoDef              MQIA_CHANNEL_AUTO_DEF
     ChannelAutoDefEvent         MQIA_CHANNEL_AUTO_DEF_EVENT
     ChannelAutoDefExit          MQCA_CHANNEL_AUTO_DEF_EXIT
     ClusterWorkLoadData         MQCA_CLUSTER_WORKLOAD_DATA
     ClusterWorkLoadExit         MQCA_CLUSTER_WORKLOAD_EXIT
     ClusterWorkLoadLength       MQIA_CLUSTER_WORKLOAD_LENGTH
     CodedCharSetId              MQIA_CODED_CHAR_SET_ID
     CommandInputQName           MQCA_COMMAND_INPUT_Q_NAME
     CommandLevel                MQIA_COMMAND_LEVEL
     DeadLetterQName             MQCA_DEAD_LETTER_Q_NAME
     DefXmitQName                MQCA_DEF_XMIT_Q_NAME
     DistLists                   MQIA_DIST_LISTS
     InhibitEvent                MQIA_INHIBIT_EVENT
     LocalEvent                  MQIA_LOCAL_EVENT
     MaxHandles                  MQIA_MAX_HANDLES
     MaxMsgLength                MQIA_MAX_MSG_LENGTH
     MaxPriority                 MQIA_MAX_PRIORITY
     MaxUncommittedMsgs          MQIA_MAX_UNCOMMITTED_MSGS
     PerformanceEvent            MQIA_PERFORMANCE_EVENT
     Platform                    MQIA_PLATFORM
     QMgrDesc                    MQCA_Q_MGR_DESC
     QMgrIdentifier              MQCA_Q_MGR_IDENTIFIER
     QMgrName                    MQCA_Q_MGR_NAME
     RemoteEvent                 MQIA_REMOTE_EVENT
     RepositoryName              MQCA_REPOSITORY_NAME
     RepositoryNamelist          MQCA_REPOSITORY_NAMELIST
     StartStopEvent              MQIA_START_STOP_EVENT
     SyncPoint                   MQIA_SYNCPOINT
     TriggerInterval             MQIA_TRIGGER_INTERVAL

   The return value of this method is a hash, whose keys are those given
as arguments, and whose values are the queried queue manager attributes.
In almost all cases, the values are left unmolested, but in the following
case, the values are mapped to more readable strings.

Platform			(integer)
          Key				Macro
          ===				=====
          MVS                         MQPL_MVS
          NSK                         MQPL_NSK
          OS2                         MQPL_OS2
          OS400                       MQPL_OS400
          UNIX                        MQPL_UNIX
          Win16                     	MQPL_WINDOWS
          Win32                  	MQPL_WINDOWS_NT

ObjDesc
-------

   This method can be used to query the ObjDesc data structure.  If no
argument is given, then the ObjDesc hash reference is returned.  If a
single argument is given, then this is interpreted as a specific key, and
the value of that key in the ObjDesc hash is returned.

   NOTE: This method is meaningless unless the queue manager has been
MQOPEN()ed via the Open() method.

Special Considerations
======================

AutoCommit
----------

   Normally, when you have pending transactions (i.e. MQPUT() and/or
MQGET() calls with syncpoint), they will be automatically committed when
MQDISC() is called.  The MQSeries::QueueManager object destructor, in an
attempt to make things easy for the programmer, automatically calls
MQDISC() for you.  The result is that transactions will be automatically
committed when the application exits in any way that allows the object
destruction to occur.

   This behavior is somewhat counter intuitive, as you would expect
transactions to be backed out unless you explicitly say otherwise (i.e.
call MQCMIT(), or in this context, the Commit() method call).

   As of the 1.12 release of the MQSeries Perl API, this behavior is under
the control of the developer.  The AutoCommit argument to the object
constructor is a Boolean value that specifies whether AutoCommit is on or
off.  If enabled, then a pending transaction will be committed before
disconnecting.  If disabled, then the transaction will be backed out, and
only if the backout succeeds will we cleanly disconnect.

   NOTE: The default behavior is backwards compatible in the 1.12 release,
meaning that AutoCommit is enabled by default.  However, if you do not
specify the AutoCommit behavior explicitly, then the automatic commit of a
pending tranaction will generate a warning when the object is destroyed.
This is because we (the MQSeries Perl API authors) feel that depending on
this functionality is dangerous.

   ANOTHER NOTE: The default behavior will change with the 1.13 release,
as AutoCommit will default to 0, not 1, making the intuitive behavior the
default.

Connection Timeout Support
--------------------------

   There are known outage scenarios wherein the queue manager will be in a
"hung" state, where it is entirely unresponsive, but still up and running.
Attempts to connect to such a queue manager can block indefinetely, with
the MQCONN() call never returning, until the queue manager is shutdown and
restarted.  Normally, applications can not trap this error, since they
will be stuck in the MQCONN() call, forever.

   By setting the ConnectTimeout argument to the MQSeries::QueueManager
constructor, a time limit on MQCONN() can be imposed, and applications
will be able to detect this situation, and take action, if so desired.

   This functionality is implemented by forking a child process, which
sleeps for the duration of the ConnectTimeout, and then sends a signal to
the parent to interrupt the MQCONN() call.  If the MQCONN() call succeeds
before the timeout is reached, then the parent kill the child with the
same signal.

   By default, SIGUSR1 is used, and the handlers are installed locally, so
there should be no conflict with any signal handlers installed by the
application, unless you really need your own SIGUSR1 to be enabled during
the MQCONN() call.  You can customize the signal used via the
ConnectTimeoutSignal argument.

   If the timeout occurs, it will be considered a retryable error. (See
the next section).

   NOTE: This functionality is only supported on platforms that support
fork(), and signals, of course.  Win32 is not supported, since it does not
support sending signals to other processes.

Connection Retry Support
------------------------

   Normally, when MQCONN() fails, the method that called it (Connect() or
new()) also fails.  It is possible to have the Connect() method retry the
MQCONN() call for a specific set of reason codes.

   By default, the retry logic is disabled, but it can be enabled by
setting the RetryCount to a non-zero value.  The list of reason codes
defaults to a few reasonable values, but a list of retryable codes can be
specified via the RetryReasons argument.

   You are probably wondering why this logic is useful for MQCONN().  The
choice of the default RetryReasons is not without its own reason.

   Consider an application that loses its connection to its queue manager,
and thus crashes and restarts.  It may very well attempt to reconnect
before the queue manager has recovered, and this support allows the
application to retry the connection for a while, until it succeeds.

   Alternately, consider an application that is started at boot time,
possible in parallel with the queue manager.  If the application comes up
before the queue manager, the MQCONN() call will fail.  Retrying this
initial connection will make the application startup more robust.

   This makes it easier to have applications recover from queue manager
failures, or that have more robust startup logic, but note that this retry
logic only applies to the initial connection.  Reconnecting at arbitrary
points in the code is far more complex, and it left as a (painful)
exercise to the reader.

Error Handling
--------------

   Most methods return a true or false value indicating success of
failure, and internally, they will call the Carp subroutine (either
Carp::Carp, or something user-defined) with a text message indicating the
cause of the failure.

   In addition, the most recent MQI Completion and Reason codes will be
available via the CompCode() and Reason() methods:

     $qmgr->CompCode()
     $qmgr->Reason()

   When distribution lists are used, then it is possible for a list of
reason codes to be returned by the API.  Normally, these are buried inside
the ObjDesc strucure, but they are also available via the

     $qmgr->Reasons()

   method.  In this case, the $queue->Reason() will always return
MQRC_MULTIPLE_REASONS.  The return value of the Reasons() method is an
array reference, and each array item is a hash reference with two keys:
CompCode and Reason.  These correspond, respectively, with the CompCode
and Reason associated with the individual queues in the distribution list.

   For example, the Reason code associated with the 3rd queue in the list
would be:

     $qmgr->Reasons()->[2]->{Reason}

   In the case of the constructor new(), which returns nothing when it
fails, these methods are not available.  Most applications will not need
to handle the specific CompCode and Reason when the instantiation fails,
but if necessary, these can be obtained in one of two ways.

   The older method, which is supported for backwards compabitility but
strongly discouarged, is to pass references to scalar variables to new().
See the new() documentation above for more details.

   The newer method would be to explicitly call the Open() method, and
error check it yourself.  This will mean that the constructor will now
fail only if there is an error processing the constructor arguments, as
opposed to an error in the MQSeries infrastructure.

   Some examples should make this clear.

   The simplest way to create an MQSeries::QueueManager object is:

     my $qmgr = MQSeries::QueueManager->new
       (
        QueueManager		=> 'some.queue.manager',
       ) || die;

   But in this case, the connection to the queue manager could fail, and
your application will not be able to determine why.

   In order to explicitly have access to the CompCode and Reason one would
do the following:

     my $qmgr = MQSeries::QueueManager->new
       (
        QueueManager		=> 'some.queue.manager',
        NoAutoConnect		=> 1,
       ) || die "Unable to instantiate MQSeries::QueueManager object\n";

     # Call the Connect method explicitly
     unless ( $qmgr->Connect() ) {
       die("Connection to queue manager failed\n" .
           "CompCode => " . $qmgr->CompCode() . "\n" .
           "Reason   => " . $qmgr->Reason() . "\n");
     }

Conversion Precedence
---------------------

   Once you have read all the MQSeries::* documentation, you might be
confused as to how the various PutConvert/GetConvert method arguments and
constructor arguments interact with the MQSeries::Message PutConvert() and
GetConvert() methods.

   The following is the precedence of the various places you can specify a
PutConvert or GetConvert subroutine, from highest to lowest:

     [A] Put(), Get(), and Put1() method arguments
     [B] MQSeries::Message PutConvert() and GetConvert() methods
     [C] MQSeries::Queue object defaults (set as arguments to new())
     [C] MQSeries::QueueManager object defaults (set as arguments to new())

   The cleanest way to code these is probably (and here your mileage will
vary wildly with your tastes) to implement a subclass of MQSeries::Message
which provides the appropriate GetConvert() and PutConvert() methods, one
seperate class for each type of data conversion which is necessary.

   Then the conversion happens "under the covers" when message objects of
that class are put to or gotten from a queue.

SEE ALSO
========

   MQSeries(3), MQSeries::Queue(3), MQSeries::Message(3)


File: pm.info,  Node: MQSeries/Utils,  Next: MRP/BaseClass,  Prev: MQSeries/QueueManager,  Up: Module List

Internal utility functions
**************************

NAME
====

   MQSeries::Utils - Internal utility functions

SYNOPSIS
========

     use MQSeries::Utils qw(ConvertUnit);

     my $wait_value = ConvertUnit('Wait', '45s');
     my $exp_value = ConvertUnit('Expiry', '1.5m');

DESCRIPTION
===========

   The MQSeries::Utils module contains internal helper functions that are
generally not of interest to users of the MQSeries module.

FUNCTIONS
=========

ConvertUnit
-----------

   This function can convert values for the 'Wait' and 'Expiry' options
from symbolic values into the numeric values required. Symbolic values are
numeric values ending in an 's' for seconds or an 'm' for minutes.

   As 'Wait' values are in 1/1000 of a second and 'Expiry' is in 1/10 of a
second, using symbolic values can help avoid mistakes such as getting the
magnitude of these numbers wrong by one or more orders of magnitude.

SEE ALSO
========

   MQSeries(3)


File: pm.info,  Node: MRP/BaseClass,  Next: MRP/Interface,  Prev: MQSeries/Utils,  Up: Module List

My base class object
********************

NAME
====

   MRP::BaseClass - My base class object

DESCRIPTION
===========

   Base class for my perl objects that generates the class interface from
a definition.

SYNOPSIS
========

   The aim of this package is to allow you to define a classes interface,
and have perl generate all of the standard functions for you. Currently,
you can define:

fields
     Member access functions are auto-generated so that nowhere in your
     code do you ever directly access member variables.

package variables
     Class functions are auto-generated to make package variables work like
     static class members.

default variables
     The package variable an be made to act as the default value for a
     field of the same name.

delegation support
     Simply specify which field is a delegate and which funcitons to
     delegate to it, and the glue code is auto-generated.

   The other realy usefull thing it does is provide dramaticaly better
error messages when methods or static functions canot be found. Try
invoking the <C -w> flag. It even lists possible correct spellings of
misspelled function names!

   As a matter of course, I include the class definition in a BEGIN block
at the end of the package. This allows the interface to be checked, and
the code to be generated at compile time. This has the additional benefit
that these checks are performed during a <C -c> compilation.

SEE ALSO
========

   This module relies upon these modules:

MRP::Interface
MRP::Text
MRP::Introspection
A skeletal derived class
========================

     package myDerived;

     use strict;                   # I'm paranoid about this...
     use vars qw ( @ISA %fields );

     use MRP::BaseClass;

     BEGIN {                       # Putting this code in BEGIN makes
                                   # errors show up at compile time.
        # our parent class - in this case only MRP::BaseClass.
        @ISA = ('MRP::BaseClass');
        # the object model - member names and initial values
        %fields = (
     	       'number' => 1,
     	       'hash' => undef,
                   'array' => undef,
     	       );
        # check4Clashes ensures that you are not overriding base class
        # member variables and creates the member access functions.
        myDerived->check4Clashes();
     }

     # Our constructor - this one is very simple.
     sub new {
        my $class = shift;              # we need to know what type we are.
        my $self = new MRP::BaseClass;  # get an object from the emediate parent
     
        $self->rebless ($class);        # re-bless the object into this package
                                        # this is when MRP::BaseClass sets up
                                        # member variables
        return $self;                   # return the object.
     }

     # This function is called during re-blessing. Here we are just going
     # to set the member 'hash' to a new hash reference.
     # At this point $self is blessed into this package, and contains
     # all of its members. You could call member funcitons from here if
     # you realy wanted to.
     sub initialize {
        my $self = shift;
        $self->hash({});
        $self->array([]);
     }

   You can now use this class as follows:

     $thing = new myDerived();          # get a new myDerived object
     $thing->hash->{'red'} = 1;         # set the key red in hash to 1
     $thing->number(5);                 # set the value of number to 5
     $thing->array->[0] = "goo";        # set the first element of array to 'goo'
     $thing->array->('a','b');          # this is not what you meant. The
                                        # array ref will be replaced with 'a' and
                                        # the rest of the parameters will be lost.
     @{$thing->array} = ('a','b');      # this is better.
     $thing->array([('a','b')]);        # replace the refrerence with a new one
                                        # containing the array ('a','b')

     print "I have the number ", $thing->number, " in me\n";

   A class derived from myDerived would just substitute the name myDerived
for MRP::BaseClass.  Hey presto - all sorted!

   The return value of the member access functons is the value of the
member. If a value is given to the member access function then the member
is set to that value, and it's new value is returned. Thus:

     $val = $thing->hash;     # puts the same reference in $val that was in hash
     $thing->hash(\%myHash);  # sets the hash reference used to\%myHash

Using clever fields
===================

   MRP::BaseClass is clever enough to create hash and array members and
specialised access functions, as well as methods that check the interface
of methods. Include a fields like this...

     %fields = (
     	       myHashMember => {},
     	       myArrayMember => [],
                myDelegate => MRP::Interface->ActionDelegate,
     	       );

   and MRP::BaseClass will do the following:

   * During rebless, a new hash or array ref will be put into these
     members.  You do not need to add these parts in initialize()

   * During member access generation, member access functions will be
     generated that understand that these members are hashes or arrays.

   * A member access function named *field_ref* gives you access to the
     actual member variable.

   * When you set $obj->myDelegate, it checks that the new object
     implements the interface ActionDelegate.

   So, reworking the original example,

     %fields = (
     	       'number' => 1,
     	       'hash' => {},   # put an empty hash here
                'array' => [],  # and an empty array here
     	       );

   The initialize subroutine can be discarded - you don't need to set
anything up now. The rest of the code is unchanged. You can access the
members as follows:

     $thing = new myDerived;          # get an object as before
     $thing->number(50);              # access to scalars doesn't change
     $thing->hash('foo'=>1,'bar'=>2); # sets hash to the value passed.
     $ref = $thing->hash;             # returns the reference used
     $val = $thing->hash->{'foo'};    # return 1
     %hash = $thing->hash;            # sets the contence of %hash equal to hash
     $thing->array(@list);            # sets the value of array to @list
     @list = $thing->array();         # sets the value of @list to array
     $array = $thing->array;          # sets $array to the same reference as array
     $val = $thing->array->[3];       # sets $val equal to the 3rd element of array
     $thing->array(\@array);          # sets array to a one member list containing
                                      # \@array. array and @array still point to
                                      # different objects
     $thing->array_ref(\@anarray);    # set array to the reference of @anarray. They
                                      # now refer to the same object.
     $thing->hash_ref(\%ahash);       # likewise, hash now refers to ahash.

Package variables
=================

   MRP::BaseClass will also generate access functions for package
variables. You must list the ones that you want to expose in the
@public_vars array. When check4Clashes is invoked, it will generate access
functions for each of the values in this array. For example,

     package myDerived;
     use strict;
     use vars qw(@ISA @public_vars $scalar %hash @array);
     use MRP::BaseClass;

     @ISA = qw(MRP::BaseClass);
     @public_vars = qw($scalar %hash @array);
     myDerived->check4Clashes();

     ...

     $s = myDerived->scalar;      # set $s to $myDerived::scalar
     myDerived->hash(%newValue);  # set %myDerived::hash to %newValue
     @list = myDerived->array;    # set @list to @myDerived::array

   The benefit of this is that in any package derived from myDerived, you
can still access these variables. This makes package variable access
follow all the same rules as member variables do for inheritance. One
freebie is that you can access these package variables via an object. So,
if $error is a global scalar then $obj->error would access the global
value of error for you. In this way, global variables are made to work
like static class members.

Package variables and fields with the same name
===============================================

   There will be cases when the same variable is used for a package
variable and field name. If you include the variable both in fields and in
public_vars, then the access function will decide which value to return
based upon whether it was invoked as a class or objet method.

     package myDerived;
     use strict;
     use vars qw(@ISA @public_vars %fields $error $linewidth);
     use MRP::BaseClass;

     @ISA = qw(MRP::BaseClass);
     %fields = { $error=>undef, };
     @public_vars = qw($error);
     myDerived->check4Clashes();

     ...

     $t = new myDerived;   # get a new object
     $t->error;            # returns the error field of object $t
     myDerived->error;     # returns the error associated with the package

Default variables
=================

   These are specified in the @defaults array. They do not need to be
listed in either fields or public_vars. A field and a package variable
will be generate, with the field providing the object-specific value and
the package variable provides the default value. This is returned when you
query an object for it, and the object value is undef. So - to illustrate
with the linewidth field:

     package myDerived;
     use strict;
     use vars qw(@ISA @defaults $linewidth);
     use MRP::BaseClass;

     @ISA = qw(MRP::BaseClass);
     @defaults = qw($linewidth);
     myDerived->check4Clashes();
     
     ...

     $t = new myDerived;        # make a new myDerived object
     $t->linewidth(72);         # set linewidth to 72 for this object
     myDerived->linewidth(70);  # set the defuault value to 70
     print $t->linewidth, "\n"; # will print '72'
     $t->linewidth(undef);      # make sure that linewidth is undef
     print $t->linewidth, "\n"; # will now print '70' - the default value

Delegation support
==================

   Very often, an object will contain a reference to another object that
it uses to implement part of its public interface. Usualy this is achieved
by just forwarding the function calls directly. MRP::BaseClass will
generate these functions automaticaly from the %delegates hash.

     package myComposite;
     use strict;
     use MRP::BaseClass;

     use vars qw(%fields %delegates @ISA);

     BEGIN {
       @ISA = qw(MRP::BaseClass);
       %delegates = (
                     stringMaker => [qw(toString toText)],
                    );
       myComopsite->check4Clashes();
     }

   ... insert new function and the rest of the functionality here...

   The delegates hash contains field names as keys followed by an arrray
reference containing function names. Thus, code will be generated to wire
myComoposite->toString to myComposite>stringMaker->toString. The arguments
are forwarded, so that myComposite objects share a subset of the interface
of the stringMaker delegate.

   I have invented a hypothetical class called StringMaker that can write
out text in different languages. I wish that I had one during school!  It
can expand messages into a string with `toText' and to formatted text with
toString. It can also have its target set with language. I do not wish
myComposite to have a language method, but I do wish it to be able to
write out text.

     $mc1 = new myComposite(); # get a composite object
     $mc2 = new myComposite(); # and another
     $mc1->stringMaker($sm1); # set stringMaker to $sm1
     $sm1->language('English UK'); # and set the stringMaker language to british.
     $mc2->stringMaker($sm2); # set this stringmaker as well
     $sm2->language(french); # and set the language to french

     print $mc1->toText('Apologise'); # an eloquant british apology
     print $mc2->toText('Apologise'); # a beautifull french apology

   If you try to use a field as a delegate that appears in the fields
hash, then a fatal error message will be printed.

Delegation support with type checking
=====================================

   It is not possible to check that the methods are legal for the
delegate, as the type of the delegate is not known at compile time.
However, by giving an interface object rather than a function name, the
object can be validated when the delegate is set.

     %delegates = (stringMaker => [MRP::Interface->StringMaker];);

   Now, any object put into the stringMaker field of this class must
implement the interfave StringMaker, or an exception will be thrown.

Enhanced <C -w> diagnostics
===========================

   If you run your script with <C -w> invoked, then MRP::BaseClass gives
you some extra diagnostics that I have found to be very usefull. The first
line is of the form:

   Can't access 'funcName' in [object/package] [objectName/packageName]:

   This clearly describes which function could not be located, whether it
was invoked as an object or package function, and the object or package.

   There may follow a section where the program lists potential
corrections. Thus, a common mistake I make is to type check4clashes -
incorrect case. In response to this, it would sudgest that I use the
function MRP::BaseClass::check4Clashes. It lists both similar filed and
function names.

   The next line says where the error occured, in the form `in
temp/testMutipleInheritance.pl at line 40'.

   It then dumps the model for the object. This consists of its fields and
their values, all methods that can be directly accessed via inheritance,
and all package variables. The function list does not include functions in
baseclasses that are overridden in derived classes, and it doesn't include
functions starting with a leading underscore.

   Following this, a complete stack trace is displayed.

Functions
=========

new
     Returns a new MRP::BaseClass object. This can then be reblessed into
     your package.

rebless
     Converts a base class into your class!  Call as $self->rebless($class)
     where $self is a base class object.  It returns $self, blessed, with
     the correct member variables. It is at this time that initialize, if
     present, is invoked. This functon should be used in every constructor
     that has to bless an object from a base class that is derived from
     MRP::BaseClass into the current package. If you employ multiple
     inheritance of field members, then use $class->rebless($parent1,
     $parent2...). This is clever enough to combine the data members from
     multiple parents. Therefore, it implements multiple inheritance by
     combining all fields within a single namespace, rather than the c++
     approach of each class having its own namespace within the object.
     This should work fine for most things.

initialize
     Override this in each derived class to provide class specific
     initialization. For example, initialize may put arrays into member
     variables that need them. MRP::BaseClass will not complain if you do
     not provied an initialize function. It will assume that it is not
     needed.

clone
     Returns a new object that is a clone of this one. Currently it copies
     scalars and references and then blesses the new object into the same
     class as the cloned object.  This is a shallow copy by default. Invoke
     it will a true argument and it will do a deep copy, calling clone for
     all objects it can. If you invoke clone with `shallow' then you force
     a shallow copy. Override this in a base class if this is not the
     behavure you want. For example, my MRP::Document objects return
     themselves when you call clone, so that only one object exists for
     each directory being documented.

_PrintMembers
     This function is provided for debugging.  It returns a string
     representaion of your object model, including members, methods and
     package variables.

check4Clashes
     Call this function after you have defined your classes interface. It
     does the following:

        * Checks the `%fields' of all classes in @ISA to ensure that you
          are not redefining members

        * Checks the interface of all classes in @ISA to ensure that you
          have no ambiguously inherited function calls that are not
          disambiguated in the current class.

        * Generates code to support member variables and static variables
          via access functions.

        * Generates code to support simple delegation models where function
          arguments are forwarded unchanged.

     The template for the automaticaly generated code can be over-ridden in
     any subclass to give more precise functionality. For example, in
     MRP::Matrix, the delegation funciton is replaced with one that
     systematicaly modifies the argumet list. This is a painless operation
     under this system.

package::memberAccess
=====================

   When the class is created, MRP::BaseClass creates a package called
class::memberAccess. This package contains the member access functions.
MRP::BaseClass then makes class::memberAccess the first parent in
@class::ISA. Thus, you can do things like this:

     package myPath;
     ...
     %fields = (path => []);
     myPath->check4Clashes();
     ...
     sub path {
     	my $self = shift;
     	my @path = $self->SUPER::path;
     	return join "/", @path;
     }

   Because the member access functions are in a seperate package, you can
still create functions of the same name in your package without 'loosing'
the member access. Cool!

Other usefull functions
=======================

   These functons are very usefull, but are more aprpreate to packages
than members. They all work regardless of whether invoked as a class or
object method.

Class variables

    _ISA
          In a scalar context, this function returns a reference to the ISA
          array for the package. In an array context it returns the
          contence of ISA for the package.

    _fields
          In a scalar context, this function returns a reference to the
          fields hash for the package. In an array context it returns the
          contence of fields for the package as a list of key/value pairs.

Text Formatting

    _pretyArray
          This function takes either an array or a reference to an array.
          It returns a string representation of the array.

    _pretyHash
          This function takes a leader string followed by either a hash or
          a reference to a hash. The leader sequene is prepended to each
          line of text. The function returns a single string representing
          the hash contence.

Inheriting from an MRP::BaseClass-derived object
================================================

   This is as simple as extending MRP::BaseClass. Optionaly define
%fields, @public_vars and @defaults, write an initialize function, and
then call check4Clashes. Then in the new function, get an object for the
imediate base class and call rebless for it.

     package myBox;

     use strict;
     use vars qw(@INC, %fields, @defaults);
     use myGraphable;

     BEGIN {
       @ISA = qw(myGraphable);
       %fields = (
         'x'=>undef, 'y'=>undef, 'w'=>undef, 'h'=>undef
       );
       @defaults = qw($color);
       myBox->check4clashes();
     }

     sub new {
       my $class = shift;
       my $self = new myGraphable;
       $self->rebless($class);
       return $self;
     }

     ... everything else goes here ...

Multiple inheritance
====================

   Much of the strife of multiple inheritance is taken care of for you.
Simply use the multi-argument form of rebless to create the new object.

     package multiple;
     use myGlyph;
     use myPersistant;

     @ISA = qw(myGlyph myPersistant);

     sub new {
       my $class = shift;
       my $glyph = new myGlyph;
       my $persistant = new myPersistant;
       my $self = multiple->rebless($glyph,$persistant);
       return $self;
     }

   ... everything else here ...

   Of course, you could include %fields, @public_vars and @defaults to
give this package extra behaviour, and you may wish to define initialize.

Multiple inheritance involving non-MRP::BaseClass parents
=========================================================

   check4Clashes stops searching a root of an inheritance hierachy when it
can find no baseclasses that support _containsFields. This section
describes how to implement _containsFields so that you can add your
classes into this framework if you wish to. The premice is that you will
only allow people to access member variables outside of the package
through access functions, and that your stoorage method doesn't clash with
mine.

   _containsFields is responsible for comparing a classes fields with the
set in the calling package. The MRP::BaseClass implimentation will work
for cases where all of the classes that contribute fields are derived from
MRP::BaseClass, and relies on my use of the %fields hash.

   _containsFields assumes that the first argument is the package that it
is being called in.  The following arguments are taken to be a list of
fields which to check are not found in members of the current package.

   It should return either undef or a reference to an array of name
clashes in the format `package::variable'. These clashes should be the
combination of classes with this package and with all of the base classes.

   So it would look something like   _containsFields {     my $class =
shift;     my @toCheck = @_;

     foreach @toCheck {
     	check that they are not in me.
     	  If they are, add them to the list of clashes to return.
     }

     add all base class clashes to your list of clashes

     if there were name clashes return a reference to them

     otherwise return undef
       }

   It is as simple as that. Currently, member variables are contained as
keys within the $self hash reference. I provide access functions for all
of the keys mentioned by name in %package::fields when check4Clashes is
called. If anybody adds keys afterwards, member access functions are not
generated for them. I can not be bothered to create a
public:protected:private system. In the pod I just don't document private
stuff.

Modifying the code generated for variable access and delegation support
=======================================================================

   Here are the parameters that are passed into the code-generating
functions.

thingy
     The class (possibly an object?) that the function is being generated
     for. You can use this to access other functions.

memberPackage
     The package that the function must be compiled into. Normaly you would
     include `package $memberPacage' as the first line of the text.

delegate
     The name of the field that is acting as a delegate

interface
     An MRP::Interface object - the generated code must ensure that objects
     implement the correct interface before setting the field.

functions
     The name of the function that the delegate is providing

    name
          The name that you must give the function

    item
          The name of the field that this function must provide access to.

     Here are the funcitons themselves.

    _delegateFunc($thingy, $memberPackage, $delegate, $function)
    _delegateAccess($thingy, $memberPackage, $item, $interface, $interface.....)
    _fieldScalarFunc($thingy, $memberPackage, $name, $interface, $item)
    _packageScalarFunc($thingy, $memberPackage, $name, $item)
    _fieldArrayFunc($thingy, $memberPackage, $name, $item)
    _packageArrayFunc($thingy, $memberPackage, $name, $item)
    _fieldHashFunc($thingy, $memberPackage, $name, $item)
    _packageHashFunc($thingy, $memberPackage, $name, $item)
    _packageAndField($thingy,$memberPackage,$item,$fieldFunc,$packageFunc)
          Handles the case when you have a static variable and a field of
          the same name

    _defaultField($thingy,$memberPackage,$item,$fieldFunc,$packageFunc)
          Handles the case when you have a static variable that provides
          the default value for a field

AUTHOR
======

   Matthew Pocock mrp@sanger.ac.uk


