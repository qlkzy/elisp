This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: XML/Checker/Parser,  Next: XML/Config,  Prev: XML/Checker,  Up: Module List

an XML::Parser that validates at parse time
*******************************************

NAME
====

   XML::Checker::Parser - an XML::Parser that validates at parse time

SYNOPSIS
========

     use XML::Checker::Parser;

     my %expat_options = (KeepCDATA => 1,
     		      Handlers => [ Unparsed => \&my_Unparsed_handler ]);
     my $parser = new XML::Checker::Parser (%expat_options);

     eval {
         local $XML::Checker::FAIL = \&my_fail;
         $parser->parsefile ("fail.xml");
     };
     if ($@) {
         # Either XML::Parser (expat) threw an exception or my_fail() died.
         ... your error handling code here ...
     }

     # Throws an exception (with die) when an error is encountered, this
     # will stop the parsing process.
     # Don't die if a warning or info message is encountered, just print a message.
     sub my_fail {
         my $code = shift;
         die XML::Checker::error_string ($code, @_) if $code < 200;
         XML::Checker::print_error ($code, @_);
     }

DESCRIPTION
===========

   XML::Checker::Parser extends *Note XML/Parser: XML/Parser,

   I hope the example in the SYNOPSIS says it all, just use *Note
XML/Checker/Parser: XML/Checker/Parser, as if it were an XML::Parser.  See
*Note XML/Parser: XML/Parser, for the supported (expat) options.

   You can also derive your parser from XML::Checker::Parser instead of
from XML::Parser. All you should have to do is replace:

     package MyParser;
     @ISA = qw( XML::Parser );

   with:

     package MyParser;
     @ISA = qw( XML::Checker::Parser );

XML::Checker::Parser constructor
================================

     $parser = new XML::Checker::Parser (SkipExternalDTD => 1, SkipInsignifWS => 1);

   The constructor takes the same parameters as *Note XML/Parser:
XML/Parser, with the following additions:

SkipExternalDTD
     By default, it will try to load external DTDs using LWP. You can
     disable this by setting SkipExternalDTD to 1. See `External
     DTDs|"External DTDs"' in this node for details.

SkipInsignifWS
     By default, it will treat insignificant whitespace as regular Char
     data.  By setting SkipInsignifWS to 1, the user Char handler will not
     be called if insignificant whitespace is encountered.  See
     `INSIGNIFICANT_WHITESPACE', *Note XML/Checker: XML/Checker, for
     details.

LWP_UserAgent
     When calling parsefile() with a URL (instead of a filename) or when
     loading external DTDs, we use LWP to download the remote file. By
     default it will use a *Note LWP/UserAgent: LWP/UserAgent, that is
     created as follows:

          use LWP::UserAgent;
          $LWP_USER_AGENT = LWP::UserAgent->new;
          $LWP_USER_AGENT->env_proxy;

     Note that `env_proxy' in this node reads proxy settings from your
     environment variables, which is what I need to do to get thru our
     firewall.  If you want to use a different LWP::UserAgent, you can
     either set it globally with:

          XML::Checker::Parser::set_LWP_UserAgent ($my_agent);

     or, you can specify it for a specific XML::Checker::Parser by passing
     it to the constructor:

          my $parser = new XML::Checker::Parser (LWP_UserAgent => $my_agent);

     Currently, LWP is used when the filename (passed to parsefile) starts
     with one of the following URL schemes: http, https, ftp, wais,
     gopher, or file (followed by a colon.) If I missed one, please let me
     know.

     The LWP modules are part of libwww-perl which is available at CPAN.

External DTDs
=============

   XML::Checker::Parser will try to load and parse external DTDs that are
referenced in DOCTYPE definitions unless you set the SkipExternalDTD
option to 1 (the default setting is 0.)  See `CAVEATS|"CAVEATS"' in this
node for details on what is not supported by XML::Checker::Parser.

   *Note XML/Parser: XML/Parser, (version 2.27 and up) does a much better
job at reading external DTDs, because recently external DTD parsing was
added to expat.  Make sure you set the *Note XML/Parser: XML/Parser,
option ParseParamEnt to 1 and the XML::Checker::Parser option
SkipExternalDTD to 1.  (They can both be set in the XML::Checker::Parser
constructor.)

   When external DTDs are parsed by XML::Checker::Parser, they are located
in the following order:

   * With the %URI_MAP, which can be set using map_uri.  This hash maps
     external resource ids (like system ID's and public ID's) to full path
     URI's.  It was meant to aid in resolving PUBLIC IDs found in DOCTYPE
     declarations after the PUBLIC keyword, e.g.

          <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

     However, you can also use this to force *Note XML/Checker:
     XML/Checker, to read DTDs from a different URL than was specified
     (e.g. from the local file system for performance reasons.)

   * on the Internet, if their system identifier starts with a protocol
     (like http://...)

   * on the local disk, if their system identifier starts with a slash
     (absolute path)

   * in the SGML_SEARCH_PATH, if their system identifier is a relative
     file name. It will use @SGML_SEARCH_PATH if it was set with
     *set_sgml_search_path()*, or the colon-separated
     $ENV{SGML_SEARCH_PATH}, or (if that isn't set) the list (".",
     "$ENV{'HOME'}/.sgml", "/usr/lib/sgml", "/usr/share/sgml"), which
     includes the current directory, so it should do the right thing in
     most cases.

Static methods related to External DTDs
---------------------------------------

set_sgml_search_path (dir1, dir2, ...)
     External DTDs with relative file paths are looked up using the
     @SGML_SEARCH_PATH, which can be set with this method. If
     @SGML_SEARCH_PATH is never set, it will use the colon-separated
     $ENV{SGML_SEARCH_PATH} instead. If neither are set it uses the list:
     ".", "$ENV{'HOME'}/.sgml", "/usr/lib/sgml", "/usr/share/sgml".

     set_sgml_search_path is a static method.

map_uri (pubid => uri, ...)
     To define the location of PUBLIC ids, as found in DOCTYPE declarations
     after the PUBLIC keyword, e.g.

          <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

     call this method, e.g.

          XML::Checker::Parser::map_uri (
          	"-//W3C//DTD HTML 4.0//EN" => "file:/user/html.dtd");

     See `External DTDs|"External DTDs"' in this node for more info.

     XML::Checker::Parser::map_uri is a static method.

Switching user handlers at parse time
=====================================

   You should be able to use setHandlers() just as in *Note XML/Parser:
XML/Parser,.  (Using setHandlers has not been tested yet.)

Error handling
==============

   XML::Checker::Parser routes the fail handler through
XML::Checker::Parser::fail_add_context() before calling your fail handler
(i.e. the global fail handler: $XML::Checker::FAIL.  See `ERROR_HANDLING',
*Note XML/Checker: XML/Checker,.)  It adds the (line, column, byte)
information from `ERROR_HANDLING', *Note XML/Parser: XML/Parser, to the
error context (unless it was the end of the XML document.)

Supported XML::Parser handlers
==============================

   Only the following *Note XML/Parser: XML/Parser, handlers are currently
routed through *Note XML/Checker: XML/Checker,: Init, Final, Char, Start,
End, Element, Attlist, Doctype, Unparsed, Notation.

CAVEATS
=======

   When using XML::Checker::Parser to parse external DTDs (i.e. with
SkipExternalDTD => 0), expect trouble when your external DTD contains
parameter entities inside declarations or conditional sections. The
external DTD should probably have the same encoding as the orignal XML
document.

AUTHOR
======

   Send bug reports, hints, tips, suggestions to Enno Derksen at
<`enno@att.com'>.

SEE ALSO
========

   *Note XML/Checker: XML/Checker, (`SEE_ALSO', *Note XML/Checker:
XML/Checker,), `SEE_ALSO', *Note XML/Parser: XML/Parser,


File: pm.info,  Node: XML/Config,  Next: XML/DOM,  Prev: XML/Checker/Parser,  Up: Module List

   Version: 0.1

   $Id: Config.pm,v 1.2 2000/05/21 23:41:03 matt Exp $

SYNOPSIS
========

   use XML::Config;

   my $cfg = new XML::Config; my %CONF =
$cfg->load_conf("path/to/file.xml");

     -OR-

   my %CONF = $cfg->load_conf("path/to/file.xml",\%your_local_config_hash);

     -OR-

   my %CONF = $cfg->load_conf("path/to/file.xml",\%your_local_config_hash,
\@do_not_overide_these);

DESCRIPTION
===========

   XML::Config is a simple shallow XML to hash converter.  Given a
configuration file in the form:

   <goxml_config process="spider"> 	<foo>Bar</foo> 	<bar>Foo</bar>
</goxml_config>

   ... XML::Config->load_conf returns:

   { 	foo => 'bar', 	bar => 'foo' }

   XML::Config will also try to load "path/to/file.xml.bak" in the case of
a non-file not found parse error.  if it does this, it will set the
err_str to "WARN: Loaded backup configuration\n";

   The second way of calling load_conf() with the hash reference allows
you to set defaults to your config hash, and have the XML overide some of
them.

   The third way makes it possible to disallow overwrites of certain
variables.  This is a good security measure.  =head1 METHODS

   load_conf($conf_file_path) err_str()

AUTHOR
======

   XML Global Technologies, Inc (Matthew MacKenzie)

COPYRIGHT
=========

   (c)2000 XML Global Technologies, Inc.



File: pm.info,  Node: XML/DOM,  Next: XML/DOM-ecmascript,  Prev: XML/Config,  Up: Module List

A perl module for building DOM Level 1 compliant document structures
********************************************************************

NAME
====

   XML::DOM - A perl module for building DOM Level 1 compliant document
structures

SYNOPSIS
========

     use XML::DOM;

     my $parser = new XML::DOM::Parser;
     my $doc = $parser->parsefile ("file.xml");

     # print all HREF attributes of all CODEBASE elements
     my $nodes = $doc->getElementsByTagName ("CODEBASE");
     my $n = $nodes->getLength;

     for (my $i = 0; $i < $n; $i++)
     {
         my $node = $nodes->item ($i);
         my $href = $node->getAttributeNode ("HREF");
         print $href->getValue . "\n";
     }

     # Print doc file
     $doc->printToFile ("out.xml");

     # Print to string
     print $doc->toString;

     # Avoid memory leaks - cleanup circular references for garbage collection
     $doc->dispose;

DESCRIPTION
===========

   This module extends the XML::Parser module by Clark Cooper.  The
XML::Parser module is built on top of XML::Parser::Expat, which is a lower
level interface to James Clark's expat library.

   XML::DOM::Parser is derived from XML::Parser. It parses XML strings or
files and builds a data structure that conforms to the API of the Document
Object Model as described at http://www.w3.org/TR/REC-DOM-Level-1.  See
the XML::Parser manpage for other available features of the
XML::DOM::Parser class.  Note that the 'Style' property should not be used
(it is set internally.)

   The XML::Parser *NoExpand* option is more or less supported, in that it
will generate EntityReference objects whenever an entity reference is
encountered in character data. I'm not sure how useful this is. Any
comments are welcome.

   As described in the synopsis, when you create an XML::DOM::Parser
object, the parse and parsefile methods create an *XML::DOM::Document*
object from the specified input. This Document object can then be
examined, modified and written back out to a file or converted to a string.

   When using XML::DOM with XML::Parser version 2.19 and up, setting the
XML::DOM::Parser option *KeepCDATA* to 1 will store CDATASections in
CDATASection nodes, instead of converting them to Text nodes.  Subsequent
CDATASection nodes will be merged into one. Let me know if this is a
problem.

   When using XML::Parser 2.27 and above, you can suppress expansion of
parameter entity references (e.g. %pent;) in the DTD, by setting
ParseParamEnt to 1 and *ExpandParamEnt* to 0. See `Hidden Nodes|' in this
node for details.

   A Document has a tree structure consisting of *Node* objects. A Node
may contain other nodes, depending on its type.  A Document may have
Element, Text, Comment, and CDATASection nodes.  Element nodes may have
Attr, Element, Text, Comment, and CDATASection nodes.  The other nodes may
not have any child nodes.

   This module adds several node types that are not part of the DOM spec
(yet.)  These are: ElementDecl (for <!ELEMENT ...> declarations),
AttlistDecl (for <!ATTLIST ...> declarations), XMLDecl (for <?xml ...?>
declarations) and AttDef (for attribute definitions in an AttlistDecl.)

XML::DOM Classes
================

   The XML::DOM module stores XML documents in a tree structure with a
root node of type XML::DOM::Document. Different nodes in tree represent
different parts of the XML file. The DOM Level 1 Specification defines the
following node types:

   * *Note XML/DOM/Node: XML/DOM/Node, - Super class of all node types

   * *Note XML/DOM/Document: XML/DOM/Document, - The root of the XML
     document

   * *Note XML/DOM/DocumentType: XML/DOM/DocumentType, - Describes the
     document structure: <!DOCTYPE root [ ... ]>

   * *Note XML/DOM/Element: XML/DOM/Element, - An XML element: <elem
     attr="val"> ... </elem>

   * *Note XML/DOM/Attr: XML/DOM/Attr, - An XML element attribute:
     name="value"

   * *Note XML/DOM/CharacterData: XML/DOM/CharacterData, - Super class of
     Text, Comment and CDATASection

   * *Note XML/DOM/Text: XML/DOM/Text, - Text in an XML element

   * *Note XML/DOM/CDATASection: XML/DOM/CDATASection, - Escaped block of
     text: <![CDATA[ text ]]>

   * *Note XML/DOM/Comment: XML/DOM/Comment, - An XML comment: <!- comment
     ->

   * *Note XML/DOM/EntityReference: XML/DOM/EntityReference, - Refers to
     an ENTITY: &ent; or %ent;

   * *Note XML/DOM/Entity: XML/DOM/Entity, - An ENTITY definition:
     <!ENTITY ...>

   * *Note XML/DOM/ProcessingInstruction: XML/DOM/ProcessingInstruction, -
     <?PI target>

   * *Note XML/DOM/DocumentFragment: XML/DOM/DocumentFragment, -
     Lightweight node for cut & paste

   * *Note XML/DOM/Notation: XML/DOM/Notation, - An NOTATION definition:
     <!NOTATION ...>

   In addition, the XML::DOM module contains the following nodes that are
not part of the DOM Level 1 Specification:

   * *Note XML/DOM/ElementDecl: XML/DOM/ElementDecl, - Defines an element:
     <!ELEMENT ...>

   * *Note XML/DOM/AttlistDecl: XML/DOM/AttlistDecl, - Defines one or more
     attributes in an <!ATTLIST ...>

   * *Note XML/DOM/AttDef: XML/DOM/AttDef, - Defines one attribute in an
     <!ATTLIST ...>

   * *Note XML/DOM/XMLDecl: XML/DOM/XMLDecl, - An XML declaration: <?xml
     version="1.0" ...>

   Other classes that are part of the DOM Level 1 Spec:

   * `XML::DOM::Implementation' in this node - Provides information about
     this implementation. Currently it doesn't do much.

   * *Note XML/DOM/NodeList: XML/DOM/NodeList, - Used internally to store
     a node's child nodes. Also returned by getElementsByTagName.

   * *Note XML/DOM/NamedNodeMap: XML/DOM/NamedNodeMap, - Used internally
     to store an element's attributes.

   Other classes that are not part of the DOM Level 1 Spec:

   * *Note XML/DOM/Parser: XML/DOM/Parser, - An non-validating XML parser
     that creates XML::DOM::Documents

   * *Note XML/DOM/ValParser: XML/DOM/ValParser, - A validating XML parser
     that creates XML::DOM::Documents. It uses *Note XML/Checker:
     XML/Checker, to check against the DocumentType (DTD)

   * *Note XML/Handler/BuildDOM: XML/Handler/BuildDOM, - A PerlSAX handler
     that creates XML::DOM::Documents.

XML::DOM package
================

Constant definitions
     The following predefined constants indicate which type of node it is.

     UNKNOWN_NODE (0)                The node type is unknown (not part of DOM)

     ELEMENT_NODE (1)                The node is an Element.
     ATTRIBUTE_NODE (2)              The node is an Attr.
     TEXT_NODE (3)                   The node is a Text node.
     CDATA_SECTION_NODE (4)          The node is a CDATASection.
     ENTITY_REFERENCE_NODE (5)       The node is an EntityReference.
     ENTITY_NODE (6)                 The node is an Entity.
     PROCESSING_INSTRUCTION_NODE (7) The node is a ProcessingInstruction.
     COMMENT_NODE (8)                The node is a Comment.
     DOCUMENT_NODE (9)               The node is a Document.
     DOCUMENT_TYPE_NODE (10)         The node is a DocumentType.
     DOCUMENT_FRAGMENT_NODE (11)     The node is a DocumentFragment.
     NOTATION_NODE (12)              The node is a Notation.

     ELEMENT_DECL_NODE (13)		 The node is an ElementDecl (not part of DOM)
     ATT_DEF_NODE (14)		 The node is an AttDef (not part of DOM)
     XML_DECL_NODE (15)		 The node is an XMLDecl (not part of DOM)
     ATTLIST_DECL_NODE (16)		 The node is an AttlistDecl (not part of DOM)

     Usage:

     if ($node->getNodeType == ELEMENT_NODE)
     {
         print "It's an Element";
     }

   *Not In DOM Spec*: The DOM Spec does not mention UNKNOWN_NODE and,
quite frankly, you should never encounter it. The last 4 node types were
added to support the 4 added node classes.

Global Variables
----------------

$VERSION
     The variable $XML::DOM::VERSION contains the version number of this
     implementation, e.g. "1.07".

METHODS
-------

   These methods are not part of the DOM Level 1 Specification.

getIgnoreReadOnly and ignoreReadOnly (readOnly)
     The DOM Level 1 Spec does not allow you to edit certain sections of
     the document, e.g. the DocumentType, so by default this
     implementation throws DOMExceptions (i.e.
     NO_MODIFICATION_ALLOWED_ERR) when you try to edit a readonly node.
     These readonly checks can be disabled by (temporarily) setting the
     global IgnoreReadOnly flag.

     The ignoreReadOnly method sets the global IgnoreReadOnly flag and
     returns its previous value. The getIgnoreReadOnly method simply
     returns its current value.

          my $oldIgnore = XML::DOM::ignoreReadOnly (1);
          eval {
          ... do whatever you want, catching any other exceptions ...
          };
          XML::DOM::ignoreReadOnly ($oldIgnore);     # restore previous value

     Another way to do it, using a local variable:

          { # start new scope
             local $XML::DOM::IgnoreReadOnly = 1;
             ... do whatever you want, don't worry about exceptions ...
          } # end of scope ($IgnoreReadOnly is set back to its previous value)

isValidName (name)
     Whether the specified name is a valid "Name" as specified in the XML
     spec.  Characters with Unicode values > 127 are now also supported.

getAllowReservedNames and allowReservedNames (boolean)
     The first method returns whether reserved names are allowed.  The
     second takes a boolean argument and sets whether reserved names are
     allowed.  The initial value is 1 (i.e. allow reserved names.)

     The XML spec states that "Names" starting with (X|x)(M|m)(L|l) are
     reserved for future use. (Amusingly enough, the XML version of the
     XML spec (REC-xml-19980210.xml) breaks that very rule by defining an
     ENTITY with the name 'xmlpio'.)  A "Name" in this context means the
     Name token as found in the BNF rules in the XML spec.

     XML::DOM only checks for errors when you modify the DOM tree, not
     when the DOM tree is built by the XML::DOM::Parser.

setTagCompression (funcref)
     There are 3 possible styles for printing empty Element tags:

    Style 0
               <empty/> or <empty attr="val"/>

          XML::DOM uses this style by default for all Elements.

    Style 1
               <empty></empty> or <empty attr="val"></empty>

    Style 2
               <empty /> or <empty attr="val" />

          This style is sometimes desired when using XHTML.  (Note the
          extra space before the slash "/") See `http:' in this node
          Appendix C for more details.

     By default XML::DOM compresses all empty Element tags (style 0.)  You
     can control which style is used for a particular Element by calling
     XML::DOM::setTagCompression with a reference to a function that takes
     2 arguments. The first is the tag name of the Element, the second is
     the XML::DOM::Element that is being printed.  The function should
     return 0, 1 or 2 to indicate which style should be used to print the
     empty tag. E.g.

          XML::DOM::setTagCompression (\&my_tag_compression);

          sub my_tag_compression
          {
             my ($tag, $elem) = @_;

          # Print empty br, hr and img tags like this: <br />
          return 2 if $tag =~ /^(br|hr|img)$/;

          # Print other empty tags like this: <empty></empty>
          return 1;
           }

IMPLEMENTATION DETAILS
======================

   * Perl Mappings

     The value undef was used when the DOM Spec said null.

     The DOM Spec says: Applications must encode DOMString using UTF-16
     (defined in Appendix C.3 of [UNICODE] and Amendment 1 of [ISO-10646]).
     In this implementation we use plain old Perl strings encoded in UTF-8
     instead of UTF-16.

   * Text and CDATASection nodes

     The Expat parser expands EntityReferences and CDataSection sections to
     raw strings and does not indicate where it was found.  This
     implementation does therefore convert both to Text nodes at parse
     time.  CDATASection and EntityReference nodes that are added to an
     existing Document (by the user) will be preserved.

     Also, subsequent Text nodes are always merged at parse time. Text
     nodes that are added later can be merged with the normalize method.
     Consider using the addText method when adding Text nodes.

   * Printing and toString

     When printing (and converting an XML Document to a string) the
     strings have to encoded differently depending on where they occur.
     E.g. in a CDATASection all substrings are allowed except for "]]>".
     In regular text, certain characters are not allowed, e.g. ">" has to
     be converted to "&gt;".  These routines should be verified by someone
     who knows the details.

   * Quotes

     Certain sections in XML are quoted, like attribute values in an
     Element.  XML::Parser strips these quotes and the print methods in
     this implementation always uses double quotes, so when parsing and
     printing a document, single quotes may be converted to double quotes.
     The default value of an attribute definition (AttDef) in an
     AttlistDecl, however, will maintain its quotes.

   * AttlistDecl

     Attribute declarations for a certain Element are always merged into a
     single AttlistDecl object.

   * Comments

     Comments in the DOCTYPE section are not kept in the right place. They
     will become child nodes of the Document.

   * Hidden Nodes

     Previous versions of XML::DOM would expand parameter entity references
     (like *%pent;*), so when printing the DTD, it would print the contents
     of the external entity, instead of the parameter entity reference.
     With this release (1.27), you can prevent this by setting the
     XML::DOM::Parser options ParseParamEnt => 1 and ExpandParamEnt => 0.

     When it is parsing the contents of the external entities, it *DOES*
     still add the nodes to the DocumentType, but it marks these nodes by
     setting the 'Hidden' property. In addition, it adds an
     EntityReference node to the DocumentType node.

     When printing the DocumentType node (or when using to_expat() or
     to_sax()), the 'Hidden' nodes are suppressed, so you will see the
     parameter entity reference instead of the contents of the external
     entities. See test case t/dom_extent.t for an example.

     The reason for adding the 'Hidden' nodes to the DocumentType node, is
     that the nodes may contain <!ENTITY> definitions that are referenced
     further in the document. (Simply not adding the nodes to the
     DocumentType could cause such entity references to be expanded
     incorrectly.)

     Note that you need XML::Parser 2.27 or higher for this to work
     correctly.

SEE ALSO
========

   The Japanese version of this document by Takanori Kawai (Hippo2000) at
`http:' in this node

   The DOM Level 1 specification at `http:' in this node

   The XML spec (Extensible Markup Language 1.0) at `http:' in this node

   The *Note XML/Parser: XML/Parser, and *Note XML/Parser/Expat:
XML/Parser/Expat, manual pages.

CAVEATS
=======

   The method getElementsByTagName() does not return a "live" NodeList.
Whether this is an actual caveat is debatable, but a few people on the
www-dom mailing list seemed to think so. I haven't decided yet. It's a pain
to implement, it slows things down and the benefits seem marginal.  Let me
know what you think.

   (To subscribe to the www-dom mailing list send an email with the subject
"subscribe" to www-dom-request@w3.org. I only look here occasionally, so
don't send bug reports or suggestions about XML::DOM to this list, send
them to enno@att.com instead.)

AUTHOR
======

   Send bug reports, hints, tips, suggestions to Enno Derksen at
<`enno@att.com'>.

   Thanks to Clark Cooper for his help with the initial version.


File: pm.info,  Node: XML/DOM-ecmascript,  Next: XML/DOM/AttDef,  Prev: XML/DOM,  Up: Module List

XML::Grove and DOM Level One
============================

   XML::Grove is similar in concept to the ECMA Script Language Binding to
DOM Level 1 Core (Appendix E of the DOM Recommendation).

   <http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html>

   The ECMA Script Language Binding presents DOM properties as ECMA Script
object properties.  The same is true for XML::Grove, XML::Grove presents
DOM properties as Perl blessed hashes.

   The biggest difference between the ECMA Script Language Binding and
XML::Grove is that XML::Grove uses a Perl hash for nodes, Perl arrays for
NodeLists, Perl hashes for NamedNodeLists so those object classes don't
exist in XML::Grove.  Because those classes don't exist, you use ordinary
Perl syntax for manipulating the DOM properties (lists and named node
lists) instead of methods like ``nextSibling()'' or ``replaceChild()''.
Element attributes in XML::Grove are stored in Perl hashes; attribute
types are available through the document object.

   Another difference is that XML::Grove attempts to marry the PerlSAX and
DOM naming so that less (no?) name-changing occurs between using PerlSAX
interfaces and filters and DOM modules.  Where conflicts occur, the
PerlSAX naming is used.

   XML::Grove uses a blessed hash for nodes, so the node type is available
using Perl's ``ref()'' instead of using a ``nodeType()'' method and all
class names are prefixed with ``XML::Grove::''.

   The following object descriptions are the most basic and common
provided by many PerlSAX parsers.  PerlSAX parsers often provide
additional properties or objects, refer to your PerlSAX parser
documentation for details.

Document Object Model Level 1 Core
==================================

Object XML::Grove::Document
---------------------------

Contents
     The children of this object.  This property is an array.

Entities
     The entities declared in this document.  This property is a hash of
     XML::Grove::Entity objects keyed by entity name.

Notations
     The notations declared in this document.  This property is a hash of
     XML::Grove::Notation objects keyed by notation name.

Object XML::Grove::Element
--------------------------

Name
     The tag type name for this element.  This property is a string.

Attributes
     The attributes for this element.  This property is a hash and it's
     hash values are strings (or arrays with some grove builders).

Contents
     The children of this object.  This property is an array of XML::Grove
     objects.

Object XML::Grove::Characters
-----------------------------

Data
     The text of the character data.  This property is a string.

Object XML::Grove::Comment
--------------------------

Data
     The text of the character data.  This property is a string.

Object XML::Grove::CData
------------------------

   The `CData' object is called a `CDATASection' in DOM.

Data
     The text of the character data.  This property is a string.

Object XML::Grove::Notation
---------------------------

Name
     The name of this notation.  This property is a string.

SystemId
     The system identifier of this notation.  This property is a string.

PublicId
     The public identifier of this notation.  This property is a string.

Object XML::Grove::Entity
-------------------------

Name
     The name of this entity.  This property is a string.

SystemId
     The system identifier of this notation.  This property is a string.

PublicId
     The public identifier of this notation.  This property is a string.

Notation
     The notation declared for this entity.  This property is either the
     name of the notation as a string or an `XML::Grove::Notation' object.

Object XML::Grove::PI
---------------------

   The PI object is called a `ProcessingInstruction' in DOM.

Target
     The target of the processing instruction.  This property is a string.

Data
     The text of the processing instruction.  This property is a string.


File: pm.info,  Node: XML/DOM/AttDef,  Next: XML/DOM/AttlistDecl,  Prev: XML/DOM-ecmascript,  Up: Module List

A single XML attribute definition in an ATTLIST in XML::DOM
***********************************************************

NAME
====

   XML::DOM::AttDef - A single XML attribute definition in an ATTLIST in
XML::DOM

DESCRIPTION
===========

   XML::DOM::AttDef extends *Note XML/DOM/Node: XML/DOM/Node,, but is not
part of the DOM Level 1 specification.

   Each object of this class represents one attribute definition in an
AttlistDecl.

METHODS
-------

getName
     Returns the attribute name.

getDefault
     Returns the default value, or undef.

isFixed
     Whether the attribute value is fixed (see #FIXED keyword.)

isRequired
     Whether the attribute value is required (see #REQUIRED keyword.)

isImplied
     Whether the attribute value is implied (see #IMPLIED keyword.)


File: pm.info,  Node: XML/DOM/AttlistDecl,  Next: XML/DOM/Attr,  Prev: XML/DOM/AttDef,  Up: Module List

An XML ATTLIST declaration in XML::DOM
**************************************

NAME
====

   XML::DOM::AttlistDecl - An XML ATTLIST declaration in XML::DOM

DESCRIPTION
===========

   XML::DOM::AttlistDecl extends *Note XML/DOM/Node: XML/DOM/Node, but is
not part of the DOM Level 1 specification.

   This node represents an ATTLIST declaration, e.g.

     <!ATTLIST person
       sex      (male|female)  #REQUIRED
       hair     CDATA          "bold"
       eyes     (none|one|two) "two"
       species  (human)        #FIXED "human">

   Each attribute definition is stored a separate AttDef node. The AttDef
nodes can be retrieved with getAttDef and added with addAttDef.  (The
AttDef nodes are stored in a NamedNodeMap internally.)

METHODS
-------

getName
     Returns the Element tagName.

getAttDef (attrName)
     Returns the AttDef node for the attribute with the specified name.

addAttDef (attrName, type, default, [ fixed ])
     Adds a AttDef node for the attribute with the specified name.

     Parameters:  *attrName* the attribute name.   type     the attribute
     type (e.g. "CDATA" or "(male|female)".)   default  the default value
     enclosed in quotes (!), the string #IMPLIED or              the
     string #REQUIRED.   fixed    whether the attribute is '#FIXED'
     (default is 0.)


File: pm.info,  Node: XML/DOM/Attr,  Next: XML/DOM/CDATASection,  Prev: XML/DOM/AttlistDecl,  Up: Module List

An XML attribute in XML::DOM
****************************

NAME
====

   XML::DOM::Attr - An XML attribute in XML::DOM

DESCRIPTION
===========

   XML::DOM::Attr extends *Note XML/DOM/Node: XML/DOM/Node,.

   The Attr nodes built by the XML::DOM::Parser always have one child node
which is a Text node containing the expanded string value (i.e.
EntityReferences are always expanded.) EntityReferences may be added when
modifying or creating a new Document.

   The Attr interface represents an attribute in an Element object.
Typically the allowable values for the attribute are defined in a document
type definition.

   Attr objects inherit the Node interface, but since they are not
actually child nodes of the element they describe, the DOM does not
consider them part of the document tree. Thus, the Node attributes
parentNode, previousSibling, and nextSibling have a undef value for Attr
objects. The DOM takes the view that attributes are properties of elements
rather than having a separate identity from the elements they are
associated with; this should make it more efficient to implement such
features as default attributes associated with all elements of a given
type. Furthermore, Attr nodes may not be immediate children of a
DocumentFragment. However, they can be associated with Element nodes
contained within a DocumentFragment. In short, users and implementors of
the DOM need to be aware that Attr nodes have some things in common with
other objects inheriting the Node interface, but they also are quite
distinct.

   The attribute's effective value is determined as follows: if this
attribute has been explicitly assigned any value, that value is the
attribute's effective value; otherwise, if there is a declaration for this
attribute, and that declaration includes a default value, then that
default value is the attribute's effective value; otherwise, the attribute
does not exist on this element in the structure model until it has been
explicitly added. Note that the nodeValue attribute on the Attr instance
can also be used to retrieve the string version of the attribute's
value(s).

   In XML, where the value of an attribute can contain entity references,
the child nodes of the Attr node provide a representation in which entity
references are not expanded. These child nodes may be either Text or
EntityReference nodes. Because the attribute type may be unknown, there
are no tokenized attribute values.

METHODS
-------

getValue
     On retrieval, the value of the attribute is returned as a string.
     Character and general entity references are replaced with their
     values.

setValue (str)
     DOM Spec: On setting, this creates a Text node with the unparsed
     contents of the string.

getName
     Returns the name of this attribute.


File: pm.info,  Node: XML/DOM/CDATASection,  Next: XML/DOM/CharacterData,  Prev: XML/DOM/Attr,  Up: Module List

Escaping XML text blocks in XML::DOM
************************************

NAME
====

   XML::DOM::CDATASection - Escaping XML text blocks in XML::DOM

DESCRIPTION
===========

   XML::DOM::CDATASection extends *Note XML/DOM/CharacterData:
XML/DOM/CharacterData, which extends *Note XML/DOM/Node: XML/DOM/Node,.

   CDATA sections are used to escape blocks of text containing characters
that would otherwise be regarded as markup. The only delimiter that is
recognized in a CDATA section is the "]]>" string that ends the CDATA
section. CDATA sections can not be nested. The primary purpose is for
including material such as XML fragments, without needing to escape all
the delimiters.

   The DOMString attribute of the Text node holds the text that is
contained by the CDATA section. Note that this may contain characters that
need to be escaped outside of CDATA sections and that, depending on the
character encoding ("charset") chosen for serialization, it may be
impossible to write out some characters as part of a CDATA section.

   The CDATASection interface inherits the CharacterData interface through
the Text interface. Adjacent CDATASections nodes are not merged by use of
the Element.normalize() method.

   NOTE: XML::DOM::Parser and XML::DOM::ValParser convert all CDATASections
to regular text by default.  To preserve CDATASections, set the parser
option KeepCDATA to 1.


File: pm.info,  Node: XML/DOM/CharacterData,  Next: XML/DOM/Comment,  Prev: XML/DOM/CDATASection,  Up: Module List

Common interface for Text, CDATASections and Comments
*****************************************************

NAME
====

   XML::DOM::CharacterData - Common interface for Text, CDATASections and
Comments

DESCRIPTION
===========

   XML::DOM::CharacterData extends *Note XML/DOM/Node: XML/DOM/Node,

   The CharacterData interface extends Node with a set of attributes and
methods for accessing character data in the DOM. For clarity this set is
defined here rather than on each object that uses these attributes and
methods. No DOM objects correspond directly to CharacterData, though Text,
Comment and CDATASection do inherit the interface from it.  All offsets in
this interface start from 0.

METHODS
-------

getData and setData (data)
     The character data of the node that implements this interface. The
     DOM implementation may not put arbitrary limits on the amount of data
     that may be stored in a CharacterData node. However, implementation
     limits may mean that the entirety of a node's data may not fit into a
     single DOMString. In such cases, the user may call substringData to
     retrieve the data in appropriately sized pieces.

getLength
     The number of characters that are available through data and the
     substringData method below. This may have the value zero, i.e.,
     CharacterData nodes may be empty.

substringData (offset, count)
     Extracts a range of data from the node.

     Parameters:  offset  Start offset of substring to extract.   count
     The number of characters to extract.

     Return Value: The specified substring. If the sum of offset and count
     exceeds the length, then all characters to the end of the data are
     returned.

appendData (str)
     Appends the string to the end of the character data of the node. Upon
     success, data provides access to the concatenation of data and the
     DOMString specified.

insertData (offset, arg)
     Inserts a string at the specified character offset.

     Parameters:  offset  The character offset at which to insert.   *arg*
        The DOMString to insert.

deleteData (offset, count)
     Removes a range of characters from the node.  Upon success, data and
     length reflect the change.  If the sum of offset and count exceeds
     length then all characters from offset to the end of the data are
     deleted.

     Parameters:  offset  The offset from which to remove characters.
     count   The number of characters to delete.

replaceData (offset, count, arg)
     Replaces the characters starting at the specified character offset
     with the specified string.

     Parameters:  offset  The offset from which to start replacing.
     count   The number of characters to replace.   *arg*     The
     DOMString with which the range must be replaced.

     If the sum of offset and count exceeds length, then all characters to
     the end of the data are replaced (i.e., the effect is the same as a
     remove method call with the same range, followed by an append method
     invocation).


File: pm.info,  Node: XML/DOM/Comment,  Next: XML/DOM/DOMImplementation,  Prev: XML/DOM/CharacterData,  Up: Module List

An XML comment in XML::DOM
**************************

NAME
====

   XML::DOM::Comment - An XML comment in XML::DOM

DESCRIPTION
===========

   XML::DOM::Comment extends *Note XML/DOM/CharacterData:
XML/DOM/CharacterData, which extends *Note XML/DOM/Node: XML/DOM/Node,.

   This node represents the content of a comment, i.e., all the characters
between the starting '<!-' and ending '->'. Note that this is the
definition of a comment in XML, and, in practice, HTML, although some HTML
tools may implement the full SGML comment structure.


File: pm.info,  Node: XML/DOM/DOMImplementation,  Next: XML/DOM/Document,  Prev: XML/DOM/Comment,  Up: Module List

Information about XML::DOM implementation
*****************************************

NAME
====

   XML::DOM::DOMImplementation - Information about XML::DOM implementation

DESCRIPTION
===========

   The DOMImplementation interface provides a number of methods for
performing operations that are independent of any particular instance of
the document object model.

   The DOM Level 1 does not specify a way of creating a document instance,
and hence document creation is an operation specific to an implementation.
Future Levels of the DOM specification are expected to provide methods for
creating documents directly.

METHODS
-------

hasFeature (feature, version)
     Returns 1 if and only if feature equals "XML" and version equals
     "1.0".


File: pm.info,  Node: XML/DOM/Document,  Next: XML/DOM/DocumentFragment,  Prev: XML/DOM/DOMImplementation,  Up: Module List

An XML document node in XML::DOM
********************************

NAME
====

   XML::DOM::Document - An XML document node in XML::DOM

DESCRIPTION
===========

   XML::DOM::Document extends *Note XML/DOM/Node: XML/DOM/Node,.

   It is the main root of the XML document structure as returned by
XML::DOM::Parser::parse and XML::DOM::Parser::parsefile.

   Since elements, text nodes, comments, processing instructions, etc.
cannot exist outside the context of a Document, the Document interface
also contains the factory methods needed to create these objects. The Node
objects created have a getOwnerDocument method which associates them with
the Document within whose context they were created.

METHODS
-------

getDocumentElement
     This is a convenience method that allows direct access to the child
     node that is the root Element of the document.

getDoctype
     The Document Type Declaration (see DocumentType) associated with this
     document. For HTML documents as well as XML documents without a
     document type declaration this returns undef. The DOM Level 1 does
     not support editing the Document Type Declaration.

     *Not In DOM Spec*: This implementation allows editing the doctype.
     See *XML::DOM::ignoreReadOnly* for details.

getImplementation
     The DOMImplementation object that handles this document. A DOM
     application may use objects from multiple implementations.

createElement (tagName)
     Creates an element of the type specified. Note that the instance
     returned implements the Element interface, so attributes can be
     specified directly on the returned object.

     DOMExceptions:

        * INVALID_CHARACTER_ERR

          Raised if the tagName does not conform to the XML spec.

createTextNode (data)
     Creates a Text node given the specified string.

createComment (data)
     Creates a Comment node given the specified string.

createCDATASection (data)
     Creates a CDATASection node given the specified string.

createAttribute (name [, value [, specified ]])
     Creates an Attr of the given name. Note that the Attr instance can
     then be set on an Element using the setAttribute method.

     *Not In DOM Spec*: The DOM Spec does not allow passing the value or
     the specified property in this method. In this implementation they
     are optional.

     Parameters:  value     The attribute's value. See Attr::setValue for
     details.                If the value is not supplied, the specified
     property is set to 0.   *specified* Whether the attribute value was
     specified or whether the default               value was used. If not
     supplied, it's assumed to be 1.

     DOMExceptions:

        * INVALID_CHARACTER_ERR

          Raised if the name does not conform to the XML spec.

createProcessingInstruction (target, data)
     Creates a ProcessingInstruction node given the specified name and
     data strings.

     Parameters:  target  The target part of the processing instruction.
     data    The data for the node.

     DOMExceptions:

        * INVALID_CHARACTER_ERR

          Raised if the target does not conform to the XML spec.

createDocumentFragment
     Creates an empty DocumentFragment object.

createEntityReference (name)
     Creates an EntityReference object.

Additional methods not in the DOM Spec
--------------------------------------

getXMLDecl and setXMLDecl (xmlDecl)
     Returns the XMLDecl for this Document or undef if none was specified.
     Note that XMLDecl is not part of the list of child nodes.

setDoctype (doctype)
     Sets or replaces the DocumentType.  NOTE: Don't use appendChild or
     insertBefore to set the DocumentType.  Even though doctype will be
     part of the list of child nodes, it is handled specially.

getDefaultAttrValue (elem, attr)
     Returns the default attribute value as a string or undef, if none is
     available.

     Parameters:  elem    The element tagName.   attr    The attribute
     name.

getEntity (name)
     Returns the Entity with the specified name.

createXMLDecl (version, encoding, standalone)
     Creates an XMLDecl object. All parameters may be undefined.

createDocumentType (name, sysId, pubId)
     Creates a DocumentType object. SysId and pubId may be undefined.

createNotation (name, base, sysId, pubId)
     Creates a new Notation object. Consider using
     XML::DOM::DocumentType::addNotation!

createEntity (parameter, notationName, value, sysId, pubId, ndata)
     Creates an Entity object. Consider using
     XML::DOM::DocumentType::addEntity!

createElementDecl (name, model)
     Creates an ElementDecl object.

     DOMExceptions:

        * INVALID_CHARACTER_ERR

          Raised if the element name (tagName) does not conform to the XML
          spec.

createAttlistDecl (name)
     Creates an AttlistDecl object.

     DOMExceptions:

        * INVALID_CHARACTER_ERR

          Raised if the element name (tagName) does not conform to the XML
          spec.

expandEntity (entity [, parameter])
     Expands the specified entity or parameter entity (if parameter=1) and
     returns its value as a string, or undef if the entity does not exist.
     (The entity name should not contain the '%', '&' or ';' delimiters.)

check ( [$checker] )
     Uses the specified *Note XML/Checker: XML/Checker, to validate the
     document.  If no XML::Checker is supplied, a new XML::Checker is
     created.  See *Note XML/Checker: XML/Checker, for details.

check_sax ( [$checker] )
     Similar to check() except it uses the SAX interface to XML::Checker
     instead of the expat interface. This method may disappear or replace
     check() at some time.

createChecker ()
     Creates an XML::Checker based on the document's DTD.  The $checker
     can be reused to check any elements within the document.  Create a
     new *Note XML/Checker: XML/Checker, whenever the DOCTYPE section of
     the document is altered!


File: pm.info,  Node: XML/DOM/DocumentFragment,  Next: XML/DOM/DocumentType,  Prev: XML/DOM/Document,  Up: Module List

Facilitates cut & paste in XML::DOM documents
*********************************************

NAME
====

   XML::DOM::DocumentFragment - Facilitates cut & paste in XML::DOM
documents

DESCRIPTION
===========

   XML::DOM::DocumentFragment extends *Note XML/DOM/Node: XML/DOM/Node,

   DocumentFragment is a "lightweight" or "minimal" Document object. It is
very common to want to be able to extract a portion of a document's tree
or to create a new fragment of a document. Imagine implementing a user
command like cut or rearranging a document by moving fragments around. It
is desirable to have an object which can hold such fragments and it is
quite natural to use a Node for this purpose. While it is true that a
Document object could fulfil this role, a Document object can potentially
be a heavyweight object, depending on the underlying implementation. What
is really needed for this is a very lightweight object. DocumentFragment
is such an object.

   Furthermore, various operations - such as inserting nodes as children
of another Node - may take DocumentFragment objects as arguments; this
results in all the child nodes of the DocumentFragment being moved to the
child list of this node.

   The children of a DocumentFragment node are zero or more nodes
representing the tops of any sub-trees defining the structure of the
document. DocumentFragment nodes do not need to be well-formed XML
documents (although they do need to follow the rules imposed upon
well-formed XML parsed entities, which can have multiple top nodes).  For
example, a DocumentFragment might have only one child and that child node
could be a Text node. Such a structure model represents neither an HTML
document nor a well-formed XML document.

   When a DocumentFragment is inserted into a Document (or indeed any
other Node that may take children) the children of the DocumentFragment
and not the DocumentFragment itself are inserted into the Node. This makes
the DocumentFragment very useful when the user wishes to create nodes that
are siblings; the DocumentFragment acts as the parent of these nodes so
that the user can use the standard methods from the Node interface, such
as insertBefore() and appendChild().


File: pm.info,  Node: XML/DOM/DocumentType,  Next: XML/DOM/Element,  Prev: XML/DOM/DocumentFragment,  Up: Module List

An XML document type (DTD) in XML::DOM
**************************************

NAME
====

   XML::DOM::DocumentType - An XML document type (DTD) in XML::DOM

DESCRIPTION
===========

   XML::DOM::DocumentType extends *Note XML/DOM/Node: XML/DOM/Node,.

   Each Document has a doctype attribute whose value is either null or a
DocumentType object. The DocumentType interface in the DOM Level 1 Core
provides an interface to the list of entities that are defined for the
document, and little else because the effect of namespaces and the various
XML scheme efforts on DTD representation are not clearly understood as of
this writing.  The DOM Level 1 doesn't support editing DocumentType nodes.

   *Not In DOM Spec*: This implementation has added a lot of extra
functionality to the DOM Level 1 interface.  To allow editing of the
DocumentType nodes, see XML::DOM::ignoreReadOnly.

METHODS
-------

getName
     Returns the name of the DTD, i.e. the name immediately following the
     DOCTYPE keyword.

getEntities
     A NamedNodeMap containing the general entities, both external and
     internal, declared in the DTD. Duplicates are discarded.  For example
     in:

          <!DOCTYPE ex SYSTEM "ex.dtd" [
           <!ENTITY foo "foo">
           <!ENTITY bar "bar">
           <!ENTITY % baz "baz">
          ]>
          <ex/>

     the interface provides access to foo and bar but not baz.  Every node
     in this map also implements the Entity interface.

     The DOM Level 1 does not support editing entities, therefore entities
     cannot be altered in any way.

     *Not In DOM Spec*: See XML::DOM::ignoreReadOnly to edit the
     DocumentType etc.

getNotations
     A NamedNodeMap containing the notations declared in the DTD.
     Duplicates are discarded. Every node in this map also implements the
     Notation interface.

     The DOM Level 1 does not support editing notations, therefore
     notations cannot be altered in any way.

     *Not In DOM Spec*: See XML::DOM::ignoreReadOnly to edit the
     DocumentType etc.

Additional methods not in the DOM Spec
--------------------------------------

Creating and setting the DocumentType
     A new DocumentType can be created with:

          $doctype = $doc->createDocumentType ($name, $sysId, $pubId, $internal);

     To set (or replace) the DocumentType for a particular document, use:

          $doc->setDocType ($doctype);

getSysId and setSysId (sysId)
     Returns or sets the system id.

getPubId and setPubId (pudId)
     Returns or sets the public id.

setName (name)
     Sets the name of the DTD, i.e. the name immediately following the
     DOCTYPE keyword. Note that this should always be the same as the
     element tag name of the root element.

getAttlistDecl (elemName)
     Returns the AttlistDecl for the Element with the specified name, or
     undef.

getElementDecl (elemName)
     Returns the ElementDecl for the Element with the specified name, or
     undef.

getEntity (entityName)
     Returns the Entity with the specified name, or undef.

addAttlistDecl (elemName)
     Adds a new AttDecl node with the specified elemName if one doesn't
     exist yet.  Returns the AttlistDecl (new or existing) node.

addElementDecl (elemName, model)
     Adds a new ElementDecl node with the specified elemName and model if
     one doesn't exist yet.  Returns the AttlistDecl (new or existing)
     node. The model is ignored if one already existed.

addEntity (parameter, notationName, value, sysId, pubId, ndata)
     Adds a new Entity node. Don't use createEntity and appendChild,
     because it should be added to the internal NamedNodeMap containing
     the entities.

     Parameters:  parameter	 whether it is a parameter entity
     (%ent;) or not (&ent;).   *notationName* the entity name.   value
       the entity value.   *sysId*        the system id (if any.)
     *pubId*        the public id (if any.)   *ndata*        the NDATA
     declaration (if any, for general unparsed entities.)

     SysId, pubId and ndata may be undefined.

     DOMExceptions:

        * INVALID_CHARACTER_ERR

          Raised if the notationName does not conform to the XML spec.

addNotation (name, base, sysId, pubId)
     Adds a new Notation object.

     Parameters:  name   the notation name.   base   the base to be used
     for resolving a relative URI.   *sysId*  the system id.   *pubId*
     the public id.

     Base, sysId, and pubId may all be undefined.  (These parameters are
     passed by the XML::Parser Notation handler.)

     DOMExceptions:

        * INVALID_CHARACTER_ERR

          Raised if the notationName does not conform to the XML spec.

addAttDef (elemName, attrName, type, default, fixed)
     Adds a new attribute definition. It will add the AttDef node to the
     AttlistDecl if it exists. If an AttDef with the specified attrName
     already exists for the given elemName, this function only generates a
     warning.

     See XML::DOM::AttDef::new for the other parameters.

getDefaultAttrValue (elem, attr)
     Returns the default attribute value as a string or undef, if none is
     available.

     Parameters:  elem    The element tagName.   attr    The attribute
     name.

expandEntity (entity [, parameter])
     Expands the specified entity or parameter entity (if parameter=1) and
     returns its value as a string, or undef if the entity does not exist.
     (The entity name should not contain the '%', '&' or ';' delimiters.)


