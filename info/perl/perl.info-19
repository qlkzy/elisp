This is Info file perl.info, produced by Makeinfo version 1.68 from the
input file bigperl.texi.

   settitle perl


File: perl.info,  Node: perlnumber,  Next: perlsec,  Prev: perldiag,  Up: Top

semantics of numbers and numeric operations in Perl
***************************************************

NAME
====

   perlnumber - semantics of numbers and numeric operations in Perl

SYNOPSIS
========

     $n = 1234;			# decimal integer
     $n = 0b1110011;		# binary integer
     $n = 01234;			# octal integer
     $n = 0x1234;		# hexadecimal integer
     $n = 12.34e-56;		# exponential notation
     $n = "-12.34e56";		# number specified as a string
     $n = "1234";		# number specified as a string
     $n = v49.50.51.52;		# number specified as a string, which in
     				# turn is specified in terms of numbers :-)

DESCRIPTION
===========

   This document describes how Perl internally handles numeric values.

   Perl's operator overloading facility is completely ignored here.
Operator overloading allows user-defined behaviors for numbers, such as
operations over arbitrarily large integers, floating points numbers with
arbitrary precision, operations over "exotic" numbers such as modular
arithmetic or p-adic arithmetic, and so on.  See *Note Overload:
(pm.info)overload, for details.

Storing numbers
===============

   Perl can internally represent numbers in 3 different ways: as native
integers, as native floating point numbers, and as decimal strings.
Decimal strings may have an exponential notation part, as in `"12.34e-56"'.
*Native* here means "a format supported by the C compiler which was used
to build perl".

   The term "native" does not mean quite as much when we talk about native
integers, as it does when native floating point numbers are involved.  The
only implication of the term "native" on integers is that the limits for
the maximal and the minimal supported true integral quantities are close to
powers of 2.  However, "native" floats have a most fundamental
restriction: they may represent only those numbers which have a relatively
"short" representation when converted to a binary fraction.  For example,
0.9 cannot be respresented by a native float, since the binary fraction
for 0.9 is infinite:

     binary0.1110011001100...

   with the sequence `1100' repeating again and again.  In addition to this
limitation,  the exponent of the binary number is also restricted when it
is represented as a floating point number.  On typical hardware, floating
point values can store numbers with up to 53 binary digits, and with binary
exponents between -1024 and 1024.  In decimal representation this is close
to 16 decimal digits and decimal exponents in the range of -304..304.  The
upshot of all this is that Perl cannot store a number like
12345678901234567 as a floating point number on such architectures without
loss of information.

   Similarly, decimal strings can represent only those numbers which have a
finite decimal expansion.  Being strings, and thus of arbitrary length,
there is no practical limit for the exponent or number of decimal digits
for these numbers.  (But realize that what we are discussing the rules for
just the storage of these numbers.  The fact that you can store such
"large" numbers does not mean that that the operations over these numbers
will use all of the significant digits.  See `"Numeric operators and
numeric conversions"' in this node for details.)

   In fact numbers stored in the native integer format may be stored either
in the signed native form, or in the unsigned native form.  Thus the limits
for Perl numbers stored as native integers would typically be
-2**31..2**32-1, with appropriate modifications in the case of 64-bit
integers.  Again, this does not mean that Perl can do operations only over
integers in this range: it is possible to store many more integers in
floating point format.

   Summing up, Perl numeric values can store only those numbers which have
a finite decimal expansion or a "short" binary expansion.

Numeric operators and numeric conversions
=========================================

   As mentioned earlier, Perl can store a number in any one of three
formats, but most operators typically understand only one of those
formats.  When a numeric value is passed as an argument to such an
operator, it will be converted to the format understood by the operator.

   Six such conversions are possible:

     native integer        --> native floating point	(*)
     native integer        --> decimal string
     native floating_point --> native integer		(*)
     native floating_point --> decimal string		(*)
     decimal string        --> native integer
     decimal string        --> native floating point	(*)

   These conversions are governed by the following general rules:

   * If the source number can be represented in the target form, that
     representation is used.

   * If the source number is outside of the limits representable in the
     target form, a representation of the closest limit is used.  (*Loss
     of information*)

   * If the source number is between two numbers representable in the
     target form, a representation of one of these numbers is used.
     (*Loss of information*)

   * In `< native floating point --' native integer >> conversions the
     magnitude of the result is less than or equal to the magnitude of the
     source.  (*"Rounding to zero".*)

   * If the `< decimal string --' native integer >> conversion cannot be
     done without loss of information, the result is compatible with the
     conversion sequence `< decimal_string --' native_floating_point ->
     native_integer >>.  In particular, rounding is strongly biased to 0,
     though a number like `"0.99999999999999999999"' has a chance of being
     rounded to 1.

   *RESTRICTION*: The conversions marked with `(*)' above involve steps
performed by the C compiler.  In particular, bugs/features of the compiler
used may lead to breakage of some of the above rules.

Flavors of Perl numeric operations
==================================

   Perl operations which take a numeric argument treat that argument in one
of four different ways: they may force it to one of the integer/floating/
string formats, or they may behave differently depending on the format of
the operand.  Forcing a numeric value to a particular format does not
change the number stored in the value.

   All the operators which need an argument in the integer format treat the
argument as in modular arithmetic, e.g., `mod 2**32' on a 32-bit
architecture.  `sprintf "%u", -1' therefore provides the same result as
`sprintf "%u", ~0'.

Arithmetic operators except, `no integer'
     force the argument into the floating point format.

Arithmetic operators except, `use integer'
Bitwise operators, `no integer'
     force the argument into the integer format if it is not a string.

Bitwise operators, `use integer'
     force the argument into the integer format

Operators which expect an integer
     force the argument into the integer format.  This is applicable to
     the third and fourth arguments of sysread, for example.

Operators which expect a string
     force the argument into the string format.  For example, this is
     applicable to `printf "%s", $value'.

   Though forcing an argument into a particular form does not change the
stored number, Perl remembers the result of such conversions.  In
particular, though the first such conversion may be time-consuming,
repeated operations will not need to redo the conversion.

AUTHOR
======

   Ilya Zakharevich `ilya@math.ohio-state.edu'

   Editorial adjustments by Gurusamy Sarathy <gsar@ActiveState.com>

SEE ALSO
========

   *Note Overload: (pm.info)overload,


File: perl.info,  Node: perlobj,  Next: perltie,  Prev: perltootc,  Up: Top

Perl objects
************

NAME
====

   perlobj - Perl objects

DESCRIPTION
===========

   First you need to understand what references are in Perl.  See *Note
Perlref: perlref, for that.  Second, if you still find the following
reference work too complicated, a tutorial on object-oriented programming
in Perl can be found in *Note Perltoot: perltoot, and *Note Perltootc:
perltootc,.

   If you're still with us, then here are three very simple definitions
that you should find reassuring.

  1. An object is simply a reference that happens to know which class it
     belongs to.

  2. A class is simply a package that happens to provide methods to deal
     with object references.

  3. A method is simply a subroutine that expects an object reference (or
     a package name, for class methods) as the first argument.

        We'll cover these points now in more depth.

An Object is Simply a Reference
-------------------------------

   Unlike say C++, Perl doesn't provide any special syntax for
constructors.  A constructor is merely a subroutine that returns a
reference to something "blessed" into a class, generally the class that
the subroutine is defined in.  Here is a typical constructor:

     package Critter;
     sub new { bless {} }

   That word new isn't special.  You could have written a construct this
way, too:

     package Critter;
     sub spawn { bless {} }

   This might even be preferable, because the C++ programmers won't be
tricked into thinking that new works in Perl as it does in C++.  It
doesn't.  We recommend that you name your constructors whatever makes
sense in the context of the problem you're solving.  For example,
constructors in the Tk extension to Perl are named after the widgets they
create.

   One thing that's different about Perl constructors compared with those
in C++ is that in Perl, they have to allocate their own memory.  (The other
things is that they don't automatically call overridden base-class
constructors.)  The `{}' allocates an anonymous hash containing no
key/value pairs, and returns it  The bless() takes that reference and
tells the object it references that it's now a Critter, and returns the
reference.  This is for convenience, because the referenced object itself
knows that it has been blessed, and the reference to it could have been
returned directly, like this:

     sub new {
     	my $self = {};
     	bless $self;
     	return $self;
     }

   You often see such a thing in more complicated constructors that wish
to call methods in the class as part of the construction:

     sub new {
     	my $self = {};
     	bless $self;
     	$self->initialize();
     	return $self;
     }

   If you care about inheritance (and you should; see `"Modules: Creation,
Use, and Abuse"', *Note Perlmodlib: perlmodlib,), then you want to use the
two-arg form of bless so that your constructors may be inherited:

     sub new {
     	my $class = shift;
     	my $self = {};
     	bless $self, $class;
     	$self->initialize();
     	return $self;
     }

   Or if you expect people to call not just `< CLASS-'new() >> but also `<
$obj-'new() >>, then use something like this.  The initialize() method
used will be of whatever $class we blessed the object into:

     sub new {
     	my $this = shift;
     	my $class = ref($this) || $this;
     	my $self = {};
     	bless $self, $class;
     	$self->initialize();
     	return $self;
     }

   Within the class package, the methods will typically deal with the
reference as an ordinary reference.  Outside the class package, the
reference is generally treated as an opaque value that may be accessed
only through the class's methods.

   Although a constructor can in theory re-bless a referenced object
currently belonging to another class, this is almost certainly going to
get you into trouble.  The new class is responsible for all cleanup later.
The previous blessing is forgotten, as an object may belong to only one
class at a time.  (Although of course it's free to inherit methods from
many classes.)  If you find yourself having to do this, the parent class
is probably misbehaving, though.

   A clarification:  Perl objects are blessed.  References are not.
Objects know which package they belong to.  References do not.  The bless()
function uses the reference to find the object.  Consider the following
example:

     $a = {};
     $b = $a;
     bless $a, BLAH;
     print "\$b is a ", ref($b), "\n";

   This reports $b as being a BLAH, so obviously bless() operated on the
object and not on the reference.

A Class is Simply a Package
---------------------------

   Unlike say C++, Perl doesn't provide any special syntax for class
definitions.  You use a package as a class by putting method definitions
into the class.

   There is a special array within each package called @ISA, which says
where else to look for a method if you can't find it in the current
package.  This is how Perl implements inheritance.  Each element of the
@ISA array is just the name of another package that happens to be a class
package.  The classes are searched (depth first) for missing methods in
the order that they occur in @ISA.  The classes accessible through @ISA
are known as base classes of the current class.

   All classes implicitly inherit from class UNIVERSAL as their last base
class.  Several commonly used methods are automatically supplied in the
UNIVERSAL class; see `"Default UNIVERSAL methods"' in this node for more
details.

   If a missing method is found in a base class, it is cached in the
current class for efficiency.  Changing @ISA or defining new subroutines
invalidates the cache and causes Perl to do the lookup again.

   If neither the current class, its named base classes, nor the UNIVERSAL
class contains the requested method, these three places are searched all
over again, this time looking for a method named AUTOLOAD().  If an
AUTOLOAD is found, this method is called on behalf of the missing method,
setting the package global $AUTOLOAD to be the fully qualified name of the
method that was intended to be called.

   If none of that works, Perl finally gives up and complains.

   Perl classes do method inheritance only.  Data inheritance is left up
to the class itself.  By and large, this is not a problem in Perl, because
most classes model the attributes of their object using an anonymous hash,
which serves as its own little namespace to be carved up by the various
classes that might want to do something with the object.  The only problem
with this is that you can't sure that you aren't using a piece of the hash
that isn't already used.  A reasonable workaround is to prepend your
fieldname in the hash with the package name.

     sub bump {
     	my $self = shift;
     	$self->{ __PACKAGE__ . ".count"}++;
     }

A Method is Simply a Subroutine
-------------------------------

   Unlike say C++, Perl doesn't provide any special syntax for method
definition.  (It does provide a little syntax for method invocation
though.  More on that later.)  A method expects its first argument to be
the object (reference) or package (string) it is being invoked on.  There
are two ways of calling methods, which we'll call class methods and
instance methods.

   A class method expects a class name as the first argument.  It provides
functionality for the class as a whole, not for any individual object
belonging to the class.  Constructors are often class methods, but see
*Note Perltoot: perltoot, and *Note Perltootc: perltootc, for alternatives.
Many class methods simply ignore their first argument, because they
already know what package they're in and don't care what package they were
invoked via.  (These aren't necessarily the same, because class methods
follow the inheritance tree just like ordinary instance methods.)  Another
typical use for class methods is to look up an object by name:

     sub find {
     	my ($class, $name) = @_;
     	$objtable{$name};
     }

   An instance method expects an object reference as its first argument.
Typically it shifts the first argument into a "self" or "this" variable,
and then uses that as an ordinary reference.

     sub display {
     	my $self = shift;
     	my @keys = @_ ? @_ : sort keys %$self;
     	foreach $key (@keys) {
     	    print "\t$key => $self->{$key}\n";
     	}
     }

Method Invocation
-----------------

   There are two ways to invoke a method, one of which you're already
familiar with, and the other of which will look familiar.  Perl 4 already
had an "indirect object" syntax that you use when you say

     print STDERR "help!!!\n";

   This same syntax can be used to call either class or instance methods.
We'll use the two methods defined above, the class method to lookup an
object reference and the instance method to print out its attributes.

     $fred = find Critter "Fred";
     display $fred 'Height', 'Weight';

   These could be combined into one statement by using a BLOCK in the
indirect object slot:

     display {find Critter "Fred"} 'Height', 'Weight';

   For C++ fans, there's also a syntax using -> notation that does exactly
the same thing.  The parentheses are required if there are any arguments.

     $fred = Critter->find("Fred");
     $fred->display('Height', 'Weight');

   or in one statement,

     Critter->find("Fred")->display('Height', 'Weight');

   There are times when one syntax is more readable, and times when the
other syntax is more readable.  The indirect object syntax is less
cluttered, but it has the same ambiguity as ordinary list operators.
Indirect object method calls are usually parsed using the same rule as list
operators: "If it looks like a function, it is a function".  (Presuming
for the moment that you think two words in a row can look like a function
name.  C++ programmers seem to think so with some regularity, especially
when the first word is "new".)  Thus, the parentheses of

     new Critter ('Barney', 1.5, 70)

   are assumed to surround ALL the arguments of the method call, regardless
of what comes after.  Saying

     new Critter ('Bam' x 2), 1.4, 45

   would be equivalent to

     Critter->new('Bam' x 2), 1.4, 45

   which is unlikely to do what you want.  Confusingly, however, this rule
applies only when the indirect object is a bareword package name, not when
it's a scalar, a BLOCK, or a `Package::' qualified package name.  In those
cases, the arguments are parsed in the same way as an indirect object list
operator like print, so

     new Critter:: ('Bam' x 2), 1.4, 45

   is the same as

     Critter::->new(('Bam' x 2), 1.4, 45)

   For more reasons why the indirect object syntax is ambiguous, see
`"WARNING"' in this node below.

   There are times when you wish to specify which class's method to use.
Here you can call your method as an ordinary subroutine call, being sure
to pass the requisite first argument explicitly:

     $fred =  MyCritter::find("Critter", "Fred");
     MyCritter::display($fred, 'Height', 'Weight');

   Unlike method calls, function calls don't consider inheritance.  If you
wish merely to specify that Perl should START looking for a method in a
particular package, use an ordinary method call, but qualify the method
name with the package like this:

     $fred = Critter->MyCritter::find("Fred");
     $fred->MyCritter::display('Height', 'Weight');

   If you're trying to control where the method search begins and you're
executing in the class itself, then you may use the SUPER pseudo class,
which says to start looking in your base class's @ISA list without having
to name it explicitly:

     $self->SUPER::display('Height', 'Weight');

   Please note that the `SUPER::' construct is meaningful *only* within the
class.

   Sometimes you want to call a method when you don't know the method name
ahead of time.  You can use the arrow form, replacing the method name with
a simple scalar variable containing the method name or a reference to the
function.

     $method = $fast ? "findfirst" : "findbest";
     $fred->$method(@args);  	    # call by name

     if ($coderef = $fred->can($parent . "::findbest")) {
     	$self->$coderef(@args);	    # call by coderef
     }

WARNING
-------

   While indirect object syntax may well be appealing to English speakers
and to C++ programmers, be not seduced!  It suffers from two grave
problems.

   The first problem is that an indirect object is limited to a name, a
scalar variable, or a block, because it would have to do too much
lookahead otherwise, just like any other postfix dereference in the
language.  (These are the same quirky rules as are used for the filehandle
slot in functions like print and printf.)  This can lead to horribly
confusing precedence problems, as in these next two lines:

     move $obj->{FIELD};                 # probably wrong!
     move $ary[$i];                      # probably wrong!

   Those actually parse as the very surprising:

     $obj->move->{FIELD};                # Well, lookee here
     $ary->move([$i]);                   # Didn't expect this one, eh?

   Rather than what you might have expected:

     $obj->{FIELD}->move();              # You should be so lucky.
     $ary[$i]->move;                     # Yeah, sure.

   The left side of "->" is not so limited, because it's an infix operator,
not a postfix operator.

   As if that weren't bad enough, think about this: Perl must guess *at
compile time* whether name and move above are functions or methods.
Usually Perl gets it right, but when it doesn't it, you get a function
call compiled as a method, or vice versa.  This can introduce subtle bugs
that are hard to unravel.  For example, calling a method new in indirect
notation-as C++ programmers are so wont to do-can be miscompiled into a
subroutine call if there's already a new function in scope.  You'd end up
calling the current package's new as a subroutine, rather than the desired
class's method.  The compiler tries to cheat by remembering bareword
requires, but the grief if it messes up just isn't worth the years of
debugging it would likely take you to track such subtle bugs down.

   The infix arrow notation using "`< -' >>" doesn't suffer from either of
these disturbing ambiguities, so we recommend you use it exclusively.

Default UNIVERSAL methods
-------------------------

   The UNIVERSAL package automatically contains the following methods that
are inherited by all other classes:

isa(CLASS)
     isa returns *true* if its object is blessed into a subclass of CLASS

     isa is also exportable and can be called as a sub with two arguments.
     This allows the ability to check what a reference points to. Example

          use UNIVERSAL qw(isa);

          if(isa($ref, 'ARRAY')) {
          	#...
          }

can(METHOD)
     can checks to see if its object has a method called METHOD, if it
     does then a reference to the sub is returned, if it does not then
     undef is returned.

VERSION( [NEED] )
     VERSION returns the version number of the class (package).  If the
     NEED argument is given then it will check that the current version (as
     defined by the $VERSION variable in the given package) not less than
     NEED; it will die if this is not the case.  This method is normally
     called as a class method.  This method is called automatically by the
     VERSION form of use.

          use A 1.2 qw(some imported subs);
          # implies:
          A->VERSION(1.2);

   NOTE: can directly uses Perl's internal code for method lookup, and isa
uses a very similar method and cache-ing strategy. This may cause strange
effects if the Perl code dynamically changes @ISA in any package.

   You may add other methods to the UNIVERSAL class via Perl or XS code.
You do not need to `use UNIVERSAL' to make these methods available to your
program.  This is necessary only if you wish to have isa available as a
plain subroutine in the current package.

Destructors
-----------

   When the last reference to an object goes away, the object is
automatically destroyed.  (This may even be after you exit, if you've
stored references in global variables.)  If you want to capture control
just before the object is freed, you may define a DESTROY method in your
class.  It will automatically be called at the appropriate moment, and you
can do any extra cleanup you need to do.  Perl passes a reference to the
object under destruction as the first (and only) argument.  Beware that
the reference is a read-only value, and cannot be modified by manipulating
`$_[0]' within the destructor.  The object itself (i.e.  the thingy the
reference points to, namely `${$_[0]}', `@{$_[0]}', `%{$_[0]}' etc.) is
not similarly constrained.

   If you arrange to re-bless the reference before the destructor returns,
perl will again call the DESTROY method for the re-blessed object after
the current one returns.  This can be used for clean delegation of object
destruction, or for ensuring that destructors in the base classes of your
choosing get called.  Explicitly calling DESTROY is also possible, but is
usually never needed.

   Do not confuse the previous discussion with how objects *CONTAINED* in
the current one are destroyed.  Such objects will be freed and destroyed
automatically when the current object is freed, provided no other
references to them exist elsewhere.

Summary
-------

   That's about all there is to it.  Now you need just to go off and buy a
book about object-oriented design methodology, and bang your forehead with
it for the next six months or so.

Two-Phased Garbage Collection
-----------------------------

   For most purposes, Perl uses a fast and simple, reference-based garbage
collection system.  That means there's an extra dereference going on at
some level, so if you haven't built your Perl executable using your C
compiler's -O flag, performance will suffer.  If you *have* built Perl
with `cc -O', then this probably won't matter.

   A more serious concern is that unreachable memory with a non-zero
reference count will not normally get freed.  Therefore, this is a bad
idea:

     {
     	my $a;
     	$a = \$a;
     }

   Even thought $a should go away, it can't.  When building recursive data
structures, you'll have to break the self-reference yourself explicitly if
you don't care to leak.  For example, here's a self-referential node such
as one might use in a sophisticated tree structure:

     sub new_node {
     	my $self = shift;
     	my $class = ref($self) || $self;
     	my $node = {};
     	$node->{LEFT} = $node->{RIGHT} = $node;
     	$node->{DATA} = [ @_ ];
     	return bless $node => $class;
     }

   If you create nodes like that, they (currently) won't go away unless you
break their self reference yourself.  (In other words, this is not to be
construed as a feature, and you shouldn't depend on it.)

   Almost.

   When an interpreter thread finally shuts down (usually when your program
exits), then a rather costly but complete mark-and-sweep style of garbage
collection is performed, and everything allocated by that thread gets
destroyed.  This is essential to support Perl as an embedded or a
multithreadable language.  For example, this program demonstrates Perl's
two-phased garbage collection:

     #!/usr/bin/perl
     package Subtle;

     sub new {
     	my $test;
     	$test = \$test;
     	warn "CREATING " . \$test;
     	return bless \$test;
     }

     sub DESTROY {
     	my $self = shift;
     	warn "DESTROYING $self";
     }

     package main;

     warn "starting program";
     {
     	my $a = Subtle->new;
     	my $b = Subtle->new;
     	$$a = 0;  # break selfref
     	warn "leaving block";
     }

     warn "just exited block";
     warn "time to die...";
     exit;

   When run as `/tmp/test', the following output is produced:

     starting program at /tmp/test line 18.
     CREATING SCALAR(0x8e5b8) at /tmp/test line 7.
     CREATING SCALAR(0x8e57c) at /tmp/test line 7.
     leaving block at /tmp/test line 23.
     DESTROYING Subtle=SCALAR(0x8e5b8) at /tmp/test line 13.
     just exited block at /tmp/test line 26.
     time to die... at /tmp/test line 27.
     DESTROYING Subtle=SCALAR(0x8e57c) during global destruction.

   Notice that "global destruction" bit there?  That's the thread garbage
collector reaching the unreachable.

   Objects are always destructed, even when regular refs aren't.  Objects
are destructed in a separate pass before ordinary refs just to prevent
object destructors from using refs that have been themselves destructed.
Plain refs are only garbage-collected if the destruct level is greater
than 0.  You can test the higher levels of global destruction by setting
the PERL_DESTRUCT_LEVEL environment variable, presuming `-DDEBUGGING' was
enabled during perl build time.

   A more complete garbage collection strategy will be implemented at a
future date.

   In the meantime, the best solution is to create a non-recursive
container class that holds a pointer to the self-referential data
structure.  Define a DESTROY method for the containing object's class that
manually breaks the circularities in the self-referential structure.

SEE ALSO
========

   A kinder, gentler tutorial on object-oriented programming in Perl can
be found in *Note Perltoot: perltoot, and *Note Perltootc: perltootc,.
You should also check out *Note Perlbot: perlbot, for other object tricks,
traps, and tips, as well as *Note Perlmodlib: perlmodlib, for some style
guides on constructing both modules and classes.


File: perl.info,  Node: perlop,  Next: perlre,  Prev: perlsyn,  Up: Top

Perl operators and precedence
*****************************

NAME
====

   perlop - Perl operators and precedence

SYNOPSIS
========

   Perl operators have the following associativity and precedence, listed
from highest precedence to lowest.  Operators borrowed from C keep the
same precedence relationship with each other, even where C's precedence is
slightly screwy.  (This makes learning Perl easier for C folks.)  With
very few exceptions, these all operate on scalar values only, not array
values.

     left	terms and list operators (leftward)
     left	->
     nonassoc	++ --
     right	**
     right	! ~ \ and unary + and -
     left	=~ !~
     left	* / % x
     left	+ - .
     left	<< >>
     nonassoc	named unary operators
     nonassoc	< > <= >= lt gt le ge
     nonassoc	== != <=> eq ne cmp
     left	&
     left	| ^
     left	&&
     left	||
     nonassoc	..  ...
     right	?:
     right	= += -= *= etc.
     left	, =>
     nonassoc	list operators (rightward)
     right	not
     left	and
     left	or xor

   In the following sections, these operators are covered in precedence
order.

   Many operators can be overloaded for objects.  See *Note Overload:
(pm.info)overload,.

DESCRIPTION
===========

Terms and List Operators (Leftward)
-----------------------------------

   A TERM has the highest precedence in Perl.  They include variables,
quote and quote-like operators, any expression in parentheses, and any
function whose arguments are parenthesized.  Actually, there aren't really
functions in this sense, just list operators and unary operators behaving
as functions because you put parentheses around the arguments.  These are
all documented in *Note Perlfunc: perlfunc,.

   If any list operator (print(), etc.) or any unary operator (chdir(),
etc.)  is followed by a left parenthesis as the next token, the operator
and arguments within parentheses are taken to be of highest precedence,
just like a normal function call.

   In the absence of parentheses, the precedence of list operators such as
print, sort, or chmod is either very high or very low depending on whether
you are looking at the left side or the right side of the operator.  For
example, in

     @ary = (1, 3, sort 4, 2);
     print @ary;		# prints 1324

   the commas on the right of the sort are evaluated before the sort, but
the commas on the left are evaluated after.  In other words, list
operators tend to gobble up all arguments that follow, and then act like a
simple TERM with regard to the preceding expression.  Be careful with
parentheses:

     # These evaluate exit before doing the print:
     print($foo, exit);	# Obviously not what you want.
     print $foo, exit;	# Nor is this.

     # These do the print before evaluating exit:
     (print $foo), exit;	# This is what you want.
     print($foo), exit;	# Or this.
     print ($foo), exit;	# Or even this.

   Also note that

     print ($foo & 255) + 1, "\n";

   probably doesn't do what you expect at first glance.  See `Named Unary
Operators' in this node for more discussion of this.

   Also parsed as terms are the `do {}' and `eval {}' constructs, as well
as subroutine and method calls, and the anonymous constructors [] and `{}'.

   See also `Quote and Quote-like Operators' in this node toward the end
of this section, as well as `"I' in this node.

The Arrow Operator
------------------

   "`< -' >>" is an infix dereference operator, just as it is in C and
C++.  If the right side is either a `[...]', `{...}', or a `(...)'
subscript, then the left side must be either a hard or symbolic reference
to an array, a hash, or a subroutine respectively.  (Or technically
speaking, a location capable of holding a hard reference, if it's an array
or hash reference being used for assignment.)  See *Note Perlreftut:
perlreftut, and *Note Perlref: perlref,.

   Otherwise, the right side is a method name or a simple scalar variable
containing either the method name or a subroutine reference, and the left
side must be either an object (a blessed reference) or a class name (that
is, a package name).  See *Note Perlobj: perlobj,.

Auto-increment and Auto-decrement
---------------------------------

   "++" and "-" work as in C.  That is, if placed before a variable, they
increment or decrement the variable before returning the value, and if
placed after, increment or decrement the variable after returning the
value.

   The auto-increment operator has a little extra builtin magic to it.  If
you increment a variable that is numeric, or that has ever been used in a
numeric context, you get a normal increment.  If, however, the variable
has been used in only string contexts since it was set, and has a value
that is not the empty string and matches the pattern
`/^[a-zA-Z]*[0-9]*$/', the increment is done as a string, preserving each
character within its range, with carry:

     print ++($foo = '99');	# prints '100'
     print ++($foo = 'a0');	# prints 'a1'
     print ++($foo = 'Az');	# prints 'Ba'
     print ++($foo = 'zz');	# prints 'aaa'

   The auto-decrement operator is not magical.

Exponentiation
--------------

   Binary "**" is the exponentiation operator.  It binds even more tightly
than unary minus, so -2**4 is -(2**4), not (-2)**4. (This is implemented
using C's pow(3) function, which actually works on doubles internally.)

Symbolic Unary Operators
------------------------

   Unary "!" performs logical negation, i.e., "not".  See also not for a
lower precedence version of this.

   Unary "-" performs arithmetic negation if the operand is numeric.  If
the operand is an identifier, a string consisting of a minus sign
concatenated with the identifier is returned.  Otherwise, if the string
starts with a plus or minus, a string starting with the opposite sign is
returned.  One effect of these rules is that `-bareword' is equivalent to
`"-bareword"'.

   Unary "~" performs bitwise negation, i.e., 1's complement.  For
example, `0666 & ~027' is 0640.  (See also `Integer Arithmetic' in this
node and `Bitwise String Operators' in this node.)  Note that the width of
the result is platform-dependent: ~0 is 32 bits wide on a 32-bit platform,
but 64 bits wide on a 64-bit platform, so if you are expecting a certain
bit width, remember use the & operator to mask off the excess bits.

   Unary "+" has no effect whatsoever, even on strings.  It is useful
syntactically for separating a function name from a parenthesized
expression that would otherwise be interpreted as the complete list of
function arguments.  (See examples above under `Terms and List Operators
(Leftward)' in this node.)

   Unary "\" creates a reference to whatever follows it.  See *Note
Perlreftut: perlreftut, and *Note Perlref: perlref,.  Do not confuse this
behavior with the behavior of backslash within a string, although both
forms do convey the notion of protecting the next thing from interpolation.

Binding Operators
-----------------

   Binary "=~" binds a scalar expression to a pattern match.  Certain
operations search or modify the string $_ by default.  This operator makes
that kind of operation work on some other string.  The right argument is a
search pattern, substitution, or transliteration.  The left argument is
what is supposed to be searched, substituted, or transliterated instead of
the default $_.  When used in scalar context, the return value generally
indicates the success of the operation.  Behavior in list context depends
on the particular operator.  See `' in this node for details.

   If the right argument is an expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a search pattern at
run time.  This can be less efficient than an explicit search, because the
pattern must be compiled every time the expression is evaluated.

   Binary "!~" is just like "=~" except the return value is negated in the
logical sense.

Multiplicative Operators
------------------------

   Binary "*" multiplies two numbers.

   Binary "/" divides two numbers.

   Binary "%" computes the modulus of two numbers.  Given integer operands
`$a' and $b: If $b is positive, then `$a % $b' is `$a' minus the largest
multiple of $b that is not greater than `$a'.  If $b is negative, then `$a
% $b' is `$a' minus the smallest multiple of $b that is not less than `$a'
(i.e. the result will be less than or equal to zero).  Note than when `use
integer' is in scope, "%" give you direct access to the modulus operator
as implemented by your C compiler.  This operator is not as well defined
for negative operands, but it will execute faster.

   Binary "x" is the repetition operator.  In scalar context or if the left
operand is not enclosed in parentheses, it returns a string consisting of
the left operand repeated the number of times specified by the right
operand.  In list context, if the left operand is enclosed in parentheses,
it repeats the list.

     print '-' x 80;		# print row of dashes

     print "\t" x ($tab/8), ' ' x ($tab%8);	# tab over

     @ones = (1) x 80;		# a list of 80 1's
     @ones = (5) x @ones;	# set all elements to 5

Additive Operators
------------------

   Binary "+" returns the sum of two numbers.

   Binary "-" returns the difference of two numbers.

   Binary "." concatenates two strings.

Shift Operators
---------------

   Binary "<<" returns the value of its left argument shifted left by the
number of bits specified by the right argument.  Arguments should be
integers.  (See also `Integer Arithmetic' in this node.)

   Binary ">>" returns the value of its left argument shifted right by the
number of bits specified by the right argument.  Arguments should be
integers.  (See also `Integer Arithmetic' in this node.)

Named Unary Operators
---------------------

   The various named unary operators are treated as functions with one
argument, with optional parentheses.  These include the filetest
operators, like -f, -M, etc.  See *Note Perlfunc: perlfunc,.

   If any list operator (print(), etc.) or any unary operator (chdir(),
etc.)  is followed by a left parenthesis as the next token, the operator
and arguments within parentheses are taken to be of highest precedence,
just like a normal function call.  Examples:

     chdir $foo    || die;	# (chdir $foo) || die
     chdir($foo)   || die;	# (chdir $foo) || die
     chdir ($foo)  || die;	# (chdir $foo) || die
     chdir +($foo) || die;	# (chdir $foo) || die

   but, because * is higher precedence than ||:

     chdir $foo * 20;	# chdir ($foo * 20)
     chdir($foo) * 20;	# (chdir $foo) * 20
     chdir ($foo) * 20;	# (chdir $foo) * 20
     chdir +($foo) * 20;	# chdir ($foo * 20)

     rand 10 * 20;	# rand (10 * 20)
     rand(10) * 20;	# (rand 10) * 20
     rand (10) * 20;	# (rand 10) * 20
     rand +(10) * 20;	# rand (10 * 20)

   See also `"Terms and List Operators (Leftward)"' in this node.

Relational Operators
--------------------

   Binary "<" returns true if the left argument is numerically less than
the right argument.

   Binary ">" returns true if the left argument is numerically greater
than the right argument.

   Binary "<=" returns true if the left argument is numerically less than
or equal to the right argument.

   Binary ">=" returns true if the left argument is numerically greater
than or equal to the right argument.

   Binary "lt" returns true if the left argument is stringwise less than
the right argument.

   Binary "gt" returns true if the left argument is stringwise greater
than the right argument.

   Binary "le" returns true if the left argument is stringwise less than
or equal to the right argument.

   Binary "ge" returns true if the left argument is stringwise greater
than or equal to the right argument.

Equality Operators
------------------

   Binary "==" returns true if the left argument is numerically equal to
the right argument.

   Binary "!=" returns true if the left argument is numerically not equal
to the right argument.

   Binary "<=>" returns -1, 0, or 1 depending on whether the left argument
is numerically less than, equal to, or greater than the right argument.

   Binary "eq" returns true if the left argument is stringwise equal to
the right argument.

   Binary "ne" returns true if the left argument is stringwise not equal
to the right argument.

   Binary "cmp" returns -1, 0, or 1 depending on whether the left argument
is stringwise less than, equal to, or greater than the right argument.

   "lt", "le", "ge", "gt" and "cmp" use the collation (sort) order
specified by the current locale if `use locale' is in effect.  See *Note
Perllocale: perllocale,.

Bitwise And
-----------

   Binary "&" returns its operators ANDed together bit by bit.  (See also
`Integer Arithmetic' in this node and `Bitwise String Operators' in this
node.)

Bitwise Or and Exclusive Or
---------------------------

   Binary "|" returns its operators ORed together bit by bit.  (See also
`Integer Arithmetic' in this node and `Bitwise String Operators' in this
node.)

   Binary "^" returns its operators XORed together bit by bit.  (See also
`Integer Arithmetic' in this node and `Bitwise String Operators' in this
node.)

C-style Logical And
-------------------

   Binary "&&" performs a short-circuit logical AND operation.  That is,
if the left operand is false, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it is
evaluated.

C-style Logical Or
------------------

   Binary "||" performs a short-circuit logical OR operation.  That is, if
the left operand is true, the right operand is not even evaluated.  Scalar
or list context propagates down to the right operand if it is evaluated.

   The `||' and `&&' operators differ from C's in that, rather than
returning 0 or 1, they return the last value evaluated.  Thus, a
reasonably portable way to find out the home directory (assuming it's not
"0") might be:

     $home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
     	(getpwuid($<))[7] || die "You're homeless!\n";

   In particular, this means that you shouldn't use this for selecting
between two aggregates for assignment:

     @a = @b || @c;		# this is wrong
     @a = scalar(@b) || @c;	# really meant this
     @a = @b ? @b : @c;		# this works fine, though

   As more readable alternatives to `&&' and `||' when used for control
flow, Perl provides and and or operators (see below).  The short-circuit
behavior is identical.  The precedence of "and" and "or" is much lower,
however, so that you can safely use them after a list operator without the
need for parentheses:

     unlink "alpha", "beta", "gamma"
     	    or gripe(), next LINE;

   With the C-style operators that would have been written like this:

     unlink("alpha", "beta", "gamma")
     	    || (gripe(), next LINE);

   Using "or" for assignment is unlikely to do what you want; see below.

Range Operators
---------------

   Binary ".." is the range operator, which is really two different
operators depending on the context.  In list context, it returns an array
of values counting (up by ones) from the left value to the right value.
If the left value is greater than the right value then it returns the
empty array.  The range operator is useful for writing `foreach (1..10)'
loops and for doing slice operations on arrays.  In the current
implementation, no temporary array is created when the range operator is
used as the expression in foreach loops, but older versions of Perl might
burn a lot of memory when you write something like this:

     for (1 .. 1_000_000) {
     	# code
     }

   In scalar context, ".." returns a boolean value.  The operator is
bistable, like a flip-flop, and emulates the line-range (comma) operator
of *sed*, *awk*, and various editors.  Each ".." operator maintains its
own boolean state.  It is false as long as its left operand is false.
Once the left operand is true, the range operator stays true until the
right operand is true, *AFTER* which the range operator becomes false
again.  It doesn't become false till the next time the range operator is
evaluated.  It can test the right operand and become false on the same
evaluation it became true (as in *awk*), but it still returns true once.
If you don't want it to test the right operand till the next evaluation,
as in *sed*, just use three dots ("...") instead of two.  In all other
regards, "..." behaves just like ".." does.

   The right operand is not evaluated while the operator is in the "false"
state, and the left operand is not evaluated while the operator is in the
"true" state.  The precedence is a little lower than || and &&.  The value
returned is either the empty string for false, or a sequence number
(beginning with 1) for true.  The sequence number is reset for each range
encountered.  The final sequence number in a range has the string "E0"
appended to it, which doesn't affect its numeric value, but gives you
something to search for if you want to exclude the endpoint.  You can
exclude the beginning point by waiting for the sequence number to be
greater than 1.  If either operand of scalar ".." is a constant expression,
that operand is implicitly compared to the $. variable, the current line
number.  Examples:

   As a scalar operator:

     if (101 .. 200) { print; }	# print 2nd hundred lines
     next line if (1 .. /^$/);	# skip header lines
     s/^/> / if (/^$/ .. eof());	# quote body

     # parse mail messages
     while (<>) {
         $in_header =   1  .. /^$/;
         $in_body   = /^$/ .. eof();
     	# do something based on those
     } continue {
     	close ARGV if eof; 		# reset $. each file
     }

   As a list operator:

     for (101 .. 200) { print; }	# print $_ 100 times
     @foo = @foo[0 .. $#foo];	# an expensive no-op
     @foo = @foo[$#foo-4 .. $#foo];	# slice last 5 items

   The range operator (in list context) makes use of the magical
auto-increment algorithm if the operands are strings.  You can say

     @alphabet = ('A' .. 'Z');

   to get all normal letters of the alphabet, or

     $hexdigit = (0 .. 9, 'a' .. 'f')[$num & 15];

   to get a hexadecimal digit, or

     @z2 = ('01' .. '31');  print $z2[$mday];

   to get dates with leading zeros.  If the final value specified is not
in the sequence that the magical increment would produce, the sequence
goes until the next value would be longer than the final value specified.

Conditional Operator
--------------------

   Ternary "?:" is the conditional operator, just as in C.  It works much
like an if-then-else.  If the argument before the ? is true, the argument
before the : is returned, otherwise the argument after the : is returned.
For example:

     printf "I have %d dog%s.\n", $n,
     	    ($n == 1) ? '' : "s";

   Scalar or list context propagates downward into the 2nd or 3rd
argument, whichever is selected.

     $a = $ok ? $b : $c;  # get a scalar
     @a = $ok ? @b : @c;  # get an array
     $a = $ok ? @b : @c;  # oops, that's just a count!

   The operator may be assigned to if both the 2nd and 3rd arguments are
legal lvalues (meaning that you can assign to them):

     ($a_or_b ? $a : $b) = $c;

   Because this operator produces an assignable result, using assignments
without parentheses will get you in trouble.  For example, this:

     $a % 2 ? $a += 10 : $a += 2

   Really means this:

     (($a % 2) ? ($a += 10) : $a) += 2

   Rather than this:

     ($a % 2) ? ($a += 10) : ($a += 2)

   That should probably be written more simply as:

     $a += ($a % 2) ? 10 : 2;

Assignment Operators
--------------------

   "=" is the ordinary assignment operator.

   Assignment operators work as in C.  That is,

     $a += 2;

   is equivalent to

     $a = $a + 2;

   although without duplicating any side effects that dereferencing the
lvalue might trigger, such as from tie().  Other assignment operators work
similarly.  The following are recognized:

     **=    +=    *=    &=    <<=    &&=
            -=    /=    |=    >>=    ||=
            .=    %=    ^=
     	         x=

   Although these are grouped by family, they all have the precedence of
assignment.

   Unlike in C, the scalar assignment operator produces a valid lvalue.
Modifying an assignment is equivalent to doing the assignment and then
modifying the variable that was assigned to.  This is useful for modifying
a copy of something, like this:

     ($tmp = $global) =~ tr [A-Z] [a-z];

   Likewise,

     ($a += 2) *= 3;

   is equivalent to

     $a += 2;
     $a *= 3;

   Similarly, a list assignment in list context produces the list of
lvalues assigned to, and a list assignment in scalar context returns the
number of elements produced by the expression on the right hand side of
the assignment.

Comma Operator
--------------

   Binary "," is the comma operator.  In scalar context it evaluates its
left argument, throws that value away, then evaluates its right argument
and returns that value.  This is just like C's comma operator.

   In list context, it's just the list argument separator, and inserts
both its arguments into the list.

   The => digraph is mostly just a synonym for the comma operator.  It's
useful for documenting arguments that come in pairs.  As of release 5.001,
it also forces any word to the left of it to be interpreted as a string.

List Operators (Rightward)
--------------------------

   On the right side of a list operator, it has very low precedence, such
that it controls all comma-separated expressions found there.  The only
operators with lower precedence are the logical operators "and", "or", and
"not", which may be used to evaluate calls to list operators without the
need for extra parentheses:

     open HANDLE, "filename"
     	or die "Can't open: $!\n";

   See also discussion of list operators in `Terms and List Operators
(Leftward)' in this node.

Logical Not
-----------

   Unary "not" returns the logical negation of the expression to its right.
It's the equivalent of "!" except for the very low precedence.

Logical And
-----------

   Binary "and" returns the logical conjunction of the two surrounding
expressions.  It's equivalent to && except for the very low precedence.
This means that it short-circuits: i.e., the right expression is evaluated
only if the left expression is true.

Logical or and Exclusive Or
---------------------------

   Binary "or" returns the logical disjunction of the two surrounding
expressions.  It's equivalent to || except for the very low precedence.
This makes it useful for control flow

     print FH $data		or die "Can't write to FH: $!";

   This means that it short-circuits: i.e., the right expression is
evaluated only if the left expression is false.  Due to its precedence,
you should probably avoid using this for assignment, only for control flow.

     $a = $b or $c;		# bug: this is wrong
     ($a = $b) or $c;		# really means this
     $a = $b || $c;		# better written this way

   However, when it's a list-context assignment and you're trying to use
"||" for control flow, you probably need "or" so that the assignment takes
higher precedence.

     @info = stat($file) || die;     # oops, scalar sense of stat!
     @info = stat($file) or die;     # better, now @info gets its due

   Then again, you could always use parentheses.

   Binary "xor" returns the exclusive-OR of the two surrounding
expressions.  It cannot short circuit, of course.

C Operators Missing From Perl
-----------------------------

   Here is what C has that Perl doesn't:

unary &
     Address-of operator.  (But see the "\" operator for taking a
     reference.)

unary *
     Dereference-address operator. (Perl's prefix dereferencing operators
     are typed: $, @, %, and &.)

(TYPE)
     Type-casting operator.

Quote and Quote-like Operators
------------------------------

   While we usually think of quotes as literal values, in Perl they
function as operators, providing various kinds of interpolating and
pattern matching capabilities.  Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your quote
character for any of them.  In the following table, a `{}' represents any
pair of delimiters you choose.

     Customary  Generic        Meaning	     Interpolates
     	''	 q{}	      Literal		  no
     	""	qq{}	      Literal		  yes
     	``	qx{}	      Command		  yes (unless '' is delimiter)
     		qw{}	     Word list		  no
     	//	 m{}	   Pattern match	  yes (unless '' is delimiter)
     		qr{}	      Pattern		  yes (unless '' is delimiter)
     		 s{}{}	    Substitution	  yes (unless '' is delimiter)
     		tr{}{}	  Transliteration	  no (but see below)

   Non-bracketing delimiters use the same character fore and aft, but the
four sorts of brackets (round, angle, square, curly) will all nest, which
means that

     q{foo{bar}baz}

   is the same as

     'foo{bar}baz'

   Note, however, that this does not always work for quoting Perl code:

     $s = q{ if($a eq "}") ... }; # WRONG

   is a syntax error. The `Text::Balanced' module on CPAN is able to do
this properly.

   There can be whitespace between the operator and the quoting
characters, except when `#' is being used as the quoting character.
`q#foo#' is parsed as the string foo, while `q #foo#' is the operator q
followed by a comment.  Its argument will be taken from the next line.
This allows you to write:

     s {foo}  # Replace foo
       {bar}  # with bar.

   For constructs that do interpolate, variables beginning with "`$'" or
"`@'" are interpolated, as are the following escape sequences.  Within a
transliteration, the first eleven of these sequences may be used.

     \t		tab             (HT, TAB)
     \n		newline         (NL)
     \r		return          (CR)
     \f		form feed       (FF)
     \b		backspace       (BS)
     \a		alarm (bell)    (BEL)
     \e		escape          (ESC)
     \033	octal char	(ESC)
     \x1b	hex char	(ESC)
     \x{263a}	wide hex char	(SMILEY)
     \c[		control char    (ESC)
     \N{name}	named char

     \l		lowercase next char
     \u		uppercase next char
     \L		lowercase till \E
     \U		uppercase till \E
     \E		end case modification
     \Q		quote non-word characters till \E

   If `use locale' is in effect, the case map used by `\l', `\L', `\u' and
`\U' is taken from the current locale.  See *Note Perllocale: perllocale,.
For documentation of `\N{name}', see *Note Charnames: (pm.info)charnames,.

   All systems use the virtual `"\n"' to represent a line terminator,
called a "newline".  There is no such thing as an unvarying, physical
newline character.  It is only an illusion that the operating system,
device drivers, C libraries, and Perl all conspire to preserve.  Not all
systems read `"\r"' as ASCII CR and `"\n"' as ASCII LF.  For example, on a
Mac, these are reversed, and on systems without line terminator, printing
`"\n"' may emit no actual data.  In general, use `"\n"' when you mean a
"newline" for your system, but use the literal ASCII when you need an
exact character.  For example, most networking protocols expect and prefer
a CR+LF (`"\012\015"' or `"\cJ\cM"') for line terminators, and although
they often accept just `"\012"', they seldom tolerate just `"\015"'.  If
you get in the habit of using `"\n"' for networking, you may be burned
some day.

   You cannot include a literal `$' or `@' within a `\Q' sequence.  An
unescaped `$' or `@' interpolates the corresponding variable, while
escaping will cause the literal string `\$' to be inserted.  You'll need
to write something like `m/\Quser\E\@\Qhost/'.

   Patterns are subject to an additional level of interpretation as a
regular expression.  This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.  If this is not what you want, use `\Q' to
interpolate a variable literally.

   Apart from the behavior described above, Perl does not expand multiple
levels of interpolation.  In particular, contrary to the expectations of
shell programmers, back-quotes do *NOT* interpolate within double quotes,
nor do single quotes impede evaluation of variables when used within
double quotes.

Regexp Quote-Like Operators
---------------------------

   Here are the quote-like operators that apply to pattern matching and
related activities.

?PATTERN?
     This is just like the /pattern/ search, except that it matches only
     once between calls to the reset() operator.  This is a useful
     optimization when you want to see only the first occurrence of
     something in each file of a set of files, for instance.  Only `??'
     patterns local to the current package are reset.

          while (<>) {
          	if (?^$?) {
          			    # blank line between header and body
          	}
          } continue {
          	reset if eof;	    # clear ?? status for next file
          }

     This usage is vaguely depreciated, which means it just might possibly
     be removed in some distant future version of Perl, perhaps somewhere
     around the year 2168.

m/PATTERN/cgimosx
/PATTERN/cgimosx
     Searches a string for a pattern match, and in scalar context returns
     true if it succeeds, false if it fails.  If no string is specified
     via the `=~' or `!~' operator, the $_ string is searched.  (The
     string specified with `=~' need not be an lvalue-it may be the result
     of an expression evaluation, but remember the `=~' binds rather
     tightly.)  See also *Note Perlre: perlre,.  See *Note Perllocale:
     perllocale, for discussion of additional considerations that apply
     when `use locale' is in effect.

     Options are:

          c	Do not reset search position on a failed match when /g is in effect.
          g	Match globally, i.e., find all occurrences.
          i	Do case-insensitive pattern matching.
          m	Treat string as multiple lines.
          o	Compile pattern only once.
          s	Treat string as single line.
          x	Use extended regular expressions.

     If "/" is the delimiter then the initial m is optional.  With the m
     you can use any pair of non-alphanumeric, non-whitespace characters
     as delimiters.  This is particularly useful for matching path names
     that contain "/", to avoid LTS (leaning toothpick syndrome).  If "?"
     is the delimiter, then the match-only-once rule of ?PATTERN? applies.
     If "'" is the delimiter, no interpolation is performed on the PATTERN.

     PATTERN may contain variables, which will be interpolated (and the
     pattern recompiled) every time the pattern search is evaluated, except
     for when the delimiter is a single quote.  (Note that $) and $| might
     not be interpolated because they look like end-of-string tests.)  If
     you want such a pattern to be compiled only once, add a `/o' after
     the trailing delimiter.  This avoids expensive run-time
     recompilations, and is useful when the value you are interpolating
     won't change over the life of the script.  However, mentioning `/o'
     constitutes a promise that you won't change the variables in the
     pattern.  If you change them, Perl won't even notice.  See also `"qr'
     in this node.

     If the PATTERN evaluates to the empty string, the last *successfully*
     matched regular expression is used instead.

     If the `/g' option is not used, m// in list context returns a list
     consisting of the subexpressions matched by the parentheses in the
     pattern, i.e., ($1, $2, $3...).  (Note that here $1 etc. are also
     set, and that this differs from Perl 4's behavior.)  When there are
     no parentheses in the pattern, the return value is the list (1) for
     success.  With or without parentheses, an empty list is returned upon
     failure.

     Examples:

          open(TTY, '/dev/tty');
          <TTY> =~ /^y/i && foo();	# do foo if desired

          if (/Version: *([0-9.]*)/) { $version = $1; }

          next if m#^/usr/spool/uucp#;

          # poor man's grep
          $arg = shift;
          while (<>) {
          	print if /$arg/o;	# compile only once
          }

          if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))

     This last example splits $foo into the first two words and the
     remainder of the line, and assigns those three fields to $F1, $F2, and
     $Etc.  The conditional is true if any variables were assigned, i.e.,
     if the pattern matched.

     The `/g' modifier specifies global pattern matching-that is, matching
     as many times as possible within the string.  How it behaves depends
     on the context.  In list context, it returns a list of the substrings
     matched by any capturing parentheses in the regular expression.  If
     there are no parentheses, it returns a list of all the matched
     strings, as if there were parentheses around the whole pattern.

     In scalar context, each execution of `m//g' finds the next match,
     returning true if it matches, and false if there is no further match.
     The position after the last match can be read or set using the pos()
     function; see `pos', *Note Perlfunc: perlfunc,.   A failed match
     normally resets the search position to the beginning of the string,
     but you can avoid that by adding the `/c' modifier (e.g. `m//gc').
     Modifying the target string also resets the search position.

     You can intermix `m//g' matches with `m/\G.../g', where `\G' is a
     zero-width assertion that matches the exact position where the
     previous `m//g', if any, left off.  The `\G' assertion is not
     supported without the `/g' modifier.  (Currently, without `/g', `\G'
     behaves just like `\A', but that's accidental and may change in the
     future.)

     Examples:

          # list context
          ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

          # scalar context
          $/ = ""; $* = 1;  # $* deprecated in modern perls
          while (defined($paragraph = <>)) {
          	while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
          	    $sentences++;
          	}
          }
          print "$sentences\n";

          # using m//gc with \G
          $_ = "ppooqppqq";
          while ($i++ < 2) {
              print "1: '";
              print $1 while /(o)/gc; print "', pos=", pos, "\n";
              print "2: '";
              print $1 if /\G(q)/gc;  print "', pos=", pos, "\n";
              print "3: '";
              print $1 while /(p)/gc; print "', pos=", pos, "\n";
          }

     The last example should print:

          1: 'oo', pos=4
          2: 'q', pos=5
          3: 'pp', pos=7
          1: '', pos=7
          2: 'q', pos=8
          3: '', pos=8

     A useful idiom for lex-like scanners is `/\G.../gc'.  You can combine
     several regexps like this to process a string part-by-part, doing
     different actions depending on which regexp matched.  Each regexp
     tries to match where the previous one leaves off.

          $_ = <<'EOL';
               $url = new URI::URL "http://www/";   die if $url eq "xXx";
          EOL
          LOOP:
             {
               print(" digits"),		redo LOOP if /\G\d+\b[,.;]?\s*/gc;
               print(" lowercase"),	redo LOOP if /\G[a-z]+\b[,.;]?\s*/gc;
               print(" UPPERCASE"),	redo LOOP if /\G[A-Z]+\b[,.;]?\s*/gc;
               print(" Capitalized"),	redo LOOP if /\G[A-Z][a-z]+\b[,.;]?\s*/gc;
               print(" MiXeD"),		redo LOOP if /\G[A-Za-z]+\b[,.;]?\s*/gc;
               print(" alphanumeric"),	redo LOOP if /\G[A-Za-z0-9]+\b[,.;]?\s*/gc;
               print(" line-noise"),	redo LOOP if /\G[^A-Za-z0-9]+/gc;
               print ". That's all!\n";
             }

     Here is the output (split into several lines):

          line-noise lowercase line-noise lowercase UPPERCASE line-noise
          UPPERCASE line-noise lowercase line-noise lowercase line-noise
          lowercase lowercase line-noise lowercase lowercase line-noise
          MiXeD line-noise. That's all!

q/STRING/
`'STRING''
     A single-quoted, literal string.  A backslash represents a backslash
     unless followed by the delimiter or another backslash, in which case
     the delimiter or backslash is interpolated.

          $foo = q!I said, "You said, 'She said it.'"!;
          $bar = q('This is it.');
          $baz = '\n';		# a two-character string

qq/STRING/
"STRING"
     A double-quoted, interpolated string.

          $_ .= qq
           (*** The previous line contains the naughty word "$1".\n)
          		if /\b(tcl|java|python)\b/i;      # :-)
          $baz = "\n";		# a one-character string

qr/STRING/imosx
     This operators quotes-and compiles-its STRING as a regular
     expression.  STRING is interpolated the same way as PATTERN in
     `m/PATTERN/'.  If "'" is used as the delimiter, no interpolation is
     done.  Returns a Perl value which may be used instead of the
     corresponding `/STRING/imosx' expression.

     For example,

          $rex = qr/my.STRING/is;
          s/$rex/foo/;

     is equivalent to

          s/my.STRING/foo/is;

     The result may be used as a subpattern in a match:

          $re = qr/$pattern/;
          $string =~ /foo${re}bar/;	# can be interpolated in other patterns
          $string =~ $re;		# or used standalone
          $string =~ /$re/;		# or this way

     Since Perl may compile the pattern at the moment of execution of qr()
     operator, using qr() may have speed advantages in some situations,
     notably if the result of qr() is used standalone:

          sub match {
          	my $patterns = shift;
          	my @compiled = map qr/$_/i, @$patterns;
          	grep {
          	    my $success = 0;
          	    foreach my $pat (@compiled) {
          		$success = 1, last if /$pat/;
          	    }
          	    $success;
          	} @_;
          }

     Precompilation of the pattern into an internal representation at the
     moment of qr() avoids a need to recompile the pattern every time a
     match `/$pat/' is attempted.  (Perl has many other internal
     optimizations, but none would be triggered in the above example if we
     did not use qr() operator.)

     Options are:

          i	Do case-insensitive pattern matching.
          m	Treat string as multiple lines.
          o	Compile pattern only once.
          s	Treat string as single line.
          x	Use extended regular expressions.

     See *Note Perlre: perlre, for additional information on valid syntax
     for STRING, and for a detailed look at the semantics of regular
     expressions.

qx/STRING/
`STRING`
     A string which is (possibly) interpolated and then executed as a
     system command with `/bin/sh' or its equivalent.  Shell wildcards,
     pipes, and redirections will be honored.  The collected standard
     output of the command is returned; standard error is unaffected.  In
     scalar context, it comes back as a single (potentially multi-line)
     string.  In list context, returns a list of lines (however you've
     defined lines with $/ or $INPUT_RECORD_SEPARATOR).

     Because backticks do not affect standard error, use shell file
     descriptor syntax (assuming the shell supports this) if you care to
     address this.  To capture a command's STDERR and STDOUT together:

          $output = `cmd 2>&1`;

     To capture a command's STDOUT but discard its STDERR:

          $output = `cmd 2>/dev/null`;

     To capture a command's STDERR but discard its STDOUT (ordering is
     important here):

          $output = `cmd 2>&1 1>/dev/null`;

     To exchange a command's STDOUT and STDERR in order to capture the
     STDERR but leave its STDOUT to come out the old STDERR:

          $output = `cmd 3>&1 1>&2 2>&3 3>&-`;

     To read both a command's STDOUT and its STDERR separately, it's
     easiest and safest to redirect them separately to files, and then
     read from those files when the program is done:

          system("program args 1>/tmp/program.stdout 2>/tmp/program.stderr");

     Using single-quote as a delimiter protects the command from Perl's
     double-quote interpolation, passing it on to the shell instead:

          $perl_info  = qx(ps $$);            # that's Perl's $$
          $shell_info = qx'ps $$';            # that's the new shell's $$

     How that string gets evaluated is entirely subject to the command
     interpreter on your system.  On most platforms, you will have to
     protect shell metacharacters if you want them treated literally.
     This is in practice difficult to do, as it's unclear how to escape
     which characters.  See *Note Perlsec: perlsec, for a clean and safe
     example of a manual fork() and exec() to emulate backticks safely.

     On some platforms (notably DOS-like ones), the shell may not be
     capable of dealing with multiline commands, so putting newlines in
     the string may not get you what you want.  You may be able to evaluate
     multiple commands in a single line by separating them with the command
     separator character, if your shell supports that (e.g. `;' on many
     Unix shells; & on the Windows NT cmd shell).

     Beginning with v5.6.0, Perl will attempt to flush all files opened for
     output before starting the child process, but this may not be
     supported on some platforms (see *Note Perlport: perlport,).  To be
     safe, you may need to set $| ($AUTOFLUSH in English) or call the
     autoflush() method of IO::Handle on any open handles.

     Beware that some command shells may place restrictions on the length
     of the command line.  You must ensure your strings don't exceed this
     limit after any necessary interpolations.  See the platform-specific
     release notes for more details about your particular environment.

     Using this operator can lead to programs that are difficult to port,
     because the shell commands called vary between systems, and may in
     fact not be present at all.  As one example, the type command under
     the POSIX shell is very different from the type command under DOS.
     That doesn't mean you should go out of your way to avoid backticks
     when they're the right way to get something done.  Perl was made to be
     a glue language, and one of the things it glues together is commands.
     Just understand what you're getting yourself into.

     See `"I' in this node for more discussion.

qw/STRING/
     Evaluates to a list of the words extracted out of STRING, using
     embedded whitespace as the word delimiters.  It can be understood as
     being roughly equivalent to:

          split(' ', q/STRING/);

     the difference being that it generates a real list at compile time.
     So this expression:

          qw(foo bar baz)

     is semantically equivalent to the list:

          'foo', 'bar', 'baz'

     Some frequently seen examples:

          use POSIX qw( setlocale localeconv )
          @EXPORT = qw( foo bar baz );

     A common mistake is to try to separate the words with comma or to put
     comments into a multi-line `qw'-string.  For this reason, the `use
     warnings' pragma and the -w switch (that is, the $^W variable)
     produces warnings if the STRING contains the "," or the "#" character.

s/PATTERN/REPLACEMENT/egimosx
     Searches a string for a pattern, and if found, replaces that pattern
     with the replacement text and returns the number of substitutions
     made.  Otherwise it returns false (specifically, the empty string).

     If no string is specified via the `=~' or `!~' operator, the $_
     variable is searched and modified.  (The string specified with `=~'
     must be scalar variable, an array element, a hash element, or an
     assignment to one of those, i.e., an lvalue.)

     If the delimiter chosen is a single quote, no interpolation is done
     on either the PATTERN or the REPLACEMENT.  Otherwise, if the PATTERN
     contains a $ that looks like a variable rather than an end-of-string
     test, the variable will be interpolated into the pattern at run-time.
     If you want the pattern compiled only once the first time the
     variable is interpolated, use the `/o' option.  If the pattern
     evaluates to the empty string, the last successfully executed regular
     expression is used instead.  See *Note Perlre: perlre, for further
     explanation on these.  See *Note Perllocale: perllocale, for
     discussion of additional considerations that apply when `use locale'
     is in effect.

     Options are:

          e	Evaluate the right side as an expression.
          g	Replace globally, i.e., all occurrences.
          i	Do case-insensitive pattern matching.
          m	Treat string as multiple lines.
          o	Compile pattern only once.
          s	Treat string as single line.
          x	Use extended regular expressions.

     Any non-alphanumeric, non-whitespace delimiter may replace the
     slashes.  If single quotes are used, no interpretation is done on the
     replacement string (the `/e' modifier overrides this, however).
     Unlike Perl 4, Perl 5 treats backticks as normal delimiters; the
     replacement text is not evaluated as a command.  If the PATTERN is
     delimited by bracketing quotes, the REPLACEMENT has its own pair of
     quotes, which may or may not be bracketing quotes, e.g.,
     `s(foo)(bar)' or `< s<foo'/bar/ >>.  A `/e' will cause the
     replacement portion to be treated as a full-fledged Perl expression
     and evaluated right then and there.  It is, however, syntax checked at
     compile-time. A second e modifier will cause the replacement portion
     to be evaled before being run as a Perl expression.

     Examples:

          s/\bgreen\b/mauve/g;		# don't change wintergreen

          $path =~ s|/usr/bin|/usr/local/bin|;

          s/Login: $foo/Login: $bar/; # run-time pattern

          ($foo = $bar) =~ s/this/that/;	# copy first, then change

          $count = ($paragraph =~ s/Mister\b/Mr./g);  # get change-count

          $_ = 'abc123xyz';
          s/\d+/$&*2/e;		# yields 'abc246xyz'
          s/\d+/sprintf("%5d",$&)/e;	# yields 'abc  246xyz'
          s/\w/$& x 2/eg;		# yields 'aabbcc  224466xxyyzz'

          s/%(.)/$percent{$1}/g;	# change percent escapes; no /e
          s/%(.)/$percent{$1} || $&/ge;	# expr now, so /e
          s/^=(\w+)/&pod($1)/ge;	# use function call

          # expand variables in $_, but dynamics only, using
          # symbolic dereferencing
          s/\$(\w+)/${$1}/g;

          # Add one to the value of any numbers in the string
          s/(\d+)/1 + $1/eg;

          # This will expand any embedded scalar variable
          # (including lexicals) in $_ : First $1 is interpolated
          # to the variable name, and then evaluated
          s/(\$\w+)/$1/eeg;

          # Delete (most) C comments.
          $program =~ s {
          	/\*	# Match the opening delimiter.
          	.*?	# Match a minimal number of characters.
          	\*/	# Match the closing delimiter.
          } []gsx;

          s/^\s*(.*?)\s*$/$1/;	# trim white space in $_, expensively

          for ($variable) {		# trim white space in $variable, cheap
          	s/^\s+//;
          	s/\s+$//;
          }

          s/([^ ]*) *([^ ]*)/$2 $1/;	# reverse 1st two fields

     Note the use of $ instead of \ in the last example.  Unlike *sed*, we
     use the \<digit> form in only the left hand side.  Anywhere else it's
     $<digit>.

     Occasionally, you can't use just a `/g' to get all the changes to
     occur that you might want.  Here are two common cases:

          # put commas in the right places in an integer
          1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;

          # expand tabs to 8-column spacing
          1 while s/\t+/' ' x (length($&)*8 - length($`)%8)/e;

tr/SEARCHLIST/REPLACEMENTLIST/cdsUC
y/SEARCHLIST/REPLACEMENTLIST/cdsUC
     Transliterates all occurrences of the characters found in the search
     list with the corresponding character in the replacement list.  It
     returns the number of characters replaced or deleted.  If no string is
     specified via the =~ or !~ operator, the $_ string is transliterated.
     (The string specified with =~ must be a scalar variable, an array
     element, a hash element, or an assignment to one of those, i.e., an
     lvalue.)

     A character range may be specified with a hyphen, so `tr/A-J/0-9/'
     does the same replacement as `tr/ACEGIBDFHJ/0246813579/'.  For *sed*
     devotees, y is provided as a synonym for tr.  If the SEARCHLIST is
     delimited by bracketing quotes, the REPLACEMENTLIST has its own pair
     of quotes, which may or may not be bracketing quotes, e.g.,
     `tr[A-Z][a-z]' or `tr(+\-*/)/ABCD/'.

     Note also that the whole range idea is rather unportable between
     character sets-and even within character sets they may cause results
     you probably didn't expect.  A sound principle is to use only ranges
     that begin from and end at either alphabets of equal case (a-e, A-E),
     or digits (0-4).  Anything else is unsafe.  If in doubt, spell out the
     character sets in full.

     Options:

          c	Complement the SEARCHLIST.
          d	Delete found but unreplaced characters.
          s	Squash duplicate replaced characters.
          U	Translate to/from UTF-8.
          C	Translate to/from 8-bit char (octet).

     If the `/c' modifier is specified, the SEARCHLIST character set is
     complemented.  If the `/d' modifier is specified, any characters
     specified by SEARCHLIST not found in REPLACEMENTLIST are deleted.
     (Note that this is slightly more flexible than the behavior of some
     tr programs, which delete anything they find in the SEARCHLIST,
     period.) If the `/s' modifier is specified, sequences of characters
     that were transliterated to the same character are squashed down to a
     single instance of the character.

     If the `/d' modifier is used, the REPLACEMENTLIST is always
     interpreted exactly as specified.  Otherwise, if the REPLACEMENTLIST
     is shorter than the SEARCHLIST, the final character is replicated
     till it is long enough.  If the REPLACEMENTLIST is empty, the
     SEARCHLIST is replicated.  This latter is useful for counting
     characters in a class or for squashing character sequences in a class.

     The first `/U' or `/C' modifier applies to the left side of the
     translation.  The second one applies to the right side.  If present,
     these modifiers override the current utf8 state.

     Examples:

          $ARGV[1] =~ tr/A-Z/a-z/;	# canonicalize to lower case

          $cnt = tr/*/*/;		# count the stars in $_

          $cnt = $sky =~ tr/*/*/;	# count the stars in $sky

          $cnt = tr/0-9//;		# count the digits in $_

          tr/a-zA-Z//s;		# bookkeeper -> bokeper

          ($HOST = $host) =~ tr/a-z/A-Z/;

          tr/a-zA-Z/ /cs;		# change non-alphas to single space

          tr [\200-\377]
             [\000-\177];		# delete 8th bit

          tr/\0-\xFF//CU;		# change Latin-1 to Unicode
          tr/\0-\x{FF}//UC;		# change Unicode to Latin-1

     If multiple transliterations are given for a character, only the
     first one is used:

          tr/AAA/XYZ/

     will transliterate any A to X.

     Because the transliteration table is built at compile time, neither
     the SEARCHLIST nor the REPLACEMENTLIST are subjected to double quote
     interpolation.  That means that if you want to use variables, you
     must use an eval():

          eval "tr/$oldlist/$newlist/";
          die $@ if $@;

          eval "tr/$oldlist/$newlist/, 1" or die $@;

Gory details of parsing quoted constructs
-----------------------------------------

   When presented with something that might have several different
interpretations, Perl uses the *DWIM* (that's "Do What I Mean") principle
to pick the most probable interpretation.  This strategy is so successful
that Perl programmers often do not suspect the ambivalence of what they
write.  But from time to time, Perl's notions differ substantially from
what the author honestly meant.

   This section hopes to clarify how Perl handles quoted constructs.
Although the most common reason to learn this is to unravel labyrinthine
regular expressions, because the initial steps of parsing are the same for
all quoting operators, they are all discussed together.

   The most important Perl parsing rule is the first one discussed below:
when processing a quoted construct, Perl first finds the end of that
construct, then interprets its contents.  If you understand this rule, you
may skip the rest of this section on the first reading.  The other rules
are likely to contradict the user's expectations much less frequently than
this first one.

   Some passes discussed below are performed concurrently, but because
their results are the same, we consider them individually.  For different
quoting constructs, Perl performs different numbers of passes, from one to
five, but these passes are always performed in the same order.

Finding the end
     The first pass is finding the end of the quoted construct, whether it
     be a multicharacter delimiter `"\nEOF\n"' in the `<<EOF' construct, a
     / that terminates a `qq//' construct, a ] which terminates `qq[]'
     construct, or a `< ' >> which terminates a fileglob started with `< <
     '>.

     When searching for single-character non-pairing delimiters, such as
     /, combinations of \\ and `\/' are skipped.  However, when searching
     for single-character pairing delimiter like [, combinations of \\,
     `\]', and `\[' are all skipped, and nested [, ] are skipped as well.
     When searching for multicharacter delimiters, nothing is skipped.

     For constructs with three-part delimiters (s///, y///, and tr///),
     the search is repeated once more.

     During this search no attention is paid to the semantics of the
     construct.  Thus:

          "$hash{"$foo/$bar"}"

     or:

          m/
            bar	# NOT a comment, this slash / terminated m//!
           /x

     do not form legal quoted expressions.   The quoted part ends on the
     first `"' and /, and the rest happens to be a syntax error.  Because
     the slash that terminated m// was followed by a `SPACE', the example
     above is not `m//x', but rather m// with no `/x' modifier.  So the
     embedded `#' is interpreted as a literal `#'.

Removal of backslashes before delimiters
     During the second pass, text between the starting and ending
     delimiters is copied to a safe location, and the \ is removed from
     combinations consisting of \ and delimiter-or delimiters, meaning
     both starting and ending delimiters will should these differ.  This
     removal does not happen for multi-character delimiters.  Note that
     the combination \\ is left intact, just as it was.

     Starting from this step no information about the delimiters is used
     in parsing.

Interpolation
     The next step is interpolation in the text obtained, which is now
     delimiter-independent.  There are four different cases.

    `<<'EOF'', `m''', `s'''', tr///, y///
          No interpolation is performed.

    ", q//
          The only interpolation is removal of \ from pairs \\.

    "", ```', `qq//', qx//, `< <file*glob' >>
          `\Q', `\U', `\u', `\L', `\l' (possibly paired with `\E') are
          converted to corresponding Perl constructs.  Thus,
          `"$foo\Qbaz$bar"' is converted to `$foo . (quotemeta("baz" .
          $bar))' internally.  The other combinations are replaced with
          appropriate expansions.

          Let it be stressed that *whatever falls between `\Q' and `\E'*
          is interpolated in the usual way.  Something like `"\Q\\E"' has
          no `\E' inside.  instead, it has `\Q', \\, and E, so the result
          is the same as for `"\\\\E"'.  As a general rule, backslashes
          between `\Q' and `\E' may lead to counterintuitive results.  So,
          `"\Q\t\E"' is converted to `quotemeta("\t")', which is the same
          as `"\\\t"' (since TAB is not alphanumeric).  Note also that:

               $str = '\t';
               return "\Q$str";

          may be closer to the conjectural *intention* of the writer of
          `"\Q\t\E"'.

          Interpolated scalars and arrays are converted internally to the
          join and . catentation operations.  Thus, `"$foo XXX '@arr'"'
          becomes:

               $foo . " XXX '" . (join $", @arr) . "'";

          All operations above are performed simultaneously, left to right.

          Because the result of `"\Q STRING \E"' has all metacharacters
          quoted, there is no way to insert a literal `$' or `@' inside a
          `\Q\E' pair.  If protected by \, `$' will be quoted to became
          `"\\\$"'; if not, it is interpreted as the start of an
          interpolated scalar.

          Note also that the interpolation code needs to make a decision on
          where the interpolated scalar ends.  For instance, whether `< "a
          $b -' {c}" >> really means:

               "a " . $b . " -> {c}";

          or:

               "a " . $b -> {c};

          Most of the time, the longest possible text that does not include
          spaces between components and which contains matching braces or
          brackets.  because the outcome may be determined by voting based
          on heuristic estimators, the result is not strictly predictable.
          Fortunately, it's usually correct for ambiguous cases.

    `?RE?', `/RE/', `m/RE/', `s/RE/foo/',
          Processing of `\Q', `\U', `\u', `\L', `\l', and interpolation
          happens (almost) as with `qq//' constructs, but the substitution
          of \ followed by RE-special chars (including \) is not
          performed.  Moreover, inside `(?{BLOCK})', `(?# comment )', and
          a `#'-comment in a `//x'-regular expression, no processing is
          performed whatsoever.  This is the first step at which the
          presence of the `//x' modifier is relevant.

          Interpolation has several quirks: $|, $(, and $) are not
          interpolated, and constructs `$var[SOMETHING]' are voted (by
          several different estimators) to be either an array element or
          `$var' followed by an RE alternative.  This is where the notation
          `${arr[$bar]}' comes handy: `/${arr[0-9]}/' is interpreted as
          array element `-9', not as a regular expression from the variable
          `$arr' followed by a digit, which would be the interpretation of
          `/$arr[0-9]/'.  Since voting among different estimators may
          occur, the result is not predictable.

          It is at this step that \1 is begrudgingly converted to $1 in
          the replacement text of s/// to correct the incorrigible *sed*
          hackers who haven't picked up the saner idiom yet.  A warning is
          emitted if the `use warnings' pragma or the -w command-line flag
          (that is, the $^W variable) was set.

          The lack of processing of \\ creates specific restrictions on
          the post-processed text.  If the delimiter is /, one cannot get
          the combination `\/' into the result of this step.  / will
          finish the regular expression, `\/' will be stripped to / on the
          previous step, and `\\/' will be left as is.  Because / is
          equivalent to `\/' inside a regular expression, this does not
          matter unless the delimiter happens to be character special to
          the RE engine, such as in `s*foo*bar*', `m[foo]', or `?foo?'; or
          an alphanumeric char, as in:

               m m ^ a \s* b mmx;

          In the RE above, which is intentionally obfuscated for
          illustration, the delimiter is m, the modifier is mx, and after
          backslash-removal the RE is the same as for `m/ ^ a s* b /mx').
          There's more than one reason you're encouraged to restrict your
          delimiters to non-alphanumeric, non-whitespace choices.

     This step is the last one for all constructs except regular
     expressions, which are processed further.

Interpolation of regular expressions
     Previous steps were performed during the compilation of Perl code,
     but this one happens at run time-although it may be optimized to be
     calculated at compile time if appropriate.  After preprocessing
     described above, and possibly after evaluation if catenation,
     joining, casing translation, or metaquoting are involved, the
     resulting string is passed to the RE engine for compilation.

     Whatever happens in the RE engine might be better discussed in *Note
     Perlre: perlre,, but for the sake of continuity, we shall do so here.

     This is another step where the presence of the `//x' modifier is
     relevant.  The RE engine scans the string from left to right and
     converts it to a finite automaton.

     Backslashed characters are either replaced with corresponding literal
     strings (as with `\{'), or else they generate special nodes in the
     finite automaton (as with `\b').  Characters special to the RE engine
     (such as |) generate corresponding nodes or groups of nodes.
     `(?#...)' comments are ignored.  All the rest is either converted to
     literal strings to match, or else is ignored (as is whitespace and
     `#'-style comments if `//x' is present).

     Parsing of the bracketed character class construct, `[...]', is
     rather different than the rule used for the rest of the pattern.  The
     terminator of this construct is found using the same rules as for
     finding the terminator of a `{}'-delimited construct, the only
     exception being that ] immediately following [ is treated as though
     preceded by a backslash.  Similarly, the terminator of `(?{...})' is
     found using the same rules as for finding the terminator of a
     `{}'-delimited construct.

     It is possible to inspect both the string given to RE engine and the
     resulting finite automaton.  See the arguments debug/`debugcolor' in
     the `use *Note Re: (pm.info)re,' pragma, as well as Perl's *-Dr*
     command-line switch documented in `"Command Switches"', *Note
     Perlrun: perlrun,.

Optimization of regular expressions
     This step is listed for completeness only.  Since it does not change
     semantics, details of this step are not documented and are subject to
     change without notice.  This step is performed over the finite
     automaton that was generated during the previous pass.

     It is at this stage that `split()' silently optimizes `/^/' to mean
     `/^/m'.

I/O Operators
-------------

   There are several I/O operators you should know about.

   A string enclosed by backticks (grave accents) first undergoes
double-quote interpolation.  It is then interpreted as an external
command, and the output of that command is the value of the
pseudo-literal, j string consisting of all output is returned.  In list
context, a list of values is returned, one per line of output.  (You can
set $/ to use a different line terminator.)  The command is executed each
time the pseudo-literal is evaluated.  The status value of the command is
returned in $? (see *Note Perlvar: perlvar, for the interpretation of $?).
Unlike in *csh*, no translation is done on the return data-newlines
remain newlines.  Unlike in any of the shells, single quotes do not hide
variable names in the command from interpretation.  To pass a literal
dollar-sign through to the shell you need to hide it with a backslash.
The generalized form of backticks is qx//.  (Because backticks always
undergo shell expansion as well, see *Note Perlsec: perlsec, for security
concerns.)

   In scalar context, evaluating a filehandle in angle brackets yields the
next line from that file (the newline, if any, included), or undef at
end-of-file or on error.  When $/ is set to undef (sometimes known as
file-slurp mode) and the file is empty, it returns " the first time,
followed by undef subsequently.

   Ordinarily you must assign the returned value to a variable, but there
is one situation where an automatic assignment happens.  If and only if
the input symbol is the only thing inside the conditional of a while
statement (even if disguised as a `for(;;)' loop), the value is
automatically assigned to the global variable $_, destroying whatever was
there previously.  (This may seem like an odd thing to you, but you'll use
the construct in almost every Perl script you write.)  The $_ variables is
not implicitly localized.  You'll have to put a `local $_;' before the
loop if you want that to happen.

   The following lines are equivalent:

     while (defined($_ = <STDIN>)) { print; }
     while ($_ = <STDIN>) { print; }
     while (<STDIN>) { print; }
     for (;<STDIN>;) { print; }
     print while defined($_ = <STDIN>);
     print while ($_ = <STDIN>);
     print while <STDIN>;

   This also behaves similarly, but avoids $_ :

     while (my $line = <STDIN>) { print $line }

   In these loop constructs, the assigned value (whether assignment is
automatic or explicit) is then tested to see whether it is defined.  The
defined test avoids problems where line has a string value that would be
treated as false by Perl, for example a "" or a "0" with no trailing
newline.  If you really mean for such values to terminate the loop, they
should be tested for explicitly:

     while (($_ = <STDIN>) ne '0') { ... }
     while (<STDIN>) { last unless $_; ... }

   In other boolean contexts, `< <*filehandle*' >> without an explicit
defined test or comparison elicit a warning if the `use warnings' pragma
or the -w command-line switch (the $^W variable) is in effect.

   The filehandles STDIN, STDOUT, and STDERR are predefined.  (The
filehandles stdin, stdout, and stderr will also work except in packages,
where they would be interpreted as local identifiers rather than global.)
Additional filehandles may be created with the open() function, amongst
others.  See *Note Perlopentut: perlopentut, and `open', *Note Perlfunc:
perlfunc, for details on this.

   If a <FILEHANDLE> is used in a context that is looking for a list, a
list comprising all input lines is returned, one line per list element.
It's easy to grow to a rather large data space this way, so use with care.

   <FILEHANDLE> may also be spelled `readline(*FILEHANDLE)'.  See
`readline', *Note Perlfunc: perlfunc,.

   The null filehandle <> is special: it can be used to emulate the
behavior of *sed* and *awk*.  Input from <> comes either from standard
input, or from each file listed on the command line.  Here's how it works:
the first time <> is evaluated, the @ARGV array is checked, and if it is
empty, `$ARGV[0]' is set to "-", which when opened gives you standard
input.  The @ARGV array is then processed as a list of filenames.  The loop

     while (<>) {
     	...			# code for each line
     }

   is equivalent to the following Perl-like pseudo code:

     unshift(@ARGV, '-') unless @ARGV;
     while ($ARGV = shift) {
     	open(ARGV, $ARGV);
     	while (<ARGV>) {
     	    ...		# code for each line
     	}
     }

   except that it isn't so cumbersome to say, and will actually work.  It
really does shift the @ARGV array and put the current filename into the
$ARGV variable.  It also uses filehandle *ARGV* internally-<> is just a
synonym for <ARGV>, which is magical.  (The pseudo code above doesn't work
because it treats <ARGV> as non-magical.)

   You can modify @ARGV before the first <> as long as the array ends up
containing the list of filenames you really want.  Line numbers ($.)
continue as though the input were one big happy file.  See the example in
`eof', *Note Perlfunc: perlfunc, for how to reset line numbers on each
file.

   If you want to set @ARGV to your own list of files, go right ahead.
This sets @ARGV to all plain text files if no @ARGV was given:

     @ARGV = grep { -f && -T } glob('*') unless @ARGV;

   You can even set them to pipe commands.  For example, this automatically
filters compressed arguments through *gzip*:

     @ARGV = map { /\.(gz|Z)$/ ? "gzip -dc < $_ |" : $_ } @ARGV;

   If you want to pass switches into your script, you can use one of the
Getopts modules or put a loop on the front like this:

     while ($_ = $ARGV[0], /^-/) {
     	shift;
         last if /^--$/;
     	if (/^-D(.*)/) { $debug = $1 }
     	if (/^-v/)     { $verbose++  }
     	# ...		# other switches
     }

     while (<>) {
     	# ...		# code for each line
     }

   The <> symbol will return undef for end-of-file only once.  If you call
it again after this, it will assume you are processing another  @ARGV
list, and if you haven't set @ARGV, will read input from STDIN.

   If angle brackets contain is a simple scalar variable (e.g., <$foo>),
then that variable contains the name of the filehandle to input from, or
its typeglob, or a reference to the same.  For example:

     $fh = \*STDIN;
     $line = <$fh>;

   If what's within the angle brackets is neither a filehandle nor a simple
scalar variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a filename pattern to be globbed, and
either a list of filenames or the next filename in the list is returned,
depending on context.  This distinction is determined on syntactic grounds
alone.  That means `< <$x' >> is always a readline() from an indirect
handle, but `< <$hash{key}' >> is always a glob().  That's because $x is a
simple scalar variable, but `$hash{key}' is not-it's a hash element.

   One level of double-quote interpretation is done first, but you can't
say `< <$foo' >> because that's an indirect filehandle as explained in the
previous paragraph.  (In older versions of Perl, programmers would insert
curly brackets to force interpretation as a filename glob: `< <${foo}' >>.
These days, it's considered cleaner to call the internal function
directly as `glob($foo)', which is probably the right way to have done it
in the first place.)  For example:

     while (<*.c>) {
     	chmod 0644, $_;
     }

   is roughly equivalent to:

     open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");
     while (<FOO>) {
     	chop;
     	chmod 0644, $_;
     }

   except that the globbing is actually done internally using the standard
File::Glob extension.  Of course, the shortest way to do the above is:

     chmod 0644, <*.c>;

   A (file)glob evaluates its (embedded) argument only when it is starting
a new list.  All values must be read before it will start over.  In list
context, this isn't important because you automatically get them all
anyway.  However, in scalar context the operator returns the next value
each time it's called, or C run out.  As with filehandle reads, an
automatic defined is generated when the glob occurs in the test part of a
while, because legal glob returns (e.g. a file called 0) would otherwise
terminate the loop.  Again, undef is returned only once.  So if you're
expecting a single value from a glob, it is much better to say

     ($file) = <blurch*>;

   than

     $file = <blurch*>;

   because the latter will alternate between returning a filename and
returning false.

   It you're trying to do variable interpolation, it's definitely better
to use the glob() function, because the older notation can cause people to
become confused with the indirect filehandle notation.

     @files = glob("$dir/*.[ch]");
     @files = glob($files[$i]);

Constant Folding
----------------

   Like C, Perl does a certain amount of expression evaluation at compile
time whenever it determines that all arguments to an operator are static
and have no side effects.  In particular, string concatenation happens at
compile time between literals that don't do variable substitution.
Backslash interpolation also happens at compile time.  You can say

     'Now is the time for all' . "\n" .
     	'good men to come to.'

   and this all reduces to one string internally.  Likewise, if you say

     foreach $file (@filenames) {
     	if (-s $file > 5 + 100 * 2**16) {  }
     }

   the compiler will precompute the number which that expression
represents so that the interpreter won't have to.

Bitwise String Operators
------------------------

   Bitstrings of any size may be manipulated by the bitwise operators (`~
| & ^').

   If the operands to a binary bitwise op are strings of different sizes,
| and ^ ops act as though the shorter operand had additional zero bits on
the right, while the & op acts as though the longer operand were truncated
to the length of the shorter.  The granularity for such extension or
truncation is one or more bytes.

     # ASCII-based examples
     print "j p \n" ^ " a h";        	# prints "JAPH\n"
     print "JA" | "  ph\n";          	# prints "japh\n"
     print "japh\nJunk" & '_____';   	# prints "JAPH\n";
     print 'p N$' ^ " E<H\n";		# prints "Perl\n";

   If you are intending to manipulate bitstrings, be certain that you're
supplying bitstrings: If an operand is a number, that will imply a numeric
bitwise operation.  You may explicitly show which type of operation you
intend by using "" or `0+', as in the examples below.

     $foo =  150  |  105 ;	# yields 255  (0x96 | 0x69 is 0xFF)
     $foo = '150' |  105 ;	# yields 255
     $foo =  150  | '105';	# yields 255
     $foo = '150' | '105';	# yields string '155' (under ASCII)

     $baz = 0+$foo & 0+$bar;	# both ops explicitly numeric
     $biz = "$foo" ^ "$bar";	# both ops explicitly stringy

   See `vec', *Note Perlfunc: perlfunc, for information on how to
manipulate individual bits in a bit vector.

Integer Arithmetic
------------------

   By default, Perl assumes that it must do most of its arithmetic in
floating point.  But by saying

     use integer;

   you may tell the compiler that it's okay to use integer operations (if
it feels like it) from here to the end of the enclosing BLOCK.  An inner
BLOCK may countermand this by saying

     no integer;

   which lasts until the end of that BLOCK.  Note that this doesn't mean
everything is only an integer, merely that Perl may use integer operations
if it is so inclined.  For example, even under `use integer', if you take
the `sqrt(2)', you'll still get `1.4142135623731' or so.

   Used on numbers, the bitwise operators ("&", "|", "^", "~", "<<", and
">>") always produce integral results.  (But see also `Bitwise String
Operators' in this node.)  However, `use integer' still has meaning for
them.  By default, their results are interpreted as unsigned integers, but
if `use integer' is in effect, their results are interpreted as signed
integers.  For example, `~0' usually evaluates to a large integral value.
However, `use integer; ~0' is `-1' on twos-complement machines.

Floating-point Arithmetic
-------------------------

   While `use integer' provides integer-only arithmetic, there is no
analogous mechanism to provide automatic rounding or truncation to a
certain number of decimal places.  For rounding to a certain number of
digits, sprintf() or printf() is usually the easiest route.  See *Note
Perlfaq4: perlfaq4,.

   Floating-point numbers are only approximations to what a mathematician
would call real numbers.  There are infinitely more reals than floats, so
some corners must be cut.  For example:

     printf "%.20g\n", 123456789123456789;
     #        produces 123456789123456784

   Testing for exact equality of floating-point equality or inequality is
not a good idea.  Here's a (relatively expensive) work-around to compare
whether two floating-point numbers are equal to a particular number of
decimal places.  See Knuth, volume II, for a more robust treatment of this
topic.

     sub fp_equal {
     	my ($X, $Y, $POINTS) = @_;
     	my ($tX, $tY);
     	$tX = sprintf("%.${POINTS}g", $X);
     	$tY = sprintf("%.${POINTS}g", $Y);
     	return $tX eq $tY;
     }

   The POSIX module (part of the standard perl distribution) implements
ceil(), floor(), and other mathematical and trigonometric functions.  The
Math::Complex module (part of the standard perl distribution) defines
mathematical functions that work on both the reals and the imaginary
numbers.  Math::Complex not as efficient as POSIX, but POSIX can't work
with complex numbers.

   Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.  In these cases,
it probably pays not to trust whichever system rounding is being used by
Perl, but to instead implement the rounding function you need yourself.

Bigger Numbers
--------------

   The standard Math::BigInt and Math::BigFloat modules provide
variable-precision arithmetic and overloaded operators, although they're
currently pretty slow.  At the cost of some space and considerable speed,
they avoid the normal pitfalls associated with limited-precision
representations.

     use Math::BigInt;
     $x = Math::BigInt->new('123456789123456789');
     print $x * $x;

     # prints +15241578780673678515622620750190521

   The non-standard modules SSLeay::BN and Math::Pari provide equivalent
functionality (and much more) with a substantial performance savings.


