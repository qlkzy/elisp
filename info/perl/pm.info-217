This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: MIME/Field/ConTraEnc,  Next: MIME/Field/ContDisp,  Prev: MIME/Entity,  Up: Module List

a "Content-transfer-encoding" field
***********************************

NAME
====

   MIME::Field::ConTraEnc - a "Content-transfer-encoding" field

DESCRIPTION
===========

   A subclass of Mail::Field.

   *Don't use this class directly... its name may change in the future!*
Instead, ask Mail::Field for new instances based on the field name!

SYNOPSIS
========

     use Mail::Field;
     use MIME::Head;
     
     # Create an instance from some text:
     $field = Mail::Field->new('Content-transfer-encoding', '7bit');
     
     # Get the encoding.
     #    Possible values: 'binary', '7bit', '8bit', 'quoted-printable',
     #    'base64' and '' (unspecified).  Note that there can't be a
     #    single default for this, since it depends on the content type!
     $encoding = $field->encoding;

AUTHOR
======

   Eryq (`eryq@zeegee.com'), ZeeGee Software Inc (`http://www.zeegee.com').


File: pm.info,  Node: MIME/Field/ContDisp,  Next: MIME/Field/ContType,  Prev: MIME/Field/ConTraEnc,  Up: Module List

a "Content-disposition" field
*****************************

NAME
====

   MIME::Field::ContDisp - a "Content-disposition" field

DESCRIPTION
===========

   A subclass of Mail::Field.

   *Don't use this class directly... its name may change in the future!*
Instead, ask Mail::Field for new instances based on the field name!

SYNOPSIS
========

     use Mail::Field;
     use MIME::Head;
     
     # Create an instance from some text:
     $field = Mail::Field->new('Content-disposition', $text);
     
     # Inline or attachment?
     $type = $field->type;
     
     # Recommended filename?
     $filename = $field->filename;

AUTHOR
======

   Eryq (`eryq@zeegee.com'), ZeeGee Software Inc (`http://www.zeegee.com').


File: pm.info,  Node: MIME/Field/ContType,  Next: MIME/Field/ParamVal,  Prev: MIME/Field/ContDisp,  Up: Module List

a "Content-type" field
**********************

NAME
====

   MIME::Field::ContType - a "Content-type" field

DESCRIPTION
===========

   A subclass of Mail::Field.

   *Don't use this class directly... its name may change in the future!*
Instead, ask Mail::Field for new instances based on the field name!

SYNOPSIS
========

     use Mail::Field;
     use MIME::Head;
     
     # Create an instance from some text:
     $field = Mail::Field->new('Content-type',
                               'text/HTML; charset="US-ASCII"');
     
     # Get the MIME type, like 'text/plain' or 'x-foobar'.
     # Returns 'text/plain' as default, as per RFC-1521:
     my ($type, $subtype) = split('/', $field->type);

     # Get generic information:
     print $field->name;
     
     # Get information related to "message" type:
     if ($type eq 'message') {
     	print $field->id;
     	print $field->number;
     	print $field->total;
     }
     
     # Get information related to "multipart" type:
     if ($type eq 'multipart') {
     	print $field->boundary;            # the basic value, fixed up
     	print $field->multipart_boundary;  # empty if not a multipart message!
     }
     
     # Get information related to "text" type:
     if ($type eq 'text') {
     	print $field->charset;      # returns 'us-ascii' as default
     }

PUBLIC INTERFACE
================

boundary
     Return the boundary field.  The boundary is returned exactly as given
     in the `Content-type:' field; that is, the leading double-hyphen (-)
     is not prepended.

     (Well, *almost* exactly... from RFC-1521:

          (If a boundary appears to end with white space, the white space
          must be presumed to have been added by a gateway, and must be deleted.)

     so we oblige and remove any trailing spaces.)

     Returns the empty string if there is no boundary, or if the boundary
     is illegal (e.g., if it is empty after all trailing whitespace has
     been removed).

multipart_boundary
     Like `boundary()', except that this will also return the empty string
     if the message is not a multipart message.  In other words, there's
     an automatic sanity check.

type
     Try real hard to determine the content type (e.g., `"text/plain"',
     `"image/gif"', `"x-weird-type"', which is returned in all-lowercase.

     A happy thing: the following code will work just as you would want,
     even if there's no subtype (as in `"x-weird-type"')... in such a case,
     the $subtype would simply be the empty string:

          ($type, $subtype) = split('/', $head->mime_type);

     If the content-type information is missing, it defaults to
     `"text/plain"', as per RFC-1521:

          Default RFC-822 messages are typed by this protocol as plain text in
          the US-ASCII character set, which can be explicitly specified as
          "Content-type: text/plain; charset=us-ascii".  If no Content-Type is
          specified, this default is assumed.

     Note: under the "be liberal in what we accept" principle, this routine
     no longer syntax-checks the content type.  If it ain't empty, just
     downcase and return it.

NOTES
=====

   Since nearly all (if not all) parameters must have non-empty values to
be considered valid, we just return the empty string to signify missing
fields.  If you need to get the real underlying value, use the inherited
param() method (which returns undef if the parameter is missing).

AUTHOR
======

   Eryq (`eryq@zeegee.com'), ZeeGee Software Inc (`http://www.zeegee.com').


File: pm.info,  Node: MIME/Field/ParamVal,  Next: MIME/Head,  Prev: MIME/Field/ContType,  Up: Module List

subclass of Mail::Field, for structured MIME fields
***************************************************

NAME
====

   MIME::Field::ParamVal - subclass of Mail::Field, for structured MIME
fields

SYNOPSIS
========

     # Create an object for a content-type field:
     $field = new Mail::Field 'Content-type';
     
     # Set some attributes:
     $field->param('_'        => 'text/html');
     $field->param('charset'  => 'us-ascii');
     $field->param('boundary' => '---ABC---');
     
     # Same:
     $field->set('_'        => 'text/html',
     		'charset'  => 'us-ascii',
     		'boundary' => '---ABC---');
     
     # Get an attribute, or undefined if not present:
     print "no id!"  if defined($field->param('id'));
     
     # Same, but use empty string for missing values:
     print "no id!"  if ($field->paramstr('id') eq '');
     
     # Output as string:
     print $field->stringify, "\n";

DESCRIPTION
===========

   This is an abstract superclass of most MIME fields.  It handles fields
with a general syntax like this:

     Content-Type: Message/Partial;
         number=2; total=3;
         id="oc=jpbe0M2Yt4s@thumper.bellcore.com"

   Comments are supported *between* items, like this:

     Content-Type: Message/Partial; (a comment)
         number=2  (another comment) ; (yet another comment) total=3;
         id="oc=jpbe0M2Yt4s@thumper.bellcore.com"

PUBLIC INTERFACE
================

set [\%PARAMHASH | KEY=>VAL,...,KEY=>VAL]
     *Instance method.*  Set this field.  The paramhash should contain
     parameter names in *all lowercase*, with the special `"_"' parameter
     name signifying the "default" (unnamed) parameter for the field:

          # Set up to be...
          #
          #     Content-type: Message/Partial; number=2; total=3; id="ocj=pbe0M2"
          #
          $conttype->set('_'       => 'Message/Partial',
          		  'number'  => 2,
          		  'total'   => 3,
          		  'id'      => "ocj=pbe0M2");

     Note that a single argument is taken to be a reference to a
     paramhash, while multiple args are taken to be the elements of the
     paramhash themselves.

     Supplying undef for a hashref, or an empty set of values, effectively
     clears the object.

     The self object is returned.

parse_params STRING
     *Class/instance utility method.* Extract parameter info from a
     structured field, and return it as a hash reference.  For example,
     here is a field with parameters:

          Content-Type: Message/Partial;
              number=2; total=3;
              id="oc=jpbe0M2Yt4s@thumper.bellcore.com"

     Here is how you'd extract them:

          $params = $class->parse_params('content-type');
          if ($$params{'_'} eq 'message/partial') {
              $number = $$params{'number'};
              $total  = $$params{'total'};
              $id     = $$params{'id'};
          }

     Like field names, parameter names are coerced to lowercase.  The
     special '_' parameter means the default parameter for the field.

     NOTE: This has been provided as a public method to support backwards
     compatibility, but you probably shouldn't use it.

parse STRING
     *Class/instance method.* Parse the string into the instance.  Any
     previous information is wiped.  The self object is returned.

     May also be used as a constructor.

param PARAMNAME,[VALUE]
     *Instance method.* Return the given parameter, or undef if it isn't
     there.  With argument, set the parameter to that VALUE.  The
     PARAMNAME is case-insensitive.  A "_" refers to the "default"
     parameter.

paramstr PARAMNAME,[VALUE]
     *Instance method.* Like param(): return the given parameter, or empty
     if it isn't there.  With argument, set the parameter to that VALUE.
     The PARAMNAME is case-insensitive.  A "_" refers to the "default"
     parameter.

stringify
     *Instance method.* Convert the field to a string, and return it.

tag
     *Instance method, abstract.* Return the tag for this field.


File: pm.info,  Node: MIME/Head,  Next: MIME/Lite,  Prev: MIME/Field/ParamVal,  Up: Module List

MIME message header (a subclass of Mail::Header)
************************************************

NAME
====

   MIME::Head - MIME message header (a subclass of Mail::Header)

SYNOPSIS
========

   Before reading further, you should see *Note MIME/Tools: MIME/Tools, to
make sure that you understand where this module fits into the grand scheme
of things.  Go on, do it now.  I'll wait.

   Ready?  Ok...

Construction
------------

     ### Create a new, empty header, and populate it manually:
     $head = MIME::Head->new;
     $head->replace('content-type', 'text/plain; charset=US-ASCII');
     $head->replace('content-length', $len);
     
     ### Parse a new header from a filehandle:
     $head = MIME::Head->read(\*STDIN);
     
     ### Parse a new header from a file, or a readable pipe:
     $testhead = MIME::Head->from_file("/tmp/test.hdr");
     $a_b_head = MIME::Head->from_file("cat a.hdr b.hdr |");

Output
------

     ### Output to filehandle:
     $head->print(\*STDOUT);
     
     ### Output as string:
     print STDOUT $head->as_string;
     print STDOUT $head->stringify;

Getting field contents
----------------------

     ### Is this a reply?
     $is_reply = 1 if ($head->get('Subject') =~ /^Re: /);
     
     ### Get receipt information:
     print "Last received from: ", $head->get('Received', 0), "\n";
     @all_received = $head->get('Received');
     
     ### Print the subject, or the empty string if none:
     print "Subject: ", $head->get('Subject',0), "\n";
     
     ### Too many hops?  Count 'em and see!
     if ($head->count('Received') > 5) { ...
     
     ### Test whether a given field exists
     warn "missing subject!" if (! $head->count('subject'));

Setting field contents
----------------------

     ### Declare this to be an HTML header:
     $head->replace('Content-type', 'text/html');

Manipulating field contents
---------------------------

     ### Get rid of internal newlines in fields:
     $head->unfold;
     
     ### Decode any Q- or B-encoded-text in fields (DEPRECATED):
     $head->decode;

Getting high-level MIME information
-----------------------------------

     ### Get/set a given MIME attribute:
     unless ($charset = $head->mime_attr('content-type.charset')) {
         $head->mime_attr("content-type.charset" => "US-ASCII");
     }

     ### The content type (e.g., "text/html"):
     $mime_type     = $head->mime_type;
     
     ### The content transfer encoding (e.g., "quoted-printable"):
     $mime_encoding = $head->mime_encoding;
     
     ### The recommended name when extracted:
     $file_name     = $head->recommended_filename;
     
     ### The boundary text, for multipart messages:
     $boundary      = $head->multipart_boundary;

DESCRIPTION
===========

   A class for parsing in and manipulating RFC-822 message headers, with
some methods geared towards standard (and not so standard) MIME fields as
specified in RFC-1521, *Multipurpose Internet Mail Extensions*.

PUBLIC INTERFACE
================

Creation, input, and output
---------------------------

new [ARG],[OPTIONS]
     *Class method, inherited.* Creates a new header object.  Arguments
     are the same as those in the superclass.

from_file EXPR,OPTIONS
     *Class or instance method*.  For convenience, you can use this to
     parse a header object in from EXPR, which may actually be any
     expression that can be sent to open() so as to return a readable
     filehandle.  The "file" will be opened, read, and then closed:

          ### Create a new header by parsing in a file:
          my $head = MIME::Head->from_file("/tmp/test.hdr");

     Since this method can function as either a class constructor or an
     instance initializer, the above is exactly equivalent to:

          ### Create a new header by parsing in a file:
          my $head = MIME::Head->new->from_file("/tmp/test.hdr");

     On success, the object will be returned; on failure, the undefined
     value.

     The OPTIONS are the same as in new(), and are passed into new() if
     this is invoked as a class method.

     Note: This is really just a convenience front-end onto read(),
     provided mostly for backwards-compatibility with MIME-parser 1.0.

read FILEHANDLE
     *Instance (or class) method.* This initiallizes a header object by
     reading it in from a FILEHANDLE, until the terminating blank line is
     encountered.  A syntax error or end-of-stream will also halt
     processing.

     Supply this routine with a reference to a filehandle glob; e.g.,
     `\*STDIN':

          ### Create a new header by parsing in STDIN:
          $head->read(\*STDIN);

     On success, the self object will be returned; on failure, a false
     value.

     Note: in the MIME world, it is perfectly legal for a header to be
     empty, consisting of nothing but the terminating blank line.  Thus,
     we can't just use the formula that "no tags equals error".

     Warning: as of the time of this writing, Mail::Header::read did not
     flag either syntax errors or unexpected end-of-file conditions (an EOF
     before the terminating blank line).  MIME::ParserBase takes this into
     account.

Getting/setting fields
----------------------

   The following are methods related to retrieving and modifying the header
fields.  Some are inherited from Mail::Header, but I've kept the
documentation around for convenience.

add TAG,TEXT,[INDEX]
     *Instance method, inherited.* Add a new occurence of the field named
     TAG, given by TEXT:

          ### Add the trace information:
          $head->add('Received',
                     'from eryq.pr.mcs.net by gonzo.net with smtp');

     Normally, the new occurence will be *appended* to the existing
     occurences.  However, if the optional INDEX argument is 0, then the
     new occurence will be *prepended*.  If you want to be explicit about
     appending, specify an INDEX of -1.

     Warning: this method always adds new occurences; it doesn't overwrite
     any existing occurences... so if you just want to change the value of
     a field (creating it if necessary), then you probably *don't* want to
     use this method: consider using replace() instead.

count TAG
     *Instance method, inherited.* Returns the number of occurences of a
     field; in a boolean context, this tells you whether a given field
     exists:

          ### Was a "Subject:" field given?
          $subject_was_given = $head->count('subject');

     The TAG is treated in a case-insensitive manner.  This method returns
     some false value if the field doesn't exist, and some true value if
     it does.

decode [FORCE]
     *Instance method, DEPRECATED.* Go through all the header fields,
     looking for RFC-1522-style "Q" (quoted-printable, sort of) or "B"
     (base64) encoding, and decode them in-place.  Fellow Americans, you
     probably don't know what the hell I'm talking about.  Europeans,
     Russians, et al, you probably do.  `:-)'.

     *This method has been deprecated.* See `decode_headers', *Note
     MIME/Parser: MIME/Parser, for the full reasons.  If you absolutely
     must use it and don't like the warning, then provide a FORCE:

          "I_NEED_TO_FIX_THIS"
                 Just shut up and do it.  Not recommended.
                 Provided only for those who need to keep old scripts functioning.

          "I_KNOW_WHAT_I_AM_DOING"
                 Just shut up and do it.  Not recommended.
                 Provided for those who REALLY know what they are doing.

     *What this method does.* For an example, let's consider a valid email
     header you might get:

          From: =?US-ASCII?Q?Keith_Moore?= <moore@cs.utk.edu>
          To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= <keld@dkuug.dk>
          CC: =?ISO-8859-1?Q?Andr=E9_?= Pirard <PIRARD@vm1.ulg.ac.be>
          Subject: =?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
           =?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?=
           =?US-ASCII?Q?.._cool!?=

     That basically decodes to (sorry, I can only approximate the Latin
     characters with 7 bit sequences /o and 'e):

          From: Keith Moore <moore@cs.utk.edu>
          To: Keld J/orn Simonsen <keld@dkuug.dk>
          CC: Andr'e  Pirard <PIRARD@vm1.ulg.ac.be>
          Subject: If you can read this you understand the example... cool!

     Note: currently, the decodings are done without regard to the
     character set: thus, the Q-encoding `=F8' is simply translated to the
     octet (hexadecimal `F8'), period.  For piece-by-piece decoding of a
     given field, you want the array context of
     `MIME::Word::decode_mimewords()'.

     Warning: the CRLF+SPACE separator that splits up long encoded words
     into shorter sequences (see the Subject: example above) gets lost
     when the field is unfolded, and so decoding after unfolding causes a
     spurious space to be left in the field.  *THEREFORE: if you're going
     to decode, do so BEFORE unfolding!*

     This method returns the self object.

     *Thanks to Kent Boortz for providing the idea, and the baseline
     RFC-1522-decoding code.*

delete TAG,[INDEX]
     *Instance method, inherited.* Delete all occurences of the field
     named TAG.

          ### Remove some MIME information:
          $head->delete('MIME-Version');
          $head->delete('Content-type');

get TAG,[INDEX]
     *Instance method, inherited.* Get the contents of field TAG.

     If a *numeric INDEX* is given, returns the occurence at that index,
     or undef if not present:

          ### Print the first and last 'Received:' entries (explicitly):
          print "First, or most recent: ", $head->get('received', 0), "\n";
          print "Last, or least recent: ", $head->get('received',-1), "\n";

     If *no INDEX* is given, but invoked in a scalar context, then INDEX
     simply defaults to 0:

          ### Get the first 'Received:' entry (implicitly):
          my $most_recent = $head->get('received');

     If *no INDEX* is given, and invoked in an array context, then all
     occurences of the field are returned:

          ### Get all 'Received:' entries:
          my @all_received = $head->get('received');

get_all FIELD
     *Instance method.* Returns the list of all occurences of the field,
     or the empty list if the field is not present:

          ### How did it get here?
          @history = $head->get_all('Received');

     Note: I had originally experimented with having get() return all
     occurences when invoked in an array context... but that causes a lot
     of accidents when you get careless and do stuff like this:

          print "\u$field: ", $head->get($field), "\n";

     It also made the intuitive behaviour unclear if the INDEX argument
     was given in an array context.  So I opted for an explicit approach
     to asking for all occurences.

print [OUTSTREAM]
     *Instance method, override.* Print the header out to the given
     OUTSTREAM, or the currently-selected filehandle if none.  The
     OUTSTREAM may be a filehandle, or any object that responds to a
     print() message.

     The override actually lets you print to any object that responds to a
     print() method.  This is vital for outputting MIME entities to
     scalars.

     Also, it defaults to the *currently-selected* filehandle if none is
     given (not STDOUT!), so *please* supply a filehandle to prevent
     confusion.

stringify
     *Instance method.* Return the header as a string.  You can also
     invoke it as as_string.

unfold [FIELD]
     *Instance method, inherited.* Unfold (remove newlines in) the text of
     all occurences of the given FIELD.  If the FIELD is omitted, all
     fields are unfolded.  Returns the "self" object.

MIME-specific methods
---------------------

   All of the following methods extract information from the following
fields:

     Content-type
     Content-transfer-encoding
     Content-disposition

   Be aware that they do not just return the raw contents of those fields,
and in some cases they will fill in sensible (I hope) default values.  Use
get() or `mime_attr()' if you need to grab and process the raw field text.

   Note: some of these methods are provided both as a convenience and for
backwards-compatibility only, while others (like recommended_filename())
*really do have to be in MIME::Head to work properly,* since they look for
their value in more than one field.  However, if you know that a value is
restricted to a single field, you should really use the Mail::Field
interface to get it.

mime_attr ATTR,[VALUE]
     A quick-and-easy interface to set/get the attributes in structured
     MIME fields:

          $head->mime_attr("content-type"         => "text/html");
          $head->mime_attr("content-type.charset" => "US-ASCII");
          $head->mime_attr("content-type.name"    => "homepage.html");

     This would cause the final output to look something like this:

          Content-type: text/html; charset=US-ASCII; name="homepage.html"

     Note that the special empty sub-field tag indicates the anonymous
     first sub-field.

     *Giving VALUE as undefined* will cause the contents of the named
     subfield to be deleted:

          $head->mime_attr("content-type.charset" => undef);

     *Supplying no VALUE argument* just returns the attribute's value, or
     undefined if it isn't there:

          $type = $head->mime_attr("content-type");      ### text/html
          $name = $head->mime_attr("content-type.name"); ### homepage.html

     In all cases, the new/current value is returned.

mime_encoding
     *Instance method.* Try *real hard* to determine the content transfer
     encoding (e.g., `"base64"', `"binary"'), which is returned in
     all-lowercase.

     If no encoding could be found, the default of `"7bit"' is returned.
     I quote from RFC-1521 section 5:

          This is the default value -- that is, "Content-Transfer-Encoding: 7BIT"
          is assumed if the Content-Transfer-Encoding header field is not present.

mime_type [DEFAULT]
     *Instance method.* Try `real hard' to determine the content type
     (e.g., `"text/plain"', `"image/gif"', `"x-weird-type"', which is
     returned in all-lowercase.  "Real hard" means that if no content type
     could be found, the default (usually `"text/plain"') is returned.
     From RFC-1521 section 7.1:

          The default Content-Type for Internet mail is
          "text/plain; charset=us-ascii".

     Unless this is a part of a "multipart/digest", in which case
     "message/rfc822" is the default.  Note that you can also set the
     default, but you shouldn't: normally only the MIME parser uses this
     feature.

multipart_boundary
     *Instance method.* If this is a header for a multipart message,
     return the "encapsulation boundary" used to separate the parts.  The
     boundary is returned exactly as given in the `Content-type:' field;
     that is, the leading double-hyphen (-) is not prepended.

     Well, *almost* exactly... this passage from RFC-1521 dictates that we
     remove any trailing spaces:

          If a boundary appears to end with white space, the white space
          must be presumed to have been added by a gateway, and must be deleted.

     Returns undef (not the empty string) if either the message is not
     multipart, if there is no specified boundary, or if the boundary is
     illegal (e.g., if it is empty after all trailing whitespace has been
     removed).

recommended_filename
     *Instance method.* Return the recommended external filename.  This is
     used when extracting the data from the MIME stream.

     Returns undef if no filename could be suggested.

NOTES
=====

Why have separate objects for the entity, head, and body?
     See the documentation for the MIME-tools distribution for the
     rationale behind this decision.

Why assume that MIME headers are email headers?
     I quote from Achim Bohnet, who gave feedback on v.1.9 (I think he's
     using the word "header" where I would use "field"; e.g., to refer to
     "Subject:", "Content-type:", etc.):

          There is also IMHO no requirement [for] MIME::Heads to look
          like [email] headers; so to speak, the MIME::Head [simply stores]
          the attributes of a complex object, e.g.:

          new MIME::Head type => "text/plain",
                         charset => ...,
                         disposition => ..., ... ;

     I agree in principle, but (alas and dammit) RFC-1521 says otherwise.
     RFC-1521 [MIME] headers are a syntactic subset of RFC-822 [email]
     headers.  Perhaps a better name for these modules would be RFC1521::
     instead of MIME::, but we're a little beyond that stage now.

     In my mind's eye, I see an abstract class, call it MIME::Attrs, which
     does what Achim suggests... so you could say:

          my $attrs = new MIME::Attrs type => "text/plain",
          				 charset => ...,
                                      disposition => ..., ... ;

     We could even make it a superclass of MIME::Head: that way, MIME::Head
     would have to implement its interface, and allow itself to be
     initiallized from a MIME::Attrs object.

     However, when you read RFC-1521, you begin to see how much MIME
     information is organized by its presence in particular fields.  I
     imagine that we'd begin to mirror the structure of RFC-1521 fields
     and subfields to such a degree that this might not give us a
     tremendous gain over just having MIME::Head.

Why all this "occurence" and "index" jazz?  Isn't every field unique?
     Aaaaaaaaaahh....no.

     Looking at a typical mail message header, it is sooooooo tempting to
     just store the fields as a hash of strings, one string per hash entry.
     Unfortunately, there's the little matter of the `Received:' field,
     which (unlike `From:', `To:', etc.) will often have multiple
     occurences; e.g.:

          Received: from gsfc.nasa.gov by eryq.pr.mcs.net  with smtp
              (Linux Smail3.1.28.1 #5) id m0tStZ7-0007X4C;
          	 Thu, 21 Dec 95 16:34 CST
          Received: from rhine.gsfc.nasa.gov by gsfc.nasa.gov
          	 (5.65/Ultrix3.0-C) id AA13596;
          	 Thu, 21 Dec 95 17:20:38 -0500
          Received: (from eryq@localhost) by rhine.gsfc.nasa.gov
          	 (8.6.12/8.6.12) id RAA28069;
          	 Thu, 21 Dec 1995 17:27:54 -0500
          Date: Thu, 21 Dec 1995 17:27:54 -0500
          From: Eryq <eryq@rhine.gsfc.nasa.gov>
          Message-Id: <199512212227.RAA28069@rhine.gsfc.nasa.gov>
          To: eryq@eryq.pr.mcs.net
          Subject: Stuff and things

     The `Received:' field is used for tracing message routes, and although
     it's not generally used for anything other than human debugging, I
     didn't want to inconvenience anyone who actually wanted to get at that
     information.

     I also didn't want to make this a special case; after all, who knows
     what other fields could have multiple occurences in the future?  So,
     clearly, multiple entries had to somehow be stored multiple times...
     and the different occurences had to be retrievable.

AUTHOR
======

   Eryq (`eryq@zeegee.com'), ZeeGee Software Inc (`http://www.zeegee.com').

   All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

   The more-comprehensive filename extraction is courtesy of Lee E.
Brotzman, Advanced Data Solutions.

VERSION
=======

   $Revision: 5.403 $ $Date: 2000/11/04 19:54:46 $


File: pm.info,  Node: MIME/Lite,  Next: MIME/Lite/HTML,  Prev: MIME/Head,  Up: Module List

low-calorie MIME generator
**************************

NAME
====

   MIME::Lite - low-calorie MIME generator

SYNOPSIS
========

     use MIME::Lite;
     
     Create a single-part message:

     ### Create a new single-part message, to send a GIF file:
     $msg = MIME::Lite->new(
                  From     =>'me@myhost.com',
                  To       =>'you@yourhost.com',
                  Cc       =>'some@other.com, some@more.com',
                  Subject  =>'Helloooooo, nurse!',
                  Type     =>'image/gif',
                  Encoding =>'base64',
                  Path     =>'hellonurse.gif'
     		 );

   Create a multipart message (i.e., one with attachments):

     ### Create a new multipart message:
     $msg = MIME::Lite->new(
                  From    =>'me@myhost.com',
                  To      =>'you@yourhost.com',
                  Cc      =>'some@other.com, some@more.com',
                  Subject =>'A message with 2 parts...',
                  Type    =>'multipart/mixed'
     		 );
     
     ### Add parts (each "attach" has same arguments as "new"):
     $msg->attach(Type     =>'TEXT',
                  Data     =>"Here's the GIF file you wanted"
     		 );
     $msg->attach(Type     =>'image/gif',
                  Path     =>'aaa000123.gif',
                  Filename =>'logo.gif'
     		 );

   Output a message:

     ### Format as a string:
     $str = $msg->as_string;
     
     ### Print to a filehandle (say, a "sendmail" stream):
     $msg->print(\*SENDMAIL);

   Send a message:

     ### Send in the "best" way (the default is to use "sendmail"):
     $msg->send;

DESCRIPTION
===========

   In the never-ending quest for great taste with fewer calories, we
proudly present: *MIME::Lite*.

   MIME::Lite is intended as a simple, standalone module for generating
(not parsing!) MIME messages... specifically, it allows you to output a
simple, decent single- or multi-part message with text or binary
attachments.  It does not require that you have the Mail:: or MIME::
modules installed.

   You can specify each message part as either the literal data itself (in
a scalar or array), or as a string which can be given to open() to get a
readable filehandle (e.g., "<filename" or "somecommand|").

   You don't need to worry about encoding your message data: this module
will do that for you.  It handles the 5 standard MIME encodings.

   If you need more sophisticated behavior, please get the MIME-tools
package instead.  I will be more likely to add stuff to that toolkit over
this one.

MORE EXAMPLES
=============

Attach a GIF to a text message
------------------------------

   This will create a multipart message exactly as above, but using the
"attach to singlepart" hack:

     ### Create a new multipart message:
     $msg = MIME::Lite->new(
                  From    =>'me@myhost.com',
                  To      =>'you@yourhost.com',
                  Cc      =>'some@other.com, some@more.com',
                  Subject =>'A message with 2 parts...',
                  Type    =>'TEXT',
                  Data    =>"Here's the GIF file you wanted"
                  );
     
     ### Attach a part:
     $msg->attach(Type     =>'image/gif',
                  Path     =>'aaa000123.gif',
                  Filename =>'logo.gif'
                  );

Send an HTML document... with images included!
----------------------------------------------

     $msg = MIME::Lite->new(
                  To      =>'you@yourhost.com',
                  Subject =>'HTML with in-line images!',
                  Type    =>'multipart/related'
                  );
     $msg->attach(Type => 'text/html',
                  Data => qq{ <body>
                              Here's <i>my</i> image:
                              <img src="cid:myimage.gif">
                              </body> }
                  );
     $msg->attach(Type => 'image/gif',
                  Id   => 'myimage.gif',
                  Path => '/path/to/somefile.gif',
                  );
     $msg->send();

Output a message to a filehandle
--------------------------------

     ### Write it to a filehandle:
     $msg->print(\*STDOUT);
     
     ### Write just the header:
     $msg->print_header(\*STDOUT);
     
     ### Write just the encoded body:
     $msg->print_body(\*STDOUT);

Get a message as a string
-------------------------

     ### Get entire message as a string:
     $str = $msg->as_string;
     
     ### Get just the header:
     $str = $msg->header_as_string;
     
     ### Get just the encoded body:
     $str = $msg->body_as_string;

Change how messages are sent
----------------------------

     ### Do something like this in your 'main':
     if ($I_DONT_HAVE_SENDMAIL) {
        MIME::Lite->send('smtp', "smtp.myisp.net", Timeout=>60);
     }
     
     ### Now this will do the right thing:
     $msg->send;         ### will now use Net::SMTP as shown above

FAQ
===

How do I prevent "Content" headers from showing up in my mail reader?
---------------------------------------------------------------------

   Apparently, some people are using mail readers which display the MIME
headers like "Content-disposition", and they want MIME::Lite not to
generate them "because they look ugly".

   Sigh.

   Y'know, kids, those headers aren't just there for cosmetic purposes.
They help ensure that the message is *understood* correctly by mail
readers.  But okay, you asked for it, you got it...  here's how you can
suppress the standard MIME headers.  Before you send the message, do this:

     $msg->scrub;

   You can scrub() any part of a multipart message independently; just be
aware that it works recursively.  Before you scrub, note the rules that I
follow:

Content-type
     You can safely scrub the "content-type" attribute if, and only if,
     the part is of type "text/plain" with charset "us-ascii".

Content-transfer-encoding
     You can safely scrub the "content-transfer-encoding" attribute if,
     and only if, the part uses "7bit", "8bit", or "binary" encoding.  You
     are far better off doing this if your lines are under 1000
     characters.  Generally, that means you can scrub it for plain text,
     and you can not scrub this for images, etc.

Content-disposition
     You can safely scrub the "content-disposition" attribute if you trust
     the mail reader to do the right thing when it decides whether to show
     an attachment inline or as a link.  Be aware that scrubbing both the
     content-disposition and the content-type means that there is no way
     to "recommend" a filename for the attachment!

     Note: there are reports of brain-dead MUAs out there that do the
     wrong thing if you *provide* the content-disposition.  If your
     attachments keep showing up inline or vice-versa, try scrubbing this
     attribute.

Content-length
     You can always scrub "content-length" safely.

How do I give my attachment a [different] recommended filename?
---------------------------------------------------------------

   By using the Filename option (which is different from Path!):

     $msg->attach(Type => "image/gif",
                  Path => "/here/is/the/real/file.GIF",
                  Filename => "logo.gif");

   You should not put path information in the Filename.

PUBLIC INTERFACE
================

Global configuration
--------------------

   To alter the way the entire module behaves, you have the following
methods/options:

MIME::Lite->quiet()
     This `classmethod|' in this node can be used to suppress/unsuppress
     all warnings coming from this module.

MIME::Lite->send()
     When used as a `classmethod|' in this node, this can be used to
     specify a different default mechanism for sending message.  The
     initial default is:

          MIME::Lite->send("sendmail", "/usr/lib/sendmail -t -oi -oem");

     However, you should consider the similar but smarter and taint-safe
     variant:

          MIME::Lite->send("sendmail");

     Or, for non-Unix users:

          MIME::Lite->send("smtp");

$MIME::Lite::PARANOID
     If true, we won't attempt to use MIME::Base64/MIME::QuotedPrint, even
     if they're available.  Default is false.

$MIME::Lite::AUTO_ENCODE
     If true, automatically choose the encoding from the content type.
     Default is *true*.

$MIME::Lite::AUTO_CC
     If true, automatically send to the Cc/Bcc addresses for
     send_by_smtp().  Default is *true*.

$MIME::Lite::AUTO_VERIFY
     If true, check paths to attachments right before printing, raising an
     exception if any path is unreadable.  Default is *true*.

Construction
------------

new [PARAMHASH]
     *Class method, constructor.* Create a new message object.

     If any arguments are given, they are passed into `build()'; otherwise,
     just the empty object is created.

attach [OBJECT|PARAMHASH]
     *Instance method.* Add a new part to this message, and return the new
     part.

     You can attach a MIME::Lite OBJECT, or have it create one by
     specifying a PARAMHASH that will be automatically given to new().

     One of the possibly-quite-useful hacks thrown into this is the
     "attach-to-singlepart" hack: if you attempt to attach a part (let's
     call it "part 1") to a message that doesn't have a content-type of
     "multipart" or "message", the following happens:

        * A new part (call it "part 0") is made.

        * The MIME attributes and data (but not the other headers) are cut
          from the "self" message, and pasted into "part 0".

        * The "self" is turned into a "multipart/mixed" message.

        * The new "part 0" is added to the "self", and *then* "part 1" is
          added.

     One of the nice side-effects is that you can create a text message
     and then add zero or more attachments to it, much in the same way
     that a user agent like Netscape allows you to do.

build [PARAMHASH]
     *Class/instance method, initializer.* Create (or initialize) a MIME
     message object.  Normally, you'll use the following keys in PARAMHASH:

          * Data, FH, or Path      (either one of these, or none if multipart)
          * Type                   (e.g., "image/jpeg")
          * From, To, and Subject  (if this is the "top level" of a message)

     The PARAMHASH can contain the following keys:

    (fieldname)
          Any field you want placed in the message header, taken from the
          standard list of header fields (you don't need to worry about
          case):

               Bcc           Encrypted     Received      Sender
               Cc            From          References    Subject
               Comments	  Keywords      Reply-To      To
               Content-*	  Message-ID    Resent-*      X-*
               Date          MIME-Version  Return-Path
                             Organization

          To give experienced users some veto power, these fields will be
          set after the ones I set... so be careful: *don't set any MIME
          fields* (like `Content-type') unless you know what you're doing!

          To specify a fieldname that's not in the above list, even one
          that's identical to an option below, just give it with a
          trailing `":"', like `"My-field:"'.  When in doubt, that always
          signals a mail field (and it sort of looks like one too).

    Data
          *Alternative to "Path" or "FH".* The actual message data.  This
          may be a scalar or a ref to an array of strings; if the latter,
          the message consists of a simple concatenation of all the
          strings in the array.

    Datestamp
          *Optional.* If given true (or omitted), we force the creation of
          a `Date:' field stamped with the current date/time if this is a
          top-level message.  You may want this if using `send_by_smtp()|'
          in this node.  If you don't want this to be done, either provide
          your own Date or explicitly set this to false.

    Disposition
          *Optional.* The content disposition, `"inline"' or
          `"attachment"'.  The default is `"inline"'.

    Encoding
          *Optional.* The content transfer encoding that should be used to
          encode your data:

               Use encoding:     | If your message contains:
               ------------------------------------------------------------
               7bit              | Only 7-bit text, all lines <1000 characters
               8bit              | 8-bit text, all lines <1000 characters
               quoted-printable  | 8-bit text or long lines (more reliable than "8bit")
               base64            | Largely non-textual data: a GIF, a tar file, etc.

          The default is taken from the Type; generally it is "binary" (no
          encoding) for text/*, message/*, and multipart/*, and "base64"
          for everything else.  A value of `"binary"' is generally not
          suitable for sending anything but ASCII text files with lines
          under 1000 characters, so consider using one of the other values
          instead.

          In the case of "7bit"/"8bit", long lines are automatically
          chopped to legal length; in the case of "7bit", all 8-bit
          characters are automatically removed.  This may not be what you
          want, so pick your encoding well!  For more info, see `"A MIME
          PRIMER"' in this node.

    FH
          *Alternative to "Data" or "Path".* Filehandle containing the
          data, opened for reading.  See "ReadNow" also.

    Filename
          *Optional.* The name of the attachment.  You can use this to
          supply a recommended filename for the end-user who is saving the
          attachment to disk, if the one in the Path is inadequate, or if
          you're using the Data argument.  You should not put path
          information in here (e.g., no "/" or "\" or ":" characters).

    Id
          *Optional.* Same as setting "content-id".

    Length
          *Optional.* Set the content length explicitly.  Normally, this
          header is automatically computed, but only under certain
          circumstances (see `"Limitations"' in this node).

    Path
          *Alternative to "Data" or "FH".* Path to a file containing the
          data... actually, it can be any open()able expression.  If it
          looks like a path, the last element will automatically be
          treated as the filename.  See "ReadNow" also.

    ReadNow
          *Optional, for use with "Path".* If true, will open the path and
          slurp the contents into core now.  This is useful if the Path
          points to a command and you don't want to run the command over
          and over if outputting the message several times.  *Fatal
          exception* raised if the open fails.

    Top
          *Optional.* If defined, indicates whether or not this is a
          "top-level" MIME message.  The parts of a multipart message are
          not top-level.  Default is true.

    Type
          *Optional.* The MIME content type, or one of these special
          values (case-sensitive):

               "TEXT"   means "text/plain"
               "BINARY" means "application/octet-stream"

          The default is `"TEXT"'.

     A picture being worth 1000 words (which is of course 2000 bytes, so
     it's probably more of an "icon" than a "picture", but I digress...),
     here are some examples:

          $msg = MIME::Lite->build(
                     From     => 'yelling@inter.com',
                     To       => 'stocking@fish.net',
                     Subject  => "Hi there!",
                     Type     => 'TEXT',
                     Encoding => '7bit',
                     Data     => "Just a quick note to say hi!");
          
          $msg = MIME::Lite->build(
                     From     => 'dorothy@emerald-city.oz',
                     To       => 'gesundheit@edu.edu.edu',
                     Subject  => "A gif for U"
                     Type     => 'image/gif',
                     Path     => "/home/httpd/logo.gif");
          
          $msg = MIME::Lite->build(
                     From     => 'laughing@all.of.us',
                     To       => 'scarlett@fiddle.dee.de',
                     Subject  => "A gzipp'ed tar file",
                     Type     => 'x-gzip',
                     Path     => "gzip < /usr/inc/somefile.tar |",
                     ReadNow  => 1,
                     Filename => "somefile.tgz");

     To show you what's really going on, that last example could also have
     been written:

          $msg = new MIME::Lite;
          $msg->build(Type     => 'x-gzip',
                      Path     => "gzip < /usr/inc/somefile.tar |",
                      ReadNow  => 1,
                      Filename => "somefile.tgz");
          $msg->add(From    => "laughing@all.of.us");
          $msg->add(To      => "scarlett@fiddle.dee.de");
          $msg->add(Subject => "A gzipp'ed tar file");

Setting/getting headers and attributes
--------------------------------------

add TAG,VALUE
     Add field TAG with the given VALUE to the end of the header.  The TAG
     will be converted to all-lowercase, and the VALUE will be made "safe"
     (returns will be given a trailing space).

     *Beware:* any MIME fields you "add" will override any MIME attributes
     I have when it comes time to output those fields.  Normally, you will
     use this method to add *non-MIME* fields:

          $msg->add("Subject" => "Hi there!");

     Giving VALUE as an arrayref will cause all those values to be added.
     This is only useful for special multiple-valued fields like
     "Received":

          $msg->add("Received" => ["here", "there", "everywhere"]

     Giving VALUE as the empty string adds an invisible placeholder to the
     header, which can be used to suppress the output of the "Content-*"
     fields or the special  "MIME-Version" field.  When suppressing
     fields, you should use replace() instead of add():

          $msg->replace("Content-disposition" => "");

     Note: add() is probably going to be more efficient than replace(), so
     you're better off using it for most applications if you are certain
     that you don't need to delete() the field first.

     Note: the name comes from Mail::Header.

attr ATTR,[VALUE]
     Set MIME attribute ATTR to the string VALUE.  ATTR is converted to
     all-lowercase.  This method is normally used to set/get MIME
     attributes:

          $msg->attr("content-type"         => "text/html");
          $msg->attr("content-type.charset" => "US-ASCII");
          $msg->attr("content-type.name"    => "homepage.html");

     This would cause the final output to look something like this:

          Content-type: text/html; charset=US-ASCII; name="homepage.html"

     Note that the special empty sub-field tag indicates the anonymous
     first sub-field.

     Giving VALUE as undefined will cause the contents of the named
     subfield to be deleted.

     Supplying no VALUE argument just returns the attribute's value:

          $type = $msg->attr("content-type");        ### returns "text/html"
          $name = $msg->attr("content-type.name");   ### returns "homepage.html"

delete TAG
     Delete field TAG with the given VALUE to the end of the header.  The
     TAG will be converted to all-lowercase.

          $msg->delete("Subject");

     Note: the name comes from Mail::Header.

fields
     Return the full header for the object, as a ref to an array of `[TAG,
     VALUE]' pairs, where each TAG is all-lowercase.  Note that any fields
     the user has explicitly set will override the corresponding MIME
     fields that we would otherwise generate.  So, don't say...

          $msg->set("Content-type" => "text/html; charset=US-ASCII");

     unless you want the above value to override the "Content-type" MIME
     field that we would normally generate.

     Note: I called this "fields" because the header() method of
     Mail::Header returns something different, but similar enough to be
     confusing.

filename [FILENAME]
     Set the filename which this data will be reported as.  This actually
     sets both "standard" attributes.

     With no argument, returns the filename as dictated by the
     content-disposition.

get TAG,[INDEX]
     Get the contents of field TAG, which might have been set with set()
     or replace().  Returns the text of the field.

          $ml->get('Subject', 0);

     If the optional 0-based INDEX is given, then we return the INDEX'th
     occurence of field TAG.  Otherwise, we look at the context: In a
     scalar context, only the first (0th) occurence of the field is
     returned; in an array context, all occurences are returned.

     Warning: this should only be used with non-MIME fields.  Behavior
     with MIME fields is TBD, and will raise an exception for now.

get_length
     Recompute the content length for the message *if the process is
     trivial*, setting the "content-length" attribute as a side-effect:

          $msg->get_length;

     Returns the length, or undefined if not set.

     Note: the content length can be difficult to compute, since it
     involves assembling the entire encoded body and taking the length of
     it (which, in the case of multipart messages, means freezing all the
     sub-parts, etc.).

     This method only sets the content length to a defined value if the
     message is a singlepart with `"binary"' encoding, and the body is
     available either in-core or as a simple file.  Otherwise, the content
     length is set to the undefined value.

     Since content-length is not a standard MIME field anyway (that's
     right, kids: it's not in the MIME RFCs, it's an HTTP thing), this
     seems pretty fair.

replace TAG,VALUE
     Delete all occurences of fields named TAG, and add a new field with
     the given VALUE.  TAG is converted to all-lowercase.

     *Beware* the special MIME fields (MIME-version, Content-*): if you
     "replace" a MIME field, the replacement text will override the
     *actual* MIME attributes when it comes time to output that field.  So
     normally you use attr() to change MIME fields and add()/replace() to
     change *non-MIME* fields:

          $msg->replace("Subject" => "Hi there!");

     Giving VALUE as the *empty string* will effectively *prevent* that
     field from being output.  This is the correct way to suppress the
     special MIME fields:

          $msg->replace("Content-disposition" => "");

     Giving VALUE as *undefined* will just cause all explicit values for
     TAG to be deleted, without having any new values added.

     Note: the name of this method  comes from Mail::Header.

scrub
     *This is Alpha code.  If you use it, please let me know how it goes.*
     Recursively goes through the "parts" tree of this message and tries
     to find MIME attributes that can be removed.  With an array argument,
     removes exactly those attributes; e.g.:

          $msg->scrub(['content-disposition', 'content-length']);

     Is the same as recursively doing:

          $msg->replace('Content-disposition' => '');
          $msg->replace('Content-length'      => '');

Setting/getting message data
----------------------------

binmode [OVERRIDE]
     With no argument, returns whether or not it thinks that the data (as
     given by the "Path" argument of `build()') should be read using
     binmode() (for example, when `read_now()' is invoked).

     The default behavior is that any content type other than `text/*' or
     `message/*' is binmode'd; this should in general work fine.

     With a defined argument, this method sets an explicit "override"
     value.  An undefined argument unsets the override.  The new current
     value is returned.

data [DATA]
     Get/set the literal DATA of the message.  The DATA may be either a
     scalar, or a reference to an array of scalars (which will simply be
     joined).

     Warning: setting the data causes the "content-length" attribute to be
     recomputed (possibly to nothing).

path [PATH]
     Get/set the PATH to the message data.

     Warning: setting the path recomputes any existing "content-length"
     field, and re-sets the "filename" (to the last element of the path if
     it looks like a simple path, and to nothing if not).

fh [FILEHANDLE]
     Get/set the FILEHANDLE which contains the message data.

     Takes a filehandle as an input and stores it in the object.  This
     routine is similar to path(); one important difference is that no
     attempt is made to set the content length.

resetfh [FILEHANDLE]
     Set the current position of the filehandle back to the beginning.
     Only applies if you used "FH" in build() or attach() for this message.

     Returns false if unable to reset the filehandle (since not all
     filehandles are seekable).

read_now
     Forces data from the path/filehandle (as specified by `build()') to
     be read into core immediately, just as though you had given it
     literally with the Data keyword.

     Note that the in-core data will always be used if available.

     Be aware that everything is slurped into a giant scalar: you may not
     want to use this if sending tar files!  The benefit of not reading in
     the data is that very large files can be handled by this module if
     left on disk until the message is output via print() or
     `print_body()'.

sign PARAMHASH
     Sign the message.  This forces the message to be read into core,
     after which the signature is appended to it.

    Data
          As in `build()': the literal signature data.  Can be either a
          scalar or a ref to an array of scalars.

    Path
          As in `build()': the path to the file.

     If no arguments are given, the default is:

          Path => "$ENV{HOME}/.signature"

     The content-length is recomputed.

verify_data
     *Instance method.* Verify that all "paths" to attached data exist,
     recursively.  It might be a good idea for you to do this before a
     print(), to prevent accidental partial output if a file might be
     missing.  Raises exception if any path is not readable.

Output
------

print [OUTHANDLE]
     *Instance method.* Print the message to the given output handle, or
     to the currently-selected filehandle if none was given.

     All OUTHANDLE has to be is a filehandle (possibly a glob ref), or any
     object that responds to a print() message.

print_body [OUTHANDLE]
     *Instance method.* Print the body of a message to the given output
     handle, or to the currently-selected filehandle if none was given.

     All OUTHANDLE has to be is a filehandle (possibly a glob ref), or any
     object that responds to a print() message.

     *Fatal exception* raised if unable to open any of the input files, or
     if a part contains no data, or if an unsupported encoding is
     encountered.

print_header [OUTHANDLE]
     *Instance method.* Print the header of the message to the given
     output handle, or to the currently-selected filehandle if none was
     given.

     All OUTHANDLE has to be is a filehandle (possibly a glob ref), or any
     object that responds to a print() message.

as_string
     *Instance method.* Return the entire message as a string, with a
     header and an encoded body.

body_as_string
     *Instance method.* Return the encoded body as a string.  This is the
     portion after the header and the blank line.

     Note: actually prepares the body by "printing" to a scalar.  Proof
     that you can hand the `print*()' methods any blessed object that
     responds to a print() message.

header_as_string
     *Instance method.* Return the header as a string.

Sending
-------

send
send HOW, HOWARGS...
     *Class/instance method.* This is the principal method for sending
     mail, and for configuring how mail will be sent.

     *As an instance method* (with no arguments), sends the message by
     whatever means has been set up (the default is to use the Unix
     "sendmail" program).  Returns whatever the mail-handling routine
     returns: this should be true on success, false/exception on error:

          $msg = MIME::Lite->new(From=>...);
          $msg->send || die "you DON'T have mail!";

     *As a class method* (with a HOW argument and optional HOWARGS), sets
     up how the instance method will work for all objects until further
     notice It treats HOW as a facility name, with optional HOWARGS
     handled by the facility (and returns the previous HOW and HOWARGS as
     an array).  There are three facilities:

    "sendmail", ARGS...
          Send a message by piping it into the "sendmail" command.  Uses
          the `send_by_sendmail()|' in this node method, giving it the
          ARGS.  This usage implements (and deprecates) the sendmail()
          method.

    "smtp", [HOSTNAME]
          Send a message by SMTP, using optional HOSTNAME as SMTP-sending
          host.  Uses the `send_by_smtp()|' in this node method.

    "sub", \&SUBREF, ARGS...
          Sends a message MSG by invoking the subroutine SUBREF of your
          choosing, with MSG as the first argument, and ARGS following.

     *For example:* let's say you're on an OS which lacks the usual Unix
     "sendmail" facility, but you've installed something a lot like it, and
     you need to configure your Perl script to use this "sendmail.exe"
     program.  Do this following in your script's setup:

          MIME::Lite->send('sendmail', "d:\\programs\\sendmail.exe");

     Then, whenever you need to send a message $msg, just say:

          $msg->send;

     That's it.  Now, if you ever move your script to a Unix box, all you
     need to do is change that line in the setup and you're done.  All of
     your $msg->send invocations will work as expected.

send_by_sendmail SENDMAILCMD
send_by_sendmail PARAM=>VALUE, ...
     *Instance method.* Send message via an external "sendmail" program
     (this will probably only work out-of-the-box on Unix systems).

     Returns true on success, false or exception on error.

     You can specify the program and all its arguments by giving a single
     string, SENDMAILCMD.  Nothing fancy is done; the message is simply
     piped in.

     However, if your needs are a little more advanced, you can specify
     zero or more of the following PARAM/VALUE pairs; a Unix-style,
     taint-safe "sendmail" command will be constructed for you:

    Sendmail
          Full path to the program to use.  Default is "/usr/lib/sendmail".

    BaseArgs
          Ref to the basic array of arguments we start with.  Default is
          `["-t", "-oi", "-oem"]'.

    SetSender
          Unless this is *explicitly* given as false, we attempt to
          automatically set the -f argument to the first address that can
          be extracted from the "From:" field of the message (if there is
          one).

          *What is the -f, and why do we use it?* Suppose we did not use
          -f, and you gave an explicit "From:" field in your message: in
          this case, the sendmail "envelope" would indicate the real user
          your process was running under, as a way of preventing mail
          forgery.  Using the -f switch causes the sender to be set in the
          envelope as well.

          *So when would I NOT want to use it?* If sendmail doesn't regard
          you as a "trusted" user, it will permit the -f but also add an
          "X-Authentication-Warning" header to the message to indicate a
          forged envelope.  To avoid this, you can either (1) have
          SetSender be false, or (2) make yourself a trusted user by
          adding a T configuration     command to your *sendmail.cf* file
            (e.g.: `Teryq' if the script is running as user "eryq").

    FromSender
          If defined, this is identical to setting SetSender to true,
          except that instead of looking at the "From:" field we use the
          address given by this option.  Thus:

               FromSender => 'me@myhost.com'

send_by_smtp ARGS...
     *Instance method.* Send message via SMTP, using Net::SMTP.  The
     optional ARGS are sent into Net::SMTP::new(): usually, these are

          MAILHOST, OPTION=>VALUE, ...

     Note that the list of recipients is taken from the "To", "Cc" and
     "Bcc" fields.

     Returns true on success, false or exception on error.

sendmail COMMAND...
     *Class method, DEPRECATED.* Declare the sender to be "sendmail", and
     set up the "sendmail" command.  *You should use send() instead.*

Miscellaneous
-------------

quiet ONOFF
     *Class method.* Suppress/unsuppress all warnings coming from this
     module.

          MIME::Lite->quiet(1);       ### I know what I'm doing

     I recommend that you include that comment as well.  And while you
     type it, say it out loud: if it doesn't feel right, then maybe you
     should reconsider the whole line.  `;-)'

NOTES
=====

Benign limitations
------------------

   This is "lite", after all...

   * There's no parsing.  Get MIME-tools if you need to parse MIME
     messages.

   * MIME::Lite messages are currently not interchangeable with either
     Mail::Internet or MIME::Entity objects.  This is a completely
     separate module.

   * A content-length field is only inserted if the encoding is binary,
     the message is a singlepart, and all the document data is available
     at `build()' time by virtue of residing in a simple path, or in-core.
     Since content-length is not a standard MIME field anyway (that's
     right, kids: it's not in the MIME RFCs, it's an HTTP thing), this
     seems pretty fair.

   * MIME::Lite alone cannot help you lose weight.  You must supplement
     your use of MIME::Lite with a healthy diet and exercise.

Cheap and easy mailing
----------------------

   I thought putting in a default "sendmail" invocation wasn't too bad an
idea, since a lot of Perlers are on UNIX systems.  The out-of-the-box
configuration is:

     MIME::Lite->send('sendmail', "/usr/lib/sendmail -t -oi -oem");

   By the way, these arguments to sendmail are:

     -t      Scan message for To:, Cc:, Bcc:, etc.
     
     -oi     Do NOT treat a single "." on a line as a message terminator.
             As in, "-oi vey, it truncated my message... why?!"
     
     -oem    On error, mail back the message (I assume to the
             appropriate address, given in the header).
             When mail returns, circle is complete.  Jai Guru Deva -oem.

   Note that these are the same arguments you get if you configure to use
the smarter, taint-safe mailing:

     MIME::Lite->send('sendmail');

   If you get "X-Authentication-Warning" headers from this, you can forgo
diddling with the envelope by instead specifying:

     MIME::Lite->send('sendmail', SetSender=>0);

   And, if you're not on a Unix system, or if you'd just rather send mail
some other way, there's always:

     MIME::Lite->send('smtp', "smtp.myisp.net");

   Or you can set up your own subroutine to call.  In any case, check out
the `send()|' in this node method.

WARNINGS
========

Good-vs-bad email addresses with send_by_smtp()
-----------------------------------------------

   If using `send_by_smtp()|' in this node, be aware that you are forcing
MIME::Lite to extract email addresses out of a possible list provided in
the `To:', `Cc:', and `Bcc:' fields.  This is tricky stuff, and as such
only the following sorts of addresses will work reliably:

     username
     full.name@some.host.com
     "Name, Full" <full.name@some.host.com>

   This last form is discouraged because SMTP must be able to get at the
name or *name@domain* portion.

   *Disclaimer:* MIME::Lite was never intended to be a Mail User Agent, so
please don't expect a full implementation of RFC-822.  Restrict yourself to
the common forms of Internet addresses described herein, and you should be
fine.  If this is not feasible, then consider using MIME::Lite to prepare
your message only, and using Net::SMTP explicitly to send your message.

Formatting of headers delayed until print()
-------------------------------------------

   This class treats a MIME header in the most abstract sense, as being a
collection of high-level attributes.  The actual RFC-822-style header
fields are not constructed until it's time to actually print the darn
thing.

Encoding of data delayed until print()
--------------------------------------

   When you specify message bodies (in `build()|' in this node or
`attach()|' in this node) - whether by FH, Data, or Path - be warned that
we don't attempt to open files, read filehandles, or encode the data until
`print()|' in this node is invoked.

   In the past, this created some confusion for users of sendmail who gave
the wrong path to an attachment body, since enough of the print() would
succeed to get the initial part of the message out.  Nowadays,
$AUTO_VERIFY is used to spot-check the Paths given before the mail
facility is employed.  A whisker slower, but tons safer.

   Note that if you give a message body via FH, and try to print() a
message twice, the second print() will not do the right thing unless you
explicitly rewind the filehandle.

   You can get past these difficulties by using the ReadNow option,
provided that you have enough memory to handle your messages.

MIME attributes are separate from header fields!
------------------------------------------------

   *Important:* the MIME attributes are stored and manipulated separately
from the message header fields; when it comes time to print the header
out, *any explicitly-given header fields override the ones that would be
created from the MIME attributes.*  That means that this:

     ### DANGER ### DANGER ### DANGER ### DANGER ### DANGER ###
     $msg->add("Content-type", "text/html; charset=US-ASCII");

   will set the exact `"Content-type"' field in the header I write,
*regardless of what the actual MIME attributes are.*

   *This feature is for experienced users only,* as an escape hatch in case
the code that normally formats MIME header fields isn't doing what you
need.  And, like any escape hatch, it's got an alarm on it: MIME::Lite
will warn you if you attempt to set() or replace() any MIME header field.
Use attr() instead.

Beware of lines consisting of a single dot
------------------------------------------

   Julian Haight noted that MIME::Lite allows you to compose messages with
lines in the body consisting of a single ".".  This is true: it should be
completely harmless so long as "sendmail" is used with the -oi option (see
`"Cheap and easy mailing"' in this node).

   However, I don't know if using Net::SMTP to transfer such a message is
equally safe.  Feedback is welcomed.

   My perspective: I don't want to magically diddle with a user's message
unless absolutely positively necessary.  Some users may want to send files
with "." alone on a line; my well-meaning tinkering could seriously harm
them.

A MIME PRIMER
=============

Content types
-------------

   The "Type" parameter of `build()' is a *content type*.  This is the
actual type of data you are sending.  Generally this is a string of the
form `"majortype/minortype"'.

   Here are the major MIME types.  A more-comprehensive listing may be
found in RFC-2046.

application
     Data which does not fit in any of the other categories, particularly
     data to be processed by some type of application program.
     `application/octet-stream', `application/gzip',
     `application/postscript'...

audio
     Audio data.  `audio/basic'...

image
     Graphics data.  `image/gif', `image/jpeg'...

message
     A message, usually another mail or MIME message.  `message/rfc822'...

multipart
     A message containing other messages.  `multipart/mixed',
     `multipart/alternative'...

text
     Textual data, meant for humans to read.  `text/plain', `text/html'...

video
     Video or video+audio data.  `video/mpeg'...

Content transfer encodings
--------------------------

   The "Encoding" parameter of `build()'.  This is how the message body is
packaged up for safe transit.

   Here are the 5 major MIME encodings.  A more-comprehensive listing may
be found in RFC-2045.

  1. Basically, no real encoding is done.  However, this label guarantees
     that no 8-bit characters are present, and that lines do not exceed
     1000 characters in length.

  2. Basically, no real encoding is done.  The message might contain 8-bit
     characters, but this encoding guarantees that lines do not exceed 1000
     characters in length.

  3. binary No encoding is done at all.  Message might contain 8-bit
     characters, and lines might be longer than 1000 characters long.

     The most liberal, and the least likely to get through mail gateways.
     Use sparingly, or (better yet) not at all.

  4. base64 Like "uuencode", but very well-defined.  This is how you
     should send essentially binary information (tar files, GIFs, JPEGs,
     etc.).

  5. quoted-printable Useful for encoding messages which are textual in
     nature, yet which contain non-ASCII characters (e.g., Latin-1,
     Latin-2, or any other 8-bit alphabet).


VERSION
=======

   $Id: Lite.pm,v 2.106 2000/11/21 08:16:32 eryq Exp $

CHANGE LOG
==========

Version 2.106   (2000/11/21)
     Added Alpha version of scrub() to make it easy for people to suppress
     the printing of unwanted MIME attributes (like Content-length).
     *Thanks to the many people who asked for this.*

     Headers with empty-strings for their values are no longer printed.
     This seems sensible, and helps us implement scrub().

Version 2.105   (2000/10/14)
     The regression-test failure was identified, and it was my fault.
     Apparently some of the \-quoting in my "autoloaded" code was making
     Perl 5.6 unhappy.  For this nesting-related idiocy, a nesting kaiku.
     *Thanks to Scott Schwartz for identifying the problem.*

          In a pattern, my
             backslash-s dwells peacefully,
          unambiguous --
          
             but I embed it
                in a double-quoted string
             doubling the backslash --
          
                interpolating
                   that same double-quoted string
                in other patterns --
          
                   and, worlds within worlds,
                      I single-quote the function
                   to autoload it --
          
                changing the meaning
             of the backslash and the 's';
          and Five-Point-Six growls.

Version 2.104   (2000/09/28)
     Now attempts to load and use Mail::Address for parsing email
     addresses before falling back to our own method.  *Thanks to numerous
     people for suggesting this.*

          Parsing addresses
             is too damn hard. One last hope:
          Let Graham Barr do it!

     For the curious, the version of Mail::Address appears as the "A"
     number in the X-Mailer:

          X-Mailer: MIME::Lite 2.104  (A1.15; B2.09; Q2.03)

     Added FromSender option to send_by_sendmail().  *Thanks to Bill
     Moseley for suggesting this feature.*

Version 2.101   (2000/06/06)
     Major revision to print_body() and body_as_string() so that "body"
     really means "the part after the header", which is what most people
     would want in this context.  This is not how it was used 1.x, where
     "body" only meant "the body of a simple singlepart".  Hopefully, this
     change will solve many problems and create very few ones.

     Added support for attaching a part to a "message/rfc822", treating
     the "message" type as a multipart-like container.

     Now takes care not to include "Bcc:" in header when using
     send_by_smtp, as a safety precaution against qmail's behavior.
     *Thanks to Tatsuhiko Miyagawa for identifying this problem.*

     Improved efficiency of many stringifying operations by using
     string-arrays which are joined, instead of doing multiple appends to
     a scalar.

     Cleaned up the "examples" directory.

Version 1.147   (2000/06/02)
     Fixed buglet where lack of Cc:/Bcc: was causing extract_addrs to emit
     "undefined variable" warnings.  Also, lack of a "To:" field now
     causes a croak.  *Thanks to David Mitchell for the bug report and
     suggested patch.*

Version 1.146   (2000/05/18)
     Fixed bug in parsing of addresses; please read the WARNINGS section
     which describes recommended address formats for "To:", "Cc:", etc.
     Also added automatic inclusion of a UT "Date:" at top level unless
     explicitly told not to.  *Thanks to Andy Jacobs for the bug report
     and the suggestion.*

Version 1.145   (2000/05/06)
     Fixed bug in encode_7bit(): a lingering `/e' modifier was removed.
     *Thanks to Michael A. Chase for the patch.*

Version 1.142   (2000/05/02)
     Added new, taint-safe invocation of "sendmail", one which also sets
     up the -f option.  Unfortunately, I couldn't make this automatic: the
     change could have broken a lot of code out there which used
     send_by_sendmail() with unusual "sendmail" variants.  So you'll have
     to configure "send" to use the new mechanism:

          MIME::Lite->send('sendmail');       ### no args!

     *Thanks to Jeremy Howard for suggesting these features.*

Version 1.140   (2000/04/27)
     Fixed bug in support for "To", "Cc", and "Bcc" in send_by_smtp():
     multiple (comma-separated) addresses should now work fine.  We try
     real hard to extract addresses from the flat text strings.  *Thanks
     to John Mason for motivating this change.*

     Added automatic verification that attached data files exist, done
     immediately before the "send" action is invoked.  To turn this off,
     set $MIME::Lite::AUTO_VERIFY to false.

Version 1.137   (2000/03/22)
     Added support for "Cc" and "Bcc" in send_by_smtp().  To turn this
     off, set $MIME::Lite::AUTO_CC to false.  *Thanks to Lucas Maneos for
     the patch, and tons of others for the suggestion.*

     Chooses a better default content-transfer-encoding if the content-type
     is "image/*", "audio/*", etc.  To turn this off, set
     $MIME::Lite::AUTO_ENCODE to false.  *Thanks to many folks for the
     suggestion.*

     Fixed bug in QP-encoding where a non-local $_ was being modified.
     *Thanks to Jochen Stenzel for finding this very obscure bug!*

     Removed references to $`, $', and $& (bad variables which slow things
     down).

     Added an example of how to send HTML files with enclosed in-line
     images, per popular demand.

Version 1.133   (1999/04/17)
     Fixed bug in "Data" handling: arrayrefs were not being handled
     properly.

Version 1.130   (1998/12/14)
     Added much larger and more-flexible send() facility.  *Thanks to
     Andrew McRae (and Optimation New Zealand Ltd) for the Net::SMTP
     interface.  Additional thanks to the many folks who requested this
     feature.*

     Added get() method for extracting basic attributes.

     New... "t" tests!

Version 1.124   (1998/11/13)
     Folded in filehandle (FH) support in build/attach.  *Thanks to Miko
     O'Sullivan for the code.*

Version 1.122   (1998/01/19)
     MIME::Base64 and MIME::QuotedPrint are used if available.

     The 7bit encoding no longer does "escapes"; it merely strips 8-bit
     characters.

Version 1.121   (1997/04/08)
     Filename attribute is now no longer ignored by build().  *Thanks to
     Ian Smith for finding and patching this bug.*

Version 1.120   (1997/03/29)
     Efficiency hack to speed up MIME::Lite::IO_Scalar.  *Thanks to David
     Aspinwall for the patch.*

Version 1.116   (1997/03/19)
     Small bug in our private copy of encode_base64() was patched.
     *Thanks to Andreas Koenig for pointing this out.*

     New, prettier way of specifying mail message headers in `build()'.

     New quiet method to turn off warnings.

     Changed "stringify" methods to more-standard "as_string" methods.

Version 1.112   (1997/03/06)
     Added `read_now()', and binmode() method for our non-Unix-using
     brethren: file data is now read using binmode() if appropriate.
     *Thanks to Xiangzhou Wang for pointing out this bug.*

Version 1.110   (1997/03/06)
     Fixed bug in opening the data filehandle.

Version 1.102   (1997/03/01)
     Initial release.

Version 1.101   (1997/03/01)
     Baseline code.

TERMS AND CONDITIONS
====================

   Copyright (c) 1997 by Eryq.  Copyright (c) 1998 by ZeeGee Software Inc.
All rights reserved.  This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

   This software comes with NO WARRANTY of any kind.  See the COPYING file
in the distribution for details.

NUTRITIONAL INFORMATION
=======================

   For some reason, the US FDA says that this is now required by law on
any products that bear the name "Lite"...

     MIME::Lite                |
     ------------------------------------------------------------
     Serving size:             | 1 module
     Servings per container:   | 1
     Calories:                 | 0
     Fat:                      | 0g
       Saturated Fat:          | 0g

   Warning: for consumption by hardware only!  May produce indigestion in
humans if taken internally.

AUTHOR
======

   Eryq (`eryq@zeegee.com').  President, ZeeGee Software Inc.
(`http://www.zeegee.com').

   Created: 11 December 1996.  Ho ho ho.


