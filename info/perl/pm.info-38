This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Audio/CoolEdit/Write,  Next: Audio/DSP,  Prev: Audio/CoolEdit/Read,  Up: Module List

Methods for writing Syntrillium CoolEdit Pro .ses files.
********************************************************

NAME
====

   Audio::CoolEdit::Write - Methods for writing Syntrillium CoolEdit Pro
.ses files.

SYNOPSIS
========

     use Audio::CoolEdit;

     my $cool = new Audio::CoolEdit;

     my $details =	{
     		'bits_sample'	=> 16,
     		'sample_rate'	=> 44100,
     		};

     my $write = $cool -> write( './test', $details );

NOTES
=====

   This module shouldn't be used directly, a blessed object can be
returned from *Note Audio/CoolEdit: Audio/CoolEdit,.

AUTHOR
======

   Nick Peskett - nick@soup.demon.co.uk

SEE ALSO
========

     L<Audio::CoolEdit>

     L<Audio::CoolEdit::Read>

METHODS
=======

file_name
---------

   Returns the filename of the session file to be written.

     my $file = $write -> file_name();

add_file
--------

   Adds a wav file to the current ses file.  Takes a reference to a hash
as the only parameter.  This hash should at least contain a path to the
wav file.

     use Audio::Tools::Fades;
     my $fade_type = 'trig';
     my $fade_length = 20000;
     my $fades = new Audio::Tools::Fades;
     my $fade_sub = $fades -> fade( $fade_length, 0, $fade_type );

     my $record =	{
     			'file'		=> './t/testout.wav',
     			'offset'	=> 0,
     			'title'		=> "song 1",
     			'fade'		=> {
     					   'in'	=>	{
     							'type'	=> $fade_type,
     							'fade'	=> $fade_sub,
     							'start'	=> 0,
     							'end'	=> $fade_length,
     							},
     					   },
     		};

     $write -> add_file( $record );

   Parameters are; (* optional)

     file	=> path to wav file
     offset*	=> offset in bytes to place the file.
     start*	=> the byte offset to start the file at.
     end*	=> the byte offset to stop the file at.
     length*	=> length of data in bytes
     title*	=> title of file
     fade*	=> this should be a reference to a hash

   If you don't supply length or offset you will need to install the
Audio::Wav module so the file can be analysed.

   The fade hash should be in the following format; see *Note
Audio/Tools/Fades: Audio/Tools/Fades,

     in/out	=>	{
     		type	=> linear/ exp/ invexp/ trig/ invtrig
     		fade	=> return from Audio::Tools::Fades -> fade method,
     		start	=> fade starts (bytes),
     		end	=> fade ends (bytes),
     		}

add_cue
-------

   Adds a cuepoint to the current file.

     $write -> add_cue( $byte_offset, 'Name', 'Description' );

finish
------

   Finish & write the current file.

     $write -> finish();


File: pm.info,  Node: Audio/DSP,  Next: Audio/MikMod,  Prev: Audio/CoolEdit/Write,  Up: Module List

Perl interface to *NIX digital audio device.
********************************************

NAME
====

   Audio::DSP - Perl interface to *NIX digital audio device.

SYNOPSIS
========

     use Audio::DSP;

     ($buf, $chan, $fmt, $rate) = (4096, 1, 8, 8192);

     $dsp = new Audio::DSP(buffer   => $buf,
                           channels => $chan,
                           format   => $fmt,
                           rate     => $rate);

     $seconds = 5;
     $length  = ($chan * $fmt * $rate * $seconds) / 8;

     $dsp->init() || die $dsp->errstr();

     # Record 5 seconds of sound
     for (my $i = 0; $i < $length; $i += $buf) {
         $dsp->read() || die $dsp->errstr();
     }

     # Play it back
     for (;;) {
         $dsp->write() || last;
     }

     $dsp->close();

DESCRIPTION
===========

   Audio::DSP is built around the OSS (Open Sound System) API and allows
perl to interface with a digital audio device. It provides, among other
things, an `initialization|"item_init"' in this node method which opens
and handles ioctl messaging on the audio device file. Audio::DSP also
provides some `rudimentary methods|"Dealing with data in memory"' in this
node for the storage and manipulation of audio data in memory.

   In order to use Audio::DSP, you'll need to have the necessary OSS
drivers/libraries installed. OSS is available for many popular Unices, and
a GPLed version (with which this extension was initially developed and
tested) is distributed with with the Linux kernel.

CONSTRUCTOR
===========

new([params])
     Returns blessed Audio::DSP object. Parameters:

    device
          Name of audio device file. Default is '/dev/dsp'.

    buffer
          Length of buffer, in bytes, for reading from/writing to the
          audio device file.  Default is 4096.

    rate
          Sampling rate in bytes per second. This parameter affects, among
          other things, the highest frequency in the sampled signal, which
          must be less than half the sample rate. Compact discs use a
          44100 samples per second sampling rate.

          Default sample rate is 8192.

    format
          Sample format. This parameter affects not only the size and the
          byte-order of a sample, but also its dynamic range.

          Sample format may be directly specified as an integer (e.g. 8 or
          16) or as one of the format `constants|"CONSTANTS"' in this node
          defined in soundcard.h and exported by Audio::DSP on use. The
          latter is preffered; an integer value of 16 (for example)
          corresponds to little endian signed 16 (AFMT_S16_LE), which
          format may or may not work with your card. So be careful.

          If the format constant is passed as a string (e.g. 'AFMT_U8'
          rather than AFMT_U8), it will work, but *this feature is
          deprecated*. It has been retained for backward-compatibility,
          but do not assume that it will be present in future versions.

          Default sample format is AFMT_U8.

    channels
          1 (mono) or 2 (stereo). Default is 1.

    file
          File from which to read raw sound data to be stored in memory.

          No effort is made to interpret the type of file being read. It's
          up to you to set the appropriate rate, channel, and format
          parameters if you wish to write the sound data to your audio
          device without damaging your hearing.

METHODS
=======

Opening and closing the device
------------------------------

init([params])
     Opens and initializes audio device file. Parameters
     `device|"item_device"' in this node, `buffer|"item_buffer"' in this
     node, `rate|"item_rate"' in this node, `format|"item_format"' in this
     node, and `channels|"item_channels"' in this node are shared with the
     constructor, and will override them. Additional parameters:

    mode
          Integer mode in which to open audio device file. Specifying the
          modes 'O_RDWR', 'O_RDONLY', and 'O_WRONLY' as strings will work,
          but *this feature is deprecated*. Use the Fcntl.pm constants to
          obtain the approriate integer mode values instead.

          The default value is O_RDWR.

     Example:

          $dsp->init(mode => O_RDONLY) || die $dsp->errstr();

     Returns true on success, false on error.

open([mode])
     Opens audio device file, does not send any ioctl messages. Default
     mode is O_RDWR.

     Example:

          $dsp->open(O_RDONLY) || die $dsp->errstr();

     Returns true on success, false on error.

close()
     Closes audio device file. Returns true on success, false on error.

Dealing with data in memory
---------------------------

audiofile($filename)
     Reads data from specified file and stores it in memory. If there is
     sound data stored already in memory, the file data will be
     concatenated onto the end of it.

     No effort is made to interpret the type of file being read. It's up
     to you to set the appropriate rate, channel, and format parameters if
     you wish to write the sound data to your audio device without
     damaging your hearing.

          $dsp->audiofile('foo.raw') || die $dsp->errstr();

     Returns true on success, false on error.

read()
     Reads buffer length of data from audio device file and appends it to
     the audio data stored in memory. Returns true on success, false on
     error.

write()
     Writes buffer length of sound data currently stored in memory,
     starting at the current `play mark|"item_setmark"' in this node
     offset, to audio device file. `Play mark|"item_setmark"' in this node
     is incremented one buffer length. Returns true on success, false on
     error or if the `play mark|"item_setmark"' in this node exceeds the
     length of audio data stored in memory.

clear()
     Clears audio data currently stored in memory, sets play mark to zero.
     No return value.

data()
     Returns sound data stored in memory.

          open RAWFILE, '>foo.raw';
          print RAWFILE $dsp->data();
          close RAWFILE;

datacat($data)
     Concatenates argument (a string) to audio data stored in memory.
     Returns length of audio data currently stored.

datalen()
     Returns length of audio data currently stored in memory.

setbuffer([$length])
     Sets read/write buffer if argument is provided.

     Returns buffer length currently specified.

setmark([$mark])
     Sets play mark if argument is provided. The play mark indicates how
     many bites of audio data stored in memory have been written to the
     audio device file since the mark was last set to zero. This lets the
     `write()|"item_write"' in this node method know what to write.

     Returns current play mark.

Reading/writing data directly to/from the device
------------------------------------------------

   These methods are provided mainly for the purposes of anyone wishing to
delve into hard-disk recording.

dread([$length])
     Reads length of data from audio device file and returns it. If length
     is not supplied, a "buffer length" of data (as specified when the
     `constructor|"item_new"' in this node/`init()|"item_init"' in this
     node method was called) is read.  If there is an error reading from
     the device file, a false value is returned.

dwrite($data)
     Writes data directly to audio device. Returns true on success, false
     on error.

I/O Control
-----------

   The device must be opened with `init()|"item_init"' in this node or
`open()|"item_open"' in this node before calling any of the following
methods.

   It is important to set sampling parameters in the following order:
`setfmt()|"item_setfmt"' in this node, `channels()|"item_channels"' in
this node, `speed()|"item_speed"' in this node. Setting sampling rate
(speed) before number of channels does not work with all devices,
according to OSS documentation. The safe alternative is to call
`init()|"item_init"' in this node with the appropriate parameters.

post()
     Sends SNDCTL_DSP_POST ioctl message to audio device file. Returns
     true on success, false on error.

reset()
     Sends SNDCTL_DSP_RESET ioctl message to audio device file. Returns
     true on success, false on error.

sync()
     Sends SNDCTL_DSP_SYNC ioctl message to audio device file. Returns
     true on success, false on error.

setfmt($format)
     Sends SNDCTL_DSP_SETFMT ioctl message to audio device file, with
     sample format as argument. Returns sample format to which the device
     was actually set if successful, false on error. You should check the
     return value even on success to ensure the requested sample format
     was in fact set for the device.

          my $format = AFMT_S16_LE; # signed 16-bit, little-endian
          my $rv     = $dsp->setfmt($format) || die $dsp->errstr;

          die "Failed to set requested sample format"
              unless ($format == $rv);

channels($channels)
     Sends SNDCTL_DSP_CHANNELS ioctl message to audio device file, with
     number of channels as argument. Returns number of channels to which
     the device was actually set if successful, false on error. You should
     check the return value even on success to ensure the requested number
     of channels were in fact set for the device.

          my $chan = 2; # stereo
          my $rv   = $dsp->channels($chan) || die $dsp->errstr;

          die "Failed to set requested number of channels"
              unless ($chan == $rv);

speed($rate)
     Sends SNDCTL_DSP_SPEED ioctl message to audio device file, with
     sample rate as argument. Returns sample rate to which the device was
     actually set if successful, false on error. You should check the
     return value even on success to ensure the requested sample rate was
     in fact set for the device.

          my $rate = 44100; # CD-quality sample rate
          my $rv   = $dsp->speed($rate) || die $dsp->errstr;

          die "Failed to set requested sample rate"
              unless ($rate == $rv);

setduplex()
     Sends SNDCTL_DSP_SETDUPLEX ioctl message to audio device file.
     Returns true on success, false on error.

Misc
----

errstr()
     Returns last recorded error.

Deprecated methods
------------------

   The following methods exist for transitional compatibility with version
0.01 and may not be available in future versions.

   The preferred alternative to the set* methods below is either to:

  1. close the device and call `init()|"item_init"' in this node with the
     appropriate parameters or:

  2. call the appropriate I/O control methods after having
     closed/re-opened the device, or after having called
     `reset()|"item_reset"' in this node
        The second should only be performed if you know what you are
doing. It is important, for example, to set sampling parameters in the
following order: `setfmt()|"item_setfmt"' in this node,
`channels()|"item_channels"' in this node, `speed()|"item_speed"' in this
node. Setting sampling rate (speed) before number of channels does not
work with all devices, according to OSS documentation.

getformat($format)
     Returns true if specified `sample format|"item_format"' in this node
     is supported by audio device. A false value may indicate the format
     is not supported, but it may also mean that the SNDCTL_DSP_GETFMTS
     ioctl failed (the `init()|"item_init"' in this node method must be
     called before this method), etc.  Be sure to check the last `error
     message|"item_errstr"' in this node in this case.

     Deprecated. If you wish to check if a given format is supported by the
     device, instead call `getfmts()|"item_getfmts"' in this node method,
     then AND the return value with the format for which you wish to check.

          my $format = AFMT_S16_LE;
          my $mask   = $dsp->getfmts;

          print "Format is supported!\n"
              if ($format & $mask);

queryformat()
     Returns currently used format of initialized audio device. Unlike the
     `setformat()|"item_setformat"' in this node method, queryformat
     "asks" the audio device directly which format is being used.

     Deprecated. If you wish to find the format to which the device is
     currently set, instead call `setfmt()|"item_setfmt"' in this node
     with AFMT_QUERY as an argument and check the return value.

          my $format = $dsp->setfmt(AFMT_QUERY);
          print "Device set to format $format.\n";

setchannels([$channels])
     Deprecated. See introduction to this section for alternative methods.

     Sets number of channels if argument is provided. If the audio device
     file is open, the number of channels will not actually be changed
     until you call `close()|"item_close"' in this node and
     `init()|"item_init"' in this node again.

     Returns number of channels currently specified.

setdevice([$device_name])
     Deprecated. See introduction to this section for alternative methods.

     Sets audio device file if argument is provided. If the device is
     open, it will not actually be changed until you call
     `close()|"item_close"' in this node and `init()|"item_init"' in this
     node again.

     Returns audio device file name currently specified.

setformat([$bits])
     Deprecated. See introduction to this section for alternative methods.

     Sets sample format if argument is provided. If the audio device file
     is open, the sample format will not actually be changed until you call
     `close()|"item_close"' in this node and `init()|"item_init"' in this
     node again.

     Returns sample format currently specified.

setrate([$rate])
     Deprecated. See introduction to this section for alternative methods.

     Sets sample rate if argument is provided. If the audio device file is
     open, the sample rate will not actually be changed until you call
     `close()|"item_close"' in this node and `init()|"item_init"' in this
     node again.

     Returns sample rate currently specified.

CONSTANTS
=========

   The following audio-format constants are exported by Audio::DSP on use:

AFMT_MU_LAW
     logarithmic mu-Law

AFMT_A_LAW
     logarithmic A-Law

AFMT_IMA_ADPCM
     4:1 compressed (IMA)

AFMT_U8
     8 bit unsigned

AFMT_S16_LE
     16 bit signed little endian (Intel - used in PC soundcards)

AFMT_S16_BE
     16 bit signed big endian (PPC, Sparc, etc)

AFMT_S8
     8 bit signed

AFMT_U16_LE
     16 bit unsigned little endian

AFMT_U16_BE
     16 bit unsigned bit endian

AFMT_MPEG
     MPEG (not currently supported by OSS)

NOTES
=====

   Audio::DSP does not provide any methods for converting the raw audio
data stored in memory into other formats (that's another project
altogether).  You can, however, use the `data()|"item_data"' in this node
method to dump the raw audio to a file, then use a program like sox to
convert it to your favorite format. If you are interested in writing .wav
files, you may want to take a look at Nick Peskett's Audio::Wav module.

AUTHOR
======

   Seth David Johnson, seth@pdamusic.com

SEE ALSO
========

   Open Sound System homepage:

     http://www.opensound.com/

   Open Sound System - Audio programming:

     http://www.opensound.com/pguide/audio.html

   OSS Programmer's guide (PDF):

     http://www.opensound.com/pguide/oss.pdf

   A GPLed version of OSS distributed with the Linux kernel was used in the
development of Audio::DSP. See "The Linux Sound Subsystem":

     http://www.linux.org.uk/OSS/

   To my knowledge, the Advanced Linux Sound Architecture (ALSA) API is
supposed to remain compatible with the OSS API on which this extension is
built. ALSA homepage:

     http://www.alsa-project.org/

   perl(1).

COPYRIGHT
=========

   Copyright (c) 1999-2000 Seth David Johnson.  All Rights Reserved. This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.


File: pm.info,  Node: Audio/MikMod,  Next: Audio/Mix,  Prev: Audio/DSP,  Up: Module List

Perl extension for libmikmod.
*****************************

NAME
====

   Audio::MikMod - Perl extension for libmikmod.

SYNOPSIS
========

     use Audio::MikMod qw(:all);
     use Time::HiRes;

     MikMod_RegisterAllDrivers();
     MikMod_RegisterAllLoaders();
     MikMod_Init();

     my $module = Player_Load('filename', 64, 0);
     Player_Start($module);

     while(Player_Active()) {
     	usleep(10000);
     	MikMod_Update();
     }

     Player_Stop();
     Player_Free($module);
     MikMod_Exit();

DESCRIPTION
===========

   This module provides an interface to the libmikmod library for playing
MOD, IT, XM, S3M, MTM, 669, STM, ULT, FAR, MED, AMF, DSM, IMF, GDM, and
STX tracker files. In addition, manipulation of WAV samples is supported.

   Please see the extensive libmikmod info documentation included with
that package.

   libmikmod is required, and can be obtained at http://mikmod.darkorb.net/

AUTHOR
======

   Daniel Sully <daniel-cpan-mikmod@electricrain.com>

SEE ALSO
========

   info mikmod, perl(1).


File: pm.info,  Node: Audio/Mix,  Next: Audio/Play/MPG123,  Prev: Audio/MikMod,  Up: Module List

Module for fading cross-fading wav audio files.
***********************************************

NAME
====

   Audio::Mix - Module for fading cross-fading wav audio files.

SYNOPSIS
========

     my $settings =	{
     		'out_dir'	=> '.',
     		'hints'		=> {
     				   'dir'	=> '.',
     				    'mode'	=> 'write',
     				   },
     		'fade_time'	=> 15,
     		'default_fade'	=> 'linear',
     		};

     my $wav = Audio::Mix -> new( $settings );

     my $xfade = 	{
     		'out_type'	=> 'cooledit',
     		'read_dir'	=> './t',
     		'out_file'	=> 'xfade',
     		'dao_file'	=> 1,
     		};

     $wav -> mix( $xfade );

DESCRIPTION
===========

Perl Wav/ CoolEdit Fader/ Cross-Fader
-------------------------------------

   The purpose of this module is to provide a way to apply fades to
uncompressed Microsoft .wav files. Not being a c programmer, the fades are
done completely in perl, making a minutes fade on a stereo  44.1 Khz,
16bit file take a considerable amount of time. The primary reason I wrote
this module was because I needed a programmatic way to mix songs together
for subsequent burning to a CDR. After spending many hours watching
countdowns while my perl loop faded files in & out I contacted
Syntrillium, makers of the excellent multitrack sound editor 'Cooledit
Pro' asking for details of their file format, so I could have the perl
program read the attributes of each .wav file, sort them by tempo, arrange
the fading curves and write all this to a small Cooledit 'session' file
for subsequent preview/ tweaking. I personally use the Cooledit mode for a
number of reasons;

   * You can listen to the results in minutes rather than hours.

   * You can view all the waveforms together and visually see the
non-destructive fades that will be applied

   * It handles clipping (when the digital volume becomes larger than the
bit size will allow), my program just warns you when it happens and does
nothing about it :-(

   Among the reasons I have left the perl .wav mixing routines is for
people who may be using a non mswin32 platform or cannot justify the price
of Cooledit. Also I'm kind of hoping that a c whizz will become interested
and contact me about writing a super cool c mixing engine in this curious
XS thing I've been hearing so much about :-) While on the subject of
different platforms, I pretty sure that this version will not work on big
endian processors as I'm not doing anything about network orders etc yet,
as it started to make my head hurt!  (*Note Audio/Tools/ByteOrder:
Audio/Tools/ByteOrder,)

Why?
====

   The concept behind this module is that each .wav file can be marked up
to give the arrangement decider (for want of a better name) clues as to
the best way to mix a song into the final output. You can start out marking
up the actual file with cuepoints and at a later stage when tweaking the
mix you can place a hint file in a given directory and these settings will
take precedence over the settings marked up in the .wav file. I'm planning
to add a feature that will encode the information in the hint file into
the .wav file. This should be able to be done fairly quickly as this
information usually resides after the sound data block.

   The Cross Fader is given either an input directory that it collects its
.wav files from or a list of fully qualified paths.

   The two methods for marking up files are;

Markup Methods
==============

Cuepoints within the .wav file.
-------------------------------

   Markups should be entered with the command in the name field & the
option in the description field. I've only used cooledit to mark these
files so I'm not sure how the program would behave with cuepoints created
in another audio editing program.

   To edit cuepoints (in cooledit) choose

     View -> Cue Edit

   * type the command in the Name & the option in Description.

   Within a .wav file, Cooledit uses the CUE block to define offsets for
each cue, but it uses LIST block to store the name & description
information. This LIST block type is known as an Associated Data List
(adtl). This method of encoding cue point names & descriptions is not
universally accepted as a good thing, but I couldn't find an alternative
method.

Entries in a hint file.
-----------------------

   If a correspondingly named .hint file exists in the hints directory
then this information will be used in preference to the markups within the
.wav file. You can set the hint directory to be the same as the .wav input
directory but this has little use when dealing with read only sources
(such as CDR).

   The hint file should have each command on a separate line with the
option on the same line after a tab. All times should be in sample format,
offset from 0 (being the start of the file).

   Hints can also exist in the .wav input directory, but if this is the
case they have lower priority than the ones in the hint directory.

Markup Types.
=============

Start/ End Points
-----------------

   command: start/ end

   *options:* none

   These markers determine at which point the song will start/ end. Fades
are started/ finished from these points

Significant points
------------------

   command: sig

   *options:* first/ last

   A significant point in a song will be used as the position the next/
previous song aligns it's first/ last point to. In general it's good
practice to try and make these points sit at the first beat of the bar (or
at least on a beat). In this way even if two songs tempos do not match
exactly at the significant point for each song it should fall on the same
beat.  I've found that significant points sound good at the centre of a
fade in/ out

Fades
-----

   See *Note Audio/Tools/Fades: Audio/Tools/Fades,

   command: fade_in/ fade_out

   *options:* linear/ trig/ invtrig/ exp/ invexp

   Currently the module only supports a fade in from either the start of
the file or from a start tag or a fade out to the end of the file or a end
tag.

   The different fade types are;

   * linear - Smooth linear fade

   * trig/ invtrig - Trigonomic fade. My favourite. looks suspiciously
like a quarter of a circle. Inv is the inverse, i.e. starts slowly, gets
louder/ quiter the nearer the end it gets

   * exp/ invexp - Exponential fade. An extreme fade that follows x
squared. Gets loud/ quite quickly and finishes slowly. invexp as above

AUTHOR
======

   Nick Peskett - nick@soup.demon.co.uk

SEE ALSO
========

   *Note Audio/Tools/ByteOrder: Audio/Tools/ByteOrder,

   *Note Audio/Tools/Fades: Audio/Tools/Fades,

   *Note Audio/Wav: Audio/Wav,

   *Note Audio/CoolEdit: Audio/CoolEdit,

METHODS
=======

new
---

   Returns a blessed Audio::Mix object.

     my $settings =	{
     		'out_dir'	=> '.',
     		'fade_time'	=> 15,
     		'default_fade'	=> 'linear',
     		'hints'		=> {
     				   'dir'	=> '.',
     				   'mode'	=> 'write',
     				   },
     		};

     my $wav = Audio::Mix -> new( $settings );

   Where; (all are optional)

   out_dir		=> the directory the mix will be created in.

   fade_time	=> the default length of a fade in seconds.

   default_fade	=> the default fade type

   auto_fade	=> if this is true (1) then unmarked-up file will have
the default 		   fade applied for the default length. The
significant point will 		   be in the centre.

   hints		=> a reference to a hash containing;

     {
     dir	=> path to read hints from
     mode	=> read, write or blank for neither
     }

mix
---

   Creates a mix of a number of given files.

     my $xfade = 	{
     		'out_type'	=> 'cooledit',
     		'read_dir'	=> './t',
     		'out_file'	=> 'xfade',
     		'dao_file'	=> 1,
     		};

     $wav -> mix( $xfade );

   Where; (* are optional) - You should have either read_dir or read_files

   out_type*	=> either cooledit or wav (so far).

   read_dir*	=> a directory where the source wav files can be found.

   read_files*	=> a reference to an array of full paths to source
wav files.

   out_file*	=> the filename to write to (without extension),
defaults to 'mix'.

   dao_file*	=> 1 to write a Goldenhawk cue file (see
Audio::Tools::Time).


File: pm.info,  Node: Audio/Play/MPG123,  Next: Audio/SoundFile,  Prev: Audio/Mix,  Up: Module List

a frontend to mpg123 version 0.59r and beyond.
**********************************************

NAME
====

   Audio::Play::MPG123 - a frontend to mpg123 version 0.59r and beyond.

SYNOPSIS
========

     use Audio::Play::MPG123;
     
     $player = new Audio::Play::MPG123;
     $player->load("kult.mp3");
     print $player->artist,"\n";
     $player->poll(1) until $player->state == 0;

     $player->load("http://x.y.z/kult.mp3");

     # see also mpg123sh from the tarball

DESCRIPTION
===========

   This is a frontend to the mpg123 player. It works by starting an
external mpg123 process with the `-R' option and feeding commands to it.

   While the standard mpg123 player can be used to play back mp3's using
this module you will encounter random deadlocks, due to bugs in its
communication code. Also, many features (like `statfreq') only work with
the included copy of mpg123, so better use that one before deciding that
this module is broken.

   (In case you wonder, the mpg123 author is not interested in including
these fixes and enhancements into mpg123).

METHODS
-------

   Most methods can be either BLOCKING (they wait until they get an answer,
which usually takes half a mpeg frame of playing time), NONBLOCKING (the
functions return as soon as they send their message, which is usallly
instant) or CACHING (the method returns some cached data which only gets
refreshed by an asynchronous STAT event or an explicit call to state).

new [parameter => value, ...]
     This creates a new player object and also starts the mpg123 process.
     New supports the following parameters:

          mpg123args      an arrayreg with additional arguments for the mpg123 process

load(<path or url>) [BLOCKING]
     Immediately loads the specified file (or url, http:// and file:///
     forms supported) and starts playing it. If you really want to play a
     file with a name starting with `file://' or `http://' then consider
     prefixing all your paths with `file:///'. Returns a true status when
     the song could be started, false otherwise.

stat [BLOCKING]
     This can be used to poll the player for it's current state (playing
     mode, frame position &c). As every other function that requires
     communication with mpg123, it might take up to one frame delay until
     the answer returns.  Using `statfreq' and infrequent calls to poll is
     often a better strategy.

pause [BLOCKING]
     Pauses or unpauses the song. state (or paused) can be used to find
     out about the current mode.

paused [CACHING]
     Returns the opposite of state, i.e. zero when something is playing
     and non-zero when the player is stopped or paused.

jump [BLOCKING]
     Jumps to the specified frame of the song. If the number is prefixed
     with "+" or "-", the jump is relative, otherweise it is absolute.

stop [BLOCKING]
     Stops the currently playing song and unloads it.

statfreq(rate) [NONBLOCKING]
     Sets the rate at which automatic frame updates are sent by mpg123. 0
     turns it off, everything else is the average number of frames between
     updates.  This can be a floating pount value, i.e.

          $player->statfreq(0.5/$player->tpf);

     will set two updates per second (one every half a second).

state [CACHING]
     Returns the current state of the player:

          0  stopped, not playing anything
          1  paused, song loaded but not playing
          2  playing, song loaded and playing

poll(<wait>) [BLOCKING or NONBLOCKING]
     Parses all outstanding events and status information. If wait is zero
     it will only parse as many messages as are currently in the queue, if
     it is one it will wait until at least one event occured.

     This can be used to wait for the end of a song, for example. This
     function should be called regularly, since mpg123 will stop playing
     when it can't write out events because the perl program is no longer
     listening...

title artist album year comment genre url type layer samplerate mode mode_extension bpf channels copyrighted error_protected title artist album year comment genre emphasis bitrate extension [CACHING]
     These accessor functions return information about the loaded song.
     Information about the artist, album, year, comment or genre might not
     be available and will be returned as undef.

tpf [CACHING]
     Returns the "time per frame", i.e. the time in seconds for one frame.
     Useful with the jump-method:

          $player->jump (60/$player->tpf);

     Jumps to second 60.

IN
     Returns the input filehandle from the mpg123 player. This can be used
     for selects() or poll().

AUTHOR
======

   Marc Lehmann <pcg@goof.com>.

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Audio/SoundFile,  Next: Audio/SoundFile/Header,  Prev: Audio/Play/MPG123,  Up: Module List

Perl interface to libsndfile, a sound I/O library
*************************************************

NAME
====

     Audio::SoundFile - Perl interface to libsndfile, a sound I/O library

SYNOPSIS
========

     use Audio::SoundFile;
     use Audio::SoundFile::Header;

     $header = new Audio::SoundFile::Header(...);
     $reader = new Audio::SoundFile::Reader(...);
     $writer = new Audio::SoundFile::Writer(...);
     ...

DESCRIPTION
===========

   This module provides interface to libsndfile, available from

     http://www.zip.com.au/~erikd/libsndfile/

   With this library, you will be able to read, write, and manipulate
sound data of more than 10 formats.

   Also, in addition to read/write interface using usual Perl scalar, this
module provides interface using PDL object directly. Since PDL provides
efficient method to handle large bytestream, sound processing is much
faster if this module and PDL is used in pair.

   For rest of the details, please consult each module's document.

NOTES
=====

   I have only tested the code with .au and .wav formats.

AUTHORS / CONTRIBUTORS
======================

   Taisuke Yamada <tai@imasy.or.jp>

COPYRIGHT
=========

   Copyright (C) 2001. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Audio/SoundFile/Header,  Next: Audio/SoundFile/Reader,  Prev: Audio/SoundFile,  Up: Module List

Interface to handle sound format information
********************************************

NAME
====

     Audio::SoundFile::Header - Interface to handle sound format information

SYNOPSIS
========

     use Audio::SoundFile::Header;

     $header = new Audio::SoundFile::Header(
        samplerate  => 44100,
        channels    => 1,
        format      => SF_FORMAT_WAV | SF_FORMAT_PCM,
     );

     die "Invalid format information" unless $header;
     die "Invalid format information" unless $header->set(channels => 2);
     die "Invalid format information" unless $header->format_check;

DESCRIPTION
===========

   This module provides abstract interface to handle sound format
information. It manages format information defined by sndfile.h in
libsndfile library.

   Currently, following methods are provided:

$header = new Audio::SoundFile::Header(%format_info);
     Constructor.

     Returns a class instance which is initialized by given format
     information. This automatically does sanity check of the info, and
     returns undef if the format structure is invalid.

$value = $header->get($name);
     Returns a value that corresponds with given parameter name.

$value = $header->set($name => $value, $name => $value, ...);
     Sets a value for given parameter name.

     If new format structure is invalid (contradicting parameters, etc),
     it discards all information passed, and returns an error. Original
     structure is retained in that case.

     Returns true on success, otherwise false.

$bool = $header->format_check;
     Runs sanity check on the format structure.  Returns true if format is
     valid, otherwise false.

AUTHORS / CONTRIBUTORS
======================

   Taisuke Yamada <tai@imasy.or.jp>

COPYRIGHT
=========

   Copyright (C) 2001. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Audio/SoundFile/Reader,  Next: Audio/SoundFile/Writer,  Prev: Audio/SoundFile/Header,  Up: Module List

Reader class for various sound formats
**************************************

NAME
====

     Audio::SoundFile::Reader - Reader class for various sound formats

SYNOPSIS
========

     use IO::Seekable;
     use Audio::SoundFile;

     $reader = new Audio::SoundFile::Reader($source, \$header);

     $length = $reader->bread_raw(\$buffer, $wanted);
     $length = $reader->bread_pdl(\$buffer, $wanted);

     $reader->fseek(1024, SEEK_SET);
     $reader->fseek(1024, SEEK_CUR);
     $reader->fseek(1024, SEEK_END);

     $reader->close;

DESCRIPTION
===========

   This module provides an interface to read various sound formats
supported by libsndfile.

   In addition to usual I/O interface, it provides direct interface to
create PDL object without making a copy of data in pure-Perl space. This
is an advantage on both speed and memory, and is a recommended way to
manipulate sound data.

   Currently supported methods are:

$reader = new Audio::SoundFile::Reader($source, \$header);
     Constructor.  Returns input stream object that reads from given
     source.

     Also assigns header information read from the source to passed scalar
     reference.

$reader->close;
     Closes input stream.  This object will be unusable after this method
     is called.

$offset = $reader->fseek($offset, $whence);
     Moves next reading position to a point where specified by $offset and
     $whence. Note $offset is not a length in bytes, but a number of
     frames to skip (frame is a block of data containing data of all
     channels at given moment).

     Return value (which should be a new position in number of frames) is
     currently unreliable.

$offset = $reader->bseek($offset, $whence);
     Moves next reading position to a point where specified by $offset and
     $whence. Note $offset is not a length in bytes, but a number of
     blocks to skip (block is a bulk of data containing data of single
     channel at given moment).

     Return value (which should be a new position in number of blocks) is
     currently unreliable.

$length = $reader->bread_raw(\$buffer, $wanted);
     Reads $wanted blocks of data, and stores it to $buffer as a Perl
     scalar. Content of $buffer is not guranteed on error.

     Returns length of the data actually stored, or 0 (or lesser value) on
     error.

$length = $reader->bread_pdl(\$buffer, $wanted);
     Reads $wanted blocks of data, and stores it to $buffer as a PDL
     object. Content of $buffer is not guranteed on error.

     Returns length of the data actually stored, or 0 (or lesser value) on
     error.

NOTES
=====

   If you mix bseek/bread and fseek/fread, things might get confusing due
to shift in internal offset - please do it with your responsibility.

AUTHORS / CONTRIBUTORS
======================

   Taisuke Yamada <tai@imasy.or.jp>

COPYRIGHT
=========

   Copyright (C) 2001. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Audio/SoundFile/Writer,  Next: Audio/Tools,  Prev: Audio/SoundFile/Reader,  Up: Module List

Writer class for various sound formats
**************************************

NAME
====

     Audio::SoundFile::Writer - Writer class for various sound formats

SYNOPSIS
========

     use Audio::SoundFile;
     use Audio::SoundFile::Header;

     $header = new Audio::SoundFile::Header(...);
     $writer = new Audio::SoundFile::Writer($target, $header);

     $length = $writer->bwrite_raw($buffer);
     $length = $writer->bwrite_pdl($buffer);

     $writer->fseek(1024, SEEK_SET); # seek by frame
     $writer->fseek(1024, SEEK_CUR); # seek by frame
     $writer->fseek(1024, SEEK_END); # seek by frame

     $writer->bseek(1024, SEEK_SET); # seek by block
     $writer->bseek(1024, SEEK_CUR); # seek by block
     $writer->bseek(1024, SEEK_END); # seek by block

     $writer->close;

DESCRIPTION
===========

   This module provides an interface to write various sound formats
supported by libsndfile.

   In addition to usual I/O interface, it provides direct interface to
write PDL object without making a copy of data in pure-Perl space. This is
an advantage on both speed and memory, and is a recommended way to handle
sound data.

   Currently supported methods are:

$writer = new Audio::SoundFile::Writer($target, $header);
     Constructor.  Returns output stream object that writes to given target
     in a format specified by $header.

$writer->close;
     Closes output stream.  This object will be unusable after this method
     is called.

$offset = $writer->fseek($offset, $whence);
     Moves next writing position to a point where specified by $offset and
     $whence. Note $offset is not a length in bytes, but a number of
     frames to skip (frame is a block of data containing data of all
     channels at given moment).

     Return value (which should be a new position in number of frames) is
     currently unreliable.

$offset = $writer->bseek($offset, $whence);
     Moves next writing position to a point where specified by $offset and
     $whence. Note $offset is not a length in bytes, but a number of
     blocks to skip (block is a bulk of data containing data of one
     channel at given moment).

     Return value (which should be a new position in number of blocks) is
     currently unreliable.

$length = $write->bwrite_raw($buffer, $wanted);
     Writes $wanted blocks of data from $buffer, which should be a Perl
     scalar.

     Returns length of the data actually written, or -1 on error.

$length = $reader->bwrite_pdl($buffer, $wanted);
     Writes $wanted blocks of data from $buffer, which should be a PDL
     object.

     Returns length of the data actually written, or -1 on error.

NOTES
=====

   If you mix bseek/bwrite and fseek/fwrite, things might get confusing
due to shift in internal offset - please do it with your responsibility.

AUTHORS / CONTRIBUTORS
======================

   Taisuke Yamada <tai@imasy.or.jp>

COPYRIGHT
=========

   Copyright (C) 2001. All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Audio/Tools,  Next: Audio/Tools/ByteOrder,  Prev: Audio/SoundFile/Writer,  Up: Module List

Common Tools for Audio::Wav, Audio::Mix & Audio::CoolEdit
*********************************************************

NAME
====

   Audio::Tools - Common Tools for Audio::Wav, Audio::Mix & Audio::CoolEdit

DESCRIPTION
===========

   The modules in this package are ByteOrder, Time & Fades.

   They are all independent and the only use, so far, for Audio::Tools is
a place to hold the documentation.

   ByteOrder is currently the unpacking rules for little endian machines,
I've seperated this from the other modules for ease of porting to big
endian machines.

   Fades is a collection of algorithms for fading in/ out audio files.

   Time is a collection of tools for conversion between time, samples &
bytes among other things.

AUTHOR
======

   Nick Peskett - nick@soup.demon.co.uk

SEE ALSO
========

   *Note Audio/Tools/ByteOrder: Audio/Tools/ByteOrder,

   *Note Audio/Tools/Time: Audio/Tools/Time,

   *Note Audio/Tools/Fades: Audio/Tools/Fades,

   *Note Audio/Wav: Audio/Wav,

   *Note Audio/Mix: Audio/Mix,

   *Note Audio/CoolEdit: Audio/CoolEdit,


File: pm.info,  Node: Audio/Tools/ByteOrder,  Next: Audio/Tools/Fades,  Prev: Audio/Tools,  Up: Module List

Unpacking rules for little endian machines.
*******************************************

NAME
====

   Audio::Tools::ByteOrder - Unpacking rules for little endian machines.

SYNOPSIS
========

     use Audio::Tools::ByteOrder;
     my $pack_order = new Audio::Tools::ByteOrder;
     my $pack_type = $pack_order -> pack_type(),
     my $pack_length = $pack_order -> pack_length(),

DESCRIPTION
===========

   This is currently the unpacking rules for little endian machines,

AUTHOR
======

   Nick Peskett - nick@soup.demon.co.uk

SEE ALSO
========

   *Note Audio/Tools: Audio/Tools,

METHODS
=======

new
---

   Returns a blessed Audio::Tools::ByteOrder object.

     my $pack_order = new Audio::Tools::ByteOrder;

pack_type
---------

   Returns a reference to a hash containing the pack types for various
data formats.

     my $pack_type = $pack_order -> pack_type(),

pack_length
-----------

   Returns a reference to a hash containing the packed lengths for various
data formats.

     my $pack_length = $pack_order -> pack_length(),


File: pm.info,  Node: Audio/Tools/Fades,  Next: Audio/Tools/Time,  Prev: Audio/Tools/ByteOrder,  Up: Module List

Fading in & out algorithms.
***************************

NAME
====

   Audio::Tools::Fades - Fading in & out algorithms.

DESCRIPTION
===========

   Fades is a collection of algorithms for fading in/ out audio files.

SYNOPSIS
========

     use Audio::Tools::Fades;

     my $up_to = 5;
     my @names = qw( in out );
     my $volume = 1;

     my $fades = new Audio::Tools::Fades;

     foreach my $type ( qw( linear exp invexp trig invtrig ) ) {
     	for my $direction ( 0, 1 ) {
     		my $fade = $fades -> fade( $up_to, $direction, $type );
     		print "fade $names[$direction] type: $type;\n\t";
     		for my $sample ( 0 .. $up_to ) {
     			printf ' %2d->%2.2f', $sample, &$fade( $sample, $volume );
     		}
     		print "\n";
     	}
     }

AUTHOR
======

   Nick Peskett - nick@soup.demon.co.uk

SEE ALSO
========

   *Note Audio/Wav: Audio/Wav,

   *Note Audio/Mix: Audio/Mix,

   *Note Audio/CoolEdit: Audio/CoolEdit,

METHODS
=======

new
---

   Returns a blessed Audio::Tools::Fades object.

     my $fades = new Audio::Tools::Fades;

fade
----

   Returns a reference to a subroutine that is initialised to the length
of samples the fade is to last for.  The subroutine returned takes the
current sample offset & the current sample value as parameters.  In the
example I have used sample value 1 so you can see the effect of the fade.

     my $fade = $fades -> fade( $length, $direction, $type );
     for my $sample ( 0 .. $length ) {
     	printf ' %2d->%2.2f', $sample, &$fade( $sample, 1 );
     }
     print "\n";

   Where;

     $length		= length of fade
     $direction	= 0 for in, 1 for out
     $type is one of;
     	linear	= smooth gradient
     	exp	= exponential (gets loud quickly)
     	invexp	= inverse exponential (gets loud slowly)
     	trig	= trigonomic, roughly in between linear & exp
     	invtrig	= inverse trigonomic


File: pm.info,  Node: Audio/Tools/Time,  Next: Audio/Wav,  Prev: Audio/Tools/Fades,  Up: Module List

time / sample / byte conversion tools.
**************************************

NAME
====

   Audio::Tools::Time - time / sample / byte conversion tools.

DESCRIPTION
===========

   Tools for converting bytes into samples, samples into time etc.

SYNOPSIS
========

     my $time = new Audio::Tools::Time 44100, 16, 2;
     my $bytes = $time -> nice_bytes( 11025 );
     my $sample = $time -> bytes_to_samples( $bytes );
     my $secs = $time -> samples_to_seconds( $sample );
     my( $mins, $secs, $fract_secs )
     	= $time -> split_time( $secs );
     my $dao_time = $time -> dao_time( $secs );

AUTHOR
======

   Nick Peskett - nick@soup.demon.co.uk

SEE ALSO
========

   *Note Audio/Wav: Audio/Wav,

   *Note Audio/Mix: Audio/Mix,

   *Note Audio/CoolEdit: Audio/CoolEdit,

METHODS
=======

new
---

   Returns a blessed Audio::Tools::Time object.

     my $time = new Audio::Tools::Time sample_rate, bits_per_sample, channels;

   Where;

     sample_rate	= number of samples per second (44100 is cd quality)
     bits_per_sample	= number of bits per samples (16 is cd quality)
     channels	= number of channels of sound (stereo is 2)

samples_to_bytes
----------------

   Converts a sample offset to it's byte offset.

     my $bytes = $time -> samples_to_bytes( $sample );

bytes_to_samples
----------------

   Converts a byte offset to it's sample offset.

     my $sample = $time -> bytes_to_samples( $bytes );

samples_to_seconds
------------------

   Converts a sample offset to it's position as floating point seconds.

     my $secs = $time -> samples_to_seconds( $sample );

bytes_to_seconds
----------------

   Converts a byte offset to it's position as floating point seconds.

     my $secs = $time -> bytes_to_seconds( $samples );

seconds_to_samples
------------------

   Converts a position in seconds (can be floating point) to it's sample
offset.

     my $sample = $time -> seconds_to_samples( $secs );

seconds_to_bytes
----------------

   Converts a position in seconds (can be floating point) to it's byte
offset.

     my $sample = $time -> seconds_to_bytes( $secs );

nice_bytes
----------

   Rounds down a byte offset to a appropriate byte offset for the current
settings.

     $bytes = $time -> nice_bytes( $bytes );

split_time
----------

   Converts a floating point seconds position to minutes, seconds &
fractional seconds.

     my( $mins, $secs, $fract_secs )
     	= $time -> split_time( $secs );

dao_time
--------

   Converts a floating point seconds position to a string containing the
format used by disk-at-once & CDRWin.  (`http:' in this node)

     my $dao_time = $time -> dao_time( $secs );

nice_time
---------

   Converts a floating point seconds position into a string that verbosely
describes the time. If $terse is true then the output will only show the
most significant value (to one decimal place if hour or minute).

     print $time -> nice_time( 90 );
     # returns "1 min, 30 secs"
     print $time -> nice_time( 90, 1 );
     # returns "1.5 mins"

dao_cue_file
------------

   Writes a cue file in the format used by disk-at-once & CDRWin.
(`http:' in this node)

     $time -> dao_cue_file( $breaks, './audio.wav', './output.cue' );

   Where $breaks is a reference to an array of byte offsets.

block_align
-----------

   Returns the current block alignment, ie 44.1khz 16 bit stereo: 1 sample
= 4 bytes

     my block_align = $time -> block_align();


