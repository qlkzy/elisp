This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Bio/Search/Processor/Fasta,  Next: Bio/Search/Processor/ProcessorI,  Prev: Bio/Search/Processor,  Up: Module List

Processor of Fasta-generated data streams
*****************************************

NAME
====

   Bio::Search::Processor::Fasta - Processor of Fasta-generated data
streams

SYNOPSIS
========

   use Bio::Search::Processor

   my $processor = new Bio::Search::Processor -file      => 'mysearchrun',
                                          -algorithm => 'Fasta';

DESCRIPTION
===========

   A Processor object is used to generate Bio::Search::Result::* objects,
given a source of Search data (a file or filehandle).  The Processor
object works very much like the SeqIO system: once initialized with the
new() method, the Processor object will continue to yield as many Result
objects as are available from the data source (for single "runs" this is
often only one Result object).

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     bioperl-guts-l@bioperl.org        - Automated bug and CVS messages
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Aaron Mackey
=====================

   Email amackey@virginia.edu

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

next_result
-----------

     Title   : next_result
     Usage   : $result = $processor->next_result()
     Function: Used to obtain Result objects from a FASTA-generated data source
     Returns : a Bio::Search::Result::Fasta object
     Args    : <none>


File: pm.info,  Node: Bio/Search/Processor/ProcessorI,  Next: Bio/Search/Result/Fasta,  Prev: Bio/Search/Processor/Fasta,  Up: Module List

Abstract Interface for Processor Objects
****************************************

NAME
====

   Bio::Search::Processor::ProcessorI - Abstract Interface for Processor
Objects

SYNOPSIS
========

   use Bio::Search::Processor

   my $processor = new Bio::Search::Processor -file      => 'mysearchrun',
                                          -algorithm => 'Blast';

   while ($result = $processor->next_result()) {

     $id = $result->get_query_id();
     $lib = $result->get_library_name();
     $size = $result->get_library_size();

     foreach $hit ( $result->get_hits() ) {
         $matchid = $hit->get_id();
         $matchdesc = $hit->get_desc();
         # etc, etc, do stuff.
     }
     }

DESCRIPTION
===========

   A Processor object is used to generate Bio::Search::Result::* objects,
given a source of Search data (a file or filehandle).  The Processor
object works very much like the SeqIO system: once initialized with the
new() method, the Processor object will continue to yield as many Result
objects as are available from the data source (for single "runs" this is
often only one Result object).

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     bioperl-guts-l@bioperl.org        - Automated bug and CVS messages
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Aaron Mackey
=====================

   Email amackey@virginia.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

next_result
-----------

     Title   : next_result
     Usage   : $result = $processor->next_result()
     Function: Returns the next Bio::Search::Result::* object available from
               the provided data stream or undef if no more are available.
     Returns : Bio::Search::Result object
     Args    : <none>


File: pm.info,  Node: Bio/Search/Result/Fasta,  Next: Bio/Search/Result/ResultI,  Prev: Bio/Search/Processor/ProcessorI,  Up: Module List

Result object for FASTA-generated data sources
**********************************************

NAME
====

   Bio::Search::Result::Fasta - Result object for FASTA-generated data
sources

SYNOPSIS
========

     These objects are generated automatically by Bio::Search::Processor::Fasta,
     and shouldn't be used directly.

DESCRIPTION
===========

   Bio::Search::Result::* objects are data structures containing the
results from the execution of a search algorithm.  As such, it may contain
various algorithm specific information as well as details of the
execution, but will contain a few fundamental elements, including the
ability to return Bio::Search::Hit::* objects.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     bioperl-guts-l@bioperl.org        - Automated bug and CVS messages
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Aaron Mackey
=====================

   Email amackey@virginia.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _


File: pm.info,  Node: Bio/Search/Result/ResultI,  Next: Bio/SearchDist,  Prev: Bio/Search/Result/Fasta,  Up: Module List

Abstract interface to Result objects
************************************

NAME
====

     Bio::Search::Result::ResultI.pm - Abstract interface to Result objects

SYNOPSIS
========

     These objects are generated automatically by Bio::Search::Processor
     objects, and wouldn't be used directly.

DESCRIPTION
===========

   Bio::Search::Result::* objects are data structures containing the
results from the execution of a search algorithm.  As such, it may contain
various algorithm specific information as well as details of the
execution, but will contain a few fundamental elements, including the
ability to return Bio::Search::Hit::* objects.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     bioperl-guts-l@bioperl.org        - Automated bug and CVS messages
     http://bioperl.org/MailList.shtml - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Aaron Mackey
=====================

   Email amackey@virginia.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

get_query_id
------------

     Title   : get_query_id
     Usage   : $id = $result->get_query_id();
     Function: Used to obtain the string identifier of the query used by the
               algorithm.
     Returns : a scalar string.
     Args    : <none>

get_library_name
----------------

     Title   : get_library_name
     Usage   : $name = $result->get_library_name()
     Function: Used to obtain the name of the library that the query was searched
               against by the algorithm.
     Returns : a scalar string
     Args    : <none>

get_library_size
----------------

     Title   : get_library_size
     Usage   : $size = $result->get_library_size()
     Function: Used to obtain the size of library that was searched against.
     Returns : a scalar integer (units specific to algorithm, but probably the
               total number of residues in the library, if available) or undef if
               the information was not available to the Processor object.
     Args    : <none>

get_library_count
-----------------

     Title   : get_library_count
     Usage   : $count = $result->get_library_count()
     Function: Used to obtain the number of entries contained in the library.
     Returns : a scalar integer representing the number of entities in the library
               or undef if the information was not available.
     Args    : <none>

get_hits
--------

     Title   : get_hits
     Usage   : @hits = $result->get_hits();
     Function: Used to obtain the array of hit objects, representing potential
               matches between the query and various entities from the library.
     Returns : an array of Bio::Search::Hit::* object (specific type depends on
               algorithm), or undef if there were none.
     Args    : <none>


File: pm.info,  Node: Bio/SearchDist,  Next: Bio/Seq,  Prev: Bio/Search/Result/ResultI,  Up: Module List

A perl wrapper around Sean Eddy's histogram object
**************************************************

NAME
====

   Bio::SearchDist - A perl wrapper around Sean Eddy's histogram object

SYNOPSIS
========

     $dis = Bio::SearchDist->new();
     foreach $score ( @scores ) {
        $dis->add_score($score);
     }

     if( $dis->fit_evd() ) {
       foreach $score ( @scores ) {
         $evalue = $dis->evalue($score);
         print "Score $score had an evalue of $evalue\n";
       }
     } else {
       warn("Could not fit histogram to an EVD!");
     }

DESCRIPTION
===========

   The Bio::SearchDist object is a wrapper around Sean Eddy's excellent
histogram object. The histogram object can bascially take in a number of
scores which are sensibly distributed somewhere around 0 that come from a
supposed Extreme Value Distribution. Having add all the scores from a
database search via the add_score method you can then fit a extreme value
distribution using fit_evd(). Once fitted you can then get out the evalue
for each score (or a new score) using evalue($score).

   The fitting procedure is better described in Sean Eddy's own code
(available from http://hmmer.wustl.edu, or in the histogram.h header file
in Compile/SW). Bascially it fits a EVD via a maximum likelhood method
with pruning of the top end of the distribution so that real positives are
discarded in the fitting procedure. This comes from an orginally idea of
Richard Mott's and the likelhood fitting is from a book by Lawless [should
ref here].

   The object relies on the fact that the scores are sensibly distributed
around about 0 and that integer bins are sensible for the histogram.
Scores based on bits are often ideal for this (bits based scoring
mechanisms is what this histogram object was originally designed for).

CONTACT
=======

   The original code this was based on comes from the histogram module as
part of the HMMer2 package. Look at http://hmmer.wustl.edu/

   Its use in Bioperl is via the Compiled XS extension which is cared for
by Ewan Birney (birney@sanger.ac.uk). Please contact Ewan first about the
use of this module

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

add_score
---------

     Title   : add_score
     Usage   : $dis->add_score(300);
     Function: Adds a single score to the distribution
     Returns : nothing
     Args    :

fit_evd
-------

     Title   : fit_evd
     Usage   : $dis->fit_evd();
     Function: fits an evd to the current distribution
     Returns : 1 if it fits successfully, 0 if not
     Args    :

fit_Gaussian
------------

     Title   : fit_Gaussian
     Usage   :
     Function:
     Example :
     Returns :
     Args    :

evalue
------

     Title   : evalue
     Usage   : $eval = $dis->evalue($score)
     Function: Returns the evalue of this score
     Returns : float
     Args    :

_engine
-------

     Title   : _engine
     Usage   : $obj->_engine($newval)
     Function: underlyine bp_sw:: histogram engine
     Returns : value of _engine
     Args    : newvalue (optional)


File: pm.info,  Node: Bio/Seq,  Next: Bio/Seq/LargePrimarySeq,  Prev: Bio/SearchDist,  Up: Module List

Sequence object, with features
******************************

NAME
====

   Bio::Seq - Sequence object, with features

SYNOPSIS
========

     $seqio  = Bio::SeqIO->new ( '-format' => 'embl' , -file => 'myfile.dat');
     $seqobj = $seqio->next_seq();

     # features must implement Bio::SeqFeatureI

     @features = $seqobj->top_SeqFeatures(); # just top level
     @features = $seqobj->all_SeqFeatures(); # descend into sub features

     $seq      = $seqobj->seq(); # actual sequence as a string
     $seqstr   = $seqobj->subseq(10,50);
     $ann      = $seqobj->annotation(); # annotation object

DESCRIPTION
===========

   A Seq object is a sequence with sequence features placed on them. The
Seq object contains a PrimarySeq object for the actual sequence and also
implements its interface.

   In bioperl we have 3 main players that people are going to use

     Bio::PrimarySeq - just the sequence and its names, nothing else.
     Bio::SeqFeatureI - a location on a sequence, potentially with a sequence.
                       and annotation
     Bio::Seq        - A sequence and a collection of seqfeatures (an aggregate) with
                       its own annotation.

   Although bioperl is not tied to file formats heavily, these
distinctions do map to file formats sensibly and for some
bioinformaticians this might help you:

     Bio::PrimarySeq - Fasta file of a sequence
     Bio::SeqFeatureI - A single entry in an EMBL/GenBank/DDBJ feature table
     Bio::Seq        - A single EMBL/GenBank/DDBJ entry

   By having this split we avoid alot of nasty ciricular references
(seqfeatures can hold a reference to a sequence without the sequence
holding a reference to the seqfeature).

   Ian Korf really helped in the design of the Seq and SeqFeature system.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                 - General discussion
     http://bio.perl.org/MailList.html  - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bioperl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney, inspired by Ian Korf objects
==================================================

   Email birney@sanger.ac.uk

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
---

     Title   : new
     Usage   : $seq    = Bio::Seq->new( -seq => 'ATGGGGGTGGTGGTACCCT',
                                        -id  => 'human_id',
     				    -accession_number => 'AL000012',
     				   );

     Function: Returns a new seq object from
               basic constructors, being a string for the sequence
               and strings for id and accession_number
     Returns : a new Bio::Seq object

PrimarySeq interface
====================

   The primaryseq interface is the basic sequence getting and setting
methods found on all sequences.

   These methods implement the PrimarySeq interface by delegating to the
primary_seq inside the object. This means that you can use a Seq object
wherever there is a PrimarySeq, and of course, you are free to use these
functions anyway.

seq
---

     Title   : seq
     Usage   : $string    = $obj->seq()
     Function: Returns the sequence as a string of letters. The
               case of the letters is left up to the implementer.
               Suggested cases are upper case for proteins and lower case for
               DNA sequence (IUPAC standard),
               but implementations are suggested to keep an open mind about
               case (some users... want mixed case!)
     Returns : A scalar

length
------

     Title   : length
     Usage   : $len = $seq->length()
     Function:
     Example :
     Returns : integer representing the length of the sequence.
     Args    :

subseq
------

     Title   : subseq
     Usage   : $substring = $obj->subseq(10,40);
     Function: returns the subseq from start to end, where the first base
               is 1 and the number is inclusive, ie 1-2 are the first two
               bases of the sequence

     Start cannot be larger than end but can be equal

     Returns : a string
     Args    :

display_id
----------

     Title   : display_id
     Usage   : $id_string = $obj->display_id($newid);
     Function: returns or sets the display id, aka the common name of the
               Sequence object.

     The semantics of this is that it is the most likely string
     to be used as an identifier of the sequence, and likely to
     have "human" readability.  The id is equivalent to the ID
     field of the GenBank/EMBL databanks and the id field of the
     Swissprot/sptrembl database. In fasta format, the >(\S+) is
     presumed to be the id, though some people overload the id
     to embed other information. Bioperl does not use any
     embedded information in the ID field, and people are
     encouraged to use other mechanisms (accession field for
     example, or extending the sequence object) to solve this.

     Notice that $seq->id() maps to this function, mainly for
     legacy/convience issues
      Returns : A string
      Args    : newid (optional)

accession_number
----------------

     Title   : accession_number
     Usage   : $unique_biological_key = $obj->accession_number;
     Function: Returns the unique biological id for a sequence, commonly
               called the accession_number. For sequences from established
               databases, the implementors should try to use the correct
               accession number. Notice that primary_id() provides the
               unique id for the implemetation, allowing multiple objects
               to have the same accession number in a particular implementation.

     For sequences with no accession number, this method should return
     "unknown".
      Returns : A string
      Args    : None

desc
----

     Title   : desc
     Usage   : $seqobj->desc()
     Function: Sets/Gets the description of the sequnce
     Example :
     Returns :
     Args    :

primary_id
----------

     Title   : primary_id
     Usage   : $unique_implementation_key = $obj->primary_id;
     Function: Returns the unique id for this object in this
               implementation. This allows implementations to manage
               their own object ids in a way the implementaiton can control
               clients can expect one id to map to one object.

     For sequences with no natural id, this method should return
     a stringified memory location.

     Also notice that this method is B<not> delegated to the
     internal PrimarySeq object
      Returns : A string
      Args    : None

can_call_new
------------

     Title   : can_call_new
     Usage   : if( $obj->can_call_new ) {
                 $newobj = $obj->new( %param );
     	   }
     Function: can_call_new returns 1 or 0 depending
               on whether an implementation allows new
               constructor to be called. If a new constructor
               is allowed, then it should take the followed hashed
               constructor list.

     $myobject->new( -seq => $sequence_as_string,
     			   -display_id  => $id
     			   -accession_number => $accession
     			   -moltype => 'dna',
     			   );
      Example :
      Returns : 1 or 0
      Args    :

moltype
-------

     Title   : moltype
     Usage   : if( $obj->moltype eq 'dna' ) { /Do Something/ }
     Function: Returns the type of sequence being one of
               'dna', 'rna' or 'protein'. This is case sensitive.

     This is not called <type> because this would cause
     upgrade problems from the 0.5 and earlier Seq objects.

     Returns : a string either 'dna','rna','protein'. NB - the object must
               make a call of the type - if there is no type specified it
               has to guess.
     Args    : none

Methods provided in the Bio::PrimarySeqI interface
==================================================

   These methods are inherited from the PrimarySeq interface and work as
one expects, building new Bio::Seq objects or other information as
expected.

   Sequence Features are not transfered to the new objects.  This is
possibly a mistake. Anyone who feels the urge in dealing with this is
welcome to give it a go.

revcom
------

     Title   : revcom
     Usage   : $rev = $seq->revcom()
     Function: Produces a new Bio::Seq object which
               is the reversed complement of the sequence. For protein
               sequences this throws an exception of "Sequence is a protein. Cannot revcom"

     The id is the same id as the orginal sequence, and the accession number
     is also indentical. If someone wants to track that this sequence has be
     reversed, it needs to define its own extensions

     To do an inplace edit of an object you can go:

     $seq = $seq->revcom();

     This of course, causes Perl to handle the garbage collection of the old
     object, but it is roughly speaking as efficient as an inplace edit.

     Returns : A new (fresh) Bio::Seq object
     Args    : none

trunc
-----

     Title   : trunc
     Usage   : $subseq = $myseq->trunc(10,100);
     Function: Provides a truncation of a sequence,

     Example :
     Returns : a fresh Bio::Seq object
     Args    :

id
--

     Title   : id
     Usage   : $id = $seq->id()
     Function: This is mapped on display_id
     Example :
     Returns :
     Args    :

Seq only methods
================

   These methods are specific to the Bio::Seq object, and not found on the
Bio::PrimarySeq object

primary_seq
-----------

     Title   : primary_seq
     Usage   : $obj->primary_seq($newval)
     Function:
     Example :
     Returns : value of primary_seq
     Args    : newvalue (optional)

annotation
----------

     Title   : annotation
     Usage   : $obj->annotation($seq_obj)
     Function:
     Example :
     Returns : value of annotation
     Args    : newvalue (optional)

add_SeqFeature
--------------

     Title   : add_SeqFeature
     Usage   : $seq->add_SeqFeature($feat);
               $seq->add_SeqFeature(@feat);
     Function: Adds the given feature object (or each of an array of feature
               objects to the feature array of this
               sequence. The object passed is required to implement the
               Bio::SeqFeatureI interface.
     Example :
     Returns : TRUE on success
     Args    : A Bio::SeqFeatureI implementing object, or an array of such objects.

top_SeqFeatures
---------------

     Title   : top_SeqFeatures
     Usage   : @feat_ary = $seq->top_SeqFeatures();
     Function: Returns the array of top-level features for this sequence object.
               Features which are not top-level are subfeatures of one or more
               of the returned feature objects, which means that you must
               traverse the subfeature arrays of each top-level feature object
               in order to traverse all features associated with this sequence.

     Use all_SeqFeatures() if you want the feature tree flattened into
     one single array.
      Example :
      Returns : An array of Bio::SeqFeatureI implementing objects.
      Args    :

all_SeqFeatures
---------------

     Title   : all_SeqFeatures
     Usage   : @feat_ary = $seq->all_SeqFeatures();
     Function: Returns the tree of feature objects attached to this sequence
               object flattened into one single array. Top-level features will
               still contain their subfeature-arrays, which means that you
               will encounter subfeatures twice if you traverse the subfeature
               tree of the returned objects.

     Use top_SeqFeatures() if you want the array to contain only the
     top-level features.
      Example :
      Returns : An array of Bio::SeqFeatureI implementing objects.
      Args    :

feature_count
-------------

     Title   : feature_count
     Usage   : $seq->feature_count()
     Function: Return the number of SeqFeatures attached to a sequence
     Example :
     Returns : number of SeqFeatures
     Args    : none

species
-------

     Title   : species
     Usage   :
     Function: Gets or sets the species
     Example : $species = $self->species();
     Returns : Bio::Species object
     Args    : Bio::Species object or none;


File: pm.info,  Node: Bio/Seq/LargePrimarySeq,  Next: Bio/Seq/LargeSeq,  Prev: Bio/Seq,  Up: Module List

PrimarySeq object that stores sequence as files in the tempdir (as found by File::Temp) or the default method in Bio::Root::RootI
*********************************************************************************************************************************

NAME
====

   Bio::Seq::LargePrimarySeq - PrimarySeq object that stores sequence as
files in the tempdir (as found by File::Temp) or the default method in
Bio::Root::RootI

SYNOPSIS
========

     # normal primary seq usage

DESCRIPTION
===========

   This object stores a sequence as a series of files in a temporary
directory. The aim is to allow someone the ability to store very large
sequences (eg, > 100MBases) in a file system without running out of memory
(eg, on a 64 MB real memory machine!).

   Of course, to actually make use of this functionality, the programs
which use this object must not call $primary_seq->seq otherwise the entire
sequence will come out into memory and probably paste your machine.
However, calls $primary_seq->subseq(10,100) will cause only 90 characters
to be brought into real memory.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org               - General discussion
     http://bio.perl.org/MailList.html   - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney, Jason Stajich
===================================

   Email birney@ebi.ac.uk Email jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

seq
---

     Title   : seq
     Usage   :
     Function:
     Example :
     Returns :
     Args    :

subseq
------

     Title   : subseq
     Usage   :
     Function:
     Example :
     Returns :
     Args    :

add_sequence_as_string
----------------------

     Title   : add_sequence_as_string
     Usage   :
     Function:
     Example :
     Returns :
     Args    :

_filename
---------

     Title   : _filename
     Usage   : $obj->_filename($newval)
     Function:
     Example :
     Returns : value of _filename
     Args    : newvalue (optional)


File: pm.info,  Node: Bio/Seq/LargeSeq,  Next: Bio/Seq/RichSeq,  Prev: Bio/Seq/LargePrimarySeq,  Up: Module List

SeqI compliant object that stores sequence as files in /tmp
***********************************************************

NAME
====

   Bio::Seq::LargeSeq - SeqI compliant object that stores sequence as
files in /tmp

SYNOPSIS
========

     # normal primary seq usage

DESCRIPTION
===========

   This object stores a sequence as a series of files in a temporary
directory. The aim is to allow someone the ability to store very large
sequences (eg, > 100MBases) in a file system without running out of memory
(eg, on a 64 MB real memory machine!).

   Of course, to actually make use of this functionality, the programs
which use this object must not call $primary_seq->seq otherwise the entire
sequence will come out into memory and probably paste your machine.
However, calls $primary_seq->subseq(10,100) will cause only 90 characters
to be brought into real memory.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://www.bioperl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email birney@ebi.ac.uk

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

trunc
-----

     Title   : trunc
     Usage   : $subseq = $myseq->trunc(10,100);
     Function: Provides a truncation of a sequence,

     Example :
     Returns : a fresh Bio::SeqI object
     Args    :


File: pm.info,  Node: Bio/Seq/RichSeq,  Next: Bio/Seq/RichSeqI,  Prev: Bio/Seq/LargeSeq,  Up: Module List

Module implementing a sequence created from a rich sequence database entry
**************************************************************************

NAME
====

   Bio::Seq::RichSeq - Module implementing a sequence created from a rich
sequence database entry

SYNOPSIS
========

   See Bio::Seq::RichSeqI and documentation of methods.

DESCRIPTION
===========

   This module implements Bio::Seq::RichSeqI, an interface for sequences
created from or created for entries from/of rich sequence databanks, like
EMBL, GenBank, and SwissProt. Methods added to the Bio::SeqI interface
therefore focus on databank-specific information. Note that not every rich
databank format may use all of the properties provided.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                 - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email birney@ebi.ac.uk

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
---

     Title   : new
     Usage   : $seq    = Bio::Seq::RichSeq->new( -seq => 'ATGGGGGTGGTGGTACCCT',
                                                 -id  => 'human_id',
     				             -accession_number => 'AL000012',
     				            );

     Function: Returns a new seq object from
               basic constructors, being a string for the sequence
               and strings for id and accession_number
     Returns : a new Bio::Seq::RichSeq object

division
--------

     Title   : division
     Usage   : $obj->division($newval)
     Function:
     Returns : value of division
     Args    : newvalue (optional)

molecule
--------

     Title   : molecule
     Usage   : $obj->molecule($newval)
     Function:
     Returns : type of molecule (DNA, mRNA)
     Args    : newvalue (optional)

add_date
--------

     Title   : add_date
     Usage   : $self->add_date($datestr)
     Function: adds a date
     Example :
     Returns : a date string or an array of such strings
     Args    :

get_dates
---------

     Title   : get_dates
     Usage   :
     Function:
     Example :
     Returns : an array of date strings
     Args    :

pid
---

     Title   : pid
     Usage   :
     Function: Get (and set, depending on the implementation) the PID property
               for the sequence.
     Example :
     Returns : a string
     Args    :

accession
---------

     Title   : accession
     Usage   : $obj->accession($newval)
     Function: Whilst the underlying sequence object does not
               have an accession, so we need one here.

     In this implementation this is merely a synonym for
     accession_number().
      Example :
      Returns : value of accession
      Args    : newvalue (optional)

add_secondary_accession
-----------------------

     Title   : add_secondary_accession
     Usage   : $self->add_domment($ref)
     Function: adds a secondary_accession
     Example :
     Returns :
     Args    : a string or an array of strings

get_secondary_accessions
------------------------

     Title   : get_secondary_accessions
     Usage   :
     Function:
     Example :
     Returns : An array of strings
     Args    :

seq_version
-----------

     Title   : seq_version
     Usage   : $obj->seq_version($newval)
     Function:
     Example :
     Returns : value of seq_version
     Args    : newvalue (optional)

keywords
--------

     Title   : keywords
     Usage   : $obj->keywords($newval)
     Function:
     Returns : value of keywords (a string)
     Args    : newvalue (optional) (a string)


File: pm.info,  Node: Bio/Seq/RichSeqI,  Next: Bio/SeqAnalysisParserI,  Prev: Bio/Seq/RichSeq,  Up: Module List

RichSeq interface, mainly for database orientated sequences
***********************************************************

NAME
====

   Bio::Seq::RichSeqI - RichSeq interface, mainly for database orientated
sequences

SYNOPSIS
========

     @secondary   = $richseq->get_secondary_accessions;
     $division    = $richseq->division;
     $mol         = $richseq->molecule;
     @dates       = $richseq->get_dates;
     $seq_version = $richseq->seq_version;
     $pid         = $richseq->pid;

DESCRIPTION
===========

   This interface extends the Bio::SeqI interface to give additional
functionality to sequences with richer data sources, in particular from
database sequences (EMBL, GenBank and Swissprot).

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                 - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Ewan Birney
====================

   Email birney@ebi.ac.uk

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

get_secondary_accessions
------------------------

     Title   : get_secondary_accessions
     Usage   :
     Function: Get the secondary accessions for a sequence.
     Example :
     Returns : an array of strings
     Args    : none

division
--------

     Title   : division
     Usage   :
     Function: Get (and set, depending on the implementation) the divison for
               a sequence.

     Examples from GenBank are PLN (plants), PRI (primates), etc.
      Example :
      Returns : a string
      Args    :

molecule
--------

     Title   : molecule
     Usage   :
     Function: Get (and set, depending on the implementation) the molecule
               type for the sequence.

     This is not necessarily the same as Bio::PrimarySeqI::moltype(),
     because it is databank-specific.
      Example :
      Returns : a string
      Args    :

pid
---

     Title   : pid
     Usage   :
     Function: Get (and set, depending on the implementation) the PID property
               for the sequence.
     Example :
     Returns : a string
     Args    :

get_dates
---------

     Title   : get_dates
     Usage   :
     Function: Get (and set, depending on the implementation) the dates the
               databank entry specified for the sequence
     Example :
     Returns : an array of strings
     Args    :

seq_version
-----------

     Title   : seq_version
     Usage   :
     Function: Get (and set, depending on the implementation) the version string
               of the sequence.
     Example :
     Returns : a string
     Args    :


File: pm.info,  Node: Bio/SeqAnalysisParserI,  Next: Bio/SeqFeature/FeaturePair,  Prev: Bio/Seq/RichSeqI,  Up: Module List

Sequence analysis output parser interface
*****************************************

NAME
====

   Bio::SeqAnalysisParserI - Sequence analysis output parser interface

SYNOPSIS
========

     # get a SeqAnalysisParserI somehow, e.g. by
     my $parser = Bio::Factory::SeqAnalysisParserFactory->get_parser(
                             '-input' => 'inputfile', '-method' => 'genscan');
     while( my $feature = $parser->next_feature() ) {
     	print "Feature from ", $feature->start, " to ", $feature->end, "\n";
     }

DESCRIPTION
===========

   SeqAnalysisParserI is a generic interface for describing sequence
analysis result parsers. Sequence analysis in this sense is a search for
similarities or the identification of features on the sequence, like a
databank search or a a gene prediction result.

   The concept behind this interface is to have a generic interface in
sequence annotation pipelines (as used e.g. in high-throughput automated
sequence annotation). This interface enables plug-and-play for new analysis
methods and their corresponding parsers without the necessity for modifying
the core of the annotation pipeline. In this concept the annotation
pipeline has to rely on only a list of methods for which to process the
results, and a factory from which it can obtain the corresponding parser
implementing this interface.

   See Bio::Factory::SeqAnalysisParserFactoryI and
Bio::Factory::SeqAnalysisParserFactory for interface and an implementation
of the corresponding factory.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org                - General discussion
     http://bio.perl.org/MailList.html    - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp, Jason Stajich
===================================

   Email Hilmar Lapp <hlapp@gmx.net>, Jason Stajich <jason@chg.mc.duke.edu>

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
---

     Title   : new
     Remark  : Classes implementing this interface are expected to implement
               recognition of at least the following named parameters:
               -file     input file (alternative to -fh)
               -fh       input stream (alternative to -file)

next_feature
------------

     Title   : next_feature
     Usage   : $seqfeature = $obj->next_feature();
     Function: Returns the next feature available in the analysis result, or
               undef if there are no more features.
     Example :
     Returns : A Bio::SeqFeatureI implementing object, or undef if there are no
               more features.
     Args    : none


File: pm.info,  Node: Bio/SeqFeature/FeaturePair,  Next: Bio/SeqFeature/Gene/Exon,  Prev: Bio/SeqAnalysisParserI,  Up: Module List

hold pair feature information e.g. blast hits
*********************************************

NAME
====

   Bio::SeqFeature::FeaturePair - hold pair feature information e.g. blast
hits

SYNOPSIS
========

     my $feat  = new Bio::SeqFeature::FeaturePair(-feature1 => $f1,
     						 -feature2 => $f2,
     					      );

     # Bio::SeqFeatureI methods can be used

     my $start = $feat->start;
     my $end   = $feat->end;

     # Bio::FeaturePair methods can be used
     my $hstart = $feat->hstart;
     my $hend   = $feat->hend;

     my $feature1 = $feat->feature1;  # returns feature1 object

DESCRIPTION
===========

   A sequence feature object where the feature is itself a feature on
another sequence - e.g. a blast hit where residues 1-40 of a protein
sequence SW:HBA_HUMAN has hit to bases 100 - 220 on a genomic sequence
HS120G22.  The genomic sequence coordinates are used to create one
sequence feature $f1 and the protein coordinates are used to create
feature $f2.  A FeaturePair object can then be made

     my $fp = new Bio::SeqFeature::FeaturePair(-feature1 => $f1,   # genomic
     					      -feature2 => $f2,   # protein
     					      );

   This object can be used as a standard Bio::SeqFeatureI in which case

     my $gstart = $fp->start  # returns start coord on feature1 - genomic seq.
     my $gend   = $fp->end    # returns end coord on feature1.

   In general standard Bio::SeqFeatureI method calls return information in
feature1.

   Data in the feature 2 object are generally obtained using the standard
methods prefixed by h (for hit!)

     my $pstart = $fp->hstart # returns start coord on feature2 = protein seq.
     my $pend   = $fp->hend   # returns end coord on feature2.

   If you wish to swap feature1 and feature2 around :

     $feat->invert

   so...

     $feat->start # etc. returns data in $feature2 object

   No sub_SeqFeatures or tags can be stored in this object directly.  Any
features or tags are expected to be stored in the contained objects
feature1, and feature2.

CONTACT
=======

   Ewan Birney <birney@sanger.ac.uk>

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

feature1
--------

     Title   : feature1
     Usage   : $f = $featpair->feature1
               $featpair->feature1($feature)
     Function: Get/set for the query feature
     Returns : Bio::SeqFeatureI
     Args    : Bio::SeqFeatureI

feature2
--------

     Title   : feature2
     Usage   : $f = $featpair->feature2
               $featpair->feature2($feature)
     Function: Get/set for the hit feature
     Returns : Bio::SeqFeatureI
     Args    : Bio::SeqFeatureI

start
-----

     Title   : start
     Usage   : $start = $featpair->start
               $featpair->start(20)
     Function: Get/set on the start coordinate of feature1
     Returns : integer
     Args    : [optional] beginning of feature

end
---

     Title   : end
     Usage   : $end = $featpair->end
               $featpair->end($end)
     Function: get/set on the end coordinate of feature1
     Returns : integer
     Args    : [optional] ending point of feature

strand
------

     Title   : strand
     Usage   : $strand = $feat->strand()
               $feat->strand($strand)
     Function: get/set on strand information, being 1,-1 or 0
     Returns : -1,1 or 0
     Args    : [optional] strand information to set

location
--------

     Title   : location
     Usage   : $location = $featpair->location
               $featpair->location($location)
     Function: Get/set location object (using feature1)
     Returns : Bio::LocationI object
     Args    : [optional] LocationI to store

score
-----

     Title   : score
     Usage   : $score = $feat->score()
               $feat->score($score)
     Function: get/set on score information
     Returns : float
     Args    : none if get, the new value if set

frame
-----

     Title   : frame
     Usage   : $frame = $feat->frame()
               $feat->frame($frame)
     Function: get/set on frame information
     Returns : 0,1,2
     Args    : none if get, the new value if set

primary_tag
-----------

     Title   : primary_tag
     Usage   : $ptag = $featpair->primary_tag
     Function: get/set on the primary_tag of feature1
     Returns : 0,1,2
     Args    : none if get, the new value if set

source_tag
----------

     Title   : source_tag
     Usage   : $tag = $feat->source_tag()
               $feat->source_tag('genscan');
     Function: Returns the source tag for a feature,
               eg, 'genscan'
     Returns : a string
     Args    : none

seqname
-------

     Title   : seqname
     Usage   : $obj->seqname($newval)
     Function: There are many cases when you make a feature that you
               do know the sequence name, but do not know its actual
               sequence. This is an attribute such that you can store
               the seqname.

     This attribute should *not* be used in GFF dumping, as
     that should come from the collection in which the seq
     feature was found.
      Returns : value of seqname
      Args    : newvalue (optional)

hseqname
--------

     Title   : hseqname
     Usage   : $featpair->hseqname($newval)
     Function: Get/set method for the name of
               feature2.
     Returns : value of $feature2->seqname
     Args    : newvalue (optional)

hstart
------

     Title   : hstart
     Usage   : $start = $featpair->hstart
               $featpair->hstart(20)
     Function: Get/set on the start coordinate of feature2
     Returns : integer
     Args    : none

hend
----

     Title   : hend
     Usage   : $end = $featpair->hend
               $featpair->hend($end)
     Function: get/set on the end coordinate of feature2
     Returns : integer
     Args    : none

hstrand
-------

     Title   : hstrand
     Usage   : $strand = $feat->strand()
               $feat->strand($strand)
     Function: get/set on strand information, being 1,-1 or 0
     Returns : -1,1 or 0
     Args    : none

hscore
------

     Title   : hscore
     Usage   : $score = $feat->score()
               $feat->score($score)
     Function: get/set on score information
     Returns : float
     Args    : none if get, the new value if set

hframe
------

     Title   : hframe
     Usage   : $frame = $feat->frame()
               $feat->frame($frame)
     Function: get/set on frame information
     Returns : 0,1,2
     Args    : none if get, the new value if set

hprimary_tag
------------

     Title   : hprimary_tag
     Usage   : $ptag = $featpair->hprimary_tag
     Function: Get/set on the primary_tag of feature2
     Returns : 0,1,2
     Args    : none if get, the new value if set

hsource_tag
-----------

     Title   : hsource_tag
     Usage   : $tag = $feat->hsource_tag()
               $feat->source_tag('genscan');
     Function: Returns the source tag for a feature,
               eg, 'genscan'
     Returns : a string
     Args    : none

invert
------

     Title   : invert
     Usage   : $tag = $feat->invert
     Function: Swaps feature1 and feature2 around
     Returns : Nothing
     Args    : none


File: pm.info,  Node: Bio/SeqFeature/Gene/Exon,  Next: Bio/SeqFeature/Gene/ExonI,  Prev: Bio/SeqFeature/FeaturePair,  Up: Module List

a feature representing an exon
******************************

NAME
====

   Bio::SeqFeature::Gene::Exon - a feature representing an exon

SYNOPSIS
========

     # obtain an exon instance $exon somehow
     print "exon from ", $exon->start(), " to ", $exon->end(),
           " on seq ", $exon->seqname(), ", strand ", $exon->strand(),
           ", encodes the peptide sequence ",
           $exon->cds()->translate()->seq(), "\n";

DESCRIPTION
===========

   This module implements a feature representing an exon by implementing
the Bio::SeqFeature::Gene::ExonI interface.

   Apart from that, this class also implements Bio::SeqFeatureI by
inheriting off Bio::SeqFeature::Generic.

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably  to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.   Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp
====================

   Email hlapp@gmx.net

   Describe contact details here

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

is_coding
---------

     Title   : is_coding
     Usage   : if($exon->is_coding()) {
                       # do something
               }
               if($is_utr) {
                   $exon->is_coding(0);
               }
     Function: Get/set whether or not the exon codes for amino acid.
     Returns : TRUE if the object represents a feature translated into protein,
               and FALSE otherwise.
     Args    : A boolean value on set.

primary_tag
-----------

     Title   : primary_tag
     Usage   : $tag = $feat->primary_tag()
               $feat->primary_tag('exon')
     Function: Get/set the primary tag for the exon feature.

     This method is overridden here in order to allow only for
     tag values following a certain convention. For consistency reasons,
     the tag value must either contain the string 'exon' or the string
     'utr' (both case-insensitive). In the case of 'exon', a string
     describing the type of exon may be appended or prefixed. Presently,
     the following types are allowed: initial, internal, and terminal
     (all case-insensitive).

     If the supplied tag value matches 'utr' (case-insensitive),
     is_coding() will automatically be set to FALSE, and to TRUE
     otherwise.

     Returns : A string.
     Args    : A string on set.

location
--------

     Title   : location
     Usage   : my $location = $exon->location()
     Function: Returns a location object suitable for identifying the location
     	   of the exon on the sequence or parent feature.

     This method is overridden here to restrict allowed location types
     to non-compound locations.

     Returns : Bio::LocationI object
     Args    : none

cds
---

     Title   : cds()
     Usage   : $cds = $exon->cds();
     Function: Get the coding sequence of the exon as a sequence object.

     The sequence of the returned object is prefixed by Ns (lower case)
     if the frame of the exon is defined and different from zero. The
     result is that the first base starts a codon (frame 0).

     This implementation returns undef if the particular exon is
     not translated to protein, i.e., is_coding() returns FALSE. Undef
     will also be returned if no sequence is attached to this exon
     feature.

     Returns : A Bio::PrimarySeqI implementing object.
     Args    :


