This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: FormMagick/Validator,  Next: Fortune,  Prev: FormMagick/TagMaker,  Up: Module List

   FormMagick::Validator - validate data from FormMagick forms

SYNOPSIS
========

   use FormMagick::Validator;

DESCRIPTION
===========

   This module provides some common validation routines.  Validation
routines return the string "OK" if they succeed, or a descriptive message
if they fail.

Validation routines provided:
-----------------------------

nonblank
     The data is not an empty string : `$data ne ""'

number
     The data is a number (strictly speaking, data is a positive number):
     `$data =~ /^[0-9.]+$/'

word
     The data looks like a single word: `$data !~ /\W/'

minlength(n)
     The data is at least n characters long: `length($data) >= $n'

maxlength(n)
     The data is no more than  n characters long: `length($data) <= $n'

exactlength(n)
     The data is exactly  n characters long: `length($data) E== $n'

lengthrange(n,m)
     The data is between  n and c<m> characters long: `length($data) >= $n'
     and `length($data) <= $m'.  =cut

     sub lengthrange { 	my $data = $_[0]; 	my $minlength= $_[1]; 	my
     $maxlength= $_[2]; 	print "min $minlength, max $maxlength";
     if ( ( length($data) >= $minlength ) and (length($data) <=
     $maxlength) ) { 	        return "OK"; 	} else { 		return
     "This field must be between $minlength and $maxlength characters";
     } }

url
     The data looks like a (normalish) URL: `$data =~
     m!(http|ftp)://[\w/.-/)!'

email
     The data looks more or less like an internet email address: `$data =~
     /\@/'

     Note: not fully compliant with the entire gamut of RFC 822 addressing
     ;)

domain_name
     The data looks like an internet domain name or hostname.

ip_number
     The data looks like a valid IP number.

     The data looks like a good, valid username

password
     The data looks like a good password

date
     The data looks like a date.

iso_country_code
     The data is a standard 2-letter ISO country code.  Uses
     Locale::Country to check.

US_state
     The data is a standard 2-letter US state abbreviation.  Uses
     Geography::State in non-strict mode.

US_zipcode
     The data looks like a valid US zipcode

credit_card_type
     The data looks like a valid type of credit card (eg Visa, Mastercard).
     Uses Business::CreditCard.

credit_card_number
     The data looks like a valid credit card number Uses
     Business::CreditCard.

credit_card_expiry
     The data looks like a valid credit card expiry date Uses
     Business::CreditCard.

   These validation routines may be overridden and others may be added on
a per-application basis.  To do this, simply define a subroutine in your
CGI script that works in a similar way and use its name in the VALIDATION
attribute in your XML.

AUTHOR
======

   Kirrily "Skud" Robert <skud@infotrope.net>

   More information about FormMagick may be found at
http://sourceforge.net/projects/formmagick/


File: pm.info,  Node: Fortune,  Next: FreezeThaw,  Prev: FormMagick/Validator,  Up: Module List

read and write fortune (strfile) databases
******************************************

NAME
====

   Fortune - read and write fortune (strfile) databases

SYNOPSIS
========

     # input
     $ffile = new Fortune ($base_filename);
     $ffile->read_header ();
     $num_fortunes = $ffile->num_fortunes ();
     $fortune = $ffile->read_fortune ($num);
     $fortune = $ffile->get_random_fortune ();

     # create header file from data file -- NOT IMPLEMENTED YET
     $ffile = new Fortune ($base_filename);
     $ffile->write_header ();

     # write to data file -- NOT IMPLEMENTED YET
     $ffile = new Fortune (">>$base_filename");
     $ffile->write_fortune ($fortune);

DESCRIPTION
===========

   The `fortune' program is a small but important part of the Unix
culture, and this module aims to provide support for its "fortune cookie"
databases to Perl programmers.  For efficiency, all versions of `fortune'
rely on a binary header consisting mainly of offsets into the fortune file
proper.  Modern versions of fortune keep this header in a separate file,
and this is the style adopted by the `Fortune' module; the older style of
munging the header and data into one large "compiled" file is not
(currently) supported.

   Using the `Fortune' module makes it trivial to write a simplified
version of the `fortune' program:

     # trivial 'fortune' progam
     my $fortune_filename = $ARGV[0];
     my $fortune_file = new Fortune ($fortune_filename);
     $fortune_file->read_header ();
     my $fortune = $fortune_file->get_random_fortune ();
     print $fortune;

   This can be compressed considerably:

     print new Fortune ($ARGV[0])->read_header()->get_random_fortune();

   Of course, this doesn't provide all of `fortune''s interesting
features, such as parallel databases of offensive fortunes, selection of
long or short fortunes, dealing with multiple fortune files, etc.  If you
want `fortune', use it - but if you just want a simple Perl interface to
its data files, the `Fortune' module is for you.

   Currently, the `Fortune' module does not support writing fortune
databases.  If it did, writing a simplified `strfile' (the program that
processes a fortune database to create the header file) would also be
trivial:

     # trivial (and hypothetical) 'strfile' program
     my $fortune_filename = @ARGV[0];
     my $fortune_file = new Fortune ($fortune_filename);
     $fortune_file->write_header ();

   Note that the header filename is assumed to be just the name of the main
fortune database, with `".dat"' appended.  You can supply an alternate
header filename to the constructor, new(), if you wish.

METHODS
=======

Initialization/cleanup
----------------------

new (FILE [, HEADER_FILE])
     Opens a fortune cookie database.  FILE is the name of the data file to
     open, and HEADER_FILE (if given) the name of the header file that
     contains (or will contain) meta-data about the fortune database.  If
     HEADER_FILE is not given, it defaults to FILE with `".dat"' appended.

     The data file is opened via `open_file()', which dies if the file
     cannot be opened.  The header file is not opened, whether you supply
     its filename or not - after all, it might not exist yet.  Rather, you
     must explicitly call `read_header()' or `write_header()' as
     appropriate.

open_file ()
     Opens the fortune file whose name was supplied to the constructor.
     Dies on failure.

close_file ()
     Closes the fortune file if it's open; does nothing otherwise.

Header functions (read and write)
---------------------------------

read_header ()
     Reads the header file associated with this fortune database.  The name
     of the header file is determined by the constructor new: either it is
     based on the name of the data file, or supplied by the caller.

     If the header file does not exist, this function calls
     `compute_header()' automatically, which has the same effect as
     reading the header from a file.

     The header contains the following values, which are stored as
     attributes of the `Fortune' object:

    version
          version number

    `numstr'
          number of strings (fortunes) in the file

    max_length
          length of longest string in the file

    min_length
          length of shortest string in the file

    flags
          bit field for flags (see strfile(1) man page)

    delim
          character that delimits fortunes

     `numstr' is available via the `num_fortunes()' method; if you're
     interested in the others, you'll have to go grubbing through the
     `Fortune' object, e.g.:

          $fortune_file = new Fortune ('fortunes');
          $fortune_file->read_header ();
          $delim = $fortune_file->{'delim'};

     `read_header()' dies if there are any problems reading the header
     file, e.g. if it seems to be corrupt or truncated.

     `read_header()' returns the current `Fortune' object, to allow for
     sneaky one-liners (see the examples above).

compute_header ([DELIM])
     Reads the contents of the fortune file and computes the header
     information that would normally be found in a header (`.dat') file.
     This is useful if you maintain a file of fortunes by hand and do not
     have the corresponding data file.

     An optional delimiter argument may be passed to this function; if
     present, that delimiter will be used to separate entries in the
     fortune file.  If not provided, the existing delim attribute of the
     Fortune object will be used.  If that is not defined, then a percent
     sign ("%") will be used.

num_fortunes ()
     Returns the number of fortunes found by `read_header()'.

write_header ([DELIM])
     is not yet implemented.

Fortune input
-------------

get_fortune (NUM)
     Reads string number NUM from the open fortune file.  NUM is
     zero-based, ie. it must be between 0 and `num_fortunes()-1'
     (inclusive).  croaks if you haven't opened the file and read the
     header, or if NUM is out of range.  (Opening the file is pretty hard
     to screw up, since it's taken care of for you by the constructor, but
     you have to read the header explicitly with `read_header()'.)
     Returns the text of the fortune as a (possibly) multiline string.

get_random_fortune ()
     Picks a random fortune for you and reads it with `read_fortune()'.

Fortune output
--------------

write_fortune (FORTUNE)
     is not yet implemented.

AUTHOR AND COPYRIGHT
====================

   Written by Greg Ward <gward@python.net>, 20 February 1999.

   Copyright (c) 1999-2000 Gregory P. Ward. All rights reserved.  This is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

AVAILABILITY
============

   You can download the `Fortune' module from my web page:

     http://starship.python.net/~gward/perl/

   and it can also be found on CPAN.

   If you are using an operating system lacking a sufficient sense of
humour to include `fortune' as part of its standard installation (most
commercial Unices seem to be so afflicted), the Linux world has a
solution: the `fortune-mod' distribution.  The latest version as of this
writing is `fortune-mod-9708', and the README file says you can find it at

     http://www.progsoc.uts.edu.au/~dbugger/hacks/hacks.html

   This is the `fortune' implementation on which the `Fortune' module is
based.


File: pm.info,  Node: FreezeThaw,  Next: Frontier/Client,  Prev: Fortune,  Up: Module List

converting Perl structures to strings and back.
***********************************************

NAME
====

   FreezeThaw - converting Perl structures to strings and back.

SYNOPSIS
========

     use FreezeThaw qw(freeze thaw cmpStr safeFreeze cmpStrHard);
     $string = freeze $data1, $data2, $data3;
     ...
     ($olddata1, $olddata2, $olddata3) = thaw $string;
     if (cmpStr($olddata2,$data2) == 0) {print "OK!"}

DESCRIPTION
===========

   Converts data to/from stringified form, appropriate for
saving-to/reading-from permanent storage.

   Deals with objects, circular lists, repeated appearence of the same
refence. Does not deal with overloaded stringify operator yet.

EXPORT
======

Default
     None.

Exportable
     `freeze thaw cmpStr cmpStrHard safeFreeze'.

User API
========

`cmpStr'
     analogue of cmp for data. Takes two arguments and compares them as
     separate entities.

`cmpStrHard'
     analogue of cmp for data. Takes two arguments and compares them
     considered as a group.

`freeze'
     returns a string that encupsulates its arguments (considered as a
     group). `thaw'ing this string leads to a fatal error if arguments to
     `freeze' contained references to `GLOB's and CODEs.

`safeFreeze'
     returns a string that encupsulates its arguments (considered as a
     group). The result is `thaw'able in the same process. `thaw'ing the
     result in a different process should result in a fatal error if
     arguments to `safeFreeze' contained references to `GLOB's and CODEs.

`thaw'
     takes one string argument and returns an array. The elements of the
     array are "equivalent" to arguments of the `freeze' command that
     created the string. Can result in a fatal error (see above).

Developer API
=============

   `FreezeThaw' `freeze's and `thaw's data blessed in some package by
calling methods `Freeze' and `Thaw' in the package. The fallback methods
are provided by the `FreezeThaw' itself. The fallback `Freeze' freezes the
"content" of blessed object (from Perl point of view). The fallback `Thaw'
blesses the `thaw'ed data back into the package.

   So the package needs to define its own methods only if the fallback
methods will fail (for example, for a lot of data the "content" of an
object is an address of some C data). The methods are called like

     $newcooky = $obj->Freeze($cooky);
     $obj = Package->Thaw($content,$cooky);

   To save and restore the data the following method are applicable:

     $cooky->FreezeScalar($data,$ignorePackage,$noduplicate);

   during Freeze()ing, and

     $data = $cooky->ThawScalar;

   Two optional arguments $ignorePackage and $noduplicate regulate whether
the freezing should not call the methods even if $data is a reference to a
blessed object, and whether the data should not be marked as seen already
even if it was seen before. The default methods

     sub UNIVERSAL::Freeze {
       my ($obj, $cooky) = (shift, shift);
       $cooky->FreezeScalar($obj,1,1);
     }

     sub UNIVERSAL::Thaw {
       my ($package, $cooky) = (shift, shift);
       my $obj = $cooky->ThawScalar;
       bless $obj, $package;
     }

   call the `FreezeScalar' method of the $cooky since the freezing engine
will see the data the second time during this call. Indeed, it is the
freezing engine who calls UNIVERSAL::Freeze(), and it calls it because it
needs to freeze $obj. The above call to $cooky->FreezeScalar() handles the
same data back to engine, but because flags are different, the code does
not cycle.

   Freezing and thawing $cooky also allows the following additional
methods:

     $cooky->isSafe;

   to find out whether the current freeze was initiated by `freeze' or
`safeFreeze' command. Analogous method for thaw $cooky returns whether the
current thaw operation is considered safe (i.e., either does not contain
cached elsewhere data, or comes from the same application). You can use

     $cooky->makeSafe;

   to prohibit cached data for the duration of the rest of freezing or
thawing of current object.

   Two methods

     $value = $cooky->repeatedOK;
     $cooky->noRepeated;		# Now repeated are prohibited

   allow to find out/change the current setting for allowing repeated
references.

   If you want to flush the cache of saved objects you can use

     FreezeThaw->flushCache;

   this can invalidate some frozen string, so that thawing them will
result in fatal error.

Instantiating
-------------

   Sometimes, when an object from a package is recreated in presense of
repeated references, it is not safe to recreate the internal structure of
an object in one step. In such a situation recreation of an object is
carried out in two steps: in the first the object is `allocate'd, in the
second it is `instantiate'd.

   The restriction is that during the *allocation* step you cannot use any
reference to any Perl object that can be referenced from any other place.
This restriction is applied since that object may not exist yet.

   Correspondingly, during *instantiation* step the previosly *allocated*
object should be `filled', i.e., it can be changed in any way such that
the references to this object remain valid.

   The methods are called like this:

     $pre_object_ref = Package->Allocate($pre_pre_object_ref);
     	# Returns reference
     Package->Instantiate($pre_object_ref,$cooky);
     	# Converts into reference to blessed object

   The reverse operations are

     $object_ref->FreezeEmpty($cooky);
     $object_ref->FreezeInstance($cooky);

   during these calls object can `freezeScalar' some information (in a
usual way) that will be used during `Allocate' and `Instantiate' calls
(via `thawScalar'). Note that the return value of `FreezeEmpty' is cached
during the phase of creation of uninialized objects. This must be used
like this: the return value is the reference to the created object, so it
is not destructed until other objects are created, thus the frozen values
of the different objects will not share the same references. Example of
bad result:

     $o1->FreezeEmpty($cooky)

   freezes `{}', and `$o2->FreezeEmpty($cooky)' makes the same. Now nobody
guaranties that that these two copies of `{}' are different, unless a
reference to the first one is preserved during the call to
`$o2->FreezeEmpty($cooky)'. If `$o1->FreezeEmpty($cooky)' returns the
value of `{}' it uses, it will be preserved by the engine.

   The helper function `FreezeThaw::copyContents' is provided for
simplification of instantiation. The syntax is

     FreezeThaw::copyContents $to, $from;

   The function copies contents the object $from point to into what the
object $to points to (including package for blessed references). Both
arguments should be references.

   The default methods are provided. They do the following:

`FreezeEmpty'
     Freezes an empty object of underlying type.

`FreezeInstance'
     Calls `Freeze'.

`Allocate'
     Thaws what was frozen by `FreezeEmpty'.

`Instantiate'
     Thaws what was frozen by `FreezeInstance', uses `copyContents' to
     transfer this to the $pre_object.

BUGS and LIMITATIONS
====================

   A lot of objects are blessed in some obscure packages by XSUB typemaps.
It is not clear how to (automatically) prevent the UNIVERSAL methods to be
called for objects in these packages.

   The objects which can survive freeze()/thaw() cycle must also survive a
change of a "member" to an equal member.  Say, after

     $a = [a => 3];
     $a->{b} = \ $a->{a};

   $a satisfies

     $a->{b} == \ $a->{a}

   This property will be broken by freeze()/thaw(), but it is also broken
by

     $a->{a} = delete $a->{a};


File: pm.info,  Node: Frontier/Client,  Next: Frontier/Daemon,  Prev: FreezeThaw,  Up: Module List

issue Frontier XML RPC requests to a server
*******************************************

NAME
====

   Frontier::Client - issue Frontier XML RPC requests to a server

SYNOPSIS
========

     use Frontier::Client;

     $server = Frontier::Client->new( I<OPTIONS> );

     $result = $server->call($method, @args);

     $boolean = $server->boolean($value);
     $date_time = $server->date_time($value);
     $base64 = $server->base64($value);

     $value = $boolean->value;
     $value = $date_time->value;
     $value = $base64->value;

DESCRIPTION
===========

   *Frontier::Client* is an XML-RPC client over HTTP.  *Frontier::Client*
instances are used to make calls to XML-RPC servers and as shortcuts for
creating XML-RPC special data types.

METHODS
=======

new( OPTIONS )
     Returns a new instance of *Frontier::Client* and associates it with
     an XML-RPC server at a URL.  OPTIONS may be a list of key, value
     pairs or a hash containing the following parameters:

    url
          The URL of the server.  This parameter is required.  For example:

               $server = Frontier::Client->new( 'url' => 'http://betty.userland.com/RPC2' );

    proxy
          A URL of a proxy to forward XML-RPC calls through.

    encoding
          The XML encoding to be specified in the XML declaration of
          outgoing RPC requests.  Incoming results may have a different
          encoding specified; XML::Parser will convert incoming data to
          UTF-8.  The default outgoing encoding is none, which uses XML
          1.0's default of UTF-8.  For example:

               $server = Frontier::Client->new( 'url' => 'http://betty.userland.com/RPC2',
                                                'encoding' => 'ISO-8859-1' );

    use_objects
          If set to a non-zero value will convert incoming <i4>, <float>,
          and <string> values to objects instead of scalars.  See int(),
          float(), and string() below for more details.

    debug
          If set to a non-zero value will print the encoded XML request
          and the XML response received.

call($method, @args)
     Forward a procedure call to the server, either returning the value
     returned by the procedure or failing with exception.  ``$method'' is
     the name of the server method, and ``@args'' is a list of arguments
     to pass.  Arguments may be Perl hashes, arrays, scalar values, or the
     XML-RPC special data types below.

boolean( $value )
date_time( $value )

base64( $base64 )
     The methods ``boolean()'', ``date_time()'', and ``base64()'' create
     and return XML-RPC-specific datatypes that can be passed to `call()'.
     Results from servers may also contain these datatypes.  The
     corresponding package names (for use with ``ref()'', for example) are
     ``Frontier::RPC2::Boolean'', ``Frontier::RPC2::DateTime::ISO8601'',
     and ``Frontier::RPC2::Base64''.

     The value of boolean, date/time, and base64 data can be set or
     returned using the `value()' method.  For example:

          # To set a value:
          $a_boolean->value(1);

          # To retrieve a value
          $base64 = $base64_xml_rpc_data->value();

     Note: ``base64()'' does not encode or decode base64 data for you, you
     must use MIME::Base64 or similar module for that.

int( 42 );
float( 3.14159 );
string( "Foo" );
     By default, you may pass ordinary Perl values (scalars) to be encoded.
     RPC2 automatically converts them to XML-RPC types if they look like an
     integer, float, or as a string.  This assumption causes problems when
     you want to pass a string that looks like "0096", RPC2 will convert
     that to an <i4> because it looks like an integer.  With these
     methods, you could now create a string object like this:

          $part_num = $server->string("0096");

     and be confident that it will be passed as an XML-RPC string.  You can
     change and retrieve values from objects using value() as described
     above.

SEE ALSO
========

   perl(1), Frontier::RPC2(3)

   <http://www.scripting.com/frontier5/xml/code/rpc.html>

AUTHOR
======

   Ken MacLeod <ken@bitsko.slc.ut.us>


File: pm.info,  Node: Frontier/Daemon,  Next: Frontier/RPC2,  Prev: Frontier/Client,  Up: Module List

receive Frontier XML RPC requests
*********************************

NAME
====

   Frontier::Daemon - receive Frontier XML RPC requests

SYNOPSIS
========

     use Frontier::Daemon;

     Frontier::Daemon->new(methods => {
         'rpcName' => \&sub_name,
            ...
         });

DESCRIPTION
===========

   *Frontier::Daemon* is an HTTP/1.1 server that listens on a socket for
incoming requests containing Frontier XML RPC2 method calls.
*Frontier::Daemon* is a subclass of *HTTP::Daemon*, which is a subclass of
IO::Socket::INET.

   *Frontier::Daemon* takes a `methods' parameter, a hash that maps an
incoming RPC method name to reference to a subroutine.

SEE ALSO
========

   perl(1), HTTP::Daemon(3), IO::Socket::INET(3), Frontier::RPC2(3)

   <http://www.scripting.com/frontier5/xml/code/rpc.html>

AUTHOR
======

   Ken MacLeod <ken@bitsko.slc.ut.us>


File: pm.info,  Node: Frontier/RPC2,  Next: Function/Override,  Prev: Frontier/Daemon,  Up: Module List

encode/decode RPC2 format XML
*****************************

NAME
====

   Frontier::RPC2 - encode/decode RPC2 format XML

SYNOPSIS
========

     use Frontier::RPC2;

     $coder = Frontier::RPC2->new;

     $xml_string = $coder->encode_call($method, @args);
     $xml_string = $coder->encode_response($result);
     $xml_string = $coder->encode_fault($code, $message);

     $call = $coder->decode($xml_string);

     $response_xml = $coder->serve($request_xml, $methods);

     $boolean_object = $coder->boolean($boolean);
     $date_time_object = $coder->date_time($date_time);
     $base64_object = $coder->base64($base64);
     $int_object = $coder->int(42);
     $float_object = $coder->float(3.14159);
     $string_object = $coder->string("Foo");

DESCRIPTION
===========

   *Frontier::RPC2* encodes and decodes XML RPC calls.

$coder = Frontier::RPC2->new( OPTIONS )
     Create a new encoder/decoder.  The following option is supported:

    encoding
          The XML encoding to be specified in the XML declaration of
          encoded RPC requests or responses.  Decoded results may have a
          different encoding specified; XML::Parser will convert decoded
          data to UTF-8.  The default encoding is none, which uses XML
          1.0's default of UTF-8.  For example:

               $server = Frontier::RPC2->new( 'encoding' => 'ISO-8859-1' );

    use_objects
          If set to a non-zero value will convert incoming <i4>, <float>,
          and <string> values to objects instead of scalars.  See int(),
          float(), and string() below for more details.

$xml_string = $coder->encode_call($method, @args)
     ``encode_call'' converts a method name and it's arguments into an
     RPC2 ``methodCall'' element, returning the XML fragment.

$xml_string = $coder->encode_response($result)
     ``encode_response'' converts the return value of a procedure into an
     RPC2 ``methodResponse'' element containing the result, returning the
     XML fragment.

$xml_string = $coder->encode_fault($code, $message)
     ``encode_fault'' converts a fault code and message into an RPC2
     ``methodResponse'' element containing a `fault' element, returning
     the XML fragment.

$call = $coder->decode($xml_string)
     `decode' converts an XML string containing an RPC2 ``methodCall'' or
     ``methodResponse'' element into a hash containing three members,
     `type', `value', and ``method_name''.  `type' is one of `call',
     `response', or `fault'.  `value' is array containing the parameters
     or result of the RPC.  For a `call' type, `value' contains call's
     parameters and ``method_name'' contains the method being called.  For
     a `response' type, the `value' array contains call's result.  For a
     `fault' type, the `value' array contains a hash with the two members
     ``faultCode'' and ``faultMessage''.

$response_xml = $coder->serve($request_xml, $methods)
     ``serve'' decodes ``$request_xml'', looks up the called method name
     in the ``$methods'' hash and calls it, and then encodes and returns
     the response as XML.

$boolean_object = $coder->boolean($boolean);
$date_time_object = $coder->date_time($date_time);

$base64_object = $coder->base64($base64);
     These methods create and return XML-RPC-specific datatypes that can be
     passed to the encoder.  The decoder may also return these datatypes.
     The corresponding package names (for use with ``ref()'', for example)
     are ``Frontier::RPC2::Boolean'',
     ``Frontier::RPC2::DateTime::ISO8601'', and ``Frontier::RPC2::Base64''.

     You can change and retrieve the value of boolean, date/time, and
     base64 data using the `value' method of those objects, i.e.:

          $boolean = $boolean_object->value;

          $boolean_object->value(1);

$int_object = $coder->int(42);
$float_object = $coder->float(3.14159);
$string_object = $coder->string("Foo");
     By default, you may pass ordinary Perl values (scalars) to be encoded.
     RPC2 automatically converts them to XML-RPC types if they look like an
     integer, float, or as a string.  This assumption causes problems when
     you want to pass a string that looks like "0096", RPC2 will convert
     that to an <i4> because it looks like an integer.  With these
     methods, you could now create a string object like this:

          $part_num = $coder->string("0096");

     and be confident that it will be passed as an XML-RPC string.  You can
     change and retrieve values from objects using value() as described
     above.

SEE ALSO
========

   perl(1), Frontier::Daemon(3), Frontier::Client(3)

   <http://www.scripting.com/frontier5/xml/code/rpc.html>

AUTHOR
======

   Ken MacLeod <ken@bitsko.slc.ut.us>


File: pm.info,  Node: Function/Override,  Next: Functional,  Prev: Frontier/RPC2,  Up: Module List

Add callbacks to existing functions.
************************************

NAME
====

   Function::Override - Add callbacks to existing functions.

SYNOPSIS
========

     use Function::Override;
     use Croak;

     BEGIN {
          override('open',
                   sub {
                       my $wantarray = (caller(1))[5];
                       carp "You didn't check if open() succeeded"
                           unless defined $wantarray;
                   }
                  );
     }

     open(FILE, $filename);      # This produces a warning now.
     print <FILE>;
     close FILE;

DESCRIPTION
===========

   ** THIS IS ALPHA CODE! **

   Function::Override provides a way to conveniently add code to existing
functions.

   You may wrap both user-defined functions and overridable CORE operators
in this way.  Although if you override a CORE function its usually wise to
do it in a BEGIN block so Perl will see it.

TODO
====

   Add a more flexible callback system offering pre and post function
routines.

   Offer more information to the callback, such as the subroutine name.

   Merge Fatal.pm and possiblely Memoize.pm.

ENVIRONMENT
===========

PERL_FUNCTION_OVERRIDE_DEBUG
     If true, this flag turns on debugging output.

AUTHOR
======

   Michael G Schwern <schwern@pobox.com> but its really 99.99% Fatal.pm by
Lionel.Cons@cern.ch

SEE ALSO
========

   *Note Fatal: Fatal,


File: pm.info,  Node: Functional,  Next: Fwctl,  Prev: Function/Override,  Up: Module List

a module which makes Perl slightly more functional (think Haskell)
******************************************************************

NAME
====

   Functional - a module which makes Perl slightly more functional (think
Haskell)

SYNOPSIS
========

     use Functional;
     print 'The first ten primes are: ',
       show(take(10, filter("prime", integers))), "\n";

DESCRIPTION
===========

   Perl already contains some functional-like functions, such as map and
grep. The purpose of this module is to add other functional-like functions
to Perl, such as foldl and foldr, as well as the use of infinite lists.

   Think as to how you would express the first ten prime numbers in a
simple way in your favourite programming language? So the example in the
synopsis is a killer app, if you will (until I think up a better one ;-).

   The idea is mostly based on Haskell, from which most of the functions
are taken. There are a couple of major omissions: currying and types.
Lists (and tuples) are simply Perl list references, none of this 'cons'
business, and strings are simple strings, not lists of characters.

   The idea is to make Perl slightly more functional, rather than
completely replace it. Hence, this slots in very well with whatever else
your program may be doing, and is very Perl-ish. Other modules are
expected to try a much more functional approach.

FUNCTIONS
=========

   The following functions are available. (Note: these should not be
called as methods).

   In each description, I shall give the Haskell definition (if I think it
would help) as well as a useful example.

show
     Show returns a string representation of an object.  It does not like
     infinite lists.

inc k
     Increases the value passed by 1. eg: inc(2) = 3.  In Haskell:

          inc          :: a -> a
          inc k         = 1 + k

double k
     Doubles the passed value. eg: double(3) = 6.  In Haskell:

          double         :: a -> a
          double k        = k * 2

square k
     Returns the square of the passed value. eg: square(3) = 9.  In
     Haskell:

          square          :: a -> a
          square k         = 1 + k

gcd x y
     Returns the greatest common denominator of two numbers. eg: gcd(144,
     1024) = 16. In Haskell:

          gcd :: Integral a => a -> a -> a
          gcd 0 0 = error "gcd 0 0 is undefined"
          gcd x y = gcd' (abs x) (abs y)
                    where gcd' x 0 = x
                    gcd' x y = gcd' y (x `rem` y)

lcm x y
     Returns the lowest common multiple of two numbers.  eg: lcm(144,
     1024) = 9216. In Haskell:

          lcm            :: (Integral a) => a -> a -> a
          lcm _ 0         = 0
          lcm 0 _         = 0
          lcm x y         = abs ((x `quot` gcd x y) * y)

id x
     The identity function - simply returns the argument.  eg: id([1..6])
     = [1, 2, 3, 4, 5, 6]. In Haskell:

          id             :: a -> a
          id x            = x

const k _
     Returns the first argument of 2 arguments.  eg: const(4, 5) = 4. In
     Haskell:

          const          :: a -> b -> a
          const k _       = k

flip f
     Given a function, flips the two arguments it is passed.  Note that
     this returns a CODEREF, as currying does not yet happen. eg: flip(sub
     { $_[0] ** $_[1] })->(2, 3) = 9.  In Haskell (ie this is what it
     should really do):

          flip           :: (a -> b -> c) -> b -> a -> c
          flip f x y      = f y x

Until p f x
     Keep on applying f to x until p(x) is true, and then return x at that
     point. eg: Until(sub { $_[0] % 10 == 0 }, "inc", 1) = 10. In Haskell:

          until          :: (a -> Bool) -> (a -> a) -> a -> a
          until p f x     = if p x then x else until p f (f x)

fst x:xs
     Returns the first element in a tuple.  eg: fst([1, 2]) = 1. In
     Haskell:

          fst            :: (a,b) -> a
          fst (x,_)       = x

snd x:y:xs
     Returns the second element in a tuple.  eg: snd([1, 2]) = 2. In
     Haskell:

          snd            :: (a,b) -> a
          snd (_,y)       = y

head xs
     Returns the head (first element) of a list.  eg: head([1..6]) = 1. In
     Haskell:

          head             :: [a] -> a
          head (x:_)        = x

Last xs
     Returns the last element of a list. Note the capital L, to make it
     distinct from the Perl 'last' command. eg: Last([1..6]) = 6. In
     Haskell:

          last             :: [a] -> a
          last [x]          = x
          last (_:xs)       = last xs

tail xs
     Returns a list minus the first element (head).  eg: tail([1..6]) =
     [2, 3, 4, 5, 6]. In Haskell:

          tail             :: [a] -> [a]
          tail (_:xs)       = xs

init xs
     Returns a list minus its last element.  eg: init([1..6]) = [1, 2, 3,
     4, 5]. In Haskell:

          init             :: [a] -> [a]
          init [x]          = []
          init (x:xs)       = x : init xs

null xs
     Returns whether or not the list is empty. eg: null([1, 2]) = False.
     In Haskell:

          null             :: [a] -> Bool
          null []           = True
          null (_:_)        = False

Map f xs
     Evaluates f for each element of the list xs and returns the list
     composed of the results of each such evaluation. It is very similar to
     the Perl command 'map', hence the capital M, but also copes with
     infinite lists. eg: Map("double", [1..6]) = [2, 4, 6, 8, 10, 12].  In
     Haskell:

          map              :: (a -> b) -> [a] -> [b]
          map f xs          = [ f x | x <- xs ]

filter p xs
     Returns the list of the elements in xs for which p(xs) returns true.
     It is similar to the Perl command 'grep', but it also copes with
     infinite lists.  eg: filter("even", [1..6]) = [2, 4, 6]. In Haskell:

          filter           :: (a -> Bool) -> [a] -> [a]
          filter p xs       = [ x | x <- xs, p x ]

concat
     Concatenates lists together into one list. eg: concat([[1..3],
     [4..6]]) = [1, 2, 3, 4, 5, 6]. In Haskell:

          concat           :: [[a]] -> [a]
          concat            = foldr (++) []

     TODO: Make sure this works with infinite lists!

Length
     Returns the length of a list - only do this with finite lists! eg:
     Length([1..6]) = 6. In Haskell:

     length           :: [a] -> Int length            = foldl' (\n _ -> n
     + 1) 0

     TODO Make sure this works!

foldl f z xs
     Applies function f to the pairs (z, xs[0]), (f(z, xs[0], xs[1]),
     (f(f(z, xs[0], xs[1])), xs[2]) and so on. ie it folds from the left
     and returns the last value.  Note that foldl should not be done to
     infinite lists. eg: the following returns the sum of 1..6: foldl(sub
     { $_[0] + $_[1] }, 0, [1..6]) = 21.  In Haskell:

          foldl            :: (a -> b -> a) -> a -> [b] -> a
          foldl f z []      = z
          foldl f z (x:xs)  = foldl f (f z x) xs

foldl1 f xs
     This is a variant of foldl where the first value of xs is taken as z.
     Applies function f to the pairs (xs[0], xs[1]), (f(xs[0], xs[1],
     xs[2]), (f(f(xs[0], xs[1], xs[2])), xs[3]) and so on. ie it folds
     from the left and returns the last value.  Note that foldl should not
     be done to infinite lists. eg: the following returns the sum of 1..6:
     foldl1(sub { $_[0] + $_[1] }, [1..6]) = 21.  In Haskell:

          foldl1           :: (a -> a -> a) -> [a] -> a
          foldl1 f (x:xs)   = foldl f x xs

scanl f q xs
     Returns a list of all the intermedia values that foldl would compute.
     ie returns the list z, f(z, xs[0]), f(f(z, xs[0]), xs[1]), f(f(f(z,
     xs[0]), xs[1]), xs[2]) and so on.  eg: scanl(sub { $_[0] + $_[1] },
     0, [1..6]) = [0, 1, 3, 6, 10, 15, 21].  In Haskell:

          scanl        :: (a -> b -> a) -> a -> [b] -> [a]
          scanl f q xs  = q : (case xs of
                               []   -> []
                               x:xs -> scanl f (f q x) xs)

scanl1 f xs
     This is a variant of scanl where the first value of xs is taken as q.
     Returns a list of all the intermedia values that foldl would compute.
     ie returns the list f(xs[0], xs[1]), f(f(xs[0], xs[1]), xs[2]),
     f(f(f(xs[0], xs[1]), xs[2]), xs[3]) and so on.  eg: scanl1(sub {
     $_[0] + $_[1] }, [1..6]) = [1, 3, 6, 10, 15, 21].  In Haskell:

          scanl1           :: (a -> a -> a) -> [a] -> [a]
          scanl1 f (x:xs)   = scanl f x xs

foldr f z xs
     This is similar to foldl but is folding from the right instead of the
     left.  Note that foldr should not be done to infinite lists.  eg: the
     following returns the sum of 1..6: foldl(sub { $_[0] + $_[1] }, 0,
     [1..6]) = 21.  In Haskell:

          foldr            :: (a -> b -> b) -> b -> [a] -> b
          foldr f z []      = z
          foldr f z (x:xs)  = f x (foldr f z xs)

foldr1 f xs
     This is similar to foldr1 but is folding from the right instead of
     the left. Note that foldr1 should not be done on infinite lists.  eg:
     foldr1(sub { $_[0] + $_[1] }, [1..6]) = 21.  In Haskell:

          foldr1           :: (a -> a -> a) -> [a] -> a
          foldr1 f [x]      = x
          foldr1 f (x:xs)   = f x (foldr1 f xs)

scanr f z xs
     This is similar to scanl but is scanning and folding from the right
     instead of the left. Note that scanr should not be done on infinite
     lists. eg: scanr(sub { $_[0] + $_[1] }, 0, [1..6]) = [0, 6, 11, 15,
     18, 20, 21].  In Haskell:

          scanr            :: (a -> b -> b) -> b -> [a] -> [b]
          scanr f q0 []     = [q0]
          scanr f q0 (x:xs) = f x q : qs
                              where qs@(q:_) = scanr f q0 xs

scanr1 f xs
     This is similar to scanl1 but is scanning and folding from the right
     instead of the left. Note that scanr1 should not be done on infinite
     lists. eg: scanr1(sub { $_[0] + $_[1] }, [1..6]) = [6, 11, 15, 18,
     20, 21].  In Haskell:

          scanr1           :: (a -> a -> a) -> [a] -> [a]
          scanr1 f [x]      = [x]
          scanr1 f (x:xs)   = f x q : qs
                              where qs@(q:_) = scanr1 f xs

iterate f x
     This returns the infinite list (x, f(x), f(f(x)), f(f(f(x)))...) and
     so on. eg: take(8, iterate(sub { $_[0]*2 }, 1)) = [1, 2, 4, 8, 16,
     32, 64, 128].  In Haskell:

          iterate          :: (a -> a) -> a -> [a]
          iterate f x       = x : iterate f (f x)

repeat x
     This returns the infinite list where all elements are x. eg: take(4,
     repeat(42)) = [42, 42, 42, 42].  In Haskell:

          repeat           :: a -> [a]
          repeat x          = xs where xs = x:xs

replicate n x
     Returns a list containing n times the element x.  eg: replicate(5, 1)
     = [1, 1, 1, 1, 1]. In Haskell:

          replicate        :: Int -> a -> [a]
          replicate n x     = take n (repeat x)

take n xs
     Returns a list containing the first n elements from the list xs.  eg:
     take(2, [1..6]) = [1, 2]. In Haskell:

          take                :: Int -> [a] -> [a]
          take 0 _             = []
          take _ []            = []
          take n (x:xs) | n>0  = x : take (n-1) xs
          take _ _             = error "Prelude.take: negative argument"

drop n xs
     Returns a list containing xs with the first n elements missing. eg:
     drop(2, [1..6]) = [3, 4, 5, 6].  In Haskell:

          drop                :: Int -> [a] -> [a]
          drop 0 xs            = xs
          drop _ []            = []
          drop n (_:xs) | n>0  = drop (n-1) xs
          drop _ _             = error "Prelude.drop: negative argument"

splitAt n xs
     Splits the list xs into two lists at element n. eg: splitAt(2,
     [1..6]) = [[1, 2], [3, 4, 5, 6]].  In Haskell:

          splitAt               :: Int -> [a] -> ([a], [a])
          splitAt 0 xs           = ([],xs)
          splitAt _ []           = ([],[])
          splitAt n (x:xs) | n>0 = (x:xs',xs'') where (xs',xs'') = splitAt (n-1) xs
          splitAt _ _            = error "Prelude.splitAt: negative argument"

takeWhile p xs
     Takes elements from xs while p(that element) is true. Returns the
     list. eg: takeWhile(sub { $_[0] <= 4 }, [1..6]) = [1, 2, 3, 4].  In
     Haskell:

          takeWhile           :: (a -> Bool) -> [a] -> [a]
          takeWhile p []       = []
          takeWhile p (x:xs)
                   | p x       = x : takeWhile p xs
                   | otherwise = []

dropWhile p xs
     Drops elements from the head of xs while p(that element) is true.
     Returns the list. eg: dropWhile(sub { $_[0] <= 4 }, [1..6]) = [5, 6].
     In Haskell:

          dropWhile           :: (a -> Bool) -> [a] -> [a]
          dropWhile p []       = []
          dropWhile p xs@(x:xs')
                   | p x       = dropWhile p xs'
                   | otherwise = xs

span p xs
     Splits xs into two lists, the first containing the first few elements
     for which p(that element) is true. eg: span(sub { $_[0] <= 4 },
     [1..6]) = [[1, 2, 3, 4], [5, 6]].  In Haskell:

          span                :: (a -> Bool) -> [a] -> ([a],[a])
          span p []            = ([],[])
          span p xs@(x:xs')
                   | p x       = (x:ys, zs)
                   | otherwise = ([],xs)
                                 where (ys,zs) = span p xs'

break p xs
     Splits xs into two lists, the first containing the first few elements
     for which p(that element) is false. eg: break(sub { $_[0] >= 4 },
     [1..6]) = [[1, 2, 3], [4, 5, 6]].  In Haskell:

          break         :: (a -> Bool) -> [a] -> ([a],[a])
          break p        = span (not . p)

lines s
     Breaks the string s into multiple strings, split at line boundaries.
     eg: lines("A\nB\nC") = ['A', 'B', 'C'].  In Haskell:

          lines     :: String -> [String]
          lines ""   = []
          lines s    = let (l,s') = break ('\n'==) s
                       in l : case s' of []      -> []
                                         (_:s'') -> lines s''

words s
     Breaks the string s into multiple strings, split at whitespace
     boundaries. eg: words("hey how random") = ['hey', 'how', 'random'].
     In Haskell:

          words     :: String -> [String]
          words s    = case dropWhile isSpace s of
                            "" -> []
                            s' -> w : words s''
                                  where (w,s'') = break isSpace s'

unlines xs
     Does the opposite of unlines, that is: joins multiple strings into
     one, joined by newlines. eg: unlines(['A', 'B', 'C']) = "A\nB\nC"; In
     Haskell:

          unlines   :: [String] -> String
          unlines    = concatMap (\l -> l ++ "\n")

     (note that strings in Perl are not lists of characters, so this
     approach will not actually work...)

unwords ws
     Does the opposite of unwords, that is: joins multiple strings into
     one, joined by a space. eg: unwords(["hey","how","random"]) = 'hey
     how random'.  In Haskell:

          unwords   :: [String] -> String
          unwords [] = []
          unwords ws = foldr1 (\w s -> w ++ ' ':s) ws

Reverse xs
     Returns a list containing the elements of xs in reverse order. Note
     the capital R, so as not to clash with the Perl command 'reverse'.
     You should not try to Reverse an infinite list.  eg: Reverse([1..6])
     = [6, 5, 4, 3, 2, 1]. In Haskell:

          reverse   :: [a] -> [a]
          reverse    = foldl (flip (:)) []

And xs
     Returns true if all the elements in xs are true. Returns false
     otherwise. Note the capital A, so as not to clash with the Perl
     command 'and'. You should not try to And an infinite list (unless you
     expect it to fail, as it will short-circuit).  eg: And([1, 1, 1]) = 1.
     In Haskell:

          and       :: [Bool] -> Bool
          and        = foldr (&&) True

Or xs
     Returns true if one of the elements in xs is true. Returns false
     otherwise. Note the capital O, so as not to clash with the Perl
     command 'or'. You may try to Or an infinite list as it will
     short-circuit (unless you expect it to fail, that is). eg: Or([0, 0,
     1]) = 1. In Haskell:

          or        :: [Bool] -> Bool
          or         = foldr (||) False

any p xs
     Returns true if one of p(each element of xs) are true. Returns false
     otherwise. You should not try to And an infinite list (unless you
     expect it to fail, as it will short-circuit).  eg: any("even", [1, 2,
     3]) = 1.  In Haskell:

          any       :: (a -> Bool) -> [a] -> Bool
          any p      = or  . map p

all p xs
     Returns true if all of the p(each element of xs) is true. Returns
     false otherwise. You may try to Or an infinite list as it will
     short-circuit (unless you expect it to fail, that is). eg: all("odd",
     [1, 1, 3]) = 1. In Haskell:

          all  :: (a -> Bool) -> [a] -> Bool
          all p      = and . map p

elem x xs
     Returns true is x is present in xs.  You probably should not do this
     with infinite lists.  Note that this assumes x and xs are numbers.
     eg: elem(2, [1, 2, 3]) = 1.  In Haskell:

          elem             :: Eq a => a -> [a] -> Bool
          elem              = any . (==)

notElem x xs
     Returns true if x is not present in x. You should not do this with
     infinite lists. Note that this assumes that x and xs are numbers.

          notElem          :: Eq a => a -> [a] -> Bool
          notElem           = all . (/=)

lookup key xys
     This returns the value of the key in xys, where xys is a list of key,
     value pairs. It returns undef if the key was not found. You should
     not do this with infinite lists. Note that this assumes that the keys
     are strings. eg: lookup(3, [1..6]) = 4.  In Haskell:

          lookup           :: Eq a => a -> [(a,b)] -> Maybe b
          lookup k []       = Nothing
          lookup k ((x,y):xys)
                | k==x      = Just y
                | otherwise = lookup k xys

minimum xs
     Returns the minimum value in xs.  You should not do this with a
     infinite list.  eg: minimum([1..6]) = 1. In Haskell:

          minimum          :: Ord a => [a] -> a
          minimum           = foldl1 min

maximum xs
     Returns the maximum value in xs.  You should not do this with an
     infinite list.  eg: maximum([1..6]) = 6. In Haskell:

          maximum          :: Ord a => [a] -> a
          maximum           = foldl1 max

sum xs
     Returns the sum of the elements of xs.  You should not do this with
     an infinite list.  eg: sum([1..6]) = 21. In Haskell:

          sum          :: Num a => [a] -> a
          sum           = foldl' (+) 0

product xs
     Returns the products of the elements of xs.  You should not do this
     with an infinite list.  eg: product([1..6]) = 720. In Haskell:

          product      :: Num a => [a] -> a
          product       = foldl' (*) 1

zip as bs
     Zips together two lists into one list. Should not be done with
     infinite lists.  eg: zip([1..6], [7..12]) = [1, 7, 2, 8, 3, 9, 4, 10,
     5, 11, 6, 12].  In Haskell:

          zip              :: [a] -> [b] -> [(a,b)]
          zip               = zipWith  (\a b -> (a,b))

          zipWith                  :: (a->b->c) -> [a]->[b]->[c]
          zipWith z (a:as) (b:bs)   = z a b : zipWith z as bs
          zipWith _ _      _        = []

zip3 as bs cs
     Zips together three lists into one. Should not be done with infinite
     lists.  eg: zip3([1..2], [3..4], [5..6]) = [1, 3, 5, 2, 4, 6].  In
     Haskell:

          zip3             :: [a] -> [b] -> [c] -> [(a,b,c)]
          zip3              = zipWith3 (\a b c -> (a,b,c))

          zipWith3                 :: (a->b->c->d) -> [a]->[b]->[c]->[d]
          zipWith3 z (a:as) (b:bs) (c:cs)
                                    = z a b c : zipWith3 z as bs cs
          zipWith3 _ _ _ _          = []

unzip abs
     Unzips one list into two. Should not be done with infinite lists.
     eg: unzip([1,7,2,8,3,9,4,10,5,11,6,12]) = ([1, 2, 3, 4, 5, 6], [7, 8,
     9, 10, 11, 12]).

          unzip    :: [(a,b)] -> ([a],[b])
          unzip     = foldr (\(a,b) ~(as,bs) -> (a:as, b:bs)) ([], [])

unzip abcs
     Unzips one list into three. Should not be done with infinite lists.
     eg: unzip3([1,3,5,2,4,6]) = ([1, 2], [3, 4], [5, 6]).  In Haskell:

          unzip3   :: [(a,b,c)] -> ([a],[b],[c])
          unzip3    = foldr (\(a,b,c) ~(as,bs,cs) -> (a:as,b:bs,c:cs))
          		      ([],[],[])

integers
     A useful function that returns an infinite list containing all the
     integers. eg: integers = (1, 2, 3, 4, 5, ...).

factors x
     A useful function that returns the factors of x.  eg: factors(100) =
     [1, 2, 4, 5, 10, 20, 25, 50, 100].  In Haskell:

          factors x = [n | n <- [1..x], x `mod` n == 0]

prime x
     A useful function that returns, rather unefficiently, if x is a prime
     number or not. It is rather useful while used as a filter, eg:
     take(10, filter("prime", integers)) = [2, 3, 5, 7, 11, 13, 17, 19,
     23, 29].  In Haskell:

          primes = [n | n <- [2..], length (factors n) == 2]

AUTHOR
======

   Leon Brocard <`acme@astray.com'>

COPYRIGHT
=========

   Copyright (C) 1999, Leon Brocard

   This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.


