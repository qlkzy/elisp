This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Math/NumberCruncher,  Next: Math/PRSG,  Prev: Math/MatrixReal,  Up: Module List

Very useful, commonly needed math/statistics/geometric functions.
*****************************************************************

NAME
====

   Math::NumberCruncher - Very useful, commonly needed
math/statistics/geometric functions.

SYNOPSIS
========

   use Math::NumberCruncher;

   ($high, $low) = Math::NumberCruncher::Range(\@array);

   $mean = Math::NumberCruncher::Mean(\@array);

   $median = Math::NumberCruncher::Median(\@array);

   $odd_median = Math::NumberCruncher::OddMedian(\@array);

   $mode = Math::NumberCruncher::Mode(\@array);

   $covariance = Math::NumberCruncher::Covariance(\@array1, \@array2);

   $correlation = Math::NumberCruncher::Correlation(\@array1, \@array2);

   ($slope, $y_intercept) = Math::NumberCruncher::BestFit(\@array1,
\@array2);

   $distance = Math::NumberCruncher::Distance($x1,$y1,$z1,$x2,$y2,$z2);

   $distance = Math::NumberCruncher::Distance($x1,$y1,$x1,$x2);

   $distance = Math::NumberCruncher::ManhattanDistance($x1,$y1,$x2,$y2);

   $probAll = Math::NumberCruncher::AllOf('0.3','0.25','0.91','0.002');

   $probNone = Math::NumberCruncher::NoneOf('0.4','0.5772','0.212');

   $probSome = Math::NumberCruncher::SomeOf('0.11','0.56','0.3275');

   $factorial = Math::NumberCruncher::Factorial($some_number);

   $permutations = Math::NumberCruncher::Permutation($n);

   $permutations = Math::NumberCruncher::Permutation($n,$k);

   $roll = Math::NumberCruncher::Dice(3,12,4);

   $randInt = Math::NumberCruncher::RandInt(10,50);

   $randomElement = Math::NumberCruncher::RandomElement(\@array);

   @shuffled = Math::NumberCruncher::ShuffleArray(\@array);

   @unique = Math::NumberCruncher::Unique(\@array);

   @a_only = Math::NumberCruncher::Compare(\@a,\@b);

   @union = Math::NumberCruncher::Union(\@a,\@b);

   @intersection = Math::NumberCruncher::Intersection(\@a,\@b);

   @difference = Math::NumberCruncher::Difference(\@a,\@b);

   $gaussianRand = Math::NumberCruncher::GaussianRand();

   $prob = Math::NumberCruncher::Choose($n,$k);

   $binomial =
Math::NumberCruncher::Binomial($attempts,$successes,$probability);

   $gaussianDist = Math::NumberCruncher::GaussianDist($x,$mean,$variance);

   $StdDev = Math::NumberCruncher::StandardDeviation(\@array);

   $variance = Math::NumberCruncher::Variance(\@array);

   @scores = Math::NumberCruncher::StandardScores(\@array);

   $confidence =
Math::NumberCruncher::SignSignificance($trials,$hits,$probability);

   $e = Math::Numbercruncher::EMC2( "m512" [, 1] );

   $m = Math::NumberCruncher::EMC2( "e987432" [, 1] );

   $force = Math::NumberCruncher::FMA( "m12", "a73.5" );

   $mass = Math::NumberCruncher::FMA( "a43", "f1324" );

   $acceleration = Math::NumberCruncher::FMA( "f53512", "m356" );

   $predicted_value = Math::NubmerCruncher::Predict( $slope, $y_intercept,
$proposed_x );

   $area = Math::NumberCruncher::TriangleHeron( $a, $b, $c );

   $area = Math::NumberCruncher::TriangleHeron( 1,3, 5,7, 8,2 );

   $perimeter = Math::NumberCruncher::PolygonPerimeter( $x0,$y0, $x1,$y1,
$x2,$y2, ...);

   $direction = Math::NumberCruncher::Clockwise( $x0,$y0, $x1,$y1, $x2,$y2
);

   $collision = Math::NumberCruncher::InPolygon( $x, $y, @xy );

   @points = Math::NumberCruncher::BoundingBox_Points( $d, @p );

   $in_triangle = Math::NumberCruncher::InTriangle( $x,$y, $x0,$y0,
$x1,$y1, $x2,$y2 );

   $area = Math::NumberCruncher::PolygonArea( 0, 1, 1, 0, 2, 0, 3, 2, 2, 3
);

   $area = Math::NumberCruncher::CircleArea( $diameter );

   $circumference = Math::NumberCruncher::Circumference( $diameter );

   $volume = Math::NumberCruncher::SphereVolume( $radius );

   $surface_area = Math::NumberCruncher::SphereSurface( $radius );

DESCRIPTION
===========

   This module is a collection of commonly needed number-related
functions, including numerous standard statistical, geometric, and
probability functions.  Some of these functions are taken directly from
_Mastering Algorithms with Perl_, by Jon Orwant, Jarkko Hietaniemi, and
John Macdonald, and others are adapted heavily from same.  The remainder
are either original functions written by the author, or original
adaptations of standard algorithms.  Some of the functions are fairly
obvious, others are explained in greater detail below.  For all
calculations involving pi, the value of pi is taken out to 100 places.
Overkill? Probably, but it is better, in my opinion, to have too much
accuracy as opposed to not enough.

EXAMPLES
========

($high,$low) = *Math::NumberCruncher::Range*(\@array);
     Returns the largest and smallest elements in an array.

$mean = *Math::NumberCruncher::Mean*(\@array);
     Returns the mean, or average, of an array.

$median = *Math::NumberCruncher::Median*(\@array);
     Returns the median, or the middle, of an array.  The median may or
     may not be an element of the array itself.

$odd_median = *Math::NumberCruncher::OddMedian*(\@array);
     Returns the odd median, which, unlike the median, *is* an element of
     the array.  In all other respects it is similar to the median.

$mode = *Math::NumberCruncher::Mode*(\@array);
     Returns the mode, or most frequently occurring item, of @array.

$covariance = *Math::NumberCruncher::Covariance*(\@array1,\@array2);
     Returns the covariance, which is a measurement of the correlation of
     two variables.

$correlation = *Math::NumberCruncher::Correlation*(\@array1,\@array2);
     Returns the correlation of two variables. Correlation ranges from 1
     to -1, with a correlation of zero meaning no correlation exists
     between the two variables.

($slope,$y_intercept ) = *Math::NumberCruncher::BestFit*(\@array1,\@array2);
     Returns the slope and y-intercept of the line of best fit for the
     data in question.

$distance = *Math::NumberCruncher::Distance*($x1,$y1,$x1,$x2);
     Returns the Euclidian distance between two points.  The above example
     demonstrates the use in two dimensions. For three dimensions, use
     would be *$distance =
     *Math::NumberCruncher::Distance*($x1,$y1,$z1,$x2,$y2,$z2);*

$distance = *Math::NumberCruncher::ManhattanDistance*($x1,$y1,$x2,$y2);
     Modified two-dimensional distance between two points. As stated in
     _Mastering Algorithms with Perl_, "Helicopter pilots tend to think in
     Euclidian distance, good New York cabbies tend to think in Manhattan
     distance." Rather than distance "as the crow flies," this is distance
     based on a rigid grid, or network of streets, like those found in
     Manhattan.

$probAll = *Math::NumberCruncher::AllOf*('0.3','0.25','0.91','0.002');
     The probability that all of the probabilities in question will be
     satisfied. (i.e., the probability that the Steelers will win the
     SuperBowl and that David Tua will win the World Heavyweight Title in
     boxing.)

$probNone = *Math::NumberCruncher::NoneOf*('0.4','0.5772','0.212');
     The probability that none of the probabilities in question will be
     satisfied. (i.e., the probability that the Steelers will not win the
     SuperBowl and that David Tua will not win the World Heavyweight Title
     in boxing.)

$probSome = *Math::NumberCruncher::SomeOf*('0.11','0.56','0.3275');
     The probability that at least one of the probabilities in question
     will be satisfied. (i.e., the probability that either the Steelers
     will win the SuperBowl or David Tua will win the World Heavyweight
     Title in boxing.)

$factorial = *Math::NumberCruncher::Factorial*($some_number);
     The number of possible orderings of $factorial items. The factorial
     n! gives the number of ways in which n objects can be permuted.

$permutations = *Math::NumberCruncher::Permutation*($n);
     The number of permutations of $n elements.

$permutations = *Math::NumberCruncher::Permutation*($n,$k);
     The number of permutations of $k elements drawn from a set of $n
     elements.

$roll = *Math::NumberCruncher::Dice*($number,$sides,$plus);
     The obligatory dice rolling routine. Returns the result after passing
     the number of rolls of the die, the number of sides of the die, and
     any additional points to be added to the roll.  As commonly seen in
     role playing games, 4d12+5 would be expressed as *Dice(4,12,5)*.  The
     function defaults to a single 6-sided die rolled once without any
     points added.

$randInt = *Math::NumberCruncher::RandInt*(10,50);
     Returns a random integer between the two number passed to the
     function, inclusive. With no parameters passed, the function returns
     either 0 or 1.

$randomElement = *Math::NumberCruncher::RandomElement*(\@array);
     Returns a randome element from @array.

@shuffled = *Math::NumberCruncher::ShuffleArray*(\@array);
     Shuffles the elements of @array and returns them.

@unique = *Math::NumberCruncher::Unique*(\@array);
     Returns an array of the unique items in an array.

@a_only = *Math::NumberCruncher::Compare*(\@a,\@b);
     Returns an array of elements that appear only in the first array
     passed. Any elements that appear in both arrays, or appear only in
     the second array, are discarded.

@union = *Math::NumberCruncher::Union*(\@a,\@b);
     Returns an array of the unique elements produced from the joining of
     the two arrays.

@intersection = *Math::NumberCruncher::Intersection*(\@a,\@b);
     Returns an array of the elements that appear in both arrays.

@difference = *Math::NumberCruncher::Difference*(\@a,\@b);
     Returns an array of the symmetric difference of the two arrays. For
     example, in the words of _Mastering Algorithms in Perl_, "show me the
     web documents that talk about Perl or about sets *but not* those that
     talk about both.

$gaussianRand = *Math::NumberCruncher::GaussianRand*();
     Returns one or two floating point numbers based on the Gaussian
     Distribution, based upon the call wants an array or a scalar value.

$probability = *Math::NumberCruncher::Choose*($n,$k);
     Returns the probability of $k successes in $n tries.

$binomial = *Math::NumberCruncher::Binomial*($n,$k,$p);
     Returns the probability of $k successes in $n tries, given a
     probability of $p. (i.e., if the probability of being struck by
     lightning is 1 in 75,000, in 100 days, the probability of being
     struck by lightning exactly twice would be expressed as
     *Binomial('100','2','0.0000133')*)

$probability = *Math::NumberCruncher::GaussianDist*($x,$mean,$variance);
     Returns the probability, based on Gaussian Distribution, of our
     random variable, $x, given the $mean and $variance.

$StdDev = *Math::NumberCruncher::StandardDeviation*(\@array);
     Returns the Standard Deviation of @array, which is a measurement of
     how diverse your data is.

$variance = *Math::NumberCruncher::Variance*(\@array);
     Returns the variance for @array, which is the square of the standard
     deviation.  Or think of standard deviation as the square root of the
     variance.  Variance is another indicator of the diversity of your
     data.

@scores = *Math::NumberCruncher::StandardScores*(\@array);
     Returns an array of the number of standard deviations above the mean
     for @array.

$confidence = *Math::NumberCruncher::SignSignificance*($trials,$hits,$probability);
     Returns the probability of how likely it is that your data is due to
     chance.  The lower the confidence, the less likely your data is due
     to chance.

$e = *Math::NumberCruncher::EMC2*( "m36" [, 1] );
     Implementation of Einstein's E=MC**2.  Given either energy or mass,
     the function returns the other. When passing mass, the value must be
     preceeded by a "m," which may be either upper or lower case.  When
     passing energy, the value must be preceeded by a "e," which may be
     either upper or lower case. The function defaults to using kilometers
     per second for the speed of light.  To make the function use miles
     per second for the speed of light, simply pass any non-zero value as
     the second value.

$force = *Math::NumberCruncher::FMA*( "m97", "a53" );
     Implementation of the stadard force = mass * acceleration formula.
     Given two of the three variables (i.e., mass and force, mass and
     acceleration, or acceleration and force), the function returns the
     third.  When passing the values, mass must be preceeded by a "m,"
     force must be preceeded by a "f," and acceleration must be preceeded
     by an "a."  Case is irrelevant.

$predicted = *Math::NumberCruncher::Predict*( $slope, $y_intercept, $proposed_x );
     Useful for predicting values based on data trends, as calculated by
     BestFit(). Given the slope and y-intercept, and a proposed value of
     x, returns corresponding y.

$area = *Math::NumberCruncher::TriangleHeron*( $a, $b, $c );
     Calculates the area of a triangle, using Heron's formula.
     TriangleHeron() can be passed either the lengths of the three sides
     of the triangle, or the (x,y) coordinates of the three verticies.

$perimeter = *Math::NumberCruncher::PolygonPerimeter*( $x0,$y0, $x1,$y1, $x2,$y2, ...);
     Calculates the length of the perimeter of a given polygon.

$direction = *Math::NumberCruncher::Clockwise*( $x0,$y0, $x1,$y1, $x2,$y2 );
     Given three pairs of points, returns a positive number if you must
     turn clockwise when moving from p1 to p2 to p3, returns a negative
     number if you must turn counter-clockwise when moving from p1 to p2
     to p3, and a zero if the three points lie on the same line.

$collision = *Math::NumberCruncher::InPolygon*( $x, $y, @xy );
     Given a set of xy pairs (@xy) that define the perimeter of a polygon,
     returns a 1 if point ($x,$y) is inside the polygon and returns 0 if
     the point ($x,$y) is outside the polygon.

@points = *Math::NumberCruncher::BoundingBox_Points*( $d, @p );
     Given a set of @p points and $d dimensions, returns two points that
     define the upper left and lower right corners of the bounding box for
     set of points @p.

$in_triangle = *Math::NumberCruncher::InTriangle*( $x,$y, $x0,$y0, $x1,$y1, $x2,$y2 );
     Returns true if point $x,$y is inside the triangle defined by points
     ($x0,$y0), ($x1,$y1), and ($x2,$y2)

$area = *Math::NumberCruncher::PolygonArea*( 0, 1, 1, 0, 3, 2, 2, 3, 0, 2 );
     Calculates the area of a polygon using determinants.

$area = *Math::NumberCruncher::CircleArea*( $diameter );
     Calculates the area of a circle, given the diameter.

$circumference = *Math::NumberCruncher::Circumference*( $diameter );
     Calculates the circumference of a circle, given the diameter.

$volume = *Math::NumberCruncher::SphereVolume*( $radius );
     Calculates the volume of a sphere, given the radius.

$surface_area = *Math::NumberCruncher::SphereSurface*( $radius );
     Calculates the surface area of a sphere, given the radius.

AUTHOR
======

   Kurt Kincaid, sifukurt@yahoo.com Jon Orwant Jarkko Hietaniemi John
Macdonald

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Math/PRSG,  Next: Math/Polynomial,  Prev: Math/NumberCruncher,  Up: Module List

Perl interface to pseudo random sequence generator function.
************************************************************

NAME
====

   PRSG - Perl interface to pseudo random sequence generator function.

SYNOPSIS
========

     use Math::PRSG;

DESCRIPTION
===========

   This perl extension implements a (159, 31, 0) LFSR, giving a period of
160 bits.  This can then be used as a RNG if seeded well (ie. with 160
bits of entropy) and if the output is fed through a message digest
function (in order to prevent any prediction).

FUNCTIONS
=========

new
          my $prsg = new PRSG $seed;

     Create a new PRSG object.  A 160 bit (20-byte) $seed must be provided,
     which is used to seed the LFSR.

seed
          $prsg->seed($rnd);

     Seed the LFSR with $rnd.

clock
          $value = $prsg->clock();

     Clock the LFSR, returning the new register value as a 20-byte string.

COPYRIGHT
=========

   Systemics Ltd ( http://www.systemics.com/ )


File: pm.info,  Node: Math/Polynomial,  Next: Math/Polynomial/Solve,  Prev: Math/PRSG,  Up: Module List

Perl class for working with polynomials.
****************************************

NAME
====

   Math::Polynomial - Perl class for working with polynomials.

SYNOPSIS
========

     use Math::Polynomial;

     # The polynomial 2x^2 + 3x - 2
         my $P = Math::Polynomial->new(2,3,-2);

     # Evaluate the polynomial for x = 10
     my $result = $P->eval(10);

     # The polynomial 3x + 4
     my $Q = Math::Polynomial->new(3,4);

     print "$P / $Q = ", $P / $Q, "\n";

     my $polynomial = Math::Polynomial::interpolate(1 => 5, 2 => 12, 3 => 6);

DESCRIPTION
===========

   This module implements single variable polynomials using arrays. It also
implements some useful functionality when working with polynomials, such
as adding, multiplication, etc.

CONSTRUCTOR
===========

   The following constructors exist to create new polynomials.

new(*coefficient*, ...)
     A new polynomial is constructed. The coefficient for the highest
     degree term is first in the list, while the constant (the coefficient
     for X**0) is the last one in the list.

CLASS METHODS
=============

   Here is a list of class methods available. The methods can be applied
to individual polynomials or `Math::Polynomial'. If it is applied to an
object it will affect the entire class.

configure(variable => value, ...)
     Configure various things regarding the class. Following is a list of
     variables used by the class.

    PLUS
          The string inserted as a plus sign between terms.  Default is `'
          + ''.

    MINUS
          The string inserted as a minus sign between terms. If the first
          coefficient is negative, this string without spaces is used as
          prefix.  Default is `' - ''.

    TIMES
          The string inserted as multiplication between the coefficients
          and the variables. Default is '*'.

    POWER
          The string inserted as power between the variable and the power.
          Default is `'**''.

    VARIABLE
          The string used as variable in the polynom. Default is `'$X''.

quotrem(*numerator*,*denominator*)
     This method computes the quotient and the remainder when dividing
     *numerator* by *denominator* and returns a list
     (*quotient*,*remainder*). It is used by the operators / and %.

     It uses the *Euclidian algorithm* for division, hence we have a
     complexity of *O(n*m)* where n and m are the degrees of the
     polynomials.

verbose(*bool*)
     If verbose is turned on, string conversion will return a string for
     the polynomial, otherwise a list of coefficients will be returned.

OBJECT METHODS
==============

   Here is a list of object methods available. Object methods are applied
to the object in question, in contrast with class methods which are
applied to a class.

clone()
     This method will clone the polynomial and return a copy of it.

coeff(*degree*)
     This method returns the coefficient for degree *degree*.

degree()
     This method returns the degree of the polynomial. The degree of a
     polynomial is the maximum of the degree of terms with non-zero
     coefficients.

eval(value)
     The polynomial is evaluated for value. The evaluation is done using
     *Horners rule*, hence evaluation is done in *O(n)* time, where n is
     the degree of the polynomial.

size()
     This method returns the internal size of the polynomial, i.e. the
     length of the array where the coefficients are stored. After a
     tidy(), *degree* is equal to size-1.

tidy()
     This method removes all terms which are redundant, i.e. the
     coefficients where all higher degree coefficients are zero.

     This method is never called automatically, since it is assumed that
     the programmer knows best when to tidy the polynomial.

OPERATORS
=========

   There is a set of operators defined for polynomials.

polynomial + polynomial
     Adds two polynomials together, returning the sum. The operation is
     *O(n)*, where n is the maximum of the degrees of the polynomials.

polynomial - polynomial
     Substracts the right polynomial from the left polynomial, returning
     the difference. The operation is *O(n)*, where n is the maximum of
     the degrees of the polynomials.

polynomial * polynomial
     Multiplies two polynomials together, returning the product. The
     operation is *O(n*m)*, where n and m are the degrees of the
     polynomials respectively.

polynomial / polynomial
     Divides the polynomial on the left (called the numerator) with the
     polynomial on the right (called the denominator) and returns the
     quotient. If the degree of the denominator is greater than the degree
     of the numerator, the zero polynomial will be returned.

polynomial % polynomial
     Divides the polynomial on the left (called the numerator) with the
     polynomial on the right (called the denominator) and returns the
     remainder of the division. If the degree of the denominator is greater
     than the degree of numerator, the numerator will be returned.

String conversion.
     If verbose is turned on, the polynomial will be converted to a string
     where '$X' is used as the variable. If a coefficient is zero, that
     term will not be printed.

     To change the string used as variable, use the configure class method
     described above.

     If verbose is turned off, a parenthesised, $"-separated list will be
     returned.

SUBROUTINES
===========

interpolate(x => y, ...)
     Given a set of pairs of x and y values, interpolate will return a
     polynomial which interpolates those values. The data points are
     supplied as a list of alternating x and y values.

     The degree of the resulting polynomial will be one less than the
     number of pairs, e.g. the polynomial in the synopsis will be of
     degree 2.

     The interpolation is done using *Lagrange's formula* and the
     implementation runs in *O(n^2)*, where n is the number of pairs
     supplied to interpolate.

     Please note that it is a *bad idea* to use interpolation for
     extrapolation, i.e. if you are interpolating a polynomial for
     x-values in the range 0 to 10, then you may get terrible results if
     you try to predict y-values outside this range. This is true
     especially if the true function is not a polynomial.

INTERNAL METHODS
================

   The methods in this section are internal and should not acually be used
for anything but internal stuff. They are documented here anyway, but
beware that these methods may change or dissapear without notice!

dump()
     Returns a compact, but human readable, string representing the object.

mul1c(c)
     Multiply the polynomial by *(x - c)*. Used internally by the
     interpolation package.

div1c(c)
     Divide the polynomial by *(x - c)*. Used internally by the
     interpolation package.

SEE ALSO
========

   *A Perl Module for Polynomial Interpolation*

COPYRIGHT
=========

   Copyright 1997 Matz Kindahl. All rights reserved.

   This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Math/Polynomial/Solve,  Next: Math/Rand48,  Prev: Math/Polynomial,  Up: Module List

Find the roots of polynomial equations.
***************************************

NAME
====

   Math::Polynomial::Solve - Find the roots of polynomial equations.

SYNOPSIS
========

     use Math::Complex;  # The roots may be complex numbers.
     use Math::Polynomial::Solve qw(poly_roots);

     my @x = poly_roots(@coefficients);

   or

     use Math::Complex;  # The roots may be complex numbers.
     use Math::Polynomial::Solve
     	qw(linear_roots quadratic_roots cubic_roots quartic_roots);

     # Find the roots of ax + b
     my @x1 = linear_roots($a, $b);

     # Find the roots of ax**2 + bx +c
     my @x2 = quadratic_roots($a, $b, $c);

     # Find the roots of ax**3 + bx**2 +cx + d
     my @x3 = cubic_roots($a, $b, $c, $d);

     # Find the roots of ax**4 + bx**3 +cx**2 + dx + e
     my @x4 = quartic_roots($a, $b, $c, $d, $e);

DESCRIPTION
===========

   This package supplies a set of functions that find the roots of
polynomials up to the quartic. There are no solutions for powers higher
than that at this time (partly because there are no general solutions for
fifth and higher powers).

   The linear, quadratic, cubic, and quartic *_roots() functions all expect
to have a non-zero value for the $a term.

   Passing a zero constant term means that the first value returned from
the function will always be zero, for all functions.

poly_roots()
------------

   A generic function that calls one of the other root-finding functions,
depending on the degree of the polynomial. Returns the solution for
polynomials of degree 1 to degree 4.

   Unlike the other root-finding functions, it will check for coefficients
of zero for the highest power, and 'step down' the degree of the
polynomial to the appropriate case. Additionally, it will check for
coefficients of zero for the lowest power terms, and add zeros to its root
list before calling one of the root-finding functions. Therefore, it is
possible to solve a polynomial of degree higher than 4, as long as it
meets these rather specialized conditions.

linear_roots()
--------------

   Here for completeness's sake more than anything else. Returns the
solution for

     ax + b = 0

   by returning `-b/a'. This may be in either a scalar or an array context.

quadratic_roots()
-----------------

   Gives the roots of the quadratic equation

     ax**2 + bx + c = 0

   using the well-known quadratic formula. A two-element list is returned.

cubic_roots()
-------------

   Gives the roots of the cubic equation

     ax**3 + bx**2 + cx + d = 0

   by the method described by R. W. D. Nickalls (see the Acknowledgments
section below). A three-element list is returned. The first element will
always be real. The next two values will either be both real or both
complex numbers.

quartic_roots()
---------------

   Gives the roots of the quartic equation

     ax**4 + bx**3 + cx**2 + dx + e = 0

   using Ferrari's method (see the Acknowledgments section below). A
four-element list is returned. The first two elements will be either both
real or both complex. The next two elements will also be alike in type.

EXPORT
------

   There are no default exports. The functions may be named in an export
list.

Acknowledgments
===============

The cubic
---------

   The cubic is solved by the method described by R. W. D. Nickalls, "A New
Approach to solving the cubic: Cardan's solution revealed," The
Mathematical Gazette, 77, 354-359, 1993. This article is available on the
web at http://www.m-a.org.uk/eb/mg/mg077ch.pdf.

   Dr. Nickalls was kind enough to send me his article, with notes and
revisions, and directed me to a Matlab script that was based on that
article, written by Herman Bruyninckx, of the Dept. Mechanical Eng., Div.
PMA, Katholieke Universiteit Leuven, Belgium. This function is an almost
direct translation of that script, and I owe Herman Bruyninckx for
creating it in the first place. It may be found on the web at
http://www.mech.kuleuven.ac.be/~bruyninc/matlab/cubic.ml

   Dick Nickalls, dicknickalls@compuserve.com

   Herman Bruyninckx, Herman.Bruyninckx@mech.kuleuven.ac.be,
http://www.mech.kuleuven.ac.be/~bruyninc

The quartic
-----------

   The method for quartic solution is Ferrari's, as described in the web
page Karl's Calculus Tutor, http://www.netsrq.com/~hahn/quartic.html.  I
also made use of some short cuts mentioned in web page Ask Dr. Math FAQ,
http://forum.swarthmore.edu/dr.math/faq/faq.cubic.equations.html.

Other functionality
-------------------

   Matz Kindahl, the author of Math::Polynomial, suggested the poly_roots()
function.

SEE ALSO
========

   Forsyth, George E., Michael A. Malcolm, and Cleve B. Moler (1977),
Computer Methods for Mathematical Computations, Prentice-Hall.

AUTHOR
======

   John M. Gamble, jgamble@ripco.com


File: pm.info,  Node: Math/Rand48,  Next: Math/Random,  Prev: Math/Polynomial/Solve,  Up: Module List

perl bindings for drand48() family of random functions
******************************************************

NAME
====

   Math::Rand48 - perl bindings for drand48() family of random functions

SYNOPSIS
========

     use Math::Rand48;
     
     my $n = drand48();        # Float value [0.0,1.0)
     my $seed = seed48();      # Get seed for drand48, lrand48, mrand48
     my $m = erand48($seed);   # Float value [0.0,1.0) - modifies $seed

     seed48($seed);            # Set seed for drand48, lrand48, mrand48

     use Math::Rand48 qw(lrand48);
     my $un = lrand48();
     my $um = nrand48($seed);

DESCRIPTION
===========

   This package provides an interface to the 48-bit family of random number
functions, commonly provided on UNIX systems.

`seed48'
     Returns the current seed used by `drand48', `lrand48', `mrand48'.  If
     given an argument sets the seed to that value.

`drand48'

`erand48'($seed)
     Return float value in range [0.0,1.0).  Multiple independent streams
     of numbers can be obtained using `erand48'.

`lrand48'

`nrand48'($seed)
     Return integer in range [0,2**31).  Multiple independent streams of
     numbers can be obtained using `nrand48'.

`mrand48'

`jrand48'($seed)
     Return integer in range [-2**31,2**31).  Multiple independent streams
     of numbers can be obtained using `jrand48'.

Seed values
-----------

   The *$seed* above are perl scalars. When in use they are converted to 6
byte binary "strings". If the incoming value is a string of less then 6
bytes it is padded with 0xFF. If the incoming value is a string of more
than 6 bytes it is "hashed" using perl's hash function to yield a 32 bit
value which is then padded with two bytes of 0xFF. If the incoming value
is an integer it is used for 4 bytes, with two bytes of 0xFF.

AUTHOR
======

   Nick Ing-Simmons <nick@ni-s.u-net.com>


File: pm.info,  Node: Math/Random,  Next: Math/Round,  Prev: Math/Rand48,  Up: Module List

Random Number Generators
************************

NAME
====

   *Math::Random* - Random Number Generators

SYNOPSIS
========

   *      use Math::Random;

     Exports the following routines by default (see `DEFAULT ROUTINES' in
     this node):

          random_set_seed_from_phrase
          random_get_seed
          random_seed_from_phrase
          random_set_seed
          random_uniform
          random_uniform_integer
          random_permutation
          random_permuted_index
          random_normal

     In this case the extended routines (see `"EXTENDED ROUTINES"' in this
     node) can be used by    qualifying  them  explicitly  with
     `Math::Random::',   for example: `$stdexp =
     Math::Random::random_exponential();'

   *      use Math::Random qw(random_beta
                              random_chi_square
                              random_exponential
                              random_f
                              random_gamma
                              random_multivariate_normal
                              random_multinomial
                              random_noncentral_chi_square
                              random_noncentral_f
                              random_normal
                              random_permutation
                              random_permuted_index
                              random_uniform
                              random_poisson
                              random_uniform_integer
                              random_negative_binomial
                              random_binomial
                              random_seed_from_phrase
                              random_get_seed
                              random_set_seed_from_phrase
                              random_set_seed );

     Exports all the routines explicitly.  Use a subset of the list for the
     routines you want.

   *      use Math::Random qw(:all);

     Exports all the routines, as well.

DESCRIPTION
===========

   *Math::Random* is  a Perl port  of the C version of *randlib*, which is
 a suite of  routines for  generating  random deviates.  See `"RANDLIB"'
in this node for more information.

   This port supports all of the distributions  from which the *Fortran*
and C  versions generate deviates.   The major functionalities that are
excluded  are   the  multiple  generators/splitting  facility  and
antithetic  random number  generation.   These facilities,  along with
some of  the distributions which *are*  included, are probably not of
interest   except  to the   very  sophisticated   user.  If there   is
sufficient interest, the excluded   facilities will be included in   a
future  release.   The code  to   perform the  excluded facilities  is
available as *randlib* in *Fortran* and C source.

Default routines:
-----------------

   The routines which are exported by default are  the only ones that the
average Perl programmer is likely to need.

`random_set_seed_from_phrase($phrase)'
     Sets  the  seed   of the  base  generator  to   a  value determined by
     *$phrase*.  The value used for a given  *$phrase* is consistent from
     implementation to implementation  (it   does not rely on   the machine
     collating sequence).    Note:  When the   Perl processor   loads
     package  *Math::Random*  the seed  is set   to a value  based on  the
     current time.  The seed  changes  each time *Math::Random*  generates
     something random.

     The ability to set the seed is useful for debugging,  or for those who
     like reproducible runs.

`random_get_seed()'
     Returns  an   array of  length two  which  contains  the  two integers
     constituting  the seed   (assuming   a call   in array   context).  An
     invocation   in  a scalar  context  returns   the  integer 2, which is
     probably not useful.

`random_seed_from_phrase($phrase)'
     Returns   an  array of  length  two which  contains   the two integers
     consituting   the seed   (assuming a    call  in array  context).   An
     invocation   in  a scalar  context returns  the   integer  2, which is
     probably not useful.  The  seed generated is the seed  used to set the
     seed in a  call to `random_set_seed_from_phrase'.

     Note:   the  following  two calls  (for   the  same *$phrase*) are
     equivalent:

          random_set_seed(random_seed_from_phrase($phrase));

     and

          random_set_seed_from_phrase($phrase);

`random_set_seed(@seed)'
     Sets  the  seed  of the  base  generator  to  the value *@seed*[0,1].
     Usually, the  argument  *@seed* should be  the result  of  a  call to
     `random_get_seed'  or `random_seed_from_phrase'.  *@seed*[0,1] must
     be two integers in the range (1, 1) to (2147483562, 2147483398),
     inclusive.

`random_uniform($n, $low, $high)'
`random_uniform($n)'
`random_uniform()'
     When called  in an array context,  returns an array of  $n deviates
     generated from   a *uniform($low,* *$high)* distribution.    When
     called in  a scalar context,    generates and returns only  one   such
     deviate as a scalar, regardless of the value of $n.

     Argument restrictions: *$low* must be less than or equal to *$high*.

     Defaults are  (1, 0, 1).    Note:  *$high* must   be specified if
     *$low* is specified.

`random_uniform_integer($n, $low, $high)'
     When called  in an array context,  returns  an array of  $n integer
     deviates generated from  a  *uniform($low,* *$high)* distribution on
     the   integers.  When called   in a  scalar context, generates  and
     returns only one such deviate as a  scalar, regardless of the value of
     $n.

     Argument  restrictions: *$low* and *$high*  are  first rounded using
     `int()'; the resulting *$low* must be less than or equal to *$high*,
     and  the  resulting  range  *($high* - *$low)*  must not be and  the
     resulting  range  *($high - $low)*  must not be greater than
     2147483561.

     There are no defaults; all three arguments must be provided.

`random_permutation(@array)'
     Returns *@array*, randomly permuted.

`random_permuted_index($n)'
     Returns  an array  of  array indices, randomly  permuted.  The indices
     used are (0, ... ,($n -  1)).  This produces the indices used by
     `random_permutation' for a given seed, without passing arrays.

     Note: the following are equivalent:

          random_set_seed_from_phrase('jjv');
          random_permutation(@array);

     and

          random_set_seed_from_phrase('jjv');
          @array[(random_permuted_index(scalar(@array)))];

`random_normal($n, $av, $sd)'
`random_normal($n, $av)'
`random_normal($n)'
`random_normal()'
     When called in  an array context, returns  an array  of $n deviates
     generated from a *normal($av, $sd^2)* distribution.  When called in a
     scalar context,  generates  and returns  only one  such   deviate as a
     scalar, regardless of the value of $n.

     Argument restrictions: *$sd* must be non-negative.

     Defaults are (1, 0, 1).

Extended Routines:
------------------

   These routines generate deviates from many other distributions.

   Note: The parameterizations of these deviates are standard (insofar as
there *is* a  standard ...  ) but  particular attention  should be paid to
the distributions of the *beta*  and *gamma* deviates (noted in
`random_beta' and `random_gamma' below).

`random_beta($n, $aa, $bb)'
     When called in an array  context, returns an  array of $n  deviates
     generated from  the  *beta* distribution  with parameters  *$aa* and
     *$bb*.  The density of the beta is:

     X^(*$aa* - 1) * (1 - X)^(*$bb* - 1) / B(*$aa* , *$bb*) for 0 < X < 1.

     When called in  a scalar context, generates  and returns only one such
     deviate as a scalar, regardless of the value of $n.

     Argument restrictions:  Both *$aa* and *$bb* must  not  be less than
     `1.0E-37'.

     There are no defaults; all three arguments must be provided.

`random_binomial($n, $nt, $p)'
     When called  in an array context,  returns an array  of $n outcomes
     generated  from the  binomial  distribution with  number  of trials
     *$nt* and probability of an  event in each  trial $p.  When called in
     a scalar context, generates and returns  only one such outcome as a
     scalar, regardless of the value of $n.

     Argument restrictions: *$nt*  is rounded  using `int()'; the  result
     must be non-negative.  $p must be between 0 and 1 inclusive.

     There are no defaults; both arguments must be provided.

`random_chi_square($n, $df)'
     When called in an  array context, returns an  array of $n  deviates
     generated from the *chi-square*  distribution with *$df* degrees  of
     freedom.  When called in a  scalar context, generates and returns only
     one such deviate as a scalar, regardless of the value of $n.

     Argument restrictions: *$df* must be positive.

     There are no defaults; both arguments must be provided.

`random_exponential($n, $av)'
`random_exponential($n)'
`random_exponential()'
     When  called in an  array context, returns  an array of $n deviates
     generated from the *exponential* distribution with mean *$av*.  When
     called    in a scalar  context, generates   and  returns only one such
     deviate as a scalar, regardless of the value of $n.

     Argument restrictions: *$av* must be non-negative.

     Defaults are (1, 1).

`random_f($n, $dfn, $dfd)'
     When called  in an array  context, returns an  array of $n deviates
     generated from the F  (variance ratio) distribution with degrees of
     freedom *$dfn* (numerator) and *$dfd* (denominator).  When called in
     a scalar context,  generates and  returns only  one such deviate  as a
     scalar, regardless of the value of $n.

     Argument restrictions: Both *$dfn* and *$dfd* must be positive.

     There are no defaults; all three arguments must be provided.

`random_gamma($n, $a, $r)'
     When called in  an array context, returns  an array of  $n deviates
     generated from  the  *gamma* distribution  with  parameters *$a* and
     $r.  The density of the gamma is:

     (*$a***$r) / Gamma($r) * X**($r - 1) * Exp(-*$a**X)

     When called in  a scalar context, generates and  returns only one such
     deviate as a scalar, regardless of the value of $n.

     Argument restrictions: Both *$a* and $r must be positive.

     There are no defaults; all three arguments must be provided.

`random_multinomial($n, @p)'
     When called in an array  context, returns single observation from  the
     *multinomial* distribution, with $n events classified into as many
     categories as the length of *@p*.   The probability of an event being
     classified into category i is given by the ith element of *@p*.  The
     observation is an array with length equal to *@p*, so when called in
     a scalar  context it  returns  the length  of @p.   The sum of  the
     elements of the observation is equal to $n.

     Argument  restrictions: $n is  rounded  with `int()' before it  is
     used; the  result  must be  non-negative.   *@p* must have  length at
     least 2.  All elements of *@p* except the  last must be between 0 and
     1  inclusive, and sum to  no  more than   0.99999.  Note: The  last
     element of *@p* is a dummy to indicate  the number of categories, and
     it is adjusted to bring the sum of the elements of *@p* to 1.

     There are no defaults; both arguments must be provided.

`random_multivariate_normal($n, @mean, @covar)'
     When  called in an array context,  returns  an array of $n deviates
     (each   deviate  being    an  array  reference) generated   from   the
     *multivariate  normal*  distribution with  mean  vector *@mean*  and
     variance-covariance  matrix  *@covar*.     When called  in  a  scalar
     context,  generates and  returns only  one  such  deviate  as an array
     reference, regardless of the value of $n.

     Argument restrictions: If the dimension of the deviate to be generated
     is p,  *@mean*  should be a   length p array  of real  numbers.
     *@covar* should be  a length p array of  references to length p
     arrays of real  numbers  (i.e.  a  p  by  p  matrix).   Further,
     *@covar* should be a symmetric positive-definite matrix, although the
     Perl code does  not check positive-definiteness, and the underlying C
     code    assumes  the  matrix  is   symmetric.    Given that   the
     variance-covariance matrix is  symmetric, it   doesn't matter if   the
     references  refer   to rows  or columns.   If  a non-positive definite
     matrix is passed  to the function,  it  will abort with the  following
     message:

          COVM not positive definite in SETGMN

     Also,  a    non-symmetric   *@covar* may    produce  deviates without
     complaint,  although they may not  be  from the expected distribution.
     For  these reasons, you  are   encouraged  to *verify  the  arguments
     passed*.

     The Perl code *does*   check  the dimensionality of *@mean*   and
     *@covar* for consistency.  It does so by  checking that the length of
     the argument  vector  passed is  odd,  that  what  should be the  last
     element of *@mean* and the first element  of *@covar* look like they
     are a number followed by an array reference respectively, and that the
     arrays referred to in *@covar* are as long as *@mean*.

     There are no defaults; all three arguments must be provided.

`random_negative_binomial($n, $ne, $p)'
     When  called in an  array context, returns  an array of $n outcomes
     generated from the  *negative  binomial* distribution with number  of
     events *$ne* and  probability of an event  in each trial $p.  When
     called  in  a scalar   context, generates  and  returns only  one such
     outcome as a scalar, regardless of the value of $n.

     Argument restrictions: *$ne* is   rounded using `int()', the  result
     must be positive.  $p must be between 0 and 1 exclusive.

     There are no defaults; both arguments must be provided.

`random_noncentral_chi_square($n, $df, $nonc)'
     When called in  an array context, returns  an array  of $n deviates
     generated  from the *noncentral  chi-square* distribution with *$df*
     degrees of freedom and noncentrality  parameter *$nonc*.  When called
     in a scalar context, generates and returns only  one such deviate as a
     scalar, regardless of the value of $n.

     Argument restrictions:   *$df* must be at  least  1, *$nonc* must be
     non-negative.

     There are no defaults; all three arguments must be provided.

`random_noncentral_f($n, $dfn, $dfd, $nonc)'
     When called in  an array context, returns an  array of  $n deviates
     generated from the *noncentral F*  (variance ratio) distribution with
     degrees of freedom *$dfn* (numerator)  and *$dfd* (denominator); and
     noncentrality parameter *$nonc*.   When  called in a  scalar context,
     generates and returns only one such deviate as a scalar, regardless of
     the value of $n.

     Argument restrictions:  *$dfn* must  be at least   1, *$dfd* must be
     positive, and *$nonc* must be non-negative.

     There are no defaults; all four arguments must be provided.

`random_poisson($n, $mu)'
     When called  in an array context,  returns an array  of $n outcomes
     generated  from the Poisson  distribution  with mean  *$mu*.  When
     called  in a  scalar   context, generates and  returns  only  one such
     outcome as a scalar, regardless of the value of $n.

     Argument restrictions: *$mu* must be non-negative.

     There are no defaults; both arguments must be provided.

ERROR HANDLING
==============

   The Perl code should croak if bad arguments are passed or if the
underlying C code  cannot allocate the  necessary memory.  The only error
which should kill the job without  croaking is a non-positive definite
   variance-covariance      matrix      passed        to
`random_multivarite_normal' (see `"EXTENDED ROUTINES"' in this node).

RANDLIB
=======

   *randlib*  is available in *Fortran* and  C source form, and will soon
be available in *Fortran90* source as well.  *randlib.c* can be obtained
from     *statlib*.  Send mail   whose  message   is *'send randlib.c.shar
from general'* to:

     statlib@lib.stat.cmu.edu

   *randlib.c*   can  also  be    obtained    by  anonymous  ftp   to:

     odin.mdacc.tmc.edu (143.111.62.32)

   where it is available as

     /pub/source/randlib.c-1.3.tar.gz

   For obvious reasons, the original *randlib*  (in *Fortran*) has been
renamed to

     /pub/source/randlib.f-1.3.tar.gz

   on the same machine.

   Our FTP index is on file `./pub/index'.

   If you have Internet access and a browser you might note the following
web site addresses:

   University of Texas M. D. Anderson Cancer Center Home Page:

     http://utmdacc.mdacc.tmc.edu/

   Department of Biomathematics Home Page:

     http://odin.mdacc.tmc.edu/

   Available Software:

     http://odin.mdacc.tmc.edu/anonftp/

SUPPORT
=======

   This work  was supported  in part by  grant CA-16672 from the National
Cancer Institute.  We are grateful  to Larry and  Pat McNeil of Corpus
Cristi for their generous support.  Some equipment used in this effort was
provided by IBM as part of a cooperative study agreement; we thank them.

CODE MANIPULATION
=================

   The   C  version of  *randlib*  was  obtained  by  translating the
original   *Fortran*     *randlib*  using  *PROMULA.FORTRAN*,   and
performing some hand crafting of the result.

   Information on *PROMULA.FORTRAN* can be obtained from:

     PROMULA Development Corporation
      3620 N. High Street, Suite 301
     			 Columbus, Ohio 43214
     			    (614) 263-5454

   `wrapper.c'  was created  by   using  *SWIG*, and  performing   some
modification of the result.    *SWIG* also produced the skeleton   of
`Random.pm'.

   Information on *SWIG* can be obtained from:

     http://www.cs.utah.edu/~beazley/SWIG

   and

     ftp://ftp.cs.utah.edu/pub/beazley/SWIG

SOURCES
=======

   The following routines,  which  were  written by others   and  lightly
modified for consistency in packaging, are included in *randlib*.

Bottom Level Routines
     These routines are a transliteration of the *Pascal* in the reference
     to *Fortran*, and thence to C.

     L'Ecuyer, P., and Cote, S. "Implementing  a Random Number Package with
     Splitting  Facilities."  ACM  Transactions   on Mathematical Software,
     17:98-111 (1991).

Exponential
     This code was obtained from Netlib.

     Ahrens, J. H., and Dieter, U.  "Computer Methods for Sampling from the
     Exponential and Normal  Distributions."  Comm. ACM, 15,10 (Oct. 1972),
     873-882.

Gamma
     (Case R >= 1.0)

     Ahrens, J. H., and Dieter, U. "Generating Gamma Variates by a Modified
     Rejection Technique."  Comm. ACM, 25,1 (Jan. 1982), 47-54.  Algorithm
     GD

     (Case 0.0 <= R <= 1.0)

     Ahrens, J. H.,  and  Dieter, U.  "Computer Methods  for Sampling  from
     Gamma, Beta, Poisson and Binomial Distributions."  Computing, 12
     (1974), 223-246.  Adaptation of algorithm GS.

Normal
     This code was obtained from netlib.

     Ahrens, J. H., and  Dieter, U.   "Extensions of  Forsythe's Method for
     Random Sampling  from the Normal Distribution."  Math. Comput., 27,124
     (Oct. 1973), 927-937.

Binomial
     This code was kindly sent to Dr. Brown by Dr. Kachitvichyanukul.

     Kachitvichyanukul, V., and Schmeiser,  B. W.  "Binomial Random Variate
     Generation."  Comm. ACM, 31, 2 (Feb. 1988), 216.

Poisson
     This code was obtained from netlib.

     Ahrens, J. H., and Dieter, U. "Computer Generation of Poisson Deviates
     from Modified Normal Distributions."  ACM Trans.  Math. Software, 8, 2
     (June 1982), 163-179.

Beta
     This code was written by us following the recipe in the following.

     Cheng, R. C. H.  "Generating  Beta Variables  with  Nonintegral  Shape
     Parameters."  Comm. ACM, 21:317-322 (1978). (Algorithms BB and BC)

Linpack
     Routines   `SPOFA' and  `SDOT' are  used    to perform  the Cholesky
     decomposition of   the covariance matrix  in  `SETGMN'  (used for the
     generation of multivariate normal deviates).

     Dongarra, J. J., Moler,   C.  B., Bunch, J.   R., and  Stewart, G.  W.
     Linpack User's Guide.  SIAM Press, Philadelphia.  (1979)

Multinomial
     The  algorithm is from  page 559  of Devroye,  Luc Non-Uniform  Random
     Variate Generation.  New York: Springer-Verlag, 1986.

Negative Binomial
     The  algorithm is from  page 480  of Devroye,  Luc Non-Uniform  Random
     Variate Generation.  New York: Springer-Verlag, 1986.

VERSION
=======

   This POD documents *Math::Random* version 0.61.

AUTHORS
=======

   * *Math::Random* (the Perl port  of *Randlib*) was put  together by
     John Venier  and Barry W. Brown with help from  *SWIG*.  For  version
     0.61, Geoffrey Rommel made various cosmetic changes.

   * *randlib* was compiled and written  by: Barry W. Brown, James Lovato,
     Kathy Russell, and John Venier.

   * Correspondence   regarding   *Math::Random* or   *randlib* should be
     addressed to John Venier by email to

          venier@odin.mdacc.tmc.edu

   * Our address is:

          Department of Biomathematics, Box 237
          	 The University of Texas, M.D. Anderson Cancer Center
                 1515 Holcombe Boulevard
          	  Houston, TX 77030

   * Geoffrey Rommel may be reached at grommel@sears.com.

LEGALITIES
==========

   * The programs in the  Perl code distributed with *Math::Random* and in
       the C code `helper.c', as    well as  the documentation, are
     copyright by John  Venier and  Barry  W.  Brown for the  University of
     Texas M.  D.  Anderson Cancer Center in 1997.  They may be distributed
     and used under the same conditions as Perl.

   * The code in `wrapper.c' is lightly modified from the output of *SWIG*.
     See `"CODE MANIPULATION"' in this node.

   * `randlib.c',  `com.c',  and `randlib.h'   are from  *randlib* (See
     `"RANDLIB"' in this node) and are distributed with the following
     legalities:

     Code that appeared  in an    ACM  publication  is subject  to    their
     algorithms policy:

     Submittal of  an  algorithm    for publication  in   one of   the  ACM
     Transactions implies that unrestricted use  of the algorithm within  a
     computer is permissible.   General permission  to copy and  distribute
     the algorithm without fee is granted provided that the copies  are not
     made  or   distributed for  direct   commercial  advantage.    The ACM
     copyright notice and the title of the publication and its date appear,
     and  notice is given that copying  is by permission of the Association
     for Computing Machinery.  To copy otherwise, or to republish, requires
     a fee and/or specific permission.

     Krogh, F.  "Algorithms Policy."  ACM  Tran.  Math.  Softw.  13 (1987),
     183-186.

     We place the Randlib code that we have written in the public domain.

   * *Math::Randlib* and *randlib*  are distributed  with NO WARRANTY.
     See `"NO WARRANTY"' in this node.

NO WARRANTY
===========

   WE PROVIDE  ABSOLUTELY  NO WARRANTY  OF ANY  KIND  EITHER  EXPRESS  OR
IMPLIED,  INCLUDING BUT   NOT LIMITED TO,  THE  IMPLIED  WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS  WITH YOU.  SHOULD THIS
PROGRAM PROVE  DEFECTIVE, YOU ASSUME  THE COST  OF  ALL NECESSARY
SERVICING, REPAIR OR CORRECTION.

   IN NO  EVENT  SHALL THE UNIVERSITY  OF TEXAS OR  ANY  OF ITS COMPONENT
INSTITUTIONS INCLUDING M. D.   ANDERSON HOSPITAL BE LIABLE  TO YOU FOR
DAMAGES, INCLUDING ANY  LOST PROFITS, LOST MONIES,   OR OTHER SPECIAL,
INCIDENTAL   OR  CONSEQUENTIAL DAMAGES   ARISING   OUT  OF  THE USE OR
INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA OR ITS
ANALYSIS BEING  RENDERED INACCURATE OR  LOSSES SUSTAINED  BY THIRD PARTIES
FROM) THE PROGRAM.

   (Above NO WARRANTY modified from the GNU NO WARRANTY statement.)


