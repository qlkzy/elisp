This is Info file perl.info, produced by Makeinfo version 1.68 from the
input file bigperl.texi.

   settitle perl


File: perl.info,  Node: perlfaq6,  Next: Top,  Prev: Top,  Up: Top

Regexes ($Revision: 1.27 $, $Date: 1999/05/23 16:08:30 $)
*********************************************************

NAME
====

   perlfaq6 - Regexes ($Revision: 1.27 $, $Date: 1999/05/23 16:08:30 $)

DESCRIPTION
===========

   This section is surprisingly small because the rest of the FAQ is
littered with answers involving regular expressions.  For example,
decoding a URL and checking whether something is a number are handled with
regular expressions, but those answers are found elsewhere in this
document (in the section on Data and the Networking one on networking, to
be precise).

How can I hope to use regular expressions without creating illegible and unmaintainable code?
---------------------------------------------------------------------------------------------

   Three techniques can make regular expressions maintainable and
understandable.

Comments Outside the Regex
     Describe what you're doing and how you're doing it, using normal Perl
     comments.

          # turn the line into the first word, a colon, and the
          # number of characters on the rest of the line
          s/^(\w+)(.*)/ lc($1) . ":" . length($2) /meg;

Comments Inside the Regex
     The `/x' modifier causes whitespace to be ignored in a regex pattern
     (except in a character class), and also allows you to use normal
     comments there, too.  As you can imagine, whitespace and comments help
     a lot.

     `/x' lets you turn this:

          s{<(?:[^>'"]*|".*?"|'.*?')+>}{}gs;

     into this:

          s{ <                    # opening angle bracket
              (?:                 # Non-backreffing grouping paren
                   [^>'"] *       # 0 or more things that are neither > nor ' nor "
                      |           #    or else
                   ".*?"          # a section between double quotes (stingy match)
                      |           #    or else
                   '.*?'          # a section between single quotes (stingy match)
              ) +                 #   all occurring one or more times
             >                    # closing angle bracket
          }{}gsx;                 # replace with nothing, i.e. delete

     It's still not quite so clear as prose, but it is very useful for
     describing the meaning of each part of the pattern.

Different Delimiters
     While we normally think of patterns as being delimited with /
     characters, they can be delimited by almost any character.  *Note
     Perlre: perlre, describes this.  For example, the s/// above uses
     braces as delimiters.  Selecting another delimiter can avoid quoting
     the delimiter within the pattern:

          s/\/usr\/local/\/usr\/share/g;	# bad delimiter choice
          s#/usr/local#/usr/share#g;		# better

I'm having trouble matching over more than one line.  What's wrong?
-------------------------------------------------------------------

   Either you don't have more than one line in the string you're looking at
(probably), or else you aren't using the correct modifier(s) on your
pattern (possibly).

   There are many ways to get multiline data into a string.  If you want
it to happen automatically while reading input, you'll want to set $/
(probably to " for paragraphs or undef for the whole file) to allow you to
read more than one line at a time.

   Read *Note Perlre: perlre, to help you decide which of `/s' and `/m'
(or both) you might want to use: `/s' allows dot to include newline, and
`/m' allows caret and dollar to match next to a newline, not just at the
end of the string.  You do need to make sure that you've actually got a
multiline string in there.

   For example, this program detects duplicate words, even when they span
line breaks (but not paragraph ones).  For this example, we don't need
`/s' because we aren't using dot in a regular expression that we want to
cross line boundaries.  Neither do we need `/m' because we aren't wanting
caret or dollar to match at any point inside the record next to newlines.
But it's imperative that $/ be set to something other than the default, or
else we won't actually ever have a multiline record read in.

     $/ = '';  		# read in more whole paragraph, not just one line
     while ( <> ) {
     	while ( /\b([\w'-]+)(\s+\1)+\b/gi ) {  	# word starts alpha
     	    print "Duplicate $1 at paragraph $.\n";
     	}
     }

   Here's code that finds sentences that begin with "From " (which would
be mangled by many mailers):

     $/ = '';  		# read in more whole paragraph, not just one line
     while ( <> ) {
     	while ( /^From /gm ) { # /m makes ^ match next to \n
     	    print "leading from in paragraph $.\n";
     	}
     }

   Here's code that finds everything between START and END in a paragraph:

     undef $/;  		# read in whole file, not just one line or paragraph
     while ( <> ) {
     	while ( /START(.*?)END/sm ) { # /s makes . cross line boundaries
     	    print "$1\n";
     	}
     }

How can I pull out lines between two patterns that are themselves on different lines?
-------------------------------------------------------------------------------------

   You can use Perl's somewhat exotic `..' operator (documented in *Note
Perlop: perlop,):

     perl -ne 'print if /START/ .. /END/' file1 file2 ...

   If you wanted text and not lines, you would use

     perl -0777 -ne 'print "$1\n" while /START(.*?)END/gs' file1 file2 ...

   But if you want nested occurrences of START through END, you'll run up
against the problem described in the question in this section on matching
balanced text.

   Here's another example of using `..':

     while (<>) {
         $in_header =   1  .. /^$/;
         $in_body   = /^$/ .. eof();
     	# now choose between them
     } continue {
     	reset if eof();		# fix $.
     }

I put a regular expression into $/ but it didn't work. What's wrong?
--------------------------------------------------------------------

   $/ must be a string, not a regular expression.  Awk has to be better
for something. :-)

   Actually, you could do this if you don't mind reading the whole file
into memory:

     undef $/;
     @records = split /your_pattern/, <FH>;

   The Net::Telnet module (available from CPAN) has the capability to wait
for a pattern in the input stream, or timeout if it doesn't appear within
a certain time.

     ## Create a file with three lines.
     open FH, ">file";
     print FH "The first line\nThe second line\nThe third line\n";
     close FH;

     ## Get a read/write filehandle to it.
     $fh = new FileHandle "+<file";

     ## Attach it to a "stream" object.
     use Net::Telnet;
     $file = new Net::Telnet (-fhopen => $fh);

     ## Search for the second line and print out the third.
     $file->waitfor('/second line\n/');
     print $file->getline;

How do I substitute case insensitively on the LHS, but preserving case on the RHS?
----------------------------------------------------------------------------------

   Here's a lovely Perlish solution by Larry Rosler.  It exploits
properties of bitwise xor on ASCII strings.

     $_= "this is a TEsT case";

     $old = 'test';
     $new = 'success';

     s{(\Q$old\E}
      { uc $new | (uc $1 ^ $1) .
     	(uc(substr $1, -1) ^ substr $1, -1) x
     	    (length($new) - length $1)
      }egi;

     print;

   And here it is as a subroutine, modelled after the above:

     sub preserve_case($$) {
     	my ($old, $new) = @_;
     	my $mask = uc $old ^ $old;

     uc $new | $mask .
         substr($mask, -1) x (length($new) - length($old))
         }

     $a = "this is a TEsT case";
     $a =~ s/(test)/preserve_case($1, "success")/egi;
     print "$a\n";

   This prints:

     this is a SUcCESS case

   Just to show that C programmers can write C in any programming language,
if you prefer a more C-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.  (It
also happens to run about 240% slower than the Perlish solution runs.)  If
the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.

     # Original by Nathan Torkington, massaged by Jeffrey Friedl
     #
     sub preserve_case($$)
     {
         my ($old, $new) = @_;
         my ($state) = 0; # 0 = no change; 1 = lc; 2 = uc
         my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
         my ($len) = $oldlen < $newlen ? $oldlen : $newlen;

     for ($i = 0; $i < $len; $i++) {
         if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) {
             $state = 0;
         } elsif (lc $c eq $c) {
             substr($new, $i, 1) = lc(substr($new, $i, 1));
             $state = 1;
         } else {
             substr($new, $i, 1) = uc(substr($new, $i, 1));
             $state = 2;
         }
     }
     # finish up with any remaining new (for when new is longer than old)
     if ($newlen > $oldlen) {
         if ($state == 1) {
             substr($new, $oldlen) = lc(substr($new, $oldlen));
         } elsif ($state == 2) {
             substr($new, $oldlen) = uc(substr($new, $oldlen));
         }
     }
     return $new;
         }

How can I make `\w' match national character sets?
--------------------------------------------------

   See *Note Perllocale: perllocale,.

How can I match a locale-smart version of `/[a-zA-Z]/'?
-------------------------------------------------------

   One alphabetic character would be `/[^\W\d_]/', no matter what locale
you're in.  Non-alphabetics would be `/[\W\d_]/' (assuming you don't
consider an underscore a letter).

How can I quote a variable to use in a regex?
---------------------------------------------

   The Perl parser will expand $variable and @variable references in
regular expressions unless the delimiter is a single quote.  Remember,
too, that the right-hand side of a s/// substitution is considered a
double-quoted string (see *Note Perlop: perlop, for more details).
Remember also that any regex special characters will be acted on unless you
precede the substitution with \Q.  Here's an example:

     $string = "to die?";
     $lhs = "die?";
     $rhs = "sleep, no more";

     $string =~ s/\Q$lhs/$rhs/;
     # $string is now "to sleep no more"

   Without the \Q, the regex would also spuriously match "di".

What is `/o' really for?
------------------------

   Using a variable in a regular expression match forces a re-evaluation
(and perhaps recompilation) each time through.  The `/o' modifier locks in
the regex the first time it's used.  This always happens in a constant
regular expression, and in fact, the pattern was compiled into the
internal format at the same time your entire program was.

   Use of `/o' is irrelevant unless variable interpolation is used in the
pattern, and if so, the regex engine will neither know nor care whether
the variables change after the pattern is evaluated the *very first* time.

   `/o' is often used to gain an extra measure of efficiency by not
performing subsequent evaluations when you know it won't matter (because
you know the variables won't change), or more rarely, when you don't want
the regex to notice if they do.

   For example, here's a "paragrep" program:

     $/ = '';  # paragraph mode
     $pat = shift;
     while (<>) {
         print if /$pat/o;
     }

How do I use a regular expression to strip C style comments from a file?
------------------------------------------------------------------------

   While this actually can be done, it's much harder than you'd think.
For example, this one-liner

     perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

   will work in many but not all cases.  You see, it's too simple-minded
for certain kinds of C programs, in particular, those with what appear to
be comments in quoted strings.  For that, you'd need something like this,
created by Jeffrey Friedl and later modified by Fred Curtis.

     $/ = undef;
     $_ = <>;
     s#/\*[^*]*\*+([^/*][^*]*\*+)*/|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs
     print;

   This could, of course, be more legibly written with the `/x' modifier,
adding whitespace and comments.  Here it is expanded, courtesy of Fred
Curtis.

     s{
        /\*         ##  Start of /* ... */ comment
        [^*]*\*+    ##  Non-* followed by 1-or-more *'s
        (
          [^/*][^*]*\*+
        )*          ##  0-or-more things which don't start with /
                    ##    but do end with '*'
        /           ##  End of /* ... */ comment

     |         ##     OR  various things which aren't comments:

     (
       "           ##  Start of " ... " string
       (
         \\.           ##  Escaped char
       |               ##    OR
         [^"\\]        ##  Non "\
       )*
       "           ##  End of " ... " string

     |         ##     OR

     '           ##  Start of ' ... ' string
     (
       \\.           ##  Escaped char
     |               ##    OR
       [^'\\]        ##  Non '\
     )*
     '           ##  End of ' ... ' string

     |         ##     OR

     .           ##  Anything other char
     [^/"'\\]*   ##  Chars which doesn't start a comment, string or escape
            )
          }{$2}gxs;

   A slight modification also removes C++ comments:

     s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//[^\n]*|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^/"'\\]*)#$2#gs;

Can I use Perl regular expressions to match balanced text?
----------------------------------------------------------

   Although Perl regular expressions are more powerful than "mathematical"
regular expressions, because they feature conveniences like backreferences
(\1 and its ilk), they still aren't powerful enough - with the possible
exception of bizarre and experimental features in the development-track
releases of Perl.  You still need to use non-regex techniques to parse
balanced text, such as the text enclosed between matching parentheses or
braces, for example.

   An elaborate subroutine (for 7-bit ASCII only) to pull out balanced and
possibly nested single chars, like ``' and `'', `{' and `}', or ( and )
can be found in
http://www.perl.com/CPAN/authors/id/TOMC/scripts/pull_quotes.gz .

   The C::Scan module from CPAN contains such subs for internal usage, but
they are undocumented.

What does it mean that regexes are greedy?  How can I get around it?
--------------------------------------------------------------------

   Most people mean that greedy regexes match as much as they can.
Technically speaking, it's actually the quantifiers (?, *, +, `{}') that
are greedy rather than the whole pattern; Perl prefers local greed and
immediate gratification to overall greed.  To get non-greedy versions of
the same quantifiers, use (`??', `*?', `+?', `{}?').

   An example:

     $s1 = $s2 = "I am very very cold";
     $s1 =~ s/ve.*y //;      # I am cold
     $s2 =~ s/ve.*?y //;     # I am very cold

   Notice how the second substitution stopped matching as soon as it
encountered "y ".  The `*?' quantifier effectively tells the regular
expression engine to find a match as quickly as possible and pass control
on to whatever is next in line, like you would if you were playing hot
potato.

How do I process each word on each line?
----------------------------------------

   Use the split function:

     while (<>) {
     	foreach $word ( split ) {
     	    # do something with $word here
     	}
     }

   Note that this isn't really a word in the English sense; it's just
chunks of consecutive non-whitespace characters.

   To work with only alphanumeric sequences, you might consider

     while (<>) {
     	foreach $word (m/(\w+)/g) {
     	    # do something with $word here
     	}
     }

How can I print out a word-frequency or line-frequency summary?
---------------------------------------------------------------

   To do this, you have to parse out each word in the input stream.  We'll
pretend that by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than the non-whitespace chunk idea of a word given in
the previous question:

     while (<>) {
     	while ( /(\b[^\W_\d][\w'-]+\b)/g ) {   # misses "`sheep'"
     	    $seen{$1}++;
     	}
     }
     while ( ($word, $count) = each %seen ) {
     	print "$count $word\n";
     }

   If you wanted to do the same thing for lines, you wouldn't need a
regular expression:

     while (<>) {
     	$seen{$_}++;
     }
     while ( ($line, $count) = each %seen ) {
     	print "$count $line";
     }

   If you want these output in a sorted order, see the section on Hashes.

How can I do approximate matching?
----------------------------------

   See the module String::Approx available from CPAN.

How do I efficiently match many regular expressions at once?
------------------------------------------------------------

   The following is extremely inefficient:

     # slow but obvious way
     @popstates = qw(CO ON MI WI MN);
     while (defined($line = <>)) {
     	for $state (@popstates) {
     	    if ($line =~ /\b$state\b/i) {
     		print $line;
     		last;
     	    }
     	}
     }

   That's because Perl has to recompile all those patterns for each of the
lines of the file.  As of the 5.005 release, there's a much better
approach, one which makes use of the new `qr//' operator:

     # use spiffy new qr// operator, with /i flag even
     use 5.005;
     @popstates = qw(CO ON MI WI MN);
     @poppats   = map { qr/\b$_\b/i } @popstates;
     while (defined($line = <>)) {
     	for $patobj (@poppats) {
     	    print $line if $line =~ /$patobj/;
     	}
     }

Why don't word-boundary searches with `\b' work for me?
-------------------------------------------------------

   Two common misconceptions are that `\b' is a synonym for `\s+', and
that it's the edge between whitespace characters and non-whitespace
characters.  Neither is correct.  `\b' is the place between a `\w'
character and a `\W' character (that is, `\b' is the edge of a "word").
It's a zero-width assertion, just like ^, `$', and all the other anchors,
so it doesn't consume any characters.  *Note Perlre: perlre, describes the
behavior of all the regex metacharacters.

   Here are examples of the incorrect application of `\b', with fixes:

     "two words" =~ /(\w+)\b(\w+)/;	    # WRONG
     "two words" =~ /(\w+)\s+(\w+)/;	    # right

     " =matchless= text" =~ /\b=(\w+)=\b/;   # WRONG
     " =matchless= text" =~ /=(\w+)=/;       # right

   Although they may not do what you thought they did, `\b' and `\B' can
still be quite useful.  For an example of the correct use of `\b', see the
example of matching duplicate words over multiple lines.

   An example of using `\B' is the pattern `\Bis\B'.  This will find
occurrences of "is" on the insides of words only, as in "thistle", but not
"this" or "island".

Why does using $&, $`, or $' slow my program down?
--------------------------------------------------

   Because once Perl sees that you need one of these variables anywhere in
the program, it has to provide them on each and every pattern match.  The
same mechanism that handles these provides for the use of $1, $2, etc., so
you pay the same price for each regex that contains capturing parentheses.
But if you never use $&, etc., in your script, then regexes *without*
capturing parentheses won't be penalized. So avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price.  Remember that some algorithms
really appreciate them.  As of the 5.005 release.  the $& variable is no
longer "expensive" the way the other two are.

What good is `\G' in a regular expression?
------------------------------------------

   The notation `\G' is used in a match or substitution in conjunction the
`/g' modifier (and ignored if there's no `/g') to anchor the regular
expression to the point just past where the last match occurred, i.e. the
pos() point.  A failed match resets the position of `\G' unless the `/c'
modifier is in effect.

   For example, suppose you had a line of text quoted in standard mail and
Usenet notation, (that is, with leading `< ' >> characters), and you want
change each leading `< ' >> into a corresponding :.  You could do so in
this way:

     s/^(>+)/':' x length($1)/gem;

   Or, using `\G', the much simpler (and faster):

     s/\G>/:/g;

   A more sophisticated use might involve a tokenizer.  The following
lex-like example is courtesy of Jeffrey Friedl.  It did not work in 5.003
due to bugs in that release, but does work in 5.004 or better.  (Note the
use of `/c', which prevents a failed match with `/g' from resetting the
search position back to the beginning of the string.)

     while (<>) {
       chomp;
       PARSER: {
            m/ \G( \d+\b    )/gcx    && do { print "number: $1\n";  redo; };
            m/ \G( \w+      )/gcx    && do { print "word:   $1\n";  redo; };
            m/ \G( \s+      )/gcx    && do { print "space:  $1\n";  redo; };
            m/ \G( [^\w\d]+ )/gcx    && do { print "other:  $1\n";  redo; };
       }
     }

   Of course, that could have been written as

     while (<>) {
       chomp;
       PARSER: {
     	   if ( /\G( \d+\b    )/gcx  {
     		print "number: $1\n";
     		redo PARSER;
     	   }
     	   if ( /\G( \w+      )/gcx  {
     		print "word: $1\n";
     		redo PARSER;
     	   }
     	   if ( /\G( \s+      )/gcx  {
     		print "space: $1\n";
     		redo PARSER;
     	   }
     	   if ( /\G( [^\w\d]+ )/gcx  {
     		print "other: $1\n";
     		redo PARSER;
     	   }
       }
     }

   But then you lose the vertical alignment of the regular expressions.

Are Perl regexes DFAs or NFAs?  Are they POSIX compliant?
---------------------------------------------------------

   While it's true that Perl's regular expressions resemble the DFAs
(deterministic finite automata) of the egrep(1) program, they are in fact
implemented as NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing.  And they aren't POSIX-style either,
because those guarantee worst-case behavior for all cases.  (It seems that
some people prefer guarantees of consistency, even when what's guaranteed
is slowness.)  See the book "Mastering Regular Expressions" (from
O'Reilly) by Jeffrey Friedl for all the details you could ever hope to
know on these matters (a full citation appears in *Note Perlfaq2:
perlfaq2,).

What's wrong with using grep or map in a void context?
------------------------------------------------------

   Both grep and map build a return list, regardless of their context.
This means you're making Perl go to the trouble of building up a return
list that you then just ignore.  That's no way to treat a programming
language, you insensitive scoundrel!

How can I match strings with multibyte characters?
--------------------------------------------------

   This is hard, and there's no good way.  Perl does not directly support
wide characters.  It pretends that a byte and a character are synonymous.
The following set of approaches was offered by Jeffrey Friedl, whose
article in issue #5 of The Perl Journal talks about this very matter.

   Let's suppose you have some weird Martian encoding where pairs of ASCII
uppercase letters encode single Martian letters (i.e. the two bytes "CV"
make a single Martian letter, as do the two bytes "SG", "VS", "XX", etc.).
Other bytes represent single characters, just like ASCII.

   So, the string of Martian "I am CVSGXX!" uses 12 bytes to encode the
nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.

   Now, say you want to search for the single character `/GX/'. Perl
doesn't know about Martian, so it'll find the two bytes "GX" in the "I am
CVSGXX!"  string, even though that character isn't there: it just looks
like it is because "SG" is next to "XX", but there's no real "GX".  This
is a big problem.

   Here are a few ways, all painful, to deal with it:

     $martian =~ s/([A-Z][A-Z])/ $1 /g; # Make sure adjacent ``martian'' bytes
                                        # are no longer adjacent.
     print "found GX!\n" if $martian =~ /GX/;

   Or like this:

     @chars = $martian =~ m/([A-Z][A-Z]|[^A-Z])/g;
     # above is conceptually similar to:     @chars = $text =~ m/(.)/g;
     #
     foreach $char (@chars) {
         print "found GX!\n", last if $char eq 'GX';
     }

   Or like this:

     while ($martian =~ m/\G([A-Z][A-Z]|.)/gs) {  # \G probably unneeded
         print "found GX!\n", last if $1 eq 'GX';
     }

   Or like this:

     die "sorry, Perl doesn't (yet) have Martian support )-:\n";

   There are many double- (and multi-) byte encodings commonly used these
days.  Some versions of these have 1-, 2-, 3-, and 4-byte characters, all
mixed.

How do I match a pattern that is supplied by the user?
------------------------------------------------------

   Well, if it's really a pattern, then just use

     chomp($pattern = <STDIN>);
     if ($line =~ /$pattern/) { }

   Or, since you have no guarantee that your user entered a valid regular
expression, trap the exception this way:

     if (eval { $line =~ /$pattern/ }) { }

   But if all you really want to search for a string, not a pattern, then
you should either use the index() function, which is made for string
searching, or if you can't be disabused of using a pattern match on a
non-pattern, then be sure to use `\Q'...`\E', documented in *Note Perlre:
perlre,.

     $pattern = <STDIN>;

     open (FILE, $input) or die "Couldn't open input $input: $!; aborting";
     while (<FILE>) {
     	print if /\Q$pattern\E/;
     }
     close FILE;

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.


File: perl.info,  Node: perlfaq7,  Next: Top,  Prev: Top,  Up: Top

Perl Language Issues ($Revision: 1.28 $, $Date: 1999/05/23 20:36:18 $)
**********************************************************************

NAME
====

   perlfaq7 - Perl Language Issues ($Revision: 1.28 $, $Date: 1999/05/23
20:36:18 $)

DESCRIPTION
===========

   This section deals with general Perl language issues that don't clearly
fit into any of the other sections.

Can I get a BNF/yacc/RE for the Perl language?
----------------------------------------------

   There is no BNF, but you can paw your way through the yacc grammar in
perly.y in the source distribution if you're particularly brave.  The
grammar relies on very smart tokenizing code, so be prepared to venture
into toke.c as well.

   In the words of Chaim Frenkel: "Perl's grammar can not be reduced to
BNF.  The work of parsing perl is distributed between yacc, the lexer,
smoke and mirrors."

What are all these $@%&* punctuation signs, and how do I know when to use them?
-------------------------------------------------------------------------------

   They are type specifiers, as detailed in *Note Perldata: perldata,:

     $ for scalar values (number, string or reference)
     @ for arrays
     % for hashes (associative arrays)
     & for subroutines (aka functions, procedures, methods)
     * for all types of that symbol name.  In version 4 you used them like
       pointers, but in modern perls you can just use references.

   A couple of others that you're likely to encounter that aren't really
type specifiers are:

     <> are used for inputting a record from a filehandle.
     \  takes a reference to something.

   Note that <FILE> is *neither* the type specifier for files nor the name
of the handle.  It is the `< <' >> operator applied to the handle FILE.
It reads one line (well, record - see `$', *Note Perlvar: perlvar,) from
the handle FILE in scalar context, or all lines in list context.  When
performing open, close, or any other operation besides `< <' >> on files,
or even talking about the handle, do not use the brackets.  These are
correct: `eof(FH)', `seek(FH, 0, 2)' and "copying from STDIN to FILE".

Do I always/never have to quote my strings or use semicolons and commas?
------------------------------------------------------------------------

   Normally, a bareword doesn't need to be quoted, but in most cases
probably should be (and must be under `use strict').  But a hash key
consisting of a simple word (that isn't the name of a defined subroutine)
and the left-hand operand to the `< =' >> operator both count as though
they were quoted:

     This                    is like this
     ------------            ---------------
     $foo{line}              $foo{"line"}
     bar => stuff            "bar" => stuff

   The final semicolon in a block is optional, as is the final comma in a
list.  Good style (see *Note Perlstyle: perlstyle,) says to put them in
except for one-liners:

     if ($whoops) { exit 1 }
     @nums = (1, 2, 3);

     if ($whoops) {
         exit 1;
     }
     @lines = (
     	"There Beren came from mountains cold",
     	"And lost he wandered under leaves",
     );

How do I skip some return values?
---------------------------------

   One way is to treat the return values as a list and index into it:

     $dir = (getpwnam($user))[7];

   Another way is to use undef as an element on the left-hand-side:

     ($dev, $ino, undef, undef, $uid, $gid) = stat($file);

How do I temporarily block warnings?
------------------------------------

   If you are running Perl 5.6.0 or better, the `use warnings' pragma
allows fine control of what warning are produced.  See *Note Perllexwarn:
perllexwarn, for more details.

     {
     	no warnings;          # temporarily turn off warnings
     	$a = $b + $c;         # I know these might be undef
     }

   If you have an older version of Perl, the $^W variable (documented in
*Note Perlvar: perlvar,) controls runtime warnings for a block:

     {
     	local $^W = 0;        # temporarily turn off warnings
     	$a = $b + $c;         # I know these might be undef
     }

   Note that like all the punctuation variables, you cannot currently use
my() on $^W, only local().

What's an extension?
--------------------

   A way of calling compiled C code from Perl.  Reading *Note Perlxstut:
perlxstut, is a good place to learn more about extensions.

Why do Perl operators have different precedence than C operators?
-----------------------------------------------------------------

   Actually, they don't.  All C operators that Perl copies have the same
precedence in Perl as they do in C.  The problem is with operators that C
doesn't have, especially functions that give a list context to everything
on their right, eg print, chmod, exec, and so on.  Such functions are
called "list operators" and appear as such in the precedence table in
*Note Perlop: perlop,.

   A common mistake is to write:

     unlink $file || die "snafu";

   This gets interpreted as:

     unlink ($file || die "snafu");

   To avoid this problem, either put in extra parentheses or use the super
low precedence or operator:

     (unlink $file) || die "snafu";
     unlink $file or die "snafu";

   The "English" operators (and, or, xor, and not) deliberately have
precedence lower than that of list operators for just such situations as
the one above.

   Another operator with surprising precedence is exponentiation.  It
binds more tightly even than unary minus, making `-2**2' product a
negative not a positive four.  It is also right-associating, meaning that
`2**3**2' is two raised to the ninth power, not eight squared.

   Although it has the same precedence as in C, Perl's `?:' operator
produces an lvalue.  This assigns $x to either $a or $b, depending on the
trueness of $maybe:

     ($maybe ? $a : $b) = $x;

How do I declare/create a structure?
------------------------------------

   In general, you don't "declare" a structure.  Just use a (probably
anonymous) hash reference.  See *Note Perlref: perlref, and *Note Perldsc:
perldsc, for details.  Here's an example:

     $person = {};                   # new anonymous hash
     $person->{AGE}  = 24;           # set field AGE to 24
     $person->{NAME} = "Nat";        # set field NAME to "Nat"

   If you're looking for something a bit more rigorous, try *Note
Perltoot: perltoot,.

How do I create a module?
-------------------------

   A module is a package that lives in a file of the same name.  For
example, the Hello::There module would live in Hello/There.pm.  For
details, read *Note Perlmod: perlmod,.  You'll also find *Note Exporter:
(pm.info)Exporter, helpful.  If you're writing a C or mixed-language
module with both C and Perl, then you should study *Note Perlxstut:
perlxstut,.

   Here's a convenient template you might wish you use when starting your
own module.  Make sure to change the names appropriately.

     package Some::Module;  # assumes Some/Module.pm

     use strict;
     use warnings;

     BEGIN {
     	use Exporter   ();
     	our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);

     ## set the version for version checking; uncomment to use
     ## $VERSION     = 1.00;

     # if using RCS/CVS, this next line may be preferred,
     # but beware two-digit versions.
     $VERSION = do{my@r=q$Revision: 1.28 $=~/\d+/g;sprintf '%d.'.'%02d'x$#r,@r};

     @ISA         = qw(Exporter);
     @EXPORT      = qw(&func1 &func2 &func3);
     %EXPORT_TAGS = ( );  	# eg: TAG => [ qw!name1 name2! ],

     # your exported package globals go here,
     # as well as any optionally exported functions
     @EXPORT_OK   = qw($Var1 %Hashit);
         }
         our @EXPORT_OK;

     # non-exported package globals go here
     our @more;
     our $stuff;

     # initialize package globals, first exported ones
     $Var1   = '';
     %Hashit = ();

     # then the others (which are still accessible as $Some::Module::stuff)
     $stuff  = '';
     @more   = ();

     # all file-scoped lexicals must be created before
     # the functions below that use them.

     # file-private lexicals go here
     my $priv_var    = '';
     my %secret_hash = ();

     # here's a file-private function as a closure,
     # callable as &$priv_func;  it cannot be prototyped.
     my $priv_func = sub {
         # stuff goes here.
     };

     # make all your functions, whether exported or not;
     # remember to put something interesting in the {} stubs
     sub func1      {}	 # no prototype
     sub func2()    {}	 # proto'd void
     sub func3($$)  {}	 # proto'd to 2 scalars

     # this one isn't exported, but could be called!
     sub func4(\%)  {}    # proto'd to 1 hash ref

     END { }       # module clean-up code here (global destructor)

     1;            # modules must return true

   The h2xs program will create stubs for all the important stuff for you:

     % h2xs -XA -n My::Module

How do I create a class?
------------------------

   See *Note Perltoot: perltoot, for an introduction to classes and
objects, as well as *Note Perlobj: perlobj, and *Note Perlbot: perlbot,.

How can I tell if a variable is tainted?
----------------------------------------

   See `"Laundering and Detecting Tainted Data"', *Note Perlsec: perlsec,.
Here's an example (which doesn't use any system calls, because the kill()
is given no processes to signal):

     sub is_tainted {
     	return ! eval { join('',@_), kill 0; 1; };
     }

   This is not -w clean, however.  There is no -w clean way to detect
taintedness - take this as a hint that you should untaint all
possibly-tainted data.

What's a closure?
-----------------

   Closures are documented in *Note Perlref: perlref,.

   *Closure* is a computer science term with a precise but hard-to-explain
meaning. Closures are implemented in Perl as anonymous subroutines with
lasting references to lexical variables outside their own scopes.  These
lexicals magically refer to the variables that were around when the
subroutine was defined (deep binding).

   Closures make sense in any programming language where you can have the
return value of a function be itself a function, as you can in Perl.  Note
that some languages provide anonymous functions but are not capable of
providing proper closures; the Python language, for example.  For more
information on closures, check out any textbook on functional programming.
Scheme is a language that not only supports but encourages closures.

   Here's a classic function-generating function:

     sub add_function_generator {
       return sub { shift + shift };
     }

     $add_sub = add_function_generator();
     $sum = $add_sub->(4,5);                # $sum is 9 now.

   The closure works as a *function template* with some customization
slots left out to be filled later.  The anonymous subroutine returned by
add_function_generator() isn't technically a closure because it refers to
no lexicals outside its own scope.

   Contrast this with the following make_adder() function, in which the
returned anonymous function contains a reference to a lexical variable
outside the scope of that function itself.  Such a reference requires that
Perl return a proper closure, thus locking in for all time the value that
the lexical had when the function was created.

     sub make_adder {
         my $addpiece = shift;
         return sub { shift + $addpiece };
     }

     $f1 = make_adder(20);
     $f2 = make_adder(555);

   Now `&$f1($n)' is always 20 plus whatever $n you pass in, whereas
`&$f2($n)' is always 555 plus whatever $n you pass in.  The $addpiece in
the closure sticks around.

   Closures are often used for less esoteric purposes.  For example, when
you want to pass in a bit of code into a function:

     my $line;
     timeout( 30, sub { $line = <STDIN> } );

   If the code to execute had been passed in as a string, `< '$line =
<STDIN'' >>, there would have been no way for the hypothetical timeout()
function to access the lexical variable $line back in its caller's scope.

What is variable suicide and how can I prevent it?
--------------------------------------------------

   Variable suicide is when you (temporarily or permanently) lose the
value of a variable.  It is caused by scoping through my() and local()
interacting with either closures or aliased foreach() iterator variables
and subroutine arguments.  It used to be easy to inadvertently lose a
variable's value this way, but now it's much harder.  Take this code:

     my $f = "foo";
     sub T {
       while ($i++ < 3) { my $f = $f; $f .= "bar"; print $f, "\n" }
     }
     T;
     print "Finally $f\n";

   The $f that has "bar" added to it three times should be a new $f (`my
$f' should create a new local variable each time through the loop).  It
isn't, however.  This was a bug, now fixed in the latest releases (tested
against 5.004_05, 5.005_03, and 5.005_56).

How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?
---------------------------------------------------------------------------

   With the exception of regexes, you need to pass references to these
objects.  See `"Pass by Reference"', *Note Perlsub: perlsub, for this
particular question, and `"Pass by Reference"', *Note Perlref: perlref,
for information on references.

Passing Variables and Functions
     Regular variables and functions are quite easy: just pass in a
     reference to an existing or anonymous variable or function:

          func( \$some_scalar );

          func( \@some_array  );
          func( [ 1 .. 10 ]   );

          func( \%some_hash   );
          func( { this => 10, that => 20 }   );

          func( \&some_func   );
          func( sub { $_[0] ** $_[1] }   );

Passing Filehandles
     To pass filehandles to subroutines, use the `*FH' or `\*FH' notations.
     These are "typeglobs" - see `"Typeglobs and Filehandles"', *Note
     Perldata: perldata, and especially `"Pass by Reference"', *Note
     Perlsub: perlsub, for more information.

     Here's an excerpt:

     If you're passing around filehandles, you could usually just use the
     bare typeglob, like *STDOUT, but typeglobs references would be better
     because they'll still work properly under `use strict 'refs''.  For
     example:

          splutter(\*STDOUT);
          sub splutter {
              my $fh = shift;
              print $fh "her um well a hmmm\n";
          }

          $rec = get_rec(\*STDIN);
          sub get_rec {
              my $fh = shift;
              return scalar <$fh>;
          }

     If you're planning on generating new filehandles, you could do this:

          sub openit {
              my $name = shift;
              local *FH;
              return open (FH, $path) ? *FH : undef;
          }
          $fh = openit('< /etc/motd');
          print <$fh>;

Passing Regexes
     To pass regexes around, you'll need to be using a release of Perl
     sufficiently recent as to support the `qr//' construct, pass around
     strings and use an exception-trapping eval, or else be very, very
     clever.

     Here's an example of how to pass in a string to be regex compared
     using `qr//':

          sub compare($$) {
              my ($val1, $regex) = @_;
              my $retval = $val1 =~ /$regex/;
          	return $retval;
          }
          $match = compare("old McDonald", qr/d.*D/i);

     Notice how `qr//' allows flags at the end.  That pattern was compiled
     at compile time, although it was executed later.  The nifty `qr//'
     notation wasn't introduced until the 5.005 release.  Before that, you
     had to approach this problem much less intuitively.  For example, here
     it is again if you don't have `qr//':

          sub compare($$) {
              my ($val1, $regex) = @_;
              my $retval = eval { $val1 =~ /$regex/ };
          	die if $@;
          	return $retval;
          }

          $match = compare("old McDonald", q/($?i)d.*D/);

     Make sure you never say something like this:

          return eval "\$val =~ /$regex/";   # WRONG

     or someone can sneak shell escapes into the regex due to the double
     interpolation of the eval and the double-quoted string.  For example:

          $pattern_of_evil = 'danger ${ system("rm -rf * &") } danger';

          eval "\$string =~ /$pattern_of_evil/";

     Those preferring to be very, very clever might see the O'Reilly book,
     *Mastering Regular Expressions*, by Jeffrey Friedl.  Page 273's
     Build_MatchMany_Function() is particularly interesting.  A complete
     citation of this book is given in *Note Perlfaq2: perlfaq2,.

Passing Methods
     To pass an object method into a subroutine, you can do this:

          call_a_lot(10, $some_obj, "methname")
          sub call_a_lot {
              my ($count, $widget, $trick) = @_;
              for (my $i = 0; $i < $count; $i++) {
                  $widget->$trick();
              }
          }

     Or you can use a closure to bundle up the object and its method call
     and arguments:

          my $whatnot =  sub { $some_obj->obfuscate(@args) };
          func($whatnot);
          sub func {
              my $code = shift;
              &$code();
          }

     You could also investigate the can() method in the UNIVERSAL class
     (part of the standard perl distribution).

How do I create a static variable?
----------------------------------

   As with most things in Perl, TMTOWTDI.  What is a "static variable" in
other languages could be either a function-private variable (visible only
within a single function, retaining its value between calls to that
function), or a file-private variable (visible only to functions within
the file it was declared in) in Perl.

   Here's code to implement a function-private variable:

     BEGIN {
         my $counter = 42;
         sub prev_counter { return --$counter }
         sub next_counter { return $counter++ }
     }

   Now prev_counter() and next_counter() share a private variable $counter
that was initialized at compile time.

   To declare a file-private variable, you'll still use a my(), putting it
at the outer scope level at the top of the file.  Assume this is in file
Pax.pm:

     package Pax;
     my $started = scalar(localtime(time()));

     sub begun { return $started }

   When `use Pax' or `require Pax' loads this module, the variable will be
initialized.  It won't get garbage-collected the way most variables going
out of scope do, because the begun() function cares about it, but no one
else can get it.  It is not called $Pax::started because its scope is
unrelated to the package.  It's scoped to the file.  You could conceivably
have several packages in that same file all accessing the same private
variable, but another file with the same package couldn't get to it.

   See `"Persistent Private Variables"', *Note Perlsub: perlsub, for
details.

What's the difference between dynamic and lexical (static) scoping?  Between local() and my()?
----------------------------------------------------------------------------------------------

   `local($x)' saves away the old value of the global variable $x, and
assigns a new value for the duration of the subroutine, *which is visible
in other functions called from that subroutine*.  This is done at
run-time, so is called dynamic scoping.  local() always affects global
variables, also called package variables or dynamic variables.

   `my($x)' creates a new variable that is only visible in the current
subroutine.  This is done at compile-time, so is called lexical or static
scoping.  my() always affects private variables, also called lexical
variables or (improperly) static(ly scoped) variables.

   For instance:

     sub visible {
     	print "var has value $var\n";
     }

     sub dynamic {
     	local $var = 'local';	# new temporary value for the still-global
     	visible();              #   variable called $var
     }

     sub lexical {
     	my $var = 'private';    # new private variable, $var
     	visible();              # (invisible outside of sub scope)
     }

     $var = 'global';

     visible();      		# prints global
     dynamic();      		# prints local
     lexical();      		# prints global

   Notice how at no point does the value "private" get printed.  That's
because $var only has that value within the block of the lexical()
function, and it is hidden from called subroutine.

   In summary, local() doesn't make what you think of as private, local
variables.  It gives a global variable a temporary value.  my() is what
you're looking for if you want private variables.

   See `"Private Variables via my()"', *Note Perlsub: perlsub, and
`"Temporary Values via local()"', *Note Perlsub: perlsub, for excruciating
details.

How can I access a dynamic variable while a similarly named lexical is in scope?
--------------------------------------------------------------------------------

   You can do this via symbolic references, provided you haven't set `use
strict "refs"'.  So instead of $var, use `${'var'}'.

     local $var = "global";
     my    $var = "lexical";

     print "lexical is $var\n";

     no strict 'refs';
     print "global  is ${'var'}\n";

   If you know your package, you can just mention it explicitly, as in
$Some_Pack::var.  Note that the notation $::var is not the dynamic $var in
the current package, but rather the one in the main package, as though you
had written $main::var.  Specifying the package directly makes you
hard-code its name, but it executes faster and avoids running afoul of
`use strict "refs"'.

What's the difference between deep and shallow binding?
-------------------------------------------------------

   In deep binding, lexical variables mentioned in anonymous subroutines
are the same ones that were in scope when the subroutine was created.  In
shallow binding, they are whichever variables with the same names happen
to be in scope when the subroutine is called.  Perl always uses deep
binding of lexical variables (i.e., those created with my()).  However,
dynamic variables (aka global, local, or package variables) are
effectively shallowly bound.  Consider this just one more reason not to
use them.  See the answer to `"What's a closure?"' in this node.

Why doesn't "my($foo) = <FILE>;" work right?
--------------------------------------------

   my() and `local()' give list context to the right hand side of =.  The
<FH> read operation, like so many of Perl's functions and operators, can
tell which context it was called in and behaves appropriately.  In
general, the scalar() function can help.  This function does nothing to
the data itself (contrary to popular myth) but rather tells its argument
to behave in whatever its scalar fashion is.  If that function doesn't
have a defined scalar behavior, this of course doesn't help you (such as
with sort()).

   To enforce scalar context in this particular case, however, you need
merely omit the parentheses:

     local($foo) = <FILE>;	    # WRONG
     local($foo) = scalar(<FILE>);   # ok
     local $foo  = <FILE>;	    # right

   You should probably be using lexical variables anyway, although the
issue is the same here:

     my($foo) = <FILE>;	# WRONG
     my $foo  = <FILE>;	# right

How do I redefine a builtin function, operator, or method?
----------------------------------------------------------

   Why do you want to do that? :-)

   If you want to override a predefined function, such as open(), then
you'll have to import the new definition from a different module.  See
`"Overriding Built-in Functions"', *Note Perlsub: perlsub,.  There's also
an example in `"Class::Template"', *Note Perltoot: perltoot,.

   If you want to overload a Perl operator, such as + or `**', then you'll
want to use the `use overload' pragma, documented in *Note Overload:
(pm.info)overload,.

   If you're talking about obscuring method calls in parent classes, see
`"Overridden Methods"', *Note Perltoot: perltoot,.

What's the difference between calling a function as &foo and foo()?
-------------------------------------------------------------------

   When you call a function as `&foo', you allow that function access to
your current @_ values, and you by-pass prototypes.  That means that the
function doesn't get an empty @_, it gets yours!  While not strictly
speaking a bug (it's documented that way in *Note Perlsub: perlsub,), it
would be hard to consider this a feature in most cases.

   When you call your function as `&foo()', then you do get a new @_, but
prototyping is still circumvented.

   Normally, you want to call a function using `foo()'.  You may only omit
the parentheses if the function is already known to the compiler because
it already saw the definition (use but not require), or via a forward
reference or `use subs' declaration.  Even in this case, you get a clean
@_ without any of the old values leaking through where they don't belong.

How do I create a switch or case statement?
-------------------------------------------

   This is explained in more depth in the *Note Perlsyn: perlsyn,.
Briefly, there's no official case statement, because of the variety of
tests possible in Perl (numeric comparison, string comparison, glob
comparison, regex matching, overloaded comparisons, ...).  Larry couldn't
decide how best to do this, so he left it out, even though it's been on the
wish list since perl1.

   The general answer is to write a construct like this:

     for ($variable_to_test) {
     	if    (/pat1/)  { }     # do something
     	elsif (/pat2/)  { }     # do something else
     	elsif (/pat3/)  { }     # do something else
     	else            { }     # default
     }

   Here's a simple example of a switch based on pattern matching, this
time lined up in a way to make it look more like a switch statement.
We'll do a multi-way conditional based on the type of reference stored in
$whatchamacallit:

     SWITCH: for (ref $whatchamacallit) {

     /^$/		&& die "not a reference";

     /SCALAR/	&& do {
     			print_scalar($$ref);
     			last SWITCH;
     		};

     /ARRAY/		&& do {
     			print_array(@$ref);
     			last SWITCH;
     		};

     /HASH/		&& do {
     			print_hash(%$ref);
     			last SWITCH;
     		};

     /CODE/		&& do {
     			warn "can't print function ref";
     			last SWITCH;
     		};

     # DEFAULT

     warn "User defined type skipped";

     }

   See `perlsyn/"Basic BLOCKs and Switch Statements"' for many other
examples in this style.

   Sometimes you should change the positions of the constant and the
variable.  For example, let's say you wanted to test which of many answers
you were given, but in a case-insensitive way that also allows
abbreviations.  You can use the following technique if the strings all
start with different characters, or if you want to arrange the matches so
that one takes precedence over another, as `"SEND"' has precedence over
`"STOP"' here:

     chomp($answer = <>);
     if    ("SEND"  =~ /^\Q$answer/i) { print "Action is send\n"  }
     elsif ("STOP"  =~ /^\Q$answer/i) { print "Action is stop\n"  }
     elsif ("ABORT" =~ /^\Q$answer/i) { print "Action is abort\n" }
     elsif ("LIST"  =~ /^\Q$answer/i) { print "Action is list\n"  }
     elsif ("EDIT"  =~ /^\Q$answer/i) { print "Action is edit\n"  }

   A totally different approach is to create a hash of function references.

     my %commands = (
         "happy" => \&joy,
         "sad",  => \&sullen,
         "done"  => sub { die "See ya!" },
         "mad"   => \&angry,
     );

     print "How are you? ";
     chomp($string = <STDIN>);
     if ($commands{$string}) {
         $commands{$string}->();
     } else {
         print "No such command: $string\n";
     }

How can I catch accesses to undefined variables/functions/methods?
------------------------------------------------------------------

   The AUTOLOAD method, discussed in `"Autoloading"', *Note Perlsub:
perlsub, and `"AUTOLOAD: Proxy Methods"', *Note Perltoot: perltoot,, lets
you capture calls to undefined functions and methods.

   When it comes to undefined variables that would trigger a warning under
-w, you can use a handler to trap the pseudo-signal `__WARN__' like this:

     $SIG{__WARN__} = sub {

     for ( $_[0] ) {		# voici un switch statement

     /Use of uninitialized value/  && do {
     		# promote warning to a fatal
     		die $_;
     };

     # other warning cases to catch could go here;

     warn $_;
     	}

     };

Why can't a method included in this same file be found?
-------------------------------------------------------

   Some possible reasons: your inheritance is getting confused, you've
misspelled the method name, or the object is of the wrong type.  Check out
*Note Perltoot: perltoot, for details on these.  You may also use `print
ref($object)' to find out the class $object was blessed into.

   Another possible reason for problems is because you've used the
indirect object syntax (eg, `find Guru "Samy"') on a class name before
Perl has seen that such a package exists.  It's wisest to make sure your
packages are all defined before you start using them, which will be taken
care of if you use the use statement instead of require.  If not, make
sure to use arrow notation (eg, `< Guru-'find("Samy") >>) instead.  Object
notation is explained in *Note Perlobj: perlobj,.

   Make sure to read about creating modules in *Note Perlmod: perlmod, and
the perils of indirect objects in `"WARNING"', *Note Perlobj: perlobj,.

How can I find out my current package?
--------------------------------------

   If you're just a random program, you can do this to find out what the
currently compiled package is:

     my $packname = __PACKAGE__;

   But if you're a method and you want to print an error message that
includes the kind of object you were called on (which is not necessarily
the same as the one in which you were compiled):

     sub amethod {
     	my $self  = shift;
     	my $class = ref($self) || $self;
     	warn "called me from a $class object";
     }

How can I comment out a large block of perl code?
-------------------------------------------------

   Use embedded POD to discard it:

     # program is here

     =for nobody
     This paragraph is commented out

     # program continues

     =begin comment text

     all of this stuff

     here will be ignored
     by everyone

     =end comment text

     =cut

   This can't go just anywhere.  You have to put a pod directive where the
parser is expecting a new statement, not just in the middle of an
expression or some other arbitrary yacc grammar production.

How do I clear a package?
-------------------------

   Use this code, provided by Mark-Jason Dominus:

     sub scrub_package {
     	no strict 'refs';
     	my $pack = shift;
     	die "Shouldn't delete main package"
     	    if $pack eq "" || $pack eq "main";
     	my $stash = *{$pack . '::'}{HASH};
     	my $name;
     	foreach $name (keys %$stash) {
     	    my $fullname = $pack . '::' . $name;
     	    # Get rid of everything with that name.
     	    undef $$fullname;
     	    undef @$fullname;
     	    undef %$fullname;
     	    undef &$fullname;
     	    undef *$fullname;
     	}
     }

   Or, if you're using a recent release of Perl, you can just use the
Symbol::delete_package() function instead.

How can I use a variable as a variable name?
--------------------------------------------

   Beginners often think they want to have a variable contain the name of
a variable.

     $fred    = 23;
     $varname = "fred";
     ++$$varname;         # $fred now 24

   This works *sometimes*, but it is a very bad idea for two reasons.

   The first reason is that they *only work on global variables*.  That
means above that if $fred is a lexical variable created with my(), that
the code won't work at all: you'll accidentally access the global and skip
right over the private lexical altogether.  Global variables are bad
because they can easily collide accidentally and in general make for
non-scalable and confusing code.

   Symbolic references are forbidden under the `use strict' pragma.  They
are not true references and consequently are not reference counted or
garbage collected.

   The other reason why using a variable to hold the name of another
variable a bad idea is that the question often stems from a lack of
understanding of Perl data structures, particularly hashes.  By using
symbolic references, you are just using the package's symbol-table hash
(like `%main::') instead of a user-defined hash.  The solution is to use
your own hash or a real reference instead.

     $fred    = 23;
     $varname = "fred";
     $USER_VARS{$varname}++;  # not $$varname++

   There we're using the %USER_VARS hash instead of symbolic references.
Sometimes this comes up in reading strings from the user with variable
references and wanting to expand them to the values of your perl program's
variables.  This is also a bad idea because it conflates the
program-addressable namespace and the user-addressable one.  Instead of
reading a string and expanding it to the actual contents of your program's
own variables:

     $str = 'this has a $fred and $barney in it';
     $str =~ s/(\$\w+)/$1/eeg;		  # need double eval

   Instead, it would be better to keep a hash around like %USER_VARS and
have variable references actually refer to entries in that hash:

     $str =~ s/\$(\w+)/$USER_VARS{$1}/g;   # no /e here at all

   That's faster, cleaner, and safer than the previous approach.  Of
course, you don't need to use a dollar sign.  You could use your own
scheme to make it less confusing, like bracketed percent symbols, etc.

     $str = 'this has a %fred% and %barney% in it';
     $str =~ s/%(\w+)%/$USER_VARS{$1}/g;   # no /e here at all

   Another reason that folks sometimes think they want a variable to
contain the name of a variable is because they don't know how to build
proper data structures using hashes.  For example, let's say they wanted
two hashes in their program: %fred and %barney, and to use another scalar
variable to refer to those by name.

     $name = "fred";
     $$name{WIFE} = "wilma";     # set %fred

     $name = "barney";
     $$name{WIFE} = "betty";	# set %barney

   This is still a symbolic reference, and is still saddled with the
problems enumerated above.  It would be far better to write:

     $folks{"fred"}{WIFE}   = "wilma";
     $folks{"barney"}{WIFE} = "betty";

   And just use a multilevel hash to start with.

   The only times that you absolutely must use symbolic references are
when you really must refer to the symbol table.  This may be because it's
something that can't take a real reference to, such as a format name.
Doing so may also be important for method calls, since these always go
through the symbol table for resolution.

   In those cases, you would turn off `strict 'refs'' temporarily so you
can play around with the symbol table.  For example:

     @colors = qw(red blue green yellow orange purple violet);
     for my $name (@colors) {
         no strict 'refs';  # renege for the block
         *$name = sub { "<FONT COLOR='$name'>@_</FONT>" };
     }

   All those functions (red(), blue(), green(), etc.) appear to be
separate, but the real code in the closure actually was compiled only once.

   So, sometimes you might want to use symbolic references to directly
manipulate the symbol table.  This doesn't matter for formats, handles, and
subroutines, because they are always global - you can't use my() on them.
But for scalars, arrays, and hashes - and usually for subroutines - you
probably want to use hard references only.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.


File: perl.info,  Node: perlfaq8,  Next: Top,  Prev: Top,  Up: Top

System Interaction ($Revision: 1.39 $, $Date: 1999/05/23 18:37:57 $)
********************************************************************

NAME
====

   perlfaq8 - System Interaction ($Revision: 1.39 $, $Date: 1999/05/23
18:37:57 $)

DESCRIPTION
===========

   This section of the Perl FAQ covers questions involving operating
system interaction.  This involves interprocess communication (IPC),
control over the user-interface (keyboard, screen and pointing devices),
and most anything else not related to data manipulation.

   Read the FAQs and documentation specific to the port of perl to your
operating system (eg, *Note Perlvms: perlvms,, `perlplan9' in this node,
...).  These should contain more detailed information on the vagaries of
your perl.

How do I find out which operating system I'm running under?
-----------------------------------------------------------

   The $^O variable ($OSNAME if you use English) contains an indication of
the name of the operating system (not its release number) that your perl
binary was built for.

How come exec() doesn't return?
-------------------------------

   Because that's what it does: it replaces your currently running program
with a different one.  If you want to keep going (as is probably the case
if you're asking this question) use system() instead.

How do I do fancy stuff with the keyboard/screen/mouse?
-------------------------------------------------------

   How you access/control keyboards, screens, and pointing devices
("mice") is system-dependent.  Try the following modules:

Keyboard
          Term::Cap			Standard perl distribution
          Term::ReadKey		CPAN
          Term::ReadLine::Gnu		CPAN
          Term::ReadLine::Perl	CPAN
          Term::Screen		CPAN

Screen
          Term::Cap			Standard perl distribution
          Curses			CPAN
          Term::ANSIColor		CPAN

Mouse
     * Menu:
     
     * perl:: 	Perl overview (this section)
     * perldelta:: 	Perl changes since previous version
     * perl5005delta:: Perl changes in version 5.005
     * perl5004delta:: Perl changes in version 5.004
     * perlfaq:: 	Perl frequently asked questions
     * perltoc:: 	Perl documentation table of contents
     
     * perldata:: 	Perl data structures
     * perlsyn:: 	Perl syntax
     * perlop:: 	Perl operators and precedence
     * perlre:: 	Perl regular expressions
     * perlrun:: 	Perl execution and options
     * perlfunc:: 	Perl builtin functions
     * perlopentut:: 	Perl open() tutorial
     * perlvar:: 	Perl predefined variables
     * perlsub:: 	Perl subroutines
     * perlmod:: 	Perl modules: how they work
     * perlmodlib:: 	Perl modules: how to write and use
     * perlmodinstall:: Perl modules: how to install from CPAN
     * perlform:: 	Perl formats
     * perlunicode:: 	Perl unicode support
     * perllocale:: 	Perl locale support
     
     * perlreftut:: 	Perl references short introduction
     * perlref:: 	Perl references, the rest of the story
     * perldsc:: 	Perl data structures intro
     * perllol:: 	Perl data structures: arrays of arrays
     * perlboot:: 	Perl OO tutorial for beginners
     * perltoot:: 	Perl OO tutorial, part 1
     * perltootc:: 	Perl OO tutorial, part 2
     * perlobj:: 	Perl objects
     * perltie:: 	Perl objects hidden behind simple variables
     * perlbot:: 	Perl OO tricks and examples
     * perlipc:: 	Perl interprocess communication
     * perlfork:: 	Perl fork() information
     * perlthrtut:: 	Perl threads tutorial
     * perllexwarn:: 	Perl warnings and their control
     * perlfilter:: 	Perl source filters
     * perldbmfilter:: Perl DBM filters
     
     * perlcompile:: 	Perl compiler suite intro
     * perldebug:: 	Perl debugging
     * perldiag:: 	Perl diagnostic messages
     * perlnumber:: 	Perl number semantics
     * perlsec:: 	Perl security
     * perltrap:: 	Perl traps for the unwary
     * perlport:: 	Perl portability guide
     * perlstyle:: 	Perl style guide
     
     * perlpod:: 	Perl plain old documentation
     * perlbook:: 	Perl book information
     
     * perlembed:: 	Perl ways to embed perl in your C or C++ application
     * perlapio:: 	Perl internal IO abstraction interface
     * perldebguts:: 	Perl debugging guts and tips
     * perlxs:: 	Perl XS application programming interface
     * perlxstut:: 	Perl XS tutorial
     * perlguts:: 	Perl internal functions for those doing extensions
     * perlcall:: 	Perl calling conventions from C
     * perlapi:: 	Perl API listing (autogenerated)
     * perlintern:: 	Perl internal functions (autogenerated)
     
     * perltodo:: 	Perl things to do
     * perlhack:: 	Perl hackers guide
     * perlhist:: 	Perl history records
     
     * perlamiga:: 	Perl notes for Amiga
     * perlcygwin:: 	Perl notes for Cygwin
     * perldos:: 	Perl notes for DOS
     * perlhpux:: 	Perl notes for HP-UX
     * perlmachten:: 	Perl notes for Power MachTen
     * perlos2:: 	Perl notes for OS/2
     * perlos390:: 	Perl notes for OS/390
     * perlvms:: 	Perl notes for VMS
     * perlwin32:: 	Perl notes for Windows
     
     * Tk:: 			CPAN
     
     
     * Module List:(pm.info)Module List. Got your modules, right here
     * Function Index:: Perl functions and operators
     * Predefined Variable Index:: Perl predefined variables
     * Diagnostics Index:: Perl diagnostic messages

   Some of these specific cases are shown below.

How do I print something out in color?
--------------------------------------

   In general, you don't, because you don't know whether the recipient has
a color-aware display device.  If you know that they have an ANSI terminal
that understands color, you can use the Term::ANSIColor module from CPAN:

     use Term::ANSIColor;
     print color("red"), "Stop!\n", color("reset");
     print color("green"), "Go!\n", color("reset");

   Or like this:

     use Term::ANSIColor qw(:constants);
     print RED, "Stop!\n", RESET;
     print GREEN, "Go!\n", RESET;

How do I read just one key without waiting for a return key?
------------------------------------------------------------

   Controlling input buffering is a remarkably system-dependent matter.
On many systems, you can just use the *stty* command as shown in `getc',
*Note Perlfunc: perlfunc,, but as you see, that's already getting you into
portability snags.

     open(TTY, "+</dev/tty") or die "no tty: $!";
     system "stty  cbreak </dev/tty >/dev/tty 2>&1";
     $key = getc(TTY);		# perhaps this works
     # OR ELSE
     sysread(TTY, $key, 1);	# probably this does
     system "stty -cbreak </dev/tty >/dev/tty 2>&1";

   The Term::ReadKey module from CPAN offers an easy-to-use interface that
should be more efficient than shelling out to *stty* for each key.  It
even includes limited support for Windows.

     use Term::ReadKey;
     ReadMode('cbreak');
     $key = ReadKey(0);
     ReadMode('normal');

   However, that requires that you have a working C compiler and can use it
to build and install a CPAN module.  Here's a solution using the standard
POSIX module, which is already on your systems (assuming your system
supports POSIX).

     use HotKey;
     $key = readkey();

   And here's the HotKey module, which hides the somewhat mystifying calls
to manipulate the POSIX termios structures.

     # HotKey.pm
     package HotKey;

     @ISA = qw(Exporter);
     @EXPORT = qw(cbreak cooked readkey);

     use strict;
     use POSIX qw(:termios_h);
     my ($term, $oterm, $echo, $noecho, $fd_stdin);

     $fd_stdin = fileno(STDIN);
     $term     = POSIX::Termios->new();
     $term->getattr($fd_stdin);
     $oterm     = $term->getlflag();

     $echo     = ECHO | ECHOK | ICANON;
     $noecho   = $oterm & ~$echo;

     sub cbreak {
         $term->setlflag($noecho);  # ok, so i don't want echo either
         $term->setcc(VTIME, 1);
         $term->setattr($fd_stdin, TCSANOW);
     }

     sub cooked {
         $term->setlflag($oterm);
         $term->setcc(VTIME, 0);
         $term->setattr($fd_stdin, TCSANOW);
     }

     sub readkey {
         my $key = '';
         cbreak();
         sysread(STDIN, $key, 1);
         cooked();
         return $key;
     }

     END { cooked() }

     1;

How do I check whether input is ready on the keyboard?
------------------------------------------------------

   The easiest way to do this is to read a key in nonblocking mode with the
Term::ReadKey module from CPAN, passing it an argument of -1 to indicate
not to block:

     use Term::ReadKey;

     ReadMode('cbreak');

     if (defined ($char = ReadKey(-1)) ) {
         # input was waiting and it was $char
     } else {
         # no input was waiting
     }

     ReadMode('normal');                  # restore normal tty settings

How do I clear the screen?
--------------------------

   If you only have do so infrequently, use system:

     system("clear");

   If you have to do this a lot, save the clear string so you can print it
100 times without calling a program 100 times:

     $clear_string = `clear`;
     print $clear_string;

   If you're planning on doing other screen manipulations, like cursor
positions, etc, you might wish to use Term::Cap module:

     use Term::Cap;
     $terminal = Term::Cap->Tgetent( {OSPEED => 9600} );
     $clear_string = $terminal->Tputs('cl');

How do I get the screen size?
-----------------------------

   If you have Term::ReadKey module installed from CPAN, you can use it to
fetch the width and height in characters and in pixels:

     use Term::ReadKey;
     ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

   This is more portable than the raw ioctl, but not as illustrative:

     require 'sys/ioctl.ph';
     die "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
     open(TTY, "+</dev/tty")                     or die "No tty: $!";
     unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
         die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
     }
     ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
     print "(row,col) = ($row,$col)";
     print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
     print "\n";

How do I ask the user for a password?
-------------------------------------

   (This question has nothing to do with the web.  See a different FAQ for
that.)

   There's an example of this in `crypt', *Note Perlfunc: perlfunc,).
First, you put the terminal into "no echo" mode, then just read the
password normally.  You may do this with an old-style ioctl() function,
POSIX terminal control (see `crypt', *Note POSIX: (pm.info)POSIX,, and
Chapter 7 of the Camel), or a call to the *stty* program, with varying
degrees of portability.

   You can also do this for most systems using the Term::ReadKey module
from CPAN, which is easier to use and in theory more portable.

     use Term::ReadKey;

     ReadMode('noecho');
     $password = ReadLine(0);

How do I read and write the serial port?
----------------------------------------

   This depends on which operating system your program is running on.  In
the case of Unix, the serial ports will be accessible through files in
/dev; on other systems, the devices names will doubtless differ.  Several
problem areas common to all device interaction are the following

lockfiles
     Your system may use lockfiles to control multiple access.  Make sure
     you follow the correct protocol.  Unpredictable behaviour can result
     from multiple processes reading from one device.

open mode
     If you expect to use both read and write operations on the device,
     you'll have to open it for update (see `"open"', *Note Perlfunc:
     perlfunc, for details).  You may wish to open it without running the
     risk of blocking by using sysopen() and `O_RDWR|O_NDELAY|O_NOCTTY'
     from the Fcntl module (part of the standard perl distribution).  See
     `"sysopen"', *Note Perlfunc: perlfunc, for more on this approach.

end of line
     Some devices will be expecting a "\r" at the end of each line rather
     than a "\n".  In some ports of perl, "\r" and "\n" are different from
     their usual (Unix) ASCII values of "\012" and "\015".  You may have to
     give the numeric values you want directly, using octal ("\015"), hex
     ("0x0D"), or as a control-character specification ("\cM").

          print DEV "atv1\012";	# wrong, for some devices
          print DEV "atv1\015";	# right, for some devices

     Even though with normal text files, a "\n" will do the trick, there is
     still no unified scheme for terminating a line that is portable
     between Unix, DOS/Win, and Macintosh, except to terminate ALL line
     ends with "\015\012", and strip what you don't need from the output.
     This applies especially to socket I/O and autoflushing, discussed
     next.

flushing output
     If you expect characters to get to your device when you print() them,
     you'll want to autoflush that filehandle.  You can use select() and
     the $| variable to control autoflushing (see `$|', *Note Perlvar:
     perlvar, and `select', *Note Perlfunc: perlfunc,):

          $oldh = select(DEV);
          $| = 1;
          select($oldh);

     You'll also see code that does this without a temporary variable, as
     in

          select((select(DEV), $| = 1)[0]);

     Or if you don't mind pulling in a few thousand lines of code just
     because you're afraid of a little $| variable:

          use IO::Handle;
          DEV->autoflush(1);

     As mentioned in the previous item, this still doesn't work when using
     socket I/O between Unix and Macintosh.  You'll need to hardcode your
     line terminators, in that case.

non-blocking input
     If you are doing a blocking read() or sysread(), you'll have to
     arrange for an alarm handler to provide a timeout (see `alarm', *Note
     Perlfunc: perlfunc,).  If you have a non-blocking open, you'll likely
     have a non-blocking read, which means you may have to use a 4-arg
     select() to determine whether I/O is ready on that device (see
     `"select"', *Note Perlfunc: perlfunc,.

   While trying to read from his caller-id box, the notorious Jamie
Zawinski <jwz@netscape.com>, after much gnashing of teeth and fighting
with sysread, sysopen, POSIX's tcgetattr business, and various other
functions that go bump in the night, finally came up with this:

     sub open_modem {
     	use IPC::Open2;
     	my $stty = `/bin/stty -g`;
     	open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2>&1");
     	# starting cu hoses /dev/tty's stty settings, even when it has
     	# been opened on a pipe...
     	system("/bin/stty $stty");
     	$_ = <MODEM_IN>;
     	chop;
     	if ( !m/^Connected/ ) {
     	    print STDERR "$0: cu printed `$_' instead of `Connected'\n";
     	}
     }

How do I decode encrypted password files?
-----------------------------------------

   You spend lots and lots of money on dedicated hardware, but this is
bound to get you talked about.

   Seriously, you can't if they are Unix password files - the Unix
password system employs one-way encryption.  It's more like hashing than
encryption.  The best you can check is whether something else hashes to
the same string.  You can't turn a hash back into the original string.
Programs like Crack can forcibly (and intelligently) try to guess
passwords, but don't (can't) guarantee quick success.

   If you're worried about users selecting bad passwords, you should
proactively check when they try to change their password (by modifying
passwd(1), for example).

How do I start a process in the background?
-------------------------------------------

   You could use

     system("cmd &")

   or you could use fork as documented in `"fork"', *Note Perlfunc:
perlfunc,, with further examples in `"fork"', *Note Perlipc: perlipc,.
Some things to be aware of, if you're on a Unix-like system:

STDIN, STDOUT, and STDERR are shared
     Both the main process and the backgrounded one (the "child" process)
     share the same STDIN, STDOUT and STDERR filehandles.  If both try to
     access them at once, strange things can happen.  You may want to close
     or reopen these for the child.  You can get around this with opening
     a pipe (see `"open"', *Note Perlfunc: perlfunc,) but on some systems
     this means that the child process cannot outlive the parent.

Signals
     You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too.
     SIGCHLD is sent when the backgrounded process finishes.  SIGPIPE is
     sent when you write to a filehandle whose child process has closed (an
     untrapped SIGPIPE can cause your program to silently die).  This is
     not an issue with `system("cmd&")'.

Zombies
     You have to be prepared to "reap" the child process when it finishes

          $SIG{CHLD} = sub { wait };

     See `"Signals"', *Note Perlipc: perlipc, for other examples of code
     to do this.  Zombies are not an issue with `system("prog &")'.

How do I trap control characters/signals?
-----------------------------------------

   You don't actually "trap" a control character.  Instead, that character
generates a signal which is sent to your terminal's currently foregrounded
process group, which you then trap in your process.  Signals are
documented in `"Signals"', *Note Perlipc: perlipc, and chapter 6 of the
Camel.

   Be warned that very few C libraries are re-entrant.  Therefore, if you
attempt to print() in a handler that got invoked during another stdio
operation your internal structures will likely be in an inconsistent
state, and your program will dump core.  You can sometimes avoid this by
using syswrite() instead of print().

   Unless you're exceedingly careful, the only safe things to do inside a
signal handler are: set a variable and exit.  And in the first case, you
should only set a variable in such a way that malloc() is not called (eg,
by setting a variable that already has a value).

   For example:

     $Interrupted = 0;	# to ensure it has a value
     $SIG{INT} = sub {
         $Interrupted++;
     	syswrite(STDERR, "ouch\n", 5);
     }

   However, because syscalls restart by default, you'll find that if
you're in a "slow" call, such as <FH>, read(), connect(), or wait(), that
the only way to terminate them is by "longjumping" out; that is, by
raising an exception.  See the time-out handler for a blocking flock() in
`"Signals"', *Note Perlipc: perlipc, or chapter 6 of the Camel.

How do I modify the shadow password file on a Unix system?
----------------------------------------------------------

   If perl was installed correctly, and your shadow library was written
properly, the getpw*() functions described in *Note Perlfunc: perlfunc,
should in theory provide (read-only) access to entries in the shadow
password file.  To change the file, make a new shadow password file (the
format varies from system to system - see `passwd(5)' in this node for
specifics) and use pwd_mkdb(8) to install it (see `pwd_mkdb(8)' in this
node for more details).

How do I set the time and date?
-------------------------------

   Assuming you're running under sufficient permissions, you should be
able to set the system-wide date and time by running the date(1) program.
(There is no way to set the time and date on a per-process basis.)  This
mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent
is `set time'.

   However, if all you want to do is change your timezone, you can
probably get away with setting an environment variable:

     $ENV{TZ} = "MST7MDT";		   # unixish
     $ENV{'SYS$TIMEZONE_DIFFERENTIAL'}="-5" # vms
     system "trn comp.lang.perl.misc";

How can I sleep() or alarm() for under a second?
------------------------------------------------

   If you want finer granularity than the 1 second that the sleep()
function provides, the easiest way is to use the select() function as
documented in `"select"', *Note Perlfunc: perlfunc,.  If your system has
itimers and syscall() support, you can check out the old example in
http://www.perl.com/CPAN/doc/misc/ancient/tutorial/eg/itimers.pl .

How can I measure time under a second?
--------------------------------------

   In general, you may not be able to.  The Time::HiRes module (available
from CPAN) provides this functionality for some systems.

   If your system supports both the syscall() function in Perl as well as
a system call like gettimeofday(2), then you may be able to do something
like this:

     require 'sys/syscall.ph';

     $TIMEVAL_T = "LL";

     $done = $start = pack($TIMEVAL_T, ());

     syscall(&SYS_gettimeofday, $start, 0) != -1
                or die "gettimeofday: $!";

     ##########################
     # DO YOUR OPERATION HERE #
     ##########################

     syscall( &SYS_gettimeofday, $done, 0) != -1
            or die "gettimeofday: $!";

     @start = unpack($TIMEVAL_T, $start);
     @done  = unpack($TIMEVAL_T, $done);

     # fix microseconds
     for ($done[1], $start[1]) { $_ /= 1_000_000 }

     $delta_time = sprintf "%.4f", ($done[0]  + $done[1]  )
                                             -
                                  ($start[0] + $start[1] );

How can I do an atexit() or setjmp()/longjmp()? (Exception handling)
--------------------------------------------------------------------

   Release 5 of Perl added the END block, which can be used to simulate
atexit().  Each package's END block is called when the program or thread
ends (see *Note Perlmod: perlmod, manpage for more details).

   For example, you can use this to make sure your filter program managed
to finish its output without filling up the disk:

     END {
     	close(STDOUT) || die "stdout close failed: $!";
     }

   The END block isn't called when untrapped signals kill the program,
though, so if you use END blocks you should also use

     use sigtrap qw(die normal-signals);

   Perl's exception-handling mechanism is its eval() operator.  You can
use eval() as setjmp and die() as longjmp.  For details of this, see the
section on signals, especially the time-out handler for a blocking flock()
in `"Signals"', *Note Perlipc: perlipc, and chapter 6 of the Camel.

   If exception handling is all you're interested in, try the
exceptions.pl library (part of the standard perl distribution).

   If you want the atexit() syntax (and an rmexit() as well), try the
AtExit module available from CPAN.

Why doesn't my sockets program work under System V (Solaris)? What does the error message "Protocol not supported" mean?
------------------------------------------------------------------------------------------------------------------------

   Some Sys-V based systems, notably Solaris 2.X, redefined some of the
standard socket constants.  Since these were constant across all
architectures, they were often hardwired into perl code.  The proper way
to deal with this is to "use Socket" to get the correct values.

   Note that even though SunOS and Solaris are binary compatible, these
values are different.  Go figure.

How can I call my system's unique C functions from Perl?
--------------------------------------------------------

   In most cases, you write an external module to do it - see the answer
to "Where can I learn about linking C with Perl? [h2xs, xsubpp]".
However, if the function is a system call, and your system supports
syscall(), you can use the syscall function (documented in *Note Perlfunc:
perlfunc,).

   Remember to check the modules that came with your distribution, and
CPAN as well - someone may already have written a module to do it.

Where do I get the include files to do ioctl() or syscall()?
------------------------------------------------------------

   Historically, these would be generated by the h2ph tool, part of the
standard perl distribution.  This program converts cpp(1) directives in C
header files to files containing subroutine definitions, like
&SYS_getitimer, which you can use as arguments to your functions.  It
doesn't work perfectly, but it usually gets most of the job done.  Simple
files like `errno.h', `syscall.h', and `socket.h' were fine, but the hard
ones like `ioctl.h' nearly always need to hand-edited.  Here's how to
install the *.ph files:

     1.  become super-user
     2.  cd /usr/include
     3.  h2ph *.h */*.h

   If your system supports dynamic loading, for reasons of portability and
sanity you probably ought to use h2xs (also part of the standard perl
distribution).  This tool converts C header files to Perl extensions.  See
*Note Perlxstut: perlxstut, for how to get started with h2xs.

   If your system doesn't support dynamic loading, you still probably
ought to use h2xs.  See *Note Perlxstut: perlxstut, and *Note
ExtUtils/MakeMaker: (pm.info)ExtUtils/MakeMaker, for more information (in
brief, just use *make perl* instead of a plain make to rebuild perl with a
new static extension).

Why do setuid perl scripts complain about kernel problems?
----------------------------------------------------------

   Some operating systems have bugs in the kernel that make setuid scripts
inherently insecure.  Perl gives you a number of options (described in
*Note Perlsec: perlsec,) to work around such systems.

How can I open a pipe both to and from a command?
-------------------------------------------------

   The IPC::Open2 module (part of the standard perl distribution) is an
easy-to-use approach that internally uses pipe(), fork(), and exec() to do
the job.  Make sure you read the deadlock warnings in its documentation,
though (see *Note IPC/Open2: (pm.info)IPC/Open2,).  See `"Bidirectional
Communication with Another Process"', *Note Perlipc: perlipc, and
`"Bidirectional Communication with Yourself"', *Note Perlipc: perlipc,

   You may also use the IPC::Open3 module (part of the standard perl
distribution), but be warned that it has a different order of arguments
from IPC::Open2 (see *Note IPC/Open3: (pm.info)IPC/Open3,).

Why can't I get the output of a command with system()?
------------------------------------------------------

   You're confusing the purpose of system() and backticks (").  system()
runs a command and returns exit status information (as a 16 bit value: the
low 7 bits are the signal the process died from, if any, and the high 8
bits are the actual exit value).  Backticks (") run a command and return
what it sent to STDOUT.

     $exit_status   = system("mail-users");
     $output_string = `ls`;

How can I capture STDERR from an external command?
--------------------------------------------------

   There are three basic ways of running external commands:

     system $cmd;		# using system()
     $output = `$cmd`;		# using backticks (``)
     open (PIPE, "cmd |");	# using open()

   With system(), both STDOUT and STDERR will go the same place as the
script's versions of these, unless the command redirects them.  Backticks
and open() read *only* the STDOUT of your command.

   With any of these, you can change file descriptors before the call:

     open(STDOUT, ">logfile");
     system("ls");

   or you can use Bourne shell file-descriptor redirection:

     $output = `$cmd 2>some_file`;
     open (PIPE, "cmd 2>some_file |");

   You can also use file-descriptor redirection to make STDERR a duplicate
of STDOUT:

     $output = `$cmd 2>&1`;
     open (PIPE, "cmd 2>&1 |");

   Note that you *cannot* simply open STDERR to be a dup of STDOUT in your
Perl program and avoid calling the shell to do the redirection.  This
doesn't work:

     open(STDERR, ">&STDOUT");
     $alloutput = `cmd args`;  # stderr still escapes

   This fails because the open() makes STDERR go to where STDOUT was going
at the time of the open().  The backticks then make STDOUT go to a string,
but don't change STDERR (which still goes to the old STDOUT).

   Note that you must use Bourne shell (sh(1)) redirection syntax in
backticks, not csh(1)!  Details on why Perl's system() and backtick and
pipe opens all use the Bourne shell are in
http://www.perl.com/CPAN/doc/FMTEYEWTK/versus/csh.whynot .  To capture a
command's STDERR and STDOUT together:

     $output = `cmd 2>&1`;                       # either with backticks
     $pid = open(PH, "cmd 2>&1 |");              # or with an open pipe
     while (<PH>) { }                            #    plus a read

   To capture a command's STDOUT but discard its STDERR:

     $output = `cmd 2>/dev/null`;                # either with backticks
     $pid = open(PH, "cmd 2>/dev/null |");       # or with an open pipe
     while (<PH>) { }                            #    plus a read

   To capture a command's STDERR but discard its STDOUT:

     $output = `cmd 2>&1 1>/dev/null`;           # either with backticks
     $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or with an open pipe
     while (<PH>) { }                            #    plus a read

   To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out our old STDERR:

     $output = `cmd 3>&1 1>&2 2>&3 3>&-`;        # either with backticks
     $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&-|");# or with an open pipe
     while (<PH>) { }                            #    plus a read

   To read both a command's STDOUT and its STDERR separately, it's easiest
and safest to redirect them separately to files, and then read from those
files when the program is done:

     system("program args 1>/tmp/program.stdout 2>/tmp/program.stderr");

   Ordering is important in all these examples.  That's because the shell
processes file descriptor redirections in strictly left to right order.

     system("prog args 1>tmpfile 2>&1");
     system("prog args 2>&1 1>tmpfile");

   The first command sends both standard out and standard error to the
temporary file.  The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.

Why doesn't open() return an error when a pipe open fails?
----------------------------------------------------------

   Because the pipe open takes place in two steps: first Perl calls fork()
to start a new process, then this new process calls exec() to run the
program you really wanted to open.  The first step reports success or
failure to your process, so open() can only tell you whether the fork()
succeeded or not.

   To find out if the exec() step succeeded, you have to catch SIGCHLD and
wait() to get the exit status.  You should also catch SIGPIPE if you're
writing to the child-you may not have found out the exec() failed by the
time you write.  This is documented in *Note Perlipc: perlipc,.

   In some cases, even this won't work.  If the second argument to a piped
open() contains shell metacharacters, perl fork()s, then exec()s a shell
to decode the metacharacters and eventually run the desired program.  Now
when you call wait(), you only learn whether or not the *shell* could be
successfully started.  Best to avoid shell metacharacters.

   On systems that follow the spawn() paradigm, open() *might* do what you
expect-unless perl uses a shell to start your command. In this case the
fork()/exec() description still applies.

What's wrong with using backticks in a void context?
----------------------------------------------------

   Strictly speaking, nothing.  Stylistically speaking, it's not a good
way to write maintainable code because backticks have a (potentially
humongous) return value, and you're ignoring it.  It's may also not be very
efficient, because you have to read in all the lines of output, allocate
memory for them, and then throw it away.  Too often people are lulled to
writing:

     `cp file file.bak`;

   And now they think "Hey, I'll just always use backticks to run
programs."  Bad idea: backticks are for capturing a program's output; the
system() function is for running programs.

   Consider this line:

     `cat /etc/termcap`;

   You haven't assigned the output anywhere, so it just wastes memory (for
a little while).  Plus you forgot to check $? to see whether the program
even ran correctly.  Even if you wrote

     print `cat /etc/termcap`;

   In most cases, this could and probably should be written as

     system("cat /etc/termcap") == 0
     	or die "cat program failed!";

   Which will get the output quickly (as it is generated, instead of only
at the end) and also check the return value.

   system() also provides direct control over whether shell wildcard
processing may take place, whereas backticks do not.

How can I call backticks without shell processing?
--------------------------------------------------

   This is a bit tricky.  Instead of writing

     @ok = `grep @opts '$search_string' @filenames`;

   You have to do this:

     my @ok = ();
     if (open(GREP, "-|")) {
         while (<GREP>) {
     	    chomp;
             push(@ok, $_);
         }
     	close GREP;
     } else {
         exec 'grep', @opts, $search_string, @filenames;
     }

   Just as with system(), no shell escapes happen when you exec() a list.
Further examples of this can be found in `"Safe Pipe Opens"', *Note
Perlipc: perlipc,.

   Note that if you're stuck on Microsoft, no solution to this vexing issue
is even possible.  Even if Perl were to emulate fork(), you'd still be
hosed, because Microsoft gives no argc/argv-style API.  Their API always
reparses from a single string, which is fundamentally wrong, but you're
not likely to get the Gods of Redmond to acknowledge this and fix it for
you.

Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?
-----------------------------------------------------------------------------------

   Because some stdio's set error and eof flags that need clearing.  The
POSIX module defines clearerr() that you can use.  That is the technically
correct way to do it.  Here are some less reliable workarounds:

  1. Try keeping around the seekpointer and go there, like this:

          $where = tell(LOG);
          seek(LOG, $where, 0);

  2. If that doesn't work, try seeking to a different part of the file and
     then back.

  3. If that doesn't work, try seeking to a different part of the file,
     reading something, and then seeking back.

  4. If that doesn't work, give up on your stdio package and use sysread.


How can I convert my shell script to perl?
------------------------------------------

   Learn Perl and rewrite it.  Seriously, there's no simple converter.
Things that are awkward to do in the shell are easy to do in Perl, and
this very awkwardness is what would make a shell->perl converter nigh-on
impossible to write.  By rewriting it, you'll think about what you're
really trying to do, and hopefully will escape the shell's pipeline
datastream paradigm, which while convenient for some matters, causes many
inefficiencies.

Can I use perl to run a telnet or ftp session?
----------------------------------------------

   Try the Net::FTP, TCP::Client, and Net::Telnet modules (available from
CPAN).  http://www.perl.com/CPAN/scripts/netstuff/telnet.emul.shar will
also help for emulating the telnet protocol, but Net::Telnet is quite
probably easier to use..

   If all you want to do is pretend to be telnet but don't need the
initial telnet handshaking, then the standard dual-process approach will
suffice:

     use IO::Socket; 	    	# new in 5.004
     $handle = IO::Socket::INET->new('www.perl.com:80')
     	    || die "can't connect to port 80 on www.perl.com: $!";
     $handle->autoflush(1);
     if (fork()) { 	    	# XXX: undef means failure
     	select($handle);
     	print while <STDIN>;    # everything from stdin to socket
     } else {
     	print while <$handle>;  # everything from socket to stdout
     }
     close $handle;
     exit;

How can I write expect in Perl?
-------------------------------

   Once upon a time, there was a library called chat2.pl (part of the
standard perl distribution), which never really got finished.  If you find
it somewhere, *don't use it*.  These days, your best bet is to look at the
Expect module available from CPAN, which also requires two other modules
from CPAN, IO::Pty and IO::Stty.

Is there a way to hide perl's command line from programs such as "ps"?
----------------------------------------------------------------------

   First of all note that if you're doing this for security reasons (to
avoid people seeing passwords, for example) then you should rewrite your
program so that critical information is never given as an argument.
Hiding the arguments won't make your program completely secure.

   To actually alter the visible command line, you can assign to the
variable $0 as documented in *Note Perlvar: perlvar,.  This won't work on
all operating systems, though.  Daemon programs like sendmail place their
state there, as in:

     $0 = "orcus [accepting connections]";

I {changed directory, modified my environment} in a perl script.  How come the change disappeared when I exited the script?  How do I get my changes to be visible?
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

Unix
     In the strictest sense, it can't be done - the script executes as a
     different process from the shell it was started from.  Changes to a
     process are not reflected in its parent, only in its own children
     created after the change.  There is shell magic that may allow you to
     fake it by eval()ing the script's output in your shell; check out the
     comp.unix.questions FAQ for details.

How do I close a process's filehandle without waiting for it to complete?
-------------------------------------------------------------------------

   Assuming your system supports such things, just send an appropriate
signal to the process (see `"kill"', *Note Perlfunc: perlfunc,.  It's
common to first send a TERM signal, wait a little bit, and then send a
KILL signal to finish it off.

How do I fork a daemon process?
-------------------------------

   If by daemon process you mean one that's detached (disassociated from
its tty), then the following process is reported to work on most Unixish
systems.  Non-Unix users should check their Your_OS::Process module for
other solutions.

   * Open /dev/tty and use the TIOCNOTTY ioctl on it.  See `tty(4)' in
     this node for details.  Or better yet, you can just use the
     POSIX::setsid() function, so you don't have to worry about process
     groups.

   * Change directory to /

   * Reopen STDIN, STDOUT, and STDERR so they're not connected to the old
     tty.

   * Background yourself like this:

          fork && exit;

   The Proc::Daemon module, available from CPAN, provides a function to
perform these actions for you.

How do I make my program run with sh and csh?
---------------------------------------------

   See the `eg/nih' script (part of the perl source distribution).

How do I find out if I'm running interactively or not?
------------------------------------------------------

   Good question.  Sometimes `-t STDIN' and `-t STDOUT' can give clues,
sometimes not.

     if (-t STDIN && -t STDOUT) {
     	print "Now what? ";
     }

   On POSIX systems, you can test whether your own process group matches
the current process group of your controlling terminal as follows:

     use POSIX qw/getpgrp tcgetpgrp/;
     open(TTY, "/dev/tty") or die $!;
     $tpgrp = tcgetpgrp(fileno(*TTY));
     $pgrp = getpgrp();
     if ($tpgrp == $pgrp) {
         print "foreground\n";
     } else {
         print "background\n";
     }

How do I timeout a slow event?
------------------------------

   Use the alarm() function, probably in conjunction with a signal
handler, as documented in `"Signals"', *Note Perlipc: perlipc, and chapter
6 of the Camel.  You may instead use the more flexible Sys::AlarmCall
module available from CPAN.

How do I set CPU limits?
------------------------

   Use the BSD::Resource module from CPAN.

How do I avoid zombies on a Unix system?
----------------------------------------

   Use the reaper code from `"Signals"', *Note Perlipc: perlipc, to call
wait() when a SIGCHLD is received, or else use the double-fork technique
described in `fork', *Note Perlfunc: perlfunc,.

How do I use an SQL database?
-----------------------------

   There are a number of excellent interfaces to SQL databases.  See the
DBD::* modules available from http://www.perl.com/CPAN/modules/DBD .  A
lot of information on this can be found at
http://www.symbolstone.org/technology/perl/DBI/

How do I make a system() exit on control-C?
-------------------------------------------

   You can't.  You need to imitate the system() call (see *Note Perlipc:
perlipc, for sample code) and then have a signal handler for the INT
signal that passes the signal on to the subprocess.  Or you can check for
it:

     $rc = system($cmd);
     if ($rc & 127) { die "signal death" }

How do I open a file without blocking?
--------------------------------------

   If you're lucky enough to be using a system that supports non-blocking
reads (most Unixish systems do), you need only to use the O_NDELAY or
O_NONBLOCK flag from the Fcntl module in conjunction with sysopen():

     use Fcntl;
     sysopen(FH, "/tmp/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
         or die "can't open /tmp/somefile: $!":

How do I install a module from CPAN?
------------------------------------

   The easiest way is to have a module also named CPAN do it for you.
This module comes with perl version 5.004 and later.  To manually install
the CPAN module, or any well-behaved CPAN module for that matter, follow
these steps:

  1. Unpack the source into a temporary area.

  2.      perl Makefile.PL

  3.      make

  4.      make test

  5.      make install

        If your version of perl is compiled without dynamic loading, then
you just need to replace step 3 (make) with *make perl* and you will get a
new `perl' binary with your extension linked in.

   See *Note ExtUtils/MakeMaker: (pm.info)ExtUtils/MakeMaker, for more
details on building extensions.  See also the next question.

What's the difference between require and use?
----------------------------------------------

   Perl offers several different ways to include code from one file into
another.  Here are the deltas between the various inclusion constructs:

     1)  do $file is like eval `cat $file`, except the former:
     	1.1: searches @INC and updates %INC.
     	1.2: bequeaths an *unrelated* lexical scope on the eval'ed code.

     2)  require $file is like do $file, except the former:
     	2.1: checks for redundant loading, skipping already loaded files.
     	2.2: raises an exception on failure to find, compile, or execute $file.

     3)  require Module is like require "Module.pm", except the former:
     	3.1: translates each "::" into your system's directory separator.
     	3.2: primes the parser to disambiguate class Module as an indirect object.

     4)  use Module is like require Module, except the former:
     	4.1: loads the module at compile time, not run-time.
     	4.2: imports symbols and semantics from that package to the current one.

   In general, you usually want use and a proper Perl module.

How do I keep my own module/library directory?
----------------------------------------------

   When you build modules, use the PREFIX option when generating Makefiles:

     perl Makefile.PL PREFIX=/u/mydir/perl

   then either set the PERL5LIB environment variable before you run
scripts that use the modules/libraries (see *Note Perlrun: perlrun,) or say

     use lib '/u/mydir/perl';

   This is almost the same as:

     BEGIN {
     	unshift(@INC, '/u/mydir/perl');
     }

   except that the lib module checks for machine-dependent subdirectories.
See Perl's *Note Lib: (pm.info)lib, for more information.

How do I add the directory my program lives in to the module/library search path?
---------------------------------------------------------------------------------

     use FindBin;
     use lib "$FindBin::Bin";
     use your_own_modules;

How do I add a directory to my include path at runtime?
-------------------------------------------------------

   Here are the suggested ways of modifying your include path:

     the PERLLIB environment variable
     the PERL5LIB environment variable
     the perl -Idir command line flag
     the use lib pragma, as in
         use lib "$ENV{HOME}/myown_perllib";

   The latter is particularly useful because it knows about machine
dependent architectures.  The lib.pm pragmatic module was first included
with the 5.002 release of Perl.

What is socket.ph and where do I get it?
----------------------------------------

   It's a perl4-style file defining values for system networking
constants.  Sometimes it is built using h2ph when Perl is installed, but
other times it is not.  Modern programs `use Socket;' instead.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.


File: perl.info,  Node: perlfaq9,  Next: Top,  Prev: Top,  Up: Top

Networking ($Revision: 1.26 $, $Date: 1999/05/23 16:08:30 $)
************************************************************

NAME
====

   perlfaq9 - Networking ($Revision: 1.26 $, $Date: 1999/05/23 16:08:30 $)

DESCRIPTION
===========

   This section deals with questions related to networking, the internet,
and a few on the web.

My CGI script runs from the command line but not the browser.   (500 Server Error)
----------------------------------------------------------------------------------

   If you can demonstrate that you've read the following FAQs and that
your problem isn't something simple that can be easily answered, you'll
probably receive a courteous and useful reply to your question if you post
it on comp.infosystems.www.authoring.cgi (if it's something to do with
HTTP, HTML, or the CGI protocols).  Questions that appear to be Perl
questions but are really CGI ones that are posted to comp.lang.perl.misc
may not be so well received.

   The useful FAQs and related documents are:

     CGI FAQ
         http://www.webthing.com/tutorials/cgifaq.html

     Web FAQ
         http://www.boutell.com/faq/

     WWW Security FAQ
         http://www.w3.org/Security/Faq/

     HTTP Spec
         http://www.w3.org/pub/WWW/Protocols/HTTP/

     HTML Spec
         http://www.w3.org/TR/REC-html40/
         http://www.w3.org/pub/WWW/MarkUp/

     CGI Spec
         http://www.w3.org/CGI/

     CGI Security FAQ
         http://www.go2net.com/people/paulp/cgi-security/safe-cgi.txt

How can I get better error messages from a CGI program?
-------------------------------------------------------

   Use the CGI::Carp module.  It replaces warn and die, plus the normal
Carp modules carp, croak, and `confess' functions with more verbose and
safer versions.  It still sends them to the normal server error log.

     use CGI::Carp;
     warn "This is a complaint";
     die "But this one is serious";

   The following use of CGI::Carp also redirects errors to a file of your
choice, placed in a BEGIN block to catch compile-time warnings as well:

     BEGIN {
         use CGI::Carp qw(carpout);
         open(LOG, ">>/var/local/cgi-logs/mycgi-log")
             or die "Unable to append to mycgi-log: $!\n";
         carpout(*LOG);
     }

   You can even arrange for fatal errors to go back to the client browser,
which is nice for your own debugging, but might confuse the end user.

     use CGI::Carp qw(fatalsToBrowser);
     die "Bad error here";

   Even if the error happens before you get the HTTP header out, the module
will try to take care of this to avoid the dreaded server 500 errors.
Normal warnings still go out to the server error log (or wherever you've
sent them with `carpout') with the application name and date stamp
prepended.

How do I remove HTML from a string?
-----------------------------------

   The most correct way (albeit not the fastest) is to use HTML::Parser
from CPAN.  Another mostly correct way is to use HTML::FormatText which
not only removes HTML but also attempts to do a little simple formatting
of the resulting plain text.

   Many folks attempt a simple-minded regular expression approach, like `<
s/<.*?'//g >>, but that fails in many cases because the tags may continue
over line breaks, they may contain quoted angle-brackets, or HTML comment
may be present.  Plus folks forget to convert entities, like `&lt;' for
example.

   Here's one "simple-minded" approach, that works for most files:

     #!/usr/bin/perl -p0777
     s/<(?:[^>'"]*|(['"]).*?\1)*>//gs

   If you want a more complete solution, see the 3-stage striphtml program
in http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/striphtml.gz .

   Here are some tricky cases that you should think about when picking a
solution:

     <IMG SRC = "foo.gif" ALT = "A > B">

     <IMG SRC = "foo.gif"
     	 ALT = "A > B">

     <!-- <A comment> -->

     <script>if (a<b && a>c)</script>

     <# Just data #>

     <![INCLUDE CDATA [ >>>>>>>>>>>> ]]>

   If HTML comments include other tags, those solutions would also break
on text like this:

     <!-- This section commented out.
         <B>You can't see me!</B>
     -->

How do I extract URLs?
----------------------

   A quick but imperfect approach is

     #!/usr/bin/perl -n00
     # qxurl - tchrist@perl.com
     print "$2\n" while m{
     	< \s*
     	  A \s+ HREF \s* = \s* (["']) (.*?) \1
     	\s* >
     }gsix;

   This version does not adjust relative URLs, understand alternate bases,
deal with HTML comments, deal with HREF and NAME attributes in the same
tag, understand extra qualifiers like TARGET, or accept URLs themselves as
arguments.  It also runs about 100x faster than a more "complete" solution
using the LWP suite of modules, such as the
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/xurl.gz program.

How do I download a file from the user's machine?  How do I open a file on another machine?
-------------------------------------------------------------------------------------------

   In the context of an HTML form, you can use what's known as
*multipart/form-data* encoding.  The CGI.pm module (available from CPAN)
supports this in the start_multipart_form() method, which isn't the same
as the startform() method.

How do I make a pop-up menu in HTML?
------------------------------------

   Use the *< <SELECT* >> and *< <OPTION* >> tags.  The CGI.pm module
(available from CPAN) supports this widget, as well as many others,
including some that it cleverly synthesizes on its own.

How do I fetch an HTML file?
----------------------------

   One approach, if you have the lynx text-based HTML browser installed on
your system, is this:

     $html_code = `lynx -source $url`;
     $text_data = `lynx -dump $url`;

   The libwww-perl (LWP) modules from CPAN provide a more powerful way to
do this.  They don't require lynx, but like lynx, can still work through
proxies:

     # simplest version
     use LWP::Simple;
     $content = get($URL);

     # or print HTML from a URL
     use LWP::Simple;
     getprint "http://www.linpro.no/lwp/";

     # or print ASCII from HTML from a URL
     # also need HTML-Tree package from CPAN
     use LWP::Simple;
     use HTML::Parser;
     use HTML::FormatText;
     my ($html, $ascii);
     $html = get("http://www.perl.com/");
     defined $html
         or die "Can't fetch HTML from http://www.perl.com/";
     $ascii = HTML::FormatText->new->format(parse_html($html));
     print $ascii;

How do I automate an HTML form submission?
------------------------------------------

   If you're submitting values using the GET method, create a URL and
encode the form using the `query_form' method:

     use LWP::Simple;
     use URI::URL;

     my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
     $url->query_form(module => 'DB_File', readme => 1);
     $content = get($url);

   If you're using the POST method, create your own user agent and encode
the content appropriately.

     use HTTP::Request::Common qw(POST);
     use LWP::UserAgent;

     $ua = LWP::UserAgent->new();
     my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
                    [ module => 'DB_File', readme => 1 ];
     $content = $ua->request($req)->as_string;

How do I decode or create those %-encodings on the web?
-------------------------------------------------------

   Here's an example of decoding:

     $string = "http://altavista.digital.com/cgi-bin/query?pg=q&what=news&fmt=.&q=%2Bcgi-bin+%2Bperl.exe";
     $string =~ s/%([a-fA-F0-9]{2})/chr(hex($1))/ge;

   Encoding is a bit harder, because you can't just blindly change all the
non-alphanumunder character (`\W') into their hex escapes.  It's important
that characters with special meaning like / and ?  not be translated.
Probably the easiest way to get this right is to avoid reinventing the
wheel and just use the URI::Escape module, available from CPAN.

How do I redirect to another page?
----------------------------------

   Instead of sending back a `Content-Type' as the headers of your reply,
send back a `Location:' header.  Officially this should be a `URI:'
header, so the CGI.pm module (available from CPAN) sends back both:

     Location: http://www.domain.com/newpage
     URI: http://www.domain.com/newpage

   Note that relative URLs in these headers can cause strange effects
because of "optimizations" that servers do.

     $url = "http://www.perl.com/CPAN/";
     print "Location: $url\n\n";
     exit;

   To target a particular frame in a frameset, include the "Window-target:"
in the header.

     print <<EOF;
     Location: http://www.domain.com/newpage
     Window-target: <FrameName>

     EOF

   To be correct to the spec, each of those virtual newlines should really
be physical `"\015\012"' sequences by the time you hit the client browser.
Except for NPH scripts, though, that local newline should get translated
by your server into standard form, so you shouldn't have a problem here,
even if you are stuck on MacOS.  Everybody else probably won't even notice.

How do I put a password on my web pages?
----------------------------------------

   That depends.  You'll need to read the documentation for your web
server, or perhaps check some of the other FAQs referenced above.

How do I edit my .htpasswd and .htgroup files with Perl?
--------------------------------------------------------

   The HTTPD::UserAdmin and HTTPD::GroupAdmin modules provide a consistent
OO interface to these files, regardless of how they're stored.  Databases
may be text, dbm, Berkley DB or any database with a DBI compatible driver.
HTTPD::UserAdmin supports files used by the `Basic' and `Digest'
authentication schemes.  Here's an example:

     use HTTPD::UserAdmin ();
     HTTPD::UserAdmin
     	  ->new(DB => "/foo/.htpasswd")
     	  ->add($username => $password);

How do I make sure users can't enter values into a form that cause my CGI script to do bad things?
--------------------------------------------------------------------------------------------------

   Read the CGI security FAQ, at
http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html, and the
Perl/CGI FAQ at http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html.

   In brief: use tainting (see *Note Perlsec: perlsec,), which makes sure
that data from outside your script (eg, CGI parameters) are never used in
eval or system calls.  In addition to tainting, never use the
single-argument form of system() or exec().  Instead, supply the command
and arguments as a list, which prevents shell globbing.

How do I parse a mail header?
-----------------------------

   For a quick-and-dirty solution, try this solution derived from page 222
of the 2nd edition of "Programming Perl":

     $/ = '';
     $header = <MSG>;
     $header =~ s/\n\s+/ /g;	 # merge continuation lines
     %head = ( UNIX_FROM_LINE, split /^([-\w]+):\s*/m, $header );

   That solution doesn't do well if, for example, you're trying to
maintain all the Received lines.  A more complete approach is to use the
Mail::Header module from CPAN (part of the MailTools package).

How do I decode a CGI form?
---------------------------

   You use a standard module, probably CGI.pm.  Under no circumstances
should you attempt to do so by hand!

   You'll see a lot of CGI programs that blindly read from STDIN the number
of bytes equal to CONTENT_LENGTH for POSTs, or grab QUERY_STRING for
decoding GETs.  These programs are very poorly written.  They only work
sometimes.  They typically forget to check the return value of the read()
system call, which is a cardinal sin.  They don't handle HEAD requests.
They don't handle multipart forms used for file uploads.  They don't deal
with GET/POST combinations where query fields are in more than one place.
They don't deal with keywords in the query string.

   In short, they're bad hacks.  Resist them at all costs.  Please do not
be tempted to reinvent the wheel.  Instead, use the CGI.pm or CGI_Lite.pm
(available from CPAN), or if you're trapped in the module-free land of
perl1 .. perl4, you might look into cgi-lib.pl (available from
http://cgi-lib.stanford.edu/cgi-lib/ ).

   Make sure you know whether to use a GET or a POST in your form.  GETs
should only be used for something that doesn't update the server.
Otherwise you can get mangled databases and repeated feedback mail
messages.  The fancy word for this is "idempotency".  This simply means
that there should be no difference between making a GET request for a
particular URL once or multiple times.  This is because the HTTP protocol
definition says that a GET request may be cached by the browser, or
server, or an intervening proxy.  POST requests cannot be cached, because
each request is independent and matters.  Typically, POST requests change
or depend on state on the server (query or update a database, send mail,
or purchase a computer).

How do I check a valid mail address?
------------------------------------

   You can't, at least, not in real time.  Bummer, eh?

   Without sending mail to the address and seeing whether there's a human
on the other hand to answer you, you cannot determine whether a mail
address is valid.  Even if you apply the mail header standard, you can
have problems, because there are deliverable addresses that aren't RFC-822
(the mail header standard) compliant, and addresses that aren't
deliverable which are compliant.

   Many are tempted to try to eliminate many frequently-invalid mail
addresses with a simple regex, such as `/^[\w.-]+\@([\w.-]\.)+\w+$/'.
It's a very bad idea.  However, this also throws out many valid ones, and
says nothing about potential deliverability, so is not suggested.
Instead, see
http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/ckaddr.gz ,
which actually checks against the full RFC spec (except for nested
comments), looks for addresses you may not wish to accept mail to (say,
Bill Clinton or your postmaster), and then makes sure that the hostname
given can be looked up in the DNS MX records.  It's not fast, but it works
for what it tries to do.

   Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a password.
This usually weeds out typos.  If both versions match, send mail to that
address with a personal message that looks somewhat like:

     Dear someuser@host.com,

     Please confirm the mail address you gave us Wed May  6 09:38:41
     MDT 1998 by replying to this message.  Include the string
     "Rumpelstiltskin" in that reply, but spelled in reverse; that is,
     start with "Nik...".  Once this is done, your confirmed address will
     be entered into our records.

   If you get the message back and they've followed your directions, you
can be reasonably assured that it's real.

   A related strategy that's less open to forgery is to give them a PIN
(personal ID number).  Record the address and PIN (best that it be a
random one) for later processing.  In the mail you send, ask them to
include the PIN in their reply.  But if it bounces, or the message is
included via a "vacation" script, it'll be there anyway.  So it's best to
ask them to mail back a slight alteration of the PIN, such as with the
characters reversed, one added or subtracted to each digit, etc.

How do I decode a MIME/BASE64 string?
-------------------------------------

   The MIME-tools package (available from CPAN) handles this and a lot
more.  Decoding BASE64 becomes as simple as:

     use MIME::base64;
     $decoded = decode_base64($encoded);

   A more direct approach is to use the unpack() function's "u" format
after minor transliterations:

     tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
     tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
     $len = pack("c", 32 + 0.75*length);   # compute length byte
     print unpack("u", $len . $_);         # uudecode and print

How do I return the user's mail address?
----------------------------------------

   On systems that support getpwuid, the $< variable and the Sys::Hostname
module (which is part of the standard perl distribution), you can probably
try using something like this:

     use Sys::Hostname;
     $address = sprintf('%s@%s', scalar getpwuid($<), hostname);

   Company policies on mail address can mean that this generates addresses
that the company's mail system will not accept, so you should ask for
users' mail addresses when this matters.  Furthermore, not all systems on
which Perl runs are so forthcoming with this information as is Unix.

   The Mail::Util module from CPAN (part of the MailTools package)
provides a mailaddress() function that tries to guess the mail address of
the user.  It makes a more intelligent guess than the code above, using
information given when the module was installed, but it could still be
incorrect.  Again, the best way is often just to ask the user.

How do I send mail?
-------------------

   Use the sendmail program directly:

     open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
                         or die "Can't fork for sendmail: $!\n";
     print SENDMAIL <<"EOF";
     From: User Originating Mail <me\@host>
     To: Final Destination <you\@otherhost>
     Subject: A relevant subject line

     Body of the message goes here after the blank line
     in as many lines as you like.
     EOF
     close(SENDMAIL)     or warn "sendmail didn't close nicely";

   The *-oi* option prevents sendmail from interpreting a line consisting
of a single dot as "end of message".  The -t option says to use the
headers to decide who to send the message to, and *-odq* says to put the
message into the queue.  This last option means your message won't be
immediately delivered, so leave it out if you want immediate delivery.

   Alternate, less convenient approaches include calling mail (sometimes
called mailx) directly or simply opening up port 25 have having an
intimate conversation between just you and the remote SMTP daemon,
probably sendmail.

   Or you might be able use the CPAN module Mail::Mailer:

     use Mail::Mailer;

     $mailer = Mail::Mailer->new();
     $mailer->open({ From    => $from_address,
                     To      => $to_address,
                     Subject => $subject,
                   })
         or die "Can't open: $!\n";
     print $mailer $body;
     $mailer->close();

   The Mail::Internet module uses Net::SMTP which is less Unix-centric than
Mail::Mailer, but less reliable.  Avoid raw SMTP commands.  There are many
reasons to use a mail transport agent like sendmail.  These include
queueing, MX records, and security.

How do I read mail?
-------------------

   While you could use the Mail::Folder module from CPAN (part of the
MailFolder package) or the Mail::Internet module from CPAN (also part of
the MailTools package), often a module is overkill, though.  Here's a mail
sorter.

     #!/usr/bin/perl
     # bysub1 - simple sort by subject
     my(@msgs, @sub);
     my $msgno = -1;
     $/ = '';                    # paragraph reads
     while (<>) {
         if (/^From/m) {
             /^Subject:\s*(?:Re:\s*)*(.*)/mi;
             $sub[++$msgno] = lc($1) || '';
         }
         $msgs[$msgno] .= $_;
     }
     for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
         print $msgs[$i];
     }

   Or more succinctly,

     #!/usr/bin/perl -n00
     # bysub2 - awkish sort-by-subject
     BEGIN { $msgno = -1 }
     $sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
     $msg[$msgno] .= $_;
     END { print @msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }

How do I find out my hostname/domainname/IP address?
----------------------------------------------------

   The normal way to find your own hostname is to call the ``hostname`'
program.  While sometimes expedient, this has some problems, such as not
knowing whether you've got the canonical name or not.  It's one of those
tradeoffs of convenience versus portability.

   The Sys::Hostname module (part of the standard perl distribution) will
give you the hostname after which you can find out the IP address
(assuming you have working DNS) with a gethostbyname() call.

     use Socket;
     use Sys::Hostname;
     my $host = hostname();
     my $addr = inet_ntoa(scalar gethostbyname($host || 'localhost'));

   Probably the simplest way to learn your DNS domain name is to grok it
out of /etc/resolv.conf, at least under Unix.  Of course, this assumes
several things about your resolv.conf configuration, including that it
exists.

   (We still need a good DNS domain name-learning method for non-Unix
systems.)

How do I fetch a news article or the active newsgroups?
-------------------------------------------------------

   Use the Net::NNTP or News::NNTPClient modules, both available from CPAN.
This can make tasks like fetching the newsgroup list as simple as:

     perl -MNews::NNTPClient
       -e 'print News::NNTPClient->new->list("newsgroups")'

How do I fetch/put an FTP file?
-------------------------------

   LWP::Simple (available from CPAN) can fetch but not put.  Net::FTP (also
available from CPAN) is more complex but can put as well as fetch.

How can I do RPC in Perl?
-------------------------

   A DCE::RPC module is being developed (but is not yet available), and
will be released as part of the DCE-Perl package (available from CPAN).
The rpcgen suite, available from CPAN/authors/id/JAKE/, is an RPC stub
generator and includes an RPC::ONC module.

AUTHOR AND COPYRIGHT
====================

   Copyright (c) 1997-1999 Tom Christiansen and Nathan Torkington.  All
rights reserved.

   When included as part of the Standard Version of Perl, or as part of
its complete documentation whether printed or otherwise, this work may be
distributed only under the terms of Perl's Artistic License.  Any
distribution of this file or derivatives thereof *outside* of that package
require that special arrangements be made with copyright holder.

   Irrespective of its distribution, all code examples in this file are
hereby placed into the public domain.  You are permitted and encouraged to
use this code in your own programs for fun or for profit as you see fit.
A simple comment in the code giving credit would be courteous but is not
required.


File: perl.info,  Node: perlfilter,  Next: perldbmfilter,  Prev: perllexwarn,  Up: Top

Source Filters
**************

NAME
====

   perlfilter - Source Filters

DESCRIPTION
===========

   This article is about a little-known feature of Perl called *source
filters*. Source filters alter the program text of a module before Perl
sees it, much as a C preprocessor alters the source text of a C program
before the compiler sees it. This article tells you more about what source
filters are, how they work, and how to write your own.

   The original purpose of source filters was to let you encrypt your
program source to prevent casual piracy. This isn't all they can do, as
you'll soon learn. But first, the basics.

CONCEPTS
========

   Before the Perl interpreter can execute a Perl script, it must first
read it from a file into memory for parsing and compilation. If that
script itself includes other scripts with a use or require statement, then
each of those scripts will have to be read from their respective files as
well.

   Now think of each logical connection between the Perl parser and an
individual file as a *source stream*. A source stream is created when the
Perl parser opens a file, it continues to exist as the source code is read
into memory, and it is destroyed when Perl is finished parsing the file.
If the parser encounters a require or use statement in a source stream, a
new and distinct stream is created just for that file.

   The diagram below represents a single source stream, with the flow of
source from a Perl script file on the left into the Perl parser on the
right. This is how Perl normally operates.

     file -------> parser

   There are two important points to remember:

  1. Although there can be any number of source streams in existence at any
     given time, only one will be active.

  2. Every source stream is associated with only one file.

        A source filter is a special kind of Perl module that intercepts
and modifies a source stream before it reaches the parser. A source filter
changes our diagram like this:

     file ----> filter ----> parser

   If that doesn't make much sense, consider the analogy of a command
pipeline. Say you have a shell script stored in the compressed file
*trial.gz*. The simple pipeline command below runs the script without
needing to create a temporary file to hold the uncompressed file.

     gunzip -c trial.gz | sh

   In this case, the data flow from the pipeline can be represented as
follows:

     trial.gz ----> gunzip ----> sh

   With source filters, you can store the text of your script compressed
and use a source filter to uncompress it for Perl's parser:

     compressed           gunzip
         Perl program ---> source filter ---> parser

USING FILTERS
=============

   So how do you use a source filter in a Perl script? Above, I said that
a source filter is just a special kind of module. Like all Perl modules, a
source filter is invoked with a use statement.

   Say you want to pass your Perl source through the C preprocessor before
execution. You could use the existing -P command line option to do this,
but as it happens, the source filters distribution comes with a C
preprocessor filter module called Filter::cpp. Let's use that instead.

   Below is an example program, `cpp_test', which makes use of this filter.
Line numbers have been added to allow specific lines to be referenced
easily.

     1: use Filter::cpp ;
     2: #define TRUE 1
     3: $a = TRUE ;
     4: print "a = $a\n" ;

   When you execute this script, Perl creates a source stream for the
file. Before the parser processes any of the lines from the file, the
source stream looks like this:

     cpp_test ---------> parser

   Line 1, `use Filter::cpp', includes and installs the `cpp' filter
module. All source filters work this way. The use statement is compiled
and executed at compile time, before any more of the file is read, and it
attaches the cpp filter to the source stream behind the scenes. Now the
data flow looks like this:

     cpp_test ----> cpp filter ----> parser

   As the parser reads the second and subsequent lines from the source
stream, it feeds those lines through the `cpp' source filter before
processing them. The `cpp' filter simply passes each line through the real
C preprocessor. The output from the C preprocessor is then inserted back
into the source stream by the filter.

     .-> cpp --.
     |         |
     |         |
     |       <-'
        cpp_test ----> cpp filter ----> parser

   The parser then sees the following code:

     use Filter::cpp ;
     $a = 1 ;
     print "a = $a\n" ;

   Let's consider what happens when the filtered code includes another
module with use:

     1: use Filter::cpp ;
     2: #define TRUE 1
     3: use Fred ;
     4: $a = TRUE ;
     5: print "a = $a\n" ;

   The `cpp' filter does not apply to the text of the Fred module, only to
the text of the file that used it (`cpp_test'). Although the use statement
on line 3 will pass through the cpp filter, the module that gets included
(`Fred') will not. The source streams look like this after line 3 has been
parsed and before line 4 is parsed:

     cpp_test ---> cpp filter ---> parser (INACTIVE)

     Fred.pm ----> parser

   As you can see, a new stream has been created for reading the source
from `Fred.pm'. This stream will remain active until all of `Fred.pm' has
been parsed. The source stream for `cpp_test' will still exist, but is
inactive. Once the parser has finished reading Fred.pm, the source stream
associated with it will be destroyed. The source stream for `cpp_test'
then becomes active again and the parser reads line 4 and subsequent lines
from `cpp_test'.

   You can use more than one source filter on a single file. Similarly,
you can reuse the same filter in as many files as you like.

   For example, if you have a uuencoded and compressed source file, it is
possible to stack a uudecode filter and an uncompression filter like this:

     use Filter::uudecode ; use Filter::uncompress ;
     M'XL(".H<US4''V9I;F%L')Q;>7/;1I;_>_I3=&E=%:F*I"T?22Q/
     M6]9*<IQCO*XFT"0[PL%%'Y+IG?WN^ZYN-$'J.[.JE$,20/?K=_[>
     ...

   Once the first line has been processed, the flow will look like this:

     file ---> uudecode ---> uncompress ---> parser
                filter         filter

   Data flows through filters in the same order they appear in the source
file. The uudecode filter appeared before the uncompress filter, so the
source file will be uudecoded before it's uncompressed.

WRITING A SOURCE FILTER
=======================

   There are three ways to write your own source filter. You can write it
in C, use an external program as a filter, or write the filter in Perl.  I
won't cover the first two in any great detail, so I'll get them out of the
way first. Writing the filter in Perl is most convenient, so I'll devote
the most space to it.

WRITING A SOURCE FILTER IN C
============================

   The first of the three available techniques is to write the filter
completely in C. The external module you create interfaces directly with
the source filter hooks provided by Perl.

   The advantage of this technique is that you have complete control over
the implementation of your filter. The big disadvantage is the increased
complexity required to write the filter - not only do you need to
understand the source filter hooks, but you also need a reasonable
knowledge of Perl guts. One of the few times it is worth going to this
trouble is when writing a source scrambler. The decrypt filter (which
unscrambles the source before Perl parses it) included with the source
filter distribution is an example of a C source filter (see Decryption
Filters, below).

*Decryption Filters*
     All decryption filters work on the principle of "security through
     obscurity." Regardless of how well you write a decryption filter and
     how strong your encryption algorithm, anyone determined enough can
     retrieve the original source code. The reason is quite simple - once
     the decryption filter has decrypted the source back to its original
     form, fragments of it will be stored in the computer's memory as Perl
     parses it. The source might only be in memory for a short period of
     time, but anyone possessing a debugger, skill, and lots of patience
     can eventually reconstruct your program.

     That said, there are a number of steps that can be taken to make life
     difficult for the potential cracker. The most important: Write your
     decryption filter in C and statically link the decryption module into
     the Perl binary. For further tips to make life difficult for the
     potential cracker, see the file *decrypt.pm* in the source filters
     module.

CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE
=================================================

   An alternative to writing the filter in C is to create a separate
executable in the language of your choice. The separate executable reads
from standard input, does whatever processing is necessary, and writes the
filtered data to standard output. `Filter:cpp' is an example of a source
filter implemented as a separate executable - the executable is the C
preprocessor bundled with your C compiler.

   The source filter distribution includes two modules that simplify this
task: `Filter::exec' and `Filter::sh'. Both allow you to run any external
executable. Both use a coprocess to control the flow of data into and out
of the external executable. (For details on coprocesses, see Stephens,
W.R. "Advanced Programming in the UNIX Environment."  Addison-Wesley, ISBN
0-210-56317-7, pages 441-445.) The difference between them is that
`Filter::exec' spawns the external command directly, while `Filter::sh'
spawns a shell to execute the external command. (Unix uses the Bourne
shell; NT uses the cmd shell.) Spawning a shell allows you to make use of
the shell metacharacters and redirection facilities.

   Here is an example script that uses `Filter::sh':

     use Filter::sh 'tr XYZ PQR' ;
     $a = 1 ;
     print "XYZ a = $a\n" ;

   The output you'll get when the script is executed:

     PQR a = 1

   Writing a source filter as a separate executable works fine, but a
small performance penalty is incurred. For example, if you execute the
small example above, a separate subprocess will be created to run the Unix
tr command. Each use of the filter requires its own subprocess.  If
creating subprocesses is expensive on your system, you might want to
consider one of the other options for creating source filters.

WRITING A SOURCE FILTER IN PERL
===============================

   The easiest and most portable option available for creating your own
source filter is to write it completely in Perl. To distinguish this from
the previous two techniques, I'll call it a Perl source filter.

   To help understand how to write a Perl source filter we need an example
to study. Here is a complete source filter that performs rot13 decoding.
(Rot13 is a very simple encryption scheme used in Usenet postings to hide
the contents of offensive posts. It moves every letter forward thirteen
places, so that A becomes N, B becomes O, and Z becomes M.)

     package Rot13 ;

     use Filter::Util::Call ;

     sub import {
        my ($type) = @_ ;
        my ($ref) = [] ;
        filter_add(bless $ref) ;
     }

     sub filter {
        my ($self) = @_ ;
        my ($status) ;

     tr/n-za-mN-ZA-M/a-zA-Z/
        if ($status = filter_read()) > 0 ;
     $status ;
        }

     1;

   All Perl source filters are implemented as Perl classes and have the
same basic structure as the example above.

   First, we include the `Filter::Util::Call' module, which exports a
number of functions into your filter's namespace. The filter shown above
uses two of these functions, `filter_add()' and `filter_read()'.

   Next, we create the filter object and associate it with the source
stream by defining the import function. If you know Perl well enough, you
know that import is called automatically every time a module is included
with a use statement. This makes import the ideal place to both create and
install a filter object.

   In the example filter, the object ($ref) is blessed just like any other
Perl object. Our example uses an anonymous array, but this isn't a
requirement. Because this example doesn't need to store any context
information, we could have used a scalar or hash reference just as well.
The next section demonstrates context data.

   The association between the filter object and the source stream is made
with the `filter_add()' function. This takes a filter object as a
parameter ($ref in this case) and installs it in the source stream.

   Finally, there is the code that actually does the filtering. For this
type of Perl source filter, all the filtering is done in a method called
`filter()'. (It is also possible to write a Perl source filter using a
closure. See the `Filter::Util::Call' manual page for more details.) It's
called every time the Perl parser needs another line of source to process.
The `filter()' method, in turn, reads lines from the source stream using
the `filter_read()' function.

   If a line was available from the source stream, `filter_read()' returns
a status value greater than zero and appends the line to $_.  A status
value of zero indicates end-of-file, less than zero means an error. The
filter function itself is expected to return its status in the same way,
and put the filtered line it wants written to the source stream in $_. The
use of $_ accounts for the brevity of most Perl source filters.

   In order to make use of the rot13 filter we need some way of encoding
the source file in rot13 format. The script below, `mkrot13', does just
that.

     die "usage mkrot13 filename\n" unless @ARGV ;
     my $in = $ARGV[0] ;
     my $out = "$in.tmp" ;
     open(IN, "<$in") or die "Cannot open file $in: $!\n";
     open(OUT, ">$out") or die "Cannot open file $out: $!\n";

     print OUT "use Rot13;\n" ;
     while (<IN>) {
        tr/a-zA-Z/n-za-mN-ZA-M/ ;
        print OUT ;
     }

     close IN;
     close OUT;
     unlink $in;
     rename $out, $in;

   If we encrypt this with `mkrot13':

     print " hello fred \n" ;

   the result will be this:

     use Rot13;
     cevag "uryyb serq\a" ;

   Running it produces this output:

     hello fred

USING CONTEXT: THE DEBUG FILTER
===============================

   The rot13 example was a trivial example. Here's another demonstration
that shows off a few more features.

   Say you wanted to include a lot of debugging code in your Perl script
during development, but you didn't want it available in the released
product. Source filters offer a solution. In order to keep the example
simple, let's say you wanted the debugging output to be controlled by an
environment variable, DEBUG. Debugging code is enabled if the variable
exists, otherwise it is disabled.

   Two special marker lines will bracket debugging code, like this:

     ## DEBUG_BEGIN
     if ($year > 1999) {
        warn "Debug: millennium bug in year $year\n" ;
     }
     ## DEBUG_END

   When the DEBUG environment variable exists, the filter ensures that
Perl parses only the code between the `DEBUG_BEGIN' and `DEBUG_END'
markers. That means that when DEBUG does exist, the code above should be
passed through the filter unchanged. The marker lines can also be passed
through as-is, because the Perl parser will see them as comment lines.
When DEBUG isn't set, we need a way to disable the debug code. A simple
way to achieve that is to convert the lines between the two markers into
comments:

     ## DEBUG_BEGIN
     #if ($year > 1999) {
     #     warn "Debug: millennium bug in year $year\n" ;
     #}
     ## DEBUG_END

   Here is the complete Debug filter:

     package Debug;

     use strict;
     use warnings;
     use Filter::Util::Call ;

     use constant TRUE => 1 ;
     use constant FALSE => 0 ;

     sub import {
        my ($type) = @_ ;
        my (%context) = (
          Enabled => defined $ENV{DEBUG},
          InTraceBlock => FALSE,
          Filename => (caller)[1],
          LineNo => 0,
          LastBegin => 0,
        ) ;
        filter_add(bless \%context) ;
     }

     sub Die {
        my ($self) = shift ;
        my ($message) = shift ;
        my ($line_no) = shift || $self->{LastBegin} ;
        die "$message at $self->{Filename} line $line_no.\n"
     }

     sub filter {
        my ($self) = @_ ;
        my ($status) ;
        $status = filter_read() ;
        ++ $self->{LineNo} ;

     # deal with EOF/error first
     if ($status <= 0) {
         $self->Die("DEBUG_BEGIN has no DEBUG_END")
             if $self->{InTraceBlock} ;
         return $status ;
     }

     if ($self->{InTraceBlock}) {
        if (/^\s*##\s*DEBUG_BEGIN/ ) {
            $self->Die("Nested DEBUG_BEGIN", $self->{LineNo})
        } elsif (/^\s*##\s*DEBUG_END/) {
            $self->{InTraceBlock} = FALSE ;
        }

     # comment out the debug lines when the filter is disabled
     s/^/#/ if ! $self->{Enabled} ;
            } elsif ( /^\s*##\s*DEBUG_BEGIN/ ) {
     $self->{InTraceBlock} = TRUE ;
     $self->{LastBegin} = $self->{LineNo} ;
            } elsif ( /^\s*##\s*DEBUG_END/ ) {
     $self->Die("DEBUG_END has no DEBUG_BEGIN", $self->{LineNo});
            }
            return $status ;
         }

     1 ;

   The big difference between this filter and the previous example is the
use of context data in the filter object. The filter object is based on a
hash reference, and is used to keep various pieces of context information
between calls to the filter function. All but two of the hash fields are
used for error reporting. The first of those two, Enabled, is used by the
filter to determine whether the debugging code should be given to the Perl
parser. The second, InTraceBlock, is true when the filter has encountered
a `DEBUG_BEGIN' line, but has not yet encountered the following
`DEBUG_END' line.

   If you ignore all the error checking that most of the code does, the
essence of the filter is as follows:

     sub filter {
        my ($self) = @_ ;
        my ($status) ;
        $status = filter_read() ;

     # deal with EOF/error first
     return $status if $status <= 0 ;
     if ($self->{InTraceBlock}) {
        if (/^\s*##\s*DEBUG_END/) {
           $self->{InTraceBlock} = FALSE
        }

     # comment out debug lines when the filter is disabled
     s/^/#/ if ! $self->{Enabled} ;
            } elsif ( /^\s*##\s*DEBUG_BEGIN/ ) {
     $self->{InTraceBlock} = TRUE ;
            }
            return $status ;
         }

   Be warned: just as the C-preprocessor doesn't know C, the Debug filter
doesn't know Perl. It can be fooled quite easily:

     print <<EOM;
     ##DEBUG_BEGIN
     EOM

   Such things aside, you can see that a lot can be achieved with a modest
amount of code.

CONCLUSION
==========

   You now have better understanding of what a source filter is, and you
might even have a possible use for them. If you feel like playing with
source filters but need a bit of inspiration, here are some extra features
you could add to the Debug filter.

   First, an easy one. Rather than having debugging code that is
all-or-nothing, it would be much more useful to be able to control which
specific blocks of debugging code get included. Try extending the syntax
for debug blocks to allow each to be identified. The contents of the DEBUG
environment variable can then be used to control which blocks get included.

   Once you can identify individual blocks, try allowing them to be
nested. That isn't difficult either.

   Here is a interesting idea that doesn't involve the Debug filter.
Currently Perl subroutines have fairly limited support for formal
parameter lists. You can specify the number of parameters and their type,
but you still have to manually take them out of the `@_' array yourself.
Write a source filter that allows you to have a named parameter list. Such
a filter would turn this:

     sub MySub ($first, $second, @rest) { ... }

   into this:

     sub MySub($$@) {
        my ($first) = shift ;
        my ($second) = shift ;
        my (@rest) = @_ ;
        ...
     }

   Finally, if you feel like a real challenge, have a go at writing a
full-blown Perl macro preprocessor as a source filter. Borrow the useful
features from the C preprocessor and any other macro processors you know.
The tricky bit will be choosing how much knowledge of Perl's syntax you
want your filter to have.

REQUIREMENTS
============

   The Source Filters distribution is available on CPAN, in

     CPAN/modules/by-module/Filter

AUTHOR
======

   Paul Marquess <Paul.Marquess@btinternet.com>

Copyrights
==========

   This article originally appeared in The Perl Journal #11, and is
copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The
Perl Journal.  This document may be distributed under the same terms as
Perl itself.


File: perl.info,  Node: perlfork,  Next: perlthrtut,  Prev: perlipc,  Up: Top

Perl's fork() emulation
***********************

NAME
====

   perlfork - Perl's fork() emulation

SYNOPSIS
========

   Perl provides a fork() keyword that corresponds to the Unix system call
of the same name.  On most Unix-like platforms where the fork() system
call is available, Perl's fork() simply calls it.

   On some platforms such as Windows where the fork() system call is not
available, Perl can be built to emulate fork() at the interpreter level.
While the emulation is designed to be as compatible as possible with the
real fork() at the the level of the Perl program, there are certain
important differences that stem from the fact that all the pseudo child
"processes" created this way live in the same real process as far as the
operating system is concerned.

   This document provides a general overview of the capabilities and
limitations of the fork() emulation.  Note that the issues discussed here
are not applicable to platforms where a real fork() is available and Perl
has been configured to use it.

DESCRIPTION
===========

   The fork() emulation is implemented at the level of the Perl
interpreter.  What this means in general is that running fork() will
actually clone the running interpreter and all its state, and run the
cloned interpreter in a separate thread, beginning execution in the new
thread just after the point where the fork() was called in the parent.  We
will refer to the thread that implements this child "process" as the
pseudo-process.

   To the Perl program that called fork(), all this is designed to be
transparent.  The parent returns from the fork() with a pseudo-process ID
that can be subsequently used in any process manipulation functions; the
child returns from the fork() with a value of 0 to signify that it is the
child pseudo-process.

Behavior of other Perl features in forked pseudo-processes
----------------------------------------------------------

   Most Perl features behave in a natural way within pseudo-processes.

$$ or $PROCESS_ID
     This special variable is correctly set to the pseudo-process ID.  It
     can be used to identify pseudo-processes within a particular session.
     Note that this value is subject to recycling if any pseudo-processes
     are launched after others have been wait()-ed on.

%ENV
     Each pseudo-process maintains its own virtual enviroment.
     Modifications to %ENV affect the virtual environment, and are only
     visible within that pseudo-process, and in any processes (or
     pseudo-processes) launched from it.

chdir() and all other builtins that accept filenames
     Each pseudo-process maintains its own virtual idea of the current
     directory.  Modifications to the current directory using chdir() are
     only visible within that pseudo-process, and in any processes (or
     pseudo-processes) launched from it.  All file and directory accesses
     from the pseudo-process will correctly map the virtual working
     directory to the real working directory appropriately.

wait() and waitpid()
     wait() and waitpid() can be passed a pseudo-process ID returned by
     fork().  These calls will properly wait for the termination of the
     pseudo-process and return its status.

kill()
     kill() can be used to terminate a pseudo-process by passing it the ID
     returned by fork().  This should not be used except under dire
     circumstances, because the operating system may not guarantee
     integrity of the process resources when a running thread is
     terminated.  Note that using kill() on a pseudo-process() may
     typically cause memory leaks, because the thread that implements the
     pseudo-process does not get a chance to clean up its resources.

exec()
     Calling exec() within a pseudo-process actually spawns the requested
     executable in a separate process and waits for it to complete before
     exiting with the same exit status as that process.  This means that
     the process ID reported within the running executable will be
     different from what the earlier Perl fork() might have returned.
     Similarly, any process manipulation functions applied to the ID
     returned by fork() will affect the waiting pseudo-process that called
     exec(), not the real process it is waiting for after the exec().

exit()
     exit() always exits just the executing pseudo-process, after
     automatically wait()-ing for any outstanding child pseudo-processes.
     Note that this means that the process as a whole will not exit unless
     all running pseudo-processes have exited.

Open handles to files, directories and network sockets
     All open handles are dup()-ed in pseudo-processes, so that closing
     any handles in one process does not affect the others.  See below for
     some limitations.

Resource limits
---------------

   In the eyes of the operating system, pseudo-processes created via the
fork() emulation are simply threads in the same process.  This means that
any process-level limits imposed by the operating system apply to all
pseudo-processes taken together.  This includes any limits imposed by the
operating system on the number of open file, directory and socket handles,
limits on disk space usage, limits on memory size, limits on CPU
utilization etc.

Killing the parent process
--------------------------

   If the parent process is killed (either using Perl's kill() builtin, or
using some external means) all the pseudo-processes are killed as well,
and the whole process exits.

Lifetime of the parent process and pseudo-processes
---------------------------------------------------

   During the normal course of events, the parent process and every
pseudo-process started by it will wait for their respective pseudo-children
to complete before they exit.  This means that the parent and every
pseudo-child created by it that is also a pseudo-parent will only exit
after their pseudo-children have exited.

   A way to mark a pseudo-processes as running detached from their parent
(so that the parent would not have to wait() for them if it doesn't want
to) will be provided in future.

CAVEATS AND LIMITATIONS
-----------------------

BEGIN blocks
     The fork() emulation will not work entirely correctly when called from
     within a BEGIN block.  The forked copy will run the contents of the
     BEGIN block, but will not continue parsing the source stream after the
     BEGIN block.  For example, consider the following code:

          BEGIN {
              fork and exit;		# fork child and exit the parent
          	print "inner\n";
          }
          print "outer\n";

     This will print:

          inner

     rather than the expected:

          inner
          outer

     This limitation arises from fundamental technical difficulties in
     cloning and restarting the stacks used by the Perl parser in the
     middle of a parse.

Open filehandles
     Any filehandles open at the time of the fork() will be dup()-ed.
     Thus, the files can be closed independently in the parent and child,
     but beware that the dup()-ed handles will still share the same seek
     pointer.  Changing the seek position in the parent will change it in
     the child and vice-versa.  One can avoid this by opening files that
     need distinct seek pointers separately in the child.

Forking pipe open() not yet implemented
     The `open(FOO, "|-")' and `open(BAR, "-|")' constructs are not yet
     implemented.  This limitation can be easily worked around in new code
     by creating a pipe explicitly.  The following example shows how to
     write to a forked child:

          # simulate open(FOO, "|-")
          sub pipe_to_fork ($) {
          	my $parent = shift;
          	pipe my $child, $parent or die;
          	my $pid = fork();
          	die "fork() failed: $!" unless defined $pid;
          	if ($pid) {
          	    close $child;
          	}
          	else {
          	    close $parent;
          	    open(STDIN, "<&=" . fileno($child)) or die;
          	}
          	$pid;
          }

          if (pipe_to_fork('FOO')) {
          	# parent
          	print FOO "pipe_to_fork\n";
          	close FOO;
          }
          else {
          	# child
          	while (<STDIN>) { print; }
          	close STDIN;
          	exit(0);
          }

     And this one reads from the child:

          # simulate open(FOO, "-|")
          sub pipe_from_fork ($) {
          	my $parent = shift;
          	pipe $parent, my $child or die;
          	my $pid = fork();
          	die "fork() failed: $!" unless defined $pid;
          	if ($pid) {
          	    close $child;
          	}
          	else {
          	    close $parent;
          	    open(STDOUT, ">&=" . fileno($child)) or die;
          	}
          	$pid;
          }

          if (pipe_from_fork('BAR')) {
          	# parent
          	while (<BAR>) { print; }
          	close BAR;
          }
          else {
          	# child
          	print "pipe_from_fork\n";
          	close STDOUT;
          	exit(0);
          }

     Forking pipe open() constructs will be supported in future.

Global state maintained by XSUBs
     External subroutines (XSUBs) that maintain their own global state may
     not work correctly.  Such XSUBs will either need to maintain locks to
     protect simultaneous access to global data from different
     pseudo-processes, or maintain all their state on the Perl symbol
     table, which is copied naturally when fork() is called.  A callback
     mechanism that provides extensions an opportunity to clone their
     state will be provided in the near future.

Interpreter embedded in larger application
     The fork() emulation may not behave as expected when it is executed
     in an application which embeds a Perl interpreter and calls Perl APIs
     that can evaluate bits of Perl code.  This stems from the fact that
     the emulation only has knowledge about the Perl interpreter's own
     data structures and knows nothing about the containing application's
     state.  For example, any state carried on the application's own call
     stack is out of reach.

Thread-safety of extensions
     Since the fork() emulation runs code in multiple threads, extensions
     calling into non-thread-safe libraries may not work reliably when
     calling fork().  As Perl's threading support gradually becomes more
     widely adopted even on platforms with a native fork(), such extensions
     are expected to be fixed for thread-safety.

BUGS
====

   * Having pseudo-process IDs be negative integers breaks down for the
     integer `-1' because the wait() and waitpid() functions treat this
     number as being special.  The tacit assumption in the current
     implementation is that the system never allocates a thread ID of 1
     for user threads.  A better representation for pseudo-process IDs
     will be implemented in future.

   * This document may be incomplete in some respects.

AUTHOR
======

   Support for concurrent interpreters and the fork() emulation was
implemented by ActiveState, with funding from Microsoft Corporation.

   This document is authored and maintained by Gurusamy Sarathy
<gsar@activestate.com>.

SEE ALSO
========

   `"fork"', *Note Perlfunc: perlfunc,, `"fork"', *Note Perlipc: perlipc,


File: perl.info,  Node: perlform,  Next: perlunicode,  Prev: perlmodinstall,  Up: Top

Perl formats
************

NAME
====

   perlform - Perl formats

DESCRIPTION
===========

   Perl has a mechanism to help you generate simple reports and charts.  To
facilitate this, Perl helps you code up your output page close to how it
will look when it's printed.  It can keep track of things like how many
lines are on a page, what page you're on, when to print page headers, etc.
Keywords are borrowed from FORTRAN: format() to declare and write() to
execute; see their entries in *Note Perlfunc: perlfunc,.  Fortunately, the
layout is much more legible, more like BASIC's PRINT USING statement.
Think of it as a poor man's nroff(1).

   Formats, like packages and subroutines, are declared rather than
executed, so they may occur at any point in your program.  (Usually it's
best to keep them all together though.) They have their own namespace
apart from all the other "types" in Perl.  This means that if you have a
function named "Foo", it is not the same thing as having a format named
"Foo".  However, the default name for the format associated with a given
filehandle is the same as the name of the filehandle.  Thus, the default
format for STDOUT is named "STDOUT", and the default format for filehandle
TEMP is named "TEMP".  They just look the same.  They aren't.

   Output record formats are declared as follows:

     format NAME =
     FORMLIST
     .

   If name is omitted, format "STDOUT" is defined.  FORMLIST consists of a
sequence of lines, each of which may be one of three types:

  1. A comment, indicated by putting a '#' in the first column.

  2. A "picture" line giving the format for one output line.

  3. An argument line supplying values to plug into the previous picture
     line.

        Picture lines are printed exactly as they look, except for certain
fields that substitute values into the line.  Each field in a picture line
starts with either "@" (at) or "^" (caret).  These lines do not undergo
any kind of variable interpolation.  The at field (not to be confused with
the array marker @) is the normal kind of field; the other kind, caret
fields, are used to do rudimentary multi-line text block filling.  The
length of the field is supplied by padding out the field with multiple
"<", ">", or "|" characters to specify, respectively, left justification,
right justification, or centering.  If the variable would exceed the width
specified, it is truncated.

   As an alternate form of right justification, you may also use "#"
characters (with an optional ".") to specify a numeric field.  This way
you can line up the decimal points.  If any value supplied for these
fields contains a newline, only the text up to the newline is printed.
Finally, the special field "@*" can be used for printing multi-line,
nontruncated values; it should appear by itself on a line.

   The values are specified on the following line in the same order as the
picture fields.  The expressions providing the values should be separated
by commas.  The expressions are all evaluated in a list context before the
line is processed, so a single list expression could produce multiple list
elements.  The expressions may be spread out to more than one line if
enclosed in braces.  If so, the opening brace must be the first token on
the first line.  If an expression evaluates to a number with a decimal
part, and if the corresponding picture specifies that the decimal part
should appear in the output (that is, any picture except multiple "#"
characters *without* an embedded "."), the character used for the decimal
point is always determined by the current LC_NUMERIC locale.  This means
that, if, for example, the run-time environment happens to specify a
German locale, "," will be used instead of the default ".".  See *Note
Perllocale: perllocale, and `"WARNINGS"' in this node for more information.

   Picture fields that begin with ^ rather than @ are treated specially.
With a # field, the field is blanked out if the value is undefined.  For
other field types, the caret enables a kind of fill mode.  Instead of an
arbitrary expression, the value supplied must be a scalar variable name
that contains a text string.  Perl puts as much text as it can into the
field, and then chops off the front of the string so that the next time
the variable is referenced, more of the text can be printed.  (Yes, this
means that the variable itself is altered during execution of the write()
call, and is not returned.)  Normally you would use a sequence of fields
in a vertical stack to print out a block of text.  You might wish to end
the final field with the text "...", which will appear in the output if
the text was too long to appear in its entirety.  You can change which
characters are legal to break on by changing the variable $: (that's
$FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a
list of the desired characters.

   Using caret fields can produce variable length records.  If the text to
be formatted is short, you can suppress blank lines by putting a "~"
(tilde) character anywhere in the line.  The tilde will be translated to a
space upon output.  If you put a second tilde contiguous to the first, the
line will be repeated until all the fields on the line are exhausted.  (If
you use a field of the at variety, the expression you supply had better
not give the same value every time forever!)

   Top-of-form processing is by default handled by a format with the same
name as the current filehandle with "_TOP" concatenated to it.  It's
triggered at the top of each page.  See `write', *Note Perlfunc: perlfunc,.

   Examples:

     # a report on the /etc/passwd file
     format STDOUT_TOP =
                             Passwd File
     Name                Login    Office   Uid   Gid Home
     ------------------------------------------------------------------
     .
     format STDOUT =
     @<<<<<<<<<<<<<<<<<< @||||||| @<<<<<<@>>>> @>>>> @<<<<<<<<<<<<<<<<<
     $name,              $login,  $office,$uid,$gid, $home
     .

     # a report from a bug report form
     format STDOUT_TOP =
                             Bug Reports
     @<<<<<<<<<<<<<<<<<<<<<<<     @|||         @>>>>>>>>>>>>>>>>>>>>>>>
     $system,                      $%,         $date
     ------------------------------------------------------------------
     .
     format STDOUT =
     Subject: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
              $subject
     Index: @<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            $index,                       $description
     Priority: @<<<<<<<<<< Date: @<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
               $priority,        $date,   $description
     From: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
           $from,                         $description
     Assigned to: @<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                  $programmer,            $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                          $description
     ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<...
                                          $description
     .

   It is possible to intermix print()s with write()s on the same output
channel, but you'll have to handle $- ($FORMAT_LINES_LEFT) yourself.

Format Variables
----------------

   The current format name is stored in the variable $~ ($FORMAT_NAME),
and the current top of form format name is in $^ ($FORMAT_TOP_NAME).  The
current output page number is stored in $% ($FORMAT_PAGE_NUMBER), and the
number of lines on the page is in $= ($FORMAT_LINES_PER_PAGE).  Whether to
autoflush output on this handle is stored in $| ($OUTPUT_AUTOFLUSH).  The
string output before each top of page (except the first) is stored in $^L
($FORMAT_FORMFEED).  These variables are set on a per-filehandle basis, so
you'll need to select() into a different one to affect them:

     select((select(OUTF),
     	    $~ = "My_Other_Format",
     	    $^ = "My_Top_Format"
     	   )[0]);

   Pretty ugly, eh?  It's a common idiom though, so don't be too surprised
when you see it.  You can at least use a temporary variable to hold the
previous filehandle: (this is a much better approach in general, because
not only does legibility improve, you now have intermediary stage in the
expression to single-step the debugger through):

     $ofh = select(OUTF);
     $~ = "My_Other_Format";
     $^ = "My_Top_Format";
     select($ofh);

   If you use the English module, you can even read the variable names:

     use English;
     $ofh = select(OUTF);
     $FORMAT_NAME     = "My_Other_Format";
     $FORMAT_TOP_NAME = "My_Top_Format";
     select($ofh);

   But you still have those funny select()s.  So just use the FileHandle
module.  Now, you can access these special variables using lowercase
method names instead:

     use FileHandle;
     format_name     OUTF "My_Other_Format";
     format_top_name OUTF "My_Top_Format";

   Much better!

NOTES
=====

   Because the values line may contain arbitrary expressions (for at
fields, not caret fields), you can farm out more sophisticated processing
to other functions, like sprintf() or one of your own.  For example:

     format Ident =
     	@<<<<<<<<<<<<<<<
     	&commify($n)
     .

   To get a real at or caret into the field, do this:

     format Ident =
     I have an @ here.
     	    "@"
     .

   To center a whole line of text, do something like this:

     format Ident =
     @|||||||||||||||||||||||||||||||||||||||||||||||
     	    "Some text line"
     .

   There is no builtin way to say "float this to the right hand side of
the page, however wide it is."  You have to specify where it goes.  The
truly desperate can generate their own format on the fly, based on the
current number of columns, and then eval() it:

     $format  = "format STDOUT = \n"
              . '^' . '<' x $cols . "\n"
              . '$entry' . "\n"
              . "\t^" . "<" x ($cols-8) . "~~\n"
              . '$entry' . "\n"
              . ".\n";
     print $format if $Debugging;
     eval $format;
     die $@ if $@;

   Which would generate a format looking something like this:

     format STDOUT =
     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
     $entry
             ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~
     $entry
     .

   Here's a little program that's somewhat like fmt(1):

     format =
     ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ~~
     $_

     .

     $/ = '';
     while (<>) {
         s/\s*\n\s*/ /g;
         write;
     }

Footers
-------

   While $FORMAT_TOP_NAME contains the name of the current header format,
there is no corresponding mechanism to automatically do the same thing for
a footer.  Not knowing how big a format is going to be until you evaluate
it is one of the major problems.  It's on the TODO list.

   Here's one strategy:  If you have a fixed-size footer, you can get
footers by checking $FORMAT_LINES_LEFT before each write() and print the
footer yourself if necessary.

   Here's another strategy: Open a pipe to yourself, using `open(MYSELF,
"|-")' (see `open()', *Note Perlfunc: perlfunc,) and always write() to
MYSELF instead of STDOUT.  Have your child process massage its STDIN to
rearrange headers and footers however you like.  Not very convenient, but
doable.

Accessing Formatting Internals
------------------------------

   For low-level access to the formatting mechanism.  you may use
formline() and access $^A (the $ACCUMULATOR variable) directly.

   For example:

     $str = formline <<'END', 1,2,3;
     @<<<  @|||  @>>>
     END

     print "Wow, I just stored `$^A' in the accumulator!\n";

   Or to make an swrite() subroutine, which is to write() what sprintf()
is to printf(), do this:

     use Carp;
     sub swrite {
     	croak "usage: swrite PICTURE ARGS" unless @_;
     	my $format = shift;
     	$^A = "";
     	formline($format,@_);
     	return $^A;
     }

     $string = swrite(<<'END', 1, 2, 3);
      Check me out
      @<<<  @|||  @>>>
      END
     print $string;

WARNINGS
========

   The lone dot that ends a format can also prematurely end a mail message
passing through a misconfigured Internet mailer (and based on experience,
such misconfiguration is the rule, not the exception).  So when sending
format code through mail, you should indent it so that the format-ending
dot is not on the left margin; this will prevent SMTP cutoff.

   Lexical variables (declared with "my") are not visible within a format
unless the format is declared within the scope of the lexical variable.
(They weren't visible at all before version 5.001.)

   Formats are the only part of Perl that unconditionally use information
from a program's locale; if a program's environment specifies an
LC_NUMERIC locale, it is always used to specify the decimal point
character in formatted output.  Perl ignores all other aspects of locale
handling unless the `use locale' pragma is in effect.  Formatted output
cannot be controlled by `use locale' because the pragma is tied to the
block structure of the program, and, for historical reasons, formats exist
outside that block structure.  See *Note Perllocale: perllocale, for
further discussion of locale handling.

   Inside of an expression, the whitespace characters \n, \t and \f are
considered to be equivalent to a single space.  Thus, you could think of
this filter being applied to each value in the format:

     $value =~ tr/\n\t\f/ /;

   The remaining whitespace character, \r, forces the printing of a new
line if allowed by the picture line.


File: perl.info,  Node: perlfunc,  Next: perlopentut,  Prev: perlrun,  Up: Top

Perl builtin functions
**********************

NAME
====

   perlfunc - Perl builtin functions

DESCRIPTION
===========

   The functions in this section can serve as terms in an expression.
They fall into two major categories: list operators and named unary
operators.  These differ in their precedence relationship with a following
comma.  (See the precedence table in *Note Perlop: perlop,.)  List
operators take more than one argument, while unary operators can never
take more than one argument.  Thus, a comma terminates the argument of a
unary operator, but merely separates the arguments of a list operator.  A
unary operator generally provides a scalar context to its argument, while
a list operator may provide either scalar or list contexts for its
arguments.  If it does both, the scalar arguments will be first, and the
list argument will follow.  (Note that there can ever be only one such
list argument.)  For instance, splice() has three scalar arguments
followed by a list, whereas gethostbyname() has four scalar arguments.

   In the syntax descriptions that follow, list operators that expect a
list (and provide list context for the elements of the list) are shown
with LIST as an argument.  Such a list may consist of any combination of
scalar arguments or list values; the list values will be included in the
list as if each individual element were interpolated at that point in the
list, forming a longer single-dimensional list value.  Elements of the
LIST should be separated by commas.

   Any function in the list below may be used either with or without
parentheses around its arguments.  (The syntax descriptions omit the
parentheses.)  If you use the parentheses, the simple (but occasionally
surprising) rule is this: It *looks* like a function, therefore it *is* a
function, and precedence doesn't matter.  Otherwise it's a list operator
or unary operator, and precedence does matter.  And whitespace between the
function and left parenthesis doesn't count-so you need to be careful
sometimes:

     print 1+2+4;	# Prints 7.
     print(1+2) + 4;	# Prints 3.
     print (1+2)+4;	# Also prints 3!
     print +(1+2)+4;	# Prints 7.
     print ((1+2)+4);	# Prints 7.

   If you run Perl with the -w switch it can warn you about this.  For
example, the third line above produces:

     print (...) interpreted as function at - line 1.
     Useless use of integer addition in void context at - line 1.

   A few functions take no arguments at all, and therefore work as neither
unary nor list operators.  These include such functions as time and
endpwent.  For example, `time+86_400' always means `time() + 86_400'.

   For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in a scalar context by
returning the undefined value, and in a list context by returning the null
list.

   Remember the following important rule: There is *no rule* that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.  It might do two totally different things.  Each
operator and function decides which sort of value it would be most
appropriate to return in scalar context.  Some operators return the length
of the list that would have been returned in list context.  Some operators
return the first value in the list.  Some operators return the last value
in the list.  Some operators return a count of successful operations.  In
general, they do what you want, unless you want consistency.

   An named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.  You can't get a list
like `(1,2,3)' into being in scalar context, because the compiler knows
the context at compile time.  It would generate the scalar comma operator
there, not the list construction version of the comma.  That means it was
never a list to start with.

   In general, functions in Perl that serve as wrappers for system calls
of the same name (like chown(2), fork(2), closedir(2), etc.) all return
true when they succeed and undef otherwise, as is usually mentioned in the
descriptions below.  This is different from the C interfaces, which return
`-1' on failure.  Exceptions to this rule are wait, waitpid, and syscall.
System calls also set the special $!  variable on failure.  Other
functions do not, except accidentally.

Perl Functions by Category
--------------------------

   Here are Perl's functions (including things that look like functions,
like some keywords and named operators) arranged by category.  Some
functions appear in more than one place.

Functions for SCALARs or strings
     chomp, chop, chr, crypt, hex, index, lc, lcfirst, length, oct, ord,
     pack, q/STRING/, qq/STRING/, reverse, rindex, sprintf, substr, tr///,
     uc, ucfirst, y///

Regular expressions and pattern matching
     m//, pos, quotemeta, s///, split, study, `qr//'

Numeric functions
     abs, atan2, cos, exp, hex, int, log, oct, rand, sin, sqrt, srand

Functions for real @ARRAYs
     pop, push, shift, splice, unshift

Functions for list data
     grep, join, map, qw/STRING/, reverse, sort, unpack

Functions for real %HASHes
     delete, each, exists, keys, values

Input and output functions
     binmode, close, closedir, dbmclose, dbmopen, die, eof, fileno, flock,
     format, getc, print, printf, read, readdir, rewinddir, seek, seekdir,
     select, syscall, sysread, sysseek, syswrite, tell, telldir, truncate,
     warn, write

Functions for fixed length data or records
     pack, read, syscall, sysread, syswrite, unpack, vec

Functions for filehandles, files, or directories
     `-*X*', chdir, chmod, chown, chroot, fcntl, glob, ioctl, link, lstat,
     mkdir, open, opendir, readlink, rename, rmdir, stat, symlink, umask,
     unlink, utime

Keywords related to the control flow of your perl program
     caller, continue, die, do, dump, eval, exit, goto, last, next, redo,
     return, sub, wantarray

Keywords related to scoping
     caller, import, local, my, package, use

Miscellaneous functions
     defined, dump, eval, formline, local, my, reset, scalar, undef,
     wantarray

Functions for processes and process groups
     alarm, exec, fork, getpgrp, getppid, getpriority, kill, pipe,
     qx/STRING/, setpgrp, setpriority, sleep, system, times, wait, waitpid

Keywords related to perl modules
     do, import, no, package, require, use

Keywords related to classes and object-orientedness
     bless, dbmclose, dbmopen, package, ref, tie, tied, untie, use

Low-level socket functions
     accept, bind, connect, getpeername, getsockname, getsockopt, listen,
     recv, send, setsockopt, shutdown, socket, socketpair

System V interprocess communication functions
     msgctl, msgget, msgrcv, msgsnd, semctl, semget, semop, shmctl,
     shmget, shmread, shmwrite

Fetching user and group info
     endgrent, endhostent, endnetent, endpwent, getgrent, getgrgid,
     getgrnam, getlogin, getpwent, getpwnam, getpwuid, setgrent, setpwent

Fetching network info
     endprotoent, endservent, gethostbyaddr, gethostbyname, gethostent,
     getnetbyaddr, getnetbyname, getnetent, getprotobyname,
     getprotobynumber, getprotoent, getservbyname, getservbyport,
     getservent, sethostent, setnetent, setprotoent, setservent

Time-related functions
     gmtime, localtime, time, times

Functions new in perl5
     abs, bless, chomp, chr, exists, formline, glob, import, lc, lcfirst,
     map, my, no, prototype, `qx', `qw', readline, readpipe, ref, `sub*',
     sysopen, tie, tied, uc, ucfirst, untie, use

     * - sub was a keyword in perl4, but in perl5 it is an operator, which
     can be used in expressions.

Functions obsoleted in perl5
     dbmclose, dbmopen

Portability
-----------

   Perl was born in Unix and can therefore access all common Unix system
calls.  In non-Unix environments, the functionality of some Unix system
calls may not be available, or details of the available functionality may
differ slightly.  The Perl functions affected by this are:

   -X, binmode, chmod, chown, chroot, crypt, dbmclose, dbmopen, dump,
endgrent, endhostent, endnetent, endprotoent, endpwent, endservent, exec,
fcntl, flock, fork, getgrent, getgrgid, gethostent, getlogin,
getnetbyaddr, getnetbyname, getnetent, getppid, `getprgp', getpriority,
getprotobynumber, getprotoent, getpwent, getpwnam, getpwuid,
getservbyport, getservent, getsockopt, glob, ioctl, kill, link, lstat,
msgctl, msgget, msgrcv, msgsnd, open, pipe, readlink, rename, select,
semctl, semget, semop, setgrent, sethostent, setnetent, setpgrp,
setpriority, setprotoent, setpwent, setservent, setsockopt, shmctl,
shmget, shmread, shmwrite, socket, socketpair, stat, symlink, syscall,
sysopen, system, times, truncate, umask, unlink, utime, wait, waitpid

   For more information about the portability of these functions, see
*Note Perlport: perlport, and other available platform-specific
documentation.

Alphabetical Listing of Perl Functions
--------------------------------------

-X FILEHANDLE
-X EXPR
-X
     A file test, where X is one of the letters listed below.  This unary
     operator takes one argument, either a filename or a filehandle, and
     tests the associated file to see if something is true about it.  If
     the argument is omitted, tests $_, except for -t, which tests STDIN.
     Unless otherwise documented, it returns 1 for true and " for false, or
     the undefined value if the file doesn't exist.  Despite the funny
     names, precedence is the same as any other named unary operator, and
     the argument may be parenthesized like any other unary operator.  The
     operator may be any of:





     X<-r>X<-w>X<-x>X<-o>X<-R>X<-W>X<-X>X<-O>X<-e>X<-z>X<-s>X<-f>X<-d>X<-l>X<-p>
     X<-S>X<-b>X<-c>X<-t>X<-u>X<-g>X<-k>X<-T>X<-B>X<-M>X<-A>X<-C>

          -r	File is readable by effective uid/gid.
          -w	File is writable by effective uid/gid.
          -x	File is executable by effective uid/gid.
          -o	File is owned by effective uid.

          -R	File is readable by real uid/gid.
          -W	File is writable by real uid/gid.
          -X	File is executable by real uid/gid.
          -O	File is owned by real uid.

          -e	File exists.
          -z	File has zero size.
          -s	File has nonzero size (returns size).

          -f	File is a plain file.
          -d	File is a directory.
          -l	File is a symbolic link.
          -p	File is a named pipe (FIFO), or Filehandle is a pipe.
          -S	File is a socket.
          -b	File is a block special file.
          -c	File is a character special file.
          -t	Filehandle is opened to a tty.

          -u	File has setuid bit set.
          -g	File has setgid bit set.
          -k	File has sticky bit set.

          -T	File is an ASCII text file.
          -B	File is a "binary" file (opposite of -T).

          -M	Age of file in days when script started.
          -A	Same for access time.
          -C	Same for inode change time.

     Example:

          while (<>) {
          	chop;
          	next unless -f $_;	# ignore specials
          	#...
          }

     The interpretation of the file permission operators -r, `-R', -w, -W,
     -x, and -X is by default based solely on the mode of the file and the
     uids and gids of the user.  There may be other reasons you can't
     actually read, write, or execute the file.  Such reasons may be for
     example network filesystem access controls, ACLs (access control
     lists), read-only filesystems, and unrecognized executable formats.

     Also note that, for the superuser on the local filesystems, the -r,
     `-R', -w, and -W tests always return 1, and -x and -X return 1 if any
     execute bit is set in the mode.  Scripts run by the superuser may
     thus need to do a stat() to determine the actual mode of the file, or
     temporarily set their effective uid to something else.

     If you are using ACLs, there is a pragma called filetest that may
     produce more accurate results than the bare stat() mode bits.  When
     under the `use filetest 'access'' the above-mentioned filetests will
     test whether the permission can (not) be granted using the access()
     family of system calls.  Also note that the -x and -X may under this
     pragma return true even if there are no execute permission bits set
     (nor any extra execute permission ACLs).  This strangeness is due to
     the underlying system calls' definitions.  Read the documentation for
     the filetest pragma for more information.

     Note that `-s/a/b/' does not do a negated substitution.  Saying
     `-exp($foo)' still works as expected, however-only single letters
     following a minus are interpreted as file tests.

     The -T and -B switches work as follows.  The first block or so of the
     file is examined for odd characters such as strange control codes or
     characters with the high bit set.  If too many strange characters
     (>30%) are found, it's a -B file, otherwise it's a -T file.  Also,
     any file containing null in the first block is considered a binary
     file.  If -T or -B is used on a filehandle, the current stdio buffer
     is examined rather than the first block.  Both -T and -B return true
     on a null file, or a file at EOF when testing a filehandle.  Because
     you have to read a file to do the -T test, on most occasions you want
     to use a -f against the file first, as in `next unless -f $file && -T
     $file'.

     If any of the file tests (or either the stat or lstat operators) are
     given the special filehandle consisting of a solitary underline, then
     the stat structure of the previous file test (or stat operator) is
     used, saving a system call.  (This doesn't work with -t, and you need
     to remember that lstat() and -l will leave values in the stat
     structure for the symbolic link, not the real file.)  Example:

          print "Can do.\n" if -r $a || -w _ || -x _;

          stat($filename);
          print "Readable\n" if -r _;
          print "Writable\n" if -w _;
          print "Executable\n" if -x _;
          print "Setuid\n" if -u _;
          print "Setgid\n" if -g _;
          print "Sticky\n" if -k _;
          print "Text\n" if -T _;
          print "Binary\n" if -B _;

abs VALUE
abs
     Returns the absolute value of its argument.  If VALUE is omitted,
     uses $_.

accept NEWSOCKET,GENERICSOCKET
     Accepts an incoming socket connect, just as the accept(2) system call
     does.  Returns the packed address if it succeeded, false otherwise.
     See the example in `"Sockets: Client', *Note Perlipc: perlipc,.

     On systems that support a close-on-exec flag on files, the flag will
     be set for the newly opened file descriptor, as determined by the
     value of $^F.  See `$^F', *Note Perlvar: perlvar,.

alarm SECONDS
alarm
     Arranges to have a SIGALRM delivered to this process after the
     specified number of seconds have elapsed.  If SECONDS is not
     specified, the value stored in $_ is used. (On some machines,
     unfortunately, the elapsed time may be up to one second less than you
     specified because of how seconds are counted.)  Only one timer may be
     counting at once.  Each call disables the previous timer, and an
     argument of 0 may be supplied to cancel the previous timer without
     starting a new one.  The returned value is the amount of time
     remaining on the previous timer.

     For delays of finer granularity than one second, you may use Perl's
     four-argument version of select() leaving the first three arguments
     undefined, or you might be able to use the syscall interface to
     access setitimer(2) if your system supports it.  The Time::HiRes
     module from CPAN may also prove useful.

     It is usually a mistake to intermix alarm and sleep calls.  (sleep
     may be internally implemented in your system with alarm)

     If you want to use alarm to time out a system call you need to use an
     eval/die pair.  You can't rely on the alarm causing the system call to
     fail with $! set to `EINTR' because Perl sets up signal handlers to
     restart system calls on some systems.  Using eval/die always works,
     modulo the caveats given in `"Signals"', *Note Perlipc: perlipc,.

          eval {
          	local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
          	alarm $timeout;
          	$nread = sysread SOCKET, $buffer, $size;
          	alarm 0;
          };
          if ($@) {
          	die unless $@ eq "alarm\n";   # propagate unexpected errors
          	# timed out
          }
          else {
          	# didn't
          }

atan2 Y,X
     Returns the arctangent of Y/X in the range -PI to PI.

     For the tangent operation, you may use the `Math::Trig::tan'
     function, or use the familiar relation:

          sub tan { sin($_[0]) / cos($_[0])  }

bind SOCKET,NAME
     Binds a network address to a socket, just as the bind system call
     does.  Returns true if it succeeded, false otherwise.  NAME should be
     a packed address of the appropriate type for the socket.  See the
     examples in `"Sockets: Client', *Note Perlipc: perlipc,.

binmode FILEHANDLE, DISCIPLINE
binmode FILEHANDLE
     Arranges for FILEHANDLE to be read or written in "binary" or "text"
     mode on systems where the run-time libraries distinguish between
     binary and text files.  If FILEHANDLE is an expression, the value is
     taken as the name of the filehandle.  DISCIPLINE can be either of
     `":raw"' for binary mode or `":crlf"' for "text" mode.  If the
     DISCIPLINE is omitted, it defaults to `":raw"'.

     binmode() should be called after open() but before any I/O is done on
     the filehandle.

     On many systems binmode() currently has no effect, but in future, it
     will be extended to support user-defined input and output disciplines.
     On some systems binmode() is necessary when you're not working with a
     text file.  For the sake of portability it is a good idea to always
     use it when appropriate, and to never use it when it isn't
     appropriate.

     In other words:  Regardless of platform, use binmode() on binary
     files, and do not use binmode() on text files.

     The open pragma can be used to establish default disciplines.  See
     *Note Open: (pm.info)open,.

     The operating system, device drivers, C libraries, and Perl run-time
     system all work together to let the programmer treat a single
     character (\n) as the line terminator, irrespective of the external
     representation.  On many operating systems, the native text file
     representation matches the internal representation, but on some
     platforms the external representation of \n is made up of more than
     one character.

     Mac OS and all variants of Unix use a single character to end each
     line in the external representation of text (even though that single
     character is not necessarily the same across these platforms).
     Consequently binmode() has no effect on these operating systems.  In
     other systems like VMS, MS-DOS and the various flavors of MS-Windows
     your program sees a \n as a simple `\cJ', but what's stored in text
     files are the two characters `\cM\cJ'.  That means that, if you don't
     use binmode() on these systems, `\cM\cJ' sequences on disk will be
     converted to \n on input, and any \n in your program will be
     converted back to `\cM\cJ' on output.  This is what you want for text
     files, but it can be disastrous for binary files.

     Another consequence of using binmode() (on some systems) is that
     special end-of-file markers will be seen as part of the data stream.
     For systems from the Microsoft family this means that if your binary
     data contains `\cZ', the I/O subsystem will ragard it as the end of
     the file, unless you use binmode().

     binmode() is not only important for readline() and print() operations,
     but also when using read(), seek(), sysread(), syswrite() and tell()
     (see *Note Perlport: perlport, for more details).  See the $/ and $\
     variables in *Note Perlvar: perlvar, for how to manually set your
     input and output line-termination sequences.

bless REF,CLASSNAME
bless REF
     This function tells the thingy referenced by REF that it is now an
     object in the CLASSNAME package.  If CLASSNAME is omitted, the
     current package is used.  Because a bless is often the last thing in
     a constructor, it returns the reference for convenience.  Always use
     the two-argument version if the function doing the blessing might be
     inherited by a derived class.  See *Note Perltoot: perltoot, and
     *Note Perlobj: perlobj, for more about the blessing (and blessings)
     of objects.

     Consider always blessing objects in CLASSNAMEs that are mixed case.
     Namespaces with all lowercase names are considered reserved for Perl
     pragmata.  Builtin types have all uppercase names, so to prevent
     confusion, you may wish to avoid such package names as well.  Make
     sure that CLASSNAME is a true value.

     See `"Perl Modules"', *Note Perlmod: perlmod,.

caller EXPR
caller
     Returns the context of the current subroutine call.  In scalar
     context, returns the caller's package name if there is a caller, that
     is, if we're in a subroutine or eval or require, and the undefined
     value otherwise.  In list context, returns

          ($package, $filename, $line) = caller;

     With EXPR, it returns some extra information that the debugger uses to
     print a stack trace.  The value of EXPR indicates how many call frames
     to go back before the current one.

          ($package, $filename, $line, $subroutine, $hasargs,
          $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller($i);

     Here $subroutine may be `(eval)' if the frame is not a subroutine
     call, but an eval.  In such a case additional elements $evaltext and
     `$is_require' are set: `$is_require' is true if the frame is created
     by a require or use statement, $evaltext contains the text of the
     `eval EXPR' statement.  In particular, for a `eval BLOCK' statement,
     $filename is `(eval)', but $evaltext is undefined.  (Note also that
     each use statement creates a require frame inside an `eval EXPR')
     frame.  `$hints' and `$bitmask' contain pragmatic hints that the
     caller was compiled with.  The `$hints' and `$bitmask' values are
     subject to change between versions of Perl, and are not meant for
     external use.

     Furthermore, when called from within the DB package, caller returns
     more detailed information: it sets the list variable `@DB::args' to
     be the arguments with which the subroutine was invoked.

     Be aware that the optimizer might have optimized call frames away
     before caller had a chance to get the information.  That means that
     `caller(N)' might not return information about the call frame you
     expect it do, for `< N ' 1 >>.  In particular, `@DB::args' might have
     information from the previous time caller was called.

chdir EXPR
     Changes the working directory to EXPR, if possible.  If EXPR is
     omitted, changes to the directory specified by `$ENV{HOME}', if set;
     if not, changes to the directory specified by `$ENV{LOGDIR}'.  If
     neither is set, chdir does nothing.  It returns true upon success,
     false otherwise.  See the example under die.

chmod LIST
     Changes the permissions of a list of files.  The first element of the
     list must be the numerical mode, which should probably be an octal
     number, and which definitely should not a string of octal digits:
     `0644' is okay, `'0644'' is not.  Returns the number of files
     successfully changed.  See also `' in this node, if all you have is a
     string.

          $cnt = chmod 0755, 'foo', 'bar';
          chmod 0755, @executables;
          $mode = '0644'; chmod $mode, 'foo';      # !!! sets mode to
                                                   # --w----r-T
          $mode = '0644'; chmod oct($mode), 'foo'; # this is better
          $mode = 0644;   chmod $mode, 'foo';      # this is best

     You can also import the symbolic `S_I*' constants from the Fcntl
     module:

          use Fcntl ':mode';

          chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;
          # This is identical to the chmod 0755 of the above example.

chomp VARIABLE
chomp LIST
chomp
     This safer version of `' in this node removes any trailing string
     that corresponds to the current value of $/ (also known as
     $INPUT_RECORD_SEPARATOR in the English module).  It returns the total
     number of characters removed from all its arguments.  It's often used
     to remove the newline from the end of an input record when you're
     worried that the final record may be missing its newline.  When in
     paragraph mode (`$/ = ""'), it removes all trailing newlines from the
     string.  When in slurp mode (`$/ = undef') or fixed-length record
     mode ($/ is a reference to an integer or the like, see *Note Perlvar:
     perlvar,) chomp() won't remove anything.  If VARIABLE is omitted, it
     chomps $_.  Example:

          while (<>) {
          	chomp;	# avoid \n on last field
          	@array = split(/:/);
          	# ...
          }

     You can actually chomp anything that's an lvalue, including an
     assignment:

          chomp($cwd = `pwd`);
          chomp($answer = <STDIN>);

     If you chomp a list, each element is chomped, and the total number of
     characters removed is returned.

chop VARIABLE
chop LIST
chop
     Chops off the last character of a string and returns the character
     chopped.  It's used primarily to remove the newline from the end of an
     input record, but is much more efficient than `s/\n//' because it
     neither scans nor copies the string.  If VARIABLE is omitted, chops
     $_.  Example:

          while (<>) {
          	chop;	# avoid \n on last field
          	@array = split(/:/);
          	#...
          }

     You can actually chop anything that's an lvalue, including an
     assignment:

          chop($cwd = `pwd`);
          chop($answer = <STDIN>);

     If you chop a list, each element is chopped.  Only the value of the
     last chop is returned.

     Note that chop returns the last character.  To return all but the last
     character, use `substr($string, 0, -1)'.

chown LIST
     Changes the owner (and group) of a list of files.  The first two
     elements of the list must be the numeric uid and gid, in that order.
     A value of -1 in either position is interpreted by most systems to
     leave that value unchanged.  Returns the number of files successfully
     changed.

          $cnt = chown $uid, $gid, 'foo', 'bar';
          chown $uid, $gid, @filenames;

     Here's an example that looks up nonnumeric uids in the passwd file:

          print "User: ";
          chomp($user = <STDIN>);
          print "Files: ";
          chomp($pattern = <STDIN>);

          ($login,$pass,$uid,$gid) = getpwnam($user)
          	or die "$user not in passwd file";

          @ary = glob($pattern);	# expand filenames
          chown $uid, $gid, @ary;

     On most systems, you are not allowed to change the ownership of the
     file unless you're the superuser, although you should be able to
     change the group to any of your secondary groups.  On insecure
     systems, these restrictions may be relaxed, but this is not a
     portable assumption.  On POSIX systems, you can detect this condition
     this way:

          use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
          $can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);

chr NUMBER
chr
     Returns the character represented by that NUMBER in the character set.
     For example, `chr(65)' is `"A"' in either ASCII or Unicode, and
     chr(0x263a) is a Unicode smiley face (but only within the scope of a
     `use utf8').  For the reverse, use `' in this node.  See *Note Utf8:
     (pm.info)utf8, for more about Unicode.

     If NUMBER is omitted, uses $_.

chroot FILENAME
chroot
     This function works like the system call by the same name: it makes
     the named directory the new root directory for all further pathnames
     that begin with a / by your process and all its children.  (It doesn't
     change your current working directory, which is unaffected.)  For
     security reasons, this call is restricted to the superuser.  If
     FILENAME is omitted, does a chroot to $_.

close FILEHANDLE
close
     Closes the file or pipe associated with the file handle, returning
     true only if stdio successfully flushes buffers and closes the system
     file descriptor.  Closes the currently selected filehandle if the
     argument is omitted.

     You don't have to close FILEHANDLE if you are immediately going to do
     another open on it, because open will close it for you.  (See open.)
     However, an explicit close on an input file resets the line counter
     ($.), while the implicit close done by open does not.

     If the file handle came from a piped open close will additionally
     return false if one of the other system calls involved fails or if the
     program exits with non-zero status.  (If the only problem was that the
     program exited non-zero $! will be set to 0.)  Closing a pipe also
     waits for the process executing on the pipe to complete, in case you
     want to look at the output of the pipe afterwards, and implicitly
     puts the exit status value of that command into $?.

     Prematurely closing the read end of a pipe (i.e. before the process
     writing to it at the other end has closed it) will result in a
     SIGPIPE being delivered to the writer.  If the other end can't handle
     that, be sure to read all the data before closing the pipe.

     Example:

          open(OUTPUT, '|sort >foo')  # pipe to sort
              or die "Can't start sort: $!";
          #...			# print stuff to output
          close OUTPUT		# wait for sort to finish
              or warn $! ? "Error closing sort pipe: $!"
                         : "Exit status $? from sort";
          open(INPUT, 'foo')		# get sort's results
              or die "Can't open 'foo' for input: $!";

     FILEHANDLE may be an expression whose value can be used as an indirect
     filehandle, usually the real filehandle name.

closedir DIRHANDLE
     Closes a directory opened by opendir and returns the success of that
     system call.

     DIRHANDLE may be an expression whose value can be used as an indirect
     dirhandle, usually the real dirhandle name.

connect SOCKET,NAME
     Attempts to connect to a remote socket, just as the connect system
     call does.  Returns true if it succeeded, false otherwise.  NAME
     should be a packed address of the appropriate type for the socket.
     See the examples in `"Sockets: Client', *Note Perlipc: perlipc,.

continue BLOCK
     Actually a flow control statement rather than a function.  If there
     is a continue BLOCK attached to a BLOCK (typically in a while or
     foreach), it is always executed just before the conditional is about
     to be evaluated again, just like the third part of a for loop in C.
     Thus it can be used to increment a loop variable, even when the loop
     has been continued via the next statement (which is similar to the C
     continue statement).

     last, next, or redo may appear within a continue block.  last and
     redo will behave as if they had been executed within the main block.
     So will next, but since it will execute a continue block, it may be
     more entertaining.

          while (EXPR) {
          	### redo always comes here
          	do_something;
          } continue {
          	### next always comes here
          	do_something_else;
          	# then back the top to re-check EXPR
          }
          ### last always comes here

     Omitting the continue section is semantically equivalent to using an
     empty one, logically enough.  In that case, next goes directly back
     to check the condition at the top of the loop.

cos EXPR
     Returns the cosine of EXPR (expressed in radians).  If EXPR is
     omitted, takes cosine of $_.

     For the inverse cosine operation, you may use the `Math::Trig::acos()'
     function, or use this relation:

          sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }

crypt PLAINTEXT,SALT
     Encrypts a string exactly like the crypt(3) function in the C library
     (assuming that you actually have a version there that has not been
     extirpated as a potential munition).  This can prove useful for
     checking the password file for lousy passwords, amongst other things.
     Only the guys wearing white hats should do this.

     Note that crypt is intended to be a one-way function, much like
     breaking eggs to make an omelette.  There is no (known) corresponding
     decrypt function.  As a result, this function isn't all that useful
     for cryptography.  (For that, see your nearby CPAN mirror.)

     When verifying an existing encrypted string you should use the
     encrypted text as the salt (like `crypt($plain, $crypted) eq
     $crypted').  This allows your code to work with the standard crypt
     and with more exotic implementations.  When choosing a new salt
     create a random two character string whose characters come from the
     set `[./0-9A-Za-z]' (like `join '', ('.', '/', 0..9, 'A'..'Z',
     'a'..'z')[rand 64, rand 64]').

     Here's an example that makes sure that whoever runs this program knows
     their own password:

          $pwd = (getpwuid($<))[1];

          system "stty -echo";
          print "Password: ";
          chomp($word = <STDIN>);
          print "\n";
          system "stty echo";

          if (crypt($word, $pwd) ne $pwd) {
          	die "Sorry...\n";
          } else {
          	print "ok\n";
          }

     Of course, typing in your own password to whoever asks you for it is
     unwise.

     The `crypt' in this node function is unsuitable for encrypting large
     quantities of data, not least of all because you can't get the
     information back.  Look at the `by-module/Crypt' and `by-module/PGP'
     directories on your favorite CPAN mirror for a slew of potentially
     useful modules.

dbmclose HASH
     [This function has been largely superseded by the untie function.]

     Breaks the binding between a DBM file and a hash.

dbmopen HASH,DBNAME,MASK
     [This function has been largely superseded by the tie function.]

     This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file
     to a hash.  HASH is the name of the hash.  (Unlike normal open, the
     first argument is not a filehandle, even though it looks like one).
     DBNAME is the name of the database (without the `.dir' or `.pag'
     extension if any).  If the database does not exist, it is created
     with protection specified by MASK (as modified by the umask).  If
     your system supports only the older DBM functions, you may perform
     only one dbmopen in your program.  In older versions of Perl, if your
     system had neither DBM nor ndbm, calling dbmopen produced a fatal
     error; it now falls back to sdbm(3).

     If you don't have write access to the DBM file, you can only read hash
     variables, not set them.  If you want to test whether you can write,
     either use file tests or try setting a dummy hash entry inside an
     eval, which will trap the error.

     Note that functions such as keys and values may return huge lists
     when used on large DBM files.  You may prefer to use the each
     function to iterate over large DBM files.  Example:

          # print out history file offsets
          dbmopen(%HIST,'/usr/lib/news/history',0666);
          while (($key,$val) = each %HIST) {
          	print $key, ' = ', unpack('L',$val), "\n";
          }
          dbmclose(%HIST);

     See also *Note AnyDBM_File: (pm.info)AnyDBM_File, for a more general
     description of the pros and cons of the various dbm approaches, as
     well as *Note DB_File: (pm.info)DB_File, for a particularly rich
     implementation.

     You can control which DBM library you use by loading that library
     before you call dbmopen():

          use DB_File;
          dbmopen(%NS_Hist, "$ENV{HOME}/.netscape/history.db")
          	or die "Can't open netscape history file: $!";

defined EXPR
defined
     Returns a Boolean value telling whether EXPR has a value other than
     the undefined value undef.  If EXPR is not present, $_ will be
     checked.

     Many operations return undef to indicate failure, end of file, system
     error, uninitialized variable, and other exceptional conditions.
     This function allows you to distinguish undef from other values.  (A
     simple Boolean test will not distinguish among undef, zero, the empty
     string, and `"0"', which are all equally false.)  Note that since
     undef is a valid scalar, its presence doesn't *necessarily* indicate
     an exceptional condition: pop returns undef when its argument is an
     empty array, or when the element to return happens to be undef.

     You may also use `defined(&func)' to check whether subroutine `&func'
     has ever been defined.  The return value is unaffected by any forward
     declarations of `&foo'.

     Use of defined on aggregates (hashes and arrays) is deprecated.  It
     used to report whether memory for that aggregate has ever been
     allocated.  This behavior may disappear in future versions of Perl.
     You should instead use a simple test for size:

          if (@an_array) { print "has array elements\n" }
          if (%a_hash)   { print "has hash members\n"   }

     When used on a hash element, it tells you whether the value is
     defined, not whether the key exists in the hash.  Use `' in this node
     for the latter purpose.

     Examples:

          print if defined $switch{'D'};
          print "$val\n" while defined($val = pop(@ary));
          die "Can't readlink $sym: $!"
          	unless defined($value = readlink $sym);
          sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }
          $debugging = 0 unless defined $debugging;

     Note:  Many folks tend to overuse defined, and then are surprised to
     discover that the number 0 and "" (the zero-length string) are, in
     fact, defined values.  For example, if you say

          "ab" =~ /a(.*)b/;

     The pattern match succeeds, and $1 is defined, despite the fact that
     it matched "nothing".  But it didn't really match nothing-rather, it
     matched something that happened to be zero characters long.  This is
     all very above-board and honest.  When a function returns an
     undefined value, it's an admission that it couldn't give you an
     honest answer.  So you should use defined only when you're
     questioning the integrity of what you're trying to do.  At other
     times, a simple comparison to 0 or "" is what you want.

     See also `' in this node, `' in this node, `' in this node.

delete EXPR
     Given an expression that specifies a hash element, array element,
     hash slice, or array slice, deletes the specified element(s) from the
     hash or array.  In the case of an array, if the array elements happen
     to be at the end, the size of the array will shrink to the highest
     element that tests true for exists() (or 0 if no such element exists).

     Returns each element so deleted or the undefined value if there was
     no such element.  Deleting from `$ENV{}' modifies the environment.
     Deleting from a hash tied to a DBM file deletes the entry from the
     DBM file.  Deleting from a tied hash or array may not necessarily
     return anything.

     Deleting an array element effectively returns that position of the
     array to its initial, uninitialized state.  Subsequently testing for
     the same element with exists() will return false.  Note that deleting
     array elements in the middle of an array will not shift the index of
     the ones after them down-use splice() for that.  See `' in this node.

     The following (inefficiently) deletes all the values of %HASH and
     @ARRAY:

          foreach $key (keys %HASH) {
          	delete $HASH{$key};
          }

          foreach $index (0 .. $#ARRAY) {
          	delete $ARRAY[$index];
          }

     And so do these:

          delete @HASH{keys %HASH};

          delete @ARRAY[0 .. $#ARRAY];

     But both of these are slower than just assigning the empty list or
     undefining %HASH or @ARRAY:

          %HASH = ();		# completely empty %HASH
          undef %HASH;	# forget %HASH ever existed

          @ARRAY = ();	# completely empty @ARRAY
          undef @ARRAY;	# forget @ARRAY ever existed

     Note that the EXPR can be arbitrarily complicated as long as the final
     operation is a hash element, array element,  hash slice, or array
     slice lookup:

          delete $ref->[$x][$y]{$key};
          delete @{$ref->[$x][$y]}{$key1, $key2, @morekeys};

          delete $ref->[$x][$y][$index];
          delete @{$ref->[$x][$y]}[$index1, $index2, @moreindices];

die LIST
     Outside an eval, prints the value of LIST to `STDERR' and exits with
     the current value of $! (errno).  If $! is 0, exits with the value of
     `<< ($? '> 8) >>> (backtick `command` status).  If `<< ($? '> 8) >>>
     is 0, exits with `255'.  Inside an `eval(),' the error message is
     stuffed into `$@' and the eval is terminated with the undefined
     value.  This makes die the way to raise an exception.

     Equivalent examples:

          die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';
          chdir '/usr/spool/news' or die "Can't cd to spool: $!\n"

     If the value of EXPR does not end in a newline, the current script
     line number and input line number (if any) are also printed, and a
     newline is supplied.  Note that the "input line number" (also known
     as "chunk") is subject to whatever notion of "line" happens to be
     currently in effect, and is also available as the special variable $..
     See `"$', *Note Perlvar: perlvar, and `"$."', *Note Perlvar: perlvar,.

     Hint: sometimes appending `", stopped"' to your message will cause it
     to make better sense when the string `"at foo line 123"' is appended.
     Suppose you are running script "canasta".

          die "/etc/games is no good";
          die "/etc/games is no good, stopped";

     produce, respectively

          /etc/games is no good at canasta line 123.
          /etc/games is no good, stopped at canasta line 123.

     See also exit(), warn(), and the Carp module.

     If LIST is empty and `$@' already contains a value (typically from a
     previous eval) that value is reused after appending
     `"\t...propagated"'.  This is useful for propagating exceptions:

          eval { ... };
          die unless $@ =~ /Expected exception/;

     If `$@' is empty then the string `"Died"' is used.

     die() can also be called with a reference argument.  If this happens
     to be trapped within an eval(), $@ contains the reference.  This
     behavior permits a more elaborate exception handling implementation
     using objects that maintain arbitary state about the nature of the
     exception.  Such a scheme is sometimes preferable to matching
     particular string values of $@ using regular expressions.  Here's an
     example:

          eval { ... ; die Some::Module::Exception->new( FOO => "bar" ) };
          if ($@) {
              if (ref($@) && UNIVERSAL::isa($@,"Some::Module::Exception")) {
                  # handle Some::Module::Exception
              }
              else {
                  # handle all other possible exceptions
              }
          }

     Because perl will stringify uncaught exception messages before
     displaying them, you may want to overload stringification operations
     on such custom exception objects.  See *Note Overload:
     (pm.info)overload, for details about that.

     You can arrange for a callback to be run just before the die does its
     deed, by setting the `$SIG{__DIE__}' hook.  The associated handler
     will be called with the error text and can change the error message,
     if it sees fit, by calling die again.  See `$SIG{expr}', *Note
     Perlvar: perlvar, for details on setting %SIG entries, and `"eval
     BLOCK"' in this node for some examples.  Although this feature was
     meant to be run only right before your program was to exit, this is
     not currently the case-the `$SIG{__DIE__}' hook is currently called
     even inside eval()ed blocks/strings!  If one wants the hook to do
     nothing in such situations, put

          die @_ if $^S;

     as the first line of the handler (see `$^S', *Note Perlvar:
     perlvar,).  Because this promotes strange action at a distance, this
     counterintuitive behavior may be fixed in a future release.

do BLOCK
     Not really a function.  Returns the value of the last command in the
     sequence of commands indicated by BLOCK.  When modified by a loop
     modifier, executes the BLOCK once before testing the loop condition.
     (On other statements the loop modifiers test the conditional first.)

     `do BLOCK' does not count as a loop, so the loop control statements
     next, last, or redo cannot be used to leave or restart the block.
     See *Note Perlsyn: perlsyn, for alternative strategies.

do SUBROUTINE(LIST)
     A deprecated form of subroutine call.  See *Note Perlsub: perlsub,.

do EXPR
     Uses the value of EXPR as a filename and executes the contents of the
     file as a Perl script.  Its primary use is to include subroutines
     from a Perl subroutine library.

          do 'stat.pl';

     is just like

          scalar eval `cat stat.pl`;

     except that it's more efficient and concise, keeps track of the
     current filename for error messages, searches the @INC libraries, and
     updates %INC if the file is found.  See `Predefined Names', *Note
     Perlvar: perlvar, for these variables.  It also differs in that code
     evaluated with `do FILENAME' cannot see lexicals in the enclosing
     scope; `eval STRING' does.  It's the same, however, in that it does
     reparse the file every time you call it, so you probably don't want
     to do this inside a loop.

     If do cannot read the file, it returns undef and sets $! to the
     error.  If do can read the file but cannot compile it, it returns
     undef and sets an error message in `$@'.   If the file is
     successfully compiled, do returns the value of the last expression
     evaluated.

     Note that inclusion of library modules is better done with the use
     and require operators, which also do automatic error checking and
     raise an exception if there's a problem.

     You might like to use do to read in a program configuration file.
     Manual error checking can be done this way:

          # read in config files: system first, then user
          for $file ("/share/prog/defaults.rc",
                     "$ENV{HOME}/.someprogrc")
             {
          	unless ($return = do $file) {
          	    warn "couldn't parse $file: $@" if $@;
          	    warn "couldn't do $file: $!"    unless defined $return;
          	    warn "couldn't run $file"       unless $return;
          	}
          }

dump LABEL
dump
     This function causes an immediate core dump.  See also the -u
     command-line switch in *Note Perlrun: perlrun,, which does the same
     thing.  Primarily this is so that you can use the *undump* program
     (not supplied) to turn your core dump into an executable binary after
     having initialized all your variables at the beginning of the
     program.  When the new binary is executed it will begin by executing
     a `goto LABEL' (with all the restrictions that goto suffers).  Think
     of it as a goto with an intervening core dump and reincarnation.  If
     `LABEL' is omitted, restarts the program from the top.

     WARNING: Any files opened at the time of the dump will not be open
     any more when the program is reincarnated, with possible resulting
     confusion on the part of Perl.

     This function is now largely obsolete, partly because it's very hard
     to convert a core file into an executable, and because the real
     compiler backends for generating portable bytecode and compilable C
     code have superseded it.

     If you're looking to use `dump' in this node to speed up your
     program, consider generating bytecode or native C code as described
     in `perlcc' in this node.  If you're just trying to accelerate a CGI
     script, consider using the mod_perl extension to Apache, or the CPAN
     module, Fast::CGI.  You might also consider autoloading or
     selfloading, which at least make your program *appear* to run faster.

each HASH
     When called in list context, returns a 2-element list consisting of
     the key and value for the next element of a hash, so that you can
     iterate over it.  When called in scalar context, returns the key for
     only the "next" element in the hash.

     Entries are returned in an apparently random order.  The actual random
     order is subject to change in future versions of perl, but it is
     guaranteed to be in the same order as either the keys or values
     function would produce on the same (unmodified) hash.

     When the hash is entirely read, a null array is returned in list
     context (which when assigned produces a false (0) value), and undef in
     scalar context.  The next call to each after that will start iterating
     again.  There is a single iterator for each hash, shared by all each,
     keys, and values function calls in the program; it can be reset by
     reading all the elements from the hash, or by evaluating `keys HASH'
     or `values HASH'.  If you add or delete elements of a hash while
     you're iterating over it, you may get entries skipped or duplicated,
     so don't.

     The following prints out your environment like the printenv(1)
     program, only in a different order:

          while (($key,$value) = each %ENV) {
          	print "$key=$value\n";
          }

     See also keys, values and sort.

eof FILEHANDLE
eof ()
eof
     Returns 1 if the next read on FILEHANDLE will return end of file, or
     if FILEHANDLE is not open.  FILEHANDLE may be an expression whose
     value gives the real filehandle.  (Note that this function actually
     reads a character and then ungetcs it, so isn't very useful in an
     interactive context.)  Do not read from a terminal file (or call
     `eof(FILEHANDLE)' on it) after end-of-file is reached.  File types
     such as terminals may lose the end-of-file condition if you do.

     An eof without an argument uses the last file read.  Using eof() with
     empty parentheses is very different.  It refers to the pseudo file
     formed from the files listed on the command line and accessed via the
     `< <' >> operator.  Since `< <' >> isn't explicitly opened, as a
     normal filehandle is, an eof() before `< <' >> has been used will
     cause `@ARGV' to be examined to determine if input is available.

     In a `< while (<') >> loop, eof or `eof(ARGV)' can be used to detect
     the end of each file, eof() will only detect the end of the last
     file.  Examples:

          # reset line numbering on each input file
          while (<>) {
          	next if /^\s*#/;	# skip comments
          	print "$.\t$_";
          } continue {
          	close ARGV  if eof;	# Not eof()!
          }

          # insert dashes just before last line of last file
          while (<>) {
          	if (eof()) {		# check for end of current file
          	    print "--------------\n";
          	    close(ARGV);	# close or last; is needed if we
          				# are reading from the terminal
          	}
          	print;
          }

     Practical hint: you almost never need to use eof in Perl, because the
     input operators typically return undef when they run out of data, or
     if there was an error.

eval EXPR
eval BLOCK
     In the first form, the return value of EXPR is parsed and executed as
     if it were a little Perl program.  The value of the expression (which
     is itself determined within scalar context) is first parsed, and if
     there weren't any errors, executed in the context of the current Perl
     program, so that any variable settings or subroutine and format
     definitions remain afterwards.  Note that the value is parsed every
     time the eval executes.  If EXPR is omitted, evaluates $_.  This form
     is typically used to delay parsing and subsequent execution of the
     text of EXPR until run time.

     In the second form, the code within the BLOCK is parsed only once-at
     the same time the code surrounding the eval itself was parsed-and
     executed within the context of the current Perl program.  This form
     is typically used to trap exceptions more efficiently than the first
     (see below), while also providing the benefit of checking the code
     within BLOCK at compile time.

     The final semicolon, if any, may be omitted from the value of EXPR or
     within the BLOCK.

     In both forms, the value returned is the value of the last expression
     evaluated inside the mini-program; a return statement may be also
     used, just as with subroutines.  The expression providing the return
     value is evaluated in void, scalar, or list context, depending on the
     context of the eval itself.  See `' in this node for more on how the
     evaluation context can be determined.

     If there is a syntax error or runtime error, or a die statement is
     executed, an undefined value is returned by eval, and `$@' is set to
     the error message.  If there was no error, `$@' is guaranteed to be a
     null string.  Beware that using eval neither silences perl from
     printing warnings to STDERR, nor does it stuff the text of warning
     messages into `$@'.  To do either of those, you have to use the
     `$SIG{__WARN__}' facility.  See `' in this node and *Note Perlvar:
     perlvar,.

     Note that, because eval traps otherwise-fatal errors, it is useful for
     determining whether a particular feature (such as socket or symlink)
     is implemented.  It is also Perl's exception trapping mechanism, where
     the die operator is used to raise exceptions.

     If the code to be executed doesn't vary, you may use the eval-BLOCK
     form to trap run-time errors without incurring the penalty of
     recompiling each time.  The error, if any, is still returned in `$@'.
     Examples:

          # make divide-by-zero nonfatal
          eval { $answer = $a / $b; }; warn $@ if $@;

          # same thing, but less efficient
          eval '$answer = $a / $b'; warn $@ if $@;

          # a compile-time error
          eval { $answer = };			# WRONG

          # a run-time error
          eval '$answer =';	# sets $@

     Due to the current arguably broken state of __DIE__ hooks, when using
     the `eval{}' form as an exception trap in libraries, you may wish not
     to trigger any __DIE__ hooks that user code may have installed.  You
     can use the `local $SIG{__DIE__}' construct for this purpose, as
     shown in this example:

          # a very private exception trap for divide-by-zero
          eval { local $SIG{'__DIE__'}; $answer = $a / $b; };
          warn $@ if $@;

     This is especially significant, given that __DIE__ hooks can call die
     again, which has the effect of changing their error messages:

          # __DIE__ hooks may modify error messages
          {
             local $SIG{'__DIE__'} =
                    sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };
             eval { die "foo lives here" };
             print $@ if $@;                # prints "bar lives here"
          }

     Because this promotes action at a distance, this counterintuitive
     behavior may be fixed in a future release.

     With an eval, you should be especially careful to remember what's
     being looked at when:

          eval $x;		# CASE 1
          eval "$x";		# CASE 2

          eval '$x';		# CASE 3
          eval { $x };	# CASE 4

          eval "\$$x++";	# CASE 5
          $$x++;		# CASE 6

     Cases 1 and 2 above behave identically: they run the code contained in
     the variable $x.  (Although case 2 has misleading double quotes making
     the reader wonder what else might be happening (nothing is).)  Cases 3
     and 4 likewise behave in the same way: they run the code `'$x'', which
     does nothing but return the value of $x.  (Case 4 is preferred for
     purely visual reasons, but it also has the advantage of compiling at
     compile-time instead of at run-time.)  Case 5 is a place where
     normally you *would* like to use double quotes, except that in this
     particular situation, you can just use symbolic references instead, as
     in case 6.

     `eval BLOCK' does not count as a loop, so the loop control statements
     next, last, or redo cannot be used to leave or restart the block.

exec LIST
exec PROGRAM LIST
     The exec function executes a system command *and never returns*- use
     system instead of exec if you want it to return.  It fails and
     returns false only if the command does not exist and it is executed
     directly instead of via your system's command shell (see below).

     Since it's a common mistake to use exec instead of system, Perl warns
     you if there is a following statement which isn't die, warn, or exit
     (if -w is set  -  but you always do that).   If you *really* want to
     follow an exec with some other statement, you can use one of these
     styles to avoid the warning:

          exec ('foo')   or print STDERR "couldn't exec foo: $!";
          { exec ('foo') }; print STDERR "couldn't exec foo: $!";

     If there is more than one argument in LIST, or if LIST is an array
     with more than one value, calls execvp(3) with the arguments in LIST.
     If there is only one scalar argument or an array with one element in
     it, the argument is checked for shell metacharacters, and if there
     are any, the entire argument is passed to the system's command shell
     for parsing (this is `/bin/sh -c' on Unix platforms, but varies on
     other platforms).  If there are no shell metacharacters in the
     argument, it is split into words and passed directly to execvp, which
     is more efficient.  Examples:

          exec '/bin/echo', 'Your arguments are: ', @ARGV;
          exec "sort $outfile | uniq";

     If you don't really want to execute the first argument, but want to
     lie to the program you are executing about its own name, you can
     specify the program you actually want to run as an "indirect object"
     (without a comma) in front of the LIST.  (This always forces
     interpretation of the LIST as a multivalued list, even if there is
     only a single scalar in the list.)  Example:

          $shell = '/bin/csh';
          exec $shell '-sh';		# pretend it's a login shell

     or, more directly,

          exec {'/bin/csh'} '-sh';	# pretend it's a login shell

     When the arguments get executed via the system shell, results will be
     subject to its quirks and capabilities.  See `"`STRING`"', *Note
     Perlop: perlop, for details.

     Using an indirect object with exec or system is also more secure.
     This usage (which also works fine with system()) forces
     interpretation of the arguments as a multivalued list, even if the
     list had just one argument.  That way you're safe from the shell
     expanding wildcards or splitting up words with whitespace in them.

          @args = ( "echo surprise" );

          exec @args;               # subject to shell escapes
                                      # if @args == 1
          exec { $args[0] } @args;  # safe even with one-arg list

     The first version, the one without the indirect object, ran the echo
     program, passing it `"surprise"' an argument.  The second version
     didn't-it tried to run a program literally called *"echo surprise"*,
     didn't find it, and set $? to a non-zero value indicating failure.

     Beginning with v5.6.0, Perl will attempt to flush all files opened for
     output before the exec, but this may not be supported on some
     platforms (see *Note Perlport: perlport,).  To be safe, you may need
     to set $| ($AUTOFLUSH in English) or call the autoflush() method of
     IO::Handle on any open handles in order to avoid lost output.

     Note that exec will not call your END blocks, nor will it call any
     DESTROY methods in your objects.

exists EXPR
     Given an expression that specifies a hash element or array element,
     returns true if the specified element in the hash or array has ever
     been initialized, even if the corresponding value is undefined.  The
     element is not autovivified if it doesn't exist.

          print "Exists\n" 	if exists $hash{$key};
          print "Defined\n" 	if defined $hash{$key};
          print "True\n"      if $hash{$key};

          print "Exists\n" 	if exists $array[$index];
          print "Defined\n" 	if defined $array[$index];
          print "True\n"      if $array[$index];

     A hash or array element can be true only if it's defined, and defined
     if it exists, but the reverse doesn't necessarily hold true.

     Given an expression that specifies the name of a subroutine, returns
     true if the specified subroutine has ever been declared, even if it
     is undefined.  Mentioning a subroutine name for exists or defined
     does not count as declaring it.

          print "Exists\n" 	if exists &subroutine;
          print "Defined\n" 	if defined &subroutine;

     Note that the EXPR can be arbitrarily complicated as long as the final
     operation is a hash or array key lookup or subroutine name:

          if (exists $ref->{A}->{B}->{$key}) 	{ }
          if (exists $hash{A}{B}{$key}) 	{ }

          if (exists $ref->{A}->{B}->[$ix]) 	{ }
          if (exists $hash{A}{B}[$ix]) 	{ }

          if (exists &{$ref->{A}{B}{$key}})   { }

     Although the deepest nested array or hash will not spring into
     existence just because its existence was tested, any intervening ones
     will.  Thus `< $ref-'{"A"} >> and `< $ref-'{"A"}->{"B"} >> will spring
     into existence due to the existence test for the $key element above.
     This happens anywhere the arrow operator is used, including even:

          undef $ref;
          if (exists $ref->{"Some key"})	{ }
          print $ref; 	    # prints HASH(0x80d3d5c)

     This surprising autovivification in what does not at first-or even
     second-glance appear to be an lvalue context may be fixed in a future
     release.

     See `"Pseudo-hashes: Using an array as a hash"', *Note Perlref:
     perlref, for specifics on how exists() acts when used on a
     pseudo-hash.

     Use of a subroutine call, rather than a subroutine name, as an
     argument to exists() is an error.

          exists &sub;	# OK
          exists &sub();	# Error

exit EXPR
     Evaluates EXPR and exits immediately with that value.    Example:

          $ans = <STDIN>;
          exit 0 if $ans =~ /^[Xx]/;

     See also die.  If EXPR is omitted, exits with 0 status.  The only
     universally recognized values for EXPR are 0 for success and 1 for
     error; other values are subject to interpretation depending on the
     environment in which the Perl program is running.  For example,
     exiting 69 (EX_UNAVAILABLE) from a sendmail incoming-mail filter will
     cause the mailer to return the item undelivered, but that's not true
     everywhere.

     Don't use exit to abort a subroutine if there's any chance that
     someone might want to trap whatever error happened.  Use die instead,
     which can be trapped by an eval.

     The exit() function does not always exit immediately.  It calls any
     defined END routines first, but these END routines may not themselves
     abort the exit.  Likewise any object destructors that need to be
     called are called before the real exit.  If this is a problem, you
     can call `POSIX:_exit($status)' to avoid END and destructor
     processing.  See *Note Perlmod: perlmod, for details.

exp EXPR
exp
     Returns e (the natural logarithm base) to the power of EXPR.  If EXPR
     is omitted, gives `exp($_)'.

fcntl FILEHANDLE,FUNCTION,SCALAR
     Implements the fcntl(2) function.  You'll probably have to say

          use Fcntl;

     first to get the correct constant definitions.  Argument processing
     and value return works just like ioctl below.  For example:

          use Fcntl;
          fcntl($filehandle, F_GETFL, $packed_return_buffer)
          	or die "can't fcntl F_GETFL: $!";

     You don't have to check for defined on the return from `fnctl'.  Like
     ioctl, it maps a 0 return from the system call into `"0 but true"' in
     Perl.  This string is true in boolean context and 0 in numeric
     context.  It is also exempt from the normal -w warnings on improper
     numeric conversions.

     Note that fcntl will produce a fatal error if used on a machine that
     doesn't implement fcntl(2).  See the Fcntl module or your fcntl(2)
     manpage to learn what functions are available on your system.

fileno FILEHANDLE
     Returns the file descriptor for a filehandle, or undefined if the
     filehandle is not open.  This is mainly useful for constructing
     bitmaps for select and low-level POSIX tty-handling operations.  If
     FILEHANDLE is an expression, the value is taken as an indirect
     filehandle, generally its name.

     You can use this to find out whether two handles refer to the same
     underlying descriptor:

          if (fileno(THIS) == fileno(THAT)) {
          	print "THIS and THAT are dups\n";
          }

flock FILEHANDLE,OPERATION
     Calls flock(2), or an emulation of it, on FILEHANDLE.  Returns true
     for success, false on failure.  Produces a fatal error if used on a
     machine that doesn't implement flock(2), fcntl(2) locking, or
     lockf(3).  flock is Perl's portable file locking interface, although
     it locks only entire files, not records.

     Two potentially non-obvious but traditional flock semantics are that
     it waits indefinitely until the lock is granted, and that its locks
     *merely advisory*.  Such discretionary locks are more flexible, but
     offer fewer guarantees.  This means that files locked with flock may
     be modified by programs that do not also use flock.  See *Note
     Perlport: perlport,, your port's specific documentation, or your
     system-specific local manpages for details.  It's best to assume
     traditional behavior if you're writing portable programs.  (But if
     you're not, you should as always feel perfectly free to write for
     your own system's idiosyncrasies (sometimes called "features").
     Slavish adherence to portability concerns shouldn't get in the way of
     your getting your job done.)

     OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined
     with LOCK_NB.  These constants are traditionally valued 1, 2, 8 and
     4, but you can use the symbolic names if you import them from the
     Fcntl module, either individually, or as a group using the ':flock'
     tag.  LOCK_SH requests a shared lock, LOCK_EX requests an exclusive
     lock, and LOCK_UN releases a previously requested lock.  If LOCK_NB
     is bitwise-or'ed with LOCK_SH or LOCK_EX then flock will return
     immediately rather than blocking waiting for the lock (check the
     return status to see if you got it).

     To avoid the possibility of miscoordination, Perl now flushes
     FILEHANDLE before locking or unlocking it.

     Note that the emulation built with lockf(3) doesn't provide shared
     locks, and it requires that FILEHANDLE be open with write intent.
     These are the semantics that lockf(3) implements.  Most if not all
     systems implement lockf(3) in terms of fcntl(2) locking, though, so
     the differing semantics shouldn't bite too many people.

     Note also that some versions of flock cannot lock things over the
     network; you would need to use the more system-specific fcntl for
     that.  If you like you can force Perl to ignore your system's flock(2)
     function, and so provide its own fcntl(2)-based emulation, by passing
     the switch `-Ud_flock' to the Configure program when you configure
     perl.

     Here's a mailbox appender for BSD systems.

          use Fcntl ':flock'; # import LOCK_* constants

          sub lock {
          	flock(MBOX,LOCK_EX);
          	# and, in case someone appended
          	# while we were waiting...
          	seek(MBOX, 0, 2);
          }

          sub unlock {
          	flock(MBOX,LOCK_UN);
          }

          open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")
          	    or die "Can't open mailbox: $!";

          lock();
          print MBOX $msg,"\n\n";
          unlock();

     On systems that support a real flock(), locks are inherited across
     fork() calls, whereas those that must resort to the more capricious
     fcntl() function lose the locks, making it harder to write servers.

     See also *Note DB_File: (pm.info)DB_File, for other flock() examples.

fork
     Does a fork(2) system call to create a new process running the same
     program at the same point.  It returns the child pid to the parent
     process, 0 to the child process, or undef if the fork is
     unsuccessful.  File descriptors (and sometimes locks on those
     descriptors) are shared, while everything else is copied.  On most
     systems supporting fork(), great care has gone into making it
     extremely efficient (for example, using copy-on-write technology on
     data pages), making it the dominant paradigm for multitasking over
     the last few decades.

     Beginning with v5.6.0, Perl will attempt to flush all files opened for
     output before forking the child process, but this may not be supported
     on some platforms (see *Note Perlport: perlport,).  To be safe, you
     may need to set $| ($AUTOFLUSH in English) or call the autoflush()
     method of IO::Handle on any open handles in order to avoid duplicate
     output.

     If you fork without ever waiting on your children, you will
     accumulate zombies.  On some systems, you can avoid this by setting
     `$SIG{CHLD}' to `"IGNORE"'.  See also *Note Perlipc: perlipc, for
     more examples of forking and reaping moribund children.

     Note that if your forked child inherits system file descriptors like
     STDIN and STDOUT that are actually connected by a pipe or socket, even
     if you exit, then the remote server (such as, say, a CGI script or a
     backgrounded job launched from a remote shell) won't think you're
     done.  You should reopen those to `/dev/null' if it's any issue.

format
     Declare a picture format for use by the write function.  For example:

          format Something =
          	Test: @<<<<<<<< @||||| @>>>>>
          	      $str,     $%,    '$' . int($num)
          .

          $str = "widget";
          $num = $cost/$quantity;
          $~ = 'Something';
          write;

     See *Note Perlform: perlform, for many details and examples.

formline PICTURE,LIST
     This is an internal function used by formats, though you may call it,
     too.  It formats (see *Note Perlform: perlform,) a list of values
     according to the contents of PICTURE, placing the output into the
     format output accumulator, $^A (or $ACCUMULATOR in English).
     Eventually, when a write is done, the contents of $^A are written to
     some filehandle, but you could also read $^A yourself and then set
     $^A back to "".  Note that a format typically does one formline per
     line of form, but the formline function itself doesn't care how many
     newlines are embedded in the PICTURE.  This means that the `~' and
     `~~' tokens will treat the entire PICTURE as a single line.  You may
     therefore need to use multiple formlines to implement a single record
     format, just like the format compiler.

     Be careful if you put double quotes around the picture, because an `@'
     character may be taken to mean the beginning of an array name.
     formline always returns true.  See *Note Perlform: perlform, for
     other examples.

getc FILEHANDLE
getc
     Returns the next character from the input file attached to FILEHANDLE,
     or the undefined value at end of file, or if there was an error.  If
     FILEHANDLE is omitted, reads from STDIN.  This is not particularly
     efficient.  However, it cannot be used by itself to fetch single
     characters without waiting for the user to hit enter.  For that, try
     something more like:

          if ($BSD_STYLE) {
          	system "stty cbreak </dev/tty >/dev/tty 2>&1";
          }
          else {
          	system "stty", '-icanon', 'eol', "\001";
          }

          $key = getc(STDIN);

          if ($BSD_STYLE) {
          	system "stty -cbreak </dev/tty >/dev/tty 2>&1";
          }
          else {
          	system "stty", 'icanon', 'eol', '^@'; # ASCII null
          }
          print "\n";

     Determination of whether $BSD_STYLE should be set is left as an
     exercise to the reader.

     The `POSIX::getattr' function can do this more portably on systems
     purporting POSIX compliance.  See also the Term::ReadKey module from
     your nearest CPAN site; details on CPAN can be found on `CPAN', *Note
     Perlmodlib: perlmodlib,.

getlogin
     Implements the C library function of the same name, which on most
     systems returns the current login from `/etc/utmp', if any.  If null,
     use getpwuid.

          $login = getlogin || getpwuid($<) || "Kilroy";

     Do not consider getlogin for authentication: it is not as secure as
     getpwuid.

getpeername SOCKET
     Returns the packed sockaddr address of other end of the SOCKET
     connection.

          use Socket;
          $hersockaddr    = getpeername(SOCK);
          ($port, $iaddr) = sockaddr_in($hersockaddr);
          $herhostname    = gethostbyaddr($iaddr, AF_INET);
          $herstraddr     = inet_ntoa($iaddr);

getpgrp PID
     Returns the current process group for the specified PID.  Use a PID
     of 0 to get the current process group for the current process.  Will
     raise an exception if used on a machine that doesn't implement
     getpgrp(2).  If PID is omitted, returns process group of current
     process.  Note that the POSIX version of getpgrp does not accept a
     PID argument, so only `PID==0' is truly portable.

getppid
     Returns the process id of the parent process.

getpriority WHICH,WHO
     Returns the current priority for a process, a process group, or a
     user.  (See `getpriority(2)' in this node.)  Will raise a fatal
     exception if used on a machine that doesn't implement getpriority(2).

getpwnam NAME
getgrnam NAME
gethostbyname NAME
getnetbyname NAME
getprotobyname NAME
getpwuid UID
getgrgid GID
getservbyname NAME,PROTO
gethostbyaddr ADDR,ADDRTYPE
getnetbyaddr ADDR,ADDRTYPE
getprotobynumber NUMBER
getservbyport PORT,PROTO
getpwent
getgrent
gethostent
getnetent
getprotoent
getservent
setpwent
setgrent
sethostent STAYOPEN
setnetent STAYOPEN
setprotoent STAYOPEN
setservent STAYOPEN
endpwent
endgrent
endhostent
endnetent
endprotoent
endservent
     These routines perform the same functions as their counterparts in the
     system library.  In list context, the return values from the various
     get routines are as follows:

          ($name,$passwd,$uid,$gid,
             $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*
          ($name,$passwd,$gid,$members) = getgr*
          ($name,$aliases,$addrtype,$length,@addrs) = gethost*
          ($name,$aliases,$addrtype,$net) = getnet*
          ($name,$aliases,$proto) = getproto*
          ($name,$aliases,$port,$proto) = getserv*

     (If the entry doesn't exist you get a null list.)

     The exact meaning of the $gcos field varies but it usually contains
     the real name of the user (as opposed to the login name) and other
     information pertaining to the user.  Beware, however, that in many
     system users are able to change this information and therefore it
     cannot be trusted and therefore the $gcos is is tainted (see *Note
     Perlsec: perlsec,).  The $passwd and $shell, user's encrypted
     password and login shell, are also tainted, because of the same
     reason.

     In scalar context, you get the name, unless the function was a lookup
     by name, in which case you get the other thing, whatever it is.  (If
     the entry doesn't exist you get the undefined value.)  For example:

          $uid   = getpwnam($name);
          $name  = getpwuid($num);
          $name  = getpwent();
          $gid   = getgrnam($name);
          $name  = getgrgid($num;
          $name  = getgrent();
          #etc.

     In *getpw*()* the fields $quota, $comment, and $expire are special
     cases in the sense that in many systems they are unsupported.  If the
     $quota is unsupported, it is an empty scalar.  If it is supported, it
     usually encodes the disk quota.  If the $comment field is unsupported,
     it is an empty scalar.  If it is supported it usually encodes some
     administrative comment about the user.  In some systems the $quota
     field may be $change or $age, fields that have to do with password
     aging.  In some systems the $comment field may be $class.  The $expire
     field, if present, encodes the expiration period of the account or the
     password.  For the availability and the exact meaning of these fields
     in your system, please consult your getpwnam(3) documentation and your
     `pwd.h' file.  You can also find out from within Perl what your
     $quota and $comment fields mean and whether you have the $expire field
     by using the Config module and the values `d_pwquota', `d_pwage',
     `d_pwchange', `d_pwcomment', and `d_pwexpire'.  Shadow password files
     are only supported if your vendor has implemented them in the
     intuitive fashion that calling the regular C library routines gets the
     shadow versions if you're running under privilege.  Those that
     incorrectly implement a separate library call are not supported.

     The $members value returned by *getgr*()* is a space separated list of
     the login names of the members of the group.

     For the *gethost*()* functions, if the `h_errno' variable is
     supported in C, it will be returned to you via $? if the function
     call fails.  The `@addrs' value returned by a successful call is a
     list of the raw addresses returned by the corresponding system
     library call.  In the Internet domain, each address is four bytes
     long and you can unpack it by saying something like:

          ($a,$b,$c,$d) = unpack('C4',$addr[0]);

     The Socket library makes this slightly easier:

          use Socket;
          $iaddr = inet_aton("127.1"); # or whatever address
          $name  = gethostbyaddr($iaddr, AF_INET);

          # or going the other way
          $straddr = inet_ntoa($iaddr);

     If you get tired of remembering which element of the return list
     contains which return value, by-name interfaces are provided in
     standard modules: File::stat, Net::hostent, Net::netent,
     Net::protoent, Net::servent, Time::gmtime, Time::localtime, and
     User::grent.  These override the normal built-ins, supplying versions
     that return objects with the appropriate names for each field.  For
     example:

          use File::stat;
          use User::pwent;
          $is_his = (stat($filename)->uid == pwent($whoever)->uid);

     Even though it looks like they're the same method calls (uid), they
     aren't, because a File::stat object is different from a User::pwent
     object.

getsockname SOCKET
     Returns the packed sockaddr address of this end of the SOCKET
     connection, in case you don't know the address because you have
     several different IPs that the connection might have come in on.

          use Socket;
          $mysockaddr = getsockname(SOCK);
          ($port, $myaddr) = sockaddr_in($mysockaddr);
          printf "Connect to %s [%s]\n",
             scalar gethostbyaddr($myaddr, AF_INET),
             inet_ntoa($myaddr);

getsockopt SOCKET,LEVEL,OPTNAME
     Returns the socket option requested, or undef if there is an error.

glob EXPR
glob
     Returns the value of EXPR with filename expansions such as the
     standard Unix shell `/bin/csh' would do.  This is the internal
     function implementing the `< <*.c' >> operator, but you can use it
     directly.  If EXPR is omitted, $_ is used.  The `< <*.c' >> operator
     is discussed in more detail in `"I', *Note Perlop: perlop,.

     Beginning with v5.6.0, this operator is implemented using the standard
     File::Glob extension.  See *Note File/Glob: (pm.info)File/Glob, for
     details.

gmtime EXPR
     Converts a time as returned by the time function to a 8-element list
     with the time localized for the standard Greenwich time zone.
     Typically used as follows:

          #  0    1    2     3     4    5     6     7
          ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday) =
          					    gmtime(time);

     All list elements are numeric, and come straight out of the C `struct
     tm'.  $sec, $min, and $hour are the seconds, minutes, and hours of the
     specified time.  $mday is the day of the month, and $mon is the month
     itself, in the range `0..11' with 0 indicating January and 11
     indicating December.  $year is the number of years since 1900.  That
     is, $year is 123 in year 2023.  $wday is the day of the week, with 0
     indicating Sunday and 3 indicating Wednesday.  $yday is the day of
     the year, in the range `1..365' (or `1..366' in leap years.)

     Note that the $year element is not simply the last two digits of the
     year.  If you assume it is, then you create non-Y2K-compliant
     programs-and you wouldn't want to do that, would you?

     The proper way to get a complete 4-digit year is simply:

          $year += 1900;

     And to get the last two digits of the year (e.g., '01' in 2001) do:

          $year = sprintf("%02d", $year % 100);

     If EXPR is omitted, `gmtime()' uses the current time (`gmtime(time)').

     In scalar context, `gmtime()' returns the ctime(3) value:

          $now_string = gmtime;  # e.g., "Thu Oct 13 04:54:34 1994"

     Also see the `timegm' function provided by the Time::Local module,
     and the strftime(3) function available via the POSIX module.

     This scalar value is not locale dependent (see *Note Perllocale:
     perllocale,), but is instead a Perl builtin.  Also see the
     Time::Local module, and the strftime(3) and mktime(3) functions
     available via the POSIX module.  To get somewhat similar but locale
     dependent date strings, set up your locale environment variables
     appropriately (please see *Note Perllocale: perllocale,) and try for
     example:

          use POSIX qw(strftime);
          $now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;

     Note that the `%a' and `%b' escapes, which represent the short forms
     of the day of the week and the month of the year, may not necessarily
     be three characters wide in all locales.

goto LABEL
goto EXPR
goto &NAME
     The `goto-LABEL' form finds the statement labeled with LABEL and
     resumes execution there.  It may not be used to go into any construct
     that requires initialization, such as a subroutine or a foreach loop.
     It also can't be used to go into a construct that is optimized away,
     or to get out of a block or subroutine given to sort.  It can be used
     to go almost anywhere else within the dynamic scope, including out of
     subroutines, but it's usually better to use some other construct such
     as last or die.  The author of Perl has never felt the need to use
     this form of goto (in Perl, that is-C is another matter).

     The `goto-EXPR' form expects a label name, whose scope will be
     resolved dynamically.  This allows for computed gotos per FORTRAN,
     but isn't necessarily recommended if you're optimizing for
     maintainability:

          goto ("FOO", "BAR", "GLARCH")[$i];

     The `goto-&NAME' form is quite different from the other forms of goto.
     In fact, it isn't a goto in the normal sense at all, and doesn't have
     the stigma associated with other gotos.  Instead, it substitutes a
     call to the named subroutine for the currently running subroutine.
     This is used by AUTOLOAD subroutines that wish to load another
     subroutine and then pretend that the other subroutine had been called
     in the first place (except that any modifications to `@_' in the
     current subroutine are propagated to the other subroutine.)  After
     the goto, not even caller will be able to tell that this routine was
     called first.

     NAME needn't be the name of a subroutine; it can be a scalar variable
     containing a code reference, or a block which evaluates to a code
     reference.

grep BLOCK LIST
grep EXPR,LIST
     This is similar in spirit to, but not the same as, grep(1) and its
     relatives.  In particular, it is not limited to using regular
     expressions.

     Evaluates the BLOCK or EXPR for each element of LIST (locally setting
     $_ to each element) and returns the list value consisting of those
     elements for which the expression evaluated to true.  In scalar
     context, returns the number of times the expression was true.

          @foo = grep(!/^#/, @bar);    # weed out comments

     or equivalently,

          @foo = grep {!/^#/} @bar;    # weed out comments

     Note that, because $_ is a reference into the list value, it can be
     used to modify the elements of the array.  While this is useful and
     supported, it can cause bizarre results if the LIST is not a named
     array.  Similarly, grep returns aliases into the original list, much
     as a for loop's index variable aliases the list elements.  That is,
     modifying an element of a list returned by grep (for example, in a
     foreach, map or another grep) actually modifies the element in the
     original list.  This is usually something to be avoided when writing
     clear code.

     See also `' in this node for a list composed of the results of the
     BLOCK or EXPR.

hex EXPR
hex
     Interprets EXPR as a hex string and returns the corresponding value.
     (To convert strings that might start with either 0, 0x, or 0b, see `'
     in this node.)  If EXPR is omitted, uses $_.

          print hex '0xAf'; # prints '175'
          print hex 'aF';   # same

     Hex strings may only represent integers.  Strings that would cause
     integer overflow trigger a warning.

import
     There is no builtin import function.  It is just an ordinary method
     (subroutine) defined (or inherited) by modules that wish to export
     names to another module.  The use function calls the import method
     for the package used.  See also `' in this node, *Note Perlmod:
     perlmod,, and *Note Exporter: (pm.info)Exporter,.

index STR,SUBSTR,POSITION
index STR,SUBSTR
     The index function searches for one string within another, but without
     the wildcard-like behavior of a full regular-expression pattern match.
     It returns the position of the first occurrence of SUBSTR in STR at
     or after POSITION.  If POSITION is omitted, starts searching from the
     beginning of the string.  The return value is based at 0 (or whatever
     you've set the $[ variable to-but don't do that).  If the substring
     is not found, returns one less than the base, ordinarily `-1'.

int EXPR
int
     Returns the integer portion of EXPR.  If EXPR is omitted, uses $_.
     You should not use this function for rounding: one because it
     truncates towards 0, and two because machine representations of
     floating point numbers can sometimes produce counterintuitive
     results.  For example, `int(-6.725/0.025)' produces -268 rather than
     the correct -269; that's because it's really more like
     -268.99999999999994315658 instead.  Usually, the sprintf, printf, or
     the `POSIX::floor' and `POSIX::ceil' functions will serve you better
     than will int().

ioctl FILEHANDLE,FUNCTION,SCALAR
     Implements the ioctl(2) function.  You'll probably first have to say

          require "ioctl.ph";	# probably in /usr/local/lib/perl/ioctl.ph

     to get the correct function definitions.  If `ioctl.ph' doesn't exist
     or doesn't have the correct definitions you'll have to roll your own,
     based on your C header files such as `< <sys/ioctl.h' >>.  (There is
     a Perl script called h2ph that comes with the Perl kit that may help
     you in this, but it's nontrivial.)  SCALAR will be read and/or
     written depending on the FUNCTION-a pointer to the string value of
     SCALAR will be passed as the third argument of the actual ioctl call.
     (If SCALAR has no string value but does have a numeric value, that
     value will be passed rather than a pointer to the string value.  To
     guarantee this to be true, add a 0 to the scalar before using it.)
     The pack and unpack functions may be needed to manipulate the values
     of structures used by ioctl.

     The return value of ioctl (and fcntl) is as follows:

          if OS returns:		then Perl returns:
              -1	  		  undefined value
               0	 		string "0 but true"
          anything else		    that number

     Thus Perl returns true on success and false on failure, yet you can
     still easily determine the actual value returned by the operating
     system:

          $retval = ioctl(...) || -1;
          printf "System returned %d\n", $retval;

     The special string "0 but true" is exempt from -w complaints about
     improper numeric conversions.

     Here's an example of setting a filehandle named REMOTE to be
     non-blocking at the system level.  You'll have to negotiate $| on
     your own, though.

          use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);

          $flags = fcntl(REMOTE, F_GETFL, 0)
                      or die "Can't get flags for the socket: $!\n";

          $flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
                      or die "Can't set flags for the socket: $!\n";

join EXPR,LIST
     Joins the separate strings of LIST into a single string with fields
     separated by the value of EXPR, and returns that new string.  Example:

          $rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);

     Beware that unlike split, join doesn't take a pattern as its first
     argument.  Compare `' in this node.

keys HASH
     Returns a list consisting of all the keys of the named hash.  (In
     scalar context, returns the number of keys.)  The keys are returned in
     an apparently random order.  The actual random order is subject to
     change in future versions of perl, but it is guaranteed to be the same
     order as either the values or each function produces (given that the
     hash has not been modified).  As a side effect, it resets HASH's
     iterator.

     Here is yet another way to print your environment:

          @keys = keys %ENV;
          @values = values %ENV;
          while (@keys) {
          	print pop(@keys), '=', pop(@values), "\n";
          }

     or how about sorted by key:

          foreach $key (sort(keys %ENV)) {
          	print $key, '=', $ENV{$key}, "\n";
          }

     To sort a hash by value, you'll need to use a sort function.  Here's
     a descending numeric sort of a hash by its values:

          foreach $key (sort { $hash{$b} <=> $hash{$a} } keys %hash) {
          	printf "%4d %s\n", $hash{$key}, $key;
          }

     As an lvalue keys allows you to increase the number of hash buckets
     allocated for the given hash.  This can gain you a measure of
     efficiency if you know the hash is going to get big.  (This is
     similar to pre-extending an array by assigning a larger number to
     $#array.)  If you say

          keys %hash = 200;

     then `%hash' will have at least 200 buckets allocated for it-256 of
     them, in fact, since it rounds up to the next power of two.  These
     buckets will be retained even if you do `%hash = ()', use `undef
     %hash' if you want to free the storage while `%hash' is still in
     scope.  You can't shrink the number of buckets allocated for the hash
     using keys in this way (but you needn't worry about doing this by
     accident, as trying has no effect).

     See also each, values and sort.

kill SIGNAL, LIST
     Sends a signal to a list of processes.  Returns the number of
     processes successfully signaled (which is not necessarily the same as
     the number actually killed).

          $cnt = kill 1, $child1, $child2;
          kill 9, @goners;

     If SIGNAL is zero, no signal is sent to the process.  This is a
     useful way to check that the process is alive and hasn't changed its
     UID.  See *Note Perlport: perlport, for notes on the portability of
     this construct.

     Unlike in the shell, if SIGNAL is negative, it kills process groups
     instead of processes.  (On System V, a negative PROCESS number will
     also kill process groups, but that's not portable.)  That means you
     usually want to use positive not negative signals.  You may also use
     a signal name in quotes.  See `"Signals"', *Note Perlipc: perlipc,
     for details.

last LABEL
last
     The last command is like the break statement in C (as used in loops);
     it immediately exits the loop in question.  If the LABEL is omitted,
     the command refers to the innermost enclosing loop.  The continue
     block, if any, is not executed:

          LINE: while (<STDIN>) {
          	last LINE if /^$/;	# exit when done with header
          	#...
          }

     last cannot be used to exit a block which returns a value such as
     `eval {}', `sub {}' or `do {}', and should not be used to exit a
     grep() or map() operation.

     Note that a block by itself is semantically identical to a loop that
     executes once.  Thus last can be used to effect an early exit out of
     such a block.

     See also `' in this node for an illustration of how last, next, and
     redo work.

lc EXPR
lc
     Returns an lowercased version of EXPR.  This is the internal function
     implementing the `\L' escape in double-quoted strings.  Respects
     current LC_CTYPE locale if `use locale' in force.  See *Note
     Perllocale: perllocale, and *Note Utf8: (pm.info)utf8,.

     If EXPR is omitted, uses $_.

lcfirst EXPR
lcfirst
     Returns the value of EXPR with the first character lowercased.  This
     is the internal function implementing the `\l' escape in
     double-quoted strings.  Respects current LC_CTYPE locale if `use
     locale' in force.  See *Note Perllocale: perllocale,.

     If EXPR is omitted, uses $_.

length EXPR
length
     Returns the length in characters of the value of EXPR.  If EXPR is
     omitted, returns length of $_.  Note that this cannot be used on an
     entire array or hash to find out how many elements these have.  For
     that, use `scalar @array' and `scalar keys %hash' respectively.

link OLDFILE,NEWFILE
     Creates a new filename linked to the old filename.  Returns true for
     success, false otherwise.

listen SOCKET,QUEUESIZE
     Does the same thing that the listen system call does.  Returns true if
     it succeeded, false otherwise.  See the example in `"Sockets:
     Client', *Note Perlipc: perlipc,.

local EXPR
     You really probably want to be using my instead, because local isn't
     what most people think of as "local".  See `"Private Variables via
     my()"', *Note Perlsub: perlsub, for details.

     A local modifies the listed variables to be local to the enclosing
     block, file, or eval.  If more than one value is listed, the list must
     be placed in parentheses.  See `"Temporary Values via local()"',
     *Note Perlsub: perlsub, for details, including issues with tied
     arrays and hashes.

localtime EXPR
     Converts a time as returned by the time function to a 9-element list
     with the time analyzed for the local time zone.  Typically used as
     follows:

          #  0    1    2     3     4    5     6     7     8
          ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
          						localtime(time);

     All list elements are numeric, and come straight out of the C `struct
     tm'.  $sec, $min, and $hour are the seconds, minutes, and hours of the
     specified time.  $mday is the day of the month, and $mon is the month
     itself, in the range `0..11' with 0 indicating January and 11
     indicating December.  $year is the number of years since 1900.  That
     is, $year is 123 in year 2023.  $wday is the day of the week, with 0
     indicating Sunday and 3 indicating Wednesday.  $yday is the day of
     the year, in the range `1..365' (or `1..366' in leap years.)  $isdst
     is true if the specified time occurs during daylight savings time,
     false otherwise.

     Note that the $year element is not simply the last two digits of the
     year.  If you assume it is, then you create non-Y2K-compliant
     programs-and you wouldn't want to do that, would you?

     The proper way to get a complete 4-digit year is simply:

          $year += 1900;

     And to get the last two digits of the year (e.g., '01' in 2001) do:

          $year = sprintf("%02d", $year % 100);

     If EXPR is omitted, `localtime()' uses the current time
     (`localtime(time)').

     In scalar context, `localtime()' returns the ctime(3) value:

          $now_string = localtime;  # e.g., "Thu Oct 13 04:54:34 1994"

     This scalar value is not locale dependent, see *Note Perllocale:
     perllocale,, but instead a Perl builtin.  Also see the Time::Local
     module (to convert the second, minutes, hours, ... back to seconds
     since the stroke of midnight the 1st of January 1970, the value
     returned by time()), and the strftime(3) and mktime(3) functions
     available via the POSIX module.  To get somewhat similar but locale
     dependent date strings, set up your locale environment variables
     appropriately (please see *Note Perllocale: perllocale,) and try for
     example:

          use POSIX qw(strftime);
          $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;

     Note that the `%a' and `%b', the short forms of the day of the week
     and the month of the year, may not necessarily be three characters
     wide.

lock
          lock I<THING>

     This function places an advisory lock on a variable, subroutine, or
     referenced object contained in *THING* until the lock goes out of
     scope.  This is a built-in function only if your version of Perl was
     built with threading enabled, and if you've said `use Threads'.
     Otherwise a user-defined function by this name will be called.  See
     `Thread' in this node.

log EXPR
log
     Returns the natural logarithm (base e) of EXPR.  If EXPR is omitted,
     returns log of $_.  To get the log of another base, use basic algebra:
     The base-N log of a number is equal to the natural log of that number
     divided by the natural log of N.  For example:

          sub log10 {
          	my $n = shift;
          	return log($n)/log(10);
          }

     See also `' in this node for the inverse operation.

lstat FILEHANDLE
lstat EXPR
lstat
     Does the same thing as the stat function (including setting the
     special _ filehandle) but stats a symbolic link instead of the file
     the symbolic link points to.  If symbolic links are unimplemented on
     your system, a normal stat is done.

     If EXPR is omitted, stats $_.

m//
     The match operator.  See *Note Perlop: perlop,.

map BLOCK LIST
map EXPR,LIST
     Evaluates the BLOCK or EXPR for each element of LIST (locally setting
     $_ to each element) and returns the list value composed of the
     results of each such evaluation.  In scalar context, returns the
     total number of elements so generated.  Evaluates BLOCK or EXPR in
     list context, so each element of LIST may produce zero, one, or more
     elements in the returned value.

          @chars = map(chr, @nums);

     translates a list of numbers to the corresponding characters.  And

          %hash = map { getkey($_) => $_ } @array;

     is just a funny way to write

          %hash = ();
          foreach $_ (@array) {
          	$hash{getkey($_)} = $_;
          }

     Note that, because $_ is a reference into the list value, it can be
     used to modify the elements of the array.  While this is useful and
     supported, it can cause bizarre results if the LIST is not a named
     array.  Using a regular foreach loop for this purpose would be
     clearer in most cases.  See also `' in this node for an array
     composed of those items of the original list for which the BLOCK or
     EXPR evaluates to true.

mkdir FILENAME,MASK
mkdir FILENAME
     Creates the directory specified by FILENAME, with permissions
     specified by MASK (as modified by umask).  If it succeeds it returns
     true, otherwise it returns false and sets $! (errno).  If omitted,
     MASK defaults to 0777.

     In general, it is better to create directories with permissive MASK,
     and let the user modify that with their umask, than it is to supply a
     restrictive MASK and give the user no way to be more permissive.  The
     exceptions to this rule are when the file or directory should be kept
     private (mail files, for instance).  The perlfunc(1) entry on umask
     discusses the choice of MASK in more detail.

msgctl ID,CMD,ARG
     Calls the System V IPC function msgctl(2).  You'll probably have to
     say

          use IPC::SysV;

     first to get the correct constant definitions.  If CMD is `IPC_STAT',
     then ARG must be a variable which will hold the returned `msqid_ds'
     structure.  Returns like ioctl: the undefined value for error, `"0
     but true"' for zero, or the actual return value otherwise.  See also
     IPC::SysV and IPC::Semaphore documentation.

msgget KEY,FLAGS
     Calls the System V IPC function msgget(2).  Returns the message queue
     id, or the undefined value if there is an error.  See also IPC::SysV
     and IPC::Msg documentation.

msgrcv ID,VAR,SIZE,TYPE,FLAGS
     Calls the System V IPC function msgrcv to receive a message from
     message queue ID into variable VAR with a maximum message size of
     SIZE.  Note that when a message is received, the message type as a
     native long integer will be the first thing in VAR, followed by the
     actual message.  This packing may be opened with `unpack("l! a*")'.
     Taints the variable.  Returns true if successful, or false if there is
     an error.  See also IPC::SysV and `IPC::SysV::Msg' documentation.

msgsnd ID,MSG,FLAGS
     Calls the System V IPC function msgsnd to send the message MSG to the
     message queue ID.  MSG must begin with the native long integer message
     type, and be followed by the length of the actual message, and finally
     the message itself.  This kind of packing can be achieved with
     `pack("l! a*", $type, $message)'.  Returns true if successful, or
     false if there is an error.  See also IPC::SysV and `IPC::SysV::Msg'
     documentation.

my EXPR
my EXPR : ATTRIBUTES
     A my declares the listed variables to be local (lexically) to the
     enclosing block, file, or eval.  If more than one value is listed,
     the list must be placed in parentheses.  See `"Private Variables via
     my()"', *Note Perlsub: perlsub, for details.

next LABEL
next
     The next command is like the continue statement in C; it starts the
     next iteration of the loop:

          LINE: while (<STDIN>) {
          	next LINE if /^#/;	# discard comments
          	#...
          }

     Note that if there were a continue block on the above, it would get
     executed even on discarded lines.  If the LABEL is omitted, the
     command refers to the innermost enclosing loop.

     next cannot be used to exit a block which returns a value such as
     `eval {}', `sub {}' or `do {}', and should not be used to exit a
     grep() or map() operation.

     Note that a block by itself is semantically identical to a loop that
     executes once.  Thus next will exit such a block early.

     See also `' in this node for an illustration of how last, next, and
     redo work.

no Module LIST
     See the `' in this node function, which no is the opposite of.

oct EXPR
oct
     Interprets EXPR as an octal string and returns the corresponding
     value.  (If EXPR happens to start off with `0x', interprets it as a
     hex string.  If EXPR starts off with `0b', it is interpreted as a
     binary string.)  The following will handle decimal, binary, octal, and
     hex in the standard Perl or C notation:

          $val = oct($val) if $val =~ /^0/;

     If EXPR is omitted, uses $_.   To go the other way (produce a number
     in octal), use sprintf() or printf():

          $perms = (stat("filename"))[2] & 07777;
          $oct_perms = sprintf "%lo", $perms;

     The oct() function is commonly used when a string such as `644' needs
     to be converted into a file mode, for example. (Although perl will
     automatically convert strings into numbers as needed, this automatic
     conversion assumes base 10.)

open FILEHANDLE,MODE,LIST
open FILEHANDLE,EXPR
open FILEHANDLE
     Opens the file whose filename is given by EXPR, and associates it with
     FILEHANDLE.  If FILEHANDLE is an expression, its value is used as the
     name of the real filehandle wanted.  (This is considered a symbolic
     reference, so `use strict 'refs'' should not be in effect.)

     If EXPR is omitted, the scalar variable of the same name as the
     FILEHANDLE contains the filename.  (Note that lexical variables-those
     declared with my-will not work for this purpose; so if you're using
     my, specify EXPR in your call to open.)  See *Note Perlopentut:
     perlopentut, for a kinder, gentler explanation of opening files.

     If MODE is `< '<' '> or nothing, the file is opened for input.  If
     MODE is `< ''' >>, the file is truncated and opened for output, being
     created if necessary.  If MODE is `<< ''>' >>>, the file is opened
     for appending, again being created if necessary.  You can put a '+'
     in front of the `< ''' >> or `< '<' '> to indicate that you want both
     read and write access to the file; thus `< '+<' '> is almost always
     preferred for read/write updates-the `< '+'' >> mode would clobber the
     file first.  You can't usually use either read-write mode for updating
     textfiles, since they have variable length records.  See the -i
     switch in *Note Perlrun: perlrun, for a better approach.  The file is
     created with permissions of `0666' modified by the process' umask
     value.

     These various prefixes correspond to the fopen(3) modes of `'r'',
     `'r+'', 'w', `'w+'', 'a', and `'a+''.

     In the 2-arguments (and 1-argument) form of the call the mode and
     filename should be concatenated (in this order), possibly separated by
     spaces.  It is possible to omit the mode if the mode is `< '<' '>.

     If the filename begins with '|', the filename is interpreted as a
     command to which output is to be piped, and if the filename ends with
     a '|', the filename is interpreted as a command which pipes output to
     us.  See `"Using open() for IPC"', *Note Perlipc: perlipc, for more
     examples of this.  (You are not allowed to open to a command that
     pipes both in and out, but see `"Using open() for IPC"', *Note
     IPC/Open2: (pm.info)IPC/Open2,, `"Using open() for IPC"', *Note
     IPC/Open3: (pm.info)IPC/Open3,, and `"Bidirectional Communication
     with Another Process"', *Note Perlipc: perlipc, for alternatives.)

     If MODE is `'|-'', the filename is interpreted as a command to which
     output is to be piped, and if MODE is `'-|'', the filename is
     interpreted as a command which pipes output to us.  In the
     2-arguments (and 1-argument) form one should replace dash ('-') with
     the command.  See `"Using open() for IPC"', *Note Perlipc: perlipc,
     for more examples of this.  (You are not allowed to open to a command
     that pipes both in and out, but see `"Using open() for IPC"', *Note
     IPC/Open2: (pm.info)IPC/Open2,, `"Using open() for IPC"', *Note
     IPC/Open3: (pm.info)IPC/Open3,, and `"Bidirectional Communication"',
     *Note Perlipc: perlipc, for alternatives.)

     In the 2-arguments (and 1-argument) form opening '-' opens STDIN and
     opening `< ''-' >> opens STDOUT.

     Open returns nonzero upon success, the undefined value otherwise.  If
     the open involved a pipe, the return value happens to be the pid of
     the subprocess.

     If you're unfortunate enough to be running Perl on a system that
     distinguishes between text files and binary files (modern operating
     systems don't care), then you should check out `' in this node for
     tips for dealing with this.  The key distinction between systems that
     need binmode and those that don't is their text file formats.
     Systems like Unix, MacOS, and Plan9, which delimit lines with a
     single character, and which encode that character in C as `"\n"', do
     not need binmode.  The rest need it.

     When opening a file, it's usually a bad idea to continue normal
     execution if the request failed, so open is frequently used in
     connection with die.  Even if die won't do what you want (say, in a
     CGI script, where you want to make a nicely formatted error message
     (but there are modules that can help with that problem)) you should
     always check the return value from opening a file.  The infrequent
     exception is when working with an unopened filehandle is actually
     what you want to do.

     Examples:

          $ARTICLE = 100;
          open ARTICLE or die "Can't find article $ARTICLE: $!\n";
          while (<ARTICLE>) {...

          open(LOG, '>>/usr/spool/news/twitlog');	# (log is reserved)
          # if the open fails, output is discarded

          open(DBASE, '+<', 'dbase.mine')		# open for update
          	or die "Can't open 'dbase.mine' for update: $!";

          open(DBASE, '+<dbase.mine')			# ditto
          	or die "Can't open 'dbase.mine' for update: $!";

          open(ARTICLE, '-|', "caesar <$article")     # decrypt article
          	or die "Can't start caesar: $!";

          open(ARTICLE, "caesar <$article |")		# ditto
          	or die "Can't start caesar: $!";

          open(EXTRACT, "|sort >/tmp/Tmp$$")		# $$ is our process id
          	or die "Can't start sort: $!";

          # process argument list of files along with any includes

          foreach $file (@ARGV) {
          	process($file, 'fh00');
          }

          sub process {
          	my($filename, $input) = @_;
          	$input++;		# this is a string increment
          	unless (open($input, $filename)) {
          	    print STDERR "Can't open $filename: $!\n";
          	    return;
          	}

          local $_;
          while (<$input>) {		# note use of indirection
              if (/^#include "(.*)"/) {
          	process($1, $input);
          	next;
              }
              #...		# whatever
          }
              }

     You may also, in the Bourne shell tradition, specify an EXPR beginning
     with `< ''&' >>, in which case the rest of the string is interpreted
     as the name of a filehandle (or file descriptor, if numeric) to be
     duped and opened.  You may use & after `< ' >>, `<< '> >>>, `< < '>,
     `< +' >>, `<< +'> >>>, and `< +< '>.  The mode you specify should
     match the mode of the original filehandle.  (Duping a filehandle does
     not take into account any existing contents of stdio buffers.)
     Duping file handles is not yet supported for 3-argument open().

     Here is a script that saves, redirects, and restores STDOUT and
     STDERR:

          #!/usr/bin/perl
          open(OLDOUT, ">&STDOUT");
          open(OLDERR, ">&STDERR");

          open(STDOUT, '>', "foo.out") || die "Can't redirect stdout";
          open(STDERR, ">&STDOUT")     || die "Can't dup stdout";

          select(STDERR); $| = 1;	# make unbuffered
          select(STDOUT); $| = 1;	# make unbuffered

          print STDOUT "stdout 1\n";	# this works for
          print STDERR "stderr 1\n"; 	# subprocesses too

          close(STDOUT);
          close(STDERR);

          open(STDOUT, ">&OLDOUT");
          open(STDERR, ">&OLDERR");

          print STDOUT "stdout 2\n";
          print STDERR "stderr 2\n";

     If you specify `< '<&=N' '>, where N is a number, then Perl will do an
     equivalent of C's fdopen of that file descriptor; this is more
     parsimonious of file descriptors.  For example:

          open(FILEHANDLE, "<&=$fd")

     Note that this feature depends on the fdopen() C library function.
     On many UNIX systems, fdopen() is known to fail when file descriptors
     exceed a certain value, typically 255. If you need more file
     descriptors than that, consider rebuilding Perl to use the `sfio'
     library.

     If you open a pipe on the command '-', i.e., either `'|-'' or `'-|''
     with 2-arguments (or 1-argument) form of open(), then there is an
     implicit fork done, and the return value of open is the pid of the
     child within the parent process, and 0 within the child process.
     (Use `defined($pid)' to determine whether the open was successful.)
     The filehandle behaves normally for the parent, but i/o to that
     filehandle is piped from/to the STDOUT/STDIN of the child process.
     In the child process the filehandle isn't opened-i/o happens from/to
     the new STDOUT or STDIN.  Typically this is used like the normal
     piped open when you want to exercise more control over just how the
     pipe command gets executed, such as when you are running setuid, and
     don't want to have to scan shell commands for metacharacters.  The
     following triples are more or less equivalent:

          open(FOO, "|tr '[a-z]' '[A-Z]'");
          open(FOO, '|-', "tr '[a-z]' '[A-Z]'");
          open(FOO, '|-') || exec 'tr', '[a-z]', '[A-Z]';

          open(FOO, "cat -n '$file'|");
          open(FOO, '-|', "cat -n '$file'");
          open(FOO, '-|') || exec 'cat', '-n', $file;

     See `"Safe Pipe Opens"', *Note Perlipc: perlipc, for more examples of
     this.

     Beginning with v5.6.0, Perl will attempt to flush all files opened for
     output before any operation that may do a fork, but this may not be
     supported on some platforms (see *Note Perlport: perlport,).  To be
     safe, you may need to set $| ($AUTOFLUSH in English) or call the
     autoflush() method of IO::Handle on any open handles.

     On systems that support a close-on-exec flag on files, the flag will
     be set for the newly opened file descriptor as determined by the
     value of $^F.  See `$^F', *Note Perlvar: perlvar,.

     Closing any piped filehandle causes the parent process to wait for the
     child to finish, and returns the status value in $?.

     The filename passed to 2-argument (or 1-argument) form of open() will
     have leading and trailing whitespace deleted, and the normal
     redirection characters honored.  This property, known as "magic open",
     can often be used to good effect.  A user could specify a filename of
     `"rsh cat file |"', or you could change certain filenames as needed:

          $filename =~ s/(.*\.gz)\s*$/gzip -dc < $1|/;
          open(FH, $filename) or die "Can't open $filename: $!";

     Use 3-argument form to open a file with arbitrary weird characters in
     it,

          open(FOO, '<', $file);

     otherwise it's necessary to protect any leading and trailing
     whitespace:

          $file =~ s#^(\s)#./$1#;
          open(FOO, "< $file\0");

     (this may not work on some bizzare filesystems).  One should
     conscientiously choose between the the magic and 3-arguments form of
     open():

          open IN, $ARGV[0];

     will allow the user to specify an argument of the form `"rsh cat file
     |"', but will not work on a filename which happens to have a trailing
     space, while

          open IN, '<', $ARGV[0];

     will have exactly the opposite restrictions.

     If you want a "real" C open (see `open(2)' in this node on your
     system), then you should use the sysopen function, which involves no
     such magic (but may use subtly different filemodes than Perl open(),
     which is mapped to C fopen()).  This is another way to protect your
     filenames from interpretation.  For example:

          use IO::Handle;
          sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)
          	or die "sysopen $path: $!";
          $oldfh = select(HANDLE); $| = 1; select($oldfh);
          print HANDLE "stuff $$\n");
          seek(HANDLE, 0, 0);
          print "File contains: ", <HANDLE>;

     Using the constructor from the IO::Handle package (or one of its
     subclasses, such as IO::File or IO::Socket), you can generate
     anonymous filehandles that have the scope of whatever variables hold
     references to them, and automatically close whenever and however you
     leave that scope:

          use IO::File;
          #...
          sub read_myfile_munged {
          	my $ALL = shift;
          	my $handle = new IO::File;
          	open($handle, "myfile") or die "myfile: $!";
          	$first = <$handle>
          	    or return ();     # Automatically closed here.
          	mung $first or die "mung failed";	# Or here.
          	return $first, <$handle> if $ALL;	# Or here.
          	$first;					# Or here.
          }

     See `' in this node for some details about mixing reading and writing.

opendir DIRHANDLE,EXPR
     Opens a directory named EXPR for processing by readdir, telldir,
     seekdir, rewinddir, and closedir.  Returns true if successful.
     DIRHANDLEs have their own namespace separate from FILEHANDLEs.

ord EXPR
ord
     Returns the numeric (ASCII or Unicode) value of the first character
     of EXPR.  If EXPR is omitted, uses $_.  For the reverse, see `' in
     this node.  See *Note Utf8: (pm.info)utf8, for more about Unicode.

our EXPR
     An our declares the listed variables to be valid globals within the
     enclosing block, file, or eval.  That is, it has the same scoping
     rules as a "my" declaration, but does not create a local variable.
     If more than one value is listed, the list must be placed in
     parentheses.  The our declaration has no semantic effect unless "use
     strict vars" is in effect, in which case it lets you use the declared
     global variable without qualifying it with a package name.  (But only
     within the lexical scope of the our declaration.  In this it differs
     from "use vars", which is package scoped.)

     An our declaration declares a global variable that will be visible
     across its entire lexical scope, even across package boundaries.  The
     package in which the variable is entered is determined at the point
     of the declaration, not at the point of use.  This means the following
     behavior holds:

          package Foo;
          our $bar;		# declares $Foo::bar for rest of lexical scope
          $bar = 20;

          package Bar;
          print $bar;		# prints 20

     Multiple our declarations in the same lexical scope are allowed if
     they are in different packages.  If they happened to be in the same
     package, Perl will emit warnings if you have asked for them.

          use warnings;
          package Foo;
          our $bar;		# declares $Foo::bar for rest of lexical scope
          $bar = 20;

          package Bar;
          our $bar = 30;	# declares $Bar::bar for rest of lexical scope
          print $bar;		# prints 30

          our $bar;		# emits warning

pack TEMPLATE,LIST
     Takes a LIST of values and converts it into a string using the rules
     given by the TEMPLATE.  The resulting string is the concatenation of
     the converted values.  Typically, each converted value looks like its
     machine-level representation.  For example, on 32-bit machines a
     converted integer may be represented by a sequence of 4 bytes.

     The TEMPLATE is a sequence of characters that give the order and type
     of values, as follows:

          a	A string with arbitrary binary data, will be null padded.
          A	An ascii string, will be space padded.
          Z	A null terminated (asciz) string, will be null padded.

          b	A bit string (ascending bit order inside each byte, like vec()).
          B	A bit string (descending bit order inside each byte).
          h	A hex string (low nybble first).
          H	A hex string (high nybble first).

          c	A signed char value.
          C	An unsigned char value.  Only does bytes.  See U for Unicode.

          s	A signed short value.
          S	An unsigned short value.
          	  (This 'short' is _exactly_ 16 bits, which may differ from
          	   what a local C compiler calls 'short'.  If you want
          	   native-length shorts, use the '!' suffix.)

          i	A signed integer value.
          I	An unsigned integer value.
          	  (This 'integer' is _at_least_ 32 bits wide.  Its exact
                 size depends on what a local C compiler calls 'int',
                 and may even be larger than the 'long' described in
                 the next item.)

          l	A signed long value.
          L	An unsigned long value.
          	  (This 'long' is _exactly_ 32 bits, which may differ from
          	   what a local C compiler calls 'long'.  If you want
          	   native-length longs, use the '!' suffix.)

          n	An unsigned short in "network" (big-endian) order.
          N	An unsigned long in "network" (big-endian) order.
          v	An unsigned short in "VAX" (little-endian) order.
          V	An unsigned long in "VAX" (little-endian) order.
          	  (These 'shorts' and 'longs' are _exactly_ 16 bits and
          	   _exactly_ 32 bits, respectively.)

          q	A signed quad (64-bit) value.
          Q	An unsigned quad value.
          	  (Quads are available only if your system supports 64-bit
          	   integer values _and_ if Perl has been compiled to support those.
                 Causes a fatal error otherwise.)

          f	A single-precision float in the native format.
          d	A double-precision float in the native format.

          p	A pointer to a null-terminated string.
          P	A pointer to a structure (fixed-length string).

          u	A uuencoded string.
          U	A Unicode character number.  Encodes to UTF-8 internally.
          	Works even if C<use utf8> is not in effect.

          w	A BER compressed integer.  Its bytes represent an unsigned
          	integer in base 128, most significant digit first, with as
              few digits as possible.  Bit eight (the high bit) is set
              on each byte except the last.

          x	A null byte.
          X	Back up a byte.
          @	Null fill to absolute position.

     The following rules apply:

        * Each letter may optionally be followed by a number giving a
          repeat count.  With all types except a, A, `Z', b, B, h, H, and
          P the pack function will gobble up that many values from the
          LIST.  A * for the repeat count means to use however many items
          are left, except for `@', x, X, where it is equivalent to 0, and
          u, where it is equivalent to 1 (or 45, what is the same).

          When used with `Z', * results in the addition of a trailing null
          byte (so the packed result will be one longer than the byte
          length of the item).

          The repeat count for u is interpreted as the maximal number of
          bytes to encode per line of output, with 0 and 1 replaced by 45.

        * The a, A, and `Z' types gobble just one value, but pack it as a
          string of length count, padding with nulls or spaces as
          necessary.  When unpacking, A strips trailing spaces and nulls,
          `Z' strips everything after the first null, and a returns data
          verbatim.  When packing, a, and `Z' are equivalent.

          If the value-to-pack is too long, it is truncated.  If too long
          and an explicit count is provided, `Z' packs only `$count-1'
          bytes, followed by a null byte.  Thus `Z' always packs a
          trailing null byte under all circumstances.

        * Likewise, the b and B fields pack a string that many bits long.
          Each byte of the input field of pack() generates 1 bit of the
          result.  Each result bit is based on the least-significant bit
          of the corresponding input byte, i.e., on `ord($byte)%2'.  In
          particular, bytes `"0"' and `"1"' generate bits 0 and 1, as do
          bytes `"\0"' and `"\1"'.

          Starting from the beginning of the input string of pack(), each
          8-tuple of bytes is converted to 1 byte of output.  With format b
          the first byte of the 8-tuple determines the least-significant
          bit of a byte, and with format B it determines the
          most-significant bit of a byte.

          If the length of the input string is not exactly divisible by 8,
          the remainder is packed as if the input string were padded by
          null bytes at the end.  Similarly, during unpack()ing the
          "extra" bits are ignored.

          If the input string of pack() is longer than needed, extra bytes
          are ignored.  A * for the repeat count of pack() means to use
          all the bytes of the input field.  On unpack()ing the bits are
          converted to a string of `"0"'s and `"1"'s.

        * The h and H fields pack a string that many nybbles (4-bit groups,
          representable as hexadecimal digits, 0-9a-f) long.

          Each byte of the input field of pack() generates 4 bits of the
          result.  For non-alphabetical bytes the result is based on the 4
          least-significant bits of the input byte, i.e., on
          `ord($byte)%16'.  In particular, bytes `"0"' and `"1"' generate
          nybbles 0 and 1, as do bytes `"\0"' and `"\1"'.  For bytes
          `"a".."f"' and `"A".."F"' the result is compatible with the
          usual hexadecimal digits, so that `"a"' and `"A"' both generate
          the nybble `0xa==10'.  The result for bytes `"g".."z"' and
          `"G".."Z"' is not well-defined.

          Starting from the beginning of the input string of pack(), each
          pair of bytes is converted to 1 byte of output.  With format h
          the first byte of the pair determines the least-significant
          nybble of the output byte, and with format H it determines the
          most-significant nybble.

          If the length of the input string is not even, it behaves as if
          padded by a null byte at the end.  Similarly, during unpack()ing
          the "extra" nybbles are ignored.

          If the input string of pack() is longer than needed, extra bytes
          are ignored.  A * for the repeat count of pack() means to use
          all the bytes of the input field.  On unpack()ing the bits are
          converted to a string of hexadecimal digits.

        * The p type packs a pointer to a null-terminated string.  You are
          responsible for ensuring the string is not a temporary value
          (which can potentially get deallocated before you get around to
          using the packed result).  The P type packs a pointer to a
          structure of the size indicated by the length.  A NULL pointer
          is created if the corresponding value for p or P is undef,
          similarly for unpack().

        * The / template character allows packing and unpacking of strings
          where the packed structure contains a byte count followed by the
          string itself.  You write *length-item*/*string-item*.

          The *length-item* can be any pack template letter, and describes
          how the length value is packed.  The ones likely to be of most
          use are integer-packing ones like n (for Java strings), w (for
          ASN.1 or SNMP) and N (for Sun XDR).

          The *string-item* must, at present, be `"A*"', `"a*"' or `"Z*"'.
          For unpack the length of the string is obtained from the
          *length-item*, but if you put in the '*' it will be ignored.

               unpack 'C/a', "\04Gurusamy";        gives 'Guru'
               unpack 'a3/A* A*', '007 Bond  J ';  gives (' Bond','J')
               pack 'n/a* w/a*','hello,','world';  gives "\000\006hello,\005world"

          The *length-item* is not returned explicitly from unpack.

          Adding a count to the *length-item* letter is unlikely to do
          anything useful, unless that letter is A, a or `Z'.  Packing
          with a *length-item* of a or `Z' may introduce `"\000"'
          characters, which Perl does not regard as legal in numeric
          strings.

        * The integer types s, S, l, and L may be immediately followed by
          a ! suffix to signify native shorts or longs-as you can see from
          above for example a bare l does mean exactly 32 bits, the native
          long (as seen by the local C compiler) may be larger.  This is
          an issue mainly in 64-bit platforms.  You can see whether using
          ! makes any difference by

               print length(pack("s")), " ", length(pack("s!")), "\n";
               print length(pack("l")), " ", length(pack("l!")), "\n";

          `i!' and `I!' also work but only because of completeness; they
          are identical to i and I.

          The actual sizes (in bytes) of native shorts, ints, longs, and
          long longs on the platform where Perl was built are also
          available via *Note Config: (pm.info)Config,:

               use Config;
               print $Config{shortsize},    "\n";
               print $Config{intsize},      "\n";
               print $Config{longsize},     "\n";
               print $Config{longlongsize}, "\n";

          (The `$Config{longlongsize}' will be undefine if your system does
          not support long longs.)

        * The integer formats s, S, i, I, l, and L are inherently
          non-portable between processors and operating systems because
          they obey the native byteorder and endianness.  For example a
          4-byte integer 0x12345678 (305419896 decimal) be ordered natively
          (arranged in and handled by the CPU registers) into bytes as

               0x12 0x34 0x56 0x78	# little-endian
               0x78 0x56 0x34 0x12	# big-endian

          Basically, the Intel, Alpha, and VAX CPUs are little-endian,
          while everybody else, for example Motorola m68k/88k, PPC, Sparc,
          HP PA, Power, and Cray are big-endian.  MIPS can be either:
          Digital used it in little-endian mode; SGI uses it in big-endian
          mode.

          The names `big-endian' and `little-endian' are comic references
          to the classic "Gulliver's Travels" (via the paper "On Holy Wars
          and a Plea for Peace" by Danny Cohen, USC/ISI IEN 137, April 1,
          1980) and the egg-eating habits of the Lilliputians.

          Some systems may have even weirder byte orders such as

               0x56 0x78 0x12 0x34
               0x34 0x12 0x78 0x56

          You can see your system's preference with

               print join(" ", map { sprintf "%#02x", $_ }
                                           unpack("C*",pack("L",0x12345678))), "\n";

          The byteorder on the platform where Perl was built is also
          available via *Note Config: (pm.info)Config,:

               use Config;
               print $Config{byteorder}, "\n";

          Byteorders `'1234'' and `'12345678'' are little-endian, `'4321''
          and `'87654321'' are big-endian.

          If you want portable packed integers use the formats n, N, v,
          and V, their byte endianness and size is known.  See also *Note
          Perlport: perlport,.

        * Real numbers (floats and doubles) are in the native machine
          format only; due to the multiplicity of floating formats around,
          and the lack of a standard "network" representation, no facility
          for interchange has been made.  This means that packed floating
          point data written on one machine may not be readable on another
          - even if both use IEEE floating point arithmetic (as the
          endian-ness of the memory representation is not part of the IEEE
          spec).  See also *Note Perlport: perlport,.

          Note that Perl uses doubles internally for all numeric
          calculation, and converting from double into float and thence
          back to double again will lose precision (i.e., `unpack("f",
          pack("f", $foo)') will not in general equal $foo).

        * You must yourself do any alignment or padding by inserting for
          example enough 'x'es while packing.  There is no way to pack()
          and unpack() could know where the bytes are going to or coming
          from.  Therefore pack (and unpack) handle their output and input
          as flat sequences of bytes.

        * A comment in a TEMPLATE starts with `#' and goes to the end of
          line.

        * If TEMPLATE requires more arguments to pack() than actually
          given, pack() assumes additional "" arguments.  If TEMPLATE
          requires less arguments to pack() than actually given, extra
          arguments are ignored.

     Examples:

          $foo = pack("CCCC",65,66,67,68);
          # foo eq "ABCD"
          $foo = pack("C4",65,66,67,68);
          # same thing
          $foo = pack("U4",0x24b6,0x24b7,0x24b8,0x24b9);
          # same thing with Unicode circled letters

          $foo = pack("ccxxcc",65,66,67,68);
          # foo eq "AB\0\0CD"

          # note: the above examples featuring "C" and "c" are true
          # only on ASCII and ASCII-derived systems such as ISO Latin 1
          # and UTF-8.  In EBCDIC the first example would be
          # $foo = pack("CCCC",193,194,195,196);

          $foo = pack("s2",1,2);
          # "\1\0\2\0" on little-endian
          # "\0\1\0\2" on big-endian

          $foo = pack("a4","abcd","x","y","z");
          # "abcd"

          $foo = pack("aaaa","abcd","x","y","z");
          # "axyz"

          $foo = pack("a14","abcdefg");
          # "abcdefg\0\0\0\0\0\0\0"

          $foo = pack("i9pl", gmtime);
          # a real struct tm (on my system anyway)

          $utmp_template = "Z8 Z8 Z16 L";
          $utmp = pack($utmp_template, @utmp1);
          # a struct utmp (BSDish)

          @utmp2 = unpack($utmp_template, $utmp);
          # "@utmp1" eq "@utmp2"

          sub bintodec {
          	unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
          }

          $foo = pack('sx2l', 12, 34);
          # short 12, two zero bytes padding, long 34
          $bar = pack('s@4l', 12, 34);
          # short 12, zero fill to position 4, long 34
          # $foo eq $bar

     The same template may generally also be used in unpack().

package
package NAMESPACE
     Declares the compilation unit as being in the given namespace.  The
     scope of the package declaration is from the declaration itself
     through the end of the enclosing block, file, or eval (the same as
     the my operator).  All further unqualified dynamic identifiers will
     be in this namespace.  A package statement affects only dynamic
     variables-including those you've used local on-but not lexical
     variables, which are created with my.  Typically it would be the
     first declaration in a file to be included by the require or use
     operator.  You can switch into a package in more than one place; it
     merely influences which symbol table is used by the compiler for the
     rest of that block.  You can refer to variables and filehandles in
     other packages by prefixing the identifier with the package name and
     a double colon:  `$Package::Variable'.  If the package name is null,
     the main package as assumed.  That is, `$::sail' is equivalent to
     `$main::sail' (as well as to `$main'sail', still seen in older code).

     If NAMESPACE is omitted, then there is no current package, and all
     identifiers must be fully qualified or lexicals.  This is stricter
     than `use strict', since it also extends to function names.

     See `"Packages"', *Note Perlmod: perlmod, for more information about
     packages, modules, and classes.  See `"Packages"', *Note Perlsub:
     perlsub, for other scoping issues.

pipe READHANDLE,WRITEHANDLE
     Opens a pair of connected pipes like the corresponding system call.
     Note that if you set up a loop of piped processes, deadlock can occur
     unless you are very careful.  In addition, note that Perl's pipes use
     stdio buffering, so you may need to set $| to flush your WRITEHANDLE
     after each command, depending on the application.

     See *Note IPC/Open2: (pm.info)IPC/Open2,, *Note IPC/Open3:
     (pm.info)IPC/Open3,, and `"Bidirectional Communication"', *Note
     Perlipc: perlipc, for examples of such things.

     On systems that support a close-on-exec flag on files, the flag will
     be set for the newly opened file descriptors as determined by the
     value of $^F.  See `$^F', *Note Perlvar: perlvar,.

pop ARRAY
pop
     Pops and returns the last value of the array, shortening the array by
     one element.  Has an effect similar to

          $ARRAY[$#ARRAY--]

     If there are no elements in the array, returns the undefined value
     (although this may happen at other times as well).  If ARRAY is
     omitted, pops the `@ARGV' array in the main program, and the `@_'
     array in subroutines, just like shift.

pos SCALAR
pos
     Returns the offset of where the last `m//g' search left off for the
     variable is in question ($_ is used when the variable is not
     specified).  May be modified to change that offset.  Such
     modification will also influence the `\G' zero-width assertion in
     regular expressions.  See *Note Perlre: perlre, and *Note Perlop:
     perlop,.

print FILEHANDLE LIST
print LIST
print
     Prints a string or a list of strings.  Returns true if successful.
     FILEHANDLE may be a scalar variable name, in which case the variable
     contains the name of or a reference to the filehandle, thus
     introducing one level of indirection.  (NOTE: If FILEHANDLE is a
     variable and the next token is a term, it may be misinterpreted as an
     operator unless you interpose a + or put parentheses around the
     arguments.)  If FILEHANDLE is omitted, prints by default to standard
     output (or to the last selected output channel-see `' in this node).
     If LIST is also omitted, prints $_ to the currently selected output
     channel.  To set the default output channel to something other than
     STDOUT use the select operation.  The current value of $, (if any) is
     printed between each LIST item.  The current value of $\ (if any) is
     printed after the entire LIST has been printed.  Because print takes
     a LIST, anything in the LIST is evaluated in list context, and any
     subroutine that you call will have one or more of its expressions
     evaluated in list context.  Also be careful not to follow the print
     keyword with a left parenthesis unless you want the corresponding
     right parenthesis to terminate the arguments to the print-interpose a
     + or put parentheses around all the arguments.

     Note that if you're storing FILEHANDLES in an array or other
     expression, you will have to use a block returning its value instead:

          print { $files[$i] } "stuff\n";
          print { $OK ? STDOUT : STDERR } "stuff\n";

printf FILEHANDLE FORMAT, LIST
printf FORMAT, LIST
     Equivalent to `print FILEHANDLE sprintf(FORMAT, LIST)', except that $\
     (the output record separator) is not appended.  The first argument of
     the list will be interpreted as the printf format.  If `use locale' is
     in effect, the character used for the decimal point in formatted real
     numbers is affected by the LC_NUMERIC locale.  See *Note Perllocale:
     perllocale,.

     Don't fall into the trap of using a printf when a simple print would
     do.  The print is more efficient and less error prone.

prototype FUNCTION
     Returns the prototype of a function as a string (or undef if the
     function has no prototype).  FUNCTION is a reference to, or the name
     of, the function whose prototype you want to retrieve.

     If FUNCTION is a string starting with `CORE::', the rest is taken as a
     name for Perl builtin.  If the builtin is not *overridable* (such as
     `qw//') or its arguments cannot be expressed by a prototype (such as
     system) returns undef because the builtin does not really behave like
     a Perl function.  Otherwise, the string describing the equivalent
     prototype is returned.

push ARRAY,LIST
     Treats ARRAY as a stack, and pushes the values of LIST onto the end
     of ARRAY.  The length of ARRAY increases by the length of LIST.  Has
     the same effect as

          for $value (LIST) {
          	$ARRAY[++$#ARRAY] = $value;
          }

     but is more efficient.  Returns the new number of elements in the
     array.

q/STRING/
qq/STRING/
qr/STRING/
qx/STRING/
qw/STRING/
     Generalized quotes.  See `"Regexp Quote-Like Operators"', *Note
     Perlop: perlop,.

quotemeta EXPR
quotemeta
     Returns the value of EXPR with all non-alphanumeric characters
     backslashed.  (That is, all characters not matching `/[A-Za-z_0-9]/'
     will be preceded by a backslash in the returned string, regardless of
     any locale settings.)  This is the internal function implementing the
     `\Q' escape in double-quoted strings.

     If EXPR is omitted, uses $_.

rand EXPR
rand
     Returns a random fractional number greater than or equal to 0 and less
     than the value of EXPR.  (EXPR should be positive.)  If EXPR is
     omitted, the value 1 is used.  Automatically calls srand unless srand
     has already been called.  See also srand.

     (Note: If your rand function consistently returns numbers that are too
     large or too small, then your version of Perl was probably compiled
     with the wrong number of RANDBITS.)

read FILEHANDLE,SCALAR,LENGTH,OFFSET
read FILEHANDLE,SCALAR,LENGTH
     Attempts to read LENGTH bytes of data into variable SCALAR from the
     specified FILEHANDLE.  Returns the number of bytes actually read, 0
     at end of file, or undef if there was an error.  SCALAR will be grown
     or shrunk to the length actually read.  An OFFSET may be specified to
     place the read data at some other place than the beginning of the
     string.  This call is actually implemented in terms of stdio's
     fread(3) call.  To get a true read(2) system call, see sysread.

readdir DIRHANDLE
     Returns the next directory entry for a directory opened by opendir.
     If used in list context, returns all the rest of the entries in the
     directory.  If there are no more entries, returns an undefined value
     in scalar context or a null list in list context.

     If you're planning to filetest the return values out of a readdir,
     you'd better prepend the directory in question.  Otherwise, because
     we didn't chdir there, it would have been testing the wrong file.

          opendir(DIR, $some_dir) || die "can't opendir $some_dir: $!";
          @dots = grep { /^\./ && -f "$some_dir/$_" } readdir(DIR);
          closedir DIR;

readline EXPR
     Reads from the filehandle whose typeglob is contained in EXPR.  In
     scalar context, each call reads and returns the next line, until
     end-of-file is reached, whereupon the subsequent call returns undef.
     In list context, reads until end-of-file is reached and returns a
     list of lines.  Note that the notion of "line" used here is however
     you may have defined it with $/ or $INPUT_RECORD_SEPARATOR).  See
     `"$', *Note Perlvar: perlvar,.

     When $/ is set to undef, when readline() is in scalar context (i.e.
     file slurp mode), and when an empty file is read, it returns " the
     first time, followed by undef subsequently.

     This is the internal function implementing the `< <EXPR' >> operator,
     but you can use it directly.  The `< <EXPR' >> operator is discussed
     in more detail in `"I', *Note Perlop: perlop,.

          $line = <STDIN>;
          $line = readline(*STDIN);		# same thing

readlink EXPR
readlink
     Returns the value of a symbolic link, if symbolic links are
     implemented.  If not, gives a fatal error.  If there is some system
     error, returns the undefined value and sets $! (errno).  If EXPR is
     omitted, uses $_.

readpipe EXPR
     EXPR is executed as a system command.  The collected standard output
     of the command is returned.  In scalar context, it comes back as a
     single (potentially multi-line) string.  In list context, returns a
     list of lines (however you've defined lines with $/ or
     $INPUT_RECORD_SEPARATOR).  This is the internal function implementing
     the `qx/EXPR/' operator, but you can use it directly.  The `qx/EXPR/'
     operator is discussed in more detail in `"I', *Note Perlop: perlop,.

recv SOCKET,SCALAR,LENGTH,FLAGS
     Receives a message on a socket.  Attempts to receive LENGTH bytes of
     data into variable SCALAR from the specified SOCKET filehandle.
     SCALAR will be grown or shrunk to the length actually read.  Takes
     the same flags as the system call of the same name.  Returns the
     address of the sender if SOCKET's protocol supports this; returns an
     empty string otherwise.  If there's an error, returns the undefined
     value.  This call is actually implemented in terms of recvfrom(2)
     system call.  See `"UDP: Message Passing"', *Note Perlipc: perlipc,
     for examples.

redo LABEL
redo
     The redo command restarts the loop block without evaluating the
     conditional again.  The continue block, if any, is not executed.  If
     the LABEL is omitted, the command refers to the innermost enclosing
     loop.  This command is normally used by programs that want to lie to
     themselves about what was just input:

          # a simpleminded Pascal comment stripper
          # (warning: assumes no { or } in strings)
          LINE: while (<STDIN>) {
          	while (s|({.*}.*){.*}|$1 |) {}
          	s|{.*}| |;
          	if (s|{.*| |) {
          	    $front = $_;
          	    while (<STDIN>) {
          		if (/}/) {	# end of comment?
          		    s|^|$front\{|;
          		    redo LINE;
          		}
          	    }
          	}
          	print;
          }

     redo cannot be used to retry a block which returns a value such as
     `eval {}', `sub {}' or `do {}', and should not be used to exit a
     grep() or map() operation.

     Note that a block by itself is semantically identical to a loop that
     executes once.  Thus redo inside such a block will effectively turn
     it into a looping construct.

     See also `' in this node for an illustration of how last, next, and
     redo work.

ref EXPR
ref
     Returns a true value if EXPR is a reference, false otherwise.  If EXPR
     is not specified, $_ will be used.  The value returned depends on the
     type of thing the reference is a reference to.  Builtin types include:

          SCALAR
          ARRAY
          HASH
          CODE
          REF
          GLOB
          LVALUE

     If the referenced object has been blessed into a package, then that
     package name is returned instead.  You can think of ref as a `typeof'
     operator.

          if (ref($r) eq "HASH") {
          	print "r is a reference to a hash.\n";
          }
          unless (ref($r)) {
          	print "r is not a reference at all.\n";
          }
          if (UNIVERSAL::isa($r, "HASH")) {  # for subclassing
          	print "r is a reference to something that isa hash.\n";
          }

     See also *Note Perlref: perlref,.

rename OLDNAME,NEWNAME
     Changes the name of a file; an existing file NEWNAME will be
     clobbered.  Returns true for success, false otherwise.

     Behavior of this function varies wildly depending on your system
     implementation.  For example, it will usually not work across file
     system boundaries, even though the system mv command sometimes
     compensates for this.  Other restrictions include whether it works on
     directories, open files, or pre-existing files.  Check *Note
     Perlport: perlport, and either the rename(2) manpage or equivalent
     system documentation for details.

require VERSION
require EXPR
require
     Demands some semantics specified by EXPR, or by $_ if EXPR is not
     supplied.

     If a VERSION is specified as a literal of the form v5.6.1, demands
     that the current version of Perl ($^V or $PERL_VERSION) be at least
     as recent as that version, at run time.  (For compatibility with
     older versions of Perl, a numeric argument will also be interpreted
     as VERSION.)  Compare with `' in this node, which can do a similar
     check at compile time.

          require v5.6.1;	# run time version check
          require 5.6.1;	# ditto
          require 5.005_03;	# float version allowed for compatibility

     Otherwise, demands that a library file be included if it hasn't
     already been included.  The file is included via the do-FILE
     mechanism, which is essentially just a variety of eval.  Has
     semantics similar to the following subroutine:

          sub require {
          	my($filename) = @_;
          	return 1 if $INC{$filename};
          	my($realfilename,$result);
          	ITER: {
          	    foreach $prefix (@INC) {
          		$realfilename = "$prefix/$filename";
          		if (-f $realfilename) {
          		    $INC{$filename} = $realfilename;
          		    $result = do $realfilename;
          		    last ITER;
          		}
          	    }
          	    die "Can't find $filename in \@INC";
          	}
          	delete $INC{$filename} if $@ || !$result;
          	die $@ if $@;
          	die "$filename did not return true value" unless $result;
          	return $result;
          }

     Note that the file will not be included twice under the same specified
     name.  The file must return true as the last statement to indicate
     successful execution of any initialization code, so it's customary to
     end such a file with `1;' unless you're sure it'll return true
     otherwise.  But it's better just to put the `1;', in case you add more
     statements.

     If EXPR is a bareword, the require assumes a "`.pm'" extension and
     replaces "`::'" with "/" in the filename for you, to make it easy to
     load standard modules.  This form of loading of modules does not risk
     altering your namespace.

     In other words, if you try this:

          require Foo::Bar;    # a splendid bareword

     The require function will actually look for the "`Foo/Bar.pm'" file
     in the directories specified in the `@INC' array.

     But if you try this:

          $class = 'Foo::Bar';
          require $class;	     # $class is not a bareword
              #or
          require "Foo::Bar";  # not a bareword because of the ""

     The require function will look for the "`Foo::Bar'" file in the @INC
     array and will complain about not finding "`Foo::Bar'" there.  In
     this case you can do:

          eval "require $class";

     For a yet-more-powerful import facility, see `' in this node and
     *Note Perlmod: perlmod,.

reset EXPR
reset
     Generally used in a continue block at the end of a loop to clear
     variables and reset `??' searches so that they work again.  The
     expression is interpreted as a list of single characters (hyphens
     allowed for ranges).  All variables and arrays beginning with one of
     those letters are reset to their pristine state.  If the expression is
     omitted, one-match searches (?pattern?) are reset to match again.
     Resets only variables or searches in the current package.  Always
     returns 1.  Examples:

          reset 'X';		# reset all X variables
          reset 'a-z';	# reset lower case variables
          reset;		# just reset ?one-time? searches

     Resetting `"A-Z"' is not recommended because you'll wipe out your
     `@ARGV' and `@INC' arrays and your %ENV hash.  Resets only package
     variables-lexical variables are unaffected, but they clean themselves
     up on scope exit anyway, so you'll probably want to use them instead.
     See `' in this node.

return EXPR
return
     Returns from a subroutine, eval, or `do FILE' with the value given in
     EXPR.  Evaluation of EXPR may be in list, scalar, or void context,
     depending on how the return value will be used, and the context may
     vary from one execution to the next (see wantarray).  If no EXPR is
     given, returns an empty list in list context, the undefined value in
     scalar context, and (of course) nothing at all in a void context.

     (Note that in the absence of a explicit return, a subroutine, eval,
     or do FILE will automatically return the value of the last expression
     evaluated.)

reverse LIST
     In list context, returns a list value consisting of the elements of
     LIST in the opposite order.  In scalar context, concatenates the
     elements of LIST and returns a string value with all characters in
     the opposite order.

          print reverse <>;		# line tac, last line first

          undef $/;			# for efficiency of <>
          print scalar reverse <>;	# character tac, last line tsrif

     This operator is also handy for inverting a hash, although there are
     some caveats.  If a value is duplicated in the original hash, only
     one of those can be represented as a key in the inverted hash.  Also,
     this has to unwind one hash and build a whole new one, which may take
     some time on a large hash, such as from a DBM file.

          %by_name = reverse %by_address;	# Invert the hash

rewinddir DIRHANDLE
     Sets the current position to the beginning of the directory for the
     readdir routine on DIRHANDLE.

rindex STR,SUBSTR,POSITION
rindex STR,SUBSTR
     Works just like index() except that it returns the position of the
     LAST occurrence of SUBSTR in STR.  If POSITION is specified, returns
     the last occurrence at or before that position.

rmdir FILENAME
rmdir
     Deletes the directory specified by FILENAME if that directory is
     empty.  If it succeeds it returns true, otherwise it returns false
     and sets $! (errno).  If FILENAME is omitted, uses $_.

s///
     The substitution operator.  See *Note Perlop: perlop,.

scalar EXPR
     Forces EXPR to be interpreted in scalar context and returns the value
     of EXPR.

          @counts = ( scalar @a, scalar @b, scalar @c );

     There is no equivalent operator to force an expression to be
     interpolated in list context because in practice, this is never
     needed.  If you really wanted to do so, however, you could use the
     construction `@{[ (some expression) ]}', but usually a simple `(some
     expression)' suffices.

     Because scalar is unary operator, if you accidentally use for EXPR a
     parenthesized list, this behaves as a scalar comma expression,
     evaluating all but the last element in void context and returning the
     final element evaluated in scalar context.  This is seldom what you
     want.

     The following single statement:

          print uc(scalar(&foo,$bar)),$baz;

     is the moral equivalent of these two:

          &foo;
          print(uc($bar),$baz);

     See *Note Perlop: perlop, for more details on unary operators and the
     comma operator.

seek FILEHANDLE,POSITION,WHENCE
     Sets FILEHANDLE's position, just like the fseek call of `stdio'.
     FILEHANDLE may be an expression whose value gives the name of the
     filehandle.  The values for WHENCE are 0 to set the new position to
     POSITION, 1 to set it to the current position plus POSITION, and 2 to
     set it to EOF plus POSITION (typically negative).  For WHENCE you may
     use the constants `SEEK_SET', `SEEK_CUR', and `SEEK_END' (start of
     the file, current position, end of the file) from the Fcntl module.
     Returns 1 upon success, 0 otherwise.

     If you want to position file for sysread or syswrite, don't use
     seek-buffering makes its effect on the file's system position
     unpredictable and non-portable.  Use sysseek instead.

     Due to the rules and rigors of ANSI C, on some systems you have to do
     a seek whenever you switch between reading and writing.  Amongst other
     things, this may have the effect of calling stdio's clearerr(3).  A
     WHENCE of 1 (`SEEK_CUR') is useful for not moving the file position:

          seek(TEST,0,1);

     This is also useful for applications emulating `tail -f'.  Once you
     hit EOF on your read, and then sleep for a while, you might have to
     stick in a seek() to reset things.  The seek doesn't change the
     current position, but it *does* clear the end-of-file condition on
     the handle, so that the next `< <FILE' >> makes Perl try again to
     read something.  We hope.

     If that doesn't work (some stdios are particularly cantankerous), then
     you may need something more like this:

          for (;;) {
          	for ($curpos = tell(FILE); $_ = <FILE>;
                   $curpos = tell(FILE)) {
          	    # search for some stuff and put it into files
          	}
          	sleep($for_a_while);
          	seek(FILE, $curpos, 0);
          }

seekdir DIRHANDLE,POS
     Sets the current position for the readdir routine on DIRHANDLE.  POS
     must be a value returned by telldir.  Has the same caveats about
     possible directory compaction as the corresponding system library
     routine.

select FILEHANDLE
select
     Returns the currently selected filehandle.  Sets the current default
     filehandle for output, if FILEHANDLE is supplied.  This has two
     effects: first, a write or a print without a filehandle will default
     to this FILEHANDLE.  Second, references to variables related to
     output will refer to this output channel.  For example, if you have to
     set the top of form format for more than one output channel, you might
     do the following:

          select(REPORT1);
          $^ = 'report1_top';
          select(REPORT2);
          $^ = 'report2_top';

     FILEHANDLE may be an expression whose value gives the name of the
     actual filehandle.  Thus:

          $oldfh = select(STDERR); $| = 1; select($oldfh);

     Some programmers may prefer to think of filehandles as objects with
     methods, preferring to write the last example as:

          use IO::Handle;
          STDERR->autoflush(1);

select RBITS,WBITS,EBITS,TIMEOUT
     This calls the select(2) system call with the bit masks specified,
     which can be constructed using fileno and vec, along these lines:

          $rin = $win = $ein = '';
          vec($rin,fileno(STDIN),1) = 1;
          vec($win,fileno(STDOUT),1) = 1;
          $ein = $rin | $win;

     If you want to select on many filehandles you might wish to write a
     subroutine:

          sub fhbits {
          	my(@fhlist) = split(' ',$_[0]);
          	my($bits);
          	for (@fhlist) {
          	    vec($bits,fileno($_),1) = 1;
          	}
          	$bits;
          }
          $rin = fhbits('STDIN TTY SOCK');

     The usual idiom is:

          ($nfound,$timeleft) =
            select($rout=$rin, $wout=$win, $eout=$ein, $timeout);

     or to block until something becomes ready just do this

          $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);

     Most systems do not bother to return anything useful in $timeleft, so
     calling select() in scalar context just returns $nfound.

     Any of the bit masks can also be undef.  The timeout, if specified, is
     in seconds, which may be fractional.  Note: not all implementations
     are capable of returning the$timeleft.  If not, they always return
     $timeleft equal to the supplied $timeout.

     You can effect a sleep of 250 milliseconds this way:

          select(undef, undef, undef, 0.25);

     WARNING: One should not attempt to mix buffered I/O (like read or
     <FH>) with select, except as permitted by POSIX, and even then only
     on POSIX systems.  You have to use sysread instead.

semctl ID,SEMNUM,CMD,ARG
     Calls the System V IPC function semctl.  You'll probably have to say

          use IPC::SysV;

     first to get the correct constant definitions.  If CMD is IPC_STAT or
     GETALL, then ARG must be a variable which will hold the returned
     semid_ds structure or semaphore value array.  Returns like ioctl: the
     undefined value for error, "`0 but true'" for zero, or the actual
     return value otherwise.  The ARG must consist of a vector of native
     short integers, which may may be created with `pack("s!",(0)x$nsem)'.
     See also IPC::SysV and IPC::Semaphore documentation.

semget KEY,NSEMS,FLAGS
     Calls the System V IPC function semget.  Returns the semaphore id, or
     the undefined value if there is an error.  See also IPC::SysV and
     `IPC::SysV::Semaphore' documentation.

semop KEY,OPSTRING
     Calls the System V IPC function semop to perform semaphore operations
     such as signaling and waiting.  OPSTRING must be a packed array of
     semop structures.  Each semop structure can be generated with
     `pack("sss", $semnum, $semop, $semflag)'.  The number of semaphore
     operations is implied by the length of OPSTRING.  Returns true if
     successful, or false if there is an error.  As an example, the
     following code waits on semaphore $semnum of semaphore id $semid:

          $semop = pack("sss", $semnum, -1, 0);
          die "Semaphore trouble: $!\n" unless semop($semid, $semop);

     To signal the semaphore, replace `-1' with 1.  See also IPC::SysV and
     `IPC::SysV::Semaphore' documentation.

send SOCKET,MSG,FLAGS,TO
send SOCKET,MSG,FLAGS
     Sends a message on a socket.  Takes the same flags as the system call
     of the same name.  On unconnected sockets you must specify a
     destination to send TO, in which case it does a C sendto.  Returns
     the number of characters sent, or the undefined value if there is an
     error.  The C system call sendmsg(2) is currently unimplemented.  See
     `"UDP: Message Passing"', *Note Perlipc: perlipc, for examples.

setpgrp PID,PGRP
     Sets the current process group for the specified PID, 0 for the
     current process.  Will produce a fatal error if used on a machine
     that doesn't implement POSIX setpgid(2) or BSD setpgrp(2).  If the
     arguments are omitted, it defaults to `0,0'.  Note that the BSD 4.2
     version of setpgrp does not accept any arguments, so only
     `setpgrp(0,0)' is portable.  See also `POSIX::setsid()'.

setpriority WHICH,WHO,PRIORITY
     Sets the current priority for a process, a process group, or a user.
     (See setpriority(2).)  Will produce a fatal error if used on a machine
     that doesn't implement setpriority(2).

setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL
     Sets the socket option requested.  Returns undefined if there is an
     error.  OPTVAL may be specified as undef if you don't want to pass an
     argument.

shift ARRAY
shift
     Shifts the first value of the array off and returns it, shortening the
     array by 1 and moving everything down.  If there are no elements in
     the array, returns the undefined value.  If ARRAY is omitted, shifts
     the `@_' array within the lexical scope of subroutines and formats,
     and the `@ARGV' array at file scopes or within the lexical scopes
     established by the `eval ''', `BEGIN {}', `INIT {}', `CHECK {}', and
     `END {}' constructs.

     See also unshift, push, and pop.  `Shift()' and unshift do the same
     thing to the left end of an array that pop and push do to the right
     end.

shmctl ID,CMD,ARG
     Calls the System V IPC function shmctl.  You'll probably have to say

          use IPC::SysV;

     first to get the correct constant definitions.  If CMD is `IPC_STAT',
     then ARG must be a variable which will hold the returned `shmid_ds'
     structure.  Returns like ioctl: the undefined value for error, "0 but
     true" for zero, or the actual return value otherwise.  See also
     IPC::SysV documentation.

shmget KEY,SIZE,FLAGS
     Calls the System V IPC function shmget.  Returns the shared memory
     segment id, or the undefined value if there is an error.  See also
     IPC::SysV documentation.

shmread ID,VAR,POS,SIZE
shmwrite ID,STRING,POS,SIZE
     Reads or writes the System V shared memory segment ID starting at
     position POS for size SIZE by attaching to it, copying in/out, and
     detaching from it.  When reading, VAR must be a variable that will
     hold the data read.  When writing, if STRING is too long, only SIZE
     bytes are used; if STRING is too short, nulls are written to fill out
     SIZE bytes.  Return true if successful, or false if there is an error.
     shmread() taints the variable. See also IPC::SysV documentation and
     the `IPC::Shareable' module from CPAN.

shutdown SOCKET,HOW
     Shuts down a socket connection in the manner indicated by HOW, which
     has the same interpretation as in the system call of the same name.

          shutdown(SOCKET, 0);    # I/we have stopped reading data
          shutdown(SOCKET, 1);    # I/we have stopped writing data
          shutdown(SOCKET, 2);    # I/we have stopped using this socket

     This is useful with sockets when you want to tell the other side
     you're done writing but not done reading, or vice versa.  It's also a
     more insistent form of close because it also disables the file
     descriptor in any forked copies in other processes.

sin EXPR
sin
     Returns the sine of EXPR (expressed in radians).  If EXPR is omitted,
     returns sine of $_.

     For the inverse sine operation, you may use the `Math::Trig::asin'
     function, or use this relation:

          sub asin { atan2($_[0], sqrt(1 - $_[0] * $_[0])) }

sleep EXPR
sleep
     Causes the script to sleep for EXPR seconds, or forever if no EXPR.
     May be interrupted if the process receives a signal such as `SIGALRM'.
     Returns the number of seconds actually slept.  You probably cannot
     mix alarm and sleep calls, because sleep is often implemented using
     alarm.

     On some older systems, it may sleep up to a full second less than what
     you requested, depending on how it counts seconds.  Most modern
     systems always sleep the full amount.  They may appear to sleep
     longer than that, however, because your process might not be
     scheduled right away in a busy multitasking system.

     For delays of finer granularity than one second, you may use Perl's
     syscall interface to access setitimer(2) if your system supports it,
     or else see `' in this node above.  The Time::HiRes module from CPAN
     may also help.

     See also the POSIX module's `sigpause' function.

socket SOCKET,DOMAIN,TYPE,PROTOCOL
     Opens a socket of the specified kind and attaches it to filehandle
     SOCKET.  DOMAIN, TYPE, and PROTOCOL are specified the same as for the
     system call of the same name.  You should `use Socket' first to get
     the proper definitions imported.  See the examples in `"Sockets:
     Client', *Note Perlipc: perlipc,.

     On systems that support a close-on-exec flag on files, the flag will
     be set for the newly opened file descriptor, as determined by the
     value of $^F.  See `$^F', *Note Perlvar: perlvar,.

socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL
     Creates an unnamed pair of sockets in the specified domain, of the
     specified type.  DOMAIN, TYPE, and PROTOCOL are specified the same as
     for the system call of the same name.  If unimplemented, yields a
     fatal error.  Returns true if successful.

     On systems that support a close-on-exec flag on files, the flag will
     be set for the newly opened file descriptors, as determined by the
     value of $^F.  See `$^F', *Note Perlvar: perlvar,.

     Some systems defined pipe in terms of socketpair, in which a call to
     `pipe(Rdr, Wtr)' is essentially:

          use Socket;
          socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
          shutdown(Rdr, 1);        # no more writing for reader
          shutdown(Wtr, 0);        # no more reading for writer

     See *Note Perlipc: perlipc, for an example of socketpair use.

sort SUBNAME LIST
sort BLOCK LIST
sort LIST
     Sorts the LIST and returns the sorted list value.  If SUBNAME or BLOCK
     is omitted, sorts in standard string comparison order.  If SUBNAME is
     specified, it gives the name of a subroutine that returns an integer
     less than, equal to, or greater than 0, depending on how the elements
     of the list are to be ordered.  (The `< <=' >> and cmp operators are
     extremely useful in such routines.)  SUBNAME may be a scalar variable
     name (unsubscripted), in which case the value provides the name of
     (or a reference to) the actual subroutine to use.  In place of a
     SUBNAME, you can provide a BLOCK as an anonymous, in-line sort
     subroutine.

     If the subroutine's prototype is `($$)', the elements to be compared
     are passed by reference in `@_', as for a normal subroutine.  This is
     slower than unprototyped subroutines, where the elements to be
     compared are passed into the subroutine as the package global
     variables $a and $b (see example below).  Note that in the latter
     case, it is usually counter-productive to declare $a and $b as
     lexicals.

     In either case, the subroutine may not be recursive.  The values to be
     compared are always passed by reference, so don't modify them.

     You also cannot exit out of the sort block or subroutine using any of
     the loop control operators described in *Note Perlsyn: perlsyn, or
     with goto.

     When `use locale' is in effect, `sort LIST' sorts LIST according to
     the current collation locale.  See *Note Perllocale: perllocale,.

     Examples:

          # sort lexically
          @articles = sort @files;

          # same thing, but with explicit sort routine
          @articles = sort {$a cmp $b} @files;

          # now case-insensitively
          @articles = sort {uc($a) cmp uc($b)} @files;

          # same thing in reversed order
          @articles = sort {$b cmp $a} @files;

          # sort numerically ascending
          @articles = sort {$a <=> $b} @files;

          # sort numerically descending
          @articles = sort {$b <=> $a} @files;

          # this sorts the %age hash by value instead of key
          # using an in-line function
          @eldest = sort { $age{$b} <=> $age{$a} } keys %age;

          # sort using explicit subroutine name
          sub byage {
          	$age{$a} <=> $age{$b};	# presuming numeric
          }
          @sortedclass = sort byage @class;

          sub backwards { $b cmp $a }
          @harry  = qw(dog cat x Cain Abel);
          @george = qw(gone chased yz Punished Axed);
          print sort @harry;
          	    # prints AbelCaincatdogx
          print sort backwards @harry;
          	    # prints xdogcatCainAbel
          print sort @george, 'to', @harry;
          	    # prints AbelAxedCainPunishedcatchaseddoggonetoxyz

          # inefficiently sort by descending numeric compare using
          # the first integer after the first = sign, or the
          # whole record case-insensitively otherwise

          @new = sort {
          	($b =~ /=(\d+)/)[0] <=> ($a =~ /=(\d+)/)[0]
          			    ||
          	            uc($a)  cmp  uc($b)
          } @old;

          # same thing, but much more efficiently;
          # we'll build auxiliary indices instead
          # for speed
          @nums = @caps = ();
          for (@old) {
          	push @nums, /=(\d+)/;
          	push @caps, uc($_);
          }

          @new = @old[ sort {
          			$nums[$b] <=> $nums[$a]
          				 ||
          			$caps[$a] cmp $caps[$b]
          		       } 0..$#old
          	       ];

          # same thing, but without any temps
          @new = map { $_->[0] }
                 sort { $b->[1] <=> $a->[1]
                                 ||
                        $a->[2] cmp $b->[2]
                 } map { [$_, /=(\d+)/, uc($_)] } @old;

          # using a prototype allows you to use any comparison subroutine
          # as a sort subroutine (including other package's subroutines)
          package other;
          sub backwards ($$) { $_[1] cmp $_[0]; }	# $a and $b are not set here

          package main;
          @new = sort other::backwards @old;

     If you're using strict, you *must not* declare $a and $b as lexicals.
     They are package globals.  That means if you're in the main package,
     it's

          @articles = sort {$main::b <=> $main::a} @files;

     or just

          @articles = sort {$::b <=> $::a} @files;

     but if you're in the `FooPack' package, it's

          @articles = sort {$FooPack::b <=> $FooPack::a} @files;

     The comparison function is required to behave.  If it returns
     inconsistent results (sometimes saying `$x[1]' is less than `$x[2]'
     and sometimes saying the opposite, for example) the results are not
     well-defined.

splice ARRAY,OFFSET,LENGTH,LIST
splice ARRAY,OFFSET,LENGTH
splice ARRAY,OFFSET
splice ARRAY
     Removes the elements designated by OFFSET and LENGTH from an array,
     and replaces them with the elements of LIST, if any.  In list context,
     returns the elements removed from the array.  In scalar context,
     returns the last element removed, or undef if no elements are
     removed.  The array grows or shrinks as necessary.  If OFFSET is
     negative then it starts that far from the end of the array.  If
     LENGTH is omitted, removes everything from OFFSET onward.  If LENGTH
     is negative, leaves that many elements off the end of the array.  If
     both OFFSET and LENGTH are omitted, removes everything.

     The following equivalences hold (assuming `$[ == 0'):

          push(@a,$x,$y)	splice(@a,@a,0,$x,$y)
          pop(@a)		splice(@a,-1)
          shift(@a)		splice(@a,0,1)
          unshift(@a,$x,$y)	splice(@a,0,0,$x,$y)
          $a[$x] = $y		splice(@a,$x,1,$y)

     Example, assuming array lengths are passed before arrays:

          sub aeq {	# compare two list values
          	my(@a) = splice(@_,0,shift);
          	my(@b) = splice(@_,0,shift);
          	return 0 unless @a == @b;	# same len?
          	while (@a) {
          	    return 0 if pop(@a) ne pop(@b);
          	}
          	return 1;
          }
          if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }

split /PATTERN/,EXPR,LIMIT
split /PATTERN/,EXPR
split /PATTERN/
split
     Splits a string into a list of strings and returns that list.  By
     default, empty leading fields are preserved, and empty trailing ones
     are deleted.

     If not in list context, returns the number of fields found and splits
     into the `@_' array.  (In list context, you can force the split into
     `@_' by using `??' as the pattern delimiters, but it still returns
     the list value.)  The use of implicit split to `@_' is deprecated,
     however, because it clobbers your subroutine arguments.

     If EXPR is omitted, splits the $_ string.  If PATTERN is also omitted,
     splits on whitespace (after skipping any leading whitespace).
     Anything matching PATTERN is taken to be a delimiter separating the
     fields.  (Note that the delimiter may be longer than one character.)

     If LIMIT is specified and positive, splits into no more than that
     many fields (though it may split into fewer).  If LIMIT is unspecified
     or zero, trailing null fields are stripped (which potential users of
     pop would do well to remember).  If LIMIT is negative, it is treated
     as if an arbitrarily large LIMIT had been specified.

     A pattern matching the null string (not to be confused with a null
     pattern `//', which is just one member of the set of patterns
     matching a null string) will split the value of EXPR into separate
     characters at each point it matches that way.  For example:

          print join(':', split(/ */, 'hi there'));

     produces the output 'h:i:t:h:e:r:e'.

     The LIMIT parameter can be used to split a line partially

          ($login, $passwd, $remainder) = split(/:/, $_, 3);

     When assigning to a list, if LIMIT is omitted, Perl supplies a LIMIT
     one larger than the number of variables in the list, to avoid
     unnecessary work.  For the list above LIMIT would have been 4 by
     default.  In time critical applications it behooves you not to split
     into more fields than you really need.

     If the PATTERN contains parentheses, additional list elements are
     created from each matching substring in the delimiter.

          split(/([,-])/, "1-10,20", 3);

     produces the list value

          (1, '-', 10, ',', 20)

     If you had the entire header of a normal Unix email message in
     $header, you could split it up into fields and their values this way:

          $header =~ s/\n\s+/ /g;  # fix continuation lines
          %hdrs   =  (UNIX_FROM => split /^(\S*?):\s*/m, $header);

     The pattern `/PATTERN/' may be replaced with an expression to specify
     patterns that vary at runtime.  (To do runtime compilation only once,
     use `/$variable/o'.)

     As a special case, specifying a PATTERN of space (`' '') will split on
     white space just as split with no arguments does.  Thus, `split(' ')'
     can be used to emulate *awk*'s default behavior, whereas `split(/ /)'
     will give you as many null initial fields as there are leading spaces.
     A split on `/\s+/' is like a `split(' ')' except that any leading
     whitespace produces a null first field.  A split with no arguments
     really does a `split(' ', $_)' internally.

     Example:

          open(PASSWD, '/etc/passwd');
          while (<PASSWD>) {
          	($login, $passwd, $uid, $gid,
               $gcos, $home, $shell) = split(/:/);
          	#...
          }

     (Note that $shell above will still have a newline on it.  See `' in
     this node, `' in this node, and `' in this node.)

sprintf FORMAT, LIST
     Returns a string formatted by the usual printf conventions of the C
     library function sprintf.  See `sprintf(3)' in this node or
     `printf(3)' in this node on your system for an explanation of the
     general principles.

     Perl does its own sprintf formatting-it emulates the C function
     sprintf, but it doesn't use it (except for floating-point numbers,
     and even then only the standard modifiers are allowed).  As a result,
     any non-standard extensions in your local sprintf are not available
     from Perl.

     Perl's sprintf permits the following universally-known conversions:

          %%	a percent sign
          %c	a character with the given number
          %s	a string
          %d	a signed integer, in decimal
          %u	an unsigned integer, in decimal
          %o	an unsigned integer, in octal
          %x	an unsigned integer, in hexadecimal
          %e	a floating-point number, in scientific notation
          %f	a floating-point number, in fixed decimal notation
          %g	a floating-point number, in %e or %f notation

     In addition, Perl permits the following widely-supported conversions:

          %X	like %x, but using upper-case letters
          %E	like %e, but using an upper-case "E"
          %G	like %g, but with an upper-case "E" (if applicable)
          %b	an unsigned integer, in binary
          %p	a pointer (outputs the Perl value's address in hexadecimal)
          %n	special: *stores* the number of characters output so far
               into the next variable in the parameter list

     Finally, for backward (and we do mean "backward") compatibility, Perl
     permits these unnecessary but widely-supported conversions:

          %i	a synonym for %d
          %D	a synonym for %ld
          %U	a synonym for %lu
          %O	a synonym for %lo
          %F	a synonym for %f

     Perl permits the following universally-known flags between the % and
     the conversion letter:

          space   prefix positive number with a space
          +       prefix positive number with a plus sign
          -       left-justify within the field
          0       use zeros, not spaces, to right-justify
          #       prefix non-zero octal with "0", non-zero hex with "0x"
          number  minimum field width
          .number "precision": digits after decimal point for
                  floating-point, max length for string, minimum length
                  for integer
          l       interpret integer as C type "long" or "unsigned long"
          h       interpret integer as C type "short" or "unsigned short"
                  If no flags, interpret integer as C type "int" or "unsigned"

     There are also two Perl-specific flags:

          V       interpret integer as Perl's standard integer type
          v       interpret string as a vector of integers, output as
                  numbers separated either by dots, or by an arbitrary
          	   string received from the argument list when the flag
          	   is preceded by C<*>

     Where a number would appear in the flags, an asterisk (*) may be used
     instead, in which case Perl uses the next item in the parameter list
     as the given number (that is, as the field width or precision).  If a
     field width obtained through * is negative, it has the same effect as
     the - flag: left-justification.

     The v flag is useful for displaying ordinal values of characters in
     arbitrary strings:

          printf "version is v%vd\n", $^V;		# Perl's version
          printf "address is %*vX\n", ":", $addr;	# IPv6 address
          printf "bits are %*vb\n", " ", $bits;	# random bitstring

     If `use locale' is in effect, the character used for the decimal
     point in formatted real numbers is affected by the LC_NUMERIC locale.
     See *Note Perllocale: perllocale,.

     If Perl understands "quads" (64-bit integers) (this requires either
     that the platform natively support quads or that Perl be specifically
     compiled to support quads), the characters

          d u o x X b i D U O

     print quads, and they may optionally be preceded by

          ll L q

     For example

          %lld %16LX %qo

     You can find out whether your Perl supports quads via *Note Config:
     (pm.info)Config,:

          use Config;
          ($Config{use64bitint} eq 'define' || $Config{longsize} == 8) &&
          	print "quads\n";

     If Perl understands "long doubles" (this requires that the platform
     support long doubles), the flags

          e f g E F G

     may optionally be preceded by

          ll L

     For example

          %llf %Lg

     You can find out whether your Perl supports long doubles via *Note
     Config: (pm.info)Config,:

          use Config;
          $Config{d_longdbl} eq 'define' && print "long doubles\n";

sqrt EXPR
sqrt
     Return the square root of EXPR.  If EXPR is omitted, returns square
     root of $_.  Only works on non-negative operands, unless you've
     loaded the standard Math::Complex module.

          use Math::Complex;
          print sqrt(-2);    # prints 1.4142135623731i

srand EXPR
srand
     Sets the random number seed for the rand operator.  If EXPR is
     omitted, uses a semi-random value supplied by the kernel (if it
     supports the `/dev/urandom' device) or based on the current time and
     process ID, among other things.  In versions of Perl prior to 5.004
     the default seed was just the current time.  This isn't a
     particularly good seed, so many old programs supply their own seed
     value (often `time ^ $$' or `time ^ ($$ + ($$ << 15))'), but that
     isn't necessary any more.

     In fact, it's usually not necessary to call srand at all, because if
     it is not called explicitly, it is called implicitly at the first use
     of the rand operator.  However, this was not the case in version of
     Perl before 5.004, so if your script will run under older Perl
     versions, it should call srand.

     Note that you need something much more random than the default seed
     for cryptographic purposes.  Checksumming the compressed output of
     one or more rapidly changing operating system status programs is the
     usual method.  For example:

          srand (time ^ $$ ^ unpack "%L*", `ps axww | gzip`);

     If you're particularly concerned with this, see the
     `Math::TrulyRandom' module in CPAN.

     Do not call srand multiple times in your program unless you know
     exactly what you're doing and why you're doing it.  The point of the
     function is to "seed" the rand function so that rand can produce a
     different sequence each time you run your program.  Just do it once
     at the top of your program, or you *won't* get random numbers out of
     rand!

     Frequently called programs (like CGI scripts) that simply use

          time ^ $$

     for a seed can fall prey to the mathematical property that

          a^b == (a+1)^(b+1)

     one-third of the time.  So don't do that.

stat FILEHANDLE
stat EXPR
stat
     Returns a 13-element list giving the status info for a file, either
     the file opened via FILEHANDLE, or named by EXPR.  If EXPR is omitted,
     it stats $_.  Returns a null list if the stat fails.  Typically used
     as follows:

          ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
             $atime,$mtime,$ctime,$blksize,$blocks)
                 = stat($filename);

     Not all fields are supported on all filesystem types.  Here are the
     meaning of the fields:

          0 dev      device number of filesystem
          1 ino      inode number
          2 mode     file mode  (type and permissions)
          3 nlink    number of (hard) links to the file
          4 uid      numeric user ID of file's owner
          5 gid      numeric group ID of file's owner
          6 rdev     the device identifier (special files only)
          7 size     total size of file, in bytes
          8 atime    last access time in seconds since the epoch
          9 mtime    last modify time in seconds since the epoch
           10 ctime    inode change time (NOT creation time!) in seconds since the epoch
           11 blksize  preferred block size for file system I/O
           12 blocks   actual number of blocks allocated

     (The epoch was at 00:00 January 1, 1970 GMT.)

     If stat is passed the special filehandle consisting of an underline,
     no stat is done, but the current contents of the stat structure from
     the last stat or filetest are returned.  Example:

          if (-x $file && (($d) = stat(_)) && $d < 0) {
          	print "$file is executable NFS file\n";
          }

     (This works on machines only for which the device number is negative
     under NFS.)

     Because the mode contains both the file type and its permissions, you
     should mask off the file type portion and (s)printf using a `"%o"' if
     you want to see the real permissions.

          $mode = (stat($filename))[2];
          printf "Permissions are %04o\n", $mode & 07777;

     In scalar context, stat returns a boolean value indicating success or
     failure, and, if successful, sets the information associated with the
     special filehandle _.

     The File::stat module provides a convenient, by-name access mechanism:

          use File::stat;
          $sb = stat($filename);
          printf "File is %s, size is %s, perm %04o, mtime %s\n",
          	$filename, $sb->size, $sb->mode & 07777,
          	scalar localtime $sb->mtime;

     You can import symbolic mode constants (`S_IF*') and functions
     (`S_IS*') from the Fcntl module:

          use Fcntl ':mode';

          $mode = (stat($filename))[2];

          $user_rwx      = ($mode & S_IRWXU) >> 6;
          $group_read    = ($mode & S_IRGRP) >> 3;
          $other_execute =  $mode & S_IXOTH;

          printf "Permissions are %04o\n", S_ISMODE($mode), "\n";

          $is_setuid     =  $mode & S_ISUID;
          $is_setgid     =  S_ISDIR($mode);

     You could write the last two using the -u and -d operators.  The
     commonly available S_IF* constants are

          # Permissions: read, write, execute, for user, group, others.

          S_IRWXU S_IRUSR S_IWUSR S_IXUSR
          S_IRWXG S_IRGRP S_IWGRP S_IXGRP
          S_IRWXO S_IROTH S_IWOTH S_IXOTH

          # Setuid/Setgid/Stickiness.

          S_ISUID S_ISGID S_ISVTX S_ISTXT

          # File types.  Not necessarily all are available on your system.

          S_IFREG S_IFDIR S_IFLNK S_IFBLK S_ISCHR S_IFIFO S_IFSOCK S_IFWHT S_ENFMT

          # The following are compatibility aliases for S_IRUSR, S_IWUSR, S_IXUSR.

          S_IREAD S_IWRITE S_IEXEC

     and the S_IF* functions are

          S_IFMODE($mode)	the part of $mode containg the permission bits
          			and the setuid/setgid/sticky bits

          S_IFMT($mode)	the part of $mode containing the file type
          			which can be bit-anded with e.g. S_IFREG
                              or with the following functions

          # The operators -f, -d, -l, -b, -c, -p, and -s.

          S_ISREG($mode) S_ISDIR($mode) S_ISLNK($mode)
          S_ISBLK($mode) S_ISCHR($mode) S_ISFIFO($mode) S_ISSOCK($mode)

          # No direct -X operator counterpart, but for the first one
          # the -g operator is often equivalent.  The ENFMT stands for
          # record flocking enforcement, a platform-dependent feature.

          S_ISENFMT($mode) S_ISWHT($mode)

     See your native chmod(2) and stat(2) documentation for more details
     about the S_* constants.

study SCALAR
study
     Takes extra time to study SCALAR ($_ if unspecified) in anticipation
     of doing many pattern matches on the string before it is next
     modified.  This may or may not save time, depending on the nature and
     number of patterns you are searching on, and on the distribution of
     character frequencies in the string to be searched-you probably want
     to compare run times with and without it to see which runs faster.
     Those loops which scan for many short constant strings (including the
     constant parts of more complex patterns) will benefit most.  You may
     have only one study active at a time-if you study a different scalar
     the first is "unstudied".  (The way study works is this: a linked
     list of every character in the string to be searched is made, so we
     know, for example, where all the 'k' characters are.  From each
     search string, the rarest character is selected, based on some static
     frequency tables constructed from some C programs and English text.
     Only those places that contain this "rarest" character are examined.)

     For example, here is a loop that inserts index producing entries
     before any line containing a certain pattern:

          while (<>) {
          	study;
          	print ".IX foo\n" 	if /\bfoo\b/;
          	print ".IX bar\n" 	if /\bbar\b/;
          	print ".IX blurfl\n" 	if /\bblurfl\b/;
          	# ...
          	print;
          }

     In searching for `/\bfoo\b/', only those locations in $_ that contain
     f will be looked at, because f is rarer than o.  In general, this is
     a big win except in pathological cases.  The only question is whether
     it saves you more time than it took to build the linked list in the
     first place.

     Note that if you have to look for strings that you don't know till
     runtime, you can build an entire loop as a string and eval that to
     avoid recompiling all your patterns all the time.  Together with
     undefining $/ to input entire files as one record, this can be very
     fast, often faster than specialized programs like fgrep(1).  The
     following scans a list of files (`@files') for a list of words
     (`@words'), and prints out the names of those files that contain a
     match:

          $search = 'while (<>) { study;';
          foreach $word (@words) {
          	$search .= "++\$seen{\$ARGV} if /\\b$word\\b/;\n";
          }
          $search .= "}";
          @ARGV = @files;
          undef $/;
          eval $search;		# this screams
          $/ = "\n";		# put back to normal input delimiter
          foreach $file (sort keys(%seen)) {
          	print $file, "\n";
          }

sub BLOCK
sub NAME
sub NAME BLOCK
     This is subroutine definition, not a real function *per se*.  With
     just a NAME (and possibly prototypes or attributes), it's just a
     forward declaration.  Without a NAME, it's an anonymous function
     declaration, and does actually return a value: the CODE ref of the
     closure you just created.  See *Note Perlsub: perlsub, and *Note
     Perlref: perlref, for details.

substr EXPR,OFFSET,LENGTH,REPLACEMENT
substr EXPR,OFFSET,LENGTH
substr EXPR,OFFSET
     Extracts a substring out of EXPR and returns it.  First character is
     at offset 0, or whatever you've set $[ to (but don't do that).  If
     OFFSET is negative (or more precisely, less than $[), starts that far
     from the end of the string.  If LENGTH is omitted, returns everything
     to the end of the string.  If LENGTH is negative, leaves that many
     characters off the end of the string.

     You can use the substr() function as an lvalue, in which case EXPR
     must itself be an lvalue.  If you assign something shorter than
     LENGTH, the string will shrink, and if you assign something longer
     than LENGTH, the string will grow to accommodate it.  To keep the
     string the same length you may need to pad or chop your value using
     sprintf.

     If OFFSET and LENGTH specify a substring that is partly outside the
     string, only the part within the string is returned.  If the substring
     is beyond either end of the string, substr() returns the undefined
     value and produces a warning.  When used as an lvalue, specifying a
     substring that is entirely outside the string is a fatal error.
     Here's an example showing the behavior for boundary cases:

          my $name = 'fred';
          substr($name, 4) = 'dy';		# $name is now 'freddy'
          my $null = substr $name, 6, 2;	# returns '' (no warning)
          my $oops = substr $name, 7;		# returns undef, with warning
          substr($name, 7) = 'gap';		# fatal error

     An alternative to using substr() as an lvalue is to specify the
     replacement string as the 4th argument.  This allows you to replace
     parts of the EXPR and return what was there before in one operation,
     just as you can with splice().

symlink OLDFILE,NEWFILE
     Creates a new filename symbolically linked to the old filename.
     Returns 1 for success, 0 otherwise.  On systems that don't support
     symbolic links, produces a fatal error at run time.  To check for
     that, use eval:

          $symlink_exists = eval { symlink("",""); 1 };

syscall LIST
     Calls the system call specified as the first element of the list,
     passing the remaining elements as arguments to the system call.  If
     unimplemented, produces a fatal error.  The arguments are interpreted
     as follows: if a given argument is numeric, the argument is passed as
     an int.  If not, the pointer to the string value is passed.  You are
     responsible to make sure a string is pre-extended long enough to
     receive any result that might be written into a string.  You can't
     use a string literal (or other read-only string) as an argument to
     syscall because Perl has to assume that any string pointer might be
     written through.  If your integer arguments are not literals and have
     never been interpreted in a numeric context, you may need to add 0 to
     them to force them to look like numbers.  This emulates the syswrite
     function (or vice versa):

          require 'syscall.ph';		# may need to run h2ph
          $s = "hi there\n";
          syscall(&SYS_write, fileno(STDOUT), $s, length $s);

     Note that Perl supports passing of up to only 14 arguments to your
     system call, which in practice should usually suffice.

     Syscall returns whatever value returned by the system call it calls.
     If the system call fails, syscall returns `-1' and sets $! (errno).
     Note that some system calls can legitimately return `-1'.  The proper
     way to handle such calls is to assign `$!=0;' before the call and
     check the value of $! if syscall returns `-1'.

     There's a problem with `syscall(&SYS_pipe)': it returns the file
     number of the read end of the pipe it creates.  There is no way to
     retrieve the file number of the other end.  You can avoid this
     problem by using pipe instead.

sysopen FILEHANDLE,FILENAME,MODE
sysopen FILEHANDLE,FILENAME,MODE,PERMS
     Opens the file whose filename is given by FILENAME, and associates it
     with FILEHANDLE.  If FILEHANDLE is an expression, its value is used as
     the name of the real filehandle wanted.  This function calls the
     underlying operating system's open function with the parameters
     FILENAME, MODE, PERMS.

     The possible values and flag bits of the MODE parameter are
     system-dependent; they are available via the standard module Fcntl.
     See the documentation of your operating system's open to see which
     values and flag bits are available.  You may combine several flags
     using the |-operator.

     Some of the most common values are `O_RDONLY' for opening the file in
     read-only mode, `O_WRONLY' for opening the file in write-only mode,
     and `O_RDWR' for opening the file in read-write mode, and.

     For historical reasons, some values work on almost every system
     supported by perl: zero means read-only, one means write-only, and two
     means read/write.  We know that these values do not work under OS/390
     & VM/ESA Unix and on the Macintosh; you probably don't want to use
     them in new code.

     If the file named by FILENAME does not exist and the open call creates
     it (typically because MODE includes the `O_CREAT' flag), then the
     value of PERMS specifies the permissions of the newly created file.
     If you omit the PERMS argument to sysopen, Perl uses the octal value
     `0666'.  These permission values need to be in octal, and are
     modified by your process's current umask.

     In many systems the `O_EXCL' flag is available for opening files in
     exclusive mode.  This is not locking: exclusiveness means here that
     if the file already exists, sysopen() fails.  The `O_EXCL' wins
     `O_TRUNC'.

     Sometimes you may want to truncate an already-existing file:
     `O_TRUNC'.

     You should seldom if ever use `0644' as argument to sysopen, because
     that takes away the user's option to have a more permissive umask.
     Better to omit it.  See the perlfunc(1) entry on umask for more on
     this.

     Note that sysopen depends on the fdopen() C library function.  On
     many UNIX systems, fdopen() is known to fail when file descriptors
     exceed a certain value, typically 255. If you need more file
     descriptors than that, consider rebuilding Perl to use the `sfio'
     library, or perhaps using the POSIX::open() function.

     See *Note Perlopentut: perlopentut, for a kinder, gentler explanation
     of opening files.

sysread FILEHANDLE,SCALAR,LENGTH,OFFSET
sysread FILEHANDLE,SCALAR,LENGTH
     Attempts to read LENGTH bytes of data into variable SCALAR from the
     specified FILEHANDLE, using the system call read(2).  It bypasses
     stdio, so mixing this with other kinds of reads, print, write, seek,
     tell, or eof can cause confusion because stdio usually buffers data.
     Returns the number of bytes actually read, 0 at end of file, or undef
     if there was an error.  SCALAR will be grown or shrunk so that the
     last byte actually read is the last byte of the scalar after the read.

     An OFFSET may be specified to place the read data at some place in the
     string other than the beginning.  A negative OFFSET specifies
     placement at that many bytes counting backwards from the end of the
     string.  A positive OFFSET greater than the length of SCALAR results
     in the string being padded to the required size with `"\0"' bytes
     before the result of the read is appended.

     There is no syseof() function, which is ok, since eof() doesn't work
     very well on device files (like ttys) anyway.  Use sysread() and check
     for a return value for 0 to decide whether you're done.

sysseek FILEHANDLE,POSITION,WHENCE
     Sets FILEHANDLE's system position using the system call lseek(2).  It
     bypasses stdio, so mixing this with reads (other than sysread),
     print, write, seek, tell, or eof may cause confusion.  FILEHANDLE may
     be an expression whose value gives the name of the filehandle.  The
     values for WHENCE are 0 to set the new position to POSITION, 1 to set
     the it to the current position plus POSITION, and 2 to set it to EOF
     plus POSITION (typically negative).  For WHENCE, you may also use the
     constants `SEEK_SET', `SEEK_CUR', and `SEEK_END' (start of the file,
     current position, end of the file) from the Fcntl module.

     Returns the new position, or the undefined value on failure.  A
     position of zero is returned as the string `"0 but true"'; thus
     sysseek returns true on success and false on failure, yet you can
     still easily determine the new position.

system LIST
system PROGRAM LIST
     Does exactly the same thing as `exec LIST', except that a fork is
     done first, and the parent process waits for the child process to
     complete.  Note that argument processing varies depending on the
     number of arguments.  If there is more than one argument in LIST, or
     if LIST is an array with more than one value, starts the program
     given by the first element of the list with arguments given by the
     rest of the list.  If there is only one scalar argument, the argument
     is checked for shell metacharacters, and if there are any, the entire
     argument is passed to the system's command shell for parsing (this is
     `/bin/sh -c' on Unix platforms, but varies on other platforms).  If
     there are no shell metacharacters in the argument, it is split into
     words and passed directly to execvp, which is more efficient.

     Beginning with v5.6.0, Perl will attempt to flush all files opened for
     output before any operation that may do a fork, but this may not be
     supported on some platforms (see *Note Perlport: perlport,).  To be
     safe, you may need to set $| ($AUTOFLUSH in English) or call the
     autoflush() method of IO::Handle on any open handles.

     The return value is the exit status of the program as returned by the
     wait call.  To get the actual exit value divide by 256.  See also `'
     in this node.  This is not what you want to use to capture the output
     from a command, for that you should use merely backticks or qx//, as
     described in `"`STRING`"', *Note Perlop: perlop,.  Return value of -1
     indicates a failure to start the program (inspect $! for the reason).

     Like exec, system allows you to lie to a program about its name if
     you use the `system PROGRAM LIST' syntax.  Again, see `' in this node.

     Because system and backticks block `SIGINT' and `SIGQUIT', killing the
     program they're running doesn't actually interrupt your program.

          @args = ("command", "arg1", "arg2");
          system(@args) == 0
          	 or die "system @args failed: $?"

     You can check all the failure possibilities by inspecting $? like
     this:

          $exit_value  = $? >> 8;
          $signal_num  = $? & 127;
          $dumped_core = $? & 128;

     When the arguments get executed via the system shell, results and
     return codes will be subject to its quirks and capabilities.  See
     `"`STRING`"', *Note Perlop: perlop, and `' in this node for details.

syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET
syswrite FILEHANDLE,SCALAR,LENGTH
syswrite FILEHANDLE,SCALAR
     Attempts to write LENGTH bytes of data from variable SCALAR to the
     specified FILEHANDLE, using the system call write(2).  If LENGTH is
     not specified, writes whole SCALAR.  It bypasses stdio, so mixing
     this with reads (other than `sysread())', print, write, seek, tell,
     or eof may cause confusion because stdio usually buffers data.
     Returns the number of bytes actually written, or undef if there was
     an error.  If the LENGTH is greater than the available data in the
     SCALAR after the OFFSET, only as much data as is available will be
     written.

     An OFFSET may be specified to write the data from some part of the
     string other than the beginning.  A negative OFFSET specifies writing
     that many bytes counting backwards from the end of the string.  In the
     case the SCALAR is empty you can use OFFSET but only zero offset.

tell FILEHANDLE
tell
     Returns the current position for FILEHANDLE.  FILEHANDLE may be an
     expression whose value gives the name of the actual filehandle.  If
     FILEHANDLE is omitted, assumes the file last read.

     There is no `systell' function.  Use `sysseek(FH, 0, 1)' for that.

telldir DIRHANDLE
     Returns the current position of the readdir routines on DIRHANDLE.
     Value may be given to seekdir to access a particular location in a
     directory.  Has the same caveats about possible directory compaction
     as the corresponding system library routine.

tie VARIABLE,CLASSNAME,LIST
     This function binds a variable to a package class that will provide
     the implementation for the variable.  VARIABLE is the name of the
     variable to be enchanted.  CLASSNAME is the name of a class
     implementing objects of correct type.  Any additional arguments are
     passed to the new method of the class (meaning TIESCALAR, TIEHANDLE,
     TIEARRAY, or TIEHASH).  Typically these are arguments such as might
     be passed to the `dbm_open()' function of C.  The object returned by
     the new method is also returned by the tie function, which would be
     useful if you want to access other methods in CLASSNAME.

     Note that functions such as keys and values may return huge lists
     when used on large objects, like DBM files.  You may prefer to use the
     each function to iterate over such.  Example:

          # print out history file offsets
          use NDBM_File;
          tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);
          while (($key,$val) = each %HIST) {
          	print $key, ' = ', unpack('L',$val), "\n";
          }
          untie(%HIST);

     A class implementing a hash should have the following methods:

          TIEHASH classname, LIST
          FETCH this, key
          STORE this, key, value
          DELETE this, key
          CLEAR this
          EXISTS this, key
          FIRSTKEY this
          NEXTKEY this, lastkey
          DESTROY this

     A class implementing an ordinary array should have the following
     methods:

          TIEARRAY classname, LIST
          FETCH this, key
          STORE this, key, value
          FETCHSIZE this
          STORESIZE this, count
          CLEAR this
          PUSH this, LIST
          POP this
          SHIFT this
          UNSHIFT this, LIST
          SPLICE this, offset, length, LIST
          EXTEND this, count
          DESTROY this

     A class implementing a file handle should have the following methods:

          TIEHANDLE classname, LIST
          READ this, scalar, length, offset
          READLINE this
          GETC this
          WRITE this, scalar, length, offset
          PRINT this, LIST
          PRINTF this, format, LIST
          CLOSE this
          DESTROY this

     A class implementing a scalar should have the following methods:

          TIESCALAR classname, LIST
          FETCH this,
          STORE this, value
          DESTROY this

     Not all methods indicated above need be implemented.  See *Note
     Perltie: perltie,, *Note Tie/Hash: (pm.info)Tie/Hash,, *Note
     Tie/Array: (pm.info)Tie/Array,, *Note Tie/Scalar:
     (pm.info)Tie/Scalar,, and *Note Tie/Handle: (pm.info)Tie/Handle,.

     Unlike dbmopen, the tie function will not use or require a module for
     you-you need to do that explicitly yourself.  See *Note DB_File:
     (pm.info)DB_File, or the Config module for interesting tie
     implementations.

     For further details see *Note Perltie: perltie,, `"tied VARIABLE"' in
     this node.

tied VARIABLE
     Returns a reference to the object underlying VARIABLE (the same value
     that was originally returned by the tie call that bound the variable
     to a package.)  Returns the undefined value if VARIABLE isn't tied to
     a package.

time
     Returns the number of non-leap seconds since whatever time the system
     considers to be the epoch (that's 00:00:00, January 1, 1904 for MacOS,
     and 00:00:00 UTC, January 1, 1970 for most other systems).  Suitable
     for feeding to gmtime and localtime.

     For measuring time in better granularity than one second, you may use
     either the Time::HiRes module from CPAN, or if you have
     gettimeofday(2), you may be able to use the syscall interface of
     Perl, see *Note Perlfaq8: perlfaq8, for details.

times
     Returns a four-element list giving the user and system times, in
     seconds, for this process and the children of this process.

          ($user,$system,$cuser,$csystem) = times;

tr///
     The transliteration operator.  Same as y///.  See *Note Perlop:
     perlop,.

truncate FILEHANDLE,LENGTH
truncate EXPR,LENGTH
     Truncates the file opened on FILEHANDLE, or named by EXPR, to the
     specified length.  Produces a fatal error if truncate isn't
     implemented on your system.  Returns true if successful, the
     undefined value otherwise.

uc EXPR
uc
     Returns an uppercased version of EXPR.  This is the internal function
     implementing the `\U' escape in double-quoted strings.  Respects
     current LC_CTYPE locale if `use locale' in force.  See *Note
     Perllocale: perllocale,.  Under Unicode (`use utf8') it uses the
     standard Unicode uppercase mappings.  (It does not attempt to do
     titlecase mapping on initial letters.  See ucfirst for that.)

     If EXPR is omitted, uses $_.

ucfirst EXPR
ucfirst
     Returns the value of EXPR with the first character in uppercase
     (titlecase in Unicode).  This is the internal function implementing
     the `\u' escape in double-quoted strings.  Respects current LC_CTYPE
     locale if `use locale' in force.  See *Note Perllocale: perllocale,
     and *Note Utf8: (pm.info)utf8,.

     If EXPR is omitted, uses $_.

umask EXPR
umask
     Sets the umask for the process to EXPR and returns the previous value.
     If EXPR is omitted, merely returns the current umask.

     The Unix permission `rwxr-x---' is represented as three sets of three
     bits, or three octal digits: `0750' (the leading 0 indicates octal
     and isn't one of the digits).  The umask value is such a number
     representing disabled permissions bits.  The permission (or "mode")
     values you pass mkdir or sysopen are modified by your umask, so even
     if you tell sysopen to create a file with permissions `0777', if your
     umask is `0022' then the file will actually be created with
     permissions `0755'.  If your umask were `0027' (group can't write;
     others can't read, write, or execute), then passing sysopen `0666'
     would create a file with mode `0640' (`0666 &~ 027' is `0640').

     Here's some advice: supply a creation mode of `0666' for regular
     files (in sysopen) and one of `0777' for directories (in mkdir) and
     executable files.  This gives users the freedom of choice: if they
     want protected files, they might choose process umasks of `022',
     `027', or even the particularly antisocial mask of `077'.  Programs
     should rarely if ever make policy decisions better left to the user.
     The exception to this is when writing files that should be kept
     private: mail files, web browser cookies, *.rhosts* files, and so on.

     If umask(2) is not implemented on your system and you are trying to
     restrict access for *yourself* (i.e., (EXPR & 0700) > 0), produces a
     fatal error at run time.  If umask(2) is not implemented and you are
     not trying to restrict access for yourself, returns undef.

     Remember that a umask is a number, usually given in octal; it is not a
     string of octal digits.  See also `' in this node, if all you have is
     a string.

undef EXPR
undef
     Undefines the value of EXPR, which must be an lvalue.  Use only on a
     scalar value, an array (using `@'), a hash (using %), a subroutine
     (using &), or a typeglob (using <*>).  (Saying `undef $hash{$key}'
     will probably not do what you expect on most predefined variables or
     DBM list values, so don't do that; see `delete' in this node.)
     Always returns the undefined value.  You can omit the EXPR, in which
     case nothing is undefined, but you still get an undefined value that
     you could, for instance, return from a subroutine, assign to a
     variable or pass as a parameter.  Examples:

          undef $foo;
          undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};
          undef @ary;
          undef %hash;
          undef &mysub;
          undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.
          return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;
          select undef, undef, undef, 0.25;
          ($a, $b, undef, $c) = &foo;       # Ignore third value returned

     Note that this is a unary operator, not a list operator.

unlink LIST
unlink
     Deletes a list of files.  Returns the number of files successfully
     deleted.

          $cnt = unlink 'a', 'b', 'c';
          unlink @goners;
          unlink <*.bak>;

     Note: unlink will not delete directories unless you are superuser and
     the -U flag is supplied to Perl.  Even if these conditions are met,
     be warned that unlinking a directory can inflict damage on your
     filesystem.  Use rmdir instead.

     If LIST is omitted, uses $_.

unpack TEMPLATE,EXPR
     unpack does the reverse of pack: it takes a string and expands it out
     into a list of values.  (In scalar context, it returns merely the
     first value produced.)

     The string is broken into chunks described by the TEMPLATE.  Each
     chunk is converted separately to a value.  Typically, either the
     string is a result of pack, or the bytes of the string represent a C
     structure of some kind.

     The TEMPLATE has the same format as in the pack function.  Here's a
     subroutine that does substring:

          sub substr {
          	my($what,$where,$howmuch) = @_;
          	unpack("x$where a$howmuch", $what);
          }

     and then there's

          sub ordinal { unpack("c",$_[0]); } # same as ord()

     In addition to fields allowed in pack(), you may prefix a field with
     a %<number> to indicate that you want a <number>-bit checksum of the
     items instead of the items themselves.  Default is a 16-bit checksum.
     Checksum is calculated by summing numeric values of expanded values
     (for string fields the sum of `ord($char)' is taken, for bit fields
     the sum of zeroes and ones).

     For example, the following computes the same number as the System V
     sum program:

          $checksum = do {
          	local $/;  # slurp!
          	unpack("%32C*",<>) % 65535;
          };

     The following efficiently counts the number of set bits in a bit
     vector:

          $setbits = unpack("%32b*", $selectmask);

     The p and P formats should be used with care.  Since Perl has no way
     of checking whether the value passed to `unpack()' corresponds to a
     valid memory location, passing a pointer value that's not known to be
     valid is likely to have disastrous consequences.

     If the repeat count of a field is larger than what the remainder of
     the input string allows, repeat count is decreased.  If the input
     string is longer than one described by the TEMPLATE, the rest is
     ignored.

     See `' in this node for more examples and notes.

untie VARIABLE
     Breaks the binding between a variable and a package.  (See tie.)

unshift ARRAY,LIST
     Does the opposite of a shift.  Or the opposite of a push, depending
     on how you look at it.  Prepends list to the front of the array, and
     returns the new number of elements in the array.

          unshift(ARGV, '-e') unless $ARGV[0] =~ /^-/;

     Note the LIST is prepended whole, not one element at a time, so the
     prepended elements stay in the same order.  Use reverse to do the
     reverse.

use Module VERSION LIST
use Module VERSION
use Module LIST
use Module
use VERSION
     Imports some semantics into the current package from the named module,
     generally by aliasing certain subroutine or variable names into your
     package.  It is exactly equivalent to

          BEGIN { require Module; import Module LIST; }

     except that Module must be a bareword.

     VERSION, which can be specified as a literal of the form v5.6.1,
     demands that the current version of Perl ($^V or $PERL_VERSION) be at
     least as recent as that version.  (For compatibility with older
     versions of Perl, a numeric literal will also be interpreted as
     VERSION.)  If the version of the running Perl interpreter is less
     than VERSION, then an error message is printed and Perl exits
     immediately without attempting to parse the rest of the file.
     Compare with `' in this node, which can do a similar check at run
     time.

          use v5.6.1;		# compile time version check
          use 5.6.1;		# ditto
          use 5.005_03;	# float version allowed for compatibility

     This is often useful if you need to check the current Perl version
     before useing library modules that have changed in incompatible ways
     from older versions of Perl.  (We try not to do this more than we
     have to.)

     The BEGIN forces the require and import to happen at compile time.
     The require makes sure the module is loaded into memory if it hasn't
     been yet.  The import is not a builtin-it's just an ordinary static
     method call into the Module package to tell the module to import the
     list of features back into the current package.  The module can
     implement its import method any way it likes, though most modules
     just choose to derive their import method via inheritance from the
     Exporter class that is defined in the Exporter module.  See *Note
     Exporter: (pm.info)Exporter,.  If no import method can be found then
     the call is skipped.

     If you don't want your namespace altered, explicitly supply an empty
     list:

          use Module ();

     That is exactly equivalent to

          BEGIN { require Module }

     If the VERSION argument is present between Module and LIST, then the
     use will call the VERSION method in class Module with the given
     version as an argument.  The default VERSION method, inherited from
     the UNIVERSAL class, croaks if the given version is larger than the
     value of the variable `$Module::VERSION'.

     Again, there is a distinction between omitting LIST (import called
     with no arguments) and an explicit empty LIST `()' (import not
     called).  Note that there is no comma after VERSION!

     Because this is a wide-open interface, pragmas (compiler directives)
     are also implemented this way.  Currently implemented pragmas are:

          use integer;
          use diagnostics;
          use sigtrap  qw(SEGV BUS);
          use strict   qw(subs vars refs);
          use subs     qw(afunc blurfl);
          use warnings qw(all);

     Some of these pseudo-modules import semantics into the current block
     scope (like strict or integer, unlike ordinary modules, which import
     symbols into the current package (which are effective through the end
     of the file).

     There's a corresponding no command that unimports meanings imported
     by use, i.e., it calls `unimport Module LIST' instead of import.

          no integer;
          no strict 'refs';
          no warnings;

     If no `unimport' method can be found the call fails with a fatal
     error.

     See *Note Perlmod: perlmod, for a list of standard modules and
     pragmas.

utime LIST
     Changes the access and modification times on each file of a list of
     files.  The first two elements of the list must be the NUMERICAL
     access and modification times, in that order.  Returns the number of
     files successfully changed.  The inode change time of each file is set
     to the current time.  This code has the same effect as the touch
     command if the files already exist:

          #!/usr/bin/perl
          $now = time;
          utime $now, $now, @ARGV;

values HASH
     Returns a list consisting of all the values of the named hash.  (In a
     scalar context, returns the number of values.)  The values are
     returned in an apparently random order.  The actual random order is
     subject to change in future versions of perl, but it is guaranteed to
     be the same order as either the keys or each function would produce
     on the same (unmodified) hash.

     Note that you cannot modify the values of a hash this way, because the
     returned list is just a copy.  You need to use a hash slice for that,
     since it's lvaluable in a way that values() is not.

          for (values %hash) 	    { s/foo/bar/g }   # FAILS!
          for (@hash{keys %hash}) { s/foo/bar/g }   # ok

     As a side effect, calling values() resets the HASH's internal
     iterator.  See also keys, each, and sort.

vec EXPR,OFFSET,BITS
     Treats the string in EXPR as a bit vector made up of elements of
     width BITS, and returns the value of the element specified by OFFSET
     as an unsigned integer.  BITS therefore specifies the number of bits
     that are reserved for each element in the bit vector.  This must be a
     power of two from 1 to 32 (or 64, if your platform supports that).

     If BITS is 8, "elements" coincide with bytes of the input string.

     If BITS is 16 or more, bytes of the input string are grouped into
     chunks of size BITS/8, and each group is converted to a number as with
     pack()/unpack() with big-endian formats n/N (and analoguously for
     BITS==64).  See `"pack"' in this node for details.

     If bits is 4 or less, the string is broken into bytes, then the bits
     of each byte are broken into 8/BITS groups.  Bits of a byte are
     numbered in a little-endian-ish way, as in 0x01, 0x02, 0x04, 0x08,
     0x10, 0x20, 0x40, 0x80.  For example, breaking the single input byte
     `chr(0x36)' into two groups gives a list `(0x6, 0x3)'; breaking it
     into 4 groups gives `(0x2, 0x1, 0x3, 0x0)'.

     vec may also be assigned to, in which case parentheses are needed to
     give the expression the correct precedence as in

          vec($image, $max_x * $x + $y, 8) = 3;

     If the selected element is off the end of the string, the value 0 is
     returned.  If an element off the end of the string is written to,
     Perl will first extend the string with sufficiently many zero bytes.

     Strings created with vec can also be manipulated with the logical
     operators |, &, ^, and `~'.  These operators will assume a bit vector
     operation is desired when both operands are strings.  See `"Bitwise
     String Operators"', *Note Perlop: perlop,.

     The following code will build up an ASCII string saying
     `'PerlPerlPerl''.  The comments show the string after each step.
     Note that this code works in the same way on big-endian or
     little-endian machines.

          my $foo = '';
          vec($foo,  0, 32) = 0x5065726C;	# 'Perl'

          # $foo eq "Perl" eq "\x50\x65\x72\x6C", 32 bits
          print vec($foo, 0, 8);		# prints 80 == 0x50 == ord('P')

          vec($foo,  2, 16) = 0x5065;		# 'PerlPe'
          vec($foo,  3, 16) = 0x726C;		# 'PerlPerl'
          vec($foo,  8,  8) = 0x50;		# 'PerlPerlP'
          vec($foo,  9,  8) = 0x65;		# 'PerlPerlPe'
          vec($foo, 20,  4) = 2;		# 'PerlPerlPe'   . "\x02"
          vec($foo, 21,  4) = 7;		# 'PerlPerlPer'
                                              # 'r' is "\x72"
          vec($foo, 45,  2) = 3;		# 'PerlPerlPer'  . "\x0c"
          vec($foo, 93,  1) = 1;		# 'PerlPerlPer'  . "\x2c"
          vec($foo, 94,  1) = 1;		# 'PerlPerlPerl'
                                              # 'l' is "\x6c"

     To transform a bit vector into a string or list of 0's and 1's, use
     these:

          $bits = unpack("b*", $vector);
          @bits = split(//, unpack("b*", $vector));

     If you know the exact length in bits, it can be used in place of the
     *.

     Here is an example to illustrate how the bits actually fall in place:

          #!/usr/bin/perl -wl

          print <<'EOT';
                                            0         1         2         3
                             unpack("V",$_) 01234567890123456789012345678901
          ------------------------------------------------------------------
          EOT

          for $w (0..3) {
              $width = 2**$w;
              for ($shift=0; $shift < $width; ++$shift) {
                  for ($off=0; $off < 32/$width; ++$off) {
                      $str = pack("B*", "0"x32);
                      $bits = (1<<$shift);
                      vec($str, $off, $width) = $bits;
                      $res = unpack("b*",$str);
                      $val = unpack("V", $str);
                      write;
                  }
              }
          }

          format STDOUT =
          vec($_,@#,@#) = @<< == @######### @>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          $off, $width, $bits, $val, $res
          .
          __END__

     Regardless of the machine architecture on which it is run, the above
     example should print the following table:

          0         1         2         3
                                 unpack("V",$_) 01234567890123456789012345678901
              ------------------------------------------------------------------
              vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000
              vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000
              vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000
              vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000
              vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000
              vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000
              vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000
              vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000
              vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000
              vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000
              vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000
              vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000
              vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000
              vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000
              vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000
              vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000
              vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000
              vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000
              vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000
              vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000
              vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000
              vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000
              vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000
              vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000
              vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000
              vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000
              vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000
              vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000
              vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000
              vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100
              vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010
              vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001
              vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000
              vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000
              vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000
              vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000
              vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000
              vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000
              vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000
              vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000
              vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000
              vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000
              vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000
              vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000
              vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000
              vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000
              vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000
              vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010
              vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000
              vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000
              vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000
              vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000
              vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000
              vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000
              vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000
              vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000
              vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000
              vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000
              vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000
              vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000
              vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000
              vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000
              vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100
              vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001
              vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000
              vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000
              vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000
              vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000
              vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000
              vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000
              vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000
              vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000
              vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000
              vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000
              vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000
              vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000
              vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000
              vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000
              vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000
              vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100
              vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000
              vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000
              vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000
              vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000
              vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000
              vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000
              vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000
              vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010
              vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000
              vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000
              vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000
              vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000
              vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000
              vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000
              vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000
              vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001
              vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000
              vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000
              vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000
              vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000
              vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000
              vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000
              vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000
              vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000
              vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000
              vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000
              vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000
              vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000
              vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000
              vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000
              vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000
              vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000
              vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000
              vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000
              vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000
              vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000
              vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000
              vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000
              vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000
              vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100
              vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000
              vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000
              vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000
              vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010
              vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000
              vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000
              vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000
              vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001

wait
     Behaves like the wait(2) system call on your system: it waits for a
     child process to terminate and returns the pid of the deceased
     process, or `-1' if there are no child processes.  The status is
     returned in $?.  Note that a return value of `-1' could mean that
     child processes are being automatically reaped, as described in *Note
     Perlipc: perlipc,.

waitpid PID,FLAGS
     Waits for a particular child process to terminate and returns the pid
     of the deceased process, or `-1' if there is no such child process.
     On some systems, a value of 0 indicates that there are processes
     still running.  The status is returned in $?.  If you say

          use POSIX ":sys_wait_h";
          #...
          do {
          	$kid = waitpid(-1,&WNOHANG);
          } until $kid == -1;

     then you can do a non-blocking wait for all pending zombie processes.
     Non-blocking wait is available on machines supporting either the
     waitpid(2) or wait4(2) system calls.  However, waiting for a
     particular pid with FLAGS of 0 is implemented everywhere.  (Perl
     emulates the system call by remembering the status values of
     processes that have exited but have not been harvested by the Perl
     script yet.)

     Note that on some systems, a return value of `-1' could mean that
     child processes are being automatically reaped.  See *Note Perlipc:
     perlipc, for details, and for other examples.

wantarray
     Returns true if the context of the currently executing subroutine is
     looking for a list value.  Returns false if the context is looking
     for a scalar.  Returns the undefined value if the context is looking
     for no value (void context).

          return unless defined wantarray;	# don't bother doing more
          my @a = complex_calculation();
          return wantarray ? @a : "@a";

     This function should have been named wantlist() instead.

warn LIST
     Produces a message on STDERR just like die, but doesn't exit or throw
     an exception.

     If LIST is empty and `$@' already contains a value (typically from a
     previous eval) that value is used after appending `"\t...caught"' to
     `$@'.  This is useful for staying almost, but not entirely similar to
     die.

     If `$@' is empty then the string `"Warning: Something's wrong"' is
     used.

     No message is printed if there is a `$SIG{__WARN__}' handler
     installed.  It is the handler's responsibility to deal with the
     message as it sees fit (like, for instance, converting it into a
     die).  Most handlers must therefore make arrangements to actually
     display the warnings that they are not prepared to deal with, by
     calling warn again in the handler.  Note that this is quite safe and
     will not produce an endless loop, since `__WARN__' hooks are not
     called from inside one.

     You will find this behavior is slightly different from that of
     `$SIG{__DIE__}' handlers (which don't suppress the error text, but can
     instead call die again to change it).

     Using a `__WARN__' handler provides a powerful way to silence all
     warnings (even the so-called mandatory ones).  An example:

          # wipe out *all* compile-time warnings
          BEGIN { $SIG{'__WARN__'} = sub { warn $_[0] if $DOWARN } }
          my $foo = 10;
          my $foo = 20;          # no warning about duplicate my $foo,
                                 # but hey, you asked for it!
          # no compile-time or run-time warnings before here
          $DOWARN = 1;

          # run-time warnings enabled after here
          warn "\$foo is alive and $foo!";     # does show up

     See *Note Perlvar: perlvar, for details on setting %SIG entries, and
     for more examples.  See the Carp module for other kinds of warnings
     using its carp() and cluck() functions.

write FILEHANDLE
write EXPR
write
     Writes a formatted record (possibly multi-line) to the specified
     FILEHANDLE, using the format associated with that file.  By default
     the format for a file is the one having the same name as the
     filehandle, but the format for the current output channel (see the
     select function) may be set explicitly by assigning the name of the
     format to the $~ variable.

     Top of form processing is handled automatically:  if there is
     insufficient room on the current page for the formatted record, the
     page is advanced by writing a form feed, a special top-of-page format
     is used to format the new page header, and then the record is written.
     By default the top-of-page format is the name of the filehandle with
     "_TOP" appended, but it may be dynamically set to the format of your
     choice by assigning the name to the $^ variable while the filehandle
     is selected.  The number of lines remaining on the current page is in
     variable $-, which can be set to 0 to force a new page.

     If FILEHANDLE is unspecified, output goes to the current default
     output channel, which starts out as STDOUT but may be changed by the
     select operator.  If the FILEHANDLE is an EXPR, then the expression
     is evaluated and the resulting string is used to look up the name of
     the FILEHANDLE at run time.  For more on formats, see *Note Perlform:
     perlform,.

     Note that write is not the opposite of read.  Unfortunately.

y///
     The transliteration operator.  Same as tr///.  See *Note Perlop:
     perlop,.


