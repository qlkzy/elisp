This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Tk/ComboEntry,  Next: Tk/Common,  Prev: Tk/Columns,  Up: Module List

Drop down list entry widget
***************************

NAME
====

   Tk::ComboEntry - Drop down list entry widget

SYNOPSIS
========

     use Tk;

     my $MainWindow = MainWindow->new();

     Tk::MainLoop;

DESCRIPTION
===========

   A Drop down listbox + entry widget with nice keyboard bindings

AUTHORS
=======

   Damion K. Wilson, dkw@rcm.bm

HISTORY    =cut
===============


File: pm.info,  Node: Tk/Common,  Next: Tk/Compound,  Prev: Tk/ComboEntry,  Up: Module List

private class used by Drag&Drop
*******************************

NAME
====

   Tk::DragDrop::Common - private class used by Drag&Drop

DESCRIPTION
===========

   This class provides methods to automate the the loading and declaring
of Drop and Site 'types'.


File: pm.info,  Node: Tk/Compound,  Next: Tk/ConfigSpecs,  Prev: Tk/Common,  Up: Module List

Create multi-line compound images.
**********************************

NAME
====

   Tk::Compound - Create multi-line compound images.

DESCRIPTION
===========

   Compound image types can be used to create images that consists of
multiple horizontal lines; each line is composed of a series of items
(texts, bitmaps, images or spaces) arranged from left to right. Compound
images are mainly used to embed complex drawings into widgets that support
the *-image* option. As shown in the EXAMPLE section below, a compound
image can be used to display a bitmap and a text string simutaneously in a
Tk Button widget.

   Compound images can only be used on windows on the same display as, and
with the same pixel depth and visual as the $widget used to create them.

CREATING COMPOUND IMAGES
========================

   Compounds are created using $widget->Compound.  Compounds support the
following options:

*-background* => color
     Specifies the background color of the compound image. This color is
     also used as the default background color for the bitmap items in the
     compound image.

*-borderwidth* => *pixels*
     Specifies a non-negative value indicating the width of the 3-D border
     drawn around the compound image.

*-font* => font
     Specifies the default font for the text items in the compound image.

*-foreground* => color
     Specifies the default foreground color for the bitmap and text items
     in the compound image.

*-padx* => value
     Specifies a non-negative value indicating how much extra space to
     request for the compound image in the X-direction. The value may have
     any of the forms acceptable to *Tk_GetPixels(3)*.

*-pady* => value
     Specifies a non-negative value indicating how much extra space to
     request for the compound image in the Y-direction.

*-relief* => value
     Specifies the 3-D effect desired for the background of the compound
     image. Acceptable values are *raised*, *sunken*, flat, *ridge*, and
     *groove*.

*-showbackground* => value
     Specifies whether the background and the 3D borders should be drawn.
     Must be a valid boolean value. By default the background is not drawn
     and the compound image appears to have a transparent background.

IMAGE COMMAND
=============

   When a compound image is created, Tk also creates a new object.  This
object supports the configure and cget methods described in *Note
Tk/options: Tk/options, which can be used to enquire and modify the
options described above.

   The object also supports the following methods:

*$compound*->Line?(*option =* value ...>)?
     Creates a new line at the bottom of the compound image. Lines support
     the following options:

    *-anchor* value
          Specifies how the line should be aligned along the horizontal
          axis.  When the values are w, sw or *nw*, the line is aligned to
          the left. When the values are c, s or n, the line is aligned to
          the middle.  When the values are e, *se* or ne, the line is
          aligned to the right.

    *-padx* => value
          Specifies a non-negative value indicating how much extra space to
          request for this line in the X-direction.

*$compound*->*Itemtype*?(*option =* value ...>)?
     Creates a new item of the type *Itemtype* at the end of the last line
     of the compound image. All types of items support these following
     common options:

    *-anchor* value
          Specifies how the item should be aligned along the vertical
          axis. When the values are n, *nw* or ne, the item is aligned to
          the top of the line. When the values are c, w or e, the item is
          aligned to the middle of the line.  When the values are s, *se*
          or sw, the item is aligned to the bottom of the line.

    *-padx* => value
          Specifies a non-negative value indicating how much extra space to
          request for this item in the X-direction.

    *-pady* => value
          Specifies a non-negative value indicating how much extra space to
          request for this item in the Y-direction.

    *item-type* can be any of the following:
*$compound*->Bitmap?(*option =* value ...>)?
     Creates a new bitmap item of at the end of the last line of the
     compound image. Additional options accepted by the bitmap type are:

    *-background* => color
          Specifies the background color of the bitmap item.

    *-bitmap* => name
          Specifies a bitmap to display in this item, in any of the forms
          acceptable to *Tk_GetBitmap(3)*.

    *-foreground* => color
          Specifies the foreground color of the bitmap item.

*$compound*->Image?(*option =* value ...>)?
     Creates a new image item of at the end of the last line of the
     compound image. Additional options accepted by the image type are:

    *-image* => name
          Specifies an image to display in this item. name must have been
          created with the *image create* command.

*$compound*->*Space*?(*option =* value ...>)?
     Creates a new space item of at the end of the last line of the
     compound image. Space items do not display anything. They just acts as
     space holders that add additional spaces between items inside a
     compound image. Additional options accepted by the image type are:

    *-width* => value
          Specifies the width of this space. The value may have any of the
          forms acceptable to *Tk_GetPixels(3)*.

    *-height* => value
          Specifies the height of this space. The value may have any of
          the forms acceptable to *Tk_GetPixels(3)*.

*$compound*->Text?(*option =* value ...>)?
     Creates a new text item of at the end of the last line of the compound
     image. Additional options accepted by the text type are:

    *-background* => color
          Specifies the background color of the text item.

    *-font* => name
          Specifies the font to be used for this text item.

    *-foreground* => color
          Specifies the foreground color of the text item.

    -justify value
          When there are multiple lines of text displayed in a text item,
          this option determines how the lines line up with each other.
          value must be one of left, center, or right.  *Left* means that
          the lines' left edges all line up, center means that the lines'
          centers are aligned, and right means that the lines' right edges
          line up.

    *-text* => string
          Specifies a text string to display in this text item.

    *-underline* value
          Specifies the integer index of a character to underline in the
          text item. 0 corresponds to the first character of the text
          displayed in the text item, 1 to the next character, and so on.

    *-wraplength* value
          This option specifies the maximum line length of the label
          string on this text item. If the line length of the label string
          exceeds this length, it is wrapped onto the next line, so that
          no line is longer than the specified length. The value may be
          specified in any of the standard forms for screen distances. If
          this value is less than or equal to 0 then no wrapping is done:
          lines will break only at newline characters in the text.

EXAMPLE
=======

   The following example creates a compound image with a bitmap and a text
string and places this image into a *Button(n)* widget. Notice that the
image must be created using the widget that it resides in.

     my $b = $parent->Button;
     my $c = $b->Compound;
     $b->configure(-image => $c);
     $c->Line;
     $c->Bitmap(-bitmap => 'warning');
     $c->Space(-width => 8);
     $c->Text(-text => "Warning", -underline => 0);
     $b->pack;

KEYWORDS
========

   image(n), Tix(n)


File: pm.info,  Node: Tk/ConfigSpecs,  Next: Tk/ContextHelp,  Prev: Tk/Compound,  Up: Module List

Defining behaviour of 'configure' for composite widgets.
********************************************************

NAME
====

   Tk::ConfigSpecs - Defining behaviour of 'configure' for composite
widgets.

     sub Populate
     {
      my ($composite,$args) = @_;
      ...
      $composite->ConfigSpecs('-attribute' => [ where,dbName,dbClass,default ]);
      $composite->ConfigSpecs('-alias' => '-otherattribute');
      $composite->ConfigSpecs('DEFAULT' => [ where ]);
      ...
     }

     $composite->configure(-attribute => value);

DESCRIPTION
===========

   The aim is to make the composite widget configure method look as much
like a regular Tk widget's configure as possible.  (See *Note Tk/options:
Tk/options, for a description of this behaviour.)  To enable this the
attributes that the composite as a whole accepts needs to be defined.

Defining the ConfigSpecs for a class.
-------------------------------------

   Typically a widget will have one or more calls like the following

     $composite->ConfigSpecs(-attribute => [where,dbName,dbClass,default]);

   in its Populate method. When ConfigSpecs is called this way (with
arguments) the arguments are used to construct or augment/replace a hash
table for the widget. (More than one *-option*=>value pair can be
specified to a single call.)

   *dbName*, *dbClass* and default are only used by *ConfigDefault*
described below, or to respond to 'inquiry' configure commands.

   It may be either one of the values below, or a list of such values
enclosed in [].

   The currently permitted values of where are:

'ADVERTISED'
     apply configure to *advertised* subwidgets.

'DESCENDANTS'
     apply configure recursively to all descendants.

'CALLBACK'
     Setting the attribute does `Tk::Callback->new($value)' before storing
     in `$composite->{Configure}{-attribute}'. This is appropriate for
     `-command => ...' attributes that are handled by the composite and not
     forwarded to a subwidget. (E.g. *Tk::Tiler* has `-yscrollcommand' to
     allow it to have scrollbar attached.)

     This may be the first of several 'validating' keywords (e.g. font,
     cursor, anchor etc.) that core Tk makes special for C code.

'CHILDREN'
     apply configure to all children.  (Children are the immediate
     descendants of a widget.)

'METHOD'
     Call `$cw->attribute(value)'

     This is the most general case. Simply have a method of the composite
     class with the same name as the attribute.  The method may do any
     validation and have whatever side-effects you like.  (It is probably
     worth 'queueing' using *afterIdle* for more complex side-effects.)

'PASSIVE'
     Simply store value in `$composite->{Configure}{-attribute}'.

     This form is also a useful placeholder for attributes which you
     currently only handle at create time.

'SELF'
     Apply configure to the core widget (e.g. Frame) that is the basis of
     the composite. (This is the default behaviour for most attributes
     which makes a simple Frame behave the way you would expect.) Note
     that once you have specified ConfigSpecs for an attribute you must
     explicitly include 'SELF' in the list if you want the attribute to
     apply to the composite itself (this avoids nasty infinite recursion
     problems).

$reference (blessed)
     Call $reference->configure(-attribute => value)

     A common case is where $reference is a subwidget.

     $reference may also be result of

          Tk::Config->new(setmethod,getmethod,args,...);

     *Tk::Config* class is used to implement all the above keyword types.
     The class has configure and cget methods so allows higher level code
     to always just call one of those methods on an object of some kind.

*hash reference*
     Defining:

          $cw->ConfigSpecs(
          	...
          	-option => [ { -optionX=>$w1, -optionY=>[$w2, $w3] },
          			dbname dbclass default ],
          	...
          	);

     So `$cw->configure(-option => value)' actually does

          $w1->configure(-optionX => value);
          $w2->configure(-optionY => value);
          $w3->configure(-optionY => value);

'otherstring'
     Call

          $composite->Subwidget('otherstring')->configure( -attribute => value );

     While this is here for backward compatibility with Tk-b5, it is
     probably better just to use the subwidget reference directly.  The
     only case for retaining this form is to allow an additional layer of
     abstraction - perhaps having a 'current' subwidget - this is unproven.

Aliases
     `ConfigSpecs( -alias => '-otherattribute' )' is used to make `-alias'
     equivalent to `-otherattribute'. For example the aliases

          -fg => '-foreground',
          -bg => '-background'

     are provided automatically (if not already specified).

Default Values
--------------

   When the Populate method returns *ConfigDefault* is called.  This calls

     $composite->ConfigSpecs;

   (with no arguments) to return a reference to a hash. Entries in the hash
take the form:

     '-attribute' => [ where, dbName, dbClass, default ]

   *ConfigDefault* ignores 'where' completely (and also the DEFAULT entry)
and checks the 'options' database on the widget's behalf, and if an entry
is present matching dbName/dbClass

     -attribute => value

   is added to the list of options that new will eventually apply to the
widget. Likewise if there is not a match and default is defined this
default value will be added.

   Alias entries in the hash are used to convert user-specified values for
the alias into values for the real attribute.

New()-time Configure
--------------------

   Once control returns to new, the list of user-supplied options
augmented by those from *ConfigDefault* are applied to the widget using the
configure method below.

   Widgets are most flexible and most Tk-like if they handle the majority
of their attributes this way.

Configuring composites
----------------------

   Once the above have occurred calls of the form:

     $composite->configure( -attribute => value );

   should behave like any other widget as far as end-user code is
concerned.  configure will be handled by *Tk::Derived::configure* as
follows:

     $composite->ConfigSpecs;

   is called (with no arguments) to return a reference to a hash
*-attribute* is looked up in this hash, if *-attribute* is not present in
the hash then *'DEFAULT'* is looked for instead.  (Aliases are tried as
well and cause redirection to the aliased attribute).  The result should
be a reference to a list like:

     [ where, dbName, dbClass, default ]

   at this stage only where is of interest, it maps to a list of object
references (maybe only one) foreach one

     $object->configure( -attribute => value );

   is evaled.

Inquiring attributes of composites
----------------------------------

     $composite->cget( '-attribute' );

   This is handled by  *Tk::Derived::cget* in a similar manner to
configure. At present if where is a list of more than one object it is
ignored completely and the "cached" value in

     $composite->{Configure}{-attribute}.

   is returned.

CAVEATS
=======

   It is the author's intention to port as many of the "Tix" composite
widgets as make sense. The mechanism described above may have to evolve in
order to make this possible, although now aliases are handled I think the
above is sufficient.

SEE ALSO
========

   `Tk::composite|Tk::composite' in this node, `Tk::options|Tk::options'
in this node


File: pm.info,  Node: Tk/ContextHelp,  Next: Tk/CornerBox,  Prev: Tk/ConfigSpecs,  Up: Module List

context-sensitive help with perl/Tk
***********************************

NAME
====

   Tk::ContextHelp - context-sensitive help with perl/Tk

SYNOPSIS
========

     use Tk::ContextHelp;

     $ch = $top->ContextHelp;
     $ch->attach($widget, -msg => ...);

     $ch->HelpButton($top)->pack;

     $ch2 = $top->ContextHelp(-podfile => "perlfaq");
     $ch2->attach($widget2, -pod => 'description');

DESCRIPTION
===========

   *ContextHelp* provides a context-sensitive help system. By activating
the help system (either by clicking on a *HelpButton* or calling the
activate method, the cursor changes to a left pointer with a question mark
and the user may click on any widget in the window to get a help message
or jump to the corresponding pod entry.

   *ContextHelp* accepts all the options that the Label widget accepts. In
addition, the following options are also recognized.

*-callback*
     Set a callback to be called on each state change (useful for own
     HelpButton implementations).

*-cursor*
     Use another cursor for the help mode instead of the left pointer with
     question mark.

*-helpkey*
     Enable use of a help key. A common choice would be "F1" (or written as
     "<F1>") or maybe "<Help>", if your keyboard has a help key.

*-offcursor*
     Use another cursor for the help mode shown if the underlying widget is
     not attached to the help system. The default is a left pointer with a
     strike-through question mark.

*-podfile*
     Set the pod file for the *-pod* argument of attach. The default is $0
     (the current script).

*-stayactive*
     If set to true, help mode is active until set to false. So the user
     may browse over all topics he like.

*-verbose*
     Be verbose if something goes wrong. Default is true.

*-widget*
     Use another widget instead of the default Label for displaying
     messages. Another possible choice would be Message.

METHODS
=======

   The *ContextHelp* widget supports the following non-standard methods:

*attach(*widget, option)
     Attaches the widget indicated by widget to the context-sensitive help
     system. Option may be one of the following:

    *-msg*
          The argument is the message to be shown in a popup window.

    *-pod*
          The argument is a regular expression to jump in the
          corresponding pod file. For example, if you have a topic
          DESCRIPTION where you want to jump to, you can specify

               $contexthelp->attach($widget, -pod => '^\s*DESCRIPTION');

    *-podfile*
          The argument is a pod name to be used instead of the default pod
          file.  *-podfile* may be used together with *-pod* or all alone.

    *-command*
          The argument is a user-defined command to be called when
          activating the help system on this widget.

*detach(*widget)
     Detaches the specified widget widget from the help system.

activate
     Turn the help system on.

deactivate
     Turn the help system off.

toggle
     Toggle help system on or off.

*HelpButton(*top, options)
     Create a help button. It is a regular Button with *-bitmap* set to
     the help cursor bitmap and *-command* set to activation of the help
     system. The argument top is the parent widget, options are additional
     options for the help button.

     The button stays pressed as the help is activated. Clicking on the
     pressed button causes the end of the help mode. Clicking with
     mousebutton-3 causes the help system to stay active until the user
     clicks on the button over again.

BUGS
====

   * The user cannot click on the border of an attached widget to raise the
     help window.

   * While in help mode, it is possible to click on buttons even if the
     buttons aren't attached to the help system. This is non-intuitive, but
     hard to fix. (Maybe a solution: create inputo-widgets for all
     not-attached widgets while in context mode)

TODO
====

     * optional use of html browsers (netscape -remote openURL ...)

     * on Win32, make InputO work and use the native help system

AUTHOR
======

   Slaven Rezic <`eserte@cs.tu-berlin.de'>

   Some code and documentation is derived from Rajappa Iyer's
*Tk::Balloon*.

   Copyright (c) 1998,2000 Slaven Rezic. All rights reserved.  This
package is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

SEE ALSO
========

   Tk::Balloon(3), Tk::Pod(3).


File: pm.info,  Node: Tk/CornerBox,  Next: Tk/DItem,  Prev: Tk/ContextHelp,  Up: Module List

a geometry manager for scaling two subwidgets
*********************************************

NAME
====

   Tk::CornerBox - a geometry manager for scaling two subwidgets

SYNOPSIS
========

     use Tk;

     use Tk::CornerBox;

     my $l_MainWindow = MainWindow->new();

     my $l_Corner = $l_MainWindow->CornerBox();

     $l_Corner->place
        (
         '-width' => 20,
         '-height' => 20,
         '-relx' => 1,
         '-rely' => 1,
         '-anchor' => 'se',
         '-x' => -3,
         '-y' => -3,
        );

     Tk::MainLoop();

DESCRIPTION
===========

   The CornerBox is a simple textured widget that allows you to resize the
window its in by dragging it.  You use it by creating one in the regular
Tk manner and (preferably) packing or placing it in the lower right corner
of your window. It is frame derived and should act accordingly.

AUTHORS
=======

   Damion K. Wilson, dkw@rcm.bm

   Based on the little corner drag widget that you see all over the place.

   Hey, I know it's a M$oft thingy but I've got to integrate my Perl/Tk
apps into that environment.

HISTORY    February 1999: Actually started using it
===================================================


File: pm.info,  Node: Tk/DItem,  Next: Tk/Date,  Prev: Tk/CornerBox,  Up: Module List

Tix Display Items
*****************

NAME
====

   Tk::DItem - Tix Display Items

DESCRIPTION
===========

   The Tix *Display Items* and *Display Types* are devised to solve a
general problem: many Tix widgets (both existing and planned ones) display
many items of many types simultaneously.

   For example, a hierarchical listbox widget (see *Note Tk/HList:
Tk/HList,) can display items of images, plain text and subwindows in the
form of a hierarchy. Another widget, the tabular listbox widget (see *Note
Tk/TList: Tk/TList,) also displays items of the same types, although it
arranges the items in a tabular form. Yet another widget, the spreadsheet
widget (see *Note Tk/TixGrid: Tk/TixGrid,), also displays similar types
items, but in yet another format.

   In these examples, the display items in different widgets are only
different in how they are arranged by the *host widget*. In Tix, display
items are clearly separated from the host widgets. The advantage is
two-fold: first, the creation and configuration of display items become
uniform across different host widgets. Second, new display item types can
be added without the need to modify the existing host widgets.

   In a way, Tix display items are similar to the items inside Tk the
canvas widget. However, unlike the Tix display items, the canvas items are
not independent of the canvas widget; this makes it impossible to use the
canvas items inside other types of TK widgets.

   The appearance of a display item is controlled by a set of attributes.
It is observed that each the attributes usually fall into one of two
categroies: "*individual*" or "*collective*". For example, the text items
inside a HList widget may all display a different text string; however, in
most cases, the text items share the same color, font and spacing. Instead
of keeping a duplicated version of the same attributes inside each display
item, it will be advantageous to put the collective attributes in a
special object called a *display style*. First, there is the space
concern: a host widget may have many thousands of items; keeping
dupilcated attributes will be very wasteful. Second, when it becomes
necessary to change a collective attribute, such as changing all the text
items' foreground color to red, it will be more efficient to change only
the display style object than to modify all the text items one by one.

   The attributes of the a display item are thus stored in two places: it
has a set of *item options* to store its individual attributes. Each
display item is also associated with a *display style*, which specifies
the collective attributes of all items associated with itself.

   The division between the individual and collective attributes are fixed
and cannot be changed. Thus, when it becomes necessary for some items to
differ in their collective attributes, two or more *display styles* can be
used. For example, suppose you want to display two columns of text items
inside an HList widget, one column in red and the other in blue. You can
create a TextStyle object called "$red" which defines a red foreground,
and another called "$blue", which defines a blue foreground. You can then
associate all text items of the first column to "$red" and the second
column to "$blue"

DISPLAY ITEM TYPES AND OPTIONS
==============================

   Currently there are three types of display items: text, *imagetext* and
window.

IMAGETEXT ITEMS
===============

   Display items of the type *imagetext* are used to display an image
together with a text string. Imagetext items support the following options:

Imagetext Item Options
----------------------

Name:	bitmap
Class:	Bitmap
Switch:	*-bitmap*
     Specifies the bitmap to display in the item.

Name:	image
Class:	Image
Switch:	*-image*
     Specifies the image to display in the item. When both the *-bitmap*
     and *-image* options are specified, only the image will be displayed.

Name:	*imageTextStyle*
Class:	*ImageTextStyle*
Switch:	*-style*
     Specifies the display style to use for this item. Must be the name of
     a *imagetext* display style that has already be created with
     *ItemStyle*.

Name:	*showImage*
Class:	*ShowImage*
Switch:	*-showimage*
     A Boolean value that specifies whether the image/bitmap should be
     displayed.

Name:	*showText*
Class:	*ShowText*
Switch:	*-showtext*
     A Boolean value that specifies whether the text string should be
     displayed.

Name:	text
Class:	Text
Switch:	*-text*
     Specifies the text string to display in the item.

Name:	underline
Class:	*Underline*
Switch:	*-underline*
     Specifies the integer index of a character to underline in the text
     string in the item.  0 corresponds to the first character of the text
     displayed in the widget, 1 to the next character, and so on.

Imagetext Style Options
-----------------------

   The style information of *imagetext* items are stored in the
*imagetext* display style. The following options are supported:

   STANDARD OPTIONS

   *-activebackground*	*-activeforeground* *-anchor*	*-background*
*-disabledbackground*	*-disabledforeground* *-foreground*	*-font*
-justify	*-padx* *-pady*	*-selectbackground*
*-selectforeground*	*-wraplength*

   See *Note Tk/options: Tk/options, for details of the standard options.

   *STYLE-SPECIFIC OPTIONS*

Name:	gap
Class:	*Gap*
Switch:	*-gap*
     Specifies the distance between the bitmap/image and the text string,
     in number of pixels.

Name:	*textAnchor*
Class:	*TextAnchor*
Switch:	*-textanchor*
     The anchor position on the image to which text part is attached.
     This is a perl/Tk addition. Defaults to e for compatibility with
     standard Tix. The interesting cases are

    n
          Text is centred above the image.

    s
          Text is centred below the image

    e
          Text is centred to right of the image.

    w
          Text is centred to left of the image.

    c
          Text is centred over the image.

     The sw, *se*, ne, and b<nw> cases look rather odd.

     To get items to line up correctly it will usually be necessary to
     specify *-anchor* as well. e.g. with default e then anchoring item as
     a whole w lines images up down left with text stuck to right side.

TEXT ITEMS
==========

   Display items of the type text are used to display a text string in a
widget. Text items support the following options:

Text Item Options
-----------------

Name:	*textStyle*
Class:	*TextStyle*
Switch:	*-style*
     Specifies the display style to use for this text item. Must be the
     name of a text display style that has already be created with
     *ItemStyle*.

Name:	text
Class:	Text
Switch:	*-text*
     Specifies the text string to display in the item.

Name:	underline
Class:	*Underline*
Switch:	*-underline*
     Specifies the integer index of a character to underline in the item.
     0 corresponds to the first character of the text displayed in the
     widget, 1 to the next character, and so on.

Text Style Options
------------------

   STANDARD OPTIONS

   *-activebackground*	*-activeforeground* *-anchor*	*-background*
*-disabledbackground*	*-disabledforeground* *-foreground*	*-font*
-justify	*-padx* *-pady*	*-selectbackground*
*-selectforeground*	*-wraplength*

   See *Note Tk/options: Tk/options, for details of the standard options.

WINDOW ITEMS
============

   Display items of the type window are used to display a sub-window in a
widget. Window items support the following options:

Window Item Options
-------------------

Name:	*windowStyle*
Class:	*WindowStyle*
Switch:	*-style*
     Specifies the display style to use for this window item. Must be the
     name of a window display style that has already be created with the
     *ItemStyle* method.

Name:	window
Class:	Window
Switch:	*-window*
Alias:	*-widget*
     Specifies the sub-window to display in the item.

Window Style Options
--------------------

   *STYLE STANDARD OPTIONS*

   *-anchor*	*-padx*	*-pady*

   See *Note Tk/options: Tk/options, for details of the standard options.

CREATING DISPLAY ITEMS
======================

   Display items do not exist on their and thus they cannot be created
independently of the widgets they reside in. As a rule, display items are
created by special methods of their "host" widgets. For example, the HList
widgets has a method item which can be used to create new display items.
The following code creates a new text item at the third column of the
entry foo inside an HList widget:

     my $hlist = $parent->HList(-columns=>3);
     $hlist->add('foo');
     $hlist->itemCreate('foo', 2, -itemtype=>'text', -text=>'Hello');

   The *itemCreate* method of the HList widget accepts a variable number
of arguments. The special argument *-itemtype* specifies which type of
display item to create. Options that are valid for this type of display
items can then be specified by one or more *option-value* pairs.

   After the display item is created, they can then be configured or
destroyed using the methods provided by the host widget. For example, the
HList widget has the methods *itemConfigure*, *itemCget* and *itemDelete*
for accessing the display items.

CREATING AND MANIPULATING ITEM STYLES
=====================================

   Item styles are created with *ItemStyle*:

SYNOPSIS
========

      $widget->*ItemStyle*(*itemType* ?,*-stylename*=>name?
?,*-refwindow*=>*pathName*? ?,option=>value, ...>?);

   *itemType* must be one of the existing display items types such as
text, *imagetext*, window or any new types added by the user. Additional
arguments can be given in one or more *option-value* pairs. option can be
any of the valid option for this display style or any of the following:

*-stylename* => name
     Specifies a name for this style. If unspecified, then a default name
     will be chosen for this style.

*-refwindow* => *$otherwidget*
     Specifies a window to use for determine the default values of the
     display type. If unspecified, the $widget will be used. Default
     values for the display types can be set via the options database. The
     following example sets the *-disablebackground* and
     *-disabledforeground* options of a text display style via the option
     database:

          $widget->optionAdd('*table.list*disabledForeground' => 'blue');
          $widget->optionAdd('*table.list*disabledBackground' => 'darkgray');
          $widget->ItemStyle('text', -refwindow => $table_list, -fg => 'red');

     By using the option database to set the options of the display styles,
     we can advoid hard-coding the option values and give the user more
     flexibility in customization. See *Note Tk/option: Tk/option, for a
     detailed description of the option database.

STYLE METHODS
=============

   The *ItemStyle* method creates an object.  This object supports the
configure and cget methods described in *Note Tk/options: Tk/options,
which can be used to enquire and modify the options described above.

   The following additional methods are available for item styles:

$style->delete
     Destroy this display style object.

EXAMPLE
=======

   The following example creates two columns of data in a HList widget.
The first column is in red and the second column in blue. The colors of
the columns are controlled by two different text styles. Also, the anchor
and font of the second column is chosen so that the income data is aligned
properly.

     use strict;
     use Tk;
     use Tk::HList;
     use Tk::ItemStyle;

     my $mw = MainWindow->new();

     my $hlist = $mw->HList(-columns=>2)->pack;

     my $red  = $hlist->ItemStyle('text', -foreground=>'#800000');
     my $blue = $hlist->ItemStyle('text', -foreground=>'#000080', -anchor=>'e');

     my $e;
     foreach ([Joe => '$10,000'], [Peter => '$20,000'],
              [Raj => '$90,000'],  [Zinh => '$0']) {
         $e = $hlist->addchild("");
         $hlist->itemCreate($e, 0, -itemtype=>'text',
     		-text=>$_->[0], -style=>$red );
         $hlist->itemCreate($e, 1, -itemtype=>'text',
     		-text=>$_->[1], -style=>$blue);
     }

     Tk::MainLoop;

SEE ALSO
========

   `Tk::HList|Tk::HList' in this node `Tk::TixGrid|Tk::TixGrid' in this
node `Tk::TList|Tk::TList' in this node

KEYWORDS
========

   display item, display style, item style


File: pm.info,  Node: Tk/Date,  Next: Tk/DateEntry,  Prev: Tk/DItem,  Up: Module List

a date/time widget for perl/Tk
******************************

NAME
====

   Tk::Date - a date/time widget for perl/Tk

SYNOPSIS
========

     use Tk::Date;
     $date_widget = $top->Date->pack;
     $date_widget->get("%x %X");

DESCRIPTION
===========

   Tk::Date implements a date/time widget. There are three ways to input a
date:

   * Using the keyboard to input the digits and the tab key or the mouse
     pointer to move focus between fields.

   * Using up and down cursor keys to increment/decrement the date (only
     with installed Tk::NumEntryPlain widget).

   * Selecting up and down arrow buttons will increment or decrement the
     value of the active field (only with installed Tk::FireButton widget).

The Date/Time Format
--------------------

   Unlike Java, Perl does not have a date/time object. However, it is
possible to use the unix time (seconds since epoch, that is 1st January
1970) as a replacement. This is limited, since on most architectures, the
valid range is between 14th December 1901 and 19th January 2038. For other
dates, it is possible to use a hash notation:

     { y => year,
       m => month,
       d => day,
       H => hour,
       M => minute,
       S => second }

   The abbreviations are derivated from the format letters of strftime.
Note that year is the full year (1998 instead of 98) and month is the real
month number, as opposed to the output of localtime(), where the month is
subtracted by one.

   In this document, the first method will be referred as *unixtime* and
the second method as *datehash*.

STANDARD OPTIONS
================

   Tk::Date descends from Frame and inherits all of its options.

-orient
     Specified orientation of the increment and decrements buttons. May be
     vertical (default) or horizontal.

WIDGET-SPECIFIC OPTIONS
=======================

   Some options are only available if the prerequisite modules from the
Tk-GBARR distribution are installed too.

-allarrows
     If true then all entry fields will obtain arrows. Otherwise only one
     arrow pair for each date and time will be drawn. This option can be
     set only while creating the widget. This option needs the Tk::NumEntry
     widget to be installed.

-bell
     Specifies a boolean value. If true then a bell will ring if the user
     attempts to enter an illegal character (e.g. a non-digit).

-check
     If set to a true value, Tk::Date makes sure that the user can't input
     incorrect dates. This option can be set only while creating the
     widget.

-choices
     Creates an additional choice button. The argument to *-choices* must
     be one of now, `today', yesterday or tomorrow, or an array with a
     combination of those. If only one is used, only a simple button is
     created, otherwise an optionmenu. This option can be set only while
     creating the widget.

     Examples:

          -choices => 'now'
          -choices => ['today', 'yesterday', 'tomorrow']

     It is possible to specify user-defined values. User-defined values
     should be defined as array elements with two elements. The first
     element is the label for the button or optionmenu entry. The second
     element specifies the time associated with this value. It may be
     either a date hash (missing values are set to the current date) or a
     subroutine which calculates unix seconds.

     Here are two examples. The first defines an additional optionmenu
     entry for this year's christmas and the second defines an entry for
     the day before yesterday.

          -choices => ['today',
                               ['christmas' => { 'm' => 12, 'd' => 25}]
                              ]
                  -choices => ['today',
          	     'yesterday',
                               ['the day before yesterday' => sub { time()-86400*2 }]
                              ]

-command
     Specifies a callback which is executed every time after an arrow
     button is selected. The callback is called with the following
     arguments: reference of date widget, field specifier, increment value.
     The field specifier is either "date" or "time" or one of "H", "M",
     "S", "d", "m", "y" for the possible time and date fields.

-datefmt
     This is a sprintf/printf-like format string for setting the order and
     format of the date entries. By default, the format string is
     "%2d.%2m.%4y" meaning a two-character wide day entry, followed by a
     dot, followed by a two-character wide month entry, another dot, and
     finally a four-character wide year entry. The characters are the same
     as in the strftime function (see *Note POSIX: POSIX,). It is also
     possible to use the 'A' letter for displaying the (localized) weekday
     name. See below in the EXAMPLES section for a more US-like date
     format. This option can be set only while creating the widget.

-decbitmap
     Sets the bitmap for the decrease button. Defaults to FireButton's
     default decrease bitmap.

-editable
     If set to a false value, disables editing of the date widget. All
     entries are converted to labels and there are no arrow buttons.
     Defaults to true (widget is editable). This option can be set only
     while creating the widget.

-fields
     Specifies which fields are constructed: date, time or both. Defaults
     to both. This option can be set only while creating the widget.

-incbitmap
     Sets the bitmap for the increase button. Defaults to FireButton's
     default increase bitmap.

-monthmenu
     Use an optionmenu for input of the month.

-monthnames
     Replace the standard month names (either English or as supplied by
     the locale system) with a user-defined array. The argument should be a
     reference to a hash with 12 elements.

-precommand
     Specifies a callback which is executed every time when an arrow button
     is selected and before actually execute the increment or decrement
     command. The callback is called with following arguments: date widget,
     type (either date or time) and increment (+1 or -1). If the callback
     returns with a false value, the increment or decrement command will
     not be executed.

-repeatinterval
     Specifies the amount of time between invokations of the increment or
     decrement. Defaults to 50 milliseconds.

-repeatdelay
     Specifies the amount of time before the increment or decrement is
     first done after the Button-1 is pressed over the widget. Defaults to
     500 milliseconds.

-timefmt
     This is a sprintf/printf-like format string for setting the order and
     format of the time entries. By default, the format string is
     "%2H.%2M.%2S" meaning a two-character wide hour entry, followed by a
     dot, followed by a two-character wide minute entry, another dot, and
     finally a two-character wide seconds entry. The characters are the
     same as in the strftime function (see *Note POSIX: POSIX,). This
     option can be set only while creating the widget.

-selectlabel
     Change label text for choice menu. Defaults to 'Select:'. This option
     can be set only while creating the widget.

-value
     Sets an initial value for the widget. The argument may be *unixtime*,
     *datehash* or now (for the current time).

-varfmt
     Specifies the format of the *-variable* or *-value* argument. May be
     *unixtime* (default) or *datehash*. This option can be set only while
     creating the widget.

-variable
     Ties the specified variable to the widget. (See Bugs)

-weekdays
     Replace the standard weekday names (either English or as supplied by
     the locale system) with a user-defined array. The argument should be a
     reference to a hash with seven elements. The names have to start with
     Sunday.

METHODS
=======

   The Date widget supports the following non-standard method:

get([fmt])
     Gets the current value of the date widget. If fmt is not given or
     equal "%s", the returned value is in unix time (seconds since epoch).
     This should work on all systems.

     Otherwise, fmt is a format string which is fed to strftime.  strftime
     needs the `POSIX|POSIX' in this node module installed and therefore
     may not work on all systems.

EXAMPLES
========

   Display a date widget with only the date field in the format dd/mm/yyyy
and get the value in the same format:

     $date = $top->Date(-datefmt => '%2d/%2m/%4y',
     	  	     -fields => 'date',
     		     -value => 'now')->pack;
     # this "get" only works for systems with POSIX.pm
     $top->Button(-text => 'Get date',
     	       -command => sub { warn $date->get("%d/%m/%Y") })->pack;

   Use the datehash format instead of unixtime:

     $top->Date(-fields  => 'date',
     	     -value   => {'d' => '13', 'm' => '12', 'y' => '1957'},
     	     -varfmt => 'datehash',
     	    )->pack;

NOTES
=====

   Please note that the full set of features only available, if the
Tk-GBARR distribution is also installed. However, the widget also works
without this distribution, only lacking the arrow buttons.

   If the POSIX module is available, localised weekday and month names
will be used instead of English names. Otherwise you have to use the
-weekday and -monthnames options.

BUGS/TODO
=========

     - The -orient option can be only set while creating the widget. Also
       other options are only settable at create time.

     - waiting for a real perl Date/Time object
     - tie interface (-variable) does not work if the date widget gets destroyed
       (see uncommented DESTROY)
     - get and set must use the tied variable, otherwise tieying does no work
       at all
     - -from/-to is missing (limit) (or -minvalue, -maxvalue?)
     - range check (in DateNumEntryPlain::incdec)
     - am/pm
     - more interactive examples are needed for some design issues (how strong
       signal errors? ...)
     - check date-Function
     - optionally use Tk::DateEntry for the date part
     - -command is not fully implemented

SEE ALSO
========

   `Tk|Tk' in this node, `Tk::NumEntryPlain|Tk::NumEntryPlain' in this
node, `Tk::FireButton|Tk::FireButton' in this node, `POSIX|POSIX' in this
node

AUTHOR
======

   Slaven Rezic <eserte@cs.tu-berlin.de>

COPYRIGHT
=========

   Copyright (c) 1997, 1998, 1999, 2000 Slaven Rezic. All rights reserved.
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Tk/DateEntry,  Next: Tk/Derived,  Prev: Tk/Date,  Up: Module List

Drop down calendar widget for selecting dates.
**********************************************

NAME
====

   Tk::DateEntry - Drop down calendar widget for selecting dates.

SYNOPSIS
========

   $dateentry = $parent->DateEntry (<options>);

DESCRIPTION
===========

   Tk::DateEntry is a drop down widget for selecting dates. It looks like
the BrowseEntry widget with an Entry followed by an arrow button, but in
stead of displaying a Listbox the DateEntry displays a calendar with
buttons for each date. The calendar contains buttons for browsing through
the months.

   When the drop down is opened, the widget will try to read the current
content of the widget (the -textvariable), and display the month/year
specified. If the variable is entry, or contains invalid data, the current
month is displayed. If one or two digit year is specified, the widget
tries to guess the correct century by using a "100 year window".

REQUIREMENTS
============

   Tk::DateEntry requires Time::Local and POSIX (strftime) (and basic
Perl/Tk of course....)

OPTIONS
=======

-arrowimage => image
     Use alternative image for the arrow button.

-dateformat => integer
     Specify dateformat to use:


          1 = MM/DD/YYYY - default.


          2 = YYYY/MM/DD


          3 = DD/MM/YYYY

     See also "DATE FORMATS" below.

-parsecmd => \&callback
     In stead of using one of the builtin dateformats, you can specify your
     own by supplying a subroutine for parsing (-parsecmd) and formatting
     (-formatcmd) of the date string. These options overrides -dateformat.
     See "DATE FORMATS" below.

-formatcmd => \&callback
     See -parsecmd above and "DATE FORMATS" below.

-background => color
     Sets the background color for the Entry subwidget. Note that the
     dropdown calendar is not affected by this option. See also
     -boxbackground, -buttonbackground and -todaybackground.

-buttonbackground => color
     Sets the background color for all button in the dropdown calendar.

-boxbackground => color
     Sets the background color for the dropdown widget (not including the
     buttons).

-todaybackground => color
     Sets the background color for the button representing the current
     date.

-font => font
     Sets the font for all subwidgets.

-daynames => [qw/Sun Mon Tue Wed Thu Fri Sat/]
     Specifies the daynames which is used in the calendar heading.  The
     default is [qw/S M Tu W Th F S/]. Note that the array MUST begin with
     the name of Sunday, even if -weekstart specifies something else than
     0 (which is Sunday). See also "WEEKS" below.

-weekstart => number
     Use this if you don't want the weeks to start on Sundays. Specify a
     number between 0 (Sunday) and 6 (Saturday). See "WEEKS" below.

-headingfmt => string
     Format for the Month name heading. The month name heading is created
     by calling strftime(format,0,0,0,1,month,year). Default format is '%B
     %Y'.  Note that only month and year will have sensible values,
     including day and/or time in the heading is possible, but it makes no
     sense.

-state => string
     'normal', 'disabled' or 'readonly'. The latter forces the user to use
     the drop down, editing in the Entry subwidget is disabled.

-width => number
     Width of the Entry subwidget, default is 10 (which fits the default
     date format MM/DD/YYYY).

     All other options are handled by the Entry subwidget.

DATE FORMATS
============

   The default date format is MM/DD/YYYY. Since Tk::DateEntry has to parse
the date to decide which month to display, you can't specify strftime
formats directly (like "-dateformat => 'Date: %D. %B'").

   The "builtin" date formats are:


     -dateformat => 1       - MM/DD/YYYY (default)


     -dateformat => 2       - YYYY/MM/DD


     -dateformat => 3       - DD/MM/YYYY

   Trailing fields that are missing will be replaced by the current date,
if the year is specified by one or two digits, the widget will guess the
century by using a "100 year window".

   If you're not satisified with any of these formats, you might specify
your own parse- and format routine by using the -parsecmd and -formatcmd
options.

   The -parsecmd subroutine will be called whenever the pulldown is opened.
The subroutine will be called with the current content of -textvariable as
the only argument. It should return a three element list: (year, month,
day).  Any undefined elements will be replaced by default values.

   The -formatcmd subroutine will be called whenever the user selects a
date.  It will be called with three arguments: (year, month, day). It
should return a single string which will be assigned to the -textvariable.

   See "EXAMPLES" below.

WEEKS
=====

   The default is to display the calendar the same way as the unix "cal"
command does: Weeks begin on Sunday, and the daynames are S, M, Tu, W, Th,
F, and S.

   However, some people prefer to start the weeks at Monday (saving both
Saturday and Sunday to the weekEND...)  This can be achived by specifying
-weekstart=>1. -weekstart=>0 causes the week to start at Sunday, which is
the default. If you have a very odd schedule, you could also start the
week at Wednesday by specifying -weekstart=>3 .....

   If you don't like the "cal" headings, you might specify something else
by using the -daynames option.

   See "EXAMPLES" below.

EXAMPLES
========

The simplest way:
-----------------

     $parent-&>DateEntry-&>pack;

Other daynames:
---------------

   If you want the "locale's abbreviated weekday name" you do it like this:

     use POSIX qw/strftime/;
     my @daynames=();
     foreach (0..6) {
     	push @daynames,strftime("%a",0,0,0,1,1,1,$_);
     }
     $parent->DateEntry(-daynames=>\@daynames)->pack;

Other date formats:
-------------------

   A Norwegian would probably do something like this:

     my $dateentry=$parent->DateEntry
     	(-weekstart=>1,
     	 -daynames=>[qw/Son Man Tir Ons Tor Fre Lor/],
     	 -parsecmd=>sub {
     		my ($d,$m,$y) = ($_[0] =~ m/(\d*)\/(\d*)-(\d*)/);
     		return ($y,$m,$d);
     	 },
     	 -formatcmd=>sub {
     		sprintf ("%d/%d-%d",$_[2],$_[1],$_[0]);
     	 }
     	)->pack;

   Note that this -parsecmd will return (undef,undef,undef) even if one or
two of the fields are present. A more sophisticated regex might be
needed....

CAVEATS
=======

   Tk::DateEntry uses timelocal(), localtime() and strftime().  These
functions are based on the standard unix time representation, which is the
number of seconds since 1/1/1970.

   This means that Tk::DateEntry don't support dates prior to 1970, and on
a 32 bit computer it don't support dates after 12/31/2037.

SEE ALSO
========

   Tk::Entry


