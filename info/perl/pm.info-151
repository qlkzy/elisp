This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: GD/Graph3d,  Next: GD/Graph/Data,  Prev: GD/Graph,  Up: Module List

Create 3D Graphs with GD and GD::Graph
**************************************

NAME
====

   GD::Graph3D - Create 3D Graphs with GD and GD::Graph

SYNOPSIS
========

     use GD::Graph::moduleName;
     @data = (
        ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        [ 1203,  3500,  3973,  2859,  3012,  3423,  1230]
     );
     $graph->set(
     	x_label           => 'Day of the week',
     	y_label           => 'Number of hits',
     	title             => 'Daily Summary of Web Site',
     );
     $graph = GD::Graph::moduleName->new( 400, 300 );
     my $gd = $graph->plot( \@data );

   Where *moduleName* is one of `bars3d', `lines3d' or `pie3d'.

DESCRIPTION
===========

   This is the GD::Graph3d extensions module. It provides 3D graphs for the
GD::Graph module by Martien Verbruggen, which in turn generates graph
using Lincoln Stein's GD.pm.

   You use these modules just as you would any of the GD::Graph modules,
except that they generate 3d-looking graphs. Each graph type is described
below with only the options that are unique to the 3d version. The modules
are based on their 2d versions (e.g. GD::Graph::bars3d works like
GD::Graph::bars), and support all the options in those. Make sure to read
the documentation on GD::Graph.

GD::Graph::pie3d
     This is merely a wrapper around GD::Graph::pie for consistency. It
     also sets 3d pie mode by default (which GD::Graph does as of version
     1.22).  All options are exactly as in GD::Graph::pie.

GD::Graph::bars3d
     This works like GD::Graph::bars, but draws 3d bars. The following
     settings are new or changed in GD::Graph::bars3d.

    bar_depth
          Sets the z-direction depth of the bars. This defaults to 10. If
          you have a large number of bars or a small chart width, you may
          want to change this.  A visually good value for this is
          approximately width_of_chart / number_of_bars.

    overwrite
          In GD::Graph::bars, multiple series of bars are normally drawn
          side-by-side.  You can set overwrite to 1 to tell it to draw
          each series behind the previous one. By setting overwrite to 2
          you can have them drawn on top of each other, that is the series
          are stacked.

    shading
          By default this is set to '1' and will shade and highlight the
          bars (and axes).  The light source is at top-left-center which
          scan well for most computer users. You can disable the shading
          of bars and axes by specifiying a false value for this option.

GD::Graph::lines3d
     This works like GD::Graph::lines, but draws 3d line. The following
     settings are new or changed in GD::Graph::line3d.

    line_depth
          Sets the z-direction depth of the lines. This defaults to 10. If
          you have a large number of bars or a small chart width, you may
          want to change this.  A visually good value for this is
          approximately width_of_chart / number_of_bars.

    shading
          By default this is set to '1' and will shade and highlight the
          line (and axes).  The light source is at top-left-center which
          scan well for most computer users. You can disable the shading
          of lines and axes by specifiying a false value for this option.

VERSION
=======

   0.54 (Septemnber 4, 2000)

INSTALLATION
============

   You will need to have the GD::Graph version 1.30 or later installed.
You should also have Perl version 5.005 or 5.6 installed.

   To install, just do the normal:

     perl Makefile.PL
     make
     make install

   The documentation is in GD::Graph::Graph3d.pod.

AUTHOR
======

   Jeremy Wadsack for Wadsack-Allen Digital Group.
<`dgsupport@wadsack-allen.com'>

   Most of the modules are based on the GD::Graph modules by Martien
Verbruggen.

LATEST RELEASE
==============

   The latest release is available from CPAN: http://www.cpan.org/.

COPYRIGHT
=========

   Copyright (c) 1999,2000 Wadsack-Allen. All rights reserved.

   Much of the original code is from GD::Graph:

   GIFgraph: Copyright (c) 1995-1999 Martien Verbruggen.

   Chart::PNGgraph: Copyright (c) 1999 Steve Bonds.

   GD::Graph: Copyright (c) 1999 Martien Verbruggen.

   This package is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: GD/Graph/Data,  Next: GD/Graph/Error,  Prev: GD/Graph3d,  Up: Module List

Data set encapsulation for GD::Graph
************************************

NAME
====

   GD::Graph::Data - Data set encapsulation for GD::Graph

SYNOPSIS
========

   use GD::Graph::Data;

DESCRIPTION
===========

   This module encapsulates the data structure that is needed for GD::Graph
and friends. An object of this class contains a list of X values, and a
number of lists of corresponding Y values. This only really makes sense if
the Y values are numerical, but you can basically store anything.
Undefined values have a special meaning to GD::Graph, so they are treated
with care when stored.

   Many of the methods of this module are intended for internal use by
GD::Graph and the module itself, and will most likely not be useful to
you. Many won't even *seem* useful to you...

EXAMPLES
========

     use GD::Graph::Data;
     use GD::Graph::bars;

     my $data = GD::Graph::Data->new();

     $data->read(file => '/data/sales.dat', delimiter => ',');
     $data = $data->copy(wanted => [2, 4, 5]);

     # Add the newer figures from the database
     use DBI;
     # do DBI things, like connecting to the database, statement
     # preparation and execution

     while (@row = $sth->fetchrow_array)
     {
     	  $data->add_point(@row);
     }

     my $chart = GD::Graph::bars->new();
     my $gd = $chart->plot($data);

   or for quick changes to legacy code

     # Legacy code builds array like this
     @data = ( [qw(Jan Feb Mar)], [1, 2, 3], [5, 4, 3], [6, 3, 7] );

     # And we quickly need to do some manipulations on that
     my $data = GD::Graph::Data->new();
     $data->copy_from(\@data);

     # And now do all the new stuff that's wanted.
     while (@foo = bar_baz())
     {
     	  $data->add_point(@foo);
     }

METHODS
=======

$data = GD::Graph::Data->new()
------------------------------

   Create a new GD::Graph::Data object.

$data->set_x($np, $value);
--------------------------

   Set the X value of point *$np* to $value. Points are numbered starting
with 0. You probably will never need this. Returns undef on failure.

$data->get_x($np)
-----------------

   Get the X value of point *$np*. See `"set_x"' in this node.

$data->set_y($nd, $np, $value);
-------------------------------

   Set the Y value of point *$np* in data set *$nd* to $value. Points are
numbered starting with 0, data sets are numbered starting with 1.  You
probably will never need this. Returns undef on failure.

$data->get_y($nd, $np)
----------------------

   Get the Y value of point *$np* in data set *$nd*. See `"set_y"' in this
node. This will return undef on an error, but the fact that it returns
undef does not mean there was an error (since undefined values can be
stored, and therefore returned).

$data->get_y_cumulative($nd, $np)
---------------------------------

   Get the cumulative value of point *$np* in data set<$nd>. The
cumulative value is obtained by adding all the values of the points *$np*
in the data sets 1 to *$nd*.

$data->get_min_max_x
--------------------

   Returns a list of the minimum and maximum x value or the empty list on
failure.

$data->get_min_max_y($nd)
-------------------------

   Returns a list of the minimum and maximum y value in data set $nd or the
empty list on failure.

$data->get_min_max_y_all()
--------------------------

   Returns a list of the minimum and maximum y value in all data sets or
the empty list on failure.

$data->add_point($X, $Y1, $Y2 ...)
----------------------------------

   Adds a point to the data set. The base for the addition is the current
number of X values. This means that if you have a data set with the
contents

     (X1,  X2)
     (Y11, Y12)
     (Y21)
     (Y31, Y32, Y33, Y34)

   a $data->add_point(Xx, Y1x, Y2x, Y3x, Y4x) will result in

     (X1,    X2,    Xx )
     (Y11,   Y12,   Y1x)
     (Y21,   undef, Y2x)
     (Y31,   Y32,   Y3x,  Y34)
     (undef, undef, Y4x)

   In other words: beware how you use this. As long as you make sure that
all data sets are of equal length, this method is safe to use.

$data->num_sets()
-----------------

   Returns the number of data sets.

$data->num_points()
-------------------

   In list context, returns a list with its first element the number of X
values, and the subsequent elements the number of respective Y values for
each data set. In scalar context returns the number of points that have an
X value set, i.e. the number of data sets that would result from a call to
`make_strict'.

$data->x_values()
-----------------

   Return a list of all the X values.

$data->y_values($nd)
--------------------

   Return a list of the Y values for data set *$nd*. Data sets are
numbered from 1. Returns the empty list if $nd is out of range, or if the
data set at $nd is empty.

$data->reset() OR GD::Graph::Data->reset()
------------------------------------------

   As an object method: Reset the data container, get rid of all data and
error messages. As a class method: get rid of accumulated error messages
and possible other crud.

$data->make_strict()
--------------------

   Make all data set lists the same length as the X list by truncating data
sets that are too long, and filling data sets that are too short with
undef values. always returns a true value.

$data->cumulate(preserve_undef => boolean)
------------------------------------------

   The cumulate parameter will summarise the Y value sets as follows: the
first Y value list will be unchanged, the second will contain a sum of the
first and second, the third will contain the sum of first, second and
third, and so on.  Returns undef on failure.

   if the argument *preserve_undef* is set to a true value, then the sum
of exclusively undefined values will be preserved as an undefined value.
If it is not present or a false value, undef will be treated as zero.
Note that this still will leave undefined values in the first data set
alone.

   Note: Any non-numerical defined Y values will be treated as 0, but you
really shouldn't be using this to store that sort of Y data.

$data->wanted(indexes)
----------------------

   Removes all data sets except the ones in the argument list. It will also
reorder the data sets in the order given. Returns undef on failure.

   To remove all data sets except the first, sixth and second, in that
order:

     $data->wanted(1, 6, 2) or die $data->error;

$data->reverse
--------------

   Reverse the order of the data sets.

$data->copy_from($data_ref)
---------------------------

   Copy an 'old' style GD::Graph data structure or another GD::Graph::Data
object into this object. This will remove the current data. Returns undef
on failure.

$data->copy()
-------------

   Returns a copy of the object, or undef on failure.

$data->read(*arguments*)
------------------------

   Read a data set from a file. This will remove the current data. returns
undef on failure. This method uses the standard module Text::ParseWords to
parse lines. If you don't have this for some odd reason, don't use this
method, or your program will die.

   *Data file format*: The default data file format is tab separated data
(which can be changed with the delimiter argument). Comment lines are any
lines that start with a #. In the following example I have replaced
literal tabs with <tab> for clarity

     # This is a comment, and will be ignored
     Jan<tab>12<tab>24
     Feb<tab>13<tab>37
     # March is missing
     Mar<tab><tab>
     Apr<tab>9<tab>18

   Valid arguments are:

   file, mandatory. The file name of the file to read from.

     $data->read(file => '/data/foo.dat') or die $data->error;

   *no_comment*, optional. Give this a true value if you don't want lines
with an initial # to be skipped.

     $data->read(file => '/data/foo.dat', no_comment => 1);

   delimiter, optional. A regular expression that will become the
delimiter instead of a single tab.

     $data->read(file => '/data/foo.dat', delimiter => '\s+');
     $data->read(file => '/data/foo.dat', delimiter => qr/\s+/);

$data->error() OR GD::Graph::Data->error()
------------------------------------------

   Returns a list of all the errors that the current object has
accumulated. In scalar context, returns the last error. If called as a
class method it works at a class level.

   This method is inherited, see *Note GD/Graph/Error: GD/Graph/Error, for
more information.

$data->has_error() OR GD::Graph::Data->has_error()
--------------------------------------------------

   Returns true if the object (or class) has errors pending, false if not.
In some cases (see `"copy"' in this node) this is the best way to check
for errors.

   This method is inherited, see *Note GD/Graph/Error: GD/Graph/Error, for
more information.

NOTES
=====

   As with all Modules for Perl: Please stick to using the interface. If
you try to fiddle too much with knowledge of the internals of this module,
you could get burned. I may change them at any time.  Specifically, I
probably won't always keep this implemented as an array reference.

AUTHOR
======

   Martien Verbruggen <mgjv@tradingpost.com.au>

Copyright
---------

   Copyright (c) 2000 Martien Verbruggen.

   All rights reserved. This package is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

SEE ALSO
========

   *Note GD/Graph: GD/Graph,, *Note GD/Graph/Error: GD/Graph/Error,


File: pm.info,  Node: GD/Graph/Error,  Next: GD/Graph/FAQ,  Prev: GD/Graph/Data,  Up: Module List

Error handling for GD::Graph classes
************************************

NAME
====

   GD::Graph::Error - Error handling for GD::Graph classes

SYNOPSIS
========

   use GD::Graph::Error_subclass;

DESCRIPTION
===========

   This class is a parent for all GD::Graph classes, including
GD::Graph::Data, and offers error and warning handling and some debugging
control.

   Errors are stored in a lexical hash in this package, so the
implementation of the subclass should be irrelevant.

PUBLIC METHODS
==============

   These methods can be used by users of any of the subclasses of
GD::Graph::Error to get at the errors of objects or classes.

$object->error() OR Class->error()
----------------------------------

   Returns a list of all the errors that the current object has
accumulated. In scalar context, returns the last error. If called as a
class method it works at a class level. This is handy when a constructor
fails, for example:

     my $data = GD::Graph::Data->new()
         or die GD::Graph::Data->error;
     $data->read(file => '/foo/bar.data')
         or die $data->error;

   or if you really are only interested in the last error:

     $data->read(file => '/foo/bar.data')
         or die scalar $data->error;

   This implementation does not clear the error list, so if you don't die
on errors, you will need to make sure to never ask for anything but the
last error (put this in scalar context) or to call `clear_error()' now and
again.

   Errors are more verbose about where the errors originated if the
$GD::Graph::Error::Debug variable is set to a true value, and even more
verbose if this value is larger than 5.

   If $Debug is larger than 3, both of these will always return the full
list of errors and warnings (although the meaning of has_warning and
`has_error' does not change).

$object->has_error() OR Class->has_error()
------------------------------------------

$object->has_warning() OR Class->has_warning()
----------------------------------------------

   Returns true if there are pending errors (warnings) for the object (or
class). To be more precise, it returns a list of errors in list context,
and the number of errors in scalar context.

   This allows you to check for errors and warnings after a large number of
operations which each might fail:

     $data->read(file => '/foo/bar.data') or die $data->error;
     while (my @foo = $sth->fetchrow_array)
     {
         $data->add_point(@foo);
     }
     $data->set_x(12, 'Foo');
     $data->has_warning and warn $data->warning;
     $data->has_error   and die  $data->error;

   The reason to call this, instead of just calling error() or warning()
and looking at its return value, is that this method is much more
efficient and fast.

   If you want to count anything as bad, just set $ErrorLevel to 0, after
which you only need to call `has_error'.

$object->clear_errors() or Class->clear_errors()
------------------------------------------------

   Clears all outstanding errors.

PROTECTED METHODS
=================

   These methods are only to be called from within this class and its
Subclasses.

$object->_set_error(*arg*) or Class->_set_error(*arg*)
------------------------------------------------------

$object->_set_warning(*arg*) or Class->_set_warning(*arg*)
----------------------------------------------------------

   Subclasses call this to set an error. The argument can be a reference
to an array, of which the first element should be the error level, and the
second element the error message. Alternatively, it can just be the
message, in which case the error level will be assumed to be $ErrorLevel.

   If the error level is >= $CriticalLevel the program will die, using
Carp::croak to display the current message, as well as all the other error
messages pending.

   In the current implementation these are almost identical when called
with a scalar argument, except that the default ewrror level is different.
When called with an array reference, they are identical in function. This
may change in the future. They're mainly here for code clarity.

$object->_move_errors
---------------------

   Move errors from an object into the class it belongs to.  This can be
useful if something nasty happens in the constructor, while instantiating
one of these objects, and you need to move these errors into the class
space before returning. (see GD::Graph::Data::new for an example)

VARIABLES
=========

$GD::Graph::Error::Debug
------------------------

   The higher this value, the more verbose error messages will be. At the
moment, any true value will cause the line number and source file of the
caller at the top of the stack to be included, a value of more than 2 will
include the error severity, and a value of more than 5 will also include
the direct caller's (i.e. the spot where the error message was generated)
line number and package. Default: 0.

$GD::Graph::Error::ErrorLevel
-----------------------------

   Errors levels below this value will be counted as warnings, and error
levels above (and inclusive) up to $CriticalLevel will be counted as
errors. This is also the default error level for the `_set_error()'
method. This value should be 0 or larger, and smaller than $CriticalLevel.
Default: 5.

$GD::Graph::Error::CriticalLevel
--------------------------------

   Any errorlevel of or above this level will immediately cause the program
to die with the specified message, using Carp::croak. Default: 10.

NOTES
=====

   As with all Modules for Perl: Please stick to using the interface. If
you try to fiddle too much with knowledge of the internals of this module,
you could get burned. I may change them at any time.

AUTHOR
======

   Martien Verbruggen <mgjv@tradingpost.com.au>

Copyright
---------

   Copyright (c) 2000 Martien Verbruggen.

   All rights reserved. This package is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

SEE ALSO
========

   *Note GD/Graph: GD/Graph,, *Note GD/Graph/Data: GD/Graph/Data,


File: pm.info,  Node: GD/Graph/FAQ,  Next: GD/Graph/Map,  Prev: GD/Graph/Error,  Up: Module List

Frequently asked questions
**************************

NAME
====

   GD::Graph - Frequently asked questions

DESCRIPTION
===========

I am drawing a bar chart, and the chart area is a lot smaller than the image. What is going on?
-----------------------------------------------------------------------------------------------

   As of version 1.30, GD::Graph automatically corrects the width of the
plotting area of a chart if it needs to draw bars (i.e. for bars and some
mixed charts). This is necessary, because rounding errors cause irregular
gaps between or overlaps of bars if the bar is not an exact integer number
of pixels wide.

   If you want the old behaviour back, set the correct_with attribute to a
false value.

I have my data in some format that doesn't look at all like the array that I am supposed to give to GD::Graph's plot method.
----------------------------------------------------------------------------------------------------------------------------

   Check out the GD::Graph::Data class.

Where is the ActiveState ppm of GD::Graph?
------------------------------------------

   Ask them. I have asked them, but didn't get an answer. I don't know what
to do to get it included in their set of ppms, and I really do not have
the time to keep asking them.

Do you have some example code for me?
-------------------------------------

   The distribution has a large set of examples in it. If you don't have
the original distribution, please get it from CPAN (http://www.cpan.org/
or some local mirror).

Will you support X or Y?
------------------------

   If you send me a patch that (in a decent manner) adds the functionality
to the latest version, I may very well add it for the next release. If you
don't send me a patch, but just a question, you will have to be patient.

Why does export_format give me a weird string, instead of just 'png' or 'gif'?
------------------------------------------------------------------------------

   As of version 1.31, export_format in a list context returns all formats
that GD can export. If you are only interested in the answer 'gif' or
'png', make sure that you call it in a scalar context.

     $export_format = GD::Graph->export_format;
     $export_format = $graph->export_format;
     print "Export format is ", scalar $graph->export_format, "\n";
     print "Export format is " .  $graph->export_format . "\n";
     @export_formats = $graph->export_format;

AUTHOR
======

   Martien Verbruggen <mgjv@tradingpost.com.au>

   Copyright (c) 2000 Martien Verbruggen.

   All rights reserved. This package is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.


File: pm.info,  Node: GD/Graph/Map,  Next: GD/Graph/colour,  Prev: GD/Graph/FAQ,  Up: Module List

generate HTML map text for GD::Graph diagramms.
***********************************************

NAME
====

   *GD::Graph::Map* - generate HTML map text for GD::Graph diagramms.

SYNOPSIS
========

   use GD::Graph::Map;

   $map = new GD::Graph::Map($gr_object);

   $map->set(key1 => value1, key2 => value2 ...);

   $HTML_map = $map->imagemap($gr_file, \@data);

DESCRIPTION
===========

   This is a *perl5* module to generate HTML map text for following
GD::Graph objects *GD::Graph::pie*, *GD::Graph::bars*, *GD::Graph::lines*,
*GD::Graph::area*, *GD::Graph::point* and *GD::Graph::linespoints*.  As a
result of its work is created HTML code containing IMG and MAP tags.  You
simply need to insert this code into the necessary place of your HTML page.
In the inserted thus image, its certain parts are the references and at a
choice their mouse in a status line of your browser displays the additional
information (see Samples).

SAMPLES
=======

   See the samples directory in the distribution.

USAGE
=====

   First of all you must create the *GD::Graph* object and set options if
it is necessary.  Then create array of data and use plot routine for
create graph image.  For example create *GD::Graph::pie* object:

     $graph = new GD::Graph::pie;

     $graph->set('title'        => 'A Pie Chart',
                 'label'        => 'Label',
                 'axislabelclr' => 'black',
                 'pie_height'   => 80);

     @data = (["1st","2nd","3rd","4th","5th","6th"],
              [    4,    2,    3,    4,    3,  3.5]);

     $GIFimage = 'Demo.gif';
     open GIF, '>$GIFimage';
     print GIF $graph->plot(\@data)->gif;
     close GIF;

   Then create *GD::Graph::Map* object. And set options using set routine,
or set it in constructor immediately. If it is necessary create hrefs and
legend arrays:

     $map = new GD::Graph::Map($graph, newWindow => 1);

     $map->set(info => "%x slice contains %.1p% of %s (%x)");

   Create HTML map text using the same array of data as use
GD::Graph::plot routine and name of the your graph file:

     $HTML_map = $map->imagemap($GIFimage, \@data);

   Now you can insert $HTML_map into the necessary place of your HTML page.
You also can create only MAP tag with determined by you map name. For more
information look at noImgMarkup and mapName options of the set routine.

METHODS AND FUNCTIONS
=====================

Constructor
     Constructor of object has following syntax:

          new GD::Graph::Map($gr_object,
            [key1 => value1, key2 => value2 ...]);

     where $gr_object this is one of the following graph objects:
     *GD::Graph::pie*, *GD::Graph::bars*, *GD::Graph::lines*,
     *GD::Graph::area*, *GD::Graph::point* or *GD::Graph::linespoints*;
     key1, value1 ... the same as using in the set routine.  NOTE: Before
     use constructor you should at first set all properties for graph
     object, because they will be using for generetaing properly HTML map.

imagemap(*$gr_file*, *\@data*)
     Generate HTML map text using the graph file $file and reference to
     array of data - \@data, which must be the same as using in plot
     routine.

set(*key1* => *value1*, *key2* => *value2* .... )
     Set options. See OPTIONS.

OPTIONS
=======

*hrefs*, *lhrefs*
     Sets hyper reference for each data (hrefs), and for each legend
     (lhrefs).  Array @hrefs must the same size as arrays in @data list,
     otherwise null elements of @hrefs will set to default. Similarly
     array @lhrefs must the same size as the legend array. Default uses
     the simple JavaScript code 'javascript:;' instead reference, which do
     nothing (but in the some browsers it can work incorrectly).

     Example of *@hrefs* array:

     for the *GD::Graph::pie* object:

     if     @data  = ([  "1st",  "2nd",  "3rd"],                  [
     4,      2,      3]);

     then   @hrefs =  ["1.htm","2.htm","3.htm"];

     for the other objects:

     if     @data  = ([  "1st",  "2nd",  "3rd"],                  [
     5,     12,     24],                  [      1,      2,      5]);

     then   @hrefs = (["1.htm","2.htm","3.htm"],
     ["4.htm","5.htm","6.htm"]);

     Example of *@lhrefs* array;

     if    @legend = [  'one',  'two','three'];

     then  @lhrefs = ["1.htm","2.htm","3.htm"];

info, legend
     Set information string for the data and for the legend. It will be
     displayed in the status line of your browser. Format of this string
     the same for each data, but you can use special symbols for receive
     individual information. Now available following symbols: *%x* - Will
     be replaced on the x values in @data (first array) *%y* - Will be
     replaced on the y values in @data (other arrays) %s - Will be
     replaced on the sum of all y values.  *%l* - Will be replaced on the
     legend. For all objects, except the *GD::Graph::pie* object.  *%p* -
     Will be replaced on the value, which show what part from all contains
     this data (in percentages).

     %s and *%p* symbols can useing only in the *GD::Graph::pie* object.
     *%l* symbol vice versa available for all objects, except the
     *GD::Graph::pie* object. And *%x*, *%y* symbols available for all
     objects, except the *GD::Graph::lines* and the *GD::Graph::area*
     objects.  For the numerical parameters (%x, %y, %s and %p) you can
     use special format (the same as uses sprintf routine) for round data:
     %.d{x|y|p|s}, where 'd' is a digit from 0 to 9.  For example %.0p or
     %.3x. It is desirable uses if %x, %y, %s or %p is the floating
     numbers.  Default is 'x=%x y=%y' for info, and '%l' for legend.


     You can set any attribute in the IMG tag (except UseMap, Src, Width,
     Height and Border, they will be set automatically) use set routine:
     set(img_option => value), where 'option' is the IMG attribute. For
     instance: routine set(img_Alt => 'Example') will include Alt='Example'
     in the IMG tag.

*newWindow*, *window_**
     If the newWindow attribute is set to the TRUE and link does not
     contains JavaScript code (like javascript:), that link will be open
     in the new navigator window. Parameters of the new window you can
     establish using the window_* parameters, similarly the img_*.

mapName
     If mapName is TRUE the map will have this name. Default is time().

noImgMarkup
     If noImgMarkup is TRUE will be printed only the MAP tag, without the
     <Img UseMap=... > markup. You will have to print your own.  Useful if
     the Graph is generated and poured directly to the a web-browser and
     not plotted to a GIF file.

AUTHOR
======

   Roman Kosenko

Contact info
------------

   E-mail:    ra@amk.lg.ua

   Home page: http://amk.lg.ua/~ra/Map

Copyright
---------

   Copyright (C) 1999-2000 Roman Kosenko.  All rights reserved.  This
package is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.


File: pm.info,  Node: GD/Graph/colour,  Next: GD/Text,  Prev: GD/Graph/Map,  Up: Module List

Colour manipulation routines for use with GD::Graph
***************************************************

NAME
====

   Colour - Colour manipulation routines for use with GD::Graph

SYNOPSIS
========

   use GD::Graph::colour qw(:colours :lists :files :convert);

DESCRIPTION
===========

   The *GD::Graph::colour* package provides a few routines to work with
colours. The functionality of this package is mainly defined by what is
needed, now and historically, by the GD::Graph modules.

FUNCTIONS
=========

colour_list( *number of colours* )
----------------------------------

   Returns a list of *number of colours* colour names known to the package.
Exported with the :lists tag.

sorted_colour_list( *number of colours* )
-----------------------------------------

   Returns a list of *number of colours* colour names known to the package,
sorted by luminance or hue.  *NB.* Right now it always sorts by luminance.
Will add an option in a later stage to decide sorting method at run time.
Exported with the :lists tag.

_rgb( *colour name* )
---------------------

   Returns a list of the RGB values of *colour name*. if the colour name
is a string of the form that is acceptable to the hex2rgb sub, then the
colour will be added to the list dynamically.  Exported with the :colours
tag.

_hue( *R,G,B* )
---------------

   Returns the hue of the colour with the specified RGB values.  Exported
with the :colours tag.

_luminance( *R,G,B* )
---------------------

   Returns the luminance of the colour with the specified RGB values.
Exported with the :colours tag.

add_colour(colourname => [$r, $g, $b]) or add_colour('#7fe310')
---------------------------------------------------------------

   Self-explanatory.  Exported with the :colours tag.

rgb2hex($red, $green, $blue)
----------------------------

hex2rgb('#7fe310')
------------------

   These functions translate a list of RGB values into a hexadecimal
string, as is commonly used in HTML and the Image::Magick API, and vice
versa.  Exported with the :convert tag.

read_rgb( `file name' )
-----------------------

   Reads in colours from a rgb file as used by the X11 system.

   Doing something like:

     use GD::Graph::bars;
     use GD::Graph::colour;

     GD::Graph::colour::read_rgb("rgb.txt") or die "cannot read colours";

   Will allow you to use any colours defined in rgb.txt in your graph.
Exported with the :files tag.

PREDEFINED COLOUR NAMES
=======================

   white, lgray, gray, dgray, black, lblue, blue, dblue, gold, lyellow,
yellow, dyellow, lgreen, green, dgreen, lred, red, dred, lpurple, purple,
dpurple, lorange, orange, pink, dpink, marine, cyan, lbrown, dbrown.


File: pm.info,  Node: GD/Text,  Next: GD/Text/Align,  Prev: GD/Graph/colour,  Up: Module List

Text utilities for use with GD
******************************

NAME
====

   GD::Text - Text utilities for use with GD

SYNOPSIS
========

     use GD;
     use GD::Text;

     my $gd_text = GD::Text->new() or die GD::Text::error();
     $gd_text->set_font('funny.ttf', 12) or die $gd_text->error;
     $gd_text->set_font(gdTinyFont);
     $gd_text->set_font(GD::Font::Tiny);
     ...
     $gd_text->set_text($string);
     my ($w, $h) = $gd_text->get('width', 'height');

     if ($gd_text->is_ttf)
     {
     	  ...
     }

   Or alternatively

     my $gd_text = GD::Text->new(
           text => 'Some text',
           font => 'funny.ttf',
           ptsize => 14,
       );

DESCRIPTION
===========

   This module provides a font-independent way of dealing with text in GD,
for use with the GD::Text::* modules and GD::Graph.

NOTES
=====

   As with all Modules for Perl: Please stick to using the interface. If
you try to fiddle too much with knowledge of the internals of this module,
you could get burned. I may change them at any time.

   You can only use TrueType fonts with version of GD > 1.20, and then
only if compiled with support for this. If you attempt to do it anyway,
you will get errors.

METHODS
=======

GD::Text->new( attrib => value, ... )
-------------------------------------

   Create a new object. See the set() method for attributes.

GD::Text::error() or $gd_text->error();
---------------------------------------

   Return the last error that occured in the class. This may be imperfect.

$gd_text->set_font( font, size )
--------------------------------

   Set the font to use for this string. The arguments are either a GD
builtin font (like gdSmallFont or GD::Font->Small) or the name of a
TrueType font file and the size of the font to use. See also `"font_path"'
in this node.

   If you are not using an absolute path to the font file, you can leave of
the .ttf file extension, but you have to append it for absolute paths:

     $gd_text->set_font('cetus', 12);
     # but
     $gd_text->set_font('/usr/fonts/cetus.ttf', 12);

   The first argument can be a reference to an array of fonts. The first
font from the array that can be found will be used. This allows you to do
something like

     $gd_text->font_path( '/usr/share/fonts:/usr/fonts');
     $gd_text->set_font(
       ['verdana', 'arial', gdMediumBoldFont], 14);

   if you'd prefer verdana to be used, would be satisfied with arial, but
if none of that is available just want to make sure you can fall back on
something that will be available.

   Returns true on success, false on error.

$gd_text->set_text('some text')
-------------------------------

   Set the text to operate on.  Returns true on success and false on error.

$gd_text->set( attrib => value, ... )
-------------------------------------

   The set method provides a convenience replacement for the various other
`set_xxx()' methods. Valid attributes are:

text
     The text to operate on, see also `set_text()'.

font, ptsize
     The font to use and the point size. The point size is only used for
     TrueType fonts. Also see `set_font()'.

   Returns true on success, false on any error, even if it was partially
successful. When an error is returned, no guarantees are given about the
correctness of the attributes.

$gd_text->get( attrib, ... )
----------------------------

   Get the value of an attribute.  Return a list of the attribute values
in list context, and the value of the first attribute in scalar context.

   The attributes that can be retrieved are all the ones that can be set,
and:

width, height
     The width (height) of the string in pixels

space
     The width of a space in pixels

char_up, char_down
     The number of pixels that a character can stick out above and below
     the baseline. Note that this is only useful for TrueType fonts. For
     builtins char_up is equal to height, and char_down is always 0.

   Note that some of these parameters (char_up, char_down and space) are
generic font properties, and not necessarily a property of the text that
is set.

$gd_text->width('string')
-------------------------

   Return the length of a string in pixels, without changing the current
value of the text.  Returns the width of 'string' rendered in the current
font and size.  On failure, returns undef.

   The use of this method is vaguely deprecated.

$gd_text->is_builtin
--------------------

   Returns true if the current object is based on a builtin GD font.

$gd_text->is_ttf
----------------

   Returns true if the current object is based on a TrueType font.

$gd_text->can_do_ttf() or GD::Text->can_do_ttf()
------------------------------------------------

   Return true if this object can handle TTF fonts.

   This depends on whether your version of GD is newer than 1.19 and has
TTF support compiled into it.

$gd_text->font_path(path_spec), GD::Text->font_path(path_spec)
--------------------------------------------------------------

   This sets the font path for the class (i.e. not just for the object).
The `set_font' method will search this path to find the font specified if
it is a TrueType font. It should contain a list of paths. The current
directory is always searched first, unless '.' is present in FONT_PATH.
Examples:

     GD::Text->font_path('/usr/ttfonts'); # Unix
     GD::Text->font_path('c:/fonts');     # MS-OS

   Any font name that is not an absolute path will first be looked for in
the current directory, and then in /usr/ttfonts (c:\fonts).

     GD::Text->font_path('/usr/ttfonts:.:lib/fonts'); # Unix
     GD::Text->font_path('c:/fonts;.;f:/fonts');      # MS-OS

   Any font name that is not an absolute path will first be looked for in
/usr/ttfonts (c:\fonts), then in the current directory. and then in
lib/fonts (f:\fonts), relative to the current directory.

     GD::Text->font_path(undef);

   Font files are only looked for in the current directory.

   FONT_PATH is initialised at module load time from the environment
variables FONT_PATH or, if that's not present, TTF_FONT_PATH.

   Returns the value the font path is set to.  If called without arguments
`font_path' returns the current font path.

   Note: This currently only works for unices, and (hopefully) for
Microsoft based OS's. If anyone feels the urge to have a look at the code,
and send me patches for their OS, I'd be most grateful)

BUGS
====

   This module has only been tested with anglo-centric 'normal' fonts and
encodings.  Fonts that have other characteristics may not work well.  If
that happens, please let me know how to make this work better.

   The font height gets estimated by building a string with all printable
characters that pass the POSIX::isgraph() test. If your system doesn't
have POSIX, I make an approximation that may be false.

   The whole font path thing works well on Unix, but probably not very well
on other OS's. This is only a problem if you try to use a font path. If
you don't use a font path, there should never be a problem. I will try to
expand this in the future, but only if there's a demand for it.
Suggestions welcome.

COPYRIGHT
=========

   copyright 1999 Martien Verbruggen (mgjv@comdyn.com.au)

SEE ALSO
========

   GD(3), GD::Text::Wrap(3), GD::Text::Align(3)


File: pm.info,  Node: GD/Text/Align,  Next: GD/Text/Wrap,  Prev: GD/Text,  Up: Module List

Draw aligned strings
********************

NAME
====

   GD::Text::Align - Draw aligned strings

SYNOPSIS
========

     use GD;
     use GD::Text::Align;

     my $gd = GD::Image->new(800,600);
     # allocate colours, do other things.

     my $align = GD::Text::Align->new($gd
       valign => 'top',
       halign => 'right',
     );
     $align->set_font('cetus.ttf', 12);
     $align->set_text('some string');
     @bb = $align->bounding_box(200, 400, PI/3);
     # you can do things based on the bounding box here
     $align->draw(200, 400, PI/3);

DESCRIPTION
===========

   GD::Text::Align provides an object that draws a string aligned to a
coordinate at an angle.

   For builtin fonts only two angles are valid: 0 and PI/2. All other
angles will be converted to one of these two.

METHODS
=======

   This class inherits everything from GD::Text. I will only discuss the
methods and attributes here that are not discussed there, or that have a
different interface or behaviour. Methods directly inherited include
set_text and `set_font'.

GD::Text::Align->new($gd_object, attrib => value, ...)
------------------------------------------------------

   Create a new object. The first argument to new has to be a valid
GD::Image object. The other arguments will be passed on to the set method.

$align->set(attrib => value, ...)
---------------------------------

   Set an attribute. Valid attributes are the ones discussed in *Note
GD/Text: GD/Text, and:

valign, halign
     Vertical and horizontal alignment of the string. See also set_valign
     and set_halign.

colour, color
     Synonyms. The colour to use to draw the string. This should be the
     index of the colour in the GD::Image object's palette. The default
     value is the last colour in the GD object's palette at the time of
     the creation of `$align'.

$align->get(attribute)
----------------------

   Get the value of an attribute.  Valid attributes are all the attributes
mentioned in *Note GD/Text: GD/Text,, the attributes mentioned under the
set method and

x, y and angle
     The x and y coordinate and the angle to be used. You can only do this
     after a call to the draw or bounding_box methods. Note that these
     coordinates are not necessarily the same ones that were passed in.
     Instead, they are the coordinates from where the GD methods will start
     drawing. I doubt that this is very useful to anyone.

   Note that while you can set the colour with both 'color' and 'colour',
you can only get it as 'colour'. Sorry, but such is life in Australia.

$align->set_valign(value)
-------------------------

   Set the vertical alignment of the string to one of 'top', 'center',
'base' or 'bottom'. For builtin fonts the last two are the same. The value
'base' denotes the baseline of a TrueType font.  Returns true on success,
false on failure.

$align->set_halign(value)
-------------------------

   Set the horizontal alignment of the string to one of 'left', 'center',
or 'right'.  Returns true on success, false on failure.

$align->set_align(valign, halign)
---------------------------------

   Set the vertical and horizontal alignment. Just here for convenience.
See also `set_valign' and `set_halign'.  Returns true on success, false on
failure.

$align->draw(x, y, angle)
-------------------------

   Draw the string at coordinates x, y at an angle *angle* in radians. The
x and y coordinate become the pivot around which the string rotates.

   Note that for the builtin GD fonts the only two valid angles are 0 and
PI/2.

   Returns the bounding box of the drawn string (see `bounding_box()').

$align->bounding_box(x, y, angle)
---------------------------------

   Return the bounding box of the string to draw. This returns an
eight-element list (exactly like the GD::Image->stringTTF method):

     (x1,y1) lower left corner
     (x2,y2) lower right corner
     (x3,y3) upper right corner
     (x4,y4) upper left corner

   Note that upper, lower, left and right are relative to the string, not
to the canvas.

   The bounding box can be used to make decisions about whether to move the
string or change the font size prior to actually drawing the string.

NOTES
=====

   As with all Modules for Perl: Please stick to using the interface. If
you try to fiddle too much with knowledge of the internals of this module,
you may get burned. I may change them at any time.

   You can only use TrueType fonts with version of GD > 1.20, and then
only if compiled with support for this. If you attempt to do it anyway,
you will get errors.

   In the following, terms like 'top', 'upper', 'left' and the like are all
relative to the string to be drawn, not to the canvas.

BUGS
====

   Any bugs inherited from GD::Text.

COPYRIGHT
=========

   copyright 1999 Martien Verbruggen (mgjv@comdyn.com.au)

SEE ALSO
========

   *Note GD: GD,, *Note GD/Text: GD/Text,, *Note GD/Text/Wrap:
GD/Text/Wrap,


File: pm.info,  Node: GD/Text/Wrap,  Next: GIFgraph,  Prev: GD/Text/Align,  Up: Module List

Wrap strings in boxes
*********************

NAME
====

   GD::Text::Wrap - Wrap strings in boxes

SYNOPSIS
========

     use GD;
     use GD::Text::Wrap;

     my $gd = GD::Image->new(800,600);
     # allocate colours, do other things.
     
     my $text = <<EOSTR;
     Lorem ipsum dolor sit amet, consectetuer adipiscing elit,
     sed diam nonummy nibh euismod tincidunt ut laoreet dolore
     magna aliquam erat volutpat.
     EOSTR
     
     my $wrapbox = GDTextWrap->new( $gd,
         line_space  => 4,
         color       => $black,
         text        => $text,
     );
     $wrapbox->set_font(gdMediumBoldFont);
     $wrapbox->set_font('cetus.ttf', 12);
     $wrapbox->set(align => 'left', width => 120);
     $wrapbox->draw(10,140);

     $gd->rectangle($wrap_box->get_bounds(10,140), $color);

DESCRIPTION
===========

   GD::Text::Wrap provides an object that draws a formatted paragraph of
text in a box on a GD::Image canvas, using either a builtin GD font or a
TrueType font.

METHODS
=======

   This class doesn't inherit from GD::Text directly, but delegates most of
its work to it (in fact to a GD::Text::Align object. That means that most
of the GD::Text::Align methods are available for this class, specifically
`set_font' and `font_path'. Other methods and methods with a different
interface are described here:

GD::Text::Wrap->new( $gd_object, attribute => value, ... )
----------------------------------------------------------

   Create a new object. The first argument to new has to be a valid
GD::Image object. The other arguments will be passed to the set() method
for initialisation of the attributes.

$wrapbox->set( attribute => value, ... )
----------------------------------------

   set the value for an attribute. Valid attributes are:

width
     The width of the box to draw the text in. If unspecified, they will
     default to the width of the GD::Image object.

line_space
     The number of pixels between lines. Defaults to 2.

para_space, paragraph_space
     The number of extra pixels between paragraphs, above line_space.
     Defaults to 0.

color, colour
     Synonyms. The colour to use when drawing the font. Will be initialised
     to the last colour in the GD object's palette.

align, alignment
     Synonyms. One of 'justified' (the default), 'left', 'right' or
     'center'.

text
     The text to draw. This is the only attribute that you absolutely have
     to set.

preserve_nl
     If set to a true value, newlines in the text will cause a line break.
     Note that lines will still be justified. If only one word appears on
     the line, it could get ugly.  Defaults to 0.

   As with the methods, attributes unknown to this class get delegated to
the GD::Text::Align class.

$wrapbox->get( attribute );
---------------------------

   Get the current value of an attribute. All attributes mentioned under
the set() method can be retrieved

$wrapbox->get_bounds()
----------------------

   Returns the bounding box of the box that will be drawn with the current
attribute settings as a list. The values returned are the coordinates of
the upper left and lower right corner.

     ($left, $top, $right, $bottom) = $wrapbox->get_bounds();

   Returns an empty list on error.

   NOTE: The return list of this method may change in a future
implementation that allows angled boxes.

$wrapbox->draw(x, y)
--------------------

   Draw the box, with (x,y) as the top right corner.  Returns the same
values as the `getbounds()' method.

   NOTE: The return list of this method may change in a future
implementation that allows angled boxes.

NOTES
=====

   As with all Modules for Perl: Please stick to using the interface. If
you try to fiddle too much with knowledge of the internals of this module,
you may get burned. I may change them at any time.

   You can only use TrueType fonts with version of GD > 1.20, and then
only if compiled with support for this. If you attempt to do it anyway,
you will get errors.

   Even though this module lives in the GD::Text namespace, it is not a
GD::Text. It does however delegate a lot of its functionality to a
contained object that is one (GD::Text::Align).

BUGS
====

   None that I know of, but that doesn't mean much. There may be some
problems with exotic fonts, or locales and character encodings that I am
not used to.

TODO
====

   Angled boxes.

   At the moment, the only bit of the box that is allowed to be unspecified
and in fact must be unspecified, is the bottom. If there is enough need
for it, I might implement more flexibility, in that that you need to only
specify three of the four sides of the box, and the fourth will be
calculated.

   Automatic resizing of a TrueType font to fit inside a box when four
sides are specified, or maybe some other nifty things.

   More flexibility in the interface. Especially draw needs some thought.

   More and better error handling.

   Warnings for lines that are too long and stick out of the box.  Warning
for emptyish lines?

COPYRIGHT
=========

   copyright 1999 Martien Verbruggen (mgjv@comdyn.com.au)

SEE ALSO
========

   *Note GD: GD,, *Note GD/Text: GD/Text,, *Note GD/Text/Align:
GD/Text/Align,


