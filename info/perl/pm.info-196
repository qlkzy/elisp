This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Inline-Support,  Next: Inline/C,  Prev: Inline-API,  Up: Module List

Support - Support Information for Inline.pm and related modules.
****************************************************************

NAME
====

   Inline-Support - Support Information for Inline.pm and related modules.

DESCRIPTION
===========

   This document contains all of the latest support information for
`Inline.pm' and the recognized Inline Language Support Modules (ILSMs)
available on CPAN.

SUPPORTED LANGUAGES
===================

   The most important language that Inline supports is C. That is because
Perl itself is written in C. By giving a your Perl scripts access to C,
you in effect give them access to the entire glorious internals of Perl.
(Caveat scriptor :-)

   As of this writing, Inline also supports:

     - C++
     - Python
     - CPR

   Projects that I would most like to see happen in the year 2001 are:

     - Java
     - Fortran
     - Ruby
     - Bash

   Note: Since many C compilers allow the use of assembly code within C,
you may want to consider Assembly Language as supported. Ready to start
scripting out new device drivers?

SUPPORTED PLATFORMS
===================

   `Inline::C' should work anywhere that CPAN extension modules (those
that use XS) can be installed, using the typical install format of:

     perl Makefile.PL
     make
     make test
     make install

   It has been tested on many Unix variants and Windows NT.

   NOTE: `Inline::C' requires Perl 5.005 or higher because
Parse::RecDescent requires it. (Something to do with the qr operator)

   Inline has been tested on the following platforms:

     V#   OS      OS V#   Perl V# Human              Email
     0.20 FreeBSD 3.4     5.00503 Timothy A Gregory  tgregory@tarjema.com
     0.20 FreeBSD 4.0     5.00503 Timothy A Gregory  tgregory@tarjema.com
     0.20 FreeBSD 4.0     5.6     Timothy A Gregory  tgregory@tarjema.com
     0.20 Linux   2.0.36  5.00503 Prakasa Bellam     pbellam@cobaltgroup.com
     0.20 HPUX    B.10.20 5.00503 Jamie Shaffer      jshaffer@chronology.com
     0.20 SunOS   5.6     5.6.0   Jamie Shaffer      jshaffer@chronology.com
     0.20 SunOS   5.5.1   5.6.0   Jamie Shaffer      jshaffer@chronology.com
     0.22 OpenBSD 2.7     5.6.0   Jeremy Devenport   jeremy@weezel.com
     0.22 FreeBSD 3.1     5.00503 Doug Beaver        dougb@scalar.org
     0.25 Linux   2.2.13  5.00503 Brian Ingerson     ingy@cpan.org
     0.25 Linux   2.2.13  5.6     Brian Ingerson     ingy@cpan.org
     0.25 WinNT   4.0 sp6 5.00503 Brian Ingerson     ingy@cpan.org
     0.26 Cygwin  1.1.1   5.6.0   Leo Schalkwyk      L.Schalkwyk@iop.kcl.ac.uk
     0.26 AIX     4.3.3   5.00502 Norbert E. Gruener nog@MPA-Garching.MPG.DE
     0.26 BeOS    5.03Pro 5.00503 Daniel J. Berger   djberge@uswest.com

   The Microsoft tests deserve a little more explanation. I used the
following:

     Windows NT 4.0 (service pack 6)
     Perl 5.005_03 (ActiveState build 522)
     MS Visual C++ 6.0
     The "nmake" make utility (distributed w/ Visual C++)

   `Inline::C' pulls all of its base configuration (including which make
utility to use) from Config.pm. Since your MSWin32 version of Perl
probably came from ActiveState (as a binary distribution) the Config.pm
will indicate that `nmake' is the system's make utility. That is because
ActiveState uses Visual C++ to compile Perl.

   To install `Inline.pm' (or any other CPAN module) on MSWin32 w/ Visual
C++, use these:

     perl Makefile.PL
     nmake
     nmake test
     nmake install

   The "Cygwin" test was done on a Windows 98 machine using the Cygwin
Unix/Win32 porting layer software from Cygnus. The `perl' binary on this
machine was also compiled using the Cygwin tool set (`gcc'). This software
is freely available from http://sources.redhat.com/cygwin/

   If Inline works on your platform, you can email me the info above. If
it doesn't work, let me know as well and I'll see what can be done.

SEE ALSO
========

   For general information about Inline see *Note Inline: Inline,.

   For information about using Inline with C see *Note Inline/C: Inline/C,.

   For sample programs using Inline with C see *Note Inline/C-Cookbook:
Inline/C-Cookbook,.

   For information on writing your own Inline Language Support Module, see
*Note Inline-API: Inline-API,.

   Inline's mailing list is inline@perl.org

   To subscribe, send email to inline-subscribe@perl.org

AUTHOR
======

   Brian Ingerson <INGY@cpan.org>

COPYRIGHT
=========

   Copyright (c) 2001, Brian Ingerson.

   All Rights Reserved.  This module is free software. It may be used,
redistributed and/or modified under the terms of the Perl Artistic License.

   See http://www.perl.com/perl/misc/Artistic.html


File: pm.info,  Node: Inline/C,  Next: Inline/C-Cookbook,  Prev: Inline-Support,  Up: Module List

Write Perl Subroutines in C
***************************

NAME
====

   Inline::C - Write Perl Subroutines in C

DESCRIPTION
===========

   `Inline::C' is a module that allows you to write Perl subroutines in C.
Since version 0.30 the Inline module supports multiple programming
languages and each language has its own support module. This document
describes how to use Inline with the C programming language. It also goes
a bit into Perl C internals.

   If you want to start working with programming examples right away,
check out *Note Inline/C-Cookbook: Inline/C-Cookbook,. For more
information on Inline in general, see *Note Inline: Inline,.

Usage
=====

   You never actually use `Inline::C' directly. It is just a support
module for using `Inline.pm' with C. So the usage is always:

     use Inline C => ...;

   or

     bind Inline C => ...;

Function Definitions
====================

   The Inline grammar for C recognizes certain function definitions (or
signatures) in your C code. If a signature is recognized by Inline, then
it will be available in Perl-space. That is, Inline will generate the
"glue" necessary to call that function as if it were a Perl subroutine. If
the signature is not recognized, Inline will simply ignore it, with no
complaints. It will not be available from Perl-space, although it *will*
be available from C-space.

   Inline looks for ANSI/prototype style function definitions. They must
be of the form:

     return-type function-name ( type-name-pairs ) { ... }

   They also may only use the types: int, long, double, `char*', and
`SV*'. A return type of void may also be used. The following are examples
of valid function definitions.

     int Foo(double num, char* str) {
     void Foo(double num, char* str) {
     SV* Foo() {
     void Foo(SV*, ...) {
     long Foo(int i, int j, ...) {

   The following definitions would not be recognized:

     Foo(int i) {               # no return type
     unsigned int Foo(int i) {  # 'unsigned int' not recognized
     int Foo(num, str) double num; char* str; {
     void Foo(void) {           # void only valid for return type

   Notice that Inline only looks for function *definitions*, not function
*prototypes*. Definitions are the syntax directly preceeding a function
body. Also Inline does not scan external files, like headers. Only the
code passed to Inline is used to create bindings; although other libraries
can linked in, and called from C-space.

C Configuration Options
=======================

   For information on how to specify Inline configuration options, see
*Note Inline: Inline,. This section describes each of the configuration
options available for C. Most of the options correspond either to
MakeMaker or XS options of the same name. See *Note ExtUtils/MakeMaker:
ExtUtils/MakeMaker, and *Note Perlxs: (perl.info)perlxs,.

AUTO_INCLUDE
------------

   Specifies extra statements to automatically included. They will be
added onto the defaults. A newline char will be automatically added.

     use C => Config => AUTO_INCLUDE => '#include "yourheader.h"';

BOOT
----

   Specifies C code to be executed in the XS BOOT section. Corresponds to
the XS parameter.

CC
--

   Specify which compiler to use.

CCFLAGS
-------

   Specify extra compiler flags.

INC
---

   Specifies an include path to use. Corresponds to the MakeMaker
parameter.

     use C => Config => INC => '-I/inc/path';

LD
--

   Specify which linker to use.

LDDLFLAGS
---------

   Specify which linker flags to use.

   NOTE: These flags will completely override the existing flags, instead
of just adding to them. So if you need to use those too, you must
respecify them here.

LIBS
----

   Specifies external libraries that should be linked into your code.
Corresponds to the MakeMaker parameter.

     use C => Config => LIBS => '-lyourlib';

   or

     use C => Config => LIBS => '-L/your/path -lyourlib';

MAKE
----

   Specify the name of the 'make' utility to use.

MYEXTLIB
--------

   Specifies a user compiled object that should be linked in. Corresponds
to the MakeMaker parameter.

     use C => Config => MYEXTLIB => '/your/path/yourmodule.so';

PREFIX
------

   Specifies a prefix that will be automatically stripped from C functions
when they are bound to Perl. Useful for creating wrappers for shared
library API-s, and binding to the original names in Perl. Also useful when
names conflict with Perl internals. Corresponds to the XS parameter.

     use C => Config => PREFIX => 'ZLIB_';

TYPEMAPS
--------

   Specifies extra typemap files to use. These types will modify the
behaviour of the C parsing. Corresponds to the MakeMaker parameter.

     use C => Config => TYPEMAPS => '/your/path/typemap';

C-Perl Bindings
===============

   This section describes how the Perl variables get mapped to C variables
and back again.

   First, you need to know how Perl passes arguments back and forth to
subroutines. Basically it uses a stack (also known as the Stack). When a
sub is called, all of the parenthesized arguments get expanded into a list
of scalars and pushed onto the Stack. The subroutine then pops all of its
parameters off of the Stack. When the sub is done, it pushes all of its
return values back onto the Stack.

   The Stack is an array of scalars known internally as SV's. The Stack is
actually an array of *pointers to SV* or `SV*'; therefore every element of
the Stack is natively a `SV*'. For *FMTYEWTK* about this, read `perldoc
perlguts'.

   So back to variable mapping. XS uses a thing known as "typemaps" to
turn each `SV*' into a C type and back again. This is done through various
XS macro calls, casts and the Perl API. See `perldoc perlapi'. XS allows
you to define your own typemaps as well for fancier non-standard types
such as `typedef'-ed structs.

   Inline uses the default Perl typemap file for its default types. This
file is called `/usr/local/lib/perl5/5.6.1/ExtUtils/typemap', or something
similar, depending on your Perl installation. It has definitions for over
40 types, which are automatically used by Inline. (You should probably
browse this file at least once, just to get an idea of the possibilities.)

   Inline parses your code for these types and generates the XS code to
map them. The most commonly used types are:

     - int
     - long
     - double
     - char*
     - void
     - SV*

   If you need to deal with a type that is not in the defaults, just use
the generic `SV*' type in the function definition. Then inside your code,
do the mapping yourself. Alternatively, you can create your own typemap
files and specify them using the TYPEMAPS configuration option.

   A return type of void has a special meaning to Inline. It means that
you plan to push the values back onto the Stack yourself. This is what you
need to do to return a list of values. If you really don't want to return
anything (the traditional meaning of void) then simply don't push anything
back.

   If ellipsis or ... is used at the end of an argument list, it means
that any number of `SV*'s may follow. Again you will need to pop the
values off of the Stack yourself.

   See `"Examples"' in this node below.

The Inline Stack Macros
=======================

   When you write Inline C, the following lines are automatically
prepended to your code (by default):

     #include "EXTERN.h"
     #include "perl.h"
     #include "XSUB.h"
     #include "INLINE.h"

   The file `INLINE.h' defines a set of macros that are useful for
handling the Perl Stack from your C functions.

Inline_Stack_Vars
     You'll need to use this one, if you want to use the others. It sets
     up a few local variables: `sp', items, `ax' and mark, for use by the
     other macros. It's not important to know what they do, but I mention
     them to avoid possible name conflicts.

     NOTE: Since this macro declares variables, you'll need to put it with
     your other variable declarations at the top of your function. It must
     come before any executable statements and before any other
     `Inline_Stack' macros.

Inline_Stack_Items
     Returns the number of arguments passed in on the Stack.

Inline_Stack_Item(i)
     Refers to a particular `SV*' in the Stack, where i is an index number
     starting from zero. Can be used to get or set the value.

Inline_Stack_Reset
     Use this before pushing anything back onto the Stack. It resets the
     internal Stack pointer to the beginning of the Stack.

Inline_Stack_Push(sv)
     Push a return value back onto the Stack. The value must be of type
     `SV*'.

Inline_Stack_Done
     After you have pushed all of your return values, you must call this
     macro.

Inline_Stack_Return(n)
     Return n items on the Stack.

Inline_Stack_Void
     A special macro to indicate that you really don't want to return
     anything. Same as:

          Inline_Stack_Return(0);

   Each of these macros is available in 3 different styles to suit your
coding tastes. The following macros are equivalent.

     Inline_Stack_Vars
     inline_stack_vars
     INLINE_STACK_VARS

   All of this functionality is available through XS macro calls as well.
So why duplicate the functionality? There are a few reasons why I decided
to offer this set of macros. First, as a convenient way to access the
Stack. Second, for consistent, self documenting, non-cryptic coding.
Third, for future compatibility. It occured to me that if a lot of people
started using XS macros for their C code, the interface might break under
Perl6. By using this set, hopefully I will be able to insure future
compatibility of argument handling.

   Of course, if you use the rest of the Perl API, your code will most
likely break under Perl6. So this is not a 100% guarantee. But since
argument handling is the most common interface you're likely to use, it
seemed like a wise thinng to do.

Writing C Subroutines
=====================

   The definitions of your C functions will fall into one of the following
four categories. For each category there are special considerations.

  1.      int Foo(int arg1, char* arg2, SV* arg3) {

     This is the simplest case. You have a non void return type and a
     fixed length argument list. You don't need to worry about much. All
     the conversions will happen automatically.

  2.      void Foo(int arg1, char* arg2, SV* arg3) {

     In this category you have a void return type. This means that either
     you want to return nothing, or that you want to return a list. In the
     latter case you'll need to push values onto the Stack yourself. There
     are a few Inline macros that make this easy. Code something like this:

          int i, max; SV* my_sv[10];
          Inline_Stack_Vars;
          Inline_Stack_Reset;
          for (i = 0; i < max; i++)
            Inline_Stack_Push(my_sv[i]);
          Inline_Stack_Done;

     After resetting the Stack pointer, this code pushes a series of
     return values. At the end it uses Inline_Stack_Done to mark the end
     of the return stack.

     If you really want to return nothing, then don't use the
     `Inline_Stack_' macros. If you must use them, then set use
     Inline_Stack_Void at the end of your function.

  3.      char* Foo(SV* arg1, ...) {

     In this category you have an unfixed number of arguments. This means
     that you'll have to pop values off the Stack yourself. Do it like
     this:

          int i;
          Inline_Stack_Vars;
          for (i = 0; i < Inline_Stack_Items; i++)
            handle_sv(Inline_Stack_Item(i));

     The return type of Inline_Stack_Item(i) is `SV*'.

  4.      void* Foo(SV* arg1, ...) {

     In this category you have both a void return type and an unfixed
     number of arguments. Just combine the techniques from Categories 3
     and 4.


Examples
========

   Here is a few examples. Each one is a complete program that you can try
running yourself. For many more examples see *Note Inline/C-Cookbook:
Inline/C-Cookbook,.

Example #1 - Greetings
----------------------

   This example will take one string argument (a name) and print a
greeting. The function is called with a string and with a number. In the
second case the number is forced to a string.

   Notice that you do not need to `#include <stdio.h'>. The `perl.h'
header file which gets included by default, automatically loads the
standard C header files for you.

     greet('Ingy');
     greet(42);
     
     use Inline C => <<'END_OF_C_CODE';
     
     void greet(char* name) {
       printf("Hello %s!\n", name);
     }
     
     END_OF_C_CODE

Example #2 - and Salutations
----------------------------

   This is similar to the last example except that the name is passed in
as a `SV*' (pointer to Scalar Value) rather than a string (`char*'). That
means we need to convert the SV to a string ourselves. This is
accomplished using the SvPVX function which is part of the Perl internal
API. See `perldoc perlapi' for more info.

   One problem is that SvPVX doesn't automatically convert strings to
numbers, so we get a little surprise when we try to greet 42. The program
segfaults, a common occurence when delving into the guts of Perl.

     greet('Ingy');
     greet(42);
     
     use Inline C => <<'END_OF_C_CODE';
     
     void greet(SV* sv_name) {
       printf("Hello %s!\n", SvPVX(sv_name));
     }
     
     END_OF_C_CODE

Example #3 - Fixing the problem
-------------------------------

   We can fix the problem in Example #2 by using the SvPV function
instead. This function will stringify the SV if it does not contain a
string. SvPV returns the length of the string as it's second parameter.
Since we don't care about the length, we can just put PL_na there, which
is a special variable designed for that purpose.

     greet('Ingy');
     greet(42);
     
     use Inline C => <<'END_OF_C_CODE';
     
     void greet(SV* sv_name) {
       printf("Hello %s!\n", SvPV(sv_name, PL_na));
     }
     
     END_OF_C_CODE

SEE ALSO
========

   For general information about Inline see *Note Inline: Inline,.

   For sample programs using Inline with C see *Note Inline/C-Cookbook:
Inline/C-Cookbook,.

   For information on supported languages and platforms see *Note
Inline-Support: Inline-Support,.

   For information on writing your own Inline Language Support Module, see
*Note Inline-API: Inline-API,.

   Inline's mailing list is inline@perl.org

   To subscribe, send email to inline-subscribe@perl.org

AUTHOR
======

   Brian Ingerson <INGY@cpan.org>

COPYRIGHT
=========

   Copyright (c) 2001, Brian Ingerson. All Rights Reserved.  This module
is free software. It may be used, redistributed and/or modified under the
terms of the Perl Artistic License.

   See http://www.perl.com/perl/misc/Artistic.html


File: pm.info,  Node: Inline/C-Cookbook,  Next: Inline/CPP,  Prev: Inline/C,  Up: Module List

A Cornucopia of Inline C Recipes
********************************

NAME
====

   C Cookbook - A Cornucopia of Inline C Recipes

DESCRIPTION
===========

   It's a lot easier for most of us to cook a meal from a recipe, rather
than just throwing things into a pot until something edible forms. So it
is with programming as well. `Inline.pm' makes C programming for Perl as
easy as possible. Having a set of easy to understand samples, makes it
simpler yet.

   This Cookbook is intended to be an evergrowing repository of small yet
complete coding examples; each showing how to accomplish a particular task
with Inline. Each example is followed by a short discussion, explaining in
detail the particular features that are being demonstrated.

   Many of these recipes are apdapted from email discussions I have had
with Inline users around the world. It has been my experience so far, that
Inline provides an elegant solution to almost all problems involving Perl
and C.

   Bon Appetit!

Appetizers
==========

Hello, world
------------

Problem
     It seems that the first thing any programmer wants to do when he
     learns a new programming technique is to use it to greet the Earth.
     How can I do this using Inline?

Solution
          use Inline C => <<'END_C';
          
          void greet() {
          	printf("Hello, world\n");
          }
          END_C

          greet;

Discussion
     Nothing too fancy here. We define a single C function `greet()' which
     prints a message to STDOUT. One thing to note is that since the
     Inline code comes before the function call to `greet', we can call it
     as a bareword (no parentheses).

See Also
     See *Note Inline: Inline, and *Note Inline/C: Inline/C, for basic
     info about `Inline.pm'.

Credits
     Brian Kernigan

     Dennis Ritchie

One Liner
---------

Problem
     A concept is valid in Perl only if it can be shown to work in one
     line. Can Inline reduce the complexities of Perl/C interaction to a
     one-liner?

Solution
          perl -e 'use Inline C=>q{void greet(){printf("Hello, world\n");}};greet'

Discussion
     Try doing that in XS :-)

See Also
     My email signature of late is:

          perl -le 'use Inline C=>q{SV*JAxH(char*x){return newSVpvf("Just Another %s Hacker",x);}};print JAxH+Perl'

     A bit fancier but a few bytes too long to qualify as a true one liner
     :-(

Credits
     "Eli the Bearded" <elijah@workspot.net> gave me the idea that I
     should have an Inline one-liner as a signature.

Meat & Potatoes
===============

Data Types
----------

Problem
     How do I pass different types of data to and from Inline C functions;
     like strings, numbers and integers?

Solution
          # vowels.pl
          use Inline C;
          
          $filename = $ARGV[0];
          die "Usage: perl vowels.pl filename\n" unless -f $filename;
          
          $text = join '', <>;           # slurp input file
          $vp = vowel_scan($text);       # call our function
          $vp = sprintf("%03.1f", $vp * 100);  # format for printing
          print "The letters in $filename are $vp% vowels.\n";
          
          __END__
          __C__

          /* Find percentage of vowels to letters */
          double vowel_scan(char* str) {
              int letters = 0;
              int vowels = 0;
              int i = 0;
              char c;
              char normalize = 'a' ^ 'A';
              /* normalize forces lower case in ASCII; upper in EBCDIC */
              char A = normalize | 'a';
              char E = normalize | 'e';
              char I = normalize | 'i';
              char O = normalize | 'o';
              char U = normalize | 'u';
              char Z = normalize | 'z';
          
              while(c = str[i++]) {
                  c |= normalize;
                  if (c >= A && c <= Z) {
                       letters++;
                       if (c == A || c == E || c == I || c == O || c == U)
                           vowels++;
                  }
              }

          return letters ? ((double) vowels / letters) : 0.0;
              }

Discussion
     This script takes a file name from the command line and prints the
     ratio of vowels to letters in that file. `vowels.pl' uses an Inline C
     function called `vowel_scan', that takes a string argument, and
     returns the percentage of vowels as a floating point number between 0
     and 1. It handles upper and lower case letters, and works with ASCII
     and EBCDIC. It is also quite fast.

     Running this script produces:

          > perl vowels.pl /usr/dict/words
          The letters in /usr/dict/words are 37.5% vowels.

See Also
     The Perl Journal vol #19 has an article about Inline which uses this
     example.

Credits
     This example was reprinted by permission of The Perl Journal. It was
     edited to work with Inline v0.30 and higher.

Variable Argument Lists
-----------------------

Problem
     How do I pass a variable-sized list of arguments to an Inline C
     function?

Solution
          greet(qw(Sarathy Jan Sparky Murray Mike));
          
          use Inline C => <<'END_OF_C_CODE';
          
          void greet(SV* name1, ...) {
              Inline_Stack_Vars;
              int i;
          
              for (i = 0; i < Inline_Stack_Items; i++)
                  printf("Hello %s!\n", SvPV(Inline_Stack_Item(i), PL_na));
          
              Inline_Stack_Void;
          }
          
          END_OF_C_CODE

Discussion
     This little program greets a group of people, such as my coworkers.
     We use the C ellipsis syntax: "...", since the list can be of any
     size.

     Since there are no types or names associated with each argument, we
     can't expect XS to handle the conversions for us. We'll need to pop
     them off the Stack ourselves. Luckily there are two functions
     (macros) that make this a very easy task.

     First, we need to begin our function with a "Inline_Stack_Vars"
     statement. This defines a few internal variables that we need to
     access the Stack. Now we can use "Inline_Stack_Items", which returns
     an integer containing the number of arguments passed to us from Perl.

     NOTE: It is important to *only* use "`Inline_Stack_'" macros when
     there is an ellipsis (...) in the argument list, or the function has
     a return type of void.

     Second, we use the `Inline_Stack_Item(x)' function to access each
     argument where "0 <= x < items".

     NOTE: When using a variable length argument list, you have to specify
     at least one argument before the ellipsis. (On my compiler, anyway.)
     When XS does it's argument checking, it will complain if you pass in
     less than the number of defined arguments. Therefore, there is
     currently no way to pass an empty list when a variable length list is
     expected.

See Also
Credits
Multiple Return Values
----------------------

Problem
     How do I return a list of values from a C function?

Solution
          print map {"$_\n"} get_localtime(time);
          
          use Inline C => <<'END_OF_C_CODE';
          
          #include <time.h>
          
          void get_localtime(int utc) {
            struct tm *ltime = localtime(&utc);
            Inline_Stack_Vars;
          
            Inline_Stack_Reset;
            Inline_Stack_Push(newSViv(ltime->tm_year));
            Inline_Stack_Push(newSViv(ltime->tm_mon));
            Inline_Stack_Push(newSViv(ltime->tm_mday));
            Inline_Stack_Push(newSViv(ltime->tm_hour));
            Inline_Stack_Push(newSViv(ltime->tm_min));
            Inline_Stack_Push(newSViv(ltime->tm_sec));
            Inline_Stack_Push(newSViv(ltime->tm_isdst));
            Inline_Stack_Done;
          }
          END_OF_C_CODE

Discussion
     Perl is a language where it is common to return a list of values from
     a subroutine call instead of just a single value. C is not such a
     language. In order to accomplish this in C we need to manipulate the
     Perl call stack by hand. Luckily, Inline provides macros to make this
     easy.

     This example calls the system localtime, and returns each of the
     parts of the time struct; much like the perl builtin `localtime()'.

     NOTE: The `#include' statement is not really needed, because Inline
     automatically includes the Perl headers which include almost all
     standard system calls.

See Also
     For more information on the Inline stack macros, see *Note Inline/C:
     Inline/C,.

Credits
     Richard Anderson <starfire@zipcon.net> contributed the original idea
     for this snippet.

Using Memory
------------

Problem
     How should I allocate buffers in my Inline C code?

Solution
          print greeting('Ingy');
          
          use Inline C => <<'END_OF_C_CODE';
          
          SV* greeting(SV* sv_name) {
              return (newSVpvf("Hello %s!\n", SvPV(sv_name, PL_na)));
          }
          
          END_OF_C_CODE

Discussion
     In this example we will return the greeting to the caller, rather
     than printing it. This would seem mighty easy, except for the fact
     that we need to allocate a small buffer to create the greeting.

     I would urge you to stay away from mallocing your own buffer. Just
     use Perl's built in memory management. In other words, just create a
     new Perl string scalar. The function newSVpv does just that. And
     newSVpvf includes sprintf functionality.

     The other problem is getting rid of this new scalar. How will the ref
     count get decremented after we pass the scalar back? Perl also
     provides a function called sv_2mortal. Mortal variables die when the
     context goes out of scope. In other words, Perl will wait until the
     new scalar gets passed back and then decrement the ref count for you,
     thereby making it eligible for garbage collection. See `perldoc
     perlguts'.

     In this example the sv_2mortal call gets done under the hood by XS,
     because we declared the return type to be `SV*'.

     To view the generated XS code, run the command "`perl
     -MInline=INFO,FORCE,NOCLEAN example004.pl'". This will leave the
     build directory intact and tell you where to find it.

See Also
Credits
Fast Food
=========

Inline CGI
----------

Problem
     How do I use Inline securely in a CGI environment?

Solution
          #!/usr/bin/perl
          
          use CGI qw(:standard);
          use Inline (Config =>
                      DIRECTORY => '/usr/local/apache/Inline',
                     );
          
          print (header,
                 start_html('Inline CGI Example'),
                 h1(JAxH('Inline')),
                 end_html
                );
          
          use Inline C => <<END;
          SV* JAxH(char* x) {
              return newSVpvf("Just Another %s Hacker", x);
          }
          END

Discussion
     The problem with running Inline code from a CGI script is that Inline
     *writes* to a build area on your disk whenever it compiles code. Most
     CGI scripts don't (and shouldn't) be able to create a directory and
     write into it.

     The solution is to explicitly tell Inline which directory to use with
     the 'use Inline Config => DIRECTORY => ...' line. Then you need to
     give write access to that directory from the web server (CGI script).

     If you see this as a security hole, then there is another option.
     Give write access to yourself, but read-only access to the CGI
     script. Then run the script once by hand (from the command line).
     This will cause Inline to precompile the C code. That way the CGI
     will only need read access to the build directory (to load in the
     shared library from there).

     Just remember that whenever you change the C code, you need to
     precompile it again.

See Also
     See *Note CGI: CGI, for more information on using the `CGI.pm' module.

Credits
Object Oriented Inline
----------------------

Problem
     How do I implement Object Oriented programming in Perl using C
     objects?

Solution
          my $obj1 = Soldier->new('Benjamin', 'Private', 11111);
          my $obj2 = Soldier->new('Sanders', 'Colonel', 22222);
          my $obj3 = Soldier->new('Matt', 'Sergeant', 33333);
          
          for my $obj ($obj1, $obj2, $obj3) {
              print ($obj->get_serial, ") ",
                     $obj->get_name, " is a ",
                     $obj->get_rank, "\n");
          }
          
          #---------------------------------------------------------
          
          package Soldier;
          
          use Inline C => <<'END';
          
          typedef struct {
              char* name;
              char* rank;
              long  serial;
          } Soldier;
          
          SV* new(char* class, char* name, char* rank, long serial) {
              Soldier* soldier = malloc(sizeof(Soldier));
              SV*      obj_ref = newSViv(0);
              SV*      obj = newSVrv(obj_ref, class);

          soldier->name = strdup(name);
          soldier->rank = strdup(rank);
          soldier->serial = serial;
          
          sv_setiv(obj, (IV)soldier);
          SvREADONLY_on(obj);
          return obj_ref;
              }
          
              char* get_name(SV* obj) {
          return ((Soldier*)SvIV(SvRV(obj)))->name;
              }
          
              char* get_rank(SV* obj) {
          return ((Soldier*)SvIV(SvRV(obj)))->rank;
              }
          
              long get_serial(SV* obj) {
          return ((Soldier*)SvIV(SvRV(obj)))->serial;
              }

          void DESTROY(SV* obj) {
              Soldier* soldier = (Soldier*)SvIV(SvRV(obj));
              free(soldier->name);
              free(soldier->rank);
              free(soldier);
          }
          END

Discussion
     Damian Conway has given us myriad ways of implementing OOP in Perl.
     This is one he might not have thought of.

     The interesting thing about this example is that it uses Perl for all
     the OO bindings while using C for the attributes and methods.

     If you examine the Perl code everything looks exactly like a regular
     OO example. There is a new method and several accessor methods. The
     familiar 'arrow syntax' is used to invoke them.

     In the class definition (second part) the Perl package statement is
     used to name the object class or namespace. But that's where the
     similarities end Inline takes over.

     The idea is that we call a C subroutine called new() which returns a
     blessed scalar. The scalar contains a readonly integer which is a C
     pointer to a Soldier struct. This is our object.

     The new() function needs to malloc the memory for the struct and then
     copy the initial values into it using `strdup()'. This also allocates
     more memory (which we have to keep track of).

     The accessor methods are pretty straightforward. They return the
     current value of their attribute.

     The last method DESTROY() is called automatically by Perl whenever an
     object goes out of scope. This is where we can free all the memory
     used by the object.

     That's it. It's a very simplistic example. It doesn't show off any
     advanced OO features, but it is pretty cool to see how easy the
     implementation can be. The important Perl call is `newSVrv()' which
     creates a blessed scalar.

See Also
     Read "Object Oriented Perl" by Damian Conway, for more useful ways of
     doing OOP in Perl.

     You can learn more Perl calls in *Note Perlapi: (perl.info)perlapi,.
     If you don't have Perl 5.6.0 or higher, visit
     http://www.perldoc.com/perl5.6/pod/perlapi.html

Credits
The Main Course
===============

Exposing Shared Libraries
-------------------------

Problem
     You have this great C library and you want to be able to access parts
     of it with Perl.

Solution
          print get('http://www.axkit.org');
          
          use Inline C => Config =>
                     LIBS => '-lghttp';
          use Inline C => <<'END_OF_C_CODE';
          
          #include <ghttp.h>
          
          char *get(SV* uri) {
             SV* buffer;
             ghttp_request* request;
          
             buffer = NEWSV(0,0);
             request = ghttp_request_new();
             ghttp_set_uri(request, SvPV(uri, PL_na));
          
             ghttp_set_header(request, http_hdr_Connection, "close");
          
             ghttp_prepare(request);
             ghttp_process(request);
          
             sv_catpv(buffer, ghttp_get_body(request));
          
             ghttp_request_destroy(request);
          
             return SvPV(buffer, PL_na);
          }
          
          END_OF_C_CODE

Discussion
     This example fetches and prints the HTML from http://www.axkit.org It
     requires the GNOME http libraries. http://www.gnome.org

     One of the most common questions I get is "How can I use Inline to
     make use of some shared library?". Although it has always been
     possible to do so, the configuration was ugly, and there were no
     specific examples.

     With version 0.30 and higher, you can specify the use of shared
     libraries easily with something like this:

          use Inline C => Config => LIBS => '-lghttp';
          use Inline C => "code ...";

     or

          use Inline C => "code ...", LIBS => '-lghttp';

     To specify a specific library path, use:

          use Inline C => "code ...", LIBS => '-L/your/lib/path -lyourlib';

     To specify an include path use:

          use Inline C => "code ...",
                     LIBS => '-lghttp',
                     INC => '-I/your/inc/path';

See Also
     The LIBS and INC configuration options are formatted and passed into
     MakeMaker. For more info see *Note ExtUtils/MakeMaker:
     ExtUtils/MakeMaker,. For more options see *Note Inline/C: Inline/C,.

Credits
     This code was written by Matt Sergeant <matt@sergeant.org>, author of
     many CPAN modules. The configuration syntax has been modified for use
     with Inline v0.30.

Complex Data
------------

Problem
     How do I deal with complex data types like hashes in Inline C?

Solution
          use Inline C => <<'END_OF_C_CODE';
          
          void dump_hash(SV* hash_ref) {
              HV* hash;
              HE* hash_entry;
              int num_keys, i;
              SV* sv_key;
              SV* sv_val;
          
              if (! SvROK(hash_ref))
                  croak("hash_ref is not a reference");
          
              hash = (HV*)SvRV(hash_ref);
              num_keys = hv_iterinit(hash);
              for (i = 0; i < num_keys; i++) {
                  hash_entry = hv_iternext(hash);
                  sv_key = hv_iterkeysv(hash_entry);
                  sv_val = hv_iterval(hash, hash_entry);
                  printf("%s => %s\n", SvPV(sv_key, PL_na), SvPV(sv_val, PL_na));
              }
              return;
          }
          
          END_OF_C_CODE
          
          my %hash = (
          	        Author => "Brian Ingerson",
          	        Nickname => "INGY",
          	        Module => "Inline.pm",
          	        Version => "0.30",
          	        Language => "C",
          	       );
          
          dump_hash(\%hash);

Discussion
     The world is not made of scalars alone, although they are definitely
     the easiest creatures to deal with, when doing Inline stuff.
     Sometimes we need to deal with arrays, hashes, and code references,
     among other things.

     Since Perl subroutine calls only pass scalars as arguments, we'll
     need to use the argument type `SV*' and pass references to more
     complex types.

     The above program dumps the key/value pairs of a hash. To figure it
     out, just curl up with *Note Perlapi: (perl.info)perlapi, for a
     couple hours. Actually, its fairly straight forward once you are
     familiar with the calls.

     Note the croak function call. This is the proper way to die from your
     C extensions.

See Also
     See *Note Perlapi: (perl.info)perlapi, for information about the
     Perl5 internal API.

Credits
Hash of Lists
-------------

Problem
     How do I create a Hash of Lists from C?

Solution
          use Inline C;
          use Data::Dumper;
          
          $hash_ref = load_data("./cartoon.txt");
          print Dumper $hash_ref;
          
          __END__
          __C__
          
          static int next_word(char**, char*);
          
          SV* load_data(char* file_name) {
              char buffer[100], word[100], * pos;
              AV* array;
              HV* hash = newHV();
              FILE* fh = fopen(file_name, "r");
          
              while (fgets(pos = buffer, sizeof(buffer), fh)) {
                  if (next_word(&pos, word)) {
                      hv_store(hash, word, strlen(word),
                              newRV_noinc((SV*)array = newAV()), 0);
                      while (next_word(&pos, word))
                          av_push(array, newSVpvf("%s", word));
                  }
              }
              fclose(fh);
              return newRV_noinc((SV*) hash);
          }
          
          static int next_word(char** text_ptr, char* word) {
              char* text = *text_ptr;
              while(*text != '\0' &&
                    *text <= ' ')
                  text++;
              if (*text <= ' ')
                  return 0;
              while(*text != '\0' &&
                    *text > ' ') {
                  *word++ = *text++;
              }
              *word = '\0';
              *text_ptr = text;
              return 1;
          }

Discussion
     This is one of the larger recipes. But when you consider the number
     of calories it has, it's not so bad. The function `load_data' takes
     the name of a file as it's input. The file `cartoon.text' might look
     like:

          flintstones fred barney
          jetsons     george jane elroy
          simpsons    homer marge bart

     The function will read the file, parsing each line into words. Then
     it will create a new hash, whereby the first word in a line becomes a
     hash key and the remaining words are put into an array whose
     reference becomes the hash value. The output looks like this:

          $VAR1 = {
                    'flintstones' => [
                                       'fred',
                                       'barney'
                                     ],
                    'simpsons' => [
                                    'homer',
                                    'marge',
                                    'bart'
                                  ],
                    'jetsons' => [
                                   'george',
                                   'jane',
                                   'elroy'
                                 ]
                  };

See Also
     See *Note Perlapi: (perl.info)perlapi, for information about the
     Perl5 internal API.

Credits
     Al Danial <alnd@pacbell.net> requested a solution to this on
     comp.lang.perl.misc. He borrowed the idea from the "Hash of Lists"
     example in the Camel book.

Just Desserts
=============

Win32
-----

Problem
     How do I access Win32 DLL-s using Inline?

Solution
          use Inline C => DATA =>
                     LIBS => '-luser32';
          
          $text = "@ARGV" || 'Inline.pm works with MSWin32. Scary...';
          
          WinBox('Inline Text Box', $text);
          
          __END__
          __C__
          
          #include <windows.h>
          
          int WinBox(char* Caption, char* Text) {
            return MessageBoxA(0, Text, Caption, 0);
          }

Discussion
     This example runs on MS Windows. It makes a text box appear on the
     screen which contains a message of your choice.

     The important thing is that its proof that you can use Inline to
     interact with Windows DLL-s. Very scary indeed. 8-o

     To use Inline on Windows with ActivePerl ( http://www.ActiveState.com
     ) you'll need MS Visual Studio. You can also use the Cygwin
     environment, available at http://www.cygwin.com .

See Also
     See *Note Inline-Support: Inline-Support, for more info on MSWin32
     programming with Inline.

Credits
     This example was adapted from some sample code written by Garrett
     Goebel <garrett@scriptpro.com>

Embedding Perl in C
-------------------

Problem
     How do I use Perl from a regular C program?

Solution
          #!/usr/bin/cpr
          
          int main(void) {

          printf("Using Perl version %s from a C program!\n\n",
                         CPR_eval("use Config; $Config{version};"));

          CPR_eval("use Data::Dumper;");
          CPR_eval("print Dumper \\%INC;");

          return 0;

          }

Discussion
     By using CPR. (C Perl Run)

     This example uses another Inline module, `Inline::CPR', available
     separately on CPAN. When you install this module it also installs a
     binary interpreter called `/usr/bin/cpr'. (The path may be different
     on your system)

     When you feed a C program to the CPR interpreter, it automatically
     compiles and runs your code using Inline. This gives you full access
     to the Perl internals. CPR also provides a set of easy to use C
     macros for calling Perl internals.

     This means that you can effectively "run" C source code by putting a
     CPR hashbang as the first line of your C program.

See Also
     See *Note Inline/CPR: Inline/CPR, for more information on using CPR.

     `Inline::CPR' can be obtained from
     http://search.cpan.org/search?dist=Inline-CPR

Credits
     Randal Schwartz <merlyn@stonehenge.com>, Randolph Bentson
     <bentson@grieg.holmsjoen.com>, Richard Anderson
     <starfire@zipcon.net>, and Tim Maher <tim@consultix-inc.com> helped
     me figure out how to write a program that would work as a hashbang.

Entertaining Guests
===================

   As of version 0.30, Inline has the ability to work in cooperation with
other modules that want to expose a C API of their own. The general syntax
for doing this is:

     use Inline with => 'Module';
     use Inline C => ... ;

   This tells Module to pass configuration options to Inline. Options like
typemaps, include paths, and external libraries, are all resolved
automatically so you can just concentrate on writing the functions.

Event handling with Event.pm
----------------------------

Problem
     You need to write a C callback for the `Event.pm' module. Can this be
     done more easily with Inline?

Solution
          use Inline with => 'Event';
          
          Event->timer(desc     => 'Timer #1',
                       interval => 2,
                       cb       => \&my_callback,
                      );
          
          Event->timer(desc     => 'Timer #2',
                       interval => 3,
                       cb       => \&my_callback,
                      );
          
          print "Starting...\n";
          Event::loop;
          
          use Inline C => <<'END';
          void my_callback(pe_event* event) {
              pe_timer * watcher = event->up;
          
              printf("%s\n\tEvent priority = %d\n\tWatcher priority = %d\n\n",
                     SvPVX(watcher->base.desc),
                     event->prio,
                     watcher->base.prio
                    );
          }
          END

Discussion
     The first line tells Inline to load the `Event.pm' module. Inline
     then queries Event for configuration information. It gets the name
     and location of Event's header files, typemaps and shared objects.
     The parameters that Event returns look like:

          INC => "-I $path/Event",
          TYPEMAPS => "$path/Event/typemap",
          MYEXTLIB => "$path/auto/Event/Event.$so",
          AUTO_INCLUDE => '#include "EventAPI.h"',
          BOOT => 'I_EVENT_API("Inline");',

     Doing all of this automatically allows you, the programmer, to simply
     write a function that receives a pointer of type `'pe_event*''. This
     gives you access to the Event structure that was passed to you.

     In this example, I simply print values out of the structure. The Perl
     code defines 2 timer events which each invoke the same callback. The
     first one, every two seconds, and the second one, every three seconds.

     As of this writing, `Event.pm' is the only CPAN module that works in
     cooperation with Inline.

See Also
     Read the `Event.pm' documentation for more information. It contains a
     tutorial showing several examples of using Inline with Event.

Credits
     Jochen Stenzel <perl@jochen-stenzel.de> originally came up with the
     idea of mixing Inline and Event. He also authored the Event tutorial.

     Joshua Pritikin <joshua.pritikin@db.com> is the author of `Event.pm'.

Food for Thought
================

Calling C from both Perl and C
------------------------------

Problem
     I'd like to be able to call the same C function from both Perl and C.
     Also I like to define a C function that *doesn't* get bound to Perl.
     How do I do that?

Solution
          print "9 + 5 = ", add(9, 5), "\n";
          print "SQRT(9^2 + 5^2) = ", pyth(9, 5), "\n";
          print "9 * 5 = ", mult(9, 5), "\n";
          
          use Inline C => <<'END_C';
          int add(int x, int y) {
              return x + y;
          }
          static int mult(int x, int y) {
              return x * y;
          }
          double pyth(int x, int y) {
              return sqrt(add(mult(x, x), mult(y, y)));
          }
          END_C

Discussion
     The program produces:

          9 + 5 = 14
          SQRT(9^2 + 5^2) = 10.295630140987
          Can't locate auto/main/mult.al in @INC ...

     Every Inline function that is bound to Perl is also callable by C.
     You don't have to do anything special. Inline arranges it so that all
     the typemap code gets done by XS and is out of sight. By the time the
     C function receives control, everything has been converted from Perl
     to C.

     Of course if your function manipulates the Perl Stack, you probably
     don't want to call it from C (unless you *really* know what you're
     doing).

     If you declare a function as static, Inline won't bind it to Perl.
     That's why we were able to call `mult()' from C but the call failed
     from Perl.

See Also
Credits
Calling Perl from C
-------------------

Problem
     So now that I can call C from Perl, how do I call a Perl subroutine
     from an Inline C function.

Solution
          use Inline C;
          
          c_func_1('This is the first line');
          c_func_2('This is the second line');
          
          sub perl_sub_1 {
              print map "$_\n", @_;
          }
          
          __DATA__
          __C__
          
          void c_func_1(SV* text) {
              c_func_2(text);
          }
          
          void c_func_2(SV* text) {
              Inline_Stack_Vars;
              Inline_Stack_Push(newSVpvf("Plus an extra line"));
              Inline_Stack_Done;
              perl_call_pv("main::perl_sub_1", 0);
              Inline_Stack_Void;
          }

Discussion
     Actually, this program demonstrates calling a C function which calls
     another C function which in turn calls a Perl subroutine.

     The nice thing about Inline C functions is that you can call them
     from both Perl-space and C-space. That's because Inline creates a
     wrapper function around each C function. When you use Perl to call C
     you're actually calling that function's wrapper. The wrapper handles
     typemapping and Stack management, and then calls your C function.

     The first time we call `c_func_1' which calls `c_func_2'. The second
     time we call `c_func_2' directly. `c_func_2' calls the Perl
     subroutine (`perl_sub_1') using the internal `perl_call_pv' function.
     It has to put arguments on the stack by hand. Since there is already
     one argument on the stack when we enter the function, the
     `Inline_Stack_Push' adds a second argument. Inline_Stack_Void makes
     sure that nothing is returned from the function.

See Also
     See *Note Inline/C: Inline/C, for more information about Stack macros.

     See *Note Perlapi: (perl.info)perlapi, for more information about the
     Perl5 internal API.

Credits
Evaling C
---------

Problem
     I've totally lost my marbles and I want to generate C code at run
     time, and eval it into Perl. How do I do this?

Solution
          use Inline;
          use Code::Generator;
          
          my $c_code = generate('foo_function');
          
          Inline->bind(C => $c_code);
          
          foo_function(1, 2, 3);

Discussion
     I can't think of a real life application where you would want to
     generate C code on the fly, but at least I know know how I would do
     it. :)

     The bind() function of Inline let's you bind (compile/load/execute) C
     functions at run time. It takes all of the same arguments as 'use
     Inline C => ...'.

     The nice thing is that once a particular snippet is compiled, it
     remains cached so that it doesn't need to be compiled again. I can
     imagine that someday a mad scientist will dream up a self generating
     modeling system that would run faster and faster over time.

     If you know such a person, have them drop me a line.

See Also
Credits
SEE ALSO
========

   For generic information about Inline, see *Note Inline: Inline,.

   For information about using Inline with C see *Note Inline/C: Inline/C,.

   For information on supported languages and platforms see *Note
Inline-Support: Inline-Support,.

   For information on writing your own Inline language support module, see
*Note Inline-API: Inline-API,.

   Inline's mailing list is inline@perl.org

   To subscribe, send email to inline-subscribe@perl.org

AUTHOR
======

   Brian Ingerson <INGY@cpan.org>

COPYRIGHT
=========

   Copyright (c) 2001, Brian Ingerson.

   All Rights Reserved.  This module is free software. It may be used,
redistributed and/or modified under the terms of the Perl Artistic License.

   See http://www.perl.com/perl/misc/Artistic.html


