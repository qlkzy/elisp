This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: VCS,  Next: VCS/CVS,  Prev: VCP/Source/revml,  Up: Module List

Library for generic Version Control System access in Perl
*********************************************************

NAME
====

   VCS - Library for generic Version Control System access in Perl

SYNOPSIS
========

     use VCS;
     $file = VCS::File->new($ARGV[0]);
     print $file->name, ":\n";
     for $version ($file->versions) {
         print
             $version->version,
             ' was checked in by ',
             $version->author,
             "\n",
             ;
     }

DESCRIPTION
===========

   `VCS' is an API for abstracting access to all version control systems
from Perl code. This is achieved in a similar fashion to the DBI suite of
modules. There are "container" classes, `VCS::Dir', `VCS::File', and
`VCS::Version', and "implementation" classes, such as `VCS::Cvs::Dir',
`VCS::Cvs::File', and `VCS::Cvs::Version', which are subclasses of their
respective "container" classes.

   The "container" classes work as follows: when the new method of a
container class is called, it will cycle through each of the known
implementation classes, trying its new method with the given arguments
until one returns a defined result, which will then be returned.

   An implementation class is recognised as follows: its name starts with
`VCS::', and `require "VCS/Classname.pm"' will load the appropriate
implementation classes corresponding to the container classes.

   In general, implementation classes' new methods must be careful not to
return "false positives", by rigorously checking if their arguments
conform to their particular version control system.

   Implementation classes must include documentation for their special
requirements, such as mandatory environment variables. See *Note VCS/Cvs:
VCS/Cvs, for an example.

   If a method, or an argument to a method makes no sense for a particular
implementation, then the implementation may ignore it, but must do so
quietly.

METHODS
=======

VCS->implementations
--------------------

   Returns a list of the implementations, in the order in which they will
be tried by the container classes. The first time it is called (as
determined by whether there are any implementations known), it will search
@INC for all compliant implementations.

VCS->add_implementations(@implementations)
------------------------------------------

   `@implementations' is moved/added to the front of the list, so use this
also to set the default or control the order of implementations tried.

AVAILABILITY
============

   VCS.pm and its friends will be available from CPAN.

MAILING LIST
============

   There is currently a mailing list about VCS.

   To subscribe, send a blank message to: vcs-subscribe@astray.com.  To
talk, send a message to: vcs@astray.com.  To unsubscribe, send a blank
message to: vcs-unsubscribe@astray.com.

   General queries should be made directly to the mailing list.

COPYRIGHT
=========

   Copyright (c) 1998/9 Leon Brocard. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

SEE ALSO
========

   *Note VCS/Cvs: VCS/Cvs,, *Note VCS/Dir: VCS/Dir,, *Note VCS/File:
VCS/File,, `VCS::Rcs' in this node, *Note VCS/Version: VCS/Version,.


File: pm.info,  Node: VCS/CVS,  Next: VCS/Cvs,  Prev: VCS,  Up: Module List

Provide a simple interface to CVS (the Concurrent Versions System).
*******************************************************************

NAME
====

   `VCS::CVS' - Provide a simple interface to CVS (the Concurrent Versions
System).

   You need to be clear in your mind about the 4 directories involved:

   * The directory where your source code resides before you import it
     into CVS.  It is used only once - during the import phase. Call this
     $projectSource.

   * The directory into which you check out a read-write copy of the
     repository, in order to edit that copy. Call this $project. You will
     spend up to 100% of your time working within this directory structure.

   * The directory in which the repository resides. This is $CVSROOT. Thus
     $projectSource will be imported into $CVSROOT/$project.

   * The directory into which you get a read-only copy of the repository,
     in order to, say, make and ship that copy. Call this $someDir. It
     must not be $project.

   Note: You cannot have a directory called CVS in your home directory.
That's just asking for trouble.

SYNOPSIS
========

     #!/usr/gnu/bin/perl -w

     use integer;
     use strict;

     use VCS::CVS;

     my($history)        = 1;
     my($initialMsg)     = 'Initial version';
     my($noChange)       = 1;
     my($nullTag)        = '';
     my($permissions)    = 0775;	# But not '0775'!
     my($project)        = 'project';
     my($projectSource)  = 'projectSource';
     my($raw)            = 0;
     my($readOnly)       = 0;
     my($releaseTag)     = 'release_0.00';
     my($vendorTag)      = 'vendorTag';
     my($verbose)        = 1;

     # Note the anonymous hash in the next line, new as of V 1.10.

     my($cvs)            = VCS::CVS -> new({
     			'project' => $project,
     			'raw' => $raw,
     			'verbose' => $verbose,
     			'permissions' => $permissions,
     			'history' => $history});

     $cvs -> createRepository();
     $cvs -> populate($projectSource, $vendorTag, $releaseTag, $initialMsg);
     $cvs -> checkOut($readOnly, $nullTag, $project);

     print join("\n", @{$cvs -> update($noChange)});
     print "\n";
     print join("\n", @{$cvs -> history()});

     exit(0);

DESCRIPTION
===========

   The `VCS::CVS' module provides an OO interface to CVS.

   VCS - Version Control System - is the prefix given to each Perl module
which deals with some sort of source code control system.

   I have seen CVS corrupt binary files, even when run with CVS's binary
option -kb.  So, since CVS doesn't support binary files, neither does
VCS::CVS.

   Stop press: CVS V 1.10 (with RCS 5.7) supports binary files.

   Subroutines whose names start with a '_' are not normally called by you.

   There is a test program included, but I have not yet worked out exactly
how to set it up for make test. Stay tuned.

INSTALLATION
============

   You install `VCS::CVS', as you would install any perl module library,
by running these commands:

     perl Makefile.PL
     make
     make test
     make install

   If you want to install a private copy of `VCS::CVS' in your home
directory, then you should try to produce the initial Makefile with
something like this command:

     perl Makefile.PL LIB=~/perl
     	or
     perl Makefile.PL LIB=C:/Perl/Site/Lib

   If, like me, you don't have permission to write man pages into unix
system directories, use:

     make pure_install

   instead of make install. This option is secreted in the middle of p 414
of the second edition of the dromedary book.

WARNING re CVS bugs
===================

   The following are my ideas as to what constitutes a bug in CVS:

   * The initial revision tag, supplied when populating the repository with
     'cvs import', is not saved into $CVSROOT/CVSROOT/val-tags.

   * The 'cvs tag' command does not always put the tag into 'val-tags'.

   * `'cvs checkout -dNameOfDir'' fails if NameOfDir =~ /\/$/.

   * `'cvs checkout -d NameOfDir'' inserts a leading space into the name of
     the directory it creates.

WARNING re test environment
===========================

   This code has only been tested under Unix. Sorry.

WARNING re project names 'v' directory names
============================================

   I assume your copy of the repository was checked out into a directory
with the same name as the project, since I do a 'cd $HOME/$project' before
running 'cvs status', to see if your copy is up-to-date. This is because
some activity is forbibben unless your copy is up-to-date. Typical cases
of this include:

   * `checkOut'

   * `removeDirectory'

   * `setTag'

WARNING re shell intervention
=============================

   Some commands cause the shell to become involved, which, under Unix,
will read your .cshrc or whatever, which in turn may set CVSROOT to
something other than what you set it to before running your script. If
this happens, panic...

   Actually, I think I've eliminated such cases. You hope so.

WARNING re Perl bug
===================

   As always, be aware that these 2 lines mean the same thing, sometimes:

   * $self -> {'thing'}

   * $self->{'thing'}

   The problem is the spaces around the ->. Inside double quotes, "...",
the first space stops the dereference taking place. Outside double quotes
the scanner correctly associates the $self token with the {'thing'} token.

   I regard this as a bug.

addDirectory($dir, $subDir, $message)
=====================================

   Add an existing directory to the project.

   $dir can be a full path, or relative to the CWD.

addFile($dir, $file, $message)
==============================

   Add an existing file to the project.

   $dir can be a full path, or relative to the CWD.

checkOut($readOnly, $tag, $dir)
===============================

   Prepare & perform 'cvs checkout'.

   You call checkOut, and it calls _checkOutDontCallMe.

   * $readOnly == 0 -> Check out files as read-write.

   * $readOnly == 1 -> Check out files as read-only.

   * $tag is Null -> Do not call upToDate; ie check out repository as is.

   * $tag is not Null -> Call upToDate; Croak if repository is not
     up-to-date.

   The value of $raw used in the call to new influences the handling of
$tag:

   * $raw == 1 -> Your tag is passed as is to CVS.

   * $raw == 0 -> Your tag is assumed to be of the form release_1.23, and
     is converted to CVS's form release_1_23.

   $dir can be a full path, or relative to the CWD.

commit($message)
================

   Commit changes.

   Called as appropriate by addFile, removeFile and removeDirectory, so
you don't need to call it.

createRepository()
==================

   Create a repository, using the current $CVSROOT.

   This involves creating these files:

   * $ENV{'CVSROOT'}/CVSROOT/modules

   * $ENV{'CVSROOT'}/CVSROOT/val-tags

   * $ENV{'CVSROOT'}/CVSROOT/history

   Notes:

   * The 'modules' file contains these lines:

          CVSROOT  CVSROOT
          modules  CVSROOT  modules
          $self -> {'project'}  $self -> {'project'}

     where $self -> {'project'} comes from the 'project' parameter to new()

   * The 'val-tags' file is initially empty

   * The 'history' file is only created if the 'history' parameter to
     new() is set.  The file is initially empty

getTags()
=========

   Return a reference to a list of tags.

   See also: the $raw option to new().

   `getTags' does not take a project name because tags belong to the
repository as a whole, not to a project.

history({})
===========

   Report details from the history log, $CVSROOT/CVSROOT/history.

   You must have used new({'history' => 1}), or some other mechanism, to
create the history file, before CVS starts logging changes into the
history file.

   The anonymous hash takes any parameters 'cvs history' takes, and joins
them with a single space. Eg:

     $cvs -> history();

     $cvs -> history({'-e' => ''});

     $cvs -> history({'-xARM' => ''});

     $cvs -> history({'-u' => $ENV{'LOGNAME'}, '-x' => 'A'});

   but not

     $cvs -> history({'-xA' => 'M'});

   because it doesn't work.

new({})
=======

   Create a new object. See the synopsis.

   The anonymous hash takes these parameters, of which 'project' is the
only required one.

   * 'project' => 'killerApp'. The required name of the project. No default

   * 'permissions' => 0775. Unix-specific stuff. Default. Do not use
     '0775'.

   * 'history' => 0. Do not create $CVSROOT/CVSROOT/history when
     createRepository() is called. Default

   * 'history' => 1. Create $CVSROOT/CVSROOT/history, which initiates 'cvs
     history' stuff

   * 'raw' => 0. Convert tags from CVS format to real format. Eg:
     release_1.23. Default.

   * 'raw' => 1. Return tags in raw CVS format. Eg: release_1_23.

   * 'verbose' => 0. Do not report on the progress of mkpath/rmtree

   * 'verbose' => 1. Report on the progress of mkpath/rmtree. Default

populate($sourceDir, $vendorTag, $releaseTag, $message)
=======================================================

   Import an existing directory structure. But, (sub) import is a reserved
word.

   Use this to populate a repository for the first time.

   The value used for $vendorTag is not important; CVS discards it.

   The value used to $releaseTag is important; CVS discards it (why?) but I
force it to be the first tag in $CVSROOT/CVSROOT/val-tags. Thus you should
supply a meaningful value. Thus 'release_0_00' is strongly, repeat
strongly, recommended.

   The value of $raw used in the call to new influences the handling of
$tag:

   * $raw == 1 -> Your tag is passed as is to CVS.

   * $raw == 0 -> Your tag is assumed to be of the form release_1.23, and
     is converted to CVS's form release_1_23.

removeDirectory($dir)
=====================

   Remove a directory from the project.

   This deletes the directory (and all its files) from your working copy
of the repository, as well as deleting them from the repository.

   Warning: $dir will have $CVSROOT and $HOME prepended by this code.  Ie:
$dir starts from - but excludes - your home directory (assuming, of
course, you've checked out into your home directory...).

   You can't remove the current directory, or a parent.

removeFile($dir, $file, $message)
=================================

   Remove a file from the project.

   This deletes the file from your working copy of the repository, as well
as deleting it from the repository.

   $dir can be a full path, or relative to the CWD.  $file is relative to
$dir.

runOrCroak()
============

   The standard way to run a system command and report on the result.

setTag($tag)
============

   Tag the repository.

   You call setTag, and it calls _setTag.

   The value of $raw used in the call to new influences the handling of
$tag:

   * $raw == 1 -> Your tag is passed as is to CVS.

   * $raw == 0 -> Your tag is assumed to be of the form release_1.23, and
     is converted to CVS's form release_1_23.

stripCVSDirs($dir)
==================

   Delete all CVS directories and files from a copy of the repository.

   Each user directory contains a CVS sub-directory, which holds 3 files:

   * Entries

   * Repository

   * Root

   Zap 'em.

status()
========

   Run cvs status.

   Return a reference to a list of lines.

   Only called by upToDate(), but you may call it.

update($noChange)
=================

   Run 'cvs -q [-n] update', returning a reference to a list of lines.
Each line will start with one of [UARMC?], as per the CVS docs.

   $cvs -> update(1) is a good way to get a list of uncommited changes,
etc.

   * $noChange == 0 -> Do not add -n to the cvs command. Ie update your
     working copy

   * $noChange == 1 -> Add -n to the cvs command. Do not change any files

upToDate()
==========

   * return == 0 -> Repository not up-to-date.

   * return == 1 -> Up-to-date.

_checkOutDontCallMe($readOnly, $tag, $dir)
==========================================

   Checkout a current copy of the project.

   You call checkOut, and it calls this.

   * $readOnly == 0 -> Check out files as read-write.

   * $readOnly == 1 -> Check out files as read-only.

_fixTag($tag)
=============

   Fix a tag which CVS failed to add.

   Warning: $tag must be in CVS format: release_1_23, not release_1.23.

_mkpathOrCroak($self, $dir)
===========================

   There is no need for you to call this.

_readFile($file)
================

   Return a reference to a list of lines.

   There is no need for you to call this.

_setTag($tag)
=============

   Tag the current version of the project.

   Warning: $tag must be in CVS format: release_1_23, not release_1.23.

   You call setTag and it calls this.

_validateObject($tag, $file, $mustBeAbsent)
===========================================

   Validate an entry in one of the CVS files 'module' or 'val-tags'.

   Warning: $tag must be in CVS format: release_1_23, not release_1.23.

AUTHOR
======

   `VCS::CVS' was written by Ron Savage *<rpsavage@ozemail.com.au>* in
1998.

LICENCE
=======

   This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: VCS/Cvs,  Next: VCS/Dir,  Prev: VCS/CVS,  Up: Module List

implementation notes for CVS implementation
*******************************************

NAME
====

   VCS::Cvs - implementation notes for CVS implementation

SYNOPSIS
========

     $ENV{CVSROOT} = '/cvsroot';
     use VCS;
     $file = VCS::File->new('/source/cvsrepos/project/Makefile');

DESCRIPTION
===========

   Currently, the user needs to ensure that the environmental requirements
for CVS command line tools are satisfied.

AVAILABILITY
============

   VCS::Cvs is currently part of the main VCS distribution.

COPYRIGHT
=========

   Copyright (c) 1998-9 Leon Brocard. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

SEE ALSO
========

   *Note VCS: VCS,.


File: pm.info,  Node: VCS/Dir,  Next: VCS/File,  Prev: VCS/Cvs,  Up: Module List

module for access to a VCS directory
************************************

NAME
====

   VCS::Dir - module for access to a VCS directory

SYNOPSIS
========

     use VCS;
     my $d = VCS::Dir->new($dir);
     print $d->name . "\n";
     foreach my $x ($d->content) {
         print "\t" . $x->name . "\t" . ref($x) . "\n";
     }

DESCRIPTION
===========

   `VCS::Dir' abstracts access to a directory under version control.

METHODS
=======

   Methods marked with a "*" are not yet finalised/implemented.

VCS::Dir->create_new($dir) *
----------------------------

   $dir is a directory name, absolute or relative.  Creates data as
appropriate to convince the VCS that there is a file-container, and
returns an object of class `VCS::Dir', or undef if it fails. This is a
pure virtual method, which must be over-ridden, and cannot be called
directly in this class (a die will result).

VCS::Dir->introduce($name, $create_class) *
-------------------------------------------

   $name is a file or directory name, absolute or relative.
`$create_class' is either File or Dir, and implementation classes are
expected to use something similar to this code, to call the appropriate
create_new:

     sub introduce {
         my ($class, $name, $create_class) = @_;
         my $call_class = $class;
         $call_class =~ s/[^:]+$/$create_class/;
         return $call_class->create_new($name);
     }

   This is a pure virtual method, which must be over-ridden, and cannot be
called directly in this class (a die will result).

VCS::Dir->new($dir)
-------------------

   $dir is a directory name, absolute or relative.  Returns an object of
class `VCS::Dir', or undef if it fails.

$dir->name
----------

   Returns the $dir argument to new.

$dir->content
-------------

   Returns a list of objects, either of class `VCS::Dir' or `VCS::File',
corresponding to files and directories within this directory.

SEE ALSO
========

   *Note VCS: VCS,.

COPYRIGHT
=========

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: VCS/File,  Next: VCS/PVCS,  Prev: VCS/Dir,  Up: Module List

module for access to a file under version control
*************************************************

NAME
====

   VCS::File - module for access to a file under version control

SYNOPSIS
========

     use VCS;
     my $f = VCS::File->new($file);
     print $f->name . "\n";
     foreach my $v ($f->versions) {
         print "\tversion: " . $v->version . "\t" . ref($v) . "\n";
     }

DESCRIPTION
===========

   `VCS::File' abstracts access to a file under version control.

METHODS
=======

   Methods marked with a "*" are not yet finalised/implemented.

VCS::File->create_new($name) *
------------------------------

   $name is a file name, absolute or relative.  Creates data as
appropriate to convince the VCS that there is a file, and returns an
object of class `VCS::File', or undef if it fails. This is a pure virtual
method, which must be over-ridden, and cannot be called directly in this
class (a die will result).

VCS::File->introduce($version_args) *
-------------------------------------

   `$version_args' is a hash-ref, see *Note VCS/Version: VCS/Version, for
details.  Implementation classes are expected to use something similar to
this code, to call create_new in the right `VCS::Version' subclass:

     sub introduce {
         my ($class, $version_args) = @_;
         my $call_class = $class;
         $call_class =~ s/[^:]+$/Version/;
         return $call_class->create_new($version_args);
     }

   This is a pure virtual method, which must be over-ridden, and cannot be
called directly in this class (a die will result).

VCS::File->new($file)
---------------------

   $file is a file name, absolute or relative.  Returns an object of class
`VCS::File', or undef if it fails.

$file->name
-----------

   Returns the $file argument to new.

$file->versions
---------------

   Returns a list of objects of class `VCS::Version', in order of ascending
revision number. If it is passed an extra (defined) argument, it only
returns the last version as a `VCS::Version'.

SEE ALSO
========

   *Note VCS: VCS,.

COPYRIGHT
=========

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: VCS/PVCS,  Next: VCS/PVCS/Archive,  Prev: VCS/File,  Up: Module List

Global configuration class for for VCS::PVCS::*.
************************************************

NAME
====

   VCS::PVCS - Global configuration class for for VCS::PVCS::*.

SYNOPSIS
========

     use VCS::PVCS::Project;  # preferred
     $project = new VCS::PVCS::Project("ProjectName");

DESCRIPTION
===========

   The VCS::PVCS class simply parses the PVCS global configuration files,
including pvcsproj.pub and MASTER.CFG, found in PVCSPROJ.  The resulting
object is then included in the VCS::PVCS::Project object as it's "CONFIG".
The class members are used at various times in other subclasses, as
needed.

   NOTE: This module may require some configuration.  If your scripts wont
run, you may need to hardwire some of the global parameters, including
$ISLVINI, $PVCSPROJ, $NFSMAP, $PVCS_BINDIR and possibly others.  You
should inspect the module before installing it, to verify the settings
will work.

   This module also exports several GLOBAL variables, which are used in
various places throughout it's children, and can be used in scripts which
load the *VCS::PVCS::Project* class.  These variables include, but may not
always be limited to:

$PVCSERR
     PVCSERR is set to the current value of $? after each command.

$PVCSDEBUG
     PVCSDEBUG can be turned on to see copious (sometimes useful) debugging
     output as the module is configuring itself, and running.

$PVCSOUTPUT
     PVCSOUTPUT is all of the output from the current method, when it
     executes a pvcs command.  If the command was executed on a folder or
     project-wide basis, then PVCSOUTPUT contains ALL of the output for
     all archives.

$PVCSCURROUTPUT
     PVCSCURROUTPUT is ONLY the output for the most recent command sent to
     the shell.

$PVCSSHOWMODE
     PVCSSHOWMODE is turned on to see, and not execute, commands.

$PVCS_BINDIR
     PVCS_BINDIR is set in the environment or in VCS::PVCS.pm to be the
     location of the PVCS binaries, get, put, vlog, vcs, vdiff, etc.

$PVCSMASTERCFG
     PVCSMASTERCFG is the path to the master configuration file.  This
     variable is not exported to the world through VCS::PVCS::Project, but
     only intended for internal use.

$PVCSCURRPROJCFG
     PVCSCURRPROJCFG is the location of the current projects' Config file.
     This variable is not exported to the world through VCS::PVCS::Project,
     but only intended for internal use.

$PVCSMULTIPLATFORM
     PVCSMULTIPLATFORM tells the modules whether to make certain path
     translations when operating on something other than WIN.  Turn this
     on if you are using PVCS in a multiplatform environment.

     *This variable is turned on automatically if an NFSMAP is found*

$PVCSPROJ
     PVCSPROJ is the base directory for all PVCS control files.

   Ordinarily, this class wont be used directly.  Rather, it is in the
@ISA for VCS::PVCS::Project.  When creating a new VCS::PVCS::Project
object, this module's new() method is invoked automatically.

AUTHOR
======

   Bill Middleton, wjm@metronet.com

COPYRIGHT
=========

   The PVCS module is Copyright (c) 1998 Bill Middleton.  All rights
reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.

SUPPORT / WARRANTY
==================

   The VCS::PVCS modules are free software.

   *THEY COME WITHOUT WARRANTY OF ANY KIND.*

   Commercial support agreements for Perl can be arranged via The Perl
Clinic. See http://www.perl.co.uk/tpc for more details.

SEE ALSO
========

   perl(1), VCS::PVCS::Project


File: pm.info,  Node: VCS/PVCS/Archive,  Next: VCS/PVCS/Attributes,  Prev: VCS/PVCS,  Up: Module List

Archive class for for VCS::PVCS.
********************************

NAME
====

   VCS::PVCS::Archive - Archive class for for VCS::PVCS.

SYNOPSIS
========

     use VCS::PVCS::Project;

     $project = new VCS::PVCS::Project("ProjectName");

   # return ref to array of all folders in the project with SCRIPTS in the
name

     $folds = $project->openFolders("SCRIPTS");
     foreach $folder (@$folds){
     	@archives = $folder->Members(); # array of blessed Archive objects
     	foreach $archive(@archives){
     	    $archive->checkout;  # Checkout single archive to folder's WD
     	}
     }

DESCRIPTION
===========

   This class provides methods for use by Archive objects in the PVCS
model.

   Ordinarily, this class won't be included in your programs, as it is
part of the ISA for the master class VCS::PVCS::Project, which should
ordinarily be used, as shown above.

METHODS
=======

new
          VCS::PVCS::Archive::new(archivedir,
          	workdir,workfile,"checkin comment","workfile comment");

     Open an existing archive or create a new one.

workfile
          $workfile = $Archive->Workfile;

     Return the default workfile for this archive object.  Use opts to
     change default actions.

get
          $Archive->get([get opts]);

     Checkout the archive to the CWD.  Use opts to change default actions.

checkout
          Convenience routine calls get()

co
          Convenience routine calls get()

put
          $Archive->put([put opts]);

     Checkin the workfile in CWD to archive.  Use opts to change default
     actions.

checkin
          Convenience routine calls put()

ci
          Convenience routine calls put()

vdiff
          $Archive->vdiff([vdiff opts]);

     Takes a diff on the archive and workfile.  Use opts to change default
     actions.

vlog
          $Archive->vlog([vlog opts]);

     Takes a full vlog on the archive.  Use opts to change default actions.

log
          Convenience routine calls vlog()

history
          Convenience routine calls vlog()

lock
          $Archive->lock($label|$version,[vcs opts]);

     Locks the named revision (or rev spec'd by label).  Use opts to
     change default action.

unlock
          $Archive->unlock($label|$version,[vcs opts]);

     unlocks the named revision (or rev spec'd by label).  Use opts to
     change default action.

addVersionLabel
          $Archive->addVersionLabel($label,[vcs opts]);

     Create a new sticky version label for the archive (optionally with
     :<rev>.

deleteVersionLabel
          $Archive->deleteVersionLabel($label,[vcs opts]);

     Delete a version label from the archive.

replaceVersionLabel
          $Archive->replaceVersionLabel($newlabel,$oldlabel,[vcs opts]);

     Rename a version label in the archive

addFloatingVersionLabel
          $Archive->addFloatingVersionLabel($label,[vcs opts]);

     Create a floating version label for the archive.

transformVersionLabel
          $Archive->transformVersionLabel($label,[vcs opts])';

     Transform a specified version label to a floating version label.

deletePromoGroup
          $Archive->deletePromoGroup($group,[vcs opts]);

     Delete the promotion group from the archive.

addPromoGroup
          $Archive->deletePromoGroup($group:$rev,[vcs opts])';

     Add the archive, or promote it to, the named promotion group.

     Create a new archive

vcs
          $archive->vcs([opts][files]);

     Runs the VCS command against the archive, with opts as specified.

getAttributes
          $archive->getAttributes(@_);

     Populates and returns the archive object associated with the archive.
     This object is blessed into the VCS::PVCS::Attributes class.

attributes
          $archive->attributes;

     Returns the attributes object associated with the archive

COPYRIGHT
=========

   The PVCS module is Copyright (c) 1998 Bill Middleton.  All rights
reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.

AUTHOR
======

   Bill Middleton, wjm@metronet.com

SUPPORT / WARRANTY
==================

   The VCS::PVCS modules are free software.

   *THEY COME WITHOUT WARRANTY OF ANY KIND.*

   Commercial support agreements for Perl can be arranged via The Perl
Clinic. See http://www.perl.co.uk/tpc for more details.

SEE ALSO
========

   VCS::PVCS::Project


File: pm.info,  Node: VCS/PVCS/Attributes,  Next: VCS/PVCS/Commands,  Prev: VCS/PVCS/Archive,  Up: Module List

Attributes class for for VCS::PVCS
**********************************

NAME
====

   VCS::PVCS::Attributes - Attributes class for for VCS::PVCS

SYNOPSIS
========

     use VCS::PVCS::Project;

     $proj = new VCS::PVCS::Project("ProjectName");

     $members = $proj->members(".*");

     foreach $f (@$members){
       $attrs = $f->getAttributes();
       print $attrs->Archive; # Archive name
       print $attrs->Workfile; # Workfile name
       print $attrs->Owner; # Owner of archive
       print $attrs->Archive_created; # Date archive created
       print $attrs->Last_trunk_rev; # Most recent trunk rev
       print $attrs->Locks; # current locks on all versions
       print $attrs->Groups; # current groups assoc with this archive
       print $attrs->Rev_count; # number of revisions
       print $attrs->Attributes; # attributes
       print $attrs->Version_labels; # version labels on this archive
       print $attrs->Description;  # checkin description
       print $attrs->history;      # history and comments

     }

DESCRIPTION
===========

   This class is intended for use as an companion to the VCS::PVCS::*
classes.  The Archive objects inherits Attribute methods, and augment them.

METHODS
=======

getAttributes
          print $attrs->getAttributes(1);

     repopulate the attibutes object

Archive
          print $attrs->Archive; # Archive name

B<Workfile
          print $attrs->Workfile; # Workfile name

B<Owner
          print $attrs->Owner; # Owner of archive

B<Archive_created
          print $attrs->Archive_created; # Date archive created

B<Last_trunk_rev
          print $attrs->Last_trunk_rev; # Most recent trunk rev

B<Locks
          print $attrs->Locks; # current locks on all versions

B<Groups
          print $attrs->Groups; # current groups assoc with this archive

B<Rev_count
          print $attrs->Rev_count; # number of revisions

B<Attributes
          print $attrs->Attributes; # attributes

B<Version_labels
          print $attrs->Version_labels; # version labels on this archive

B<Description
          print $attrs->Description;  # checkin description

B<history
          print $attrs->history;      # history and comments

COPYRIGHT
=========

   The PVCS module is Copyright (c) 1998 Bill Middleton.  All rights
reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.

AUTHOR
======

   Bill Middleton, wjm@metronet.com

SUPPORT / WARRANTY
==================

   The VCS::PVCS modules are free software.

   *THEY COME WITHOUT WARRANTY OF ANY KIND.*

   Commercial support agreements for Perl can be arranged via The Perl
Clinic. See http://www.perl.co.uk/tpc for more details.

SEE ALSO
========

   VCS::PVCS::Project


File: pm.info,  Node: VCS/PVCS/Commands,  Next: VCS/PVCS/Folder,  Prev: VCS/PVCS/Attributes,  Up: Module List

Command class for for VCS::PVCS
*******************************

NAME
====

   VCS::PVCS::Commands - Command class for for VCS::PVCS

SYNOPSIS
========

     use VCS::PVCS::Project;

     $proj = new VCS::PVCS::Project("ProjectName");

   # Operate on every member in the project

     $proj->checkout("-V 1.7 -Y");
     $proj->checkin("-A foo,bar,baz -V 1.7");
     $proj->vlog("-BG foo");
     $proj->lock("mylabel");
     $proj->addFloatingVersionLabel("mylabel6");

   # OR

   # Operate on every archive in each folder

     $proj = new VCS::PVCS::Project("ProjectName");
     $folds = $proj->openFolders(".*");

     foreach $f (@$folds){
       $f->co("-Y -P -V 1.7");
       if(! $PVCSERR){
        $f->put("-A foo,bar,baz -V 1.7");
       }
       else{
         print $PVCSOUTPUT;
       }
       $f->put("-A foo,bar,baz -V 1.7");
       $f->history("-D 071363-091298");
       $f->unlock("1.7" );
       $f->addVersionLabel("mylabel2");
     }

   # OR

   # Operate on the projects archive objects separately

     $proj = new VCS::PVCS::Project("ProjectName");
     $members = $proj->members(".*");

     foreach $f (@$members){
       $f->co("-Y -P -V 1.7",$f->archive());

     if(! $PVCSERR){
       $f->put("-A foo,bar,baz -V 1.7 /path/to/archive.c_v");
     }
     else{
       print $PVCSOUTPUT;
     }
     $f->put("-A foo,bar,baz -V 1.7",$f->archive());
     $f->history("-D 071363-091298",$f->archive());
     $f->unlock("1.7" ,$f->archive());
     $f->addVersionLabel("mylabel2",$f->archive());
       }

   # OR

   # Operate on the folder's archive objects separately

     $folds = $proj->openFolders(".*");

     foreach $folder (@$folds){
       $members = $folder->members(".*");
       foreach $f (@$members){
         $f->co("-Y -P -V 1.7",$f->archive());
         if(! $PVCSERR){
           put("-A foo,bar,baz -V 1.7 /path/to/archive.c_v");
         }
         else{
           print $PVCSOUTPUT;
         }
         $f->co("-Y -P -V 1.7",$f->archive());
         $f->put("-A foo,bar,baz -V 1.7",$f->archive());
         $f->history("-D 071363-091298",$f->archive());
         $f->unlock("1.7" ,$f->archive());
         $f->addVersionLabel("mylabel2",$f->archive());
       }
     }

   # OR

   # Simple use of only this module

     use VCS::PVCS;   # You must still use the master module
     use VCS::PVCS::Commands qw(:all);

   # You MUST set these when using Commands by itself
$VCS::PVCS::PVCSMASTERCFG = "../../MASTER.CFG";
$VCS::PVCS::PVCSCURRPROJCFG = "../../examples.cfg";

   # Note the arguments may be all in one string, or separated by quotes

     checkout("-L","-V 1.7","-Y", "/path/to/archive.c_v");
     if(! $PVCSERR){
       put("-A foo,bar,baz -V 1.7 /path/to/archive.c_v");
     }
     else{
       print $PVCSOUTPUT;
     }

DESCRIPTION
===========

   Each time a command is run, the global values $PVCSERR and $PVCSOUTPUT
get set to errno and output respectively.

   This class can be used directly.  But it is intended for use as an ISA
for VCS::PVCS::* classes.  Folder, Project, and Archive objects inherit
Command methods, and augment them, to implement the appropriate actions on
each type of object.

   You *MUST *set the `$VCS::PVCS::PVCSMASTERCFG' and the
`$VCS::PVCS::PVCSCURRPROJCFG' to be the master configuration file, and the
project configuration file, respectively, when using this module by itself.

   If you wish to use this module directly, the Exporter makes most of the
symbols available when you `use VCS::PVCS'.  You should see the test cases
and the sample code above for more details.

METHODS
=======

get
          get([get opts] file(s));

checkout
     Convenience routine calls get();

co
     Convenience routine calls get();

put
          put([put opts] file(s));

     Checkin the named file.

checkin
     Convenience routine calls put();

ci
     Convenience routine calls put();

vdiff
          vdiff([vdiff opts]);

vlog
          vlog([vlog opts]);

log
     Convenience routine calls vlog();

history
     Convenience routine calls vlog();

lock
          lock([vcs opts] files)';

     Lock the named archive file(s).

unlock
          unlock([$label | $version],[vcs opts],file(s));

     Unlock the named files.

addVersionLabel
          addVersionLabel(label,[vcs opts],file(s));

     Add a version label to the named archive file(s).

deleteVersionLabel
          deleteVersionLabel(label,[vcs opts],file(s));

     Delete a version label to the named archive file(s).

replaceVersionLabel
          replaceVersionLabel($newlabel,$oldlabel,[vcs opts],files);

     Delete a version label to the named archive file(s).

transformVersionLabel
          transformVersionLabel(label,[vcs opts],file(s));

     Transform a version label to floating for the named archive file(s).

addFloatingVersionLabel
          addFloatingVersionLabel(label,[vcs opts],file(s));

     Create a floating version label for the named archive file(s).

deletePromoGroup
          deletePromoGroup($group,[vcs opts],file(s))';

     Delete the promotion group from the archive

addPromoGroup
          addPromoGroup(group:$rev,[vcs opts],files(s))';

     Add the promotion group to the archive (at rev)

createArchive
          createArchive([vcs opts],file(s))';

     Create a new archive in $file.

vcs
          vcs([opts][files])';

     Run vcs by itself.

AUTHOR
======

   Bill Middleton, wjm@metronet.com

COPYRIGHT
=========

   The PVCS module is Copyright (c) 1998 Bill Middleton.  All rights
reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.

SUPPORT / WARRANTY
==================

   The VCS::PVCS modules are free software.

   *THEY COME WITHOUT WARRANTY OF ANY KIND.*

   Commercial support agreements for Perl can be arranged via The Perl
Clinic. See http://www.perl.co.uk/tpc for more details.

SEE ALSO
========

   VCS::PVCS::Project


File: pm.info,  Node: VCS/PVCS/Folder,  Next: VCS/PVCS/Project,  Prev: VCS/PVCS/Commands,  Up: Module List

Folder class for for VCS::PVCS.
*******************************

NAME
====

   VCS::PVCS::Folder - Folder class for for VCS::PVCS.

SYNOPSIS
========

     use VCS::PVCS::Project;

     $project = new VCS::PVCS::Project("ProjectName");

   # return ref to array of all folders in the project with SCRIPTS in the
name

     $folds = $project->openFolders("SCRIPTS");
     foreach $folder (@$folds){
     	$folder->checkout;  # Checkout all files in the folder to the WD
     }

DESCRIPTION
===========

   This class implements a set of methods for operating on the
directories, archive files, and workfiles which correspond to PVCS
folders.  It should not ordinarily be loaded directly, but rather, is an
ISA to the VCS::PVCS::Project class, as shown above.

METHODS
=======

openFolders
          $folds = $project->openFolders("FOO"); # folders with FOO in the name
          @folds = $project->openFolders(".*");   # ALL folders in the project
          $folds = $project->openFolders("New Folder");  # create the folder

     Return a ref to array (or an array) of all folders in the project with
     FOO in the name.  If no match is found, the folder is created.  The
     objects in this array are blessed into the VCS::PVCS::Folder class.
     openFolders() accepts partial name matches in the single argument.
     (Names are matched with grep(//))

members
          @members = $folder->members("regexp");

     Return an array (or ref to array) of blessed Archive objects which
     reside within the folder, and match the regexp.  If no regexp is
     passed in, then return all of the archives in the project.  These
     objects can then call the methods in the VCS::PVCS::Archive class.

*newArchive *
          $Folder->newArchive($file,$archivedir);

     Create a new archive and place a copy into the folder.

getWD
          $WorkingDir =  $folder->getWD;

     Return the working directory for the folder.

getAttributes
          $Folder->getAttributes([vcs opts])';

     Populate the attributes object for each archive object member of the
     folder.

get
          $Folder->get([get opts]);

     Checkout all of the archive members in the folder to the the folders'
     working directory.  Use opts to change default actions.

checkout
          Convenience routine calls $folder->get()

co
          Convenience routine calls $folder->get()

put
          $Folder->put([put opts]);

     Checkin all of the archive members of the folder.  Use opts to change
     default actions.

checkin
          Convenience routine calls put()

ci
          Convenience routine calls put()

vlog
          $Folder->vlog([vlog opts]);

     Takes a full vlog on all of the archive members in the folder.  Use
     opts to change default actions.  Result in $PVCSOUTPUT.

log
          Convenience routine calls vlog()

history
          Convenience routine calls vlog()

lock
          $Folder->lock($label|$version,[vcs opts]);

     Locks the named revision (or rev spec'd by label) for all archive
     members in the folder.  Use opts to change default action.

unlock
          $Folder->unlock($label|$version,[vcs opts]);

     unlocks the named revision (or rev spec'd by label) for all archive
     members of the folder.  Use opts to change default action.

addVersionLabel
          $Folder->addVersionLabel($label,[vcs opts]);

     Create a new sticky version label for the all of the archive members
     of the folder (optionally with :<rev>).  Use opts for additonal
     params.

deleteVersionLabel
          $Folder->deleteVersionLabel($label,[vcs opts]);

     Delete a version label from all of the archive members of the folder.

replaceVersionLabel
          $Folder->replaceVersionLabel($newlabel,$oldlabel,[vcs opts]);

     Rename a version label in all of the archive members of the folder.

addFloatingVersionLabel
          $Folder->addFloatingVersionLabel($label,[vcs opts]);

     Create a floating version label for all of the archive members of the
     folder.

transformVersionLabel
          $Folder->transformVersionLabel($label,[vcs opts])';

     Transform a specified version label to a floating version label for
     all of  the archive members of the folder.

deletePromoGroup
          $Folder->deletePromoGroup($group,[vcs opts]);

     Delete the promotion group from the archive for all archive members
     in the folder.

addPromoGroup
          $Folder->deletePromoGroup($group:$rev,[vcs opts])';

     Add the archive, or promote it to, the named promotion group.  For
     all of the archive members in the folder.

     Create a new archive

vcs
          $Folder->vcs([opts][files]);

     Run vcs in the folder's CWD, with opts.

getAttributes
          $Folder->getAttributes(@_);

     Populates and returns the archive object associated with the archive
     for all archives in the folder.

     This object is blessed into the VCS::PVCS::Attributes class.

COPYRIGHT
=========

   The PVCS module is Copyright (c) 1998 Bill Middleton.  All rights
reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.

AUTHOR
======

   Bill Middleton, wjm@metronet.com

SUPPORT / WARRANTY
==================

   The VCS::PVCS modules are free software.

   *THEY COME WITHOUT WARRANTY OF ANY KIND.*

   Commercial support agreements for Perl can be arranged via The Perl
Clinic. See http://www.perl.co.uk/tpc for more details.

SEE ALSO
========

   VCS::PVCS::Project


File: pm.info,  Node: VCS/PVCS/Project,  Next: VCS/Version,  Prev: VCS/PVCS/Folder,  Up: Module List

Standard PVCS Project class for for VCS::PVCS
*********************************************

NAME
====

   VCS::PVCS::Project - Standard PVCS Project class for for VCS::PVCS

SYNOPSIS
========

     use VCS::PVCS::Project;
     $project = new VCS::PVCS::Project("Project Name");

     $folds = $project->openFolders("SCRIPTS");
     foreach $folder (@$folds){
           $folder->checkout;  # Checkout all files in the folder to the WD
     }

DESCRIPTION
===========

   Inherit from VCS::PVCS::* to get all necessary methods to parse master
config file, as well as the master pvcsproj.pub to learn about all
projects in the PVCSROOT.

   Provides methods to operate on an entire project's files all\ at once.
You can checkout, checkin, get history, or use the VCS command to perform
many different archive operations on all the files in the project.

METHODS
=======

new
          new VCS::PVCS::Project("NAME", {'WKDIR' => $wdir });

     Open an project in PVCS.  If the project doesn't exist, an attempt is
     made to create it.  If an VCS::PVCS object is not passed in, then the
     superclass routines from VCS::PVCS are called to parse ISLVINI,
     PVCSPROJ files, and store global information, relevant to all
     projects, from MASTER.CFG. Then open and parse project-specific files
     (pvcsfold.pub) to learn about all folders and documents within the
     project.

     Pass the hashref with WKDIR to specify a working directory for the
     entire project.  This method also creates the projects' control
     files, project.cfg, and control directory.

     Returns a project object.

members
          @members = $project->members("regexp");

     Return an array (or ref to array) of blessed Archive objects which
     match the regexp.  If no regexp is passed in, then return all of the
     archives in the project.  These objects can then call the methods in
     the VCS::PVCS::Archive class.

DESTROY
     When the Project object goes out of scope (e.g. when the program
     finishes), the destroyer checks the list of archive directories which
     have been added to the project, and saves a new config file if
     appropriate.

     *NOTE!  YOU SHOULD DISABLE THIS FEATURE IF YOU ARE USING CONDITIONAL
     CONFIGURATION OPTIONS IN THE PROJECT CONFIG FILES AROUND VCSDIR.
     THIS FEATURE MAY BE DISABLED BY TURNING ON $PVCSDONTSAVE in
     VCS::PVCS.pm.*

newArchive
          $project->newArchive()

     Create a new archive in the project. Normally, this method is called
     by $Folder->newArchive, but if you, for some reason, dont use PVCS
     folders, then you'll need to call this directly to create a new
     archive.

     =item *copyProject*

     Sorry, not copying projects in this release

deleteProject
     Sorry, not deleting projects in this release

lockProject
     Sorry, not locking projects in this release

get
          $Project->get([get opts]);

     Checkout all of the archive members in the project to the the
     project's working directory, or CWD if WD is not specified in
     pvcsproj.pub.  Use opts to change default actions.

checkout
          Convenience routine calls $Project->get()

co
          Convenience routine calls $Project->get()

put
          $Project->put([put opts]);

     Checkin all of the archive members of the project from the projects'
     WD or CWD.  Use opts to change default actions.

checkin
          Convenience routine calls put()

ci
          Convenience routine calls put()

vlog
          $Project->vlog([vlog opts]);

     Takes a full vlog on all of the archive members in the project.  Use
     opts to change default actions.  Result in $PVCSOUTPUT.

log
          Convenience routine calls vlog()

history
          Convenience routine calls vlog()

lock
          $Project->lock($label|$version,[vcs opts]);

     Locks the named revision (or rev spec'd by label) for all archive
     members in the project.  Use opts to change default action.

unlock
          $Project->unlock($label|$version,[vcs opts]);

     unlocks the named revision (or rev spec'd by label) for all archive
     members of the project.  Use opts to change default action.

addVersionLabel
          $Project->addVersionLabel($label,[vcs opts]);

     Create a new sticky version label for the all of the archive members
     of the project (optionally with :<rev>).  Use opts for additonal
     params.

deleteVersionLabel
          $Project->deleteVersionLabel($label,[vcs opts]);

     Delete a version label from all of the archive members of the project.

replaceVersionLabel
          $Project->replaceVersionLabel($newlabel,$oldlabel,[vcs opts]);

     Rename a version label in all of the archive members of the project.

addFloatingVersionLabel
          $Project->addFloatingVersionLabel($label,[vcs opts]);

     Create a floating version label for all of the archive members of the
     project.

transformVersionLabel
          $Project->transformVersionLabel($label,[vcs opts])';

     Transform a specified version label to a floating version label for
     all of  the archive members of the project.

deletePromoGroup
          $Project->deletePromoGroup($group,[vcs opts]);

     Delete the promotion group from the archive for all archive members
     in the project.

addPromoGroup
          $Project->deletePromoGroup($group:$rev,[vcs opts])';

     Add the archive, or promote it to, the named promotion group, for all
     of the archive members in the project.

     Create a new archive

vcs
          $Project->vcs([opts][files]);

     Run vcs in the project's WD, with opts.

getAttributes
          $Project->getAttributes(@_);

     Populates and returns the archive object associated with the archive
     for all archives in the project.

     This object is blessed into the VCS::PVCS::Attributes class.

AUTHOR
======

   Bill Middleton, wjm@metronet.com

COPYRIGHT
=========

   The PVCS module is Copyright (c) 1998 Bill Middleton.  All rights
reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.

SUPPORT / WARRANTY
==================

   The VCS::PVCS modules are free software.

   *THEY COME WITHOUT WARRANTY OF ANY KIND.*

   Commercial support agreements for Perl can be arranged via The Perl
Clinic. See http://www.perl.co.uk/tpc for more details.

SEE ALSO
========

   perl(1).


