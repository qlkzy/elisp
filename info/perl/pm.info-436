This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: XML/Parser/PerlSAX,  Next: XML/Parser/PyxParser,  Prev: XML/Parser/Expat,  Up: Module List

Perl SAX parser using XML::Parser
*********************************

NAME
====

   XML::Parser::PerlSAX - Perl SAX parser using XML::Parser

SYNOPSIS
========

     use XML::Parser::PerlSAX;

     $parser = XML::Parser::PerlSAX->new( [OPTIONS] );
     $result = $parser->parse( [OPTIONS] );

     $result = $parser->parse($string);

DESCRIPTION
===========

   `XML::Parser::PerlSAX' is a PerlSAX parser using the XML::Parser
module.  This man page summarizes the specific options, handlers, and
properties supported by `XML::Parser::PerlSAX'; please refer to the
PerlSAX standard in ``PerlSAX.pod'' for general usage information.

METHODS
=======

new
     Creates a new parser object.  Default options for parsing, described
     below, are passed as key-value pairs or as a single hash.  Options may
     be changed directly in the parser object unless stated otherwise.
     Options passed to `parse()' override the default options in the
     parser object for the duration of the parse.

parse
     Parses a document.  Options, described below, are passed as key-value
     pairs or as a single hash.  Options passed to `parse()' override
     default options in the parser object.

location
     Returns the location as a hash:

          ColumnNumber    The column number of the parse.
          LineNumber      The line number of the parse.
          BytePosition    The current byte position of the parse.
          PublicId        A string containing the public identifier, or undef
                          if none is available.
          SystemId        A string containing the system identifier, or undef
                          if none is available.
          Base            The current value of the base for resolving relative
                          URIs.

     ALPHA WARNING: The `SystemId' and `PublicId' properties returned are
     the system and public identifiers of the document passed to
     `parse()', not the identifiers of the currently parsing external
     entity.  The column, line, and byte positions *are* of the current
     entity being parsed.

OPTIONS
=======

   The following options are supported by `XML::Parser::PerlSAX':

     Handler          default handler to receive events
     DocumentHandler  handler to receive document events
     DTDHandler       handler to receive DTD events
     ErrorHandler     handler to receive error events
     EntityResolver   handler to resolve entities
     Locale           locale to provide localisation for errors
     Source           hash containing the input source for parsing
     UseAttributeOrder set to true to provide AttributeOrder and Defaulted
                       properties in `start_element()'

   If no handlers are provided then all events will be silently ignored,
except for ``fatal_error()'' which will cause a ``die()'' to be called
after calling ``end_document()''.

   If a single string argument is passed to the `parse()' method, it is
treated as if a `Source' option was given with a `String' parameter.

   The `Source' hash may contain the following parameters:

     ByteStream       The raw byte stream (file handle) containing the
                      document.
     String           A string containing the document.
     SystemId         The system identifier (URI) of the document.
     PublicId         The public identifier.
     Encoding         A string describing the character encoding.

   If more than one of `ByteStream', `String', or `SystemId', then
preference is given first to `ByteStream', then `String', then `SystemId'.

HANDLERS
========

   The following handlers and properties are supported by
`XML::Parser::PerlSAX':

DocumentHandler methods
-----------------------

start_document
     Receive notification of the beginning of a document.

     No properties defined.

end_document
     Receive notification of the end of a document.

     No properties defined.

start_element
     Receive notification of the beginning of an element.

          Name             The element type name.
          Attributes       A hash containing the attributes attached to the
                           element, if any.

     The `Attributes' hash contains only string values.

     If the ``UseAttributeOrder'' parser option is true, the following
     properties are also passed to `start_element':

          AttributeOrder   An array of attribute names in the order they were
                           specified, followed by the defaulted attribute
                           names.
          Defaulted        The index number of the first defaulted attribute in
                           `AttributeOrder.  If this index is equal to the
                           length of `AttributeOrder', there were no defaulted
                           values.

     Note to XML::Parser users:  ``Defaulted'' will be half the value of
     `XML::Parser::Expat''s ``specified_attr()'' function because only
     attribute names are provided, not their values.

end_element
     Receive notification of the end of an element.

          Name             The element type name.

characters
     Receive notification of character data.

          Data             The characters from the XML document.

processing_instruction
     Receive notification of a processing instruction.

          Target           The processing instruction target.
          Data             The processing instruction data, if any.

comment
     Receive notification of a comment.

          Data             The comment data, if any.

start_cdata
     Receive notification of the start of a CDATA section.

     No properties defined.

end_cdata
     Receive notification of the end of a CDATA section.

     No properties defined.

entity_reference
     Receive notification of an internal entity reference.  If this handler
     is defined, internal entities will not be expanded and not passed to
     the ``characters()'' handler.  If this handler is not defined,
     internal entities will be expanded if possible and passed to the
     ``characters()'' handler.

          Name             The entity reference name
          Value            The entity reference value

DTDHandler methods
------------------

notation_decl
     Receive notification of a notation declaration event.

          Name             The notation name.
          PublicId         The notation's public identifier, if any.
          SystemId         The notation's system identifier, if any.
          Base             The base for resolving a relative URI, if any.

unparsed_entity_decl
     Receive notification of an unparsed entity declaration event.

          Name             The unparsed entity's name.
          SystemId         The entity's system identifier.
          PublicId         The entity's public identifier, if any.
          Base             The base for resolving a relative URI, if any.

entity_decl
     Receive notification of an entity declaration event.

          Name             The entity name.
          Value            The entity value, if any.
          PublicId         The notation's public identifier, if any.
          SystemId         The notation's system identifier, if any.
          Notation         The notation declared for this entity, if any.

     For internal entities, the `Value' parameter will contain the value
     and the `PublicId', `SystemId', and `Notation' will be undefined.
     For external entities, the `Value' parameter will be undefined, the
     `SystemId' parameter will have the system id, the `PublicId'
     parameter will have the public id if it was provided (it will be
     undefined otherwise), the `Notation' parameter will contain the
     notation name for unparsed entities.  If this is a parameter entity
     declaration, then a '%' will be prefixed to the entity name.

     Note that ``entity_decl()'' and ``unparsed_entity_decl()'' overlap.
     If both methods are implemented by a handler, then this handler will
     not be called for unparsed entities.

element_decl
     Receive notification of an element declaration event.

          Name             The element type name.
          Model            The content model as a string.

attlist_decl
     Receive notification of an attribute list declaration event.

     This handler is called for each attribute in an ATTLIST declaration
     found in the internal subset. So an ATTLIST declaration that has
     multiple attributes will generate multiple calls to this handler.

          ElementName      The element type name.
          AttributeName    The attribute name.
          Type             The attribute type.
          Fixed            True if this is a fixed attribute.

     The default for `Type' is the default value, which will either be
     "#REQUIRED", "#IMPLIED" or a quoted string (i.e. the returned string
     will begin and end with a quote character).

doctype_decl
     Receive notification of a DOCTYPE declaration event.

          Name             The document type name.
          SystemId         The document's system identifier.
          PublicId         The document's public identifier, if any.
          Internal         The internal subset as a string, if any.

     Internal will contain all whitespace, comments, processing
     instructions, and declarations seen in the internal subset. The
     declarations will be there whether or not they have been processed by
     another handler (except for unparsed entities processed by the
     Unparsed handler).  However, comments and processing instructions will
     not appear if they've been processed by their respective handlers.

xml_decl
     Receive notification of an XML declaration event.

          Version          The version.
          Encoding         The encoding string, if any.
          Standalone       True, false, or undefined if not declared.

EntityResolver
--------------

resolve_entity
     Allow the handler to resolve external entities.

          Name             The notation name.
          SystemId         The notation's system identifier.
          PublicId         The notation's public identifier, if any.
          Base             The base for resolving a relative URI, if any.

     ``resolve_entity()'' should return undef to request that the parser
     open a regular URI connection to the system identifier or a hash
     describing the new input source.  This hash has the same properties as
     the `Source' parameter to `parse()':

          PublicId    The public identifier of the external entity being
                      referenced, or undef if none was supplied.
          SystemId    The system identifier of the external entity being
                      referenced.
          String      String containing XML text
          ByteStream  An open file handle.
          CharacterStream
                      An open file handle.
          Encoding    The character encoding, if known.

AUTHOR
======

   Ken MacLeod, ken@bitsko.slc.ut.us

SEE ALSO
========

   perl(1), PerlSAX.pod(3)

     Extensible Markup Language (XML) <http://www.w3c.org/XML/>
     SAX 1.0: The Simple API for XML <http://www.megginson.com/SAX/>


File: pm.info,  Node: XML/Parser/PyxParser,  Next: XML/PatAct/ActionTempl,  Prev: XML/Parser/PerlSAX,  Up: Module List

convert ESIS of Nsgmls or Pyxie to Perl SAX events.
***************************************************

NAME
====

   XML::Parser::PyxParser - convert ESIS of Nsgmls or Pyxie to Perl SAX
events.

SYNOPSIS
========

     use XML::Parser::PyxParser;
     use XML::Handler::Something;
     $writer = new XML::Handler::Something OPTIONS;
     $options = {
         OPTIONS,
         Handler  =>  $writer
     }
     $handler = new XML::Parser::PyxParser $options;
     $handler->parse;

DESCRIPTION
===========

   XML::Parser::PyxParser converts ESIS of Nsgmls or Pyxie to Perl SAX
events.   Behaviour of object is specified when the object is created  or
in method "parse".  This module as compatible as possible with
XML::Parser::PerlSAX module.

METHODS
=======

new
     Creates a new parser object. Options are passed by hash. Passed
     options overrides default options.

parse
     Parses a document. Passed options overrides options passed to method
     "new".

location
     Will not be implemented.

OPTIONS
=======

   The following options are not supported by XML::Parser::PyxParser:

   * DTDHandler

   * ErrorHandler

   * EntityResolver

   * Locale

   * UseAttributeOrder

   The following options are supported by XML::Parser::PyxParser:

Handler
     Default handler to receive events.

DocumentHandler
     Handler to receive document events.  You can use as "DocumentHandler"
     as "Handler". No difference. If no handlers are provided then object
     silently will not parse.

Source
     Hash containing the input source for parsing. See description below.

AttrBeforeElement
     Attributes are before element (1) or after  element (0). Default is 1
     (before).

CompactAttrString
     Attribute type is absent (1) or present (0). Default is 0 (present).

SkipBadTags
     Skip (1) or do not (0) skip ESIS strings with  unknown prefix.
     Default is 1 (skip).

CheckNesting
     Check (1) or do not check (0) nesting of elements. Default is 1
     (check).

ChompPI
     Cut (1) or do not cut (0) symbol '?' from the end of  processing
     instruction. Default is 1 (cut).

   XML::Parser::PyxParser does not support these options of hash "Source":

   * String

   * PublicId

   * Encoding

   Options of hash "Source":

ByteStream
     Output stream object with method "print" (for example, IO::File).

SystemId
     Name of file passed to method "open" of IO::File.  If "ByteStream" is
     defined then "SystemId" is ignored.  Default value of "SystemId" is
     "-".

RECOMMENDED VALUES
==================

   Probably you like to be compatible with Nsgmls or Pyxie. The main
difference is that Nsgmls has attributes before element and attribute
types. Pyxie has attributes after element and does not have attribute
types. By default XML::Parser::PyxParser uses Nsgmls mode.

   Recommended values for Nsgmls mode:

   * AttrBeforeElement = 1

   * CompactAttrString = 0

   * CheckNesting = 1

   * SkipBadTags = 1

   * ChompPI = 1

   Recommended values for Pyxie mode:

   * AttrBeforeElement = 0

   * CompactAttrString = 1

   * CheckNesting = 1

   * SkipBadTags = 0

   * ChompPI = 0

INPUT STREAM
============

   XML::Parser::PyxParser understand this escape sequences:

\\
     A \.

\n
     A record end character.

\nnn
     The character whose code is "nnn" octal.

\#n;
     The character whose number is "n" decimal. "n" can have any number of
     digits. But are you sure that Perl character can be greater than 255?

NOTATION
========

   Notation is a series of lines. Each line consist of an initial command
characters and arguments. The possible command	characters and
arguments are as follows:

(gi
     The start of an element whose generic identifier is "gi". Attributes
     of element are specified before or after element depending on value
     of option "AttrBeforeElement".

)gi
     The end of an element whose generic  identifier is "gi".

-data
     Data.

?pi
     A processing instruction with data "pi". By default "pi" of ESIS of
     Nsgmls on my box have symbol '?' at the end. In XML mode I do not
     have this symbol. Parser does not know origin of ESIS stream. So he
     silently cut last '?' symbol (if allowed).

Aname value
     Attribute definition if "CompactAttrString" option is set.

Aname type value
     Attribute definition if "CompactAttrString" option is not set.

     Word "type" is any word without spaces. This word  is ignored.

AUTHOR
======

   Oleg A. Paraschenko, prof@beta.math.spbu.ru

SEE ALSO
========

   XML::Handler::PyxWriter

   Home Page, http://beta.math.spbu.ru/~prof/xc/

   Nsgmls

   Pyxie, http://www.pyxie.org/

   PerlSAX

   XML::PYX

   XML::ESISParser

   SGMLS


File: pm.info,  Node: XML/PatAct/ActionTempl,  Next: XML/PatAct/Amsterdam,  Prev: XML/Parser/PyxParser,  Up: Module List

An action module for
********************

NAME
====

   XML::PatAct::ACTION - An action module for

SYNOPSIS
========

     use XML::PatAct::ACTION;

     my $patterns = [ PATTERN => ACTION,
     		  ... ];

     my $matcher = XML::PatAct::ACTION->new(Patterns => $patterns,
     					Matcher => $matcher );

DESCRIPTION
===========

   XML::PatAct::ACTION is a PerlSAX handler for applying pattern-action
lists to XML parses or trees.  XML::PatAct::ACTION ...

   New XML::PatAct::ACTION instances are creating by calling `new()'.  A
Parameters can be passed as a list of key, value pairs or a hash.
Patterns and Matcher options are required.  Patterns is the pattern-action
list to apply.  Matcher is an instance of the pattern or query matching
module.

   DESCRIBE THE FORMAT OF YOUR ACTIONS HERE

AUTHOR
======

   This template file was written by Ken MacLeod, ken@bitsko.slc.ut.us

SEE ALSO
========

   perl(1)

   "Using PatAct Modules" and "Creating PatAct Modules" in libxml-perl.


File: pm.info,  Node: XML/PatAct/Amsterdam,  Next: XML/PatAct/MatchName,  Prev: XML/PatAct/ActionTempl,  Up: Module List

An action module for simplistic style-sheets
********************************************

NAME
====

   XML::PatAct::Amsterdam - An action module for simplistic style-sheets

SYNOPSIS
========

     use XML::PatAct::Amsterdam;

     my $patterns = [ PATTERN => { Before => 'before',
     			       After => 'after' },
     		  ... ];

     my $matcher = XML::PatAct::Amsterdam->new( I<OPTIONS> );

DESCRIPTION
===========

   XML::PatAct::Amsterdam is a PerlSAX handler for applying pattern-action
lists to XML parses or trees.  XML::PatAct::Amsterdam applies a very
simple style sheet to an instance and outputs the result.  Amsterdam gets
it's name from the Amsterdam SGML Parser (ASP) which inspired this module.

   CAUTION: Amsterdam is a very simple style module, you will run into
it's limitations quickly with even moderately complex XML instances, be
aware of and prepared to switch to more complete style modules.

   New XML::PatAct::Amsterdam instances are creating by calling `new()'.
Parameters can be passed as a list of key, value pairs or a hash.  A
Patterns and Matcher options are required.  The following OPTIONS are
supported:

Patterns
     The pattern-action list to apply.  The list is an anonymous array of
     pattern, action pairs.  Each action in the list contains either or
     both a Before and an After string to copy to the output before and
     after processing an XML element.  The Before and After strings may
     contain attribute names enclosed in square brackets (`[' NAME `]'),
     these are replaced with the value of the attribute with that name.
     The special NAME ``_element'' will be replaced with the element's
     name.

Matcher
     An instance of the pattern or query matching module.

Output
     An IO::Handle or one of it's subclasses (such as IO::File), if this
     parameter is not present and the AsString option is not used, the
     module will write to standard output.

AsString
     Return the generated output as a string from the `parse()' method of
     the PerlSAX event generator.

AUTHOR
======

   Ken MacLeod, ken@bitsko.slc.ut.us

SEE ALSO
========

   perl(1)

   "Using PatAct Modules" and "Creating PatAct Modules" in libxml-perl.


File: pm.info,  Node: XML/PatAct/MatchName,  Next: XML/PatAct/PatternTempl,  Prev: XML/PatAct/Amsterdam,  Up: Module List

A pattern module for matching element names
*******************************************

NAME
====

   XML::PatAct::MatchName - A pattern module for matching element names

SYNOPSIS
========

     use XML::PatAct::MatchName;

     my $matcher = XML::PatAct::MatchName->new();

     my $patterns = [ 'foo' => ACTION,
     		  'bar/foo' => ACTION,
     		  ... ];

DESCRIPTION
===========

   XML::PatAct::MatchName is a pattern module for use with PatAct drivers
for applying pattern-action lists to XML parses or trees.
XML::PatAct::MatchName is a simple pattern module that uses just element
names to match on.  If multiple names are supplied seperated by `/'
characters, then all of the parent element names must match as well.

   The order of patterns in the list is not significant.
XML::PatAct::MatchName will use the most specific match.  Using the
synopsis above as an example, if you have an element `foo', ``bar/foo''
will match if `foo' is in an element `bar', otherwise just the pattern
with `foo' will match.

AUTHOR
======

   Ken MacLeod, ken@bitsko.slc.ut.us

SEE ALSO
========

   perl(1)

   "Using PatAct Modules" and "Creating PatAct Modules" in libxml-perl.


File: pm.info,  Node: XML/PatAct/PatternTempl,  Next: XML/PatAct/ToObjects,  Prev: XML/PatAct/MatchName,  Up: Module List

A pattern module for
********************

NAME
====

   XML::PatAct::PATTERN - A pattern module for

SYNOPSIS
========

     use XML::PatAct::PATTERN;

     my $patterns = [ PATTERN => ACTION,
                      ... ]

     my $matcher = XML::PatAct::PATTERN->new( Patterns => $patterns );

DESCRIPTION
===========

   XML::PatAct::PATTERN is a pattern module for use with PatAct action
modules for applying pattern-action lists to XML parses or trees.
XML::PatAct::PATTERN ...

   Parameters can be passed as a list of key, value pairs or a hash.

   DESCRIBE THE FORMAT OR LANGUAGE OF YOUR PATTERNS HERE

AUTHOR
======

   This template file was written by Ken MacLeod, ken@bitsko.slc.ut.us

SEE ALSO
========

   perl(1)

   "Using PatAct Modules" and "Creating PatAct Modules" in libxml-perl.


File: pm.info,  Node: XML/PatAct/ToObjects,  Next: XML/Perl2SAX,  Prev: XML/PatAct/PatternTempl,  Up: Module List

An action module for creating Perl objects
******************************************

NAME
====

   XML::PatAct::ToObjects - An action module for creating Perl objects

SYNOPSIS
========

     use XML::PatAct::ToObjects;

     my $patterns = [ PATTERN => [ OPTIONS ],
     		  PATTERN => "PERL-CODE",
     		  ... ];

     my $matcher = XML::PatAct::ToObjects->new( Patterns => $patterns,
     					    Matcher => $matcher,
     					    CopyId => 1,
     					    CopyAttributes => 1 );

DESCRIPTION
===========

   XML::PatAct::ToObjects is a PerlSAX handler for applying pattern-action
lists to XML parses or trees.  XML::PatAct::ToObjects creates Perl objects
of the types and contents of the action items you define.

   New XML::PatAct::ToObject instances are creating by calling `new()'.
Parameters can be passed as a list of key, value pairs or a hash.  `new()'
requires the Patterns and Matcher parameters, the rest are optional:

Patterns
     The pattern-action list to apply.

Matcher
     An instance of the pattern or query matching module.

CopyId
     Causes the `ID' attribute, if any, in a source XML element to be
     copied to an `ID' attribute in newly created objects.  Note that IDs
     may be lost of no pattern matches that element or an object is not
     created (`-make') for that element.

CopyAttributes
     Causes all attributes of the element to be copied to the newly created
     objects.

   Each action can either be a list of options defined below or a string
containing a fragment of Perl code.  If the action is a string of Perl
code then simple then some simple substitutions are made as described
further below.

   Options that can be used in an action item containing an option-list:

*-holder*
     Ignore this element, but continue processing it's children (compare to
     *-ignore*).  `-pcdata' may be used with this option.

*-ignore*
     Ignore (discard) this element and it's children (compare to
     *-holder*).

*-pcdata*
     Character data in this element should be copied to the Contents field.

*-make* PACKAGE
     Create an object blessed into PACKAGE, and continue processing this
     element and it's children.  PACKAGE may be the type `HASH' to simply
     create an anonyous hash.

*-args* ARGUMENTS
     Use ARGUMENTS in creating the object specified by *-make*.  This is
     commonly used to copy element attributes into fields in the newly
     created object.  For example:

          -make => 'HASH', -args => 'URL => %{href}'

     would copy the `href' attribute in an element to the `URL' field of
     the newly created hash.

*-field* *FIELD*
     Store this element, object, or children of this element in the parent
     object's field named by *FIELD*.

*-push-field* *FIELD*
     Similar to *-field*, except that *FIELD* is an array and the contents
     are pushed onto that array.

*-value* VALUE
     Use VALUE as a literal value to store in *FIELD*, otherwise ignoring
     this element and it's children.  Only valid with *-field* or
     *-push-field*.  ``%{*ATTRIBUTE*}'' notation can be used to substitute
     the value of an attribute into the literal value.

*-as-string*
     Convert the contents of this element to a string (as in
     `XML::Grove::AsString') and store in *FIELD*.  Only valid with
     *-field* or *-push-field*.

*-grove*
     Copy this element to *FIELD* without further processing.  The element
     can then be processed later as the Perl objects are manipulated.  Only
     valid with *-field* or *-push-field*.  If ToObjects is used with
     PerlSAX, this will use XML::Grove::Builder to build the grove element.

*-grove-contents*
     Used with *-make*, *-grove-contents* creates an object but then takes
     all of the content of that element and stores it in Contents.

   If an action item is a string, that string is treated as a fragment of
Perl code.  The following simple substitutions are performed on the
fragment to provide easy access to the information being converted:

*@ELEM@*
     The object that caused this action to be called.  If ToObjects is used
     with PerlSAX this will be a hash with the element name and attributes,
     with XML::Grove this will be the element object, with Data::Grove it
     will be the matching object, and with XML::DOM it will be an
     XML::DOM::Element.

EXAMPLE
=======

   The example pattern-action list below will convert the following XML
representing a Database schema:

     <schema>
       <table>
         <name>MyTable</name>
         <summary>A short summary</summary>
         <description>A long description that may
           contain a subset of HTML</description>
         <column>
           <name>MyColumn1</name>
           <summary>A short summary</summary>
           <description>A long description</description>
           <unique/>
           <non-null/>
           <default>42</default>
         </column>
       </table>
     </schema>

   into Perl objects looking like:

     [
       { Name => "MyTable",
         Summary => "A short summary",
         Description => $grove_object,
         Columns => [
           { Name => "MyColumn1",
             Summary => "A short summary",
             Description => $grove_object,
             Unique => 1,
             NonNull => 1,
             Default => 42
           }
         ]
       }
     ]

   Here is a Perl script and pattern-action list that will perform the
conversion using the simple name matching pattern module
XML::PatAct::MatchName.  The script accepts a Schema XML file as an
argument (`$ARGV[0]') to the script.  This script creates a grove as one
of it's objects, so it requires the XML::Grove module.

     use XML::Parser::PerlSAX;
     use XML::PatAct::MatchName;
     use XML::PatAct::ToObjects;

     my $patterns = [
       'schema'      => [ qw{ -holder                                  } ],
       'table'       => [ qw{ -make Schema::Table                      } ],
       'name'        => [ qw{ -field Name -as-string                   } ],
       'summary'     => [ qw{ -field Summary -as-string                } ],
       'description' => [ qw{ -field Description -grove                } ],
       'column'      => [ qw{ -make Schema::Column -push-field Columns } ],
       'unique'      => [ qw{ -field Unique -value 1                   } ],
       'non-null'    => [ qw{ -field NonNull -value 1                  } ],
       'default'     => [ qw{ -field Default -as-string                } ],
     ];

     my $matcher = XML::PatAct::MatchName->new( Patterns => $patterns );
     my $handler = XML::PatAct::ToObjects->new( Patterns => $patterns,
                                                Matcher => $matcher);

     my $parser = XML::Parser::PerlSAX->new( Handler => $handler );
     my $schema = $parser->parse(Source => { SystemId => $ARGV[0] } );

TODO
====

   * It'd be nice if patterns could be applied even in *-as-string* and
     *-grove*.

   * Implement Perl code actions.

   * *-as-xml* to write XML into the field.

AUTHOR
======

   Ken MacLeod, ken@bitsko.slc.ut.us

SEE ALSO
========

   perl(1), Data::Grove(3)

   "Using PatAct Modules" and "Creating PatAct Modules" in libxml-perl.


File: pm.info,  Node: XML/Perl2SAX,  Next: XML/QL,  Prev: XML/PatAct/ToObjects,  Up: Module List

translate Perl SAX methods to Java/CORBA style methods
******************************************************

NAME
====

   XML::SAX2Perl - translate Perl SAX methods to Java/CORBA style methods

SYNOPSIS
========

     use XML::Perl2SAX;

     $perl2sax = XML::Perl2SAX(handler => $java_style_handler);

DESCRIPTION
===========

   `XML::Perl2SAX' is a SAX filter that translates Perl style SAX methods
to Java/CORBA style method calls.  This module performs the inverse
operation from `XML::SAX2Perl'.

   `Perl2SAX' is a Perl SAX document handler.  The `new' method takes a
`handler' argument that is a Java/CORBA style handler that the new
Perl2SAX instance will call.  The SAX interfaces are defined at
<http://www.megginson.com/SAX/>.

AUTHOR
======

   Ken MacLeod <ken@bitsko.slc.ut.us>

SEE ALSO
========

   perl(1), XML::Perl2SAX(3).

     Extensible Markup Language (XML) <http://www.w3c.org/XML/>
     Simple API for XML (SAX) <http://www.megginson.com/SAX/>


File: pm.info,  Node: XML/QL,  Next: XML/RSS,  Prev: XML/Perl2SAX,  Up: Module List

An XML query language
*********************

NAME
====

   XML::QL - An XML query language

VERSION
=======

   0.07

SYNOPSIS
========

   $ql = 'WHERE          <head>$head</head>        ORDER-BY          $head
      IN          "file:REC-xml-19980210.xml"        CONSTRUCT
$head';

   print XML::QL->query($sql);

DESCRIPTION
===========

   This module is an early implementation of a note published by the W3C
called "XML-QL: A Query Language for XML". XML-QL allows the user to query
an XML document much like a database, and describe a construct for output.
Currently this module only offers partial functionality as described in
the specification, and even some of that has been changed for ease of use.
This documentation will describe the fuctionality of this module as well
as differences from the XML-QL specification.

METHODS
=======

query( "query" )
     This is the only method required to use this module. This one method
     allows the user to pass a valid XML-QL query to the module, and the
     return value is the output.

XML-QL: The Query Language
==========================

   The basic syntax consists of two parts, a WHERE clause to describe the
data to search for, and a CONSTRUCT clause to describe how to return the
data that is found.

WHERE
     WHERE XML-searchstring [ORDER-BY variable [DESCENDING] [, variable
     [DESCENDING]] ] IN 'filename'

     The WHERE clause can be separated into several parts. The first is
     the search string, the second is an optional ORDER-BY clause much
     like ORDER BY in SQL, and last is the required XML document file
     name. Each of these parts is described below.

    XML-searchstring
          The search string MUST be a valid XML snippet. This is one are
          where this module differs from the specification. It has been
          implemented in this way so that the search string may be parsed
          by the XML::Parser module.

          The first step in building a query is to list the tags to search
          for in the document.  For example, consider the following search
          string:

               <BOOK>
               	<AUTHOR></AUTHOR>
               </BOOK>

          This search string will search for the AUTHOR tag nested within
          a BOOK tag. Note however that no information has been selected
          for retrieval. In the following example, we actually grab some
          information:

               <BOOK>
               	<AUTHOR>$author</AUTHOR>
               </BOOK>

          The variable name $author will grab the information that it
          finds withing this tag, and makes this information avalable to
          us for use in the CONSTRUCT section of the query. You will
          notice that variable names start with a dollar sign ($), as this
          is called for by the specification.  In Perl, this means that if
          the query is enclosed in double quotes, this dollar sign must be
          escaped.

          In the following example we take it a step further by searching
          for books of that are non-fiction:

               <BOOK TYPE='non-fiction'>
               	<AUTHOR>$author</AUTHOR>
               </BOOK>

          We can also express this as a regular expression:

               <BOOK TYPE='non-.*'>
               	<AUTHOR>$author</AUTHOR>
               </BOOK>

          This is another area where this module differs from the
          specification. The regular expesssion ability as defined in the
          specification only allows for a subset of the ability available
          in a Perl regular expression. With this module, the full range
          of regular expression syntax has been made available. This also
          means that you must also escape things such as periods(.),
          parenthesis (), and brackets ([]). All non tag matched are case
          insensitive.

          Now lets say that besides matching the TYPE, we also wanted to
          grab the value.  Consider this example:

               <BOOK TYPE='non-.* AS_ELEMENT $type'>
               	<AUTHOR>$author</AUTHOR>
               </BOOK>

          The AS_ELEMENT keyword allows you to save the matched value for
          later use in the CONSTRUCT portion of the query.

    ORDER-BY
          The ORDER-BY clause allows to sort the data retrieved in the
          variables. You may specify multiple variables, and specify
          DESCENDING for a reverse sort. This clause is not required. For
          example:

          ORDER-BY $type, $author DESCENDING

    IN
          The IN clause is a required clause that specifies the file name
          of the XML file.  This can be any URI that is supported by LWP,
          or it can be a single file name enclosed in quotes. In later
          versions of this module there will be support for multiple
          files, directories. The following will work:

          IN 'REC-xml-19980210.xml'

          IN 'file://othermachine/share/filename.xml'

          IN 'http://www.example.com/file.xml'

CONSTRUCT
     The CONSTRUCT construct allows you to specify a template for output.
     The template will match character for character from the first space
     after the word CONSTRUCT to the end of the XML-QL query. For example:

     $ql = '(where clause...)         CONSTRUCT 	Type: $type
     Author: $author';

     The ouput of this will then be a carriage return, a tab, "Type: ",
     the contents of $type, a carriage return, a tab, "Author: ", and the
     contents of $author. This construct will be repeated for every match
     found and returned as a single string.

AUTHOR
======

   Robert Hanson - Initial Version rhanson@blast.net

   Matt Sergeant - Only minor fixes so far msergeant@ndirect.co.uk,
sergeant@geocities.com

COPYRIGHT
=========

   Robert's Original licence *was*: I hereby reserve NO rights to this
module, except for maybe a little recognition if you decide to rewrite it
and redistribute as your own.  Beyond that, you can do whatever you want
with this. I would just appreciate a copy of any improvements to this
module.

   However that only stands for version 0.01 of the module. All versions
above that are released under the same terms as perl itself.


File: pm.info,  Node: XML/RSS,  Next: XML/Records,  Prev: XML/QL,  Up: Module List

creates and updates RSS files
*****************************

NAME
====

   XML::RSS - creates and updates RSS files

SYNOPSIS
========

     # create an RSS 1.0 file (http://purl.org/rss/1.0/)
     use XML::RSS;
     my $rss = new XML::RSS (version => '1.0');
     $rss->channel(
       title        => "freshmeat.net",
       link         => "http://freshmeat.net",
       description  => "the one-stop-shop for all your Linux software needs",
       dc => {
         date       => '2000-08-23T07:00+00:00',
         subject    => "Linux Software",
         creator    => 'scoop@freshmeat.net',
         publisher  => 'scoop@freshmeat.net',
         rights     => 'Copyright 1999, Freshmeat.net',
         language   => 'en-us',
       },
       syn => {
         updatePeriod     => "hourly",
         updateFrequency  => "1",
         updateBase       => "1901-01-01T00:00+00:00",
       },
     );

     $rss->image(
       title  => "freshmeat.net",
       url    => "http://freshmeat.net/images/fm.mini.jpg",
       link   => "http://freshmeat.net",
       dc => {
         creator  => "G. Raphics (graphics at freshmeat.net)",
       },
     );
     
     $rss->add_item(
       title       => "GTKeyboard 0.85",
       link        => "http://freshmeat.net/news/1999/06/21/930003829.html",
       description => "GTKeyboard is a graphical keyboard that ...",
       dc => {
         subject  => "X11/Utilities",
         creator  => "David Allen (s2mdalle at titan.vcu.edu)",
       },
     );

     $rss->textinput(
       title        => "quick finder",
       description  => "Use the text input below to search freshmeat",
       name         => "query",
       link         => "http://core.freshmeat.net/search.php3",
     );

     # Optionally mixing in elements of a non-standard module/namespace

     $rss->add_module(prefix=>'my', uri=>'http://purl.org/my/rss/module/');

     $rss->add_item(
       title       => "xIrc 2.4pre2"
       link        => "http://freshmeat.net/projects/xirc/",
       description => "xIrc is an X11-based IRC client which ...",
       my => {
         rating    => "A+",
         category  => "X11/IRC",
       },
     );

     $rss->add_item (title=>$title, link=>$link, slash=>{ topic=>$topic });

     # create an RSS 0.91 file
     use XML::RSS;
     my $rss = new XML::RSS (version => '0.91');
     $rss->channel(title          => 'freshmeat.net',
                   link           => 'http://freshmeat.net',
                   language       => 'en',
                   description    => 'the one-stop-shop for all your Linux software needs',
                   rating         => '(PICS-1.1 "http://www.classify.org/safesurf/" 1 r (SS~~000 1))',
                   copyright      => 'Copyright 1999, Freshmeat.net',
                   pubDate        => 'Thu, 23 Aug 1999 07:00:00 GMT',
                   lastBuildDate  => 'Thu, 23 Aug 1999 16:20:26 GMT',
                   docs           => 'http://www.blahblah.org/fm.cdf',
                   managingEditor => 'scoop@freshmeat.net',
                   webMaster      => 'scoop@freshmeat.net'
                   );

     $rss->image(title       => 'freshmeat.net',
                 url         => 'http://freshmeat.net/images/fm.mini.jpg',
                 link        => 'http://freshmeat.net',
                 width       => 88,
                 height      => 31,
                 description => 'This is the Freshmeat image stupid'
                 );

     $rss->add_item(title => "GTKeyboard 0.85",
                    link  => "http://freshmeat.net/news/1999/06/21/930003829.html",
     		description => 'blah blah'
                    );

     $rss->skipHours(hour => 2);
     $rss->skipDays(day => 1);

     $rss->textinput(title => "quick finder",
                     description => "Use the text input below to search freshmeat",
                     name  => "query",
                     link  => "http://core.freshmeat.net/search.php3"
                     );

     # create an RSS 0.9 file
     use XML::RSS;
     my $rss = new XML::RSS (version => '0.9');
     $rss->channel(title => "freshmeat.net",
                   link  => "http://freshmeat.net",
                   description => "the one-stop-shop for all your Linux software needs",
                   );

     $rss->image(title => "freshmeat.net",
                 url   => "http://freshmeat.net/images/fm.mini.jpg",
                 link  => "http://freshmeat.net"
                 );

     $rss->add_item(title => "GTKeyboard 0.85",
                    link  => "http://freshmeat.net/news/1999/06/21/930003829.html"
                    );

     $rss->textinput(title => "quick finder",
                     description => "Use the text input below to search freshmeat",
                     name  => "query",
                     link  => "http://core.freshmeat.net/search.php3"
                     );

     # print the RSS as a string
     print $rss->as_string;

     # or save it to a file
     $rss->save("fm.rdf");

     # insert an item into an RSS file and removes the oldest item if
     # there are already 15 items
     my $rss = new XML::RSS;
     $rss->parsefile("fm.rdf");
     pop(@{$rss->{'items'}}) if (@{$rss->{'items'}} == 15);
     $rss->add_item(title => "MpegTV Player (mtv) 1.0.9.7",
                    link  => "http://freshmeat.net/news/1999/06/21/930003958.html",
                    mode  => 'insert'
                    );

     # parse a string instead of a file
     $rss->parse($string);

     # print the title and link of each RSS item
     foreach my $item (@{$rss->{'items'}}) {
         print "title: $item->{'title'}\n";
         print "link: $item->{'link'}\n\n";
     }

     # output the RSS 0.9 or 0.91 file as RSS 1.0
     $rss->{output} = '1.0';
     print $rss->as_string;

DESCRIPTION
===========

   This module provides a basic framework for creating and maintaining RDF
Site Summary (RSS) files. This distribution also contains many examples
that allow you to generate HTML from an RSS, convert between 0.9, 0.91,
and 1.0 version, and other nifty things.  This might be helpful if you
want to include news feeds on your Web site from sources like Slashot and
Freshmeat or if you want to syndicate your own content.

   XML::RSS currently supports 0.9, 0.91, and 1.0 versions of RSS.  See
http://my.netscape.com/publish/help/mnn20/quickstart.html for information
on RSS 0.91. See http://my.netscape.com/publish/help/ for RSS 0.9. See
http://purl.org/rss/1.0/ for RSS 1.0.

   RSS was originally developed by Netscape as the format for Netscape
Netcenter channels, however, many Web sites have since adopted it as a
simple syndication format. With the advent of RSS 1.0, users are now able
to syndication many different kinds of content including news headlines,
threaded measages, products catalogs, etc.

METHODS
=======

new XML::RSS (version=>$version, encoding=>$encoding, output=>$output)
     Constructor for XML::RSS. It returns a reference to an XML::RSS
     object.  You may also pass the RSS version and the XML encoding to
     use. The default version is 1.0. The default encoding is UTF-8. You
     may also specify the output format regarless of the input version.
     This comes in handy when you want to convert RSS between versions.
     The XML::RSS modules will convert between any of the formats.

add_item (title=>$title, link=>$link, description=>$desc, mode=>$mode)
     Adds an item to the XML::RSS object. mode and description are
     optional.  The default mode is append, which adds the item to the end
     of the list. To insert an item, set the mode to insert.

     The items are stored in the array @{$obj->{'items'}} where $obj is a
     reference to an XML::RSS object.

as_string;
     Returns a string containing the RSS for the XML::RSS object.

channel (title=>$title, link=>$link, description=>$desc, language=>$language, rating=>$rating, copyright=>$copyright, pubDate=>$pubDate, lastBuildDate=>$lastBuild, docs=>$docs, managingEditor=>$editor, webMaster=>$webMaster)
     Channel information is required in RSS. The title cannot be more the
     40 characters, the link 500, and the description 500 when outputting
     RSS 0.9. title, link, and description, are required for RSS 1.0.
     language is required for RSS 0.91.  The other parameters are optional
     for RSS 0.91 and 1.0.

     To retreive the values of the channel, pass the name of the value
     (title, link, or description) as the first and only argument like so:

     $title = channel('title');

image (title=>$title, url=>$url, link=>$link, width=>$width, height=>$height, description=>$desc)
     Adding an image is not required. url is the URL of the image, link is
     the URL the image is linked to. title, url, and link parameters are
     required if you are going to use an image in your RSS file. The
     remaining image elements are used in RSS 0.91 or optionally imported
     into RSS 1.0 via the rss091 namespace.

     The method for retrieving the values for the image is the same as it
     is for *channel()*.

parse ($string)
     Parses an RDF Site Summary which is passed into parse() as the first
     parameter.

parsefile ($file)
     Same as parse() except it parses a file rather than a string.

save ($file)
     Saves the RSS to a specified file.

skipHours (hour=>$hour)
     Specifies the number of hours that a server should wait before
     retrieving the RSS file. The *hour* parameter is required if the
     skipHours method is used. This method is currently broken.

skipDays (day=>$day)
     Specified the number of days that a server should wait before
     retrieving the RSS file. The day parameter is required if the
     skipDays method is used. This method is currently broken.

strict ($boolean)
     If it's set to 1, it will adhere to the lengths as specified by
     Netscape Netcenter requirements. It's set to 0 by default.  Use it if
     the RSS file you're generating is for Netcenter.  strict will only
     work for RSS 0.9 and 0.91. Do not use it for RSS 1.0.

textinput (title=>$title, description=>$desc, name=>$name, link=>$link);
     This RSS element is also optional. Using it allows users to submit a
     Query to a program on a Web server via an HTML form. name is the HTML
     form name and link is the URL to the program. Content is submitted
     using the GET method.

     Access to the textinput values is the the same as *channel()* and
     image().

add_module(prefix=>$prefix, uri=>$uri) Adds a module namespace declaration to the XML::RSS object, allowing you to add modularity outside of the the standard RSS 1.0 modules.  At present, the standard modules Dublin Core (dc) and Syndication (syn) are predefined for your convenience.
     The modules are stored in the hash %{$obj->{'modules'}} where $obj is
     a reference to an XML::RSS object.

     For more information on RSS 1.0 Modules, read on.

RSS 1.0 MODULES
---------------

   XML-Namespace-based modularization affords RSS 1.0 compartmentalized
extensibility.  The only modules that ship "in the box" with RSS 1.0 are
Dublin Core (http://purl.org/rss/1.0/modules/dc/) and Syndication
(http://purl.org/rss/1.0/modules/syndication/).  Consult the appropriate
module's documentation for further information.

   Adding items from these modules in XML::RSS is as simple as adding other
attributes such as title, link, and description.  The only difference is
the compartmentalization of their key/value paris in a second-level hash.

     $rss->add_item (title=>$title, link=>$link, dc=>{ subject=>$subject, creator=>$creator });

   For elements of the Dublin Core module, use the key 'dc'.  For elements
of the Syndication module, 'syn'.  These are the prefixes used in the RSS
XML document itself.  They are associated with appropriate URI-based
namespaces:

     syn: http://purl.org/rss/1.0/modules/syndication/
     dc:  http://purl.org/dc/elements/1.1/

   Dublin Core elements may occur in channel, image, item(s), and textinput
- albeit uncomming to find them under image and textinput.  Syndication
elements are limited to the channel element.

   Access to module elements after parsing an RSS 1.0 document using
XML::RSS is via either the prefix or namespace URI for your convenience.

     print $rss->{items}->[0]->{dc}->{subject};

     or

     print $rss->{items}->[0]->{'http://purl.org/dc/elements/1.1/'}->{subject};

   XML::RSS also has support for "non-standard" RSS 1.0 modularization at
the channel, image, item, and textinput levels.  Parsing an RSS document
grabs any elements of other namespaces which might appear.  XML::RSS also
allows the inclusion of arbitrary namespaces and associated elements when
building  RSS documents.

   For example, to add elements of a made-up "My" module, first declare the
namespace by associating a prefix with a URI:

     $rss->add_module(prefix=>'my', uri=>'http://purl.org/my/rss/module/');

   Then proceed as usual:

     $rss->add_item (title=>$title, link=>$link, my=>{ rating=>$rating });

   Non-standard namespaces are not, however, currently accessible via a
simple prefix; access them via their namespace URL like so:

     print $rss->{items}->[0]->{'http://purl.org/my/rss/module/'}->{rating};

   XML::RSS will continue to provide built-in support for standard RSS 1.0
modules as they appear.

AUTHOR
======

   Jonathan Eisenzopf <eisen@pobox.com> Rael Dornfest <rael@oreilly.com>

CREDITS
=======

     Wojciech Zwiefka <wojtekz@cnt.pl>
     Chris Nandor <pudge@pobox.com>
     Jim Hebert <jim@cosource.com>
     Randal Schwartz <merlyn@stonehenge.com>
     rjp@browser.org

SEE ALSO
========

   perl(1), XML::Parser(3).


