This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Term/ProgressBar,  Next: Term/Prompt,  Prev: Term/GnuplotTerminals,  Up: Module List

Perl extension to display a progress bar
****************************************

NAME
====

   Term::ProgressBar - Perl extension to display a progress bar

SYNOPSIS
========

     use Term::ProgressBar;
     my $num_items = 100;
     my $bar = new Term::Progressbar('working magic', $num_items);
     foreach (0 .. $num_items-1) {
         # do work for item $_
         update $bar;
     }

DESCRIPTION
===========

   This module provides a simple progress indicator for command line
programs.  You initialize a ProgressBar object with a brief description of
what is happening and the number of things that need doing, and after each
thing is done you call the object's update() method.

   At the moment, this is presented to the user (on stderr) as a sequence
of 50 hash marks (no matter how many things are being done).

METHODS
=======

`new(desc, num_items)'
     Create and return a new progress bar, which is displayed to the user.
     Parameters are:

    desc - descriptive name of what you're doing (eg 'working magic')
    `num_items' - total number of items which must be completed
update()
     Update the progress bar by one 'tick'.  You should call this after
     completing each one of the 'items' included in the counter's total.
     The progress bar will be updated accordingly (at present, this means
     more text printed to stderr).

AUTHOR
======

   Ed Avis, epa98@doc.ic.ac.uk

SEE ALSO
========

   perl(1).


File: pm.info,  Node: Term/Prompt,  Next: Term/Query,  Prev: Term/ProgressBar,  Up: Module List

Perl extension for prompting a user for information
***************************************************

NAME
====

   Term::Prompt - Perl extension for prompting a user for information

SYNOPSIS
========

     use Term::Prompt;
     $value = &prompt(...);

     use Term::Prompt qw(termwrap);

     print &termwrap(...);

DESCRIPTION
===========

     This perl routine will take a prompt, a default response and a list of
     possible responses and deal with the user interface, (and the user!),
     by displaying the prompt, showing the default, and checking to be sure
     that the response is one of the legal choices.
     --Mark Henderson

     Derived from im_prompt2.pl, from anlpasswd (see
     ftp://info.mcs.anl.gov/pub/systems/), with permission. Revisions for Perl 5,
     addition of alternative help text presentation, addition of floating point
     type, addition of regular expression type, addition of yes/no type, and line
     wrapping by E. Allen Smith.

     Additional "types" that could be added would be a phone type,
     a social security type, a generic numeric pattern type...

     The usage is the following:
     x = don't care, a = alpha-only, n = numeric-only, i = ignore case
     c = case sensitive, r = ranged by the low and high values
     f = floating-point, y = yes/no, e = regular expression - Added by Allen

     $result = &prompt("x", "text prompt", "help prompt", "default" );

     $result = &prompt("a", "text prompt", "help prompt", "default" );

     $result = &prompt("n", "text prompt", "help prompt", "default" );

     The result will be a positive integer or 0.

     $result = &prompt("i", "text prompt", "help prompt", "default",
     	                 "legal_options-ignore-case-list");

     $result = &prompt("c", "text prompt", "help prompt", "default",
     	                 "legal_options-case-sensitive-list");

     $result = &prompt("r", "text prompt", "help prompt", "default",
                           "low", "high");

     $result = &prompt("f", "text prompt", "help prompt", "default");

     The result will be a floating-point number.

     $result = &prompt("y", "text prompt", "help prompt", "default")

     The result will be 1 for y, 0 for n. A default not starting with y or n
     (or the uc versions of these) will be treated as y for positive, n for
     negative.

     $result = &prompt("e", "text prompt", "help prompt", "default",
                           "regular expression");

     The regular expression for the last has ^ and $ surrounding it automatically;
     just put in .* before or after if you need to free it up before or
     after. - Allen

     What, you might ask, is the difference between a "text prompt" and a
     "help prompt"?  Think about the case where the "legal_options" look
     something like: "1-1000".  Now consider what happens when you tell someone
     that "0" is not between 1-1000 and that the possible choices are:  :)
     1 2 3 4 5 .....
     This is what the "help prompt" is for.

     It will work off of unique parts of "legal_options".

     Changed by Allen - it will be treated as a true "help prompt" if you
     capitalize the type of prompt, and otherwise will be treated as a list of
     options. Capitalizing the type of prompt will also mean that a return may be
     accepted as a response, even if there is no default; whether it actually is
     will depend on the type of prompt.

Other Functions
---------------

   Part of Term::Prompt is the optionally exported function termwrap,
which is used to wrap lines to the width of the currently selected
filehandle (or to STDOUT or STDERR if the width of the current filehandle
cannot be determined).  It uses the GetTerminalSize function from
Term::ReadKey then Text::Wrap.

AUTHOR
======

   Mark Henderson (henderson@mcs.anl.gov or systems@mcs.anl.gov) Primary
contact author: Allen Smith (easmith@beatrice.rutgers.edu)

SEE ALSO
========

   *Note Perl: (perl.info)perl,, *Note Term/ReadKey: Term/ReadKey,, and
*Note Text/Wrap: Text/Wrap,.


File: pm.info,  Node: Term/Query,  Next: Term/ReadKey,  Prev: Term/Prompt,  Up: Module List

Table-driven query routine.
***************************

NAME
====

   *Term::Query* - Table-driven query routine.

SYNOPSIS
========

`use *Term::Query*'
     `qw( *query* *query_table* query_table_set_defaults
     query_table_process );'

   `$result = *query* $prompt, $flags, [ $*optional_args* ];'

   `$*ok* = *query_table* \@array;'

   `*query_table_set_defaults* \@array;'

   `$*ok* = *query_table_process* \@array, \&flagsub, \&querysub;'

DESCRIPTION
===========

query
-----

   The query subroutine fulfills the need for a generalized
question-response subroutine, with programmatic defaulting, validation,
condition and error checking.

   Given *$prompt* and $flags, and possibly additional arguments,
depending upon the characters in $flags, query issues a prompt to STDOUT
and solicits input from STDIN.  The input is validated against a set of
test criteria as configured by the characters in $flags; if any of the
tests fail, an error message is noted, and the query is reattempted.

   When STDIN is not a tty (not interactive), prompts are not issued, and
errors cause a return rather than attempting to obtain more input.  This
non-interactive behaviour can be disabled by setting the variable
`$Foce_Interactive' as below:

     $Term::Query::Force_Interactive = 1;

   When `$Force_Interactive' is a non-null, non-zero value, query will
issue prompts, error messages, and ask for additional input even when the
input is not interactive.

query_table
-----------

   The query_table subroutine performs multiple queries, by invoking
query, setting associated variables with the results of each query.
Prompts, flags, and other arguments for each query are given in an array,
called a *query table*, which is passed to the query_table subroutine by
reference.

query_table_set_defaults
------------------------

   The query_table_set_defaults subroutine causes any variables named in
the given *query table* array to be assigned their corresponding default
values, if any.  This is a non-interactive subroutine.

query_table_process
-------------------

   A general interface to processing a *query table* is available with the
query_table_process subroutine.  It accepts a *query table* array, and two
subroutine references, a *&flagsub* and a *&querysub*.  The *&flagsub* is
invoked on each each flag character given in the $flags argument of the
*query table* (see below).  The *&querysub* is invoked for each query in
the *query table*.

   The query_table and query_table_set_defaults subroutines both use
query_table_process to perform their functions.

Query Table
-----------

   The format of the *query table* array passed to query_table,
query_table_set_defaults, and query_table_process subroutines is:

     @array = ( $prompt1, $flags1, [ $arglist1, ... ],
                $prompt2, $flags2, [ $arglist2, ... ],
     	    ...
     	    $promptN, $flagsN, [ $arglistN, ... ] );

   In English, there are three items per query: a prompt string, a flags
string, and an array of arguments.  Note that the syntax used above uses
`[ ... ]' to denote a Perl 5 anonymous array, not an optional set of
arguments.  Of course, if there are no arguments for a particular query,
the corresponding anonymous array can be the null string or zero.

   The query table design is such that a query table can be created with a
set of variables, their defaults, value constraints, and help strings, and
it can be used to both initialize the variables' values and to
interactively set their new values.  The query_table_set_defaults
subroutine performs the former, while query_table does the latter.

Flag Characters
---------------

   With typical usage, given *$prompt* and $flags, query prints *$prompt*
and then waits for input from the user.  The handling of the response
depends upon the flag characters given in the $flags string.

   The flag characters indicate the type of input, how to process it,
acceptable values, etc.  Some flags simply indicate the type or processing
of the input, and do not require additional arguments.  Other flags
require that subsequent arguments to the query subroutine be given.  The
arguments must be given in the same order as their corresponding flag
characters.

   The ordering of the flags in the $flags argument is important - it
determines the ordering of the tests.  For example, if both the a and m
flags are given as `"am"', then this indicates that an after subroutine
call should be performed first, followed by a regular expression match
test.

   All tests are applied in the order given in the $flags until a
particular test fails.  When a test fails, an error message is generated
and the input is reattempted, except in the case of the I flag.

Flag Characters Without Arguments
---------------------------------

i
     The input must be an integer.

n
     The input must be a number, real or integer.

Y
     The input is a `"yes"' or "no", with a default answer of `"yes"'.

N
     The input is a `"yes"' or "no", with a default answer of "no".

r
     Some input is required; an empty response will be refused.  This
     option is only meaningful when there is no default input (see the d
     flag character below).

s
     Strip and squeeze the input.  Leading and trailing blanks are
     eliminated, and embedded whitespace is "squeezed" to single blank
     characters.  This flag is implied by the k and K flags.

H
     Do not treat input of ? as a request for help.  This disables
     automatic help, unless implemented with the after (a flag) subroutine.

Flag Characters With Arguments
------------------------------

   The following flag characters indicate the presence of an argument to
query.  The arguments must occur in the same order as their corresponding
flag characters.  For example, if both the V and h flags are given as
`"Vh"', then the first argument must be the variable name, and the next
the help string, in that order.

a *\&after*
     The next argument is the after subroutine, to be invoked after the
     input has been solicited.  This feature provides for an "open ended"
     input validation, completely at the control of the user of the Query
     module.    The after subroutine is invoked in this manner:

          &$after( \$input );

     If the after sub returns an undef, then query processing stops with
     an immediate undef return value.

     If the after sub returns a null or zero value, then the input is
     rejected and resolicted.  No error messages are displayed except the
     "Please try again." message.

     Since the after sub has the reference to the *$input* variable, it is
     free to change the value of input indirectly; ie:

          $$input = $some_new_value;

b *\&before*
     The next argument is the before subroutine, to be invoked before any
     input is attempted.    If the before sub returns a non-null, non-zero
     value, the current query will be attempted.  If a null or zero value
     is returned, the current query will be abandoned, with a null return.

     This feature, used in a *query table*, allows for selective queries to
     be programmed by using before subs on the optional queries.  For
     example, using the following anonymous sub as the b flag argument:

          sub { $> == 0; }

     will cause the corresponding query to only be issued for the root
     user.

     The ordering of the b flag in the $flags argument is unimportant,
     since, by definition, this test is always performed before attempting
     any input.

d *$default*
     The next argument is the default input.  This string is used instead
     of an empty response from the user.  The default value can be a
     scalar value, a reference to a scalar value, or a reference to a
     subroutine, which will be invoked for its result only if a default
     value is needed (no input is given).

h *$help_string*
     The next argument is the *help string*, which is printed in response
     to an input of "?".  In order to enter a ? as actual text, it must be
     prefixed with a backslash: "\".

k *\@array*
     The next argument is a reference to an array of allowable keywords.
     The input is matched against the array elements in a case-insensitive
     manner, with unambiguous abbreviations allowed.  This flag implies the
     s flag.

     The matching can be made case-sensitive by setting the following
     variable prior to the invocation of query:

          $Query::Case_sensitive = 1;

     By default, this variable is null.

K *\@array*
     The next argument is a reference to an array of disallowed keywords In
     this case, for the input to be unacceptable, it must match exactly,
     case-insensitive, one of the array elements.  This flag implies the s
     flag.

     The k option is useful for soliciting new, unique keywords to a
     growing list.  Adding new fields to a database, for example.

     The matching can be made case-sensitive by setting the
     `$Query::Case_sensitive' variable (see above).

l *$maxlen*
     The next argument specifies the maximum length of the input.

m *$regular_expression*
     The next argument specifies a regular expression pattern against which
     the input will be matched.

I $reference
     The next argument is the input: either a simple scalar value, or a
     reference to a value, such as a SCALAR variable reference (eg:
     `\$somevar'), or a CODE reference (eg: `sub {..}').  In any case, the
     resulting value is used as input instead of reading from STDIN.

     If the input returned by the reference does not match other
     constraints, additional input is not attempted.  An error message is
     noted, and an undef return is taken.

     This option is handy for applications which have already acquired the
     input, and wish to use the validation features of query.

     It is also useful to embed a query definition in a *query table* which
     does not actually perform a query, but instead does a variable
     assignment dynamically, using the I reference value.

J $reference
     The next argument is the input reference, as with the I flag, except
     that if the input fails any of the constraints, additional input is
     solicited from the input.  In other words, the J flag sets a
     *one-time* only input reference.  Think of it as *jumping* into the
     query loop with an initial input.

V *variable_name_or_ref*
     The next argument is the variable name or reference to receive the
     validated input as its value.  This option, and its corresponding
     variable name, would normally be present on all entries used with
     query_table in order to retain to the values resulting from each
     query.

     The value can either be a string representing the variable name, or a
     reference to a variable, eg: `\$some_var'.

Details
-------

   The query processing proceeds basically in the same order as defined by
the flags argument, with some exceptions.  For example, the before
subroutine is always performed prior to input.

   There are implicit precedences in the ordering of some of the flag
tests.  Generally, flags have their corresponding tests performed in the
same order as the given flags.  Some flag tests, however, require that
other flags' tests be performed beforehand in order to be effective.  For
example, when given the k flag and an s flag, stripping the input would
only be effective if the strip were done on the input before testing the
input against the keyword table.  In other words, the s flag has
precedence over the k flag.  If the user supplies the flags string as
`"ks"', the effective ordering would still be `"sk"'.

   The table below indicates the precedences of the flag tests:

     Given Flag       Flags With Higher Precedence
     ==========       ================================
     i (int)          s (strip), d (default), h (help)
     k (key)          s (strip), d (default), h (help)
     K (nonkey)       s (strip), d (default), h (help)
     l (maxlen)                  d (default), h (help)
     m (match)                   d (default), h (help)
     n (numeric)      s (strip), d (default), h (help)
     N (no)           s (strip), d (default), h (help)
     r (required)                d (default), h (help)
     s (strip)                   d (default), h (help)
     Y (yes)          s (strip), d (default), h (help)

   Except for the implied precedence indicated in the table above, the
ordering of the flag tests proceeds in the same order as given in the
flags argument.

   Excepting the precedences above, query processing proceeds generally as
described below.

   * If the b flag was given, the "before" subroutine is invoked as a
     "pre-input" test.  If the sub returns a 0, empty string, or undef, the
     query is abandoned.  Otherwise, processing continues.

   * If the I or J flags were given, then input is obtained, without
     prompting, from the associated reference.  If the reference type is
     CODE, then it is invoked and the resulting return value is used as
     the input.  Otherwise the reference is evaluated in a scalar context
     and used as the input.  The J flag test is only done once, on the
     first entry into the input loop.

   * In the absence either the I or J flags, query will issue the given
     prompt and obtain input from STDIN.  If an EOF occurs, an undef value
     will result.

   * The input is examined for "null" input (that is, the empty string),
     and processing quits in this case.  Since most input is obtained from
     STDIN, a null input indicates an end-of-file (EOF).  If the input is
     not null, a terminating newline is removed, and the input testing
     continues.  At this point, an empty input string does not indicate an
     EOF.

   * If the s, k, or K flags were given, the input is trimmed of leading
     and trailing blanks, and all whitespace is "squeezed" to single
     blanks.

   * If the input is an empty response, and there is a default input (d
     flag), use it instead.

   * Unless the H flag is given, if the input is the character "?"  with
     nothing else, then print some helpful information.  If the user had
     supplied a *help string*, it is printed, otherwise the message:

     You are being asked "*$prompt*"

     is displayed.  Also, some information about the expected response,
     according to any given flag characters, is displayed.  Finally, the
     user is returned to the prompt, and given another opportunity to
     enter a response.

   * If input is required (indicated by the r flag), and if the input is
     empty, produce an error message, and query again.

   * If there was a a flag, the corresponding after subroutine is invoked
     with the input reference as its argument.  If the subroutine returns
     a non-null, non-zero value, the input succeeds, otherwise it fails.
     It is up to the after subroutine to display any appropriate error
     messages.

   * If the query was flagged Y or N, match the input against the pattern:

          /^(y(es?)?|no?)$/i

     If the match fails, print an error message, and query again.  When the
     match succeeds, replace the input with the complete word `"yes"' or
     "no";

   * If an integer response is required (i flagged), check for integer
     input.  If not, print an error, and query again.  A successful integer
     input is returned.

   * If a numeric response is required (n flagged), check for proper
     numeric input (either integer or real format).  Errors produce a
     warning, and another query.

   * If the query was given a keyword table (flagged with k), the input is
     matched against the allowable keyword list.  If an exact match is
     found, the keyword is returned as the input.  Failing an exact match,
     an abbreviation search is performed against the keywords.  If a single
     match is found, it is returned as the input.  If no match is found, an
     error message is produced, and the user is returned to the query to
     try again.  Otherwise, the input was ambiguous, an error noted
     showing the matches, and the user is queried again.

     The matching is case-insensitive or not, according to the value of the
     variable `$Query::Case_sensitive', which is nil, by default.  The
     variable may be set by the user to change the matching from
     case-insensitive to case-sensitive.

   * If the query was given an unacceptable keyword list (flagged with K),
     the input is compared against the unacceptable keywords.  If it
     matches any keywords exactly, an error is noted, and the query is
     performed again.

     The matching is case-insensitive by default.  Set the variable
     `$Query::Case_sensitive' to a non-null, non-zero value to make the
     keyword matching case-sensitive.

   * If the query was m flagged with a Perl regular expression pattern,
     then the input is matched against the pattern.  Failures are noted
     with an error message, and the query reattempted.

   * If the query was l flagged with a maximum input length, the length of
     the input is checked against the maximum.  A length violation is noted
     with an error message and the user is queried again.

   * If the query has a variable defined with the V flag, the variable is
     assigned the input string.  This is always done last, after and only
     if all tests are successful.

     If the variable is a string name and not qualified with a package name
     (ie:  `$foo::variable'), then the variable is qualified at the level
     outside of the Query.pm module.

   * Finally, having passed whatever conditions were flagged, the input is
     returned to the user.

EXAMPLE
=======

   The following are typical usage samples:

   * To perform a simple "yes" or "no" query, with "no" as the default
     answer:

          $ans = &query("Do you wish to quit? (yn)",'N');

   * An equivalent alternative is:

          query "Do you wish to quit? (yn)", 'NV', \$ans;

   * To perform the same query, with some supplied helpful information:

          $ans = &query("Do you wish to quit? (yn)",'Nh',<<'EOF');
          You are being asked if you wish to quit.  If you answer "yes",
          then all changes will be lost.  An answer of "no", will allow
          you to return to continue making changes.
          EOF

   * To solicit an integer input:

          $mode = &query("Please enter the file mode:",'idh','644',<<'EOF');
          Please enter the 3 digit numeric file mode; if you are unsure
          of how the file mode is used, please see the man page for "chmod".
          EOF

   * To solicit one of several keywords:

          @keys = split(' ','SGI DEC IBM Sun HP Apple');
          $vendor = &query('Please enter a vendor:','rkd',\@keys,'SGI');

   * To solicit a new, unique keyword to be used as a database field name,
     with a regexp pattern to check it against:

          @fields = split(' ','Index Vendor Title'); # existing fields
          $newfield = &query('New field name:','rKm',\@fields,'^\w+$');

ENVIRONMENT
===========

COLUMNS
     This variable is used to control the width of output when listing the
     keyword arrays.  If not defined, 80 is used by default.

DEPENDENCIES
============

Carp.pm
     Used to produce usage error messages.

Array::PrintCols::print_cols
     Used to produce displays of the keyword arrays.

FILES
=====

   None.

AUTHOR
======

   Copyright (C) 1995  Alan K. Stebbens <aks@hub.ucsb.edu>

   This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

   This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

   You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
675 Mass Ave, Cambridge, MA 02139, USA.

DIAGNOSTICS
===========

Input is required.
     Issued when an empty response is given, and there is no default input.

Please answer with 'yes' or 'no', or enter '?' for help.
     Issued for Y or N flagged queries, and the input is not reconizeable.

Please enter an integer number.
     Printed when non-integer input is given for i flagged queries.

Please enter a number, real or integer.
     Printed when non-numeric input is given for n flagged queries.

The input '*$input*' is ambiguous; it matches the following:
     Issued in response to k flagged queries with input which matches more
     than one of the allowed keywords.

The input '*$input*' fails to match any of the allowed keywords:
     Printed when input to a k flagged query does not match any of the
     keywords.

The input '%s' matches a disallowed keyword '%s'.
     Printed when the input matches one of the unacceptable keywords given
     on a K flagged query.

'%s' fails to match '%s'
     This results from input failing to match the regular expression given
     on a m flagged query.

Input is %d characters too long; cannot exceed %d characters.
     The length of the input exceeded the maximum length given with the l
     flag argument.

Please try again, or enter '?' for help.
query: The k flag needs an array reference.
     The next argument in the argument list to query wasn't an array
     reference.

query: The K flag needs an array reference.
     The next argument in the argumentlist to query wasn't an array
     reference.

BUGS
====


File: pm.info,  Node: Term/ReadKey,  Next: Term/ReadLine,  Prev: Term/Query,  Up: Module List

A perl module for simple terminal control
*****************************************

NAME
====

   Term::ReadKey - A perl module for simple terminal control

SYNOPSIS
========

     use Term::ReadKey;
     ReadMode 4; # Turn off controls keys
     while (not defined ($key = ReadKey(-1)) {
     	# No key yet
     }
     print "Get key $key\n";
     ReadMode 0; # Reset tty mode before exiting

DESCRIPTION
===========

   Term::ReadKey is a compiled perl module dedicated to providing simple
control over terminal driver modes (cbreak, raw, cooked, etc.,) support for
non-blocking reads, if the architecture allows, and some generalized handy
functions for working with terminals. One of the main goals is to have the
functions as portable as possible, so you can just plug in "use
Term::ReadKey" on any architecture and have a good likelyhood of it
working.

ReadMode MODE [, Filehandle]
     Takes an integer argument, which can currently be one of the following
     values:

          0    Restore original settings.
          1    Change to cooked mode.
          2	 Change to cooked mode with echo off.
                (Good for passwords)
          3    Change to cbreak mode.
          4    Change to raw mode.
          5    Change to ultra-raw mode.
                (LF to CR/LF translation turned off)
          
          Or, you may use the synonyms:
          
          restore
          normal
          noecho
          cbreak
          raw
          ultra-raw

     These functions are automatically applied to the STDIN handle if no
     other handle is supplied. Modes 0 and 5 have some special properties
     worth mentioning: not only will mode 0 restore original settings, but
     it cause the next ReadMode call to save a new set of default
     settings. Mode 5 is similar to mode 4, except no CR/LF translation is
     performed, and if possible, parity will be disabled (only if not
     being used by the terminal, however. It is no different from mode 4
     under Windows.)

     If you are executing another program that may be changing the
     terminal mode, you will either want to say

          ReadMode 1
          system('someprogram');
          ReadMode 1;
          
          which resets the settings after the program has run, or:

          $somemode=1;
          ReadMode 0;
          system('someprogram');
          ReadMode 1;
          
          which records any changes the program may have made, before resetting the
          mode.

ReadKey MODE [, Filehandle]
     Takes an integer argument, which can currently be one of the following
     values:

          0    Perform a normal read using getc
          -1   Perform a non-blocked read
          >0	 Perform a timed read

     (If the filehandle is not supplied, it will default to STDIN.) If
     there is nothing waiting in the buffer during a non-blocked read,
     then undef will be returned. Note that if the OS does not provide any
     known mechanism for non-blocking reads, then a `ReadKey -1' can die
     with a fatal error. This will hopefully not be common.

     If MODE is greater then zero, then ReadKey will use it as a timeout
     value in seconds (fractional seconds are allowed), and won't return
     undef until that time expires. (Note, again, that some OS's may not
     support this timeout behaviour.) If MODE is less then zero, then this
     is treated as a timeout of zero, and thus will return immediately if
     no character is waiting. A MODE of zero, however, will act like a
     normal getc.

     There are currently some limitations with this call under Windows. It
     may be possible that non-blocking reads will fail when reading
     repeating keys from more then one console.

ReadLine MODE [, Filehandle]
     Takes an integer argument, which can currently be one of the following
     values:

          0    Perform a normal read using scalar(<FileHandle>)
          -1   Perform a non-blocked read
          >0	 Perform a timed read

     If there is nothing waiting in the buffer during a non-blocked read,
     then undef will be returned. Note that if the OS does not provide any
     known mechanism for non-blocking reads, then a `ReadLine 1' can die
     with a fatal error. This will hopefully not be common. Note that a
     non-blocking test is only performed for the first character in the
     line, not the entire line.  This call will probably not do what you
     assume, especially with ReadMode's higher then 1. For example,
     pressing Space and then Backspace would appear to leave you where you
     started, but any timeouts would now be suspended.

     This call is currently not available under Windows.

GetTerminalSize [Filehandle]
     Returns either an empty array if this operation is unsupported, or a
     four element array containing: the width of the terminal in
     characters, the height of the terminal in character, the width in
     pixels, and the height in pixels. (The pixel size will only be valid
     in some environments.)

     Under Windows, this function must be called with an "output"
     filehandle, such as STDOUT, or a handle opened to CONOUT$.

SetTerminalSize WIDTH,HEIGHT,XPIX,YPIX [, Filehandle]
     Return -1 on failure, 0 otherwise. Note that this terminal size is
     only for informative value, and changing the size via this mechanism
     will not change the size of the screen. For example, XTerm uses a
     call like this when it resizes the screen. If any of the new
     measurements vary from the old, the OS will probably send a SIGWINCH
     signal to anything reading that tty or pty.

     This call does not work under Windows.

GetSpeeds [, Filehandle]
     Returns either an empty array if the operation is unsupported, or a
     two value array containing the terminal in and out speeds, in
     decimal. E.g, an in speed of 9600 baud and an out speed of 4800 baud
     would be returned as (9600,4800). Note that currently the in and out
     speeds will always be identical in some OS's. No speeds are reported
     under Windows.

GetControlChars [, Filehandle]
     Returns an array containing key/value pairs suitable for a hash. The
     pairs consist of a key, the name of the control character/signal, and
     the value of that character, as a single character. This call does
     nothing under Windows.

     Each key will be an entry from the following list:

          DISCARD
          DSUSPEND
          EOF
          EOL
          EOL2
          ERASE
          ERASEWORD
          INTERRUPT
          KILL
          MIN
          QUIT
          QUOTENEXT
          REPRINT
          START
          STATUS
          STOP
          SUSPEND
          SWITCH
          TIME

     Thus, the following will always return the current interrupt
     character, regardless of platform.

          %keys = GetControlChars;
          $int = $keys{INTERRUPT};

SetControlChars [, Filehandle]
     Takes an array containing key/value pairs, as a hash will produce.
     The pairs should consist of a key that is the name of a legal control
     character/signal, and the value should be either a single character,
     or a number in the range 0-255. SetControlChars will die with a
     runtime error if an invalid character name is passed or there is an
     error changing the settings. The list of valid names is easily
     available via

          %cchars = GetControlChars();
          @cnames = keys %cchars;

     This call does nothing under Windows.

AUTHOR
======

   Kenneth Albanowski <kjahds@kjahds.com>


File: pm.info,  Node: Term/ReadLine,  Next: Term/ReadLine/Gnu,  Prev: Term/ReadKey,  Up: Module List

Perl interface to various readline packages. If no real package is found, substitutes stubs instead of basic functions.
***********************************************************************************************************************

NAME
====

   Term::ReadLine - Perl interface to various readline packages. If no
real package is found, substitutes stubs instead of basic functions.

SYNOPSIS
========

     use Term::ReadLine;
     $term = new Term::ReadLine 'Simple Perl calc';
     $prompt = "Enter your arithmetic expression: ";
     $OUT = $term->OUT || STDOUT;
     while ( defined ($_ = $term->readline($prompt)) ) {
       $res = eval($_), "\n";
       warn $@ if $@;
       print $OUT $res, "\n" unless $@;
       $term->addhistory($_) if /\S/;
     }

DESCRIPTION
===========

   This package is just a front end to some other packages. At the moment
this description is written, the only such package is Term-ReadLine,
available on CPAN near you. The real target of this stub package is to set
up a common interface to whatever Readline emerges with time.

Minimal set of supported functions
==================================

   All the supported functions should be called as methods, i.e., either as

     $term = new Term::ReadLine 'name';

   or as

     $term->addhistory('row');

   where $term is a return value of Term::ReadLine->Init.

ReadLine
     returns the actual package that executes the commands. Among possible
     values are `Term::ReadLine::Gnu', Term::ReadLine::Perl,
     `Term::ReadLine::Stub Exporter'.

new
     returns the handle for subsequent calls to following functions.
     Argument is the name of the application. Optionally can be followed
     by two arguments for IN and `OUT' filehandles. These arguments should
     be globs.

readline
     gets an input line, *possibly* with actual readline support. Trailing
     newline is removed. Returns undef on EOF.

`addhistory'
     adds the line to the history of input, from where it can be used if
     the actual readline is present.

IN, $`OUT'
     return the filehandles for input and output or undef if readline
     input and output cannot be used for Perl.

`MinLine'
     If argument is specified, it is an advice on minimal size of line to
     be included into history.  undef means do not include anything into
     history. Returns the old value.

`findConsole'
     returns an array with two strings that give most appropriate names for
     files for input and output using conventions `"<$in"', `">out"'.

Attribs
     returns a reference to a hash which describes internal configuration
     of the package. Names of keys in this hash conform to standard
     conventions with the leading `rl_' stripped.

Features
     Returns a reference to a hash with keys being features present in
     current implementation. Several optional features are used in the
     minimal interface: `appname' should be present if the first argument
     to new is recognized, and `minline' should be present if `MinLine'
     method is not dummy.  `autohistory' should be present if lines are
     put into history automatically (maybe subject to `MinLine'), and
     `addhistory' if `addhistory' method is not dummy.

     If Features method reports a feature `attribs' as present, the method
     Attribs is not dummy.

Additional supported functions
==============================

   Actually Term::ReadLine can use some other package, that will support
reacher set of commands.

   All these commands are callable via method interface and have names
which conform to standard conventions with the leading `rl_' stripped.

   The stub package included with the perl distribution allows some
additional methods:

`tkRunning'
     makes Tk event loop run when waiting for user input (i.e., during
     readline method).

`ornaments'
     makes the command line stand out by using termcap data.  The argument
     to `ornaments' should be 0, 1, or a string of a form `"aa,bb,cc,dd"'.
     Four components of this string should be names of *terminal
     capacities*, first two will be issued to make the prompt standout,
     last two to make the input line standout.

`newTTY'
     takes two arguments which are input filehandle and output filehandle.
     Switches to use these filehandles.

   One can check whether the currently loaded ReadLine package supports
these methods by checking for corresponding Features.

EXPORTS
=======

   None

ENVIRONMENT
===========

   The environment variable `PERL_RL' governs which ReadLine clone is
loaded. If the value is false, a dummy interface is used. If the value is
true, it should be tail of the name of the package to use, such as Perl or
`Gnu'.

   As a special case, if the value of this variable is space-separated,
the tail might be used to disable the ornaments by setting the tail to be
`o=0' or `ornaments=0'.  The head should be as described above, say

   If the variable is not set, or if the head of space-separated list is
empty, the best available package is loaded.

     export "PERL_RL=Perl o=0"	# Use Perl ReadLine without ornaments
     export "PERL_RL= o=0"		# Use best available ReadLine without ornaments

   (Note that processing of `PERL_RL' for ornaments is in the discretion
of the particular used `Term::ReadLine::*' package).


File: pm.info,  Node: Term/ReadLine/Gnu,  Next: Term/ReadPassword,  Prev: Term/ReadLine,  Up: Module List

Perl extension for the GNU Readline/History Library
***************************************************

NAME
====

   Term::ReadLine::Gnu - Perl extension for the GNU Readline/History
Library

SYNOPSIS
========

     use Term::ReadLine;
     $term = new Term::ReadLine 'ProgramName';
     while ( defined ($_ = $term->readline('prompt>')) ) {
       ...
     }

DESCRIPTION
===========

Overview
--------

   This is an implementation of Term::ReadLine using the GNU
Readline/History Library.

   For basic functions object oriented interface is provided. These are
described in the section `"Standard Methods"|"Standard Methods"' in this
node and `"`Term::ReadLine::Gnu' in this node
Functions"|"`Term::ReadLine::Gnu' Functions"'.

   This package also has the interface with the almost all functions and
variables which are documented in the GNU Readline/History Library Manual.
They are documented in the section `"`Term::ReadLine::Gnu' in this node
Functions"|"`Term::ReadLine::Gnu' Functions"' and `"`Term::ReadLine::Gnu'
in this node Variables"|"`Term::ReadLine::Gnu' Variables"' briefly.  For
more detail of the GNU Readline/History Library, see 'GNU Readline Library
Manual' and 'GNU History Library Manual'.

   The sample programs under `eg/' directory and test programs under `t/'
directory in the `Term::ReadLine::Gnu' distribution include many example
of this module.

Standard Methods
----------------

   These methods are standard methods defined by Term::ReadLine.

ReadLine
     returns the actual package that executes the commands. If you have
     installed this package,  possible value is `Term::ReadLine::Gnu'.

`new(NAME,[IN[,OUT]])'
     returns the handle for subsequent calls to following functions.
     Argument is the name of the application.  Optionally can be followed
     by two arguments for IN and `OUT' file handles. These arguments
     should be globs.

`readline(PROMPT[,PREPUT])'
     gets an input line, with actual `GNU Readline' support.  Trailing
     newline is removed.  Returns undef on EOF.  `PREPUT' is an optional
     argument meaning the initial value of input.

     The optional argument `PREPUT' is granted only if the value `preput'
     is in Features.

     `PROMPT' may include some escape sequences.  Use
     `RL_PROMPT_START_IGNORE' to begin a sequence of non-printing
     characters, and `RL_PROMPT_END_IGNORE' to end of such a sequence.

`AddHistory(LINE1, LINE2, ...)'
     adds the lines to the history of input, from where it can be used if
     the actual readline is present.

IN, `OUT'
     return the file handles for input and output or undef if readline
     input and output cannot be used for Perl.

`MinLine([MAX])'
     If argument MAX is specified, it is an advice on minimal size of line
     to be included into history.  undef means do not include anything
     into history.  Returns the old value.

`findConsole'
     returns an array with two strings that give most appropriate names for
     files for input and output using conventions `"<$in"', `">$out"'.

Attribs
     returns a reference to a hash which describes internal configuration
     (variables) of the package.  Names of keys in this hash conform to
     standard conventions with the leading `rl_' stripped.

     See section "Variables" for supported variables.

Features
     Returns a reference to a hash with keys being features present in
     current implementation. Several optional features are used in the
     minimal interface: `appname' should be present if the first argument
     to new is recognized, and `minline' should be present if `MinLine'
     method is not dummy.  `autohistory' should be present if lines are
     put into history automatically (maybe subject to `MinLine'), and
     `addHistory' if `AddHistory' method is not dummy.  `preput' means the
     second argument to readline method is processed.  `getHistory' and
     `setHistory' denote that the corresponding methods are present.
     `tkRunning' denotes that a Tk application may run while ReadLine is
     getting input.

`Term::ReadLine::Gnu' Functions
-------------------------------

   All these GNU Readline/History Library functions are callable via
method interface and have names which conform to standard conventions with
the leading `rl_' stripped.

   Almost methods have lower level functions in `Term::ReadLine::Gnu::XS'
package.  To use them full qualified name is required.  Using method
interface is preferred.

Readline Convenience Functions

    Naming Function

         `add_defun(NAME, FUNC [,KEY=-1])'
               Add name to the Perl function `FUNC'.  If optional argument
               KEY is specified, bind it to the `FUNC'.  Returns reference
               to `FunctionPtr'.

                    Example:
                    	# name name `reverse-line' to a function reverse_line(),
                    	# and bind it to "\C-t"
                    	$term->add_defun('reverse-line', \&reverse_line, "\ct");

    Selecting a Keymap

         `make_bare_keymap'
                    Keymap	rl_make_bare_keymap()

         `copy_keymap(MAP)'
                    Keymap	rl_copy_keymap(Keymap|str map)

         `make_keymap'
                    Keymap	rl_make_keymap()

         `discard_keymap(MAP)'
                    Keymap	rl_discard_keymap(Keymap|str map)

         `get_keymap'
                    Keymap	rl_get_keymap()

         `set_keymap(MAP)'
                    Keymap	rl_set_keymap(Keymap|str map)

         `get_keymap_by_name(NAME)'
                    Keymap	rl_get_keymap_by_name(str name)

         `get_keymap_name(MAP)'
                    str	rl_get_keymap_name(Keymap map)

    Binding Keys

         `bind_key(KEY, FUNCTION [,MAP])'
                    int	rl_bind_key(int key, FunctionPtr|str function,
                    		    Keymap|str map = rl_get_keymap())

               Bind KEY to the FUNCTION.  FUNCTION is the name added by the
               `add_defun' method.  If optional argument `MAP' is
               specified, binds in `MAP'.  Returns non-zero in case of
               error.

         `unbind_key(KEY [,MAP])'
                    int	rl_unbind_key(int key, Keymap|str map = rl_get_keymap())

               Bind KEY to the null function.  Returns non-zero in case of
               error.

         `unbind_function(FUNCTION [,MAP])'
                    int	rl_unbind_function(FunctionPtr|str function,
                    			   Keymap|str map = rl_get_keymap())

         `unbind_command(COMMAND [,MAP])'
                    int	rl_unbind_command(str command,
                    			  Keymap|str map = rl_get_keymap())

         `generic_bind(TYPE, KEYSEQ, DATA, [,MAP])'
                    int	rl_generic_bind(int type, str keyseq,
                    			FunctionPtr|Keymap|str data,
                    			Keymap|str map = rl_get_keymap())

         `parse_and_bind(LINE)'
                    void	rl_parse_and_bind(str line)

               Parse LINE as if it had been read from the `~/.inputrc'
               file and perform any key bindings and variable assignments
               found.  For more detail see 'GNU Readline Library Manual'.

         `read_init_file([FILENAME])'
                    int	rl_read_init_file(str filename = '~/.inputrc')

    Associating Function Names and Bindings

         `named_function(NAME)'
                    FunctionPtr rl_named_function(str name)

         `get_function_name(FUNCTION)'
                    str	rl_get_function_name(FunctionPtr function)

         `function_of_keyseq(KEYMAP [,MAP])'
                    (FunctionPtr|Keymap|str data, int type)
                    	rl_function_of_keyseq(str keyseq,
                    			      Keymap|str map = rl_get_keymap())

         `invoking_keyseqs(FUNCTION [,MAP])'
                    (@str)	rl_invoking_keyseqs(FunctionPtr|str function,
                    			    Keymap|str map = rl_get_keymap())

         `function_dumper([READABLE])'
                    void	rl_function_dumper(int readable = 0)

         `list_funmap_names'
                    void	rl_list_funmap_names()

         `funmap_names' (undocumented)
                    (@str)	rl_funmap_names()

    Allowing Undoing

         `begin_undo_group'
                    int	rl_begin_undo_group()

         `end_undo_group'
                    int	rl_end_undo_group()

         `add_undo(WHAT, START, END, TEXT)'
                    int	rl_add_undo(int what, int start, int end, str text)

         `free_undo_list'
                    void	free_undo_list()

         `do_undo'
                    int	rl_do_undo()

         `modifying([START [,END]])'
                    int	rl_modifying(int start = 0, int end = rl_end)

    Redisplay

         `redisplay'
                    void	rl_redisplay()

         `forced_update_display'
                    int	rl_forced_update_display()

         `on_new_line'
                    int	rl_on_new_line()

         `on_new_line_with_prompt'
                    int	rl_on_new_line_with_prompt()	# GRL 4.1

         `reset_line_state'
                    int	rl_reset_line_state()

         `message(FMT[, ...])'
                    int	rl_message(str fmt, ...)

         `clear_message'
                    int	rl_clear_message()

         `save_prompt'
                    void	rl_save_prompt()

         `restore_prompt'
                    void	rl_restore_prompt()

    Modifying Text

         `insert_text(TEXT)'
                    int	rl_insert_text(str text)

         `delete_text([START [,END]])'
                    int	rl_delete_text(start = 0, end = rl_end)

         `copy_text([START [,END]])'
                    str	rl_copy_text(start = 0, end = rl_end)

         `kill_text([START [,END]])'
                    int	rl_kill_text(start = 0, end = rl_end)

    Utility Functions

         `read_key'
                    int	rl_read_key()

         `getc(FILE)'
                    int	rl_getc(FILE *)

         `stuff_char(C)'
                    int	rl_stuff_char(int c)

         initialize
                    int	rl_initialize()

         `reset_terminal([TERMINAL_NAME])'
                    int	rl_reset_terminal(str terminal_name = getenv($TERM))

         `ding'
                    int	ding()

         `display_match_list(MATCHES [,LEN [,MAX]])'
                    void	rl_display_match_list(\@matches, len = $#maches, max) # GRL 4.0

               Since the first element of an array @matches as treated as
               a possible completion, it is not displayed.  See the
               descriptions of `completion_matches()'.

               When MAX is ommited, the max length of an item in @matches
               is used.

    Alternate Interface

         `callback_handler_install(PROMPT, LHANDLER)'
                    void	rl_callback_handler_install(str prompt, pfunc lhandler)

         `callback_read_char'
                    void	rl_callback_read_char()

         `callback_handler_remove'
                    void	rl_callback_handler_remove()

Readline Signal Handling

    `cleanup_after_signal'
               void	rl_cleanup_after_signal()	# GRL 4.0

    `free_line_state'
               void	rl_free_line_state()	# GRL 4.0

    `reset_after_signal'
               void	rl_reset_after_signal()	# GRL 4.0

    `resize_terminal'
               void	rl_resize_terminal()	# GRL 4.0

    `set_signals'
               int	rl_set_signals()	# GRL 4.0

    `clear_signals'
               int	rl_clear_signals()	# GRL 4.0

Completion Functions

    `complete_internal([WHAT_TO_DO])'
               int	rl_complete_internal(int what_to_do = TAB)

    `completion_matches(TEXT [,FUNC])'
               (@str)	completion_matches(str text,
               			   pfunc func = filename_completion_function)

    `filename_completion_function(TEXT, STATE)'
               str	filename_completion_function(str text, int state)

    `username_completion_function(TEXT, STATE)'
               str	username_completion_function(str text, int state)

    `list_completion_function(TEXT, STATE)'
               str	list_completion_function(str text, int state)

History Functions

    Initializing History and State Management

         `using_history'
                    void	using_history()

    History List Management

         `addhistory(STRING[, STRING, ...])'
                    void	add_history(str string)

         `StifleHistory(MAX)'
                    int	stifle_history(int max|undef)

               stifles the history list, remembering only the last MAX
               entries.  If MAX is undef, remembers all entries.  This is
               a replacement of unstifle_history().

         `unstifle_history'
                    int	unstifle_history()

               This is equivalent with 'stifle_history(undef)'.

         `SetHistory(LINE1 [, LINE2, ...])'
               sets the history of input, from where it can be used if the
               actual readline is present.

         `remove_history(WHICH)'
                    str	remove_history(int which)

         `replace_history_entry(WHICH, LINE)'
                    str	replace_history_entry(int which, str line)

         `clear_history'
                    void	clear_history()

         `history_is_stifled'
                    int	history_is_stifled()

    Information About the History List

         `where_history'
                    int	where_history()

         `current_history'
                    str	current_history()

         `history_get(OFFSET)'
                    str	history_get(offset)

         `history_total_bytes'
                    int	history_total_bytes()

         `GetHistory'
               returns the history of input as a list, if actual readline
               is present.

    Moving Around the History List

         `history_set_pos(POS)'
                    int	history_set_pos(int pos)

         `previous_history'
                    str	previous_history()

         `next_history'
                    str	next_history()

    Searching the History List

         `history_search(STRING [,DIRECTION])'
                    int	history_search(str string, int direction = -1)

         `history_search_prefix(STRING [,DIRECTION])'
                    int	history_search_prefix(str string, int direction = -1)

         `history_search_pos(STRING [,DIRECTION [,POS]])'
                    int	history_search_pos(str string,
                    			   int direction = -1,
                    			   int pos = where_history())

    Managing the History File

         `ReadHistory([FILENAME [,FROM [,TO]]])'
                    int	read_history(str filename = '~/.history',
                    		     int from = 0, int to = -1)

                    int	read_history_range(str filename = '~/.history',
                    			   int from = 0, int to = -1)

               adds the contents of FILENAME to the history list, a line
               at a time.  If FILENAME is false, then read from
               `~/.history'.  Start reading at line `FROM' and end at TO.
               If `FROM' is omitted or zero, start at the beginning.  If
               TO is omitted or less than `FROM', then read until the end
               of the file.  Returns true if successful, or false if not.
               `read_history()' is an aliase of `read_history_range()'.

         `WriteHistory([FILENAME])'
                    int	write_history(str filename = '~/.history')

               writes the current history to FILENAME, overwriting
               FILENAME if necessary.  If FILENAME is false, then write
               the history list to `~/.history'.  Returns true if
               successful, or false if not.

         `append_history(NELEMENTS [,FILENAME])'
                    int	append_history(int nelements, str filename = '~/.history')

         `history_truncate_file([FILENAME [,NLINES]])'
                    int	history_truncate_file(str filename = '~/.history',
                    			      int nlines = 0)

    History Expansion

         `history_expand(LINE)'
                    (int result, str expansion) history_expand(str line)

               Note that this function returns `expansion' in scalar
               context.

         `history_arg_extract(LINE, [FIRST [,LAST]])'
                    str history_arg_extract(str line, int first = 0, int last = '$')

         `get_history_event(STRING, CINDEX [,QCHAR])'
                    (str text, int cindex) = get_history_event(str  string,
                    					   int  cindex,
                    					   char qchar = '\0')

         `history_tokenize(LINE)'
                    (@str)	history_tokenize(str line)

`Term::ReadLine::Gnu' Variables
-------------------------------

   Following GNU Readline/History Library variables can be accessed from
Perl program.  See 'GNU Readline Library Manual' and ' GNU History Library
Manual' for each variable.  You can access them with Attribs methods.
Names of keys in this hash conform to standard conventions with the
leading `rl_' stripped.

   Examples:

     $attribs = $term->Attribs;
     $v = $attribs->{library_version};	# rl_library_version
     $v = $attribs->{history_base};	# history_base

Readline Variables
          str rl_line_buffer
          int rl_point
          int rl_end
          int rl_mark
          int rl_done
          int rl_pending_input
          int rl_erase_empty_line (GRL 4.0)
          str rl_prompt (read only)
          int rl_already_prompted (GRL 4.1)
          str rl_library_version (read only)
          str rl_terminal_name
          str rl_readline_name
          filehandle rl_instream
          filehandle rl_outstream
          pfunc rl_startup_hook
          pfunc rl_pre_input_hook (GRL 4.0)
          pfunc rl_event_hook
          pfunc rl_getc_function
          pfunc rl_redisplay_function
          pfunc rl_last_func (not documented)
          Keymap rl_executing_keymap (read only)
          Keymap rl_binding_keymap (read only)

Signal Handling Variables
          int rl_catch_signals (GRL 4.0)
          int rl_catch_sigwinch (GRL 4.0)

Completion Variables
          pfunc rl_completion_entry_function
          pfunc rl_attempted_completion_function
          pfunc rl_filename_quoting_function
          pfunc rl_filename_dequoting_function
          pfunc rl_char_is_quoted_p
          int rl_completion_query_items
          str rl_basic_word_break_characters
          str rl_basic_quote_characters
          str rl_completer_word_break_characters
          str rl_completer_quote_characters
          str rl_filename_quote_characters
          str rl_special_prefixes
          int rl_completion_append_character
          int rl_ignore_completion_duplicates
          int rl_filename_completion_desired
          int rl_filename_quoting_desired
          int rl_inhibit_completion
          pfunc rl_ignore_some_completion_function
          pfunc rl_directory_completion_hook
          pfunc rl_completion_display_matches_hook (GRL 4.0)

History Variables
          int history_base
          int history_length
          int max_input_history (read only)
          char history_expansion_char
          char history_subst_char
          char history_comment_char
          str history_no_expand_chars
          str history_search_delimiter_chars
          int history_quotes_inhibit_expansion
          pfunc history_inhibit_expansion_function

Function References
          rl_getc
          rl_redisplay
          rl_callback_read_char
          rl_display_match_list
          filename_completion_function
          username_completion_function
          list_completion_function
          shadow_redisplay
          Tk_getc

Custom Completion
-----------------

   In this section variables and functions for custom completion is
described with examples.

   Most of descriptions in this section is cited from GNU Readline Library
manual.

`rl_completion_entry_function'
     This variable holds reference refers to a generator function for
     `completion_matches()'.

     A generator function is called repeatedly from
     `completion_matches()', returning a string each time.  The arguments
     to the generator function are TEXT and STATE.  TEXT is the partial
     word to be completed.  STATE is zero the first time the function is
     called, allowing the generator to perform any necessary
     initialization, and a positive non-zero integer for each subsequent
     call.  When the generator function returns undef this signals
     `completion_matches()' that there are no more possibilities left.

     If the value is undef, built-in `filename_completion_function' is
     used.

     A sample generator function, `list_completion_function', is defined
     in Gnu.pm.  You can use it as follows;

          use Term::ReadLine;
          ...
          my $term = new Term::ReadLine 'sample';
          my $attribs = $term->Attribs;
          ...
          $attribs->{completion_entry_function} =
          	$attribs->{list_completion_function};
          ...
          $attribs->{completion_word} =
          	[qw(reference to a list of words which you want to use for completion)];
          $term->readline("custom completion>");

     See also `completion_matches'.

`rl_attempted_completion_function'
     A reference to an alternative function to create matches.

     The function is called with TEXT, `LINE_BUFFER', START, and END.
     `LINE_BUFFER' is a current input buffer string.  START and END are
     indices in `LINE_BUFFER' saying what the boundaries of TEXT are.

     If this function exists and returns null list or undef, or if this
     variable is set to undef, then an internal function `rl_complete()'
     will call the value of `$rl_completion_entry_function' to generate
     matches, otherwise the array of strings returned will be used.

     The default value of this variable is undef.  You can use it as
     follows;

          use Term::ReadLine;
          ...
          my $term = new Term::ReadLine 'sample';
          my $attribs = $term->Attribs;
          ...
          sub sample_completion {
              my ($text, $line, $start, $end) = @_;
              # If first word then username completion, else filename completion
              if (substr($line, 0, $start) =~ /^\s*$/) {
          	    return $term->completion_matches($text,
          					     $attribs->{'username_completion_function'});
              } else {
          	    return ();
              }
          }
          ...
          $attribs->{attempted_completion_function} = \&sample_completion;

`completion_matches(TEXT, ENTRY_FUNC)'
     Returns an array of strings which is a list of completions for TEXT.
     If there are no completions, returns undef.  The first entry in the
     returned array is the substitution for TEXT.  The remaining entries
     are the possible completions.

     `ENTRY_FUNC' is a generator function which has two arguments, and
     returns a string.  The first argument is TEXT.  The second is a state
     argument; it is zero on the first call, and non-zero on subsequent
     calls.  `ENTRY_FUNC' returns a undef to the caller when there are no
     more matches.

     If the value of `ENTRY_FUNC' is undef, built-in
     `filename_completion_function' is used.

     `completion_matches' is a Perl wrapper function of an internal
     function `completion_matches()'.  See also
     `$rl_completion_entry_function'.

`completion_function'
     A variable whose content is a reference to a function which returns a
     list of candidates to complete.

     This variable is compatible with Term::ReadLine::Perl and very easy
     to use.

          use Term::ReadLine;
          ...
          my $term = new Term::ReadLine 'sample';
          my $attribs = $term->Attribs;
          ...
          $attribs->{completion_function} = sub {
          	my ($text, $line, $start) = @_;
          	return qw(a list of candidates to complete);
          }

`list_completion_function(TEXT, STATE)'
     A sample generator function defined by `Term::ReadLine::Gnu'.
     Example code at `rl_completion_entry_function' shows how to use this
     function.

`Term::ReadLine::Gnu' Specific Features
---------------------------------------

`Term::ReadLine::Gnu' Specific Functions

    `CallbackHandlerInstall(PROMPT, LHANDLER)'
          This method provides the function `rl_callback_handler_install()'
          with the following addtional feature compatible with readline
          method; ornament feature, Term::ReadLine::Perl compatible
          completion function, histroy expansion, and addition to history
          buffer.

    `call_function(FUNCTION, [COUNT [,KEY]])'
               int	rl_call_function(FunctionPtr|str function, count = 1, key = -1)

    `rl_get_all_function_names'
          Returns a list of all function names.

    `shadow_redisplay'
          A redisplay function for password input.  You can use it as
          follows;

               $attribs->{redisplay_function} = $attribs->{shadow_redisplay};
               $line = $term->readline("password> ");

    `rl_filename_list'
          Returns candidates of filename to complete.  This function can
          be used with `completion_function' and is implemented for the
          compatibility with Term::ReadLine::Perl.

    `list_completion_function'
          See the description of section `"Custom Completion"|"Custom
          Completion"' in this node.

`Term::ReadLine::Gnu' Specific Variables

    `do_expand'
          When true, the history expansion is enabled.  By default false.

    `completion_function'
          See the description of section `"Custom Completion"|"Custom
          Completion"' in this node.

    `completion_word'
          A reference to a list of candidates to complete for
          `list_completion_function'.

`Term::ReadLine::Gnu' Specific Commands

    `operate-and-get-next'
          The equivalent of the Korn shell `C-o'
          `operate-and-get-next-history-line' editing command and the Bash
          `operate-and-get-next'.

          This command is bound to `\C-o' by default for the compatibility
          with the Bash and Term::ReadLine::Perl.

    `display-readline-version'
          Shows the version of `Term::ReadLine::Gnu' and the one of the GNU
          Readline Library.

    `change-ornaments'
          Change ornaments interactively.

FILES
=====

`~/.inputrc'
     Readline init file.  Using this file it is possible that you would
     like to use a different set of key bindings.  When a program which
     uses the Readline library starts up, the init file is read, and the
     key bindings are set.

     Conditional key binding is also available.  The program name which is
     specified by the first argument of new method is used as the
     application construct.

     For example, when your program call new method like this;

          ...
          $term = new Term::ReadLine 'PerlSh';
          ...

     your `~/.inputrc' can define key bindings only for it as follows;

          ...
          $if PerlSh
          Meta-Rubout: backward-kill-word
          "\C-x\C-r": re-read-init-file
                  "\e[11~": "Function Key 1"
          $endif
          ...

EXPORTS
=======

   None.

SEE ALSO
========

GNU Readline Library Manual
GNU History Library Manual
Term::ReadLine
Term::ReadLine::Perl (Term-ReadLine-Perl-xx.tar.gz)

and `t/*' in the Term::ReadLine::Gnu distribution
Works which use Term::ReadLine::Gnu

    Perl Debugger
               perl -d

    The Perl Shell (psh)
               http://www.focusresearch.com/gregor/psh/

          The Perl Shell is a shell that combines the interactive nature
          of a Unix shell with the power of Perl.  The goal is to
          eventually have a full featured shell that behaves as expected
          for normal shell activity.  But, the Perl Shell will use Perl
          syntax and functionality for for control-flow statements and
          other things.

    Ghostscript Shell
               http://www.panix.com/~jdf/gshell/

          It provides a friendly way to play with the Ghostscript
          interpreter, including command history and auto-completion of
          Postscript font names and reserved words.

    SPP (Synopsys Plus Perl)
               http://www.stanford.edu/~jsolomon/SPP/

          SPP (Synopsys Plus Perl) is a Perl module that wraps around
          Synopsys' shell programs.  SPP is inspired by the original
          dc_perl written by Steve Golson, but it's an entirely new
          implementation.  Why is it called SPP and not dc_perl?  Well,
          SPP was written to wrap around any of Synopsys' shells.

     If you know any other works which can be listed here, please let me
     know.

AUTHOR
======

   Hiroo Hayashi `<hiroo.hayashi@computer.org>'

   `http://www.perl.org/CPAN/authors/Hiroo_HAYASHI/'

TODO
====

   GTK+ support in addition to Tk.

BUGS
====

   `rl_add_defun()' can define up to 16 functions.

   Ornament feature works only on prompt strings.  It requires very hard
hacking of `display.c:rl_redisplay()' in GNU Readline library to ornament
input line.

   `newTTY()' is not tested yet.


