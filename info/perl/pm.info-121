This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: DNS/ZoneFile,  Next: DNS/ZoneFile/Record,  Prev: DFA/Simple,  Up: Module List

Object-Oriented Management of a Master File
*******************************************

NAME
====

     DNS::ZoneFile - Object-Oriented Management of a Master File

SYNOPSIS
========

     use C<DNS::ZoneFile>;

     my $zone=C<DNS::ZoneFile>->new(
     	$filename_or_file_as_scalar,
     	ZONE_ORIGIN	=>	$ORIGIN,
     	NEW_ZONE	=>	$NEW_ZONE,
     	);

     $zone->addRecord(
     	Domain	=>	$domain,
     	TTL	=>	$ttl,
     	Class	=>	$class,
     	Type	=>	$type,
     	Data	=>	\@arr,
     	);

     $zone->deleteRecord(
     	$domain
     	);
     
     $zone->deleteRecord(
     	$domain,
     	$type
     	);

     $zone->printZone();

DESCRIPTION
===========

my *$zone*=DNS::ZoneFile->new($file,*%params*);
-----------------------------------------------

   new() creates a new DNS::ZoneFile object. It is initialised either from
the filename supplied, or, if the first argument is a reference to a
scalar, then the values is read.

   Params:

ZONE_ORIGIN (.)
     Sets the $ORIGIN for this zone.

NEW_ZONE (false)
     If unset and DNS::ZoneFile can't read any data, then return undef.
     Otherwise create a new SOA. (If this is set, ZONE_ORIGIN shouldn't
     really be set to '.')

*$zone*->*success*();
---------------------

   Returns true if the object was created OK, false if otherwise.

*$zone*->fail();
----------------

   Returns the error message of a a failed object call, or false if the
object was created OK.

*$zone*->*addRecord*(*@RRDATA*);
--------------------------------

   This will add a record to the zone (maybe that should be %RRDATA?)

*$zone*->*deleteRecord*($domain[,$type]);
-----------------------------------------

   This is also unwritten as yet - but I envisage this as a
$zone->deleteRecord("rigel.codix.net","MX"); or
$zone->deleteRecord("alioth.codix.net");

*$zone*->*printZone*();
-----------------------

   Returns a (reference to)? a scalar which is the zone file in full.  or
perhaps it keeps track of the filenames to open?

COMMENTS
========

   I have been recommended to release this bit of code unfinished onto
CPAN by some people - yes Greg, you know who you are - I'm fully aware
that this doesn't abstract enough yet.

   Hopefully doing this will enable me to write it quicker.

   Version: 0.95

AUTHOR
======

   Matthew Byng-Maddick `<matthew@codix.net'>

SEE ALSO
========

   `bind(8)' in this node


File: pm.info,  Node: DNS/ZoneFile/Record,  Next: Data/Address/Standardize,  Prev: DNS/ZoneFile,  Up: Module List

single DNS record in a zone database
************************************

NAME
====

   *DNS::ZoneFile::Record* - single DNS record in a zone database

SYNOPSIS
========

   `use DNS::ZoneFile::Record;'

   $rec=*DNS::ZoneFile::Record*->new(origin,name,type,data...);

   $name=$rec->Name(name);

   $type=$rec->Type(type);

   $address=$rec->Addr(address);

   $serial=$rec->*Serial*(*serialno*);

   $mxcost=$rec->*MXCost*(*MXcost*);

   @record=$rec->*getRecord*();

DESCRIPTION
===========

   *DNS::ZoneFile::Record* is a companion object model to *DNS::ZoneFile*
to provide a seperate object and methods for each of the records in a zone.

   The object methods are as follows:

new(origin,name,type,data...)
-----------------------------

   The new method is to create a new object. origin is used for the value
of the $ORIGIN system in the database, so that the record can be
canonicalised. name is the name relative to origin, or ending in a period
('.') is the canonical name for this record. type is the type of this
record, and affects what data the new method expects, and how it stores it
internally. Valid types are:

SOA
     This is a start of authority record, and expects 7 data arguments, in
     order the host, the hostmaster, the serial number, the refresh time,
     the retry time, the expiry time and the minimum time to live of the
     records.

NS
     This is a nameserver record, detailing nameservers for a domain. This
     just expects one data argument viz the name of the server.

A
     This is a forward record, pointing a name to an IP address, so the
     data argument expected is a dotted quad IP address.

PTR
     This is a reverse record, only really valid in .in-addr.arpa domains,
     and points a number to a name.

MX
     This is a mail exchanger record. The arguments expected are in order
     the cost of using that server (or reverse priority) and the name of
     the server.

CNAME
     This is a canonical name record, it points one name as a redirector
     for another. Its one data argument is the name to point to.

Name(name)
----------

   Returns the full DNS name of the record, also sets the name if an
argument is provided.

Type(type)
----------

   Returns the type of the record, also sets the type if an argument is
provided, although at present this is not recommended, because no data is
moved internally, so things could break.

Addr(*addr*)
------------

   Returns the address that this record points to, this differs in meaning
depending on the record type, the main difference being in the *start of
authority* records, where the address returned is the authoritative host
for this zone. This value can also be set with the optional argument.

*Serial*(*serialno*)
--------------------

   Returns the serial number of the zone file if this is an SOA record,
also sets it if an argument is provided.

*MXCost*(*MXcost*)
------------------

   Returns the cost of this server if this is an MX record, also sets it
if an argument is provided.

*getRecord*()
-------------

   Returns the data for this record in the order that it was input (see
above new() method).

COMMENTS
========

   This is currently alpha software, internal structures are likely to
change at any time.

AUTHOR
======

   Matthew Byng-Maddick <matthew@codix.net>

SEE ALSO
========

   *DNS::ZoneFile*


File: pm.info,  Node: Data/Address/Standardize,  Next: Data/Compare,  Prev: DNS/ZoneFile/Record,  Up: Module List

Standardize U.S. postal addresses.
**********************************

NAME
====

   Data::Address::Standardize - Standardize U.S. postal addresses.

SYNOPSIS
========

     use Data::Address::Standardize;
     ($street, $city, $state, $zip) = std_addr($street, $city, $state, $zip);

   or,

     use Data::Address::Standardize;
     # Read in a pipe-delimited data set like a filter.
     while(<>) {
         chomp;
         my @addr = split('\|');
         push @addr_list, [ @addr ];
     }
     my @std_list = std_addrs(@addr_list);
     # Write a pipe-delimited data set to standard output.
     foreach (@std_list) {
         print join('|', @$_), "\n";
     }

DESCRIPTION
===========

   The United States Postal Service (USPS) has on its web site an HTML
form at `http://www.usps.gov/ncsc/lookups/lookup_zip+4.html' for
standardizing an address. Given a firm, urbanization, street address,
city, state, and zip, it will put the address into standard form (provided
the address is in their database) and display a page with the resulting
address.

   This Perl module provides a programmatic interface to this service, so
you can write a program to process your entire personal address book
without having to manually type them all in to the form.

   Because the USPS could change or remove this functionality at any time,
be prepared for the possibility that this code may fail to function. In
fact, as of this version, there is no error checking in place, so if they
do change things, this code will most likely fail in a noisy way. If you
discover that the service has changed, please email the author your
findings.

   If an error occurs in trying to standardize the address, then no array
will be returned. Otherwise, a four-element array will be returned.

   To see debugging output, set $Data::Address::Standardize::verbose to a
true value.

TERMS OF USE
============

   BE SURE TO READ AND FOLLOW THE UNITED STATES POSTAL SERVICE TERMS OF USE
PAGE AT `http://www.usps.gov/disclaimer.html'. IN PARTICULAR, NOTE THAT
THEY DO NOT PERMIT THE USE OF THEIR WEB SITE'S FUNCTIONALITY FOR COMMERCIAL
PURPOSES. DO NOT USE THIS CODE IN A WAY THAT VIOLATES THE TERMS OF USE.

   The author believes that the example usage given above does not violate
these terms, but sole responsibility for conforming to the terms of use
belongs to the user of this code, not the author.

AUTHOR
======

   Gregor N. Purdy, `gregor@focusresearch.com'.

COPYRIGHT
=========

   Copyright (C) 1999-2000 Gregor N. Purdy. All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.


File: pm.info,  Node: Data/Compare,  Next: Data/DRef,  Prev: Data/Address/Standardize,  Up: Module List

compare perl data structures
****************************

NAME
====

   Data::Compare - compare perl data structures

SYNOPSIS
========

     use Data::Compare;

     my $h = { 'foo' => [ 'bar', 'baz' ], 'FOO' => [ 'one', 'two' ] };
     my @a1 = ('one', 'two');
     my @a2 = ('bar', 'baz');
     my %v = ( 'FOO', \@a1, 'foo', \@a2 );

     # simple procedural interface
     print 'structures of $h and \%v are ',
       Compare($h, \%v) ? "" : "not ", "identical.\n";

     # OO usage
     my $c = new Data::Compare($h, \%v);
     print 'structures of $h and \%v are ',
       $c->Cmp ? "" : "not ", "identical.\n";
     # or
     my $c = new Data::Compare;
     print 'structures of $h and \%v are ',
       $c->Cmp($h, \%v) ? "" : "not ", "identical.\n";

DESCRIPTION
===========

   Compare two perl data structures recursively. Returns 0 if the
structures differ, else returns 1.

BUGS
====

   `Data::Compare' cheats with REF, CODE and GLOB references. If such a
reference is encountered in a structure being processed, the result is 0
unless references are equal.

   Currently, there is no way to compare two compiled piece of code with
perl so there is no hope to add a better CODE references support in
`Data::Compare' in a near future.

AUTHOR
======

   Fabien Tassin        fta@oleane.net

   Copyright (c) 1999 Fabien Tassin. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

VERSION
=======

   Version 0.01    (21 Apr 1999)

SEE ALSO
========

   perl(1), perlref(1)


File: pm.info,  Node: Data/DRef,  Next: Data/Direct,  Prev: Data/Compare,  Up: Module List

Delimited-key access to complex data structures
***********************************************

NAME
====

   Data::DRef - Delimited-key access to complex data structures

SYNOPSIS
========

     use Data::DRef qw( :dref_access );
     my $hash = { 'items' => [ 'first' ] };
     print get_value_for_dref($hash, 'items.0');
     set_value_for_dref( $hash, 'items.1', 'second' );
     
     set_value_for_root_dref( 'myhash', $hash );
     print get_value_for_root_dref('myhash.items.0');

     use Data::DRef qw( :select );
     matching_keys($target, %filter_criteria) : $key or @keys
     matching_values($target, %filter_criteria) : $item or @items

     use Data::DRef qw( :index );
     index_by_drefs($target, @drefs) : $index
     unique_index_by_drefs($target, @drefs) : $index
     ordered_index_by_drefs( $target, $index_dref ) : $entry_ary
     
     use Data::DRef qw( :leaf );
     leaf_drefs($target) : @drefs
     leaf_values( $target ) : @values
     leaf_drefs_and_values( $target ) : %dref_value_pairs

DESCRIPTION
===========

   Data::DRef provides a streamlined interface for accessing values within
nested Perl data structures. These structures are generally networks of
hashes and arrays, some of which may be blessed into various classes,
containing a mix of simple scalar values and references to other items in
the structure.

   The Data::DRef functions allow you to use delimited key strings to set
and retrieve values at desired nodes within these structures. These
functions are slower than direct variable access, but provide additional
flexibility for high-level scripting and other late-binding behaviour. For
example, a web-based application could use DRefs to simplify customization,
allowing the user to refer to arguments processed by CGI.pm in fairly
readable way, such as `query.param.*foo*'.

   A suite of utility functions, previous maintained in a separate
Data::Collection module, performs a variety of operations across nested
data structures. Because the Data::DRef abstraction layer is used, these
functions should work equally well with arrays, hashes, or objects that
provide their own key-value interface.

REFERENCE
=========

Value-For-Key Interface
-----------------------

   The first set of functions define our core key-value interface, and
provide its implementation for references to Perl arrays and hashes. For
example, direct access to array and hash keys usually looks like this:

     print $employee->[3];
     $person->{'name'} = 'Joe';

   Using these functions, you could replace the above statements with:

     print get_value_for_key( $employee, 3 );
     set_value_for_key( $person, 'name', 'Joe' );

   Each of these functions checks for object methods as described below.

get_keys($target) : @keys
     Returns a list of keys for which this item would be able to provide a
     value. For hash refs, returns the hash keys; for array refs, returns a
     list of numbers from 0 to $#; otherwise returns nothing.

get_values($target) : @values
     Returns a list of values for this item. For hash refs, returns the
     hash values; for array refs, returns the array contents; otherwise
     returns nothing.

get_value_for_key($target, $key) : $value
     Returns the value associated with this key. For hash refs, returns the
     value at this key, if present; for array refs, returns the value at
     this index, or complains if it's not numeric.

set_value_for_key($target, $key, $value)
     Sets the value associated with this key. For hash refs, adds or
     overwrites the entry for this key; for array refs, sets the value at
     this index, or complains if it's not numeric.

get_or_create_value_for_key($target, $key) : $value
     Gets value associated with this key using get_value_for_key, or if
     that value is undefined, sets the value to refer to a new anonymous
     hash using set_value_for_key and returns that reference.

get_reference_for_key($target, $key) : $value_reference
     Returns a reference to the scalar which is used to hold the value
     associated with this key.

Multiple-Key Chaining
---------------------

   Frequently we wish to access values at some remove within a structure
by chaining through a list of references. Programmatic access to these
values within Perl usually looks something like this:

     print $report->{'employees'}[3]{'id'};
     $report->{'employees'}[3]{'name'} = 'Joe';

   Using these functions, you could replace the above statements with:

     print get_value_for_keys( $report, 'employees', 3, 'id' );
     set_value_for_keys( $report, 'Joe', 'employees', 3, 'name' );

   These functions also support the "m_*" method delegation described
above.

get_value_for_keys($target, @keys) : $value
     Starting at the target, look up each of the provided keys sequentially
     from the results of the previous one, returning the final value.
     Return value is undefined if at any time we find a key for which no
     value is present.

set_value_for_keys($target, $value, @keys)
     Starting at the target, look up each of the provided keys sequentially
     from the results of the previous one; when we reach the final key, use
     set_value_for_key to make the assignment. If an intermediate value is
     undefined, replaces it with an empty hash to hold the next key-value
     pair.

get_or_create_value_for_keys($target, @keys) : $value
     As above.

get_reference_for_keys($target, @keys) : $val_ref
     As above.

Object Overrides
----------------

   Each of the value-for-key and multiple-key functions first check for
methods with similar names preceeded by "m_" and, if present, uses that
implementation. For example, callers can consistently request
`get_value_for_key($foo, $key)', but in cases where `$foo' supports a
method named `m_get_value_for_key', its results will be returned instead.

   Classes that wish to provide alternate DRef-like behavior or generate
values on demand should implement these methods in their packages.  A
Data::DRef::MethodBased class is provided for use by objects which use
methods to get and set attributes. By making your package a subclass of
MethodBased you'll inherit m_get_value_for_key and m_set_value_for_key
methods which treat the key as a method name to invoke.

DRef Syntax
-----------

   In order to simplify expression of the lists of keys used above, we
define a string format in which they may be represented. A DRef string is
composed of a series of simple scalar keys, each escaped with
String::Escape's printable() function, joined with the $Separator
character, '.'.

$Separator
     The multiple-key delimiter character, by default ., the period
     character.

get_key_drefs($target) : @drefs
     Uses get_keys to determine the available keys for this target, and
     then returns an appropriately-escaped version of each of them.

dref_from_keys( @keys ) : $dref
     Escapes and joins the provided keys to create a dref string.

keys_from_dref( $dref ) : @keys
     Splits and unescapes a dref string to its consituent keys.

join_drefs( @drefs ) : $dref
     Joins already-escaped dref strings into a single dref.

unshift_dref_key( $dref, $key )
     Modify the provided dref string by escaping and prepending the
     provided key.  Note that the original $dref variable is altered.

shift_dref_key( $dref ) : $key
     Modify the provided dref string by removing and unescaping the first
     key.  Note that the original $dref variable is altered, and set to "
     when the last key is removed.

DRef Pragmas
------------

   Several types of parenthesized expressions are supported as extension
mechanisms for dref strings. Nested parentheses are supported, with the
innermost parentheses resolved first.

   Continuing the above example, one could write:

     set_value_for_root_dref('empl_number', 3);
     ...
     print get_value_for_dref($report, 'employees.(#empl_number).name');

resolve_pragmas( $dref_with_embedded_parens ) : $dref
resolve_pragmas( $dref_with_embedded_parens ) : ($dref, %options)
     Calling resolve_pragmas() causes these expressions to be evaluated,
     and an expanded version of the dref is returned. In a list context,
     also returns a list of key-value pairs that may contain pragma
     information.

    (#*dref*)
          Parenthesized expressions begining with $DRefPrefix, the "#"
          character by default, are replaced with the Root-relative value
          for that *dref* using get_value_for_root_dref().

    (!flag)
          A flag indicating some optional or accessory behavior. Removed
          from the string. Sets $options{flag} to 1.

DRef Access
-----------

   These functions provide the main public interface for dref-based access
to values in nested data structures. They invoke the equivalent
..._value_for_keys() function after expanding and spliting the provided
drefs.

   Using these functions, you could replace the above statements with:

     print get_value_for_dref( $report, 'employees.3.id' );
     set_value_for_dref( $report, 'employees.3.name', 'Joe' );

get_value_for_dref($target, $dref) : $value
     Resolve pragmas and split the provided dref, then use
     get_value_for_keys to look those keys up starting with target.

set_value_for_dref($target, $dref, $value)
     Resolve pragmas and split the provided dref, then use
     set_value_for_keys.

Shared Data Graph Entry
-----------------------

   Data::DRef also provides a common point-of-entry datastructure, refered
to as $Root. Objects or structures accessible through $Root can be refered
to identically from any package using the get_value_for_root_dref and
set_value_for_root_dref functions. Here's another example:

     set_value_for_root_dref('report', $report);
     print get_value_for_root_dref('report.employees.3.name');

$Root
     The data graph entry point, by default a reference to an anonymous
     hash.

get_value_for_root_dref($dref) : $value
     Returns the value for the provided dref, starting at the root.

set_value_for_root_dref($dref, $value) : $value
     Sets the value for the provided dref, starting at the root.

get_value_for_optional_dref($literal_or_prefixed_dref) : $value
     If the argument begins with $DRefPrefix, the "#" character by default,
     the remainder is passed through get_value_for_root_dref(); otherwise
     it is returned unchanged.

Select by DRefs
---------------

   The selection functions extract and return elements of a collection by
evaluating them against a provided hash of criteria. When called in a
scalar context, they will return the first sucessful match; in a list
context, they will return all sucessful matches.

   The keys in the criteria hash are drefs to check for each candidate; a
match is sucessful if for each of the provided drefs, the candidate
returns the same value that is associated with that dref in the criteria
hash. To check the value itself, rather than looking up a dref, use undef
as the hash key.

matching_keys($target, %dref_value_criteria_pairs) : $key or @keys
     Returns keys of the target whose corresponding values match the
     provided criteria.

matching_values($target, %dref_value_criteria_pairs) : $item or @items
     Returns values of the target which match the provided criteria.

Index by DRefs
--------------

   The indexing functions extract the values from some target structure,
then return a new structure containing references to those same values.

index_by_drefs($target, @drefs) : $index
     Generates a hash, or series of nested hashes, of arrays containing
     values from the target. A single dref argument produces a
     single-level index, a hash which maps each value obtained to an array
     of values which returned them; multiple dref arguments create nested
     hashes.

unique_index_by_drefs($target, @drefs) : $index
     Similar to index_by_drefs, except that only the most-recently visited
     single value is stored at each point in the index, rather than an
     array.

ordered_index_by_drefs( $target, $index_dref ) : $entry_ary
     Constructs a single-level index while preserving the order in which
     top-level index keys are discovered. An array of hashes is returned,
     each containing one of the index keys and the array of associated
     values.

DRefs to Leaf nodes
-------------------

   These functions explore all of the references in the network of
structures accessible from some starting point, and provide access to the
outermost (non-reference) items. For a tree structure, this is equivalent
to listing the leaf nodes, but these functions can also be used in
structures with circular references.

leaf_drefs($target) : @drefs
     Returns a list of drefs to the outermost values.

leaf_values( $target ) : @values
     Returns a list of the outermost values.

leaf_drefs_and_values( $target ) : %dref_value_pairs
     Returns a flat hash of the outermost drefs and values.

Compatibility
-------------

   To provide compatibility with earlier versions of this module, many of
the functions above are also accesible through an alias with the old name.

EXAMPLES
========

   Here is a sample data structure which will be used to illustrate various
example function calls. Note that the individual hashes shown below are
only refered to in the following example results, not completely copied.

     $spud : {
       'type'=>'tubers', 'name'=>'potatoes', 'color'=>'red', 'size'=>[2,3,5]
     }
     $apple : {
       'type'=>'fruit', 'name'=>'apples', 'color'=>'red', 'size'=>[2,2,2]
     }
     $orange : {
       'type'=>'fruit', 'name'=>'oranges', 'color'=>'orange', 'size'=>[1,1,1]
     }
     
     $produce_info : [ $spud, $apple, $orange, ];

Select by DRefs
---------------

     matching_keys($produce_info, 'type'=>'tubers') : ( 0 )
     matching_keys($produce_info, 'type'=>'fruit') : ( 1, 2 )
     matching_keys($produce_info, 'type'=>'fruit', 'color'=>'red' ) : ( 1 )
     matching_keys($produce_info, 'type'=>'tubers', 'color'=>'orange' ) : ( )

     matching_values($produce_info, 'type'=>'fruit') : ( $apple, $orange )
     matching_values($produce_info, 'type'=>'fruit', 'color'=>'red' ) : ( $apple )

Index by DRefs
--------------

     index_by_drefs($produce_info, 'type') : {
       'fruit' =>  [ $apple, $orange ],
       'tubers' => [ $spud ],
     }
     
     index_by_drefs($produce_info, 'color', 'type') : {
       'red' => {
         'fruit' => [ $apple ],
         'tubers' => [ $spud ],
       },
       'orange' => {
         'fruit' => [ $orange ],
       },
     }

     unique_index_by_drefs($produce_info, 'type') : {
       'fruit' => $orange,
       'tubers' => $spud,
     }

     ordered_index_by_drefs($produce_info, 'type') : [
       {
         'value' => 'tubers',
         'items' => [ $spud ],
       },
       {
         'value' => 'fruit',
         'items' => [ $orange, $apple ],
       },
     ]

DRefs to Leaf nodes
-------------------

     leaf_drefs($spud) : ( 'type', 'name', 'color', 'size.0', 'size.1', 'size.2' )

     leaf_values($spud) : ( 'tubers', 'potatoes', 'red', '2', '3', '5' )

     leaf_drefs_and_values($spud) : (
       'type' => 'tubers', 'name' => 'potatoes', 'color' => 'red',
       'size.0' => 2, 'size.1' => 3, 'size.2' => 5
     )

Object Overrides
----------------

   Here's a get_value_for_key method for an object which provides a
calculated timestamp value:

     package Clock;
     
     sub new { bless { @_ }; }
     
     sub m_get_value_for_key {
       my ($self, $key) = @_;
       return time() if ( $key eq 'timestamp' );
       return $self->{ $key };
     }
     
     package main;
     
     set_value_for_root_dref( 'clock', new Clock ( name => "Clock 1" ) );
     ...
     print get_value_for_root_dref('clock.timestamp');

STATUS AND SUPPORT
==================

   This release of Data::DRef is intended for public review and feedback.
This is the most recent version of code that has been used for several
years and thoroughly tested, however, the interface has recently been
overhauled and it should be considered "alpha" pending that feedback.

     Name            DSLI  Description
     --------------  ----  ---------------------------------------------
     Data::
     ::DRef          adph  Nested data access using delimited strings

   You will also need the String::Escape module from CPAN or
www.evoscript.com.

   Further information and support for this module is available at
<www.evoscript.com>.

   Please report bugs or other problems to <bugs@evoscript.com>.

   There is one known bug in this version:

   * We don't always properly escape and unescape special characters within
     DRef strings or protect $Separators embedded within a subkey. This is
     expected to change soon.

   There is one major change under consideration:

   * Perhaps a minimal method-based implementation similar to that used in
     Data::DRef::MethodBased should be exported to UNIVERSAL, rather than
     requiring all sorts of unrelated classes to establish a dependancy on
     this module.  Prototype checking might prove to be useful here.

AUTHORS AND COPYRIGHT
=====================

   Copyright 1996, 1997, 1998, 1999 Evolution Online Systems, Inc.
<www.evolution.com>

   You may use this software for free under the terms of the Artistic
License.

   Contributors: M. Simon Cavalletto <simonm@evolution.com>, E. J. Evans
<piglet@evolution.com>


File: pm.info,  Node: Data/Direct,  Next: Data/Dump,  Prev: Data/DRef,  Up: Module List

Perl module to emulate seqeuntial access to SQL tables.
*******************************************************

NAME
====

   Data::Direct - Perl module to emulate seqeuntial access to SQL tables.

SYNOPSIS
========

In a script:
------------

   use Data::Direct;

   $dd = new Data::Direct("dbi:Informix:FBI", "bill_c", "M0n|c4",
"porn_suppliers", "PRICE < 99.99", "ORDER BY PUBLICATION_DATE" || die
"Failed to connect";

   Last two arguments can be ommitted.

     while (!$dd->eof) {
     		# Iterate over all records
     if ($dd{'LAST_MODIFIED'}) {
     	$dd->delete;
     		# Mark RIP flag
     	next;
     }
     		# Change fields
     $dd->{'KILL'}++ if ($dd->{'REVENUE'} > 199.99);
     $dd->update;
     		# Update record in memory
     $dd->next;
     		# Goto next record
     }

   $dd->addnew;                            # Add a new record
$dd->{'PRICE'} = 999.99; $dd->{'KILL'} = 0; $dd->{'REVENUE'} = 199.99;
$dd->update;                            # Update new record in memory

   $dd->flush;                             # Rewrite table

From the command prompt:
------------------------

*prompt %* perl -MData::Direct -e 'edit("dbi::XBase::/var/db/files",  "contacts");'
*prompt %* perl -MData::Direct -e 'edit("dbi::Oracle::CIA",  "weapons");' /U 'bill_c' /P 'M0n1c4'  /W "EXPIRES <= SYS_DATE()" /A "GROUP BY PRICE"
DESCRIPTION
===========

   Data::Direct selects rows from a table and lets you updated them in a
memory array. Upon calling the flush method, it erases the records from
the table and inserts them from the array.  You can supply a WHERE filter
to be applied both on query and on deletion, and additional SQL code for
sorting the records.

OPTIONS
=======

Constructor
-----------

new($dsn, $user, $pass, $table [, $where_clause [, $additional_select_code]] Connects to the DBI DSN specified, using #user and $pass. $where_clause and $additional_select_code will be added to your SQL code. After that, reads all the records to memory.
Navigating
----------

next
     Fetches the next record. Returns undef if gone past end.

back
     Fetches the previous record. Returns undef if gone past beginning.

eof
     Returns true if cursor is after all the records.

bof
     Simillar, checks beginning of table.

recs
     Returns the number of records in the buffer

rows
     Returns the number of records in the buffer which are not deleted.
     recs and rows are not the same!

*setbookmark*($name)
     Sets a named bookmark, to be used for gotobookmark.

*gotobookmark*($name)
     Takes the cursor to the specific bookmark.

fetch(*$rownumber*)
     Retrieve a numbered record.

cursor
     Returns the row number the cursor is at.

Manipulating records
--------------------

bind(*$column* => *\$var*, *$column* => *\$var*...)
     Binds a column to a scalar, using a scalar reference.

*bindsimple*($package)
     Binds each column to a variable with the same name, under the package
     given. Use bindsimple with no parameters to bind to the main
     namespace.

update
     Update record after fields have been changed by accessing the members
     of the object or the bound variables.

addnew
     Add a new record and point the cursor on it.

delete
     Mark a record for deletion.

undelete
     Unmark a record for deletion.

isdeleted
     Check if a record is marked for deletion.

Automatic editing
-----------------

spawn($editor, $packing_instructions, $unpacking_instructions)
     Writes a text file where every line represents a record, launch the
     process $editor, then update the table with the saved file.  Records
     are serialized and deserialized by the code references in the last
     parameters.

     $dd->spawn("grep <-v> <-i> Bill", sub {join(":", @_);}, 	sub
     {my $l = <$_>; chop $l; split(/:/, $l);});

spawn(*$editor*, *$delimiter*)
     Uses the string as a delimiter to serialize and deserialize records.

spawn(*$editor*)
     Uses CSV format to serialize and deserialize records.

spawn
     Launches vi or whatever $ENV{'EDITOR'} points to as an editor.

AUTHOR
======

   Ariel Brosh, *schop@cpan.org*

SEE ALSO
========

   `DBI' in this node.


File: pm.info,  Node: Data/Dump,  Next: Data/DumpXML,  Prev: Data/Direct,  Up: Module List

Pretty printing of data structures
**********************************

NAME
====

   Data::Dump - Pretty printing of data structures

SYNOPSIS
========

     use Data::Dump qw(dump);

     $str = dump(@list)
     @copy_of_list = eval $str;

DESCRIPTION
===========

   This module provide a single function called dump() that takes a list
of values as argument and produce a string as result.  The string contains
perl code that when evaled will produce a deep copy of the original
arguments.  The string is formatted for easy reading.

   If dump() is called in void context, then the dump will be printed on
STDERR instead of being returned.

   If you don't like to import a function that overrides Perl's
not-so-useful builtin, then you can also import the same function as pp(),
mnemonic for "pretty-print".

HISTORY
=======

   The `Data::Dump' module grew out of frustration with Sarathy's
in-most-cases-excellent Data::Dumper.  Basic ideas and some code is shared
with Sarathy's module.

   The `Data::Dump' module provide a much simpler interface than
Data::Dumper.  No OO interface is available and there are no configuration
options to worry about (yet :-).  The other benefit is that the dump
produced does not try to set any variables.  It only returns what is
needed to produce a copy of the arguments.  It means that `dump("foo")'
simply returns `"foo"', and `dump(1..5)' simply returns `(1, 2, 3, 4, 5)'.

SEE ALSO
========

   *Note Data/Dumper: Data/Dumper,, *Note Storable: Storable,

AUTHORS
=======

   The `Data::Dump' module is written by Gisle Aas <gisle@aas.no>, based
on Data::Dumper by Gurusamy Sarathy <gsar@umich.edu>.

     Copyright 1998-2000 Gisle Aas.
     Copyright 1996-1998 Gurusamy Sarathy.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Data/DumpXML,  Next: Data/DumpXML/Parser,  Prev: Data/Dump,  Up: Module List

Dump arbitrary data structures as XML
*************************************

NAME
====

   Data::DumpXML - Dump arbitrary data structures as XML

SYNOPSIS
========

     use Data::DumpXML qw(dump_xml);
     $xml = dump_xml(@list)

DESCRIPTION
===========

   This module provide a single function called dump_xml() that takes a
list of something as argument and produce a string as result.

   The string returned is an XML document that represents any perl data
structure passed in.  The following DTD is used:

     <!DOCTYPE data [
      <!ENTITY % scalar "undef | str | ref | alias">

     <!ELEMENT data (%scalar;)*>
     <!ELEMENT undef EMPTY>
     <!ELEMENT str (#PCDATA)>
     <!ELEMENT ref (%scalar; | array | hash | glob | code)>
     <!ELEMENT alias EMPTY>
     <!ELEMENT array (%scalar;)*>
     <!ELEMENT hash  (key, (%scalar;))*>
     <!ELEMENT key (#PCDATA)>
     <!ELEMENT glob EMPTY>
     <!ELEMENT code EMPTY>

     <!ENTITY % stdattlist 'id       ID             #IMPLIED
                            class    CDATA          #IMPLIED'>
     <!ENTITY % encoding   'encoding (plain|base64) "plain"'>

     <!ATTLIST undef %stdattlist;>
     <!ATTLIST ref %stdattlist;>
     <!ATTLIST undef %stdattlist;>
     <!ATTLIST array %stdattlist;>
     <!ATTLIST hash %stdattlist;>
     <!ATTLIST glob %stdattlist;>
     <!ATTLIST code %stdattlist;>

     <!ATTLIST str %stdattlist; %encoding;>
     <!ATTLIST key %encoding;>

     <!ATTLIST alias ref IDREF #IMPLIED>
       ]>

   As an example of the XML documents producted; the following call:

     $a = bless [1,2], "Foo";
     $a->[2] = \$a;
     $b = $a;
     dump_xml($a, $b);

   will produce:

     <?xml version="1.0" encoding="US-ASCII"?>
     <data>
      <ref id="r1">
       <array class="Foo" id="r2">
        <str>1</str>
        <str>2</str>
        <ref>
         <alias ref="r1"/></ref></array></ref>
      <ref>
       <alias ref="r2"/></ref></data>

   If dump_xml() is called in void context, then the dump will be printed
on STDERR instead of being returned.  For compatibility with `Data::Dump'
there is also an alias for dump_xml() simply called dump().

   You can set the variable $Data::DumpXML::INDENT to control indenting
before calling dump_xml().  To suppress indenting set it as "".

   The `Data::DumpXML::Parser' is a class that can restore datastructures
dumped by dump_xml().

BUGS
====

   Class names with 8-bit characters will be dumped as Latin-1, but
converted to UTF-8 when restored by the Data::DumpXML::Parser.

   The content of globs and subroutines are not dumped.  They are restored
as the strings; "** glob **" and "** code **".

   LVALUE and IO objects are not dumped at all.  They will simply
disappear from the restored data structure.

SEE ALSO
========

   *Note Data/DumpXML/Parser: Data/DumpXML/Parser,, *Note XML/Parser:
XML/Parser,, *Note XML/Dumper: XML/Dumper,, *Note Data/Dump: Data/Dump,

AUTHORS
=======

   The `Data::DumpXML' module is written by Gisle Aas <gisle@aas.no>,
based on `Data::Dump'.

   The `Data::Dump' module was written by Gisle Aas, based on Data::Dumper
by Gurusamy Sarathy <gsar@umich.edu>.

     Copyright 1998-2000 Gisle Aas.
     Copyright 1996-1998 Gurusamy Sarathy.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Data/DumpXML/Parser,  Next: Data/Dumper,  Prev: Data/DumpXML,  Up: Module List

Restore data dumped by Data::DumpXML
************************************

NAME
====

   Data::DumpXML::Parser - Restore data dumped by Data::DumpXML

SYNOPSIS
========

     use Data::DumpXML::Parser;

     my $p = Data::DumpXML::Parser->new;
     my $data = $p->parsefile(shift || "test.xml");

DESCRIPTION
===========

   The `Data::DumpXML::Parser' is an XML::Parser subclass that will
recreate the data structure from the XML document produced by
`Data::DumpXML'.  The parserfile() method returns a reference to an array
of the values dumped.

   The constructor method new() takes a single additional argument to that
of XML::Parser :

Blesser => CODEREF
     A subroutine that is invoked for blessing of restored objects.  The
     subroutine is invoked with two arguments; a reference to the object
     and a string containing the class name.  If not provided the built in
     bless function is used.

     For situations where the input file cannot necessarily be trusted and
     blessing arbitrary Classes might give the ability of malicious input
     to exploit the DESTROY methods of modules used by the code it is a
     good idea to provide an noop blesser:

          my $p = Data::DumpXML::Parser->new(Blesser => sub {});

SEE ALSO
========

   *Note Data/DumpXML: Data/DumpXML,, *Note XML/Parser: XML/Parser,

AUTHOR
======

   Copyright 2000 Gisle Aas.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Data/Dumper,  Next: Data/FixedFormat,  Prev: Data/DumpXML/Parser,  Up: Module List

stringified perl data structures, suitable for both printing and eval
*********************************************************************

NAME
====

   Data::Dumper - stringified perl data structures, suitable for both
printing and eval

SYNOPSIS
========

     use Data::Dumper;

     # simple procedural interface
     print Dumper($foo, $bar);

     # extended usage with names
     print Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);

     # configuration variables
     {
       local $Data::Dump::Purity = 1;
       eval Data::Dumper->Dump([$foo, $bar], [qw(foo *ary)]);
     }

     # OO usage
     $d = Data::Dumper->new([$foo, $bar], [qw(foo *ary)]);
        ...
     print $d->Dump;
        ...
     $d->Purity(1)->Terse(1)->Deepcopy(1);
     eval $d->Dump;

DESCRIPTION
===========

   Given a list of scalars or reference variables, writes out their
contents in perl syntax. The references can also be objects.  The contents
of each variable is output in a single Perl statement.  Handles
self-referential structures correctly.

   The return value can be evaled to get back an identical copy of the
original reference structure.

   Any references that are the same as one of those passed in will be named
`$VAR'n (where n is a numeric suffix), and other duplicate references to
substructures within `$VAR'n will be appropriately labeled using arrow
notation.  You can specify names for individual values to be dumped if you
use the `Dump()' method, or you can change the default `$VAR' prefix to
something else.  See $Data::Dumper::Varname and $Data::Dumper::Terse below.

   The default output of self-referential structures can be evaled, but the
nested references to `$VAR'n will be undefined, since a recursive
structure cannot be constructed using one Perl statement.  You should set
the `Purity' flag to 1 to get additional statements that will correctly
fill in these references.

   In the extended usage form, the references to be dumped can be given
user-specified names.  If a name begins with a *, the output will describe
the dereferenced type of the supplied reference for hashes and arrays, and
coderefs.  Output of names will be avoided where possible if the `Terse'
flag is set.

   In many cases, methods that are used to set the internal state of the
object will return the object itself, so method calls can be conveniently
chained together.

   Several styles of output are possible, all controlled by setting the
`Indent' flag.  See `Configuration Variables or Methods' in this node below
for details.

Methods
-------

PACKAGE->new(*ARRAYREF [*, *ARRAYREF]*)
     Returns a newly created Data::Dumper object.  The first argument is an
     anonymous array of values to be dumped.  The optional second argument
     is an anonymous array of names for the values.  The names need not
     have a leading `$' sign, and must be comprised of alphanumeric
     characters.  You can begin a name with a * to specify that the
     dereferenced type must be dumped instead of the reference itself, for
     ARRAY and HASH references.

     The prefix specified by $Data::Dumper::Varname will be used with a
     numeric suffix if the name for a value is undefined.

     Data::Dumper will catalog all references encountered while dumping the
     values. Cross-references (in the form of names of substructures in
     perl syntax) will be inserted at all possible points, preserving any
     structural interdependencies in the original set of values.
     Structure traversal is depth-first,  and proceeds in order from the
     first supplied value to the last.

*$OBJ*->Dump  or  PACKAGE->Dump(*ARRAYREF [*, *ARRAYREF]*)
     Returns the stringified form of the values stored in the object
     (preserving the order in which they were supplied to new), subject to
     the configuration options below.  In an array context, it returns a
     list of strings corresponding to the supplied values.

     The second form, for convenience, simply calls the new method on its
     arguments before dumping the object immediately.

*$OBJ*->Dumpxs  or  PACKAGE->Dumpxs(*ARRAYREF [*, *ARRAYREF]*)
     This method is available if you were able to compile and install the
     XSUB extension to Data::Dumper. It is exactly identical to the `Dump'
     method above, only about 4 to 5 times faster, since it is written
     entirely in C.

*$OBJ*->Seen(*[HASHREF]*)
     Queries or adds to the internal table of already encountered
     references.  You must use Reset to explicitly clear the table if
     needed.  Such references are not dumped; instead, their names are
     inserted wherever they are encountered subsequently.  This is useful
     especially for properly dumping subroutine references.

     Expects a anonymous hash of name => value pairs.  Same rules apply
     for names as in new.  If no argument is supplied, will return the
     "seen" list of name => value pairs, in an array context.  Otherwise,
     returns the object itself.

*$OBJ*->Values(*[ARRAYREF]*)
     Queries or replaces the internal array of values that will be dumped.
     When called without arguments, returns the values.  Otherwise,
     returns the object itself.

*$OBJ*->Names(*[ARRAYREF]*)
     Queries or replaces the internal array of user supplied names for the
     values that will be dumped.  When called without arguments, returns
     the names.  Otherwise, returns the object itself.

*$OBJ*->Reset
     Clears the internal table of "seen" references and returns the object
     itself.

Functions
---------

Dumper(LIST)
     Returns the stringified form of the values in the list, subject to the
     configuration options below.  The values will be named `$VAR'n in the
     output, where n is a numeric suffix.  Will return a list of strings
     in an array context.

DumperX(LIST)
     Identical to the `Dumper()' function above, but this calls the XSUB
     implementation.  Only available if you were able to compile and
     install the XSUB extensions in Data::Dumper.

Configuration Variables or Methods
----------------------------------

   Several configuration variables can be used to control the kind of
output generated when using the procedural interface.  These variables are
usually localized in a block so that other parts of the code are not
affected by the change.

   These variables determine the default state of the object created by
calling the new method, but cannot be used to alter the state of the object
thereafter.  The equivalent method names should be used instead to query
or set the internal state of the object.

   The method forms return the object itself when called with arguments,
so that they can be chained together nicely.

$Data::Dumper::Indent  or  *$OBJ*->Indent(*[NEWVAL]*)
     Controls the style of indentation.  It can be set to 0, 1, 2 or 3.
     Style 0 spews output without any newlines, indentation, or spaces
     between list items.  It is the most compact format possible that can
     still be called valid perl.  Style 1 outputs a readable form with
     newlines but no fancy indentation (each level in the structure is
     simply indented by a fixed amount of whitespace).  Style 2 (the
     default) outputs a very readable form which takes into account the
     length of hash keys (so the hash value lines up).  Style 3 is like
     style 2, but also annotates the elements of arrays with their index
     (but the comment is on its own line, so array output consumes twice
     the number of lines).  Style 2 is the default.

$Data::Dumper::Purity  or  *$OBJ*->Purity(*[NEWVAL]*)
     Controls the degree to which the output can be evaled to recreate the
     supplied reference structures.  Setting it to 1 will output
     additional perl statements that will correctly recreate nested
     references.  The default is 0.

$Data::Dumper::Pad  or  *$OBJ*->Pad(*[NEWVAL]*)
     Specifies the string that will be prefixed to every line of the
     output.  Empty string by default.

$Data::Dumper::Varname  or  *$OBJ*->Varname(*[NEWVAL]*)
     Contains the prefix to use for tagging variable names in the output.
     The default is "VAR".

$Data::Dumper::Useqq  or  *$OBJ*->Useqq(*[NEWVAL]*)
     When set, enables the use of double quotes for representing string
     values.  Whitespace other than space will be represented as
     `[\n\t\r]', "unsafe" characters will be backslashed, and unprintable
     characters will be output as quoted octal integers.  Since setting
     this variable imposes a performance penalty, the default is 0.  The
     `Dumpxs()' method does not honor this flag yet.

$Data::Dumper::Terse  or  *$OBJ*->Terse(*[NEWVAL]*)
     When set, Data::Dumper will emit single, non-self-referential values
     as atoms/terms rather than statements.  This means that the `$VAR'n
     names will be avoided where possible, but be advised that such output
     may not always be parseable by eval.

$Data::Dumper::Freezer  or  $OBJ->Freezer(*[NEWVAL]*)
     Can be set to a method name, or to an empty string to disable the
     feature.  Data::Dumper will invoke that method via the object before
     attempting to stringify it.  This method can alter the contents of
     the object (if, for instance, it contains data allocated from C), and
     even rebless it in a different package.  The client is responsible
     for making sure the specified method can be called via the object,
     and that the object ends up containing only perl data types after the
     method has been called.  Defaults to an empty string.

$Data::Dumper::Toaster  or  $OBJ->Toaster(*[NEWVAL]*)
     Can be set to a method name, or to an empty string to disable the
     feature.  Data::Dumper will emit a method call for any objects that
     are to be dumped using the syntax `bless(DATA, CLASS)-'METHOD()>.
     Note that this means that the method specified will have to perform
     any modifications required on the object (like creating new state
     within it, and/or reblessing it in a different package) and then
     return it.  The client is responsible for making sure the method can
     be called via the object, and that it returns a valid object.
     Defaults to an empty string.

$Data::Dumper::Deepcopy  or  $OBJ->Deepcopy(*[NEWVAL]*)
     Can be set to a boolean value to enable deep copies of structures.
     Cross-referencing will then only be done when absolutely essential
     (i.e., to break reference cycles).  Default is 0.

$Data::Dumper::Quotekeys  or  $OBJ->Quotekeys(*[NEWVAL]*)
     Can be set to a boolean value to control whether hash keys are quoted.
     A false value will avoid quoting hash keys when it looks like a simple
     string.  Default is 1, which will always enclose hash keys in quotes.

$Data::Dumper::Bless  or  $OBJ->Bless(*[NEWVAL]*)
     Can be set to a string that specifies an alternative to the bless
     builtin operator used to create objects.  A function with the
     specified name should exist, and should accept the same arguments as
     the builtin.  Default is bless.

Exports
-------

Dumper
EXAMPLES
========

   Run these code snippets to get a quick feel for the behavior of this
module.  When you are through with these examples, you may want to add or
change the various configuration variables described above, to see their
behavior.  (See the testsuite in the Data::Dumper distribution for more
examples.)

     use Data::Dumper;

     package Foo;
     sub new {bless {'a' => 1, 'b' => sub { return "foo" }}, $_[0]};

     package Fuz;                       # a weird REF-REF-SCALAR object
     sub new {bless \($_ = \ 'fu\'z'), $_[0]};

     package main;
     $foo = Foo->new;
     $fuz = Fuz->new;
     $boo = [ 1, [], "abcd", \*foo,
              {1 => 'a', 023 => 'b', 0x45 => 'c'},
              \\"p\q\'r", $foo, $fuz];
     
     ########
     # simple usage
     ########

     $bar = eval(Dumper($boo));
     print($@) if $@;
     print Dumper($boo), Dumper($bar);  # pretty print (no array indices)

     $Data::Dumper::Terse = 1;          # don't output names where feasible
     $Data::Dumper::Indent = 0;         # turn off all pretty print
     print Dumper($boo), "\n";

     $Data::Dumper::Indent = 1;         # mild pretty print
     print Dumper($boo);

     $Data::Dumper::Indent = 3;         # pretty print with array indices
     print Dumper($boo);

     $Data::Dumper::Useqq = 1;          # print strings in double quotes
     print Dumper($boo);
     
     
     ########
     # recursive structures
     ########
     
     @c = ('c');
     $c = \@c;
     $b = {};
     $a = [1, $b, $c];
     $b->{a} = $a;
     $b->{b} = $a->[1];
     $b->{c} = $a->[2];
     print Data::Dumper->Dump([$a,$b,$c], [qw(a b c)]);
     
     
     $Data::Dumper::Purity = 1;         # fill in the holes for eval
     print Data::Dumper->Dump([$a, $b], [qw(*a b)]); # print as @a
     print Data::Dumper->Dump([$b, $a], [qw(*b a)]); # print as %b
     
     
     $Data::Dumper::Deepcopy = 1;       # avoid cross-refs
     print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
     
     
     $Data::Dumper::Purity = 0;         # avoid cross-refs
     print Data::Dumper->Dump([$b, $a], [qw(*b a)]);
     
     
     ########
     # object-oriented usage
     ########
     
     $d = Data::Dumper->new([$a,$b], [qw(a b)]);
     $d->Seen({'*c' => $c});            # stash a ref without printing it
     $d->Indent(3);
     print $d->Dump;
     $d->Reset->Purity(0);              # empty the seen cache
     print join "----\n", $d->Dump;
     
     
     ########
     # persistence
     ########
     
     package Foo;
     sub new { bless { state => 'awake' }, shift }
     sub Freeze {
         my $s = shift;
     	print STDERR "preparing to sleep\n";
     	$s->{state} = 'asleep';
     	return bless $s, 'Foo::ZZZ';
     }
     
     package Foo::ZZZ;
     sub Thaw {
         my $s = shift;
     	print STDERR "waking up\n";
     	$s->{state} = 'awake';
     	return bless $s, 'Foo';
     }
     
     package Foo;
     use Data::Dumper;
     $a = Foo->new;
     $b = Data::Dumper->new([$a], ['c']);
     $b->Freezer('Freeze');
     $b->Toaster('Thaw');
     $c = $b->Dump;
     print $c;
     $d = eval $c;
     print Data::Dumper->Dump([$d], ['d']);
     
     
     ########
     # symbol substitution (useful for recreating CODE refs)
     ########
     
     sub foo { print "foo speaking\n" }
     *other = \&foo;
     $bar = [ \&other ];
     $d = Data::Dumper->new([\&other,$bar],['*other','bar']);
     $d->Seen({ '*foo' => \&foo });
     print $d->Dump;

BUGS
====

   Due to limitations of Perl subroutine call semantics, you cannot pass an
array or hash.  Prepend it with a \ to pass its reference instead.  This
will be remedied in time, with the arrival of prototypes in later versions
of Perl.  For now, you need to use the extended usage form, and prepend the
name with a * to output it as a hash or array.

   Data::Dumper cheats with CODE references.  If a code reference is
encountered in the structure being processed, an anonymous subroutine that
contains the string '"DUMMY"' will be inserted in its place, and a warning
will be printed if `Purity' is set.  You can eval the result, but bear in
mind that the anonymous sub that gets created is just a placeholder.
Someday, perl will have a switch to cache-on-demand the string
representation of a compiled piece of code, I hope.  If you have prior
knowledge of all the code refs that your data structures are likely to
have, you can use the `Seen' method to pre-seed the internal reference
table and make the dumped output point to them, instead.  See `EXAMPLES'
in this node above.

   The `Useqq' flag is not honored by `Dumpxs()' (it always outputs
strings in single quotes).

   SCALAR objects have the weirdest looking bless workaround.

AUTHOR
======

   Gurusamy Sarathy        gsar@umich.edu

   Copyright (c) 1996-98 Gurusamy Sarathy. All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

VERSION
=======

   Version 2.101    (30 Apr 1999)

SEE ALSO
========

   perl(1)


