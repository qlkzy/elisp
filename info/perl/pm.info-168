This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: HTML/Clean,  Next: HTML/DOMbo,  Prev: HTML/Changes,  Up: Module List

Cleans up HTML code for web browsers, not humans
************************************************

NAME
====

   HTML::Clean - Cleans up HTML code for web browsers, not humans

SYNOPSIS
========

     use HTML::Clean;
     $h = new HTML::Clean($filename); # or..
     $h = new HTML::Clean($htmlcode);
     
     $h->compat();
     $h->strip();
     $data = $h->data();
     print $$data;

DESCRIPTION
===========

   The HTML::Clean module encapsulates a number of common techniques for
minimizing the size of HTML files.  You can typically save between 10% and
50% of the size of a HTML file using these methods.  It provides the
following features:

Remove unneeded whitespace (begining of line, etc)
Remove unneeded META elements.
Remove HTML comments (except for styles, javascript and SSI)
Replace tags with equivilant shorter tags (<strong> -> <b>)
etc.
   The entire proces is configurable, so you can pick and choose what you
want to clean.

THE HTML::Clean CLASS
=====================

$h = new HTML::Clean($dataorfile, [$level]);
--------------------------------------------

   This creates a new HTML::Clean object.  A Prerequisite for all other
functions in this module.

   The $dataorfile parameter supplies the input HTML, either a filename,
or a reference to a scalar value holding the HTML, for example:

     $h = new HTML::Clean("/htdocs/index.html");
     $html = "<strong>Hello!</strong>";
     $h = new HTML::Clean(\$html);

   An optional 'level' parameter controls the level of optimization
performed.  Levels range from 1 to 9.  Level 1 includes only simple fast
optimizations.  Level 9 includes all optimizations.

$h->initialize($dataorfile)
---------------------------

   This function allows you to reinitialize the HTML data used by the
current object.  This is useful if you are processing many files.

   $dataorfile has the same usage as the new method.

   Return 0 for an error, 1 for success.

$h->level([$level])
-------------------

   Get/set the optimization level.  $level is a number from 1 to 9.

$myref = $h->data()
-------------------

   Returns the current HTML data as a scalar reference.

strip(\%options);
-----------------

   Removes excess space from HTML

   You can control the optimizations used by specifying them in the
%options hash reference.

   The following options are recognized:

boolean values (0 or 1 values)
          whitespace    Remove excess whitespace
          shortertags   <strong> -> <b>, etc..
          blink         No blink tags.
          contenttype   Remove default contenttype.
          comments      Remove excess comments.
          entities      &quot; -> ", etc.
          dequote       remove quotes from tag parameters where possible.
          defcolor      recode colors in shorter form. (#ffffff -> white, etc.)
          javascript    remove excess spaces and newlines in javascript code.
          htmldefaults  remove default values for some html tags
          lowercasetags translate all HTML tags to lowercase

parameterized values
          meta        Takes a space separated list of meta tags to remove,
                      default "GENERATOR FORMATTER"

          emptytags   Takes a space separated list of tags to remove when there is no
                      content between the start and end tag, like this: <b></b>.
                      The default is 'b i font center'

compat()
--------

   This function improves the cross-platform compatibility of your HTML.
Currently checks for the following problems:

Insuring all IMG tags have ALT elements.
Use of Arial, Futura, or Verdana as a font face.
Positioning the <TITLE> tag immediately after the <head> tag.
defrontpage();
--------------

   This function converts pages created with Microsoft Frontpage to
something a Unix server will understand a bit better.  This function
currently does the following:

Converts Frontpage 'hit counters' into a unix specific format.
Removes some frontpage specific html comments
SEE ALSO
========

Modules
-------

   FrontPage::Web, FrontPage::File

Web Sites
---------

Distribution Site - http://people.itu.int/~lindner/
AUTHORS
=======

   Paul Lindner for the International Telecommunication Union (ITU)

COPYRIGHT
=========

   The HTML::Strip module is Copyright (c) 1998,99 by the ITU, Geneva
Switzerland.  All rights reserved.

   You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the Perl README file.


File: pm.info,  Node: HTML/DOMbo,  Next: HTML/DynamicTemplate,  Prev: HTML/Clean,  Up: Module List

convert between XML::DOM and {XML/HTML}::Element trees
******************************************************

NAME
====

   HTML::DOMbo - convert between XML::DOM and {XML/HTML}::Element trees

SYNOPSIS
========

     use HTML::DOMbo;
     use HTML::TreeBuilder;
     my $tree = HTML::TreeBuilder->new;
     $tree->parse_from_file('foo.html');
     my $dom_tree = $tree->to_XML_DOM;
     # Now you have a DOM element in $dom_tree!

DESCRIPTION
===========

   This class puts a method into HTML::Element called to_XML_DOM, and puts
into the class XML::DOM::Node two methods, `to_HTML_Element' and
`to_XML_Element'.

to_XML_DOM
----------

   The class HTML::TreeBuilder robustly produces parse trees of HTML, but
the trees are made of HTML::Element objects, not W3C DOM objects.  If you
want to access a TreeBuilder-made parse tree (in $tree) with a DOM
interface, use HTML::DOMbo and then call

     my $dom_tree = $tree->to_XML_DOM;

   This returns a new object of the appropriate class (presumably
XML::DOM::Element), in a new DOM document, having the same structure and
content as the given HTML::TreeBuilder/Element tree.  If you want the
elements to be instantiated against an existing document object, instead
call:

     my $dom_tree = $tree->to_XML_DOM($existing_dom_document);

to_HTML_Element and to_XML_Element
----------------------------------

   This module provides two experimental methods (in the XML::DOM::Node
class) called `to_HTML_Element' and `to_XML_Element', which clone a DOM
node (or DOM document, or document fragment) as a new HTML::Element or
XML::Element object.  You need to have the XML::Element module (from the
XML::TreeBuilder dist) installed in order to use the `to_XML_Element'
method.

   It is possible for this to throw a fatal exception.  And it it possible
for this to return a text string instead (if the DOM node given was a text
node).  Moreover, in list context it may return any number of items, if
the source object is a document fragment containing more than one
top-level node, or no nodes.

   Users are encouraged to report to me any problems (or successes) in
using this method.  The behavior of this method may change in response to
your requests.

SEE ALSO
========

   *Note XML/DOM: XML/DOM,, *Note HTML/TreeBuilder: HTML/TreeBuilder,,
*Note HTML/Element: HTML/Element,, *Note XML/Element: XML/Element,.

COPYRIGHT
=========

   Copyright 2000 Sean M. Burke.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AUTHOR
======

   Sean M. Burke, <sburke@cpan.org>


File: pm.info,  Node: HTML/DynamicTemplate,  Next: HTML/EP,  Prev: HTML/DOMbo,  Up: Module List

HTML template class.
********************

NAME
====

   HTML::DynamicTemplate - HTML template class.

SYNOPSIS
========

     use HTML::DynamicTemplate;
     my $template = new HTML::DynamicTemplate 'path/to/template';
     $template->set_recursion_limit($integer);
     $template->set(NAME => $value);
     $template->set(NAME_1 => $value_1,
                    NAME_2 => $value_2,
                    NAME_3 => $value_3);

     $template->clear();
     $template->render();
     $template->render(@variables);

     path/to/template
     ----------------
     <html>
     <body>
     <h1>$HEADING</h1>

     <p><font color="$HIGHLIGHT_COLOR">This is standard HTML with
     arbitrary embedded variable references which are substituted
     with actual values when the template is rendered.</font></p>

     <p>Template variables may be set within the template itself
     with the special $SET directive. This is useful when setting
     variables for use by included templates. Example:
     $SET(PAGE_TITLE, "What's New"). Note: Be sure to escape
     quotes (&quot;) and closing parantheses (&#41;) as HTML
     entities.</p>

     <p>Additionally, templates may be recursively included by
     specifying a template with the special $INCLUDE directive.
     Example: $INCLUDE(templates/example.tmpl). Template paths may
     be variable references as in $INCLUDE($EXAMPLE_FILE). Note:
     Any variable references found in included templates will be
     substituted as in the original template.

     <p>Usage note: variable and directive names are always
     specified in uppercase.</p>

     </body>
     </html>

DESCRIPTION
===========

   The `HTML::DynamicTemplate' is a class implementing a HTML template in
perl. Significant features include the ability to set template variables
from within the template itself, the ability to recursively include other
templates, and the ability to selectively render a specified subset of
variables.

METHODS
=======

$template = new HTML::DynamicTemplate $template_filename;
     Constructor for the template. Returns a reference to a
     HTML::DynamicTemplate object based on the specified template file.

$template->set_recursion_limit($integer);
     A default recursion limit for template includes is implemented to
     prevent infinite recursions. Use this method to override the default
     value (10).

$template->set(NAME => $value);
     Sets template variable to given value.

$template->clear();
     Clears template variables. Useful when processing table row templates.

$template->render();
     Renders template by performing variable substitutions.

$template->render(@variables);
     Renders template by performing variable substitutions on only those
     variable names specified in @variables.

AUTHOR
======

   Copyright (c) 1999 Brian Ng. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as
Perl itself.

   Created May 10, 1999 by Brian Ng <brian@m80.org>.

   Based on original work by Brian Slesinsky.


File: pm.info,  Node: HTML/EP,  Next: HTML/EP/CGIEncryptForm,  Prev: HTML/DynamicTemplate,  Up: Module List

a system for embedding Perl into HTML
*************************************

NAME
====

     HTML::EP - a system for embedding Perl into HTML

SYNOPSIS
========

     <html><head><title>CGI-Env</title></head>
     <ep-comment>
     	This is an HTML document. You see. Perhaps you wonder about
     	the unknown HTML tags like ep-comment above? They are part
     	of the EP system. For example, this comment section will
     	be removed and you won't see it in your browser.
     </ep-comment>
     <ep-perl>
     	# This is an example of embedding Perl into the page.
     	# We create a variable called time, containing the current
         # time. This variable will be used below.
         my $self = $_;
     	$self->{'time'} = localtime(time());
     	''; # Return an empty string; result becomes embedded into the
             # HTML page
     </ep-perl>
     <body><h1>The current time</h1>
         Your HTML::EP system is up and running: The current time is $time$.
     </body>
     </html>

NEWS
====

   HTML::EP does now have a homepage, a CVS repository and a bug tracking
system. Try

     http://html-ep.sourceforge.net/

DESCRIPTION
===========

   Have you ever written a CGI binary? Easy thing, isn't it? Was just fun!

   Have you written two CGI binaries? Even easier, but not so much fun.

   How about the third, fourth or fifth tool? Sometimes you notice that
you are always doing the same:


     Reading and parsing variables


     Formatting output, in particular building tables


     Sending mail out from the page


     Building a database connection, passing CGI input to the database and
     vice versa


     Talking to HTML designers about realizing their wishes

   You see, it's soon to become a pain. Of course there are little helpers
around, for example the CGI module, the mod_perl suite and lots of it
more. Using them make live a lot easier, but not so much as you like.
`CGI(3)' in this node. `mod_perl(3)' in this node.

   On the other hand, there are tools like PHP or WebHTML. Incredibly easy
to use, but not as powerfull as Perl. Why not get the best from both
worlds? This is what EP wants to give you, similar to ePerl or
HTML::EmbPerl. I personally believe that EP is simpler and better
extendible than the latter two. `ePerl(1)' in this node.
`HTML::EmbPerl(3)' in this node.

   In short, it's a single, but extensible program, that scans an HTML
document for certain special HTML tags. These tags are replaced by
appropriate output generated by the EP. What remains is passed to the
browser. Its just like writing HTML for an enhanced browser!

Prerequisites
-------------

   As far as I know EP depends on no system dependent features. However,
it relies on some other Perl modules:

CGI
     The CGI module should be a part of your Perl core's installation. If
     not, you should definitely upgrade to Perl 5.004. :-) My thanks to
     Lincoln D. Stein <lstein@genome.wi.mit.edu>. Note, you need a late
     version, including the CGI::Cookie module.

HTML::Parser
     This module is used for parsing the HTML templates. My thanks to Gisle
     Aas <aas@sn.no>.

libwww
     The LWP library contains a lot of utility functions, for example HTML
     and URL encoding and decoding. Again, my thanks to Gisle Aas
     <aas@sn.no>. :-)

Mail::Internet
     Graham Barr <gbarr@pobox.com> wrote the MailTools package. Some parts
     of it, in particular the Mail::Internet module is used for sending
     mail from within the HTML page. Thank very much, Graham!

Storable
     Raphael Manfredi's <Raphael_Manfredi@grenoble.hp.com> excellent
     Storable module is used for storing sessions. I owe him much, as
     Storable is usefull in a lot of other modules.

   Perl itself and the above modules are available from any CPAN mirror,
for example

     ftp://ftp.funet.fi/pub/languages/perl/CPAN/modules/by-module

   Note that you don't need to install these manually, the CPAN module will
help you. See the `"Automatic Installation"' in this node below.

Automatic Installation
----------------------

   Installing this module (and the prerequisites from above) is quite
simple, if you have the CPAN module available and network access, you might
try an automatic installation:

     perl -MCPAN -e shell

   If the CPAN prompt appears, asking you for commands, enter

     install Bundle::HTML::EP

   Automatic installation typically doesn't work on Windows, due to a
missing C development environment. However, you might try

     ppm install http://www.cpan.org/authors/id/J/JW/JWIED/HTML-EP.ppd

Manual Installation
-------------------

   If automatic installation doesn't work, you just fetch the archive,
extract it with

     gzip -cd HTML-EP-0.1125.tar.gz | tar xf -

   (this is for Unix users, Windows users would prefer WinZip or something
similar) and then enter the following:

     cd HTML-EP-0.1125
     perl Makefile.PL
     make
     make test

   If any tests fail, let me know. Otherwise go on with

     make install

   This will put the required Perl modules into a destination where Perl
finds it by default. Additionally it will install a single CGI binary,
called `ep.cgi'.

   The docs are available online with

     perldoc HTML::EP

   If you prefer an HTML version of the docs, try

     pod2html lib/HTML/EP.pm

   in the source directory.

Using the CGI binary
--------------------

   You have different options for integrating EP into your WWW server,
depending on which server you are using and the permissions you have.  The
simplest possibility is running an external CGI binary. Another option is
to use mod_perl with Apache, see `"Using mod_perl"' in this node below.

   I suggest that you choose an extension and configure your WWW server for
feeding files with this extension into `ep.cgi'. For example, with Apache,
you can add the following lines to your `srm.conf':

     ScriptAlias /cgi-bin/ep.cgi	/usr/bin/ep.cgi
     AddType x-ep-script .ep
     Action x-ep-script /cgi-bin/ep.cgi

   This tells Apache that files with extension ep.cgi are handled by the
CGI binary `/usr/bin/ep.cgi'.  On Windows, you should replace ep.cgi with
ep.cgi.bat. Make sure, that the ScriptAlias line is entered *before* any
other ScriptAlias instruction! In particular, the following would be wrong:

     ScriptAlias /cgi-bin/ /home/httpd/cgi-bin/
     ...
     ScriptAlias /cgi-bin/ep.cgi /usr/bin/ep.cgi

   The first rule would be applied before our rule, so that it could never
match.

   From now on your server will never return files with extension .ep
directly! Verify your installation by creating the following file:

     <html><head><title>Local time</title></head>
     <body>
     The current time is:
     <ep-perl>scalar(localtime(time))</ep-perl>
     </body>

   (Note that this is a much shorter version of the example in the
synopsis.)  Store it as `/test.ep' on your web server and retrieve the
file via your Web server. If you see the time displayed, you are up and
running.

Using mod_perl
--------------

   The EP package can be integrated into mod_perl, for example by using
the following commands in `srm.conf':

     PerlModule Apache::EP
     <Files *.ep>
       SetHandler perl-script
       PerlHandler Apache::EP->handler
       Options ExecCGI
     </Files>

   Keep in mind, that mod_perl differs in many details from programming CGI
binaries. In particular you might need to restart Apache for loading
changes in modules.

Using the Internet Information Server
-------------------------------------

   I am sure there is a better way of installation, in the sense of
mod_perl, however, I am no IIS expert. I can only recommend using Perl as
an external binary, in the sense of CGI.

   The idea is to advice the IIS, that files with extension .ep have to be
executed by running

     C:\Perl\bin\perl.exe c:\Perl\bin\ep.cgi %s%s

   with %s%s being the path to the EP document. (Of course the paths have
to be adjusted to your local Perl.) This can be done by creating a new
extension in the window "Base directory/Configure". (Window name translated
from the german IIS, it´s "Basisverzeichnis / Konfigurieren" here and might
be different in english.)

Available methods
-----------------

   All EP tags are starting with the prefix *ep-*. Some available tags are:

ep-comment
     This is a multi-line tag for embedding comments into your HTML page.
     But why use this tag, instead of the usual HTML comment, `<!--'? The
     difference is, that the user will never see the former.

     Example:

          <html>
              <!-- This is a comment. I like comments. --!>
              <ep-comment>
          	    This is another comment, but you won't see it
          	    in your browser. The HTML editor will show it
          	    to you, however!
          	</ep-comment>
          </html>

     Do not try to embed EP instructions into the comment section! They
     won't produce output, but they might be executed anyways.

ep-perl
     This is for embedding Perl into your script. There are two versions of
     it: A multiline version is for embedding the Perl code immediately
     into your script. Example:

          <html>
          	<head><title>The Date</title></head>
              <body>
          	    <h1>The Date</h1>
          	    <p>Hello, today its the</p>
          	    <p align=center>
          	    <ep-perl>
          		# This little piece of Perl code will be executed
          		# while scanning the page.
          		#
          		# Let's calculate the date!
          		#
          		my($sec,$min,$hour,$mday,$mon,$year)
                          = localtime(time);
          		# Leave a string with the date as result. Will be
                      # inserted into the HTML stream:
          		sprintf("%02d.%02d.%04d", $mday, $mon+1, $year+1900);
          	    </ep-perl>
          	    </p>
              </body>
          </html>

     If you don't like to embed Perl code, you may store it into a
     different file. That's what the single-line version of ep-perl is for:

          <html>
          	<head><title>The Date</title></head>
              <body>
          	    <h1>The Date</h1>
          	    <p>Hello, today its the</p>
          	    <p align=center>
          	    <ep-perl src="date.pl">
          	    </p>
              </body>
          </html>

     You have noticed, that the little script's result was inserted into
     the HTML page, did you? It did return a date, in other words a string
     consisting of letters, digits and dots. There's no problem with
     inserting such a string into an HTML stream.

     But that's not always the case! Say you have a string like

          Use </html> for terminating the HTML page.

     This cannot be inserted as a raw string, for obvious reasons. Thus the
     ep-perl command has an attribute output. Use it like this:

          <ep-perl output=html>
              'Use </html> for terminating the HTML page.';
          </ep-perl>

     Possible values of the output attribute are raw (default), html (HTML
     encoded) and url (URL encoded).

     It's a common mistake, to use the Perl command return in embedded
     Perl.  Never do that! If you need return (there are of course
     situations where returning can help), do it like this:

          <ep-perl>
          	sub eval_me {
          	    if ($this) {
          		return 'foo';
          	    } elsif ($that) {
          		return 'bar';
          	    }
          	    '';
          	}
          	eval_me();
          </ep-perl>

     See `"Variables"' in this node below for interactions between Perl
     variables and EP variables.

     For security reasons, you might set an attribute safe, as in

          <ep-perl safe=1>...</ep-perl>

     This will create a Safe compartment for you and run the embedded
     script in the compartment. Using this attribute is highly recommended!

ep-mail
     This command will send an e-mail. The attributes will be used for
     creating the email header, in particular the subject, from and to
     attribute should be used. Example:

          <ep-mail subject="Howdy!" from="joe@ispsoft.de"
                   reply-to="joe@ispsoft.de" to="bill@whitehouse.gov">
          	Hello, Bill, old chap. How are you?

          Yours sincerely,
          Jochen
              </ep-mail>

     You can still use EP variables in the E-mail body, for example the
     following works:

          <ep-mail subject="Test" reply-to="$cgi->email$" to="joe@ispsoft.de"
                   from="webmaster@www.mydomain.com">
              Hello, Joe,
              this e-mail was sent to you by $@cgi->name$.
          </ep-mail>

     But note that we suppress conversion into HTML format in the mail
     body!  See `"Variables"' in this node below for details.

     Recent sendmail versions are quite picky about validity of email
     addresses.  Thus it is highly recommended that you use valid
     addresses for the to and from fields. If you want to customize the
     sender, you'd better choose a fixed from field and modify the
     *reply-to* field only, as in the example above.

ep-errhandler
     This command advices EP, what to do in case of errors. See `"Error
     handling"' in this node below. Example:

          <ep-comment>
          	Set the template being used for system errors.
          </ep-comment>
          <ep-errhandler type=system src=/templates/syserr.html>
          <ep-comment>
          	Likewise, set the template for user errors.
          </ep-comment>
          <ep-errhandler type=user src=/templates/usererr.html>

     If an error occurs, the given scripts are loaded and used as templates
     instead of the current one. You don't need external files! Instead
     you can use

          <ep-errhandler type=user>
              <HTML><HEAD><TITLE>User error</TITLE></HEAD>
              <BODY><H1>User error</H1>
              <P>Replace user and continue. :-)</P>
              <P>To be serious, the following problem happened:</P>
              <PRE>$errmsg$</PRE>
              <P>Please return to the calling page, fix the problem
              and retry.</P>
              </BODY></HTML>
          </ep-errhandler>

     However, you might prefer to use a single error template and of course
     it's faster to use external error templates than parsing builtin
     templates. (At least, if no error occurs. :-)

ep-error
     This command forces an error message. See `"Error handling"' in this
     node below.  You can trigger user or system errors by setting the
     type attribute to the values system (default) or user. The msg
     attribute is for setting the error message.

     Example:

          <ep-comment>
          	If no email address was entered, force a user error.
          </ep-comment>
          <ep-if eval="$cgi->email$">
              Email address is ok.
          <ep-else>
          	<ep-error msg="Missing email address" type=user>
          </ep-if>

ep-database
     This command connects to a database. Its attributes are dsn, user and
     password corresponding to the same attributes of the DBI connect
     method. See `DBI(3)' in this node for details on DBI.

     Example:

          <ep-database dsn="DBI:mysql:test" user="joe"
          	         password="Authorized?Me?">

     You can use different database connections by using the dbh attribute:

          <ep-database dbh="dbh2" dsn="DBI:mSQL:test">

     The dbh attribute advices EP to store the DBI handle in the given
     variable. (Default: dbh) See `"Variables"' in this node below.

ep-query
     This command executes an SQL statement. The query attribute will be
     used for passing the SQL statement. Of course a multiline version is
     available, thus

          <ep-query statement="INSERT INTO foo VALUES (1, 'bar')">

     is the same as

          <ep-query>
          	INSERT INTO foo VALUES (1, 'bar')
          </ep-query>

     If your query retrieves a result, use the result attribute to store it
     in a variable, for example like this:

          <ep-query statement="SELECT * FROM employees" result="employees"
                    resulttype="hash" startat=0 limit=-1>

     This will create a variable `employees', an array ref of hash refs.
     You can use the ep-list command for displaying the output. See
     `"Variables"' in this node below.

     When using multiple database connections, use the dbh attribute for
     choosing the connection. (See the *ep-database* method above.)

     If you have big result tables, you might prefer DBI's
     *fetchrow_arrayref* method over creating hash refs, because arrays
     are created faster than hash refs. This is achieved by setting the
     attribute *resulttype* to array. The default is hash. Other
     resulttypes are *single_hash* and *single_array*: If your query will
     return at most a single element, then the result variable will
     contain the first row (or an undefined value) and not an array.

     Sometimes you don't want to retrieve the complete result table. In
     that case you can use the attributes *startat* and limit. For example,
     to retrieve rows 0-19, use *startat=0* and *limit=20*. Likewise you
     would use *startat=20* and *limit=20* for rows 20-39.

     When using the *MySQL* engine, the *startat* and limit attributes are
     directly mapped to MySQL's *LIMIT* clause.

ep-list
     This command is used to display an array of refs. Lets assume, that
     the variable `employees' contains a an array ref of refs with the
     attributes name and *department*. Then you could create a table of
     employees as follows:

          <table><tr><th>Nr.</th><th>Name</th><th>Department</th>
          <ep-list items="employees" item="e">
          	   <tr><td>$i$</td><td>$e->name$</td><td>$e->department$</td>
          </ep-list>
          </table>

     This will be processed as follows: For any item in the array,
     retrieved from the variable `employees', create a variable e and
     display the text between ep-list and /ep-list for it by replacing the
     patterns $e->name$ and $e->department$ with the corresponding values.

     The variable i is initially set to 0 and incremented by one with any
     element.

     As an alternative to the items attribute, you may prefer the range
     attribute: For example

          <ep-list range="1..12" item=month><OPTION>$month$</ep-list>

     will create the options array of a select box for you, where the user
     can select a month. If your prefer month names, you may better choose

          <ep-list range="jan,feb,mar,apr,jun,jul,aug,sep,oct,nov,dec"
           item=month><OPTION>$month$</ep-list>

     It is even possible to mix both versions, as in

          <ep-list range="1..3,6..7,10" item=m><OPTION>$m$</ep-list>

     See the *ep-select* command below for another example of the range
     attribute.

     It is possible to nest multiple ep-list statements, as in

          <ep-list range="1..3" item="i"><ep-list range="4..6"
            item="j">$i$$j$ </ep-list></ep-list>

     This will create the output "14 15 16 24 25 26 34 35 36".

ep-select
     This is similar to ep-list, but it is specifically designed for
     creating SELECT boxes and similar things. We explain it by example:

          <ep-select name="year" range="1991..1995" item="y"
                     selected="$cgi->year$">
              <OPTION $selected$>$y$</ep-select>

     If you supply a *selected* attribute, then a variable *selected* will
     be created for any item. The value will be either an empty string or
     the word SELECTED (configurable via the attribute *selected-text*),
     depending on whether the item matches the *selected* value or not.

ep-input
     This is usefull for reading an objects data out of CGI variables.
     Say you have a form with input fields describing an address, the
     field names being address_t_name, address_t_street, address_n_zip and
     address_t_city. By using the command

          <ep-input prefix="address_" dest="address">

     the EP program will create a variable "address" for you which is an
     hash ref as follows:

          $cgi = $_->{cgi};
          $_->{address} = {
          	name =>   { col => 'name',
          		    val => $cgi->param("address_name"),
          		    type => 't',
          		  },
          	street => { col => 'street',
          		    val => $cgi->param("address_street"),
          		    type => 't',
          		  },
          	zip =>    { col => 'zip',
          		    val => $cgi->param("address_zip"),
          		    type => 'n',
          		  },
          	city =>   { col => 'city',
          		    val => $cgi->param("address_city"),
          		    type => 't'
          		    }
          };

     In general column names beginning with address will be splitted into
     `prefix_type_suffix', the type being one of

    t
          Text columns (CHAR, VARCHAR, BINARY, or whatever), that will be
          quoted using the $self->{'dbh'}->quote() method.

    n
          Numeric columns (INTEGER, REAL, ...) that will be left untouched

    dd
    dm
    dy
          Day, month and year of a date. The combined fields will be
          quoted as 'yyyy-mm-dd'.

    s
          Set columns as created using MultiSelect boxes; the selected
          values will be used for creating a comma separated string.

     The idea is generating SQL queries automatically out of the address
     variable. This task is supported by the *sqlquery* attribute:

          <ep-database dsn="DBI:mysql:test">
          <ep-input prefix="address_" dest="a" sqlquery=1>
          <ep-comment>Create a new record, if no ID is given</ep-comment>
          <ep-if eval="$cgi->id$">
          <ep-query
           statement="INSERT INTO addresses ($@a->names$) VALUES ($@a->values$)">
          <ep-else>
          <ep-query
           statement="UPDATE addresses SET $@a->update$ WHERE id = $@id$">

     The *sqlquery* creates attributes names, values and update for you,
     that may be used in INSERT or UPDATE queries. Note that the *ep-input*
     must be preceeded by an *ep-database* call, because it is using DBI's
     quote method. `DBI(3)' in this node.

     There are situations where you want to fetch not only a single object,
     but a list of objects. Suggest an order form of articles. Then you
     might have input fields *art_0_t_name*, *art_0_n_count*,
     *art_0_n_price*, *art_1_t_name*, ...

     In that case you can give the *ep-input* command an attribute list,
     like this:

          <ep-input prefix="art_" dest="art" list=1>

     The module will read an array ref of objects to the variable dest.
     Any object will have an additional scalar variable i referring to the
     items number, beginning with 0. In other words, you can process the
     order form as follows:

          <ep-input prefix="art_" dest="art" list=1>
          <ep-perl>
            my $self = $_;
            my $sum = 0.0;
            for (my $i = 0;  defined($self->{cgi}->param("art_$i_n_count"));
          	   $i++) {
          	  $sum += $self->{cgi}->param("art_$i_n_count") *
                        $self->{cgi}->param("art_$i_n_price")
            }
            ''
          </ep-perl>
          <ep-mail from="$cgi->email$" to="order@mydomain"
                   subject="Order form">
            The following items have been ordered:

          Nr.    Price   Article

          <ep-list>
            $art->count->val$  $art->price->val$  $art->name->val$
          </ep-list>

          Total sum: $sum$
              </ep-mail>

ep-input-sql-query
          <ep-input-sql-query dest=art>

     This method is internally called by ep-input and implements the
     creation of the names, values and *updates* attributes.

     It takes as input the hash ref given by the variable dest, usually
     created by ep-input. The hash ref consists of column names as keys
     and hash refs with the attributes type and val.

     The main reason for putting this into a separate method is
     subclassing: It is quite usual, that you want ep-input to read the
     data, then do some verification and/or modification on the data (for
     example, canonicalizing dates) and finally create the SQL query. This
     can be done quite easily by subclassing the *_ep_input_sql_query*
     method: Within the method you verify and/or modify data entered by
     the user and then call the super class.

     For example, a typical subclass implementation could look like this:

          sub _ep_input_sql_query {
            my $self = shift;  my $attr = shift;
            # If the user left the MYCOL column empty, set it to NULL.
            my $dest = $attr->{'dest'};
            $self->{$dest}->{'MYCOL'} = undef
          	if $self->{$dest}->{'MYCOL'} eq '';
            $self->SUPER::_ep_input_sql_query($attr);
          }

ep-include
     Sometimes you want to source external files. This can be done by using

          <ep-include file="myfile">

     If a file with the given name doesn't exist, the file name is treated
     as being relative to your WWW servers DOCUMENT_ROOT directory.

ep-exit
     This directive terminates processing of the current HTML page.

ep-set
     This instruction is setting an EP variable. Suggest the following
     example:

          <ep-set var=myvar val=value>

     From now on you can use

          $myvar$

     as an alias for "value". There's also a multiline version:

          <ep-set var=myvar>value</ep-set>

     The main difference between the single and the multiline version is
     that the multiline version allows supressing variable interpretation
     by setting the *noparse* attribute:

          <ep-set var=myvar noparse=1>my $value$</ep-set>

     The above example is indeed setting myvar to "my $value$" *without*
     escaping $value$!

Conditional HTML
----------------

   It is possible to blank out parts of the HTML document. See the
following example:

     <html><head><title>Conditional HTML</title></head>
     <body>
       <h1>Conditional HTML</h1>
       <ep-if eval="$_->{cgi}->param('i') < 0">
         You have entered a negative number for i!
       <ep-else eval="$_->{cgi}->param('i') == 0">
         You have entered zero for i!
       <ep-else>
         <ep-if eval="$_->{cgi}->param('j') < 0">
           You have entered a negative number for j!
         <ep-else eval="$_->{cgi}->param('h') == 0">
           You have entered zero for j!
         <ep-else>
           Ok, both numbers are positive.
         </ep-else>
       </ep-else>
     </body>
     </html>

   The example is of course somewhat unnatural, because you'd better use a
single ep-perl in that case, but it shows that we can use arbitrary
complex structures of conditional HTML.

   The eval attribute is simply treated as a truth value, as in Perl.
Thus empty strings or numeric zeros are FALSE, everything else is TRUE.
This is reversed, if you replace eval with *neval*:

     <ep-if neval="$a$">
       a is not set
     <ep-else>
       a is set
     </ep-if>

   If you'd like to compare numeric values, use the *cnd* attribute, as in

     <ep-if cnd="$a$<$b$">
       a is lower than b
     <ep-else>
       a is greater than or equal to b
     </ep-if>

   You may choose either of ==, !=, <, >, <= or >= for the condition. And
finally you may compare string values like this:

     <ep-if cnd="'$a$' eq '$b$'">
       a is equal to b
     </ep-if>

   Note the use of the single quotes, which is really required here.
Available conditions are eq and ne.

   As with ep-list, you may nest multiple ep-if's or combine them with
ep-list. The following is invalid, though:

     <ep-list range="1..3" item="i">
       <ep-if cnd="$i$<3">ok</ep-list></ep-if>

   As the ep-if starts within the ep-list, it must also be terminated
before the corresponding /ep-list.

Localization
------------

   Localization is available via the HTML::EP::Locale module. Currently it
only offers methods for localizing strings.

   To access the module, let's assume you prefer your visitors reading the
german (de) version of your page, but it is also available in english
(en). Then start your HTML page with

     <ep-package name="HTML::EP::Locale" accept-language="de,en">

   When the package is loaded, it tries to guess your documents language.
The default language is *de* (german) or whatever you choose when
installing the package. Another language can be specified by

   * By setting the CGI variable language, for example by making a link to
     `mypage.ep?language=en'.

   * By setting the environment variable *HTTP_ACCEPT_LANGUAGE*; most
     browsers do this for you. For example with Netscape, this variable is
     configurable via Edit/Preferences/Navigator/Languages.

   Two possibilities are available for localizing strings. For short
strings like titles, headers or Link refs you might prefer this version:

     <ep-language de="Titel" en="Title">

   Obviously this is not appropriate for longer strings and it must not
contain HTML patterns. Thus another version is available:

     <ep-language language=de>
       <p>Dies ist ein Absatz.</p>
       <p>Dies ist der zweite Absatz.</p>
     <ep-language language=en>
       <p>This is one paragraph.</p>
       <p>This is another paragraph.</p>
     </ep-language>

   Note you need not use a /ep-language for terminating the german part,
similar to the ep-if, ep-elseif, ..., ep-else, /ep-if structure.

   A special problem with localization is the choice of a character set.
You can fix a certain character set with something like

     <META HTTP-EQUIV="Content-type"
           CONTENT="text/html; CHARSET: iso-8859-2">

Error handling
--------------

   Error handling with EP is quite simple: All you do in case of errors is
throwing a Perl exception. For example, DBI handles are created with the
RaiseError attribute set to 1, so that SQL errors trigger a Perl
exception. You never care for errors!

   However, what happens in case of errors? In that case, EP will use the
template that you have set with ep-errhandler and treat it like an
ordinary EP document, by setting the variables errmsg and admin.

   If you don't set an error handler, the following template will be used,
which is well suited for creating an own error template:

     <html><head><title>Internal error</title></head>
     <body><h1>Internal error</h1>
     <p>An internal error occurred. The server has not been able to
     fullfill your request. The error message is:</p>
     <pre>
     	$errmsg$
     </pre>
     <p>Please contact the Webmaster,
     <a href="mailto:$admin$">$admin$</a>,
     tell him the URL, the time and error message.
     </p>
     <p>We apologize for any inconvenience, please try again later!</p>
     <br><br><br><p>Yours sincerely,</p><p>The Webmaster</p>
     </body>
     </html>

Variables
---------

   It is important to understand, how EP variables work, in particular when
working with ep-perl.

   You always have an object $_, which is an instance of the HTML::EP
class (a subclass of HTML::Parser). This object has certain attributes, in
particular `$_->{cgi}', a CGI object and `$_->{dbh}', the DBI handle. (Of
course valid after `ep-database' only.) If you want to set or modify a
variable, you have to set `$_->{varname}'. If you want to retrieve the
value, use the same. Note that you cannot use $_ for a long time, as it
will be changed by Perl loops and the like, thus your Perl code typically
starts with

     $_ = $self;

   But how do you access the variable from within EP documents? You just
write

     $varname$

   This will be replaced automatically by the parser with the value of
`$_->{varname}'. Even more, the value will be converted into HTML source!

   If `varname' is a structured variable, for example a hash or array ref,
you may as well use

     $varname->attrname$
     or

     $varname->0$

   to access `$_->{varname}->{attrname}' or `$_->{varname}->[0]',
respectively. A special value of *varname* is cgi: This will access the
CGI variable of the same name, thus the following are equivalent:

     $cgi->email$

   and

     $_->{cgi}->param('email');

   But what, if you don't want your variable to be HTML encoded? You may
as well use

     $@varname$	(Raw)
     $#varname$	(URL encoded)
     $~varname$	(SQL encoded)

   The latter uses the $_->{dbh}->quote() method. In particular this
implies that you have to be connected to a database, before using this tag!

   You can even use these symbols in attributes of EP commands. For
example, the following will be usefull when sending a mail:

     <ep-mail subject="Howdy!" from="$@cgi->email$"
     	     to="bill@whitehouse.gov">

   Attributes may include EP variables, just like ordinary HTML code.
Even more, they may contain Perl code which is evaluated just like code
between `<ep-perl>' and `</ep-perl>'. However, you need to use the
variable $_ in the code, because the package otherwise doesn't detect what
you want it to do.

   See `"Custom variable formatting"' in this node for setting up your own
formats.

   Of course you can set EP variables from within an ep-perl section. But
sometimes it is desirable to set them from within HTML. In such cases you
can do something like

     <ep-set var="a" val="b">

   Now, if you do a

     Variable a has the value $a$.

   the value b will be emitted. It is also possible to set multiline
variables:

     <ep-set var="a">
       This is a template, extending a single line.
     </ep-set>

Custom variable formatting
--------------------------

   Sometimes the builtin formatting methods of HTML::EP are not sufficient.
A good example are currencies. These can be handled with format methods.
For example, see the following method for german currency values:

     <ep-package name="MyPackage">
     <ep-perl>
         package MyPackage;
         sub _format_DM {
     	    my($self, $val) = @_;
     	    sprintf("%.2f DM", $val);
     	    $val =~ s/\./,/;
     	    $val;
         };
         ''
     </ep-perl>

   This can be used as follows, suggest we have the following variables:

     a = 1
     b = 2.4
     c = 34.47

   then we can use

     a = $&DM->a$	       	=>  1,00 DM
     b = $&DM->b$	       	=>  2,40 DM
     c = $&DM->c$	       	=> 34,47 DM

   In other words: Use the special marker &, followed by the custom
formats method name, the dereferencing operator and finally the variable
name.

   The above method is already predefined by the HTML::EP::Locale module.

   As you have seen, the pattern $&METHODNAME->var$ triggers the call of

     $self->_format_METHODNAME($self->{'var'});

   It is not always usefull to fix a method name. In such cases you may
instead store a code ref in

Modifying the CGI headers
-------------------------

   The attribute $self->{'_ep_heaaders'} is containing arguments that you
want to pass to CGI->header(). Use it like this:

     <ep-perl>
       $_->{'_ep_headers'} = { '-status' => '402 Payment required',
     			      '-expires' => '+3d'
     			     }
     </ep-perl>

Doing a redirect
----------------

   A redirect is moving the browser to another page without actually
displaying the current page. You can do it like this:

     <ep-redirect target="http://other.server/other/page">

Producing Non-HTML
------------------

   Say you want a CGI binary that creates a gif and not an HTML document.
(See the `ifgif.ep' file from the SNMP::Monitor distribution for an
example.) Two problems are arising here: First of all you have to create
your own headers. Next you *must* prevent that EP is emitting any output,
because this might trash your images validity. Here's what to do:

     <ep-perl>
         my $self = $_;
         my $cgi = $self->{'cgi'};
         $self->_ep_database({'dsn' => 'DBI:mysql:test',
     			     'user' => 'joe',
     			     'password' => 'joe'});
         $self->_ep_query({'statement' => "SELECT image FROM images WHERE"
     			      . " id = " . $cgi->param('id'),
     			  'result' => 'im',
     			  'resultype' => 'single_hash'});
         $self->print($cgi->header('-type' => 'image/gif'),
                      $self->{im}->{'image'});
         $self->Stop();
     </ep-perl>

   Note the use of $self->Stop()!

NPH Scripts
-----------

   The Apache server and other WWW servers have a nice feature that allows
you to return HTML pages line by line: If your script is called something
like nph-myscript then the server is passing the scripts output to the
browser immediately. This is usefull, for example, if you display the
output of a traceroute command: You'd like to see any line immediately,
but it may take some time untill the next line arrives.

   Unfortunately NPH scripts are not well suited for HTML::EP: One of EP's
major targets is that you need not care for errors: They may occur at any
point but are still catched and handled by creating an error message.
However, there's no other way to guarantee this without buffering output
until the script ends.

   If you really need to use NPH, do it like this:

     <ep-perl>
       my $self = $_;
       local $| = 1; # make sure that Perl isn't buffering
       $self->print($self->{'cgi'}->header('-type' => 'text/html',
     					  '-nph' => 1));
       for (my $i = 0;  $i < 20;  $i++) {
     	$self->print("This is line $i. Waiting one second ...\n")
     	sleep 1;
       }
       $self->Stop();
     </ep-perl>

   Note, that *no* more output will be produced by EP after calling
$self->Stop()!

DEBUGGING
=========

   Debugging CGI applications is always a problem. The EP module does its
best to support you.

   Whenever you supply a CGI variable debug, then the module will enter
debugging mode. For example if your document is `/mypage.ep', then tell
your browser to fetch `/mypage.ep?debug=1'. You won't see the usual HTML
page, but a plain text page with lots of debugging messages and the
created HTML source.

   You may extend the debugging code with sequences like

     <ep-perl>
         my $self = $_;
         $self->print("I'm here!\n") if $self->{debug};
     </ep-perl>

   Note that you should not call the print function directly, but the
print method! The former works well in CGI environments, but EP should
work even in other environments as well.

   But sometimes this is not sufficient: What's inserting debugging
messages compared to using the Perl debugger? In that case you can emulate
a CGI environment as follows:

     export DOCUMENT_ROOT=/usr/local/www/htdocs
     export PATH_TRANSLATED=$DOCUMENT_ROOT/mypage.ep
     export REQUEST_METHOD=GET
     export QUERY_STRING="var1=val1&var2=val2"
     perl -d /usr/bin/ep.cgi

   This allows you single-stepping through your program, displaying
variable values and the like.

   However, the debug variable is obviously a security problem. For that
reason the *debughosts* variable is present in HTML::EP::Config: You
should set it to a regular expression matching the IP numbers of hosts
that are allowed to enable debugging mode. The Makefile.PL should query
for appropriate settings automatically while running.

EXAMPLES
========

   The program comes with a set of examples incorporated. These are:

     - A simple Unix user administration in examples/admin.

     - A generic frontend for editing DBI tables in examples/edit.ep

     - A POP3 client for the web in examples/pop3.

   Other examples are:

     - The SNMP monitor, a utility for watching, logging and displaying
       interface utilization and status of network interfaces via WWW.
       See the directory authors/id/JWIED on any CPAN mirror, for example
       ftp://ftp.funet.fi/pub/languages/perl/CPAN.

     - The EP Explorer, an application I wrote for managing printer queues
       on a Unix hosts. The user can select a file for printing it, much
       like he did within the Windows explorer. Likewise, he can watch
       the printer status.

     - The HTML::EP::Glimpse package, a simple search engine based on
       Glimpse. (In other words, some flavour of WebGlimpse, which is
       much simpler to install and maintain and allows a free design.)

EXTENSIONS
==========

   It is quite easy to write own methods.

Single line extensions
----------------------

   For example, suggest you want a method for setting EP variables:

     <ep-set var="e" value=1>

   Once the variable is created, you can access it via

     $e$

   This can be done like this:

     <ep-perl package="HTML::EP">
       # Write a handler for ep-env:
       sub _ep_set ($$) {
           my($self, $attr) = @_;
     	  my $var = $attr->{'var'};
     	  my $val = $attr->{'value'};
     	  $self->{$var} = $val;
     	  '';
       }

     # Return an empty string:
     '';
         </ep-perl>

   Note that we used the name *_ep_set*: By default the EP module takes
the method name (*ep-env* in out case) translates all hyphens to
underscores and adds a leading underscore. We'll see in the next section
how you can override this behaviour.

Multi line extensions
---------------------

   But how to write methods, that use a `<tag>' .. `</tag>' syntax? As an
example, we write a method for creating external files.  The method
receives two attributes, a file attribute for the files name and a
*contents* attribute for the files contents. The method can be used in two
ways:

     <ep-file file="test.dat" contents="Hi!">

   or like this, in multiline mode:

     <ep-file file="test.dat">
         Hi!
     </ep-file>

   Here it is:

     <ep-perl package="HTML::EP">
     # Write a handler for ep-file:
     sub _ep_file {
         my $self = shift; my $attr = shift;
     	my $contents = $self->AttrVal($attr->{'contents'}, @_);
         my $file = $attr->{'file'};
     	require Symbol;
     	my $fh = Symbol::gensym();
     	(open($fh, ">$file)  &&  (print $fh $contents)  &&
             close($fh)) or die "Error while creating $file: $!";
     	'';
     }
     # Return an empty string:
     '';
     </ep-perl>

   The main difference to the previous example is that our method is that
a special attribute (*contents*) is defined, that may be passed as part of
the ep-file statement. However, if you don't define it as part of the
statement, the *AttrVal* method reads more text from the document untill
it finds a matching /ep-file.

   Note the use of the Symbol package when accessing files: *Never* use
global handles like

     open(FILE, ...)

   as this might break future multithreading code!

   The above example works well, if you don't need to nest your statement.
If this should be the case, you need to deal with EP's token streams. See
the ep-if and ep-list methods for examples.

External extensions
-------------------

   So far we have discussed only minor extensions that we did install as
part of HTML::EP. However, this is somewhat dangerous with mod_perl:
Suggest you have multiple virtual hosts. It might happen, that virtual
host www.foo.com defines a method ep-file, but www.bar.net defines
another. We'd have an immediate name space clash.

   To prevent such a namespace pollution, EP supports external extensions
with an inheritage model that is borrowed from Perl. Suggest we write a
Shop extension. Of course this extension borrows from HTML::EP::Session.
Thus we have the following class design:

     Shop  ---isa--->  HTML::EP::Session  ---isa--->  HTML::EP

   We start writing our Shop extension like any other Perl package:

     package Shop;
     @Shop::ISA = qw(HTML::EP::Session); # HTML::EP::Session inherits
                                         # from HTML::EP

     sub _ep_shop_session {
         my($self, $attr) = @_;
     	# Initialize the session
     	...
     	'';
     }

     sub init {
     	my $self = shift;
     	if (!$self->{'_ep_shop_initialized'}) {
     	    $self->{'_ep_shop_initialized'} = 1;
     	    $self->SUPER::init();
     	    # Do something here
     	    ...
     	}
     }

   In the HTML page we load this package as follows:

     <ep-package name="Shop">
     <ep-shop-session>

   This will do a *require Shop*, bless the object *$self* into the class
*Shop* and call *$self-*init()>. Note that we allow the init method to be
called more than once, this is important for stacking packages.

   By default packages are loaded from Perl's system directories. You can
use the attribute lib to add private directories to the library search
path. This can be relative to the servers document root, as in

     <ep-package name="Shop" lib="/perl-lib">

Inheriting from multiple extensions
-----------------------------------

   You may use multiple ep-package statements, as in

     <ep-package name="HTML::EP::Locale">
     <ep-package name="HTML::EP::Session">

   Your object will be blessed into a new class, that inherits from both.
However, note that the order is reversed: In the above example, your
object will be an instance of class HTML::EP::PACK2 and
HTML::EP::PACK2::ISA will be set to

     qw(HTML::EP::Session HTML::EP::Locale)

CHANGES
=======

   This section describes user visible changes against previous versions.
For details and other modifications see the `ChangeLog' file, that is part
of the distribution.

epparse
epperl
     In previous versions it was not possible to include EP variables or
     Perl code in attributes of EP commands, unless using a prefix
     `epparse-' or `epperl-', as in

          <ep-mail to=joe epparse-from="$cgi->mail$" subject=Hello>

     This is no longer the case, because the package now autodetects
     whether you are using such constructs. (At least it should. :-) The
     obvious disadvantage is an incompatibility, but the new version is
     much better readable and surprisingly even (much!) faster, because
     only hash values are modified and not hash structures.

TODO
====


     Create an EP server that is accessible via a small C wrapper


     Add a preprocessor, that creates Perl code as output.

AUTHOR AND COPYRIGHT
====================

   This module is

     Copyright (C) 1998-1999	Jochen Wiedmann
                           	Am Eisteich 9
                           	72555 Metzingen
                           	Germany

     Phone: +49 7123 14887
     Email: joe@ispsoft.de

   All rights reserved.

   You may distribute this module under the terms of either the GNU
General Public License or the Artistic License, as specified in the Perl
README file.

SEE ALSO
========

   `DBI(3)' in this node, `CGI(3)' in this node, `HTML::Parser(3)' in this
node


