This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Tie/CharArray,  Next: Tie/Collection,  Prev: Tie/CacheHash,  Up: Module List

Access Perl scalars as arrays of characters
*******************************************

NAME
====

   Tie::CharArray - Access Perl scalars as arrays of characters

SYNOPSIS
========

     use Tie::CharArray;
     my $foobar = 'a string';

     tie my @foo, 'Tie::CharArray', $foobar;
     $foo[0] = 'A';    # $foobar = 'A string'
     push @foo, '!';   # $foobar = 'A string!'
     print "@foo\n";   # prints: A   s t r i n g !

     tie my @bar, 'Tie::CharArray::Ord', $foobar;
     $bar[0]--;        # $foobar = '@ string!'
     pop @bar;         # $foobar = '@ string'
     print "@bar\n";   # prints: 64 32 115 116 114 105 110 103

DESCRIPTION
===========

   In low-level programming languages such as C, and to some extent Java,
strings are not primitive data types but arrays of characters, which in
turn are treated as integers.  This closely matches the internal
representation of strings in the memory.

   Perl, on the other hand, abstracts such internal details away behind
the concept of scalars, which can be treated as either strings or numbers,
and appear as primitive types to the programmer.  This often better
matches the way people think about the data, which facilitates programming
by making common high-level manipulation tasks trivial.

   Sometimes, though, the low-level view is better suited for the task at
hand.  Perl does offer functions such as ord()/chr(), pack()/unpack() and
substr() that can be used to solve such tasks with reasonable efficiency.
For someone used to the direct access to the internal representation
offered by other languages, however, these functions may feel awkward.
While this is often only a symptom of thinking in un-Perlish terms,
sometimes being able to manipulate strings as character arrays really does
simplify the code, making the intent more obvious by eliminating syntactic
clutter.

   This module provides a way to manipulate Perl strings through tied
arrays.  The operations are implemented in terms of the aforementioned
string manipulation functions, but the programmer normally need not be
aware of this.  As Perl has no primitive character type, two alternative
representations are provided:

Strings as arrays of single-character strings
---------------------------------------------

   The first way is to represent characters as strings of length 1.  In
most cases this is the most convenient representation, as such
"characters" can be printed without explicit transformations and written
as ordinary Perl string literals.

   This representation is provided by the main class Tie::CharArray.  As
the class maps most array operations directly to calls to substr(),
several features of that function apply.  (Below, `@foo' is an array tied
to Tie::CharArray and $n is a positive integer.)

   * `$foo[@foo]' is an empty string, `$foo[@foo+$n]' is undef.

   * Assigning to `$foo[@foo+$n]' is a fatal error.  So is splice() beyond
     the end of the array.

   * If you assign an empty string (or undef) to an element, any later
     elements are shifted down.

   * If you assign a string longer than one character to an element, any
     later elements are shifted up.

   In general, if you only put one-character strings into the array, and
don't go beyond its end, there should be no problems.

Strings as arrays of small integers
-----------------------------------

   While the representation described above is usually the most convenient
one, it still does not allow direct arithmetic manipulation of the
character code values.  For tasks where this is needed, an alternative
representation is provided by the subclass Tie::CharArray::Ord.  Note that
it is perfectly possible to manipulate a single string through both
interfaces at the same time.  As the array operations are still based on
substr(), the first two of the above caveats apply here as well.

BUGS
====

   Exposing the peculiarities of substr() to the user might be considered
a bug.  In any case, it is a feature which one should probably not rely
on, as it might change in future revisions.

AUTHORS
=======

   Copyright 2000, Ilmari Karonen.  All rights reserved.

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

   Address bug reports and comments to: perl@itz.pp.sci.fi

SEE ALSO
========

   Tie::Array, substr()


File: pm.info,  Node: Tie/Collection,  Next: Tie/Counter,  Prev: Tie/CharArray,  Up: Module List

A trivial implementaion of Tie::Cache by using a tied handle of a hash for storage.
***********************************************************************************

NAME
====

   Tie::Collection - A trivial implementaion of Tie::Cache by using a tied
handle of a hash for storage.

SYNOPSIS
========

   use Tie::Collection; use DB_File; use Fcntl;

   $dbm = tie %hash2, DB_File, 'file.db', O_RDWR | O_CREAT, 0644; tie
%hash, Tie::Collection, $dbm, {MaxBytes => $cache_size};

DESCRIPTION
===========

   Tie::Collection implements a trivial implementation of *Tie::Cache* by
Joshua Chamas, that gets a tied hash handle to store the data. Assumption
was that most common use will be disk storage, therfore the storage hash
will probably be tied.

   Tie::Collection is useful with DB_File or *MLDBM*, as will as with
*Tie::DBI*. It was designed to be used with *HTML::HTPL* in order to cache
objects accesses via a key, so they don't have to be read from disk again
and again.

   Tie::Collection needs two parameters: The handled of the tied hash, and
a hashref with parameters to pass to *Tie::Cache*. (See manpage).

AUTHOR
======

   Ariel Brosh, schop@cpan.org.  *Tie::Cache* was written by Joshua
Chamas, chamas@alumni.stanford.org

SEE ALSO
========

   perl(1), *Note Tie/Cache: Tie/Cache,.

COPYRIGHT
=========

   Tie::Collection is part of the HTPL package. See `HTML::HTPL' in this
node


File: pm.info,  Node: Tie/Counter,  Next: Tie/Cycle,  Prev: Tie/Collection,  Up: Module List

Have a counter in a scalar.
***************************

NAME
====

   Tie::Counter - Have a counter in a scalar.

SYNOPSIS
========

     use Tie::Counter;

     tie my $counter => 'Tie::Counter';

     my @array = qw /Red Green Blue/;

     foreach my $colour (@array) {           # Prints:
         print "  $counter  $colour\n";      #   0  Red
     }                                       #   1  Green
                                             #   2  Blue

DESCRIPTION
===========

   `Tie::Counter' allows you to tie a scalar in such a way that it
increments each time it is used. This might be useful for interpolating
counters in strings.

   The tie takes an optional extra argument, the first value of the
counter, defaulting to 0. Any argument for which magical increment is
defined on is allowed. Assigning to the counter will set a new value.

REVISION HISTORY
================

     $Log: Counter.pm,v $
     Revision 1.1  1999/07/20 03:03:06  abigail
     Initial revision

AUTHOR
======

   This package was written by Abigail.

COPYRIGHT and LICENSE
=====================

   This package is copyright 1999 by Abigail.

   This program is free and open software. You may use, copy, modify,
distribute and sell this program (and any modified variants) in any way
you wish, provided you do not restrict others to do the same.


File: pm.info,  Node: Tie/Cycle,  Next: Tie/DBI,  Prev: Tie/Counter,  Up: Module List

Cycle through a list of values via a scalar.
********************************************

NAME
====

   Tie::Cycle - Cycle through a list of values via a scalar.

SYNOPSIS
========

     use Tie::Cycle;

     tie my $cycle, 'Tie::Cycle', [ qw( FFFFFF 000000 FFFF00 ) ];

     print $cycle; # FFFFFF
     print $cycle; # 000000
     print $cycle; # FFFF00
     print $cycle; # FFFFFF  back to the beginning

DESCRIPTION
===========

   You use `Tie::Cycle' to go through a list over and over again.  Once
you get to the end of the list, you go back to the beginning.  You don't
have to worry about any of this since the magic of tie does that for you.

   The tie takes an array reference as its third argument.  The tie should
succeed unless the argument is not an array reference or the referenced
array contains less than two elements.

   During the tie, this module makes a shallow copy of the array
reference.  If the array reference contains references, and those
references are changed after the tie, the elements of the cycle will
change as well. See the included test.pl script for an example of this
effect.

AUTHOR
======

   brian d foy <comdog@panix.com>.

COPYRIGHT and LICENSE
=====================

   Copyright 2000 by brian d foy.

   This software is available under the same terms as perl.


File: pm.info,  Node: Tie/DBI,  Next: Tie/DB_File/SplitHash,  Prev: Tie/Cycle,  Up: Module List

Tie hashes to DBI relational databases
**************************************

NAME
====

   Tie::DBI - Tie hashes to DBI relational databases

SYNOPSIS
========

     use Tie::DBI;
     tie %h,Tie::DBI,'mysql:test','test','id',{CLOBBER=>1};

     tie %h,Tie::DBI,{db       => 'mysql:test',
     		   table    => 'test',
                      key      => 'id',
                      user     => 'nobody',
                      password => 'ghost',
                      CLOBBER  => 1};

     # fetching keys and values
     @keys = keys %h;
     @fields = keys %{$h{$keys[0]}};
     print $h{'id1'}->{'field1'};
     while (($key,$value) = each %h) {
       print "Key = $key:\n";
       foreach (sort keys %$value) {
     	print "\t$_ => $value->{$_}\n";
       }
     }

     # changing data
     $h{'id1'}->{'field1'} = 'new value';
     $h{'id1'} = { field1 => 'newer value',
                   field2 => 'even newer value',
                   field3 => "so new it's squeaky clean" };

     # other functions
     tied(%h)->commit;
     tied(%h)->rollback;
     tied(%h)->select_where('price > 1.20');
     @fieldnames = tied(%h)->fields;
     $dbh = tied(%h)->dbh;

DESCRIPTION
===========

   This module allows you to tie Perl associative arrays (hashes) to SQL
databases using the DBI interface.  The tied hash is associated with a
table in a local or networked database.  One column becomes the hash key.
Each row of the table becomes an associative array, from which individual
fields can be set or retrieved.

USING THE MODULE
================

   To use this module, you must have the DBI interface and at least one
DBD (database driver) installed.  Make sure that your database is up and
running, and that you can connect to it and execute queries using DBI.

Creating the tie
----------------

     tie %var,Tie::DBI,[database,table,keycolumn] [,\%options]

   Tie a variable to a database by providing the variable name, the tie
interface (always "Tie::DBI"), the data source name, the table to tie to,
and the column to use as the hash key.  You may also pass various flags to
the interface in an associative array.

database
     The database may either be a valid DBI-style data source string of the
     form "dbi:driver:database_name[:other information]", or a database
     handle that has previously been opened.  See the documentation for DBI
     and your DBD driver for details.  Because the initial "dbi" is always
     present in the data source, Tie::DBI will add it for you if necessary.

     Note that some drivers (Oracle in particular) have an irritating habit
     of appending blanks to the end of fixed-length fields.  This will
     screw up Tie::DBI's routines for getting key names.  To avoid this you
     should create the database handle with a ChopBlanks option of TRUE.
     You should also use a *PrintError* option of true to avoid complaints
     during STORE and LISTFIELD calls.

table
     The table in the database to bind to.  The table must previously have
     been created with a SQL CREATE statement.  This module will not create
     tables for you or modify the schema of the database.

key
     The column to use as the hash key.  This column must prevoiusly have
     been defined when the table was created.  In order for this module to
     work correctly, the key column must be unique and not nullable.  For
     best performance, the column should be also be declared a key.  These
     three requirements are automatically satisfied for primary keys.

   It is possible to omit the database, table and keycolumn arguments, in
which case the module tries to retrieve the values from the options array.
The options array contains a set of option/value pairs.  If not provided,
defaults are assumed.  The options are:

user
     Account name to use for database authentication, if necessary.
     Default is an empty string (no authentication necessary).

password
     Password to use for database authentication, if necessary.  Default is
     an empty string (no authentication necessary).

db
     The database to bind to the hash, if not provided in the argument
     list.  It may be a DBI-style data source string, or a
     previously-opened database handle.

table
     The name of the table to bind to the hash, if not provided in the
     argument list.

key
     The name of the column to use as the hash key, if not provided in the
     argument list.

CLOBBER (default 0)
     This controls whether the database is writable via the bound hash.  A
     zero value (the default) makes the database essentially read only.  An
     attempt to store to the hash will result in a fatal error.  A CLOBBER
     value of 1 will allow you to change individual fields in the database,
     and to insert new records, but not to delete entire records.  A
     CLOBBER value of 2 allows you to delete records, but not to erase the
     entire table.  A CLOBBER value of 3 or higher will allow you to erase
     the entire table.

          Operation                       Clobber      Comment

          $i = $h{strawberries}->{price}     0       All read operations
          $h{strawberries}->{price} += 5     1       Update fields
          $h{bananas}={price=>23,quant=>3}   1       Add records
          delete $h{strawberries}            2       Delete records
          %h = ()                            3       Clear entire table
          undef %h                           3       Another clear operation

     All database operations are contingent upon your access privileges.
     If your account does not have write permission to the database, hash
     store operations will fail despite the setting of CLOBBER.

AUTOCOMMIT (default 1)
     If set to a true value, the "autocommit" option causes the database
     driver to commit after every store statement.  If set to a false
     value, this option will not commit to the database until you
     explicitly call the Tie::DBI commit() method.

     The autocommit option defaults to true.

DEBUG (default 0)
     When the DEBUG option is set to a non-zero value the module will echo
     the contents of SQL statements and other debugging information to
     standard error.  Higher values of DEBUG result in more verbose (and
     annoying) output.

WARN (default 1)
     If set to a non-zero value, warns of illegal operations, such as
     attempting to delete the value of the key column.  If set to a zero
     value, these errors will be ignored silently.

USING THE TIED ARRAY
====================

   The tied array represents the database table.  Each entry in the hash
is a record, keyed on the column chosen in the tie() statement.
Ordinarily this will be the table's primary key, although any unique
column will do.

   Fetching an individual record returns a reference to a hash of field
names and values.  This hash reference is itself a tied object, so that
operations on it directly affect the database.

Fetching information
--------------------

   In the following examples, we will assume a database table structured
like this one:

     -produce-
         produce_id    price   quantity   description

     strawberries  1.20    8          Fresh Maine strawberries
     apricots      0.85    2          Ripe Norwegian apricots
     bananas       1.30    28         Sweet Alaskan bananas
     kiwis         1.50    9          Juicy New York kiwi fruits
     eggs          1.00   12          Farm-fresh Atlantic eggs

   We tie the variable %produce to the table in this way:

     tie %produce,Tie::DBI,{db    => 'mysql:stock',
                            table => 'produce',
                            key   => 'produce_id',
                            CLOBBER => 2 # allow most updates
                            };

   We can get the list of keys this way:

     print join(",",keys %produce);
        => strawberries,apricots,bananas,kiwis

   Or get the price of eggs thusly:

     $price = $produce{eggs}->{price};
     print "The price of eggs = $price";
         => The price of eggs = 1.2

   String interpolation works as you would expect:

     print "The price of eggs is still $produce{eggs}->{price}"
         => The price of eggs is still 1.2

   Various types of syntactic sugar are allowed.  For example, you can
refer to $produce{eggs}{price} rather than $produce{eggs}->{price}.  Array
slices are fully supported as well:

     ($apricots,$kiwis) = @produce{apricots,kiwis};
     print "Kiwis are $kiwis->{description};
         => Kiwis are Juicy New York kiwi fruits

     ($price,$description) = @{$produce{eggs}}{price,description};
         => (2.4,'Farm-fresh Atlantic eggs')

   If you provide the tied hash with a comma-delimited set of record
names, and you are not requesting an array slice, then the module does
something interesting.  It generates a single SQL statement that fetches
the records from the database in a single pass (rather than the multiple
passes required for an array slice) and returns the result as a reference
to an array.  For many records, this can be much faster.  For example:

     $result = $produce{apricots,bananas};
         => ARRAY(0x828a8ac)

     ($apricots,$bananas) = @$result;
     print "The price of apricots is $apricots->{price}";
         => The price of apricots is 0.85

   Field names work in much the same way:

     ($price,$quantity) = @{$produce{apricots}{price,quantity}};
     print "There are $quantity apricots at $price each";
         => There are 2 apricots at 0.85 each";

Updating information
--------------------

   If CLOBBER is set to a non-zero value (and the underlying database
privileges allow it), you can update the database with new values.  You
can operate on entire records at once or on individual fields within a
record.

   To insert a new record or update an existing one, assign a hash
reference to the record.  For example, you can create a new record in
%produce with the key "avocados" in this manner:

     $produce{avocados} = { price       => 2.00,
                            quantity    => 8,
                            description => 'Choice Irish avocados' };

   This will work with any type of hash reference, including records
extracted from another table or database.

   Only keys that correspond to valid fields in the table will be
accepted.  You will be warned if you attempt to set a field that doesn't
exist, but the other fields will be correctly set.  Likewise, you will be
warned if you attempt to set the key field.  These warnings can be turned
off by setting the WARN option to a zero value.  It is not currently
possible to add new columns to the table.  You must do this manually with
the appropriate SQL commands.

   The same syntax can be used to update an existing record.  The fields
given in the hash reference replace those in the record.  Fields that
aren't explicitly listed in the hash retain their previous values.  In the
following example, the price and quantity of the "kiwis" record are
updated, but the description remains the same:

     $produce{kiwis} = { price=>1.25,quantity=>20 };

   You may update existing records on a field-by-field manner in the
natural way:

     $produce{eggs}{price} = 1.30;
     $produce{eggs}{price} *= 2;
     print "The price of eggs is now $produce{eggs}{price}";
         => The price of eggs is now 2.6.

   Obligingly enough, you can use this syntax to insert new records too,
as in $produce{mangoes}{description}="Sun-ripened Idaho mangoes".
However, this type of update is inefficient because a separate SQL
statement is generated for each field.  If you need to update more than
one field at a time, use the record-oriented syntax shown earlier.  It's
much more efficient because it gets the work done with a single SQL
command.

   Insertions and updates may fail for any of a number of reasons, most
commonly:

  1. You do not have sufficient privileges to update the database

  2. The update would violate an integrity constraint, such as making a
     non-nullable field null, overflowing a numeric field, storing a
     string value in a numeric field, or violating a uniqueness constraint.
        The module dies with an error message when it encounters an error
during an update.  To trap these erorrs and continue processing, wrap the
update an eval().

Other functions
---------------

   The tie object supports several useful methods.  In order to call these
methods, you must either save the function result from the tie() call
(which returns the object), or call tied() on the tie variable to recover
the object.

connect(), error(), errstr()
     These are low-level class methods.  Connect() is responsible for
     establishing the connection with the DBI database.  Errstr() and
     error() return $DBI::errstr and $DBI::error respectively.  You may
     may override these methods in subclasses if you wish.  For example,
     replace connect() with this code in order to use persistent database
     connections in Apache modules:

          use Apache::DBI;  # somewhere in the declarations
          sub connect {
          my ($class,$dsn,$user,$password,$options) = @_;
             return Apache::DBI->connect($dsn,$user,
                                         $password,$options);
          }

commit()
          (tied %produce)->commit();

     When using a database with the autocommit option turned off, values
     that are stored into the hash will not become permanent until commit()
     is called.  Otherwise they are lost when the application terminates or
     the hash is untied.

     Some SQL databases don't support transactions, in which case you will
     see a warning message if you attempt to use this function.

rollback()
          (tied %produce)->rollback();

     When using a database with the autocommit option turned off, this
     function will roll back changes to the database to the state they were
     in at the last commit().  This function has no effect on database that
     don't support transactions.

select_where()
          @keys=(tied %produce)->select_where('price > 1.00 and quantity < 10');

     This executes a limited form of select statement on the tied table and
     returns a list of records that satisfy the conditions.  The argument
     you provide should be the contents of a SQL WHERE clause, minus the
     keyword "WHERE" and everything that ordinarily precedes it.  Anything
     that is legal in the WHERE clause is allowed, including function
     calls, ordering specifications, and sub-selects.  The keys to those
     records that meet the specified conditions are returned as an array,
     in the order in which the select statement returned them.

     Don't expect too much from this function.  If you want to execute a
     complex query, you're better off using the database handle (see below)
     to make the SQL query yourself with the DBI interface.

dbh()
          $dbh = (tied %produce)->dbh();

     This returns the tied hash's underlying database handle.  You can use
     this handle to create and execute your own SQL queries.

CLOBBER, DEBUG, WARN
     You can get and set the values of CLOBBER, DEBUG and WARN by directly
     accessing the object's hash:

          (tied %produce)->{DEBUG}++;

     This lets you change the behavior of the tied hash on the fly, such as
     temporarily granting your program write permission.

     There are other variables there too, such as the name of the key
     column and database table.  Change them at your own risk!

PERFORMANCE
===========

   What is the performance hit when you use this module rather than the
direct DBI interface?  It can be significant.  To measure the overhead, I
used a simple benchmark in which Perl parsed a 6180 word text file into
individual words and stored them into a database, incrementing the word
count with each store.  The benchmark then read out the words and their
counts in an each() loop.  The database driver was mySQL, running on a 133
MHz Pentium laptop with Linux 2.0.30.  I compared Tie::RDBM, to DB_File,
and to the same task using vanilla DBI SQL statements.  The results are
shown below:

     UPDATE         FETCH
       Tie::DBI      70 s        6.1  s
       Vanilla DBI   14 s        2.0  s
       DB_File        3 s        1.06 s

   There is about a five-fold penalty for updates, and a three-fold
penalty for fetches when using this interface.  Some of the penalty is due
to the overhead for creating sub-objects to handle individual fields, and
some of it is due to the inefficient way the store and fetch operations
are implemented.  For example, using the tie interface, a statement like
$h{record}{field}++ requires as much as four trips to the database: one to
verify that the record exists, one to fetch the field, and one to store
the incremented field back.  If the record doesn't already exist, an
additional statement is required to perform the insertion.  I have
experimented with cacheing schemes to reduce the number of trips to the
database, but the overhead of maintaining the cache is nearly equal to the
performance improvement, and cacheing raises a number of potential
concurrency problems.

   Clearly you would not want to use this interface for applications that
require a large number of updates to be processed rapidly.

BUGS
====

BUGS
====

   The each() call produces a fatal error when used with the Sybase driver
to access Microsoft SQL server. This is because this server only allows
one query to be active at a given time.  A workaround is to use keys() to
fetch all the keys yourself.  It is not known whether real Sybase
databases suffer from the same problem.

   The delete() operator will not work correctly for setting field values
to null with DBD::CSV or with DBD::Pg.  CSV files do not have a good
conception of database nulls.  Instead you will set the field to an empty
string.  DBD::Pg just seems to be broken in this regard.

AUTHOR
======

   Lincoln Stein, lstein@cshl.org

COPYRIGHT
=========

     Copyright (c) 1998, Lincoln D. Stein

   This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

AVAILABILITY
============

   The latest version can be obtained from:

     http://www.genome.wi.mit.edu/~lstein/Tie-DBI/

SEE ALSO
========

   perl(1), DBI(3), Tie::RDBM(3)


File: pm.info,  Node: Tie/DB_File/SplitHash,  Next: Tie/DB_FileLock,  Prev: Tie/DBI,  Up: Module List

A wrapper around the DB_File Berkeley database system
*****************************************************

NAME
====

   Tie::DB_File::SplitHash - A wrapper around the DB_File Berkeley
database system

SYNOPSIS
========

     use Tie::DB_File::SplitHash;

     [$X =] tie %hash,  'Tie::DB_File::SplitHash', $filename, $flags, $mode, $DB_HASH, $multi_n;

     $status = $X->del($key [, $flags]) ;
     $status = $X->put($key, $value [, $flags]) ;
     $status = $X->get($key, $value [, $flags]) ;
     $status = $X->seq($key, $value, $flags) ;
     $status = $X->sync([$flags]) ;
     $status = $X->fd ;

     untie %hash ;

   $multi_n determines the 'spread out' or number of files the hash will be
split between. The larger the number, the larger the final hash can be.

DESCRIPTION
===========

   Transparently splits a Berkeley database (DB_File) into multiple files
to allow the exceeding of file system limits on file size. From the
outside, it behaves identically with Berkeley DB hash support in general.
This has the potential to greatly expand the amount of data that can be
stored on a file size limitted file system.

   It does so by taking a SHA1 hash of the key to be stored, folding the
resulting hash into a value from 0 to X and storing the data to a db file
selected by the value 0 to X. The randomizing behavior of the SHA1 and
subsequent fold down distribute the records essentially randomly between
the X+1 database files, raising the capacity of the database to (X+1)
times the capacity of a single file database on the average.

   NOTE: Using an 'in-memory' database is not supported by this.  Use
DB_File directly if you want to do that. Additionally, BTREE and RECNO DBs
are not supported.

CHANGES
=======

   1.01 2000.03.06 - Removed 'dependancies' on built-ins that caused
'make' failures                   and added install tests.

`DESTROY;'
     Called when the tied object is being destroyed.

COPYRIGHT
=========

   Copyright 1999, Benjamin Franz (<URL:http://www.nihongo.org/snowhare/>)
and FreeRun Technologies, Inc. (<URL:http://www.freeruntech.com/>). All
Rights Reserved.  This software may be copied or redistributed under the
same terms as Perl itelf.

AUTHOR
======

   Benjamin Franz

TODO
====

   Testing.

VERSION
=======

   1.01 - 2000.03.06


File: pm.info,  Node: Tie/DB_FileLock,  Next: Tie/DB_Lock,  Prev: Tie/DB_File/SplitHash,  Up: Module List

Locking access to Berkeley DB 1.x
*********************************

NAME
====

   Tie::DB_FileLock - Locking access to Berkeley DB 1.x

SYNOPSIS
========

     use Tie::DB_FileLock;

     [$X =] tie %hash, 'Tie::DB_FileLock', [$file, $flags, $mode, $DB_HASH];
     [$X =] tie %hash, 'Tie::DB_FileLock', $file, $flags, $mode, $DB_BTREE;

     $X->debug($value);

     $status = $X->del($key [, $flags]);
     $status = $X->put($key, $value [, $flags]);
     $status = $X->get($key, $value [, $flags]);
     $status = $X->seq($key, $value, $flags);
     $status = $X->sync([$flags]);
     $status = $X->fd();

     # BTREE only
     $count = $X->get_dup($key);
     @list  = $X->get_dup($key);
     %list  = $X->get_dup($key, 1);
     $status = $X->find_dup($key, $value);
     $status = $X->del_dup($key, $value);

     # DBM Filters
     $old_filter = $db->filter_store_key  ( sub { ... } );
     $old_filter = $db->filter_store_value( sub { ... } );
     $old_filter = $db->filter_fetch_key  ( sub { ... } );
     $old_filter = $db->filter_fetch_value( sub { ... } );

     [undef $X;]
     untie %hash;

DESCRIPTION
===========

   Module DB_File allows perl to tie hashes to on-disk dbm files, but
fails to provide any method by which the hashes might be locked, providing
exclusive access or preventing page-level collisions.  Tie::DB_FileLock
extends DB_File, providing a locking layer using flock().

   Unlike Tie::DB_Lock, Tie::DB_FileLock does not duplicate files to allow
concurrent access for readers and writers.  Tie::DB_FileLock is therefore
suitable for large dbms with relatively short locking periods.

   Tie::DB_FileLock is designed as a drop-in replacement for DB_File,
requiring minimal code changes.  Change all occurrences of "DB_File" to
"Tie::DB_FileLock" and all should be well.  DB_RECNO is not presently
supported by Tie::DB_FileLock.

   Arguments to Tie::DB_FileLock are identical as those to DB_File.  The
dbm is locked for shared access if opened RO, exclusively otherwise.  The
default, as in DB_File, is read/write/create.

   Use of the predefined references $DB_HASH, $DB_BTREE, and $DB_RECNO, is
identical as with DB_File.  When creating your own, the new call is the
same, but the object created is a DB_File::XXX thing and not a
Tie::DB_FileLock::XXX thing - therefore error messages will refer to
DB_File::XXX.

LOCKING
=======

   The locking autoline presented by 'Programming Perl' is incorrect for
multiple simultaneous writers.  The problem is that a successful flock()
lags the tie() by some amount of time.  However the snapshot of the
on-disk dbm is that from the time of the tie() and not of the flock(),
therefore once the flock() succeeds, the dbm may have changed and
therefore must be tie()ed again, loading the latest state of the dbm.

   Locking cannot be at the level of methods like FETCH() and STORE()
because then statements like $hash{$a}++ are not atomic: that is, a
different access could (will) take place between the FETCH($a) and the
STORE($a + 1).

   Therefore locking must occur at a coarser level and the programmer must
not dawdle when locks are active.  In the case of loops, an effort need be
made to untie() the dbm periodically, permitting other processes their
due.  At some additional cost, a program may yield access to others by
breaking a loop like:

     tie(%db, 'Tie::DB_FileLock', "arg1.db");
     foreach (1..10000) { accesses; }
     untie(%db);

   into:

     my $dbobj = tie(%db, 'Tie::DB_FileLock', "arg1.db");
     foreach (1..10000) {
       accesses;
       if ($_ % 100 == 0) {
          $dbobj->unlockDB();
          $dbobj->lockDB();
       }
     }
     untie(%db);

SPEED
=====

   The first law of thermodynamics holds true for object methods.  Access
through DB_FileLock is slower than through DB_File.  Working with a 40meg
dbm containing 110k records, we find

     Keys	Values	Store
     	DB_File		30s	35s	55s
     	DB_FileLock	40s	45s	60s

   All values +/- ~3s.  YMMV.  Previous versions of DB_FileLock had a very
inefficient FIRSTKEY() routine.

AUTHOR
======

   John M Vinopal, banshee@resort.com

SEE ALSO
========

   DB_File(3p).


File: pm.info,  Node: Tie/DB_Lock,  Next: Tie/Dir,  Prev: Tie/DB_FileLock,  Up: Module List

ties hashes to databases using shared and exclusive locks
*********************************************************

NAME
====

   Tie::DB_Lock - ties hashes to databases using shared and exclusive locks

SYNOPSIS
========

     use Tie::DB_Lock;
     use DB_File;
     
     tie(%hash, 'Tie::DB_Lock', $filename, 'rw');  # Open for writing
     $hash{'key'} = 'value';
     untie %hash;
     
     tie(%hash2, 'Tie::DB_Lock', $filename); # Default is read-only
     print("Value is $hash2{'key'}\n");
     untie %hash;

DESCRIPTION
===========

   This is a front-end for the DB_File package.

   If you tie a hash in read-only mode, this module puts a shared lock on
the database file, copies it to a temporary file, unlocks the original
database, and then ties the tempfile using DB_File.

   If you tie the hash in read-write mode, we put an exclusive lock on the
database and tie it directly using DB_File.

   The reason I copy the whole file every time I read from it is that this
allows the program to read from the file for as long as it wants to,
without interfering with other people's writes.  This works well if you
typically have long, sustained reads, and short, bursty writes.  See the
README file for help in deciding whether you want to use this package.

   You don't always need to call untie() explicitly - it will be called for
you when %hash goes out of scope.  And if all goes as planned, you'll never
know the temporary file ever existed, since it will evaporate when %hash
goes away.

OPTIONS
=======

   * $Tie::DB_Lock::TEMPDIR

     You can specify the directory in which to place the temporary files
     that get created when you open a database for read-only access.  To
     do so, set the variable `$Tie::DB_Lock::TEMPDIR' to the directory you
     want to use.  You may get the best results if your temporary
     directory resides on the same disk (or filesystem) as your databases.

   * $Tie::DB_Lock::WAIT_TIME

   * $Tie::DB_Lock::RETRIES

     By default, DB_Lock will try once every second for fifteen seconds to
     put locks on the things it's trying to lock.  After that it will give
     up.  Change the number of seconds between attempts by setting the
     value of `$Tie::DB_Lock::WAIT_TIME' (must be an integer), and change
     the number of attempts by setting the value of
     `$Tie::DB_Lock::RETRIES'.

   * $Tie::DB_Lock::VERBOSE

     If you think something funny is going on with your database and you
     want to watch the locking process happening, you can set the variable
     `$Tie::DB_Lock::VERBOSE' to a true value.  A bunch of diagnostic
     messages will get printed to STDERR.

   * $Tie::DB_Lock::TIEPACK

     Don't change this unless you're sure.  If you change it, DB_Lock will
     use a different back-end database TIEHASH package instead of DB_File.
     Any database you want to use must reside entirely in a single file
     so that it can be locked properly and copied to the temporary
     directory.

WARNINGS
========

   Whenever a tie() fails because a lock blocked your access, tie() will
return the undefined value.  CHECK THE RETURN VALUE from tie()!

     tie(%hash, 'Tie::DB_Lock', $file, 'rw') or die $!;

   If you don't check the return value, you'll probably continue on your
merry way, thinking that you opened the database when in fact you didn't.

A NOTE ON DEADLOCK, by Jay Scott
================================

   Deadlock is rare, but it's awful when it happens.

   If each process wants more than one DB file before it can start work,
and processes do not all ask for their DB files in the same order, and the
processes write, then there's a risk of deadlock. The simplest case is
that process 1 wants files A and B and holds A, and process 2 wants A and
B and holds B. Neither process can get what it needs, and they both wait
forever. To avoid this, do one of the following: (1) Have all processes
open DB files in the same order, first A, then B. (2) Use a special
locking or coordination scheme.

   Deadlock can happen pretty much whenever you're using locks on a
resource.

TO DO
=====

     Maybe change from using FileHandle to IO::File?  Benchmarks involved.
     
     Allow other database back-ends than DB_File.

AUTHOR
======

   Ken Williams				ken@forum.swarthmore.edu

   Copyright (c) 1998 Ken Williams. All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

SEE ALSO
========

   perl(1), perltie(1), perlfunc(1), DB_File(3)


File: pm.info,  Node: Tie/Dir,  Next: Tie/Discovery,  Prev: Tie/DB_Lock,  Up: Module List

class definition for reading directories via a tied hash
********************************************************

NAME
====

   Tie::Dir - class definition for reading directories via a tied hash

SYNOPSIS
========

     use Tie::Dir qw(DIR_UNLINK);
     
     # Both of these produce identical results
     #(ie %hash is tied)
     tie %hash, Tie::Dir, ".", DIR_UNLINK;
     new Tie::Dir \%hash, ".", DIR_UNLINK;
     
     # This creates a reference to a hash, which is tied.
     $hash = new Tie::Dir ".";
     
     # All these examples assume that %hash is tied (ie one of the
     # first two tie methods was used
     
     # itterate through the directory
     foreach $file ( keys %hash ) {
     	...
     }
     
     # Set the access and modification times (touch :-)
     $hash{SomeFile} = time;
     
     # Obtain stat information of a file
     @stat = @{$hash{SomeFile}};
     
     # Check if entry exists
     if(exists $hash{SomeFile}) {
     	...
     }
     
     # Delete an entry, only if DIR_UNLINK specified
     delete $hash{SomeFile};

DESCRIPTION
===========

   This module provides a method of reading directories using a hash.

   The keys of the hash are the directory entries and the values are a
reference to an array which holds the result of stat being called on the
entry.

   The access and modification times of an entry can be changed by
assigning to an element of the hash. If a single number is assigned then
the access and modification times will both be set to the same value,
alternatively the access and modification times may be set separetly by
passing a reference to an array with 2 entries, the first being the access
time and the second being the modification time.

new [hashref,] dirname [, options]
     This method ties the hash referenced by `hashref' to the directory
     `dirname'.  If `hashref' is omitted then new returns a reference to a
     hash which hash been tied, otherwise it returns the result of tie

     The possible options are:

    DIR_UNLINK
          Delete operations on the hash will cause unlink to be called on
          the corresponding file

AUTHOR
======

   Graham Barr <bodg@tiuk.ti.com>, from a quick hack posted by Kenneth
Albanowski <kjahds@kjahds.com>  to the perl5-porters mailing list based on
a neat idea by Ilya Zakharevich.


File: pm.info,  Node: Tie/Discovery,  Next: Tie/EncryptedHash,  Prev: Tie/Dir,  Up: Module List

Perl extension for `Discovery' hashes
*************************************

NAME
====

   Tie::Discovery - Perl extension for `Discovery' hashes

SYNOPSIS
========

     use Tie::Discovery;
     my %config = ();
     my $obj = tie %config, "Tie::Discovery";

     sub discover_os { ... }
     $obj->register("os",\&discover_os);

     $config{os};

DESCRIPTION
===========

   A `discovery' hash is a hash that's designed to help you solve the data
dependency problem. It's based on the principle of least work; some times,
you may spend a lot of time in your program finding out paths, filenames,
operating system specifics, network information and so on that you may not
end up using. Discovery hashes allow you to get the data when you need it,
and only when you need it.

   To use a discovery hash, first tie a hash as shown above. You will want
to keep hold of the object returned by tie. You can then add things to
discover by calling the register method as shown above. The above code
`$obj->register("os",\&discover_os);' means that when (and only when!) the
value `$config{os}' is fetched, the sub `&discover_os' will be called to
find it. The return value of that sub will then be cached to save a
look-up next time.

   The real power comes from the fact that you may refer to the tied hash
inside of the discovery subroutines. This allows for fast, neat and
flexible top-down programming, and helps you avoid hard-coding values.
For instance, let us find the OS by calling the uname program.

     $obj->register( os => sub { `$config{path_to_uname}` } );

   Now we need code to find the program itself:

     use File::Spec::Functions;
     $obj->register( path_to_uname => sub {
     	foreach (path) {
     		return catfile($_,"uname") if -x catfile($_,"uname")
     	}
     	die "Couldn't even find uname"
     };

   Fetching `$config{os}' may now need a further call to fetch
`$config{path_to_uname}' unless the path is already cached. And, of
course, we needn't stop at two levels.

   Fuller examples of this technique are seen in the forthcoming `CTAN' in
this node and `SysConf' in this node modules.

METHODS
-------

   Aside from the usual hash methods, the following are available:

register(name,sub)
     Registers name as an entry in the hash, to be discovered by running
     sub

store(name,value)
     Stores value directly into the hash under the name key. The only time
     you should need to do this is to set the value of the debug key; if
     set, this shows a trace of the discovery process.

EXPORT
------

   Nothing.

LIMITATIONS
-----------

   At present, since a subroutine reference signifies something to look
up, you can't usefully return one from your discovery subroutine.

AUTHOR
======

   Simon Cozens <simon@cpan.org>

SEE ALSO
========

   perl(1), *Note Tie/Hash: Tie/Hash,


File: pm.info,  Node: Tie/EncryptedHash,  Next: Tie/FileLRUCache,  Prev: Tie/Discovery,  Up: Module List

Hashes (and objects based on hashes) with encrypting fields.
************************************************************

NAME
====

   Tie::EncryptedHash - Hashes (and objects based on hashes) with
encrypting fields.

SYNOPSIS
========

     use Tie::EncryptedHash;

     my %s = ();
     tie %s, Tie::EncryptedHash, 'passwd';

     $s{foo}  = "plaintext";     # Normal field, stored in plaintext.
     print $s{foo};              # (plaintext)
     
     $s{_bar} = "signature";     # Fieldnames that begin in single
                                 # underscore are encrypted.
     print $s{_bar};             # (signature)  Though, while the password
                                 # is set, they behave like normal fields.
     delete $s{__password};      # Delete password to disable access
                                 # to encrypting fields.
     print $s{_bar};             # (Blowfish NuRVFIr8UCAJu5AWY0w...)

     $s{__password} = 'passwd';  # Restore password to gain access.
     print $s{_bar};             # (signature)
     
     $s{_baz}{a}{b} = 42;        # Refs are fine, we encrypt them too.

DESCRIPTION
===========

   Tie::EncryptedHash augments Perl hash semantics to build secure,
encrypting containers of data.  Tie::EncryptedHash introduces special hash
fields that are coupled with encrypt/decrypt routines to encrypt
assignments at STORE() and decrypt retrievals at FETCH().  By design,
*encrypting fields* are associated with keys that begin in single
underscore.  The remaining keyspace is used for accessing normal hash
fields, which are retained without modification.

   While the password is set, a Tie::EncryptedHash behaves exactly like a
standard Perl hash.  This is its *transparent mode* of access.  Encrypting
and normal fields are identical in this mode.  When password is deleted,
encrypting fields are accessible only as ciphertext.  This is
Tie::EncryptedHash's *opaque mode* of access, optimized for serialization.

   Encryption is done with Crypt::CBC(3) which encrypts in the cipher block
chaining mode with Blowfish, DES or IDEA.  Tie::EncryptedHash uses Blowfish
by default, but can be instructed to employ any cipher supported by
Crypt::CBC(3).

MOTIVATION
==========

   Tie::EncryptedHash was designed for storage and communication of key
material used in public key cryptography algorithms.  I abstracted out the
mechanism for encrypting selected fields of a structured data record
because of the sheer convenience of this data security method.

   Quite often, applications that require data confidentiality eschew
strong cryptography in favor of OS-based access control mechanisms because
of the additional costs of cryptography integration.  Besides cipher
implementations, which are available as ready-to-deploy perl modules, use
of cryptography in an application requires code to aid conversion and
representation of encrypted data.  This code is usually encapsulated in a
data access layer that manages encryption, decryption, access control and
re-structuring of flat plaintext according to a data model.
Tie::EncryptedHash provides these functions under the disguise of a Perl
hash so perl applications can use strong cryptography without the cost of
implementing a complex data access layer.

CONSTRUCTION
============

Tied Hash
---------

   `tie %h, Tie::EncryptedHash, 'Password', 'Cipher';'

   Ties %h to Tie::EncryptedHash and sets the value of password and cipher
to 'Password' and 'Cipher'.  Both arguments are optional.

Blessed Object
--------------

   `$h = new Tie::EncryptedHash __password =' 'Password',
       __cipher => 'Cipher';>

   The new() constructor returns an object that is both tied and blessed
into Tie::EncryptedHash.  Both arguments are optional.  When used in this
manner, Tie::EncryptedHash behaves like a class with encrypting data
members.

RESERVED ATTRIBUTES
===================

   The attributes __password, __cipher and __hide are reserved for
communication with object methods.  They are "write-only" from everywhere
except the class to which the hash is tied.  __scaffolding is inaccessible.
Tie::EncryptedHash stores the current encryption password and some
transient data structures in these fields and restricts access to them on
need-to-know basis.

__password
----------

   `$h{__password} = "new password"; delete $h{__password};'

   The password is stored under the attribute __password.  In addition to
specifying a password at construction, assigning to the __password
attribute sets the current encryption password to the assigned value.
Deleting the __password unsets it and switches the hash into opaque mode.

__cipher
--------

   `$h{__cipher} = 'DES'; $h{__cipher} = 'Blowfish';'

   The cipher used for encryption/decryption is stored under the attribute
__cipher.  The value defaults to 'Blowfish'.

__hide
------

   `$h{__hide} = 1;'

   Setting this attribute *hides* encrypting fields in opaque mode.
'undef' is returned at FETCH() and EXISTS().

BEHAVIOR
========

References
----------

   A reference stored in an encrypting field is serialized before
encryption.  The data structure represented by the reference is folded
into a single line of ciphertext which is stored under the first level
key.  In the opaque mode, therefore, only the first level of keys of the
hash will be visible.

Opaque Mode
-----------

   The opaque mode introduces several other constraints on access of
encrypting fields.  Encrypting fields return ciphertext on FETCH() unless
__hide attribute is set, which forces Tie::EncryptedHash to behave as if
encrypting fields don't exist.  Irrespective of __hide, however, DELETE()
and CLEAR() fail in opaque mode.  So does STORE() on an existing
encrypting field.  Plaintext assignments to encrypting fields are silently
ignored, but ciphertext assignments are fine.  Ciphertext assignments can
be used to move data between different EncryptedHashes.

Multiple Passwords and Ciphers
------------------------------

   Modality of Tie::EncryptedHash's access system breaks down when more
than one password is used to with different encrypting fields.  This is a
feature.  Tie::EncryptedHash lets you mix passwords and ciphers in the same
hash.  Assign new values to __password and __cipher and create a new
encrypting field.  Transparent mode will be restricted to fields encrypted
with the current password.

Error Handling
--------------

   Tie::Encrypted silently ignores access errors.  It doesn't carp/croak
when you perform an illegal operation (like assign plaintext to an
encrypting field in opaque mode).  This is to prevent data lossage, the
kind that results from abnormal termination of applications.

QUIRKS
======

Autovivification
----------------

   Due to the nature of autovivified references (which spring into
existence when an undefined reference is dereferenced), references are
stored as plaintext in transparent mode.  Analogous ciphertext
representations are maintained in parallel and restored to encrypting
fields when password is deleted.  This process is completely transparent
to the user, though it's advisable to delete the password after the final
assignment to a Tie::EncryptedHash.  This ensures plaintext
representations and scaffolding data structures are duly flushed.

Data::Dumper
------------

   Serialization of references is done with Data::Dumper, therefore the
nature of data that can be assigned to encrypting fields is limited by what
Data::Dumper can grok.  We set $Data::Dumper::Purity = 1, so
self-referential and recursive structures should be OK.

Speed
-----

   Tie::EncryptedHash'es keep their contents encrypted as much as
possible, so there's a rather severe speed penalty.  With Blowfish,
STORE() on EncryptedHash can be upto 70 times slower than a standard perl
hash.  Reference STORE()'es will be quicker, but speed gain will be
adjusted at FETCH().  FETCH() is about 35 times slower than a standard
perl hash.  DES affords speed improvements of upto 2x, but is not
considered secure for long-term storage of data.  These values were
computed on a DELL PIII-300 Mhz notebook with 128 Mb RAM running perl
5.003 on Linux 2.2.16.  Variations in speed might be different on your
machine.

STANDARD USAGE
==============

   The standard usage for this module would be something along the lines
of: populate Tie::EncryptedHash with sensitive data, delete the password,
serialize the encrypted hash with Data::Dumper, store the result on disk or
send it over the wire to another machine.  Later, when the sensitive data
is required, procure the EncryptedHash, set the password and accesses the
encrypted data fields.

SEE ALSO
========

   Data::Dumper(3), Crypt::CBC(3), Crypt::DES(3), Crypt::Blowfish(3),
Tie::SecureHash(3)

ACKNOWLEDGEMENTS
================

   The framework of Tie::EncryptedHash derives heavily from Damian Conway's
Tie::SecureHash.  Objects that are blessed as well as tied are just one of
the pleasant side-effects of stealing Damian's code.  Thanks to Damian for
this brilliant module.

   PacificNet (http://www.pacificnet.net) loaned me the aforementioned
notebook to hack from the comfort of my bed.  Thanks folks!

AUTHOR
======

   Vipul Ved Prakash <mail@vipul.net>

LICENSE
=======

   Artistic.


