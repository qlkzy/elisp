This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Bio/LiveSeq/Transcript,  Next: Bio/LiveSeq/Translation,  Prev: Bio/LiveSeq/SeqI,  Up: Module List

Transcript class for LiveSeq
****************************

NAME
====

   Bio::LiveSeq::Transcript - Transcript class for LiveSeq

SYNOPSIS
========

     # documentation needed

DESCRIPTION
===========

   This stores informations about coding sequences (CDS).  The
implementation is that a Transcript object accesses a collection of Exon
objects, inferring from them the nucleotide structure and sequence.

AUTHOR - Joseph A.L. Insana
===========================

   Email:  Insana@ebi.ac.uk, jinsana@gmx.net

   Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
---

     Title   : new
     Usage   : $transcript = Bio::LiveSeq::Transcript->new(-exons => \@obj_refs);

     Function: generates a new Bio::LiveSeq::Transcript
     Returns : reference to a new object of class Transcript
     Errorcode -1
     Args    : reference to an array of Exon object references

all_Exons    Title   : all_Exons  Usage   : $transcript_obj->all_Exons()  Function: returns references to all Exon objects the Transcript is composed of  Example : foreach $exon ($transcript->all_Exons()) { do_something }  Returns : array of object references  Args    : none   =cut
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

   sub all_Exons {   my $self=shift;   my $exonsref=$self->{'exons'};   my
@exons=@{$exonsref};   my @newexons;   my $exon;   foreach $exon (@exons) {
   unless ($exon->obj_valid) {       carp "$exon no more valid, start or
end label lost, skipping....";     } else {       push(@newexons,$exon);
 }   }   if ($#exons != $#newexons) {     # update exons field
$self->{'exons'}=\@newexons;   }   return (@newexons); }

downstream_seq    Title   : downstream_seq  Usage   : $transcript_obj->downstream_seq()          : $transcript_obj->downstream_seq(64)  Function: returns a string of nucleotides downstream of the end of the            CDS. If there is some information of the real mRNA, from features in            an attached Gene object, it will return up to those boundaries.            Otherwise it will return 1000 nucleotides.            If an argument is given it will override the default 1000 number            and return instead /that/ requested number of nucleotides.            But if a Gene object is attached, this argument will be ignored.  Returns : string  Args    : an optional integer number of nucleotides to be returned instead of            the default if no gene attached
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

upstream_seq    Title   : upstream_seq  Usage   : $transcript_obj->upstream_seq()          : $transcript_obj->upstream_seq(64)  Function: just like downstream_seq but returns nucleotides before the ATG  Note    : the default, if no Gene information present and no nucleotides            number given, is to return up to 400 nucleotides.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

get_Translation
---------------

     Title   : valid
     Usage   : $translation = $obj->get_Translation()
     Function: retrieves the reference to the object of class Translation (if any)
               attached to a LiveSeq object
     Returns : object reference
     Args    : none

translation_table
-----------------

     Title   : translation_table
     Usage   : $name = $obj->translation_table;
             : $name = $obj->translation_table(11);
     Function: Returns or sets the translation_table used for translating the
               transcript.
               If it has never been set, it will return undef.
     Returns : an integer

frame
-----

     Title   : frame
     Usage   : $frame = $transcript->frame($label);
     Function: Returns the frame of a particular nucleotide.
               Frame can be 0 1 or 2 and means the position in the codon triplet
               of the particulat nucleotide. 0 is the first codon_position.
               Codon_position (1 2 3) is simply frame+1.
               If the label asked for is not inside the Transcript, -1 will be
               returned.
     Args    : a label
     Returns : 0 1 or 2
     Errorcode -1


File: pm.info,  Node: Bio/LiveSeq/Translation,  Next: Bio/LocatableSeq,  Prev: Bio/LiveSeq/Transcript,  Up: Module List

Translation class for LiveSeq
*****************************

NAME
====

   Bio::LiveSeq::Translation - Translation class for LiveSeq

SYNOPSIS
========

     #documentation needed

DESCRIPTION
===========

   This stores informations about aminoacids translations of transcripts.
The implementation is that a Translation object is the translation of a
Transcript object, with different possibilities of manipulation, different
coordinate system and eventually its own ranges (protein domains).

AUTHOR - Joseph A.L. Insana
===========================

   Email:  Insana@ebi.ac.uk, jinsana@gmx.net

   Address:

     EMBL Outstation, European Bioinformatics Institute
     Wellcome Trust Genome Campus, Hinxton
     Cambs. CB10 1SD, United Kingdom

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

new
===

     Title   : new
     Usage   : $protein = Bio::LiveSeq::Translation->new(-transcript => $transcr);

     Function: generates a new Bio::LiveSeq::Translation
     Returns : reference to a new object of class Translation
     Errorcode -1
     Args    : reference to an object of class Transcript

get_Transcript
--------------

     Title   : valid
     Usage   : $transcript = $obj->get_Transcript()
     Function: retrieves the reference to the object of class Transcript (if any)
               attached to a LiveSeq object
     Returns : object reference
     Args    : none

aa_ranges
---------

     Title   : aa_ranges
     Usage   : @proteinfeatures = $translation->aa_ranges()
     Function: to retrieve all the LiveSeq AARange objects attached to a
               Translation, usually created out of a SwissProt database entry
               crossreferenced from an EMBL CDS feature.
     Returns : an array
     Args    : none


File: pm.info,  Node: Bio/LocatableSeq,  Next: Bio/Location/AvWithinCoordPolicy,  Prev: Bio/LiveSeq/Translation,  Up: Module List

A Sequence object with start/end points on it
*********************************************

NAME
====

   Bio::LocatableSeq - A Sequence object with start/end points on it

SYNOPSIS
========

   Give standard usage here

DESCRIPTION
===========

     # a normal sequence object
     $locseq->seq();
     $locseq->id();

     # has start,end points
     $locseq->start();
     $locseq->end();

     # inheriets off RangeI, so range operations possible

     $locseq->overlaps($seqfeature);

FEEDBACK
========

Mailing Lists
-------------

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org          - General discussion
     http://bio.perl.org/MailList.html             - About the mailing lists

   The locatable sequence object was developed mainly because the
SimpleAlign object requires this functionality, and in the rewrite of the
Sequence object we had to decide what to do with this.

   It is, to be honest, not well integrated with the rest of bioperl, for
example, the trunc() function does not return a LocatableSeq object, as
some might have thought. There are all sorts of nasty gotcha's about
interactions between coordinate systems when these sort of objects are
used.

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

start
-----

     Title   : start
     Usage   : $obj->start($newval)
     Function:
     Returns : value of start
     Args    : newvalue (optional)

end
---

     Title   : end
     Usage   : $obj->end($newval)
     Function:
     Returns : value of end
     Args    : newvalue (optional)

strand
------

     Title   : strand
     Usage   : $obj->strand($newval)
     Function:
     Returns : value of strand
     Args    : newvalue (optional)

get_nse
-------

     Title   : get_nse
     Usage   :
     Function:
     Example :
     Returns :
     Args    :


File: pm.info,  Node: Bio/Location/AvWithinCoordPolicy,  Next: Bio/Location/CoordinatePolicyI,  Prev: Bio/LocatableSeq,  Up: Module List

class implementing  Bio::Location::CoordinatePolicy as the average for WITHIN and the widest possible and reasonable range otherwise
************************************************************************************************************************************

NAME
====

   Bio::Location::AvWithinCoordPolicy - class implementing
Bio::Location::CoordinatePolicy as the average for WITHIN and the widest
possible and reasonable range otherwise

SYNOPSIS
========

   See Bio::Location::CoordinatePolicyI

DESCRIPTION
===========

   CoordinatePolicyI implementing objects are used by Bio::LocationI
implementing objects to determine integer-valued coordinates when asked
for it.

   This class will compute the coordinates such that for fuzzy locations
of type WITHIN and BETWEEN the average of the two limits will be returned,
and for all other locations it will return the widest possible range, but
by using some common sense. This means that e.g. locations like "<5..100"
(start before position 5) will return 5 as start (returned values have to
be positive integers).

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp, Jason Stajich
===================================

   Email hlapp@gmx.net, jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

start
-----

     Title   : start
     Usage   : $start = $policy->start($location);
     Function: Get the integer-valued start coordinate of the given location as
               computed by this computation policy.
     Returns : A positive integer number.
     Args    : A Bio::LocationI implementing object.

end
---

     Title   : end
     Usage   : $end = $policy->end($location);
     Function: Get the integer-valued end coordinate of the given location as
               computed by this computation policy.
     Returns : A positive integer number.
     Args    : A Bio::LocationI implementing object.


File: pm.info,  Node: Bio/Location/CoordinatePolicyI,  Next: Bio/Location/Fuzzy,  Prev: Bio/Location/AvWithinCoordPolicy,  Up: Module List

Abstract interface for objects implementing a certain policy of computing integer-valued coordinates of a Location
******************************************************************************************************************

NAME
====

   Bio::Location::CoordinatePolicyI - Abstract interface for objects
implementing a certain policy of computing integer-valued coordinates of a
Location

SYNOPSIS
========

     # get a location, e.g., from a SeqFeature
     $location = $feature->location();
     # examine its coordinate computation policy
     print "Location of feature ", $feature->primary_tag(), " employs a ",
           ref($location->coordinate_policy()),
           " instance for coordinate computation\n";
     # change the policy, e.g. because the user chose to do so
     $location->coordinate_policy(Bio::Location::NarrowestCoordPolicy->new());

DESCRIPTION
===========

   Objects implementing this interface are used by Bio::LocationI
implementing objects to determine integer-valued coordinates when asked
for it. While this may seem trivial for simple locations, there are
different ways to do it for fuzzy or compound (split) locations. Classes
implementing this interface implement a certain policy, like 'always
widest range', 'always smallest range', 'mean for BETWEEN locations', etc.
By installing a different policy object in a Location object, the
behaviour of coordinate computation can be changed on-the-fly, and with a
single line of code client-side.

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp, Jason Stajich
===================================

   Email hlapp@gmx.net, jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

start
-----

     Title   : start
     Usage   : $start = $policy->start($location);
     Function: Get the integer-valued start coordinate of the given location as
               computed by this computation policy.
     Returns : A positive integer number.
     Args    : A Bio::LocationI implementing object.

end
---

     Title   : end
     Usage   : $end = $policy->end($location);
     Function: Get the integer-valued end coordinate of the given location as
               computed by this computation policy.
     Returns : A positive integer number.
     Args    : A Bio::LocationI implementing object.


File: pm.info,  Node: Bio/Location/Fuzzy,  Next: Bio/Location/FuzzyLocationI,  Prev: Bio/Location/CoordinatePolicyI,  Up: Module List

Implementation of a Location on a Sequence which has unclear start and/or end locations
***************************************************************************************

NAME
====

   Bio::Location::Fuzzy - Implementation of a Location on a Sequence which
has unclear start and/or end locations

SYNOPSIS
========

     my $fuzzylocation = new Bio::Location::Fuzzy(-start => '<30',
     						 -end   => 90,
     						 -loc_type => '.');

     print "location string is ", $fuzzylocation->to_FTstring();

DESCRIPTION
===========

   This module contains the necessary methods for representing a Fuzzy
Location, one that does not have clear start and/or end points.  This will
initially serve to handle features from Genbank/EMBL feature tables that
are written as 1^100 meaning between bases 1 and 100 or <100..300 meaning
it starts somewhere before 100.  Advanced implementations of this
interface may be able to handle the necessary logic of
overlaps/intersection/contains/union.  It was constructed to handle fuzzy
locations that can be represented in Genbank/EMBL.

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Jason Stajich
======================

   Email jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

loc_type
--------

     Title   : loc_type
     Usage   : my $location_type = $location->loc_type();
     Function: Get location type encoded as text
     Returns : string ('EXACT', 'WITHIN', 'BETWEEN')
     Args    : none

LocationI methods
=================

length
------

     Title   : length
     Usage   : $length = $fuzzy_loc->length();
     Function: Get the length of this location.

     Note that the length of a fuzzy location will always depend
     on the currently active interpretation of start and end. The
     result will therefore vary for different CoordinatePolicy objects.

     Returns : an integer
     Args    : none

start
-----

     Title   : start
     Usage   : $start = $fuzzy->start();
     Function: get/set start of this range, handling fuzzy_starts
     Returns : a positive integer representing the start of the location
     Args    : start location on set (can be fuzzy point string)

end
---

     Title   : end
     Usage   : $end = $fuzzy->end();
     Function: get/set end of this range, handling fuzzy_ends
     Returns : a positive integer representing the end of the range
     Args    : end location on set (can be fuzzy string)

min_start
---------

     Title   : min_start
     Usage   : $min_start = $fuzzy->min_start();
     Function: get/set the minimum starting point
     Returns : the minimum starting point from the contained sublocations
     Args    : integer or undef on set

max_start
---------

     Title   : max_start
     Usage   : my $maxstart = $location->max_start();
     Function: Get/set maximum starting location of feature startpoint
     Returns : integer or undef if no maximum starting point.
     Args    : integer or undef on set

start_pos_type
--------------

     Title   : start_pos_type
     Usage   : my $start_pos_type = $location->start_pos_type();
     Function: Get/set start position type.
     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : a string on set

min_end
-------

     Title   : min_end
     Usage   : my $minend = $location->min_end();
     Function: Get/set minimum ending location of feature endpoint
     Returns : integer or undef if no minimum ending point.
     Args    : integer or undef on set

max_end
-------

     Title   : max_end
     Usage   : my $maxend = $location->max_end();
     Function: Get/set maximum ending location of feature endpoint
     Returns : integer or undef if no maximum ending point.
     Args    : integer or undef on set

end_pos_type
------------

     Title   : end_pos_type
     Usage   : my $end_pos_type = $location->end_pos_type();
     Function: Get/set end position type.
     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : a string on set

seq_id
------

     Title   : seq_id
     Usage   : my $seqid = $location->seq_id();
     Function: Get/Set seq_id that location refers to
     Returns : seq_id
     Args    : [optional] seq_id value to set

coordinate_policy
-----------------

     Title   : coordinate_policy
     Usage   : $policy = $location->coordinate_policy();
               $location->coordinate_policy($mypolicy); # set may not be possible
     Function: Get the coordinate computing policy employed by this object.

     See Bio::Location::CoordinatePolicyI for documentation about
     the policy object and its use.

     The interface *does not* require implementing classes to accept
     setting of a different policy. The implementation provided here
     does, however, allow to do so.

     Implementors of this interface are expected to initialize every
     new instance with a CoordinatePolicyI object. The implementation
     provided here will return a default policy object if none has
     been set yet. To change this default policy object call this
     method as a class method with an appropriate argument. Note that
     in this case only subsequently created Location objects will be
     affected.

     Returns : A Bio::Location::CoordinatePolicyI implementing object.
     Args    : On set, a Bio::Location::CoordinatePolicyI implementing object.

to_FTstring
-----------

     Title   : to_FTstring
     Usage   : my $locstr = $location->to_FTstring()
     Function: Get/Set seq_id that location refers to
     Returns : seq_id
     Args    : [optional] seq_id value to set

_fuzzypointdecode
-----------------

     Title   : _fuzzypointdecode
     Usage   : ($type,$min,$max) = $self->_fuzzypointdecode('<5');
     Function: Decode a fuzzy string.
     Returns : A 3-element array consisting of the type of location, the
               minimum integer, and the maximum integer describing the range
               of coordinates this start or endpoint refers to. Minimum or
               maximum coordinate may be undefined.
             : Returns empty array on fail.
     Args    : fuzzypoint string


File: pm.info,  Node: Bio/Location/FuzzyLocationI,  Next: Bio/Location/NarrowestCoordPolicy,  Prev: Bio/Location/Fuzzy,  Up: Module List

Abstract interface of a Location on a Sequence which has unclear start/end location
***********************************************************************************

NAME
====

   Bio::Location::FuzzyLocationI - Abstract interface of a Location on a
Sequence which has unclear start/end location

SYNOPSIS
========

     # Get a FuzzyLocationI object somehow
     print "Fuzzy FT location string is ", $location->to_FTstring();
     print "location is of the type ", $location->loc_type, "\n";

DESCRIPTION
===========

   This interface encapsulates the necessary methods for representing a
Fuzzy Location, one that does not have clear start and/or end points.
This will initially serve to handle features from Genbank/EMBL feature
tables that are written as 1^100 meaning between bases 1 and 100 or
<100..300 meaning it starts somewhere before 100.  Advanced
implementations of this interface may be able to handle the necessary
logic of overlaps/intersection/contains/union.  It was constructed to
handle fuzzy locations that can be represented in Genbank/EMBL.

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Jason Stajich
======================

   Email jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

loc_type
--------

     Title   : loc_type
     Usage   : my $location_type = $location->loc_type();
     Function: Get location type encoded as text
     Returns : string ('EXACT', 'WITHIN', 'BETWEEN')
     Args    : none

LocationI methods
=================

min_start
---------

     Title   : min_start
     Usage   : my $minstart = $location->min_start();
     Function: Get minimum starting location of feature startpoint
     Returns : integer or undef if no maximum starting point.
     Args    : none

max_start
---------

     Title   : max_start
     Usage   : my $maxstart = $location->max_start();
     Function: Get maximum starting location of feature startpoint
     Returns : integer or undef if no maximum starting point.
     Args    : none

start_pos_type
--------------

     Title   : start_pos_type
     Usage   : my $start_pos_type = $location->start_pos_type();
     Function: Get start position type (ie <,>, ^)
     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : none

min_end
-------

     Title   : min_end
     Usage   : my $minend = $location->min_end();
     Function: Get minimum ending location of feature endpoint
     Returns : integer or undef if no minimum ending point.
     Args    : none

max_end
-------

     Title   : max_end
     Usage   : my $maxend = $location->max_end();
     Function: Get maximum ending location of feature endpoint
     Returns : integer or undef if no maximum ending point.
     Args    : none

end_pos_type
------------

     Title   : end_pos_type
     Usage   : my $end_pos_type = $location->end_pos_type();
     Function: Get end position type (ie <,>, ^)
     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : none

seq_id
------

     Title   : seq_id
     Usage   : my $seqid = $location->seq_id();
     Function: Get/Set seq_id that location refers to
     Returns : seq_id
     Args    : [optional] seq_id value to set

coordinate_policy
-----------------

     Title   : coordinate_policy
     Usage   : $policy = $location->coordinate_policy();
               $location->coordinate_policy($mypolicy); # set may not be possible
     Function: Get the coordinate computing policy employed by this object.

     See Bio::Location::CoordinatePolicyI for documentation about
     the policy object and its use.

     The interface *does not* require implementing classes to accept
     setting of a different policy. The implementation provided here
     does, however, allow to do so.

     Implementors of this interface are expected to initialize every
     new instance with a CoordinatePolicyI object. The implementation
     provided here will return a default policy object if none has
     been set yet. To change this default policy object call this
     method as a class method with an appropriate argument. Note that
     in this case only subsequently created Location objects will be
     affected.

     Returns : A Bio::Location::CoordinatePolicyI implementing object.
     Args    : On set, a Bio::Location::CoordinatePolicyI implementing object.

to_FTstring
-----------

     Title   : to_FTstring
     Usage   : my $locstr = $location->to_FTstring()
     Function: returns the FeatureTable string of this location
     Returns : string
     Args    : none


File: pm.info,  Node: Bio/Location/NarrowestCoordPolicy,  Next: Bio/Location/Simple,  Prev: Bio/Location/FuzzyLocationI,  Up: Module List

class implementing  Bio::Location::CoordinatePolicy as the narrowest possible and reasonable range
**************************************************************************************************

NAME
====

   Bio::Location::NarrowestCoordPolicy - class implementing
Bio::Location::CoordinatePolicy as the narrowest possible and reasonable
range

SYNOPSIS
========

   See Bio::Location::CoordinatePolicyI

DESCRIPTION
===========

   CoordinatePolicyI implementing objects are used by Bio::LocationI
implementing objects to determine integer-valued coordinates when asked
for it.

   This class will compute the coordinates such that always the narrowest
possible range is returned, but by using some common sense. This means
that e.g.  locations like ">5..100" (start before position 5) will return
5 as start (returned values have to be positive integers).

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp, Jason Stajich
===================================

   Email hlapp@gmx.net, jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

start
-----

     Title   : start
     Usage   : $start = $policy->start($location);
     Function: Get the integer-valued start coordinate of the given location as
               computed by this computation policy.
     Returns : A positive integer number.
     Args    : A Bio::LocationI implementing object.

end
---

     Title   : end
     Usage   : $end = $policy->end($location);
     Function: Get the integer-valued end coordinate of the given location as
               computed by this computation policy.
     Returns : A positive integer number.
     Args    : A Bio::LocationI implementing object.


File: pm.info,  Node: Bio/Location/Simple,  Next: Bio/Location/Split,  Prev: Bio/Location/NarrowestCoordPolicy,  Up: Module List

Implementation of a Simple Location on a Sequence
*************************************************

NAME
====

   Bio::Location::Simple - Implementation of a Simple Location on a
Sequence

SYNOPSIS
========

     my $location = new Bio::Location::Simple(-start => 1, -end => 100,
     					     -strand => 1 );

     if( $location->strand == -1 ) {
     	printf "complement(%d..%d)\n", $location->start, $location->end;
     } else {
     	printf "%d..%d\n", $location->start, $location->end;
     }

DESCRIPTION
===========

   This is an implementation of Bio::LocationI to manage simple location
information on a Sequence.

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Jason Stajich
======================

   Email jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

start
-----

     Title   : start
     Usage   : $start = $loc->start();
     Function: get/set the start of this range
     Returns : the start of this range
     Args    : optionaly allows the start to be set
             : using $loc->start($start)

end
---

     Title   : end
     Usage   : $end = $loc->end();
     Function: get/set the end of this range
     Returns : the end of this range
     Args    : optionaly allows the end to be set
             : using $loc->end($start)

strand
------

     Title   : strand
     Usage   : $strand = $loc->strand();
     Function: get/set the strand of this range
     Returns : the strandidness (-1, 0, +1)
     Args    : optionaly allows the strand to be set
             : using $loc->strand($strand)

length
------

     Title   : length
     Usage   : $len = $loc->length();
     Function: get the length in the coordinate space this location spans
     Example :
     Returns : an integer
     Args    : none

min_start
---------

     Title   : min_start
     Usage   : my $minstart = $location->min_start();
     Function: Get minimum starting location of feature startpoint
     Returns : integer or undef if no minimum starting point.
     Args    : none

max_start
---------

     Title   : max_start
     Usage   : my $maxstart = $location->max_start();
     Function: Get maximum starting location of feature startpoint.

     In this implementation this is exactly the same as min_start().

     Returns : integer or undef if no maximum starting point.
     Args    : none

start_pos_type
--------------

     Title   : start_pos_type
     Usage   : my $start_pos_type = $location->start_pos_type();
     Function: Get start position type (ie <,>, ^).

     In this implementation this will always be 'EXACT'.

     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : none

min_end
-------

     Title   : min_end
     Usage   : my $minend = $location->min_end();
     Function: Get minimum ending location of feature endpoint
     Returns : integer or undef if no minimum ending point.
     Args    : none

max_end
-------

     Title   : max_end
     Usage   : my $maxend = $location->max_end();
     Function: Get maximum ending location of feature endpoint

     In this implementation this is exactly the same as min_end().

     Returns : integer or undef if no maximum ending point.
     Args    : none

end_pos_type
------------

     Title   : end_pos_type
     Usage   : my $end_pos_type = $location->end_pos_type();
     Function: Get end position type (ie <,>, ^)

     In this implementation this will always be 'EXACT'.

     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : none

location_type
-------------

     Title   : location_type
     Usage   : my $location_type = $location->location_type();
     Function: Get location type encoded as text
     Returns : string ('EXACT', 'WITHIN', 'BETWEEN')
     Args    : none

to_FTstring
-----------

     Title   : to_FTstring
     Usage   : my $locstr = $location->to_FTstring()
     Function: returns the FeatureTable string of this location
     Returns : string
     Args    : none


File: pm.info,  Node: Bio/Location/Split,  Next: Bio/Location/SplitLocationI,  Prev: Bio/Location/Simple,  Up: Module List

Implementation of a Location on a Sequence which has multiple locations (start/end points)
******************************************************************************************

NAME
====

   Bio::Location::Split - Implementation of a Location on a Sequence which
has multiple locations (start/end points)

SYNOPSIS
========

     my $splitlocation = new Bio::Location::Split();
     $splitlocation->add_sub_Location(new Bio::Location::Simple(-start=>1,
     							       -end=>30,
     							       -strand=>1));
     $splitlocation->add_sub_Location(new Bio::Location::Simple(-start=>50,
     							       -end=>61,
     							       -strand=>1));
     my @sublocs = $splitlocation->sub_Location();

     my $count = 1;
     # print the start/end points of the sub locations
     foreach my $location ( sort { $a->start <=> $b->start }
     			   @sublocs ) {
     	printf "sub feature %d [%d..%d]\n",
     	       $count, $location->start,$location->end, "\n";
         $count++;
     }

DESCRIPTION
===========

   This implementation handles locations which span more than one
start/end location, or and/or lie on different sequences.

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Jason Stajich
======================

   Email jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

sub_Location
------------

     Title   : sub_Location
     Usage   : @sublocs = $splitloc->sub_Location();
     Function: Returns the array of sublocations making up this compound (split)
               location. Those sublocations referring to the same sequence as
               the root split location will be sorted by start position (forward
               sort) or end position (reverse sort) and come first (before
               those on other sequences).

     The sort order can be optionally specified or suppressed by the
     value of the first argument. The default is a forward sort.

     Returns : an array of Bio::LocationI implementing objects
     Args    : Optionally 1, 0, or -1 for specifying a forward, no, or reverse
               sort order

add_sub_Location
----------------

     Title   : add_sub_Location
     Usage   : $splitloc->add_sub_Location(@locationIobjs);
     Function: add an additional sublocation
     Returns : number of current sub locations
     Args    : list of Bio::LocationI implementing object(s) to add

splittype
---------

     Title   : splittype
     Usage   : $splittype = $fuzzy->splittype();
     Function: get/set the split splittype
     Returns : the splittype of split feature (join, order)
     Args    : splittype to set

is_single_sequence
------------------

     Title   : is_single_sequence
     Usage   : if($splitloc->is_single_sequence()) {
                   print "Location object $splitloc is split ".
                         "but only across a single sequence\n";
     	    }
     Function: Determine whether this location is split across a single or
               multiple sequences.

     This implementation ignores (sub-)locations that do not define
     seq_id(). The same holds true for the root location.

     Returns : TRUE if all sublocations lie on the same sequence as the root
               location (feature), and FALSE otherwise.
     Args    : none

LocationI methods
=================

start
-----

     Title   : start
     Usage   : $start = $location->start();
     Function: get the starting point of the first (sorted) sublocation
     Returns : integer
     Args    : none

end
---

     Title   : end
     Usage   : $end = $location->end();
     Function: get the ending point of the last (sorted) sublocation
     Returns : integer
     Args    : none

min_start
---------

     Title   : min_start
     Usage   : $min_start = $location->min_start();
     Function: get the minimum starting point
     Returns : the minimum starting point from the contained sublocations
     Args    : none

max_start
---------

     Title   : max_start
     Usage   : my $maxstart = $location->max_start();
     Function: Get maximum starting location of feature startpoint
     Returns : integer or undef if no maximum starting point.
     Args    : none

start_pos_type
--------------

     Title   : start_pos_type
     Usage   : my $start_pos_type = $location->start_pos_type();
     Function: Get start position type (ie <,>, ^)
     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : none

min_end
-------

     Title   : min_end
     Usage   : my $minend = $location->min_end();
     Function: Get minimum ending location of feature endpoint
     Returns : integer or undef if no minimum ending point.
     Args    : none

max_end
-------

     Title   : max_end
     Usage   : my $maxend = $location->max_end();
     Function: Get maximum ending location of feature endpoint
     Returns : integer or undef if no maximum ending point.
     Args    : none

end_pos_type
------------

     Title   : end_pos_type
     Usage   : my $end_pos_type = $location->end_pos_type();
     Function: Get end position type (ie <,>, ^)
     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : none

seq_id
------

     Title   : seq_id
     Usage   : my $seqid = $location->seq_id();
     Function: Get/Set seq_id that location refers to
     Returns : seq_id
     Args    : [optional] seq_id value to set

coordinate_policy
-----------------

     Title   : coordinate_policy
     Usage   : $policy = $location->coordinate_policy();
               $location->coordinate_policy($mypolicy); # set may not be possible
     Function: Get the coordinate computing policy employed by this object.

     See Bio::Location::CoordinatePolicyI for documentation about
     the policy object and its use.

     The interface *does not* require implementing classes to accept
     setting of a different policy. The implementation provided here
     does, however, allow to do so.

     Implementors of this interface are expected to initialize every
     new instance with a CoordinatePolicyI object. The implementation
     provided here will return a default policy object if none has
     been set yet. To change this default policy object call this
     method as a class method with an appropriate argument. Note that
     in this case only subsequently created Location objects will be
     affected.

     Returns : A Bio::Location::CoordinatePolicyI implementing object.
     Args    : On set, a Bio::Location::CoordinatePolicyI implementing object.

to_FTstring
-----------

     Title   : to_FTstring
     Usage   : my $locstr = $location->to_FTstring()
     Function: returns the FeatureTable string of this location
     Returns : string
     Args    : none


File: pm.info,  Node: Bio/Location/SplitLocationI,  Next: Bio/Location/WidestCoordPolicy,  Prev: Bio/Location/Split,  Up: Module List

Abstract interface of a Location on a Sequence which has multiple locations (start/end points)
**********************************************************************************************

NAME
====

   Bio::SplitLocationI - Abstract interface of a Location on a Sequence
which has multiple locations (start/end points)

SYNOPSIS
========

     # get a SplitLocationI somehow
       print $splitlocation->start, "..", $splitlocation->end, "\n";
       my @sublocs = $splitlocation->sub_Location();

     my $count = 1;
     # print the start/end points of the sub locations
     foreach my $location ( sort { $a->start <=> $b->start }
     			   @sublocs ) {
     	printf "sub feature %d [%d..%d]\n", $location->start,$location->end;
         $count++;
     }

DESCRIPTION
===========

   This interface encapsulates the necessary methods for representing the
location of a sequence feature that has more that just a single start/end
pair.  Some examples of this are the annotated exons in a gene or the
annotated CDS in a sequence file.

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Jason Stajich
======================

   Email jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

sub_Location
------------

     Title   : sub_Location
     Usage   : @locations = $feat->sub_Location();
     Function: Returns an array of LocationI objects
     Returns : An array
     Args    : none

splittype
---------

     Title   : splittype
     Usage   : $splittype = $fuzzy->splittype();
     Function: get/set the split splittype
     Returns : the splittype of split feature (join, order)
     Args    : splittype to set

is_single_sequence
------------------

     Title   : is_single_sequence
     Usage   : if($splitloc->is_single_sequence()) {
                   print "Location object $splitloc is split ".
                         "but only across a single sequence\n";
     	    }
     Function: Determine whether this location is split across a single or
               multiple sequences.
     Returns : TRUE if all sublocations lie on the same sequence as the root
               location (feature), and FALSE otherwise.
     Args    : none

LocationI methods
=================

min_start
---------

     Title   : min_start
     Usage   : my $minstart = $location->min_start();
     Function: Get minimum starting location of feature startpoint
     Returns : integer or undef if no maximum starting point.
     Args    : none

max_start
---------

     Title   : max_start
     Usage   : my $maxstart = $location->max_start();
     Function: Get maximum starting location of feature startpoint
     Returns : integer or undef if no maximum starting point.
     Args    : none

start_pos_type
--------------

     Title   : start_pos_type
     Usage   : my $start_pos_type = $location->start_pos_type();
     Function: Get start position type (ie <,>, ^)
     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : none

min_end
-------

     Title   : min_end
     Usage   : my $minend = $location->min_end();
     Function: Get minimum ending location of feature endpoint
     Returns : integer or undef if no minimum ending point.
     Args    : none

max_end
-------

     Title   : max_end
     Usage   : my $maxend = $location->max_end();
     Function: Get maximum ending location of feature endpoint
     Returns : integer or undef if no maximum ending point.
     Args    : none

end_pos_type
------------

     Title   : end_pos_type
     Usage   : my $end_pos_type = $location->end_pos_type();
     Function: Get end position type (ie <,>, ^)
     Returns : type of position coded as text
               ('BEFORE', 'AFTER', 'EXACT','WITHIN', 'BETWEEN')
     Args    : none

seq_id
------

     Title   : seq_id
     Usage   : my $seqid = $location->seq_id();
     Function: Get/Set seq_id that location refers to
     Returns : seq_id
     Args    : [optional] seq_id value to set

coordinate_policy
-----------------

     Title   : coordinate_policy
     Usage   : $policy = $location->coordinate_policy();
               $location->coordinate_policy($mypolicy); # set may not be possible
     Function: Get the coordinate computing policy employed by this object.

     See Bio::Location::CoordinatePolicyI for documentation about
     the policy object and its use.

     The interface *does not* require implementing classes to accept
     setting of a different policy. The implementation provided here
     does, however, allow to do so.

     Implementors of this interface are expected to initialize every
     new instance with a CoordinatePolicyI object. The implementation
     provided here will return a default policy object if none has
     been set yet. To change this default policy object call this
     method as a class method with an appropriate argument. Note that
     in this case only subsequently created Location objects will be
     affected.

     Returns : A Bio::Location::CoordinatePolicyI implementing object.
     Args    : On set, a Bio::Location::CoordinatePolicyI implementing object.

to_FTstring
-----------

     Title   : to_FTstring
     Usage   : my $locstr = $location->to_FTstring()
     Function: returns the FeatureTable string of this location
     Returns : string
     Args    : none


File: pm.info,  Node: Bio/Location/WidestCoordPolicy,  Next: Bio/LocationI,  Prev: Bio/Location/SplitLocationI,  Up: Module List

class implementing  Bio::Location::CoordinatePolicy as the widest possible and reasonable range
***********************************************************************************************

NAME
====

   Bio::Location::WidestCoordPolicy - class implementing
Bio::Location::CoordinatePolicy as the widest possible and reasonable range

SYNOPSIS
========

   See Bio::Location::CoordinatePolicyI

DESCRIPTION
===========

   CoordinatePolicyI implementing objects are used by Bio::LocationI
implementing objects to determine integer-valued coordinates when asked
for it.

   This class will compute the coordinates such that always the widest
possible range is returned, but by using some common sense. This means
that e.g.  locations like "<5..100" (start before position 5) will return
5 as start (returned values have to be positive integers).

FEEDBACK
========

   User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one of
the Bioperl mailing lists.  Your participation is much appreciated.

     bioperl-l@bioperl.org             - General discussion
     http://bio.perl.org/MailList.html - About the mailing lists

Reporting Bugs
--------------

   Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email or
the web:

     bioperl-bugs@bio.perl.org
     http://bio.perl.org/bioperl-bugs/

AUTHOR - Hilmar Lapp, Jason Stajich
===================================

   Email hlapp@gmx.net, jason@chg.mc.duke.edu

APPENDIX
========

   The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

start
-----

     Title   : start
     Usage   : $start = $policy->start($location);
     Function: Get the integer-valued start coordinate of the given location as
               computed by this computation policy.
     Returns : A positive integer number.
     Args    : A Bio::LocationI implementing object.

end
---

     Title   : end
     Usage   : $end = $policy->end($location);
     Function: Get the integer-valued end coordinate of the given location as
               computed by this computation policy.
     Returns : A positive integer number.
     Args    : A Bio::LocationI implementing object.


