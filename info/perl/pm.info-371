This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Text/Macros,  Next: Text/Merge,  Prev: Text/MacroScript,  Up: Module List

an object-oriented text macro engine
************************************

NAME
====

   Text::Macros.pm - an object-oriented text macro engine

SYNOPSIS
========

   use Text::Macros;

     # poetic:
     my $macro_expander = new Text::Macros qw( {{ }} );
     $text = expand_macros $macro_expander $data_object, $text;

     # noisy:
     $macro_expander = Text::Macros->new( "\Q[[", "\Q]]", 1 );
     print $macro_expander->expand_macros( $data_object, $text );

DESCRIPTION
===========

   Typical usage might look like this:

     my $template = <<EOF;
       To: [[ RecipientEmail ]]
       From: [[ SenderEmail ]]
       Subject: Payment Past Due on Account # [[ AccountNum ]]

     Dear [[ RecipientName ]]:
     Your payment of [[ PaymentAmount ]] is [[ DaysPastDue ]] days past due.
      EOF

     # get a data object from somewhere, e.g.:
     my $data_object = $database->get_record_object( 'acctnum' => $account_num );

     # make a macro expander:
     my $macro_expander = Text::Macros->new( "\Q[[", "\Q]]" );

     # expand the macros in the template:
     my $email_text = $macro_expander->expand_macros( $data_object, $template );

   To support this, a "data object" would need to exist which would need to
define methods which will be used as macro names, e.g. like this:

     package RecordObject;
     sub RecipientEmail { $_[0]->{'RecipientEmail'} }
     sub SenderEmail    { $_[0]->{'SenderEmail'}    }
     sub AccountNum     { $_[0]->{'AccountNum'}     }
     sub RecipientName  { $_[0]->{'RecipientName'}  }
     sub PaymentAmount  { $_[0]->{'PaymentAmount'}  }
     sub DaysPastDue    { $_[0]->{'DaysPastDue'}    }

   Alternatively, the data object class might have AUTOLOAD defined, for
example like this:

     package RecordObject;
     sub AUTOLOAD {
      my $self = shift;
      my $name = $AUTOLOAD;
      $name =~ s/.*:://;
      $self->{$name}
     }

   If this is the case, then the macro expander should be instructed not to
assert that the macro names encountered are valid for the object - since
CAN might fail, even though the calls will be handled by AUTOLOAD.  To do
this, pass a true value for the third value to the constructor:

     my $macro_expander = Text::Macros->new( "\Q[[", "\Q]]", 1 );

   Macros can take arguments.  Any strings which occur inside the macro
text after the macro name will be passed as arguments to the macro method
call.  By default, the macro name and any arguments are all separated by
newlines.  You can override this behavior; see the documentation of
parse_args, below.

   Example:

     $macro_expander = new Macros qw( {{ }} );

     print $macro_expander->expand_macros( $cgi_query,
       "You entered {{ param
        Name }} as your name."
     );

   This will replace the substring

     {{ param
     Name }}

   with the result of calling

     $cgi_query->param("Name")

   (Obviously this example is a little contrived.)

METHODS
=======

The Constructor
---------------

     Text::Macros->new( $open_delim, $close_delim, $no_CAN_check, $parse_args_cr );

   The delimiters are regular expressions; this gives you the greatest
power in determining how macros are to be detected in the text.  But it
means that if you simply want them to be considered literal strings, then
you must quotemeta them.

   Since the macro expander will be calling object methods, you have an
option: do you want any encountered macro names to be required to be valid
for the given object?  Or do you have some kind of autoloading in effect,
which will handle undefined methods?

   If you have some kind of autoloading, pass a true value for the third
argument to new().  If you want the expander to assert CAN for each method,
pass false (the default).

   The fourth argument, $parse_args_cr, is a reference to a sub which
implements your macro argument parsing policy.  See the section on
parse_args, below.

The Main Method: Expand Macros
------------------------------

     $text = $macro_expander->expand_macros( $data_object, $text );

   The $data_object argument is not an object of the Macros package.
Rather, this is the object upon which the macro will be called as a method.

   expand_macros() returns the result of replacing all the macros it finds
with their appropriate expansions.  Note that recursion can occur; that is,
if the expansion of a macro results in text which also contains a valid
macro, that new macro will also be expanded.  The text will be scanned for
macros, and those macros will be expanded, until none are found.

A Utility Method: Call Macro
----------------------------

     $macro_expander->call_macro( $data_object, $macro_name, @arguments );

   This is used internally by expand_macros(), but you can call it
directly if you wish.

   Essentially all this does is this:

     $macro_expander->call_macro( $data_object, $macro_name, @arguments );

   results in the call:

     $data_object->$macro_name( @arguments );

   All the macros supported by the data object can be predefined, or you
might have some kind of autoloading mechanism in place for it.  If you
have autoloading in effect, you should have passed a true value as the
third argument to new().  If you pass false (the default), the
call_macro() will check to see that the object CAN do the method; and if
it can't an exception will be thrown.

   Note: data objects' macro methods must return a string.  They can take
any number of arguments, which will all be strings.

Parsing the Macro Arguments: parse_args
---------------------------------------

   This is used internally by expand_macros().

   expand_macros tries to call the sub which was passed by reference as the
fourth argument to new(), if there was one.  If no such coderef was given
to the constructor, then expand_macros calls the parse_args method in the
Text::Macros class, which implements the default behavior of splitting the
arg text on newlines, triming off leading/trailing whitespace, and then
dropping any list elements which are " (empty strings).

   To implement some behavior other than the default, you may derive a
class from Text::Macros which overrides parse_args.  The parse_args method
takes the Text::Macros object reference as the first arg (as usual), and
the macro text as the second argument.  This is all the text between the
delimiters, as it occurs in the template text.  This method is responsible
for extracting the macro name and the values of any arguments from the
macro text.  It is advisable that the parse_args routine strip any leading
and trailing whitespace from the argument values.  (It happens
automatically for the macro name, though, so you needn't worry about that.)

   Example:

     package MyMacroParser;
     @ISA = qw( Text::Macros );
     sub parse_args {
        my( $self, $macro_text ) = @_;
        # return a list of args extracted from $macro_text...
     }

   And then, of course, you would instantiate a MyMacroParser rather than a
Text::Macros.  Everything else about its usage would be identical.

   If you prefer, you can redefine the Text::Macros::parse_args sub
directly.  That might look something like this:

     *Text::Macros::parse_args = sub {
        my( $self, $macro_text ) = @_;
        # return a list of args extracted from $macro_text...
     };

   Alternatively, you may pass a code reference as the fourth argument to
new().  The arguments to and results from this sub are the same as for the
parse_args method, as described above, even though it is not (necessarily)
a method itself.

   The precedence is this: if a sub was passed to new(), that is called;
if not, the parse_args() of the derived class is called, if defined; if
not, the parse_args() of the base class (Text::Macros) is called.

EXAMPLES
========

   Brief examples of all these usage techniques can be found in the test
script, test.pl, which accompanies this distribution.  Any questions can
be directed to the author via email.

AUTHOR
======

   jdporter@min.net (John Porter)

COPYRIGHT
=========

   This module is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.


File: pm.info,  Node: Text/Merge,  Next: Text/Merge/Lists,  Prev: Text/Macros,  Up: Module List

v.0.33  General purpose text/data merging methods in Perl.
**********************************************************

NAME
====

   Text::Merge - v.0.33  General purpose text/data merging methods in Perl.

SYNOPSIS
========

     $merge = new Text::Merge;

     $merge->line_by_line();		# query
     $merge->line_by_line(0);	# turn off
     $merge->line_by_line(1);	# turn on

     $merge->set_delimiters('<<', '>>');            # user defined delims

     $success = $merge->publish($template, \%data);
     $success = $merge->publish($template, \%data, \%actions);
     $success = $merge->publish($template, $item);

     $success = $merge->publish_to($handle, $template, \%data);
     $success = $merge->publish_to($handle, $template, \%data, \%actions);
     $success = $merge->publish_to($handle, $template, $item);

     $text = $merge->publish_text($template, \%data);
     $text = $merge->publish_text($template, \%data, \%actions);
     $text = $merge->publish_text($template, $item);

     $success = $merge->publish_email($mailer, $headers, $template, \%data);
     $success = $merge->publish_email($mailer, $headers, $template,
     						     \%data, \%actions);
     $success = $merge->publish_email($mailer, $headers, $template, $item);

     $datahash = $merge->cgi2data();        # if you used "CGI(:standard)"
     $datahash = $merge->cgi2data($cgi);    # if you just used CGI.pm

DESCRIPTION
===========

   The `Text::Merge' package is designed to provide a quick, versatile,
and extensible way to combine presentation templates and data structures.
The `Text::Merge' package attempts to do this by assuming that templates
are constructed with text and that objects consist of data and functions
that operate on that data.  `Text::Merge' is very simple, in that it works
on one file and one object at a time, although an extension exists to
display lists (`Text::Merge::Lists') and `Text::Merge' itself could easily
be extended further.

   This is not XML and is intended merely to "flatten" the learning curve
for non-programmers who design display pages for programmers or to provide
programmers with a quick way of merging page templates with data sets or
objects without extensive research.

   The templates can be interpreted "line by line" or taken as a whole.

Technical Details
-----------------

   This object is normally inherited and so the new() function is the
constructor.  It just blesses an anonymous HASH reference, sets two flags
within that HASH, and returns it.  I'm am acutely aware of the criticisms
of the overuse of OOP (Object Oriented Programming).  This module needs to
be OO because of its extensibility and encapsulation; I wanted to impose
classification of the objects to allow the greatest flexibility in context
of implementation.  `Text::Merge' is generally used on web servers, and
can become integrated quickly into the httpd using mod_perl, hence the
encapsulation and inheritance provided by the Perl OO model clearly
outweighed the constraints thereby imposed.  That's my excuse...what's
yours?

   There are four public methods for the `Text::Merge' object:
`publish()', `publish_to()', `publish_text()', `publish_email()'.  The
first, `publish()', sends output to the currently selected file handle
(normally STDOUT).  The second method, `publish_text()', returns the
merged output as a text block.  The last method, `publish_email()', sends
the merged output as a formatted e-mail message to the designated mailer.

   Support is provided to merge the data and the functions performed on
that data with a text template that contains substitution tag markup used
to designate the action or data conversion.  Data is stored in a HASH that
is passed by reference to the publishing methods.  The keys of the data
hash correspond to the field names of the data, and they are associated
with their respective values.  Actions (methods) are similarly referenced
in a hash, keyed by the action name used in the template.

   Here is a good example of a publishing call in Perl:

     $obj = new Text::Merge;
     %data = ( 'Name'=>'John Smith', 'Age'=>33, 'Sex'=>'not enough' );
     %actions = ( 'Mock' => \&mock_person,  'Laud' => \&laud_person );
     $obj->publish($template, \%data, \%actions);

   In this example, `mock_person()' and `laud_person()' would be
subroutines that took a single hash reference, the data set, as an
argument.  In this way you can create dynamic or complex composite
components and reference them with a single tag in the template.  The
actions HASH has been found to be useful for default constructs that can
be difficult to code manually, giving page designers an option to work
with quickly.

Markup Tags
-----------

   Simply put, tags are replaced with what they designate.  A tag
generally consists of a prefix, followed by a colon, then either an action
name or a field name followed by zero or more formatting directives
seperated by colons.  In addition, blocks of output can be contained
within curly brackets in certain contexts for conditional display.

REF: tags
     Simple data substitution is achieved with the REF: tag.  Here is an
     example of the use of a REF: tag in context, assume we have a
     key-value pair in our data HASH associating the key 'Animal' with the
     value of 'turtle':

          The quick brown REF:Animal jumped over the lazy dog.

     when filtered, becomes:

          The quick brown turtle jumped over the lazy dog.

     The REF: tag designators may also contain one or more format
     directives.  These are chained left to right, and act to convert the
     data before it is displayed.  For example:

          REF:Animal:lower:trunc3

     would result in the first three letters of the SCALAR data value
     associated with Animal in lower case.  See the section, `Data
     Conversions Formats', for a list of the available SCALAR data
     formatting directives.  Note that some conversions may be
     incompatible or contradictory.  The system will not necessarily warn
     you of such cases, so be forewarned.

     Any REF: tag designator can be surrounded by curly brace pairs
     containing text that would be included in the merged response only if
     the result of the designator is not empty (has a length).  There must
     be no spaces between the tag and the curly braced text.  If
     line-by-line mode is turned off, then the conditional text block may
     span multiple lines.  For example:

          The {quick brown }REF:Animal{ jumps over where the }lazy dog lies.

     Might result in:

          The quick brown fox jumps over where the lazy dog lies.

     or, if the value associated with the data key 'Animal' was undefined,
     empty, or zero:

          The lazy dog lies.

IF: tags
     The IF: tag designators performs a conditional display.  The syntax
     is as follows:

          IF:FieldName:formats{Text to display}

     This designator would result in the string *Text to display* being
     returned if the formatted data value is not empty.  The curly braced
     portion is required, and no curly braces are allowed before the
     designator.

NEG: tags
     The NEG: tag designator is similar to the IF: tag, but the bracketed
     text is processed only if the formatted data value is empty (zero
     length) or zero.  Effectively the NEG: can be thought of as *if not*.
     Here is an example:

          NEG:FieldName:formats{Text to display if the result is empty.}

ACT: tags
     The ACT: tag designates that an action is to be performed (a
     subroutine call) to obtain the result for substition.  The key name
     specified in the designator is used to look up the reference to the
     appropriate subroutine, and the data HASH reference is passed as the
     sole argument to that subroutine.  The returned value is the value
     used for the substition.

     ACT: is intended to be used to insert programmatic components into
     the document.  It can only specify action key names and has no
     equivalent tags to IF: and NEG:.  The curly brace rules for the ACT:
     tag are exactly the same as those for the REF: tag.

Conditional Text Braces
     All tags support conditional text surrounded by curly braces.  If the
     `line_by_line()' switch is set, then the entire tag degignator must
     be on a single line of text, but if the switch is OFF (default) then
     the conditional text can span multiple lines.

     The two conditional tags, IF: and NEG:, require a single conditional
     text block, surrounded by curly braces, immediately following
     (suffixing) the field name or format string.  For example:

          IF:SomeField{this text will print}

     The REF: and ACT: tags allow for curly braces both at the beginning
     (prefixing) and at the end (suffixing).  For example:

          {Some optional text }REF:SomeValue{ more text.}

Command Braces
     You may bracket entire constructs (along with any conditional text)
     with double square brackets to set them off from the rest of the
     document.  The square brackets would be removed during substitution:

          The [[IF:VerboseVar{quick, brown }]]fox jumped over the lazy dog.

     assuming that 'VerboseVar' represented some data value, the above
     example would result in one of:

          The quick, brown fox jumped over the lazy dog.
          or
          The fox jumped over the lazy dog.

Data Conversion Formats
     Here is a list of the data conversion format and the a summary.
     Details are undetermined in some cases for exceptions, but all of the
     conversion to some satisfactory degree.  These conversion methods
     will treat all values as SCALAR values:

          upper	-  converts all lowercase letters to uppercase
          lower	-  converts all uppercase letters to lower
          proper	-  treats the string as a Proper Noun
          trunc## -  truncate the scalar to ## characters (## is an integer)
          words## -  reduce to ## words seperated by spaces (## is an integer)
          paragraph## -  converts to a paragraph ## columns wide
          indent## - indents plain text ## spaces
          int	-  converts the value to an integer
          float	-  converts the value to a floating point value
          string  -  converts the numeric value to a string (does nothing)
          detab	-  replaces tabs with spaces, aligned to 8-char columns
          html	-  replaces newlines with HTML B<BR> tags
          dollars	-  converts the value to 2 decimal places
          percent	-  converts the value to a percentage
          abbr	-  converts a time value to m/d/yy format
          short	-  converts a time value to m/d/yy H:MMpm format
          time	-  converts a time value to H:MMpm (localtime am/pm)
          24h	-  converts a time value to 24hour format (localtime)
          dateonly - converts a time value to Jan. 1, 1999 format
          date	- same as 'dateonly' with 'time'
          ext	-  converts a time value to extended format:
          	        Monday, Januay 12th, 1999 at 12:20pm
          unix	-  converts a time value to UNIX date string format
          escape	-  performs a browser escape on the value (&#123;)
          unescape - performs a browser unescape (numeric only)
          urlencode - performs a url encoding on the value (%3B)
          urldecode - performs a url decoding (reverse of urlencode)

     Most of the values are self-explanatory, however a few may need
     explanation:

     The trunc format must be suffixed with an integer digit to define at
     most how many characters should be displayed, as in `trunc14'.

     The html format just inserts a <BR> construct at every newline in the
     string.  This allows text to be displayed appropriately in some cases.

     The escape format performs an HTML escape on all of the reserved
     characters of the string.  This allows values to be displayed
     correctly on browsers in most cases.  If your data is not
     prefiltered, it is usually a good idea to use escape on strings where
     HTML formatting is prohibited.  For example a '$' value would be
     converted to '&#36;'.

     The `unescape' format does the reverse of an escape format, however it
     does not operate on HTML mnemonic escapes, allowing special
     characters to remain intact.  This can be used to reverse escapes
     inherent in the use of other packages.

     The `urlencode' and `urldecode' formats either convert a value (text
     string) to url encoded format, converting special characters to their
     %xx equivalent, or converting to the original code by decoding %xx
     characters respectively from the url encoded value.

Item Support
------------

   The publishing methods all require at the very least a template, a data
set, and the action set; although either the data set or the action set or
both could be empty or null.  You may also *bundle* this information into
a single HASH (suitable for blessing as a class) with the key 'Data'
associated with the data HASH reference, and the key 'Actions' associated
with the action HASH reference.  A restatement of a previous example might
look like this:

     $obj = new Text::Merge;
     $data = { 'Name'=>'John Smith', 'Age'=>33, 'Sex'=>'not enough' };
     $actions = { 'Mock' => \&mock_person,  'Laud' => \&laud_person };
     $item = { 'Data' => $data,  'Actions' => $actions };
     $obj->publish($template, $item);

   In addition, if you specify a key 'ItemType' in your $item and give it
a value, then the item reference will be handed to any methods invoked by
the ACT: tags, rather than just the data hash.  This allows you to
construct items that can be merged with templates.  For example, the
following code is valid:

     %data = ( 'Author' => 'various',  'Title' => 'The Holy Bible' );
     %actions = ( 'Highlight' => \&highlight_item );
     $item = { 'ItemType'=>'book', 'Data'=>\%data, 'Actions'=>\%actions };
     bless $item, Some::Example::Class;
     $obj->publish($template, $item);

   In this last example, the designator `ACT:Highlight' would result in
the object $item being passed as the only argument to the subroutine
`highlight_item()' referenced in the action HASH.

Line by Line Mode
-----------------

   By default, the publishing methods slurp in the entire template and
process it as a text block.  This allows for multi-line conditional text
blocks.  However, in some cases the resulting output may be very large, or
you may want the output to be generated line by line for some other reason
(such as unbuffered output).  This is accomplished through the
`line_by_line()' method, which accepts an optional boolean value, which
sets the current setting if specified or returns the current settingif
not.  Note that this has the most notable impact on the `publish()' and
`publish_email()' methods, since the results of the merge operations are
sent to a handle.  If the line by line switch is set, then the
`publish_text()' method will substitute line by line, but will still
return the entire merged document as a single text block (not line by
line).

   This is turned OFF by default.

Templates
---------

   Templates consist of text documents that contain special substitution
designators as described previously.  The template arguments passed to the
publishing functions can take one of three forms:

File Handle
     This is a FileHandle object not a glob.  You must use the FileHandle
     package that comes with the Perl distribution for this type of
     template argument.  Processing begins at the current file position
     and continues until the end of file condition is reached.

File Path
     If the argument is a scalar string with no whitespace, it is assumed
     to be a file path.  The template at that location will be used when
     merging the document.

Text Block
     If the argument is a scalar string that contains whitespace, it is
     assumed to be the actual text template.  Substitution will be
     performed on a locally scoped copy of this argument.

     Note that you should not use this type of template argument if your
     template is very large and you are using line by line mode.  In this
     case you should use a FileHandle or file path argument.

Methods
-------

new()
     This method gives us a blessed hash reference, with the following
     attribute keys:

          _Text_Merge_LineMode

     Other keys can be added by objects which inherit `Text::Merge'.

line_by_line($setting)
     This method returns the current setting if the `$setting' argument is
     omitted.  Otherwise it resets the line-by-line mode to the setting
     requested.  A non-zero value tells the publishing methods to process
     the template line by line.  For those methods that output results to
     a handle, then those results will also be echoed line by line.

set_delimiters($start, $end)
     This method assigns a new command delimiter set for the tags (double
     square brackets by default).  The 'colon' character is not allowed
     within the delimiter, and the delimiter may not be a single curly
     bracket.  Both the $start and $end delimiters must be provided, and
     they cannot be identical.

publish($template, $dataref, $actionref)
     This is the normal publishing method.  It merges the specified
     template with the data and any provided actions.  The output is sent
     to the currently selected handle, normally STDOUT.

publish_to($handle, $template, $dataref, $actionref)
     This is similar to the normal publishing method.  It merges the
     specified template with the data and any provided actions.  The
     output is sent to the specified $handle or to the currently selected
     handle, normally STDOUT, if the $handle argument is omitted.

publish_text($template, $dataref, $actionref)
     This method works similar to the `publish_to()' method, except it
     returns the filtered output as text rather than sending it to the
     currently selected filehandle.

publish_email($mailer, $headers, $filepath, $data, $actions)
     This method is similar to `publish()' but opens a handle to
     `$mailer', and sending the merged data formatted as an e-mail
     message.  `$mailer' may contain the sequences `RECIPIENT' and/or
     `SUBJECT'.  If either does not exists, it will be echoed at the
     beginning of the email (in the form of a header), allowing e-mail to
     be passed preformatted.  This is the preferred method; use a mailer
     that can be told to accept the "To:", "Subject:" and "Reply-To:"
     fields within the body of the passed message and do not specify the
     `RECIPIENT' or `SUBJECT' tags in the `$mailer' string.  Returns false
     if failed, true if succeeded.  The recommended mail program is
     'sendmail'.  `$headers' is a HASH reference, containing the header
     information.  Only the following header keys are recognized:

          To
          Subject
          Reply-To
          CC
          From (works for privileged users only)

     The values associated with these keys will be used to construct the
     desired e-mail message header.  Secure minded site administrators
     might put hooks in here, or even better clean the data,  to protect
     access to the system as a precaution, to avoid accidental mistakes
     perhaps.

     Note: the `$mailer' argument string should begin with the type of
     pipe required for your request.  For sendmail, this argument would
     look something like (note the vertical pipe):

          '|/usr/bin/sendmail -t'

     Be careful not to run this with write permission on the sendmail file
     and forget the process pipe!!!

cgi2data($cgi)
     This method converts `CGI.pm' parameters to a data hash reference
     suitable for merging.  The $cgi parameter is a CGI object and is
     optional, but you must have imported the :standard methods from
     `CGI.pm' if you omit the $cgi paramter.  This method returns a hash
     reference containing the parameters as data.  Basically it turns list
     values into list references and puts everything in a hash keyed by
     field name.

PREREQUISITES
=============

   This module was written and tested in Perl 5.005 and runs with `-Tw'
set and `use strict'.  It requires use of the package FileHandle which is
part of the standard perl distribution.

AUTHOR
======

   This software is released under the Perl Artistic License.  Derive what
you wish, as you wish, but please attribute releases and include derived
source code.  (C) 1997-2000 by Steven D. Harris, perl@nullspace.com


File: pm.info,  Node: Text/Merge/Lists,  Next: Text/MetaText,  Prev: Text/Merge,  Up: Module List

v.0.30 Text/data merge with lists/table support
***********************************************

NAME
====

   Text::Merge::Lists - v.0.30 Text/data merge with lists/table support

SYNOPSIS
========

     $filter = new Text::Merge::Lists($template_path);

     $filter->set_max_nesting_depth($intval);

DESCRIPTION
===========

   The `Text::Merge::Lists' package is designed to extend the
`Text::Merge' package with "list styles" in addition to the other
formatting methods of fields.  This allows the display of fields that
contain "lists" of items in addition to the normal "scalar" fields
supported by `Text::Merge'.  See the `Text::Merge' package documentation
for more information on templates and merging.

   All the features of the `Text::Merge' package are supported and invoked
in an identical fashion.  The only difference in your programs to use the
`Text::Merge::Lists' object instead of the `Text::Merge' object is the
constructor, which must be invoked with the "Template Path" to the
directory containing your various arbitrary lists style directories,
described later.  See the `Text::Merge' object for a description of the
publishing methods available to you.

   Lists can be nested, and you can use the `set_max_nesting_depth()'
object method to override the default maximum nesting depth of 3.  That is
to say, you can only have a list of a list of a list by default.  If you
want to nest further you will need to adjust this value.  The depth limit
here is to prevent you from clobbering the perl stack (and possibly other
memory!) with deep recursion.

List Structure
--------------

   A list variable is a reference to an ARRAY of data HASH references or
item HASH references.  Basically, the equivalent of the $data or $item
argument to the publishing methods.  If you apply a list style to a SCALAR
it will be treated as a list of one item.  Undefined lists are not
considered empty, but they are undefined as one would expect.  Here is an
example list assignment to the variable `$fruit_list':

     $apple = { 'Color'=>'Red', 'Size'=>'medium', 'Shape'=>'round' };
     $pear = { 'Color'=>'Green', 'Size'=>'medium', 'Shape'=>'pear-shaped' };
     $grape = { 'Color'=>'Purple', 'Size'=>'small', 'Shape'=>'round' };
     $fruit_list = [ $apple, $pear, $grape ];

List Style Syntax
-----------------

   If you have read the `Text::Merge' module documentation, which is
recommended, then you may be familiar with the syntax for displaying
arbitrary fields using different styles, such as this example for a
displaying a numerical value, stored in the `MyDollars' field, as a decimal
value with two decimal places:

     REF:MyDollars:dollars

   There are many display styles available, some of which only apply to
*particular types of data*.  These are described in detail in the
`Text::Merge' module documentation.

   The `Text::Merge::Lists' object extends the `Text::Merge' object with
support for list (ARRAY) references.  By using the list style designators,
you can display lists in various contexts, just as you would any other
field value.  The templates for the various lists styles are stored in
directories corresponding to the list style names.  These are located in
the path provided to the constructor.

   The individual items stored in the lists should be data or item HASH
references as described in the `Text::Merge' documentation.  These objects
have an "ItemType" designator, allowing the individual list styles to
display each type differently in that context.  These listing templates
are plain text files, ending in '.txt' and stored in the style directory.
For example, a list style of 'showcase' stored in the templates path
`/usr/templates/' would have all of it's files stored in the path,
`/usr/templates/showcase/'.  If you had an item type of 'book' to display
in a given list, that template would be stored at
`/usr/templates/showcase/book.txt'.  The template will be used for each
occurrence of the item type 'book' in any list displayed using the
'showcase' style.  In most cases, the listing templates will be output
"end on end" but that may not always be the case as described later.

   The syntax for a reference to an item list field named, `DisplayItems',
for the example list style of 'showcase' would look something like this:

     REF:DisplayItems:list_showcase

   Notice the `list_' portion (that is an 'underscore').  This tells the
filter that you want to treat the field `DisplayItems' as a list of items
and use the 'showcase' list style.  The system will then look-up any
templates it needs for the list in the 'showcase' directory mentioned
above.

List Style Features
-------------------

   Each list style has various special features that you can use by
providing certain files in the list style directory.  These include a
header, a footer, a default item, and a message to display if the list is
empty.

List Header
     The list header is an HTML fragment contained in a plain text file
     that is treated by the filter as if it were part of the original
     document (as opposed to a list item), it is displayed immediately
     before the list itself.  It is contained in the file `header.txt' in
     the list style directory.  This file is optional.

List Footer
     The list footer is similar to the list header described above.  It is
     displayed immediately following the list itself.  It is contained in
     the file `footer.txt' in the list style directory.  This file is also
     optional.

Default Item Type
     You may provide a listing fragment that will be used for any item
     that does not have a template in the designated list style directory.
     This could be an error message, or it my display information
     universal to all of your objects.  You can use this item template if
     all of your items are very similar and you don't want to construct a
     template for each item in that style.

     The default item template is located in a file called `default.txt'
     in the designated list style directory.  This file is optional.

Empty List Message
     Similar to a header or footer, the empty list message is a file
     contained in the designate style directory that is treated as part of
     the parent document for display purposes, if no items exist in your
     list.  If this file is not provided, then empty lists are constructed
     as empty strings.  The file name for the empty list message is
     `empty.txt' in the designated list style directory and is optional.

Table Style Syntax
------------------

   In addition to list styles, `Text::Merge::Lists' also supports HTML
table styles.  Table styles are trickier to set up than list styles, but
the principle is basically the same, and you get the benefit of having
more than one column in your list display.  You maintain full control over
the styling of the individual cells and the table attributes.  All tables
are HTML.

   The syntax of a table style is very similar to the syntax of a list
style, but you need to specify the number of columns for the table in the
tag.  For example:

     REF:ItemList:table4_options

   The example listed above would generate a table using the table style
defintion, "options", that is four columns wide.  The number is required
and must be at least 1.  Large numbers (>10) are discouraged because they
are practically unusable.

   A table generated by a table style is basically a "grid" of the
specified width with a "filler" cell at the end of the table if necessary.
The filler cell may be one or more cells wide, up to one less than the
specified table width.  With this in mind, there are more restrictions on
the templates required for a table style, as described later.

   Just as is the case with the list styles, individual items stored in
the lists should be data or item HASH references as described in the
`Text::Merge' documentation.  These objects have an "ItemType" designator,
allowing the individual table styles to display the cell for each type
differently in the same context.  The cell templates are plain text files,
ending in '.txt' and stored in the table style directory.

   For example, a table style of 'options' stored in the templates path
`/usr/templates/' would be located at `/usr/templates/tables/options/'.
If you had an item of type 'choice' to display in a given list, then the
cell template for display of that particular item would be
`/usr/templates/tables/options/choice.txt'.  Notice that the path was
created by stringing together the list-styles/template
(`/usr/templates')path, the table styles subdirectory (`tables/'), and the
directory and path for the individual style and item type
(`options/choice.txt').

   If you choose to construct a table style, take care to include all the
required elements.  Start and finish your cell templates with the <TD> and
</TD> elements respectively.  Start your header with <TABLE> and end it
with </TABLE>.  Remember that the Text::Merge::Lists methods will insert
the <TR> and </TR> elements for rows containing your cell templates.  Only
use <TR> and </TR> in the header and footer files, and if you do be sure
to use only one cell in each row and use the `TableColumns' field to
assign the COLSPAN for that table.  Observing these few things should keep
your tables functional.

Table Style Features
--------------------

   Each table style has similar requirements for the files stored in the
designated table style directory.  The required files include a header, a
footer, a filler template, a default cell template, and the optional
template to use if the list is empty.  The header, footer, and empty
templates will all have access to the data of the calling template, in
addition the header and footer templates will also have the additional
field TableColumns set.  Likewise, the filler template will have the
FillerColumns field set, and that must be used to set the COLSPAN of the
last table cell as described later.

Table Header Template
     The table header is contained in a file named `header.txt' in the
     table style directory.  This file *must contain* the <TABLE ...>
     element defintion.  It may also contain full table rows to start off
     the table.  Because table styles may be invoked with a variable
     column count, the field `TableColumns' is provided to use for a cell
     in these table rows, and while limited, it does allow the insertion
     of header rows.  For example, this might be the contents of a common
     header.txt file:

          <TABLE BORDER=1>
          	<TR NOSAVE><TD ALIGN=CENTER
          		COLSPAN="REF:TableColumns"><B>Title</B></TD></TR>

     Notice the `REF:TableColumns' portion of the code, which will be
     replaced with the number of columns in the table when the table is
     created.  This allows for a "variable width" header that covers all
     columns.

Table Footer Template
     The table footer is contained in a file named `footer.txt' and is
     very similar to the `header.txt' file described above.  The
     `footer.txt' file *must contain* the </TABLE> element closing out the
     table.  Before that element, any number of optional footer rows can
     be listed, and they too can use the `TableColumns' field to span the
     table columns as well.  For example:

          <TR><TD COLSPAN="REF:TableColumns">This
          			is the last table row.</TD></TR></TABLE>

     Notice the `REF:TableColumns' field used in the the last cell
     definition, just as is done with the header rows.  Also notice the
     </TABLE> listed at the very end.  This basically closes out the table
     and is required.  You can also include other HTML after this element
     if you wish, but it will not be included in the table itself.

Table Filler Template
     The table filler cell is contained in a file named `filler.txt' in
     the table style directory.  This is the template used for the last
     cell of a table to fill the empty spaces that may be left if the
     number of items in the list is not evenly divisible by the number of
     columns in the table.  A field named `FillerColumns' is provided to
     this template and it *must be used* to specify the COLSPAN of the
     cell.  This template, as with all other cell templates, must contain
     the <TD ...> and </TD> elements of the cell.  This is a simple
     example filler cell template:

          <TD COLSPAN="REF:FillerColumns"><I>this is filler</I></TD>

     The filler cell will be created with a single non-blocking space
     character (*&nbsp;*) as content if no `filler.txt' template file
     exists.

Item Type Cell Template
     Each item in the list can be displayed based on its `ItemType'
     attribute if a cell template exists in the table style directory that
     is named with the item type followed by the '.txt' suffix.  If such a
     template exists, it will be used to display the cell using the item
     data and actions.  Every cell template *must contain* the
     <TD...>...</TD> elements to work properly in the table style.

Default Cell Template
     The default cell template will be used if there is no cell template
     for the item type to be displayed.  That is to say, if no file as
     described above exists for the item type in question, a file called
     'default.txt' will be used to display the item.  The  'default.txt'
     file is required if your table style definition is be robust.

Empty Table Template
     The empty table template is used if the list exists but contains no
     items.  The empty table template is contained in a file in the table
     style directory named 'empty.txt'.  This template will have access to
     all the data and actions of the calling template.  Note that if the
     'empty.txt' template is used, then none of the other templates will be
     used for that table style and the results of processing 'empty.txt'
     will be the only thing displayed.

Methods
-------

   These are the methods that extend the basic functions of the
`Text::Merge' object.  Note that we overload `convert_value()' in order to
insert our list style format recognition and interpretation.  This is very
elegant and easy to do.

new($liststyles)
     This method constructs a `Text::Merge::Lists' object.  It basically
     grabs a new `Text::Merge' object and then assigns the liststyles
     directory (which is required).  If the template path is omitted, an
     the call is treated as a normal `Text::Merge' object request.

convert_value($dataref, $name, $style, $item)
     This method catches list styles and handles them, otherwise the
     `Text::Merge' method is used.

set_max_nesting_depth($intval)
     This method assigns the maximum nesting depth for lists.  The default
     maximum depth is 3.

sort_method($methodstr, $listref)
     This method returns the sorted list by processing the `$methodstr'
     for each item in the list.  A common `$methodstr' might look
     something like:

          $method = 'REF:SomeField reverse numeric';

     Which would perform a reverse numeric sort on the list.  Basically a
     merge is performed on the $methodstr and the sort algorithm is
     sensitive to the keyword designators: reverse and numeric, which must
     appear at the end of the sort method string.

     These must be items, where the data is contained in the 'Data' field.
     For instance:

          $item = { 'ItemType' => 'someitem',
          	  'Data' => { 'field1' => 'val1',
          		      'field2' => 'val2' } };

PREREQUISITES
=============

   This module inherits and extends the `Text::Merge' module by this
author.  This module was written and tested under perl 5.005 and runs with
`-Tw' set and `use strict'.

AUTHOR
======

   This software is released under the Perl Artistic License.  Modify as
you please, but please attribute releases and include all derived source
code.  (C) 1997, 1998, 1999, by Steven D. Harris, sharris@nullspace.com


File: pm.info,  Node: Text/MetaText,  Next: Text/MetaText/Directive,  Prev: Text/Merge/Lists,  Up: Module List

Perl extension implementing meta-language for processing  "template" text files.
********************************************************************************

NAME
====

   Text::MetaText - Perl extension implementing meta-language for
processing "template" text files.

SYNOPSIS
========

     use Text::MetaText;

     my $mt = Text::MetaText->new();

     # process file content or text string
     print $mt->process_file($filename, \%vardefs);
     print $mt->process_text($textstring, \%vardefs);

     # pre-declare a BLOCK for subsequent INCLUDE
     $mt->declare($textstring, $blockname);
     $mt->declare(\@content, $blockname);

SUMMARY OF METATEXT DIRECTIVES
==============================

     %% DEFINE
        variable1 = value          # define variable(s)
        variable2 = "quoted value"
     %%

     %% SUBST variable  %%         # insert variable value
     %% variable %%                # short form of above

     %% BLOCK blockname %%         # define a block 'blockname'
        block text...
     %% ENDBLOCK %%

     %% INCLUDE blockname %%       # include 'blockname' block text
     %% INCLUDE filename  %%       # include external file 'filename'

     %% INCLUDE file_or_block      # a more complete example...
        variable = value           # additional variable definition(s)
        if       = condition       # conditional inclusion
        unless   = condition       # conditional exclusion
        format   = format_string   # printf-like format string with '%s'
        filter   = fltname(params) # post-process filter
     %%

     %% TIME                       # current system time, as per time(2)
        format   = format_string   # display format, as per strftime(3C)
     %%

DESCRIPTION
===========

   MetaText is a text processing and markup meta-language which can be
used for processing "template" files.  This module is a Perl 5 extension
implementing a MetaText object class which processes text files,
interpreting and acting on the embedded MetaText directives within.

   Like a glorified pre-processor, MetaText can; include files, define and
substitute variable values, execute conditional actions based on variables,
call other perl functions or object methods and capture the resulting
output back into the document, and more.  It can format the resulting
output of any of these operations in a number of ways.  The objects, and
inherently, the format and symantics of the MetaText langauge itself, are
highly configurable.

   MetaText was originally designed to aid in the creation of html
documents in a large web site.  It remains well suited for this and
similar tasks, being able to create web pages (dynamically or statically)
that are consistent with each other, yet easily customisable:

   * standard headers, footers and other elements can be defined in
     separate files and then inserted into web documents:

          %% INCLUDE header %%

   * variables can be defined externally or from within a document, then
     can be substituted back into the text.  This is useful for including
     your *%% name %%* or *%% email %%* address or any other variable, and
     for encoding URL's or file paths that can then be changed en masse.
     e.g.

          <img src="%% imgroot %%/foo/bar.gif">

   * conditional actions can be made based on variable definitions,
     allowing easily and instantly customisable web pages. e.g

          %% INCLUDE higraphics/header if="higfx && userid != abw" %%

   * blocks of text can be internally defined simplifying the creation of
     repetitive elements.  e.g.

          %% BLOCK table_row %%
          <tr> <td>%% userid %%</td> <td>%% name %%</td> </tr>
          %% ENDBLOCK %%

          %% INCLUDE table_row userid=lwall  name="Larry Wall"         %%
          %% INCLUDE table_row userid=tomc   name="Tom Christiansen"   %%
          %% INCLUDE table_row userid=merlyn name="Randal L. Schwartz" %%

   * in addition, the *metapage* utility is a script which can
     automatically traverse document trees, processing updated files to
     assist in web document management and other similar tasks.

PREREQUISITES
=============

   MetaText requires Perl 5.004 or later.  The Date::Format module should
also be installed.  This is available from CPAN (in the "TimeDate"
distribution) as described in the following section.  The *metapage*
utility also requires the File::Recurse module, distributed in the
"File-Tools" bundle, also available from CPAN.

OBTAINING AND INSTALLING THE METATEXT MODULE
============================================

   The MetaText module is available from CPAN.  As the 'perlmod' man page
explains:

     CPAN stands for the Comprehensive Perl Archive Network.
     This is a globally replicated collection of all known Perl
     materials, including hundreds of unbunded modules.

     [...]

     For an up-to-date listing of CPAN sites, see
     http://www.perl.com/perl/ or ftp://ftp.perl.com/perl/ .

   Within the CPAN archive, MetaText is in the "Text::" group which forms
part of the the category:

     *) String Processing, Language Text Processing,
        Parsing and Searching

   The module is available in the following directories:

     /modules/by-module/Text/Text-MetaText-<version>.tar.gz
     /authors/id/ABW/Text-MetaText-<version>.tar.gz

   For the latest information on MetaText or to download the latest
pre-release/beta version of the module, consult the definitive reference,
the MetaText Home Page:

     http://www.kfs.org/~abw/perl/metatext/

   MetaText is distributed as a single gzipped tar archive file:

     Text-MetaText-<version>.tar.gz

   Note that "<version>" represents the current MetaText Revision number,
of the form "0.18".  See `REVISION' in this node below to determine the
current version number for Text::MetaText.

   Unpack the archive to create a MetaText installation directory:

     gunzip Text-MetaText-<version>.tar.gz
     tar xvf Text-MetaText-<version>.tar

   'cd' into that directory, make, test and install the MetaText module:

     cd Text-MetaText-<version>
     perl Makefile.PL
     make
     make test
     make install

   The 't' sub-directory contains a number of small sample files which are
processed by the test script (called by 'make test').  See the README file
in that directory for more information.  A logfile (test.log) is generated
to report any errors that occur during this process.  Please note that the
test suite is incomplete and very much in an 'alpha' state.  Any further
contributions here are welcome.

   The 'make install' will install the module on your system.  You may need
root access to perform this task.  If you install the module in a local
directory (for example, by executing "perl Makefile.PL LIB=~/lib" in the
above - see `perldoc MakeMaker' for full details), you will need to ensure
that the PERL5LIB environment variable is set to include the location, or
add a line to your scripts explicitly naming the library location:

     use lib '/local/path/to/lib';

   The *metapage* utility is a script designed to automate MetaText
processing of files.  It can traverse directory trees, identify modified
files (by comparing the time stamp of the equivalent file in both "source"
and "destination" directories), process them and direct the resulting
output to the appropriate file location in the destination tree.  One can
think of *metapage* as the MetaText equivalent of the Unix make(1S)
utility.

   The installation process detailed above should install *metapage* in
your system's perl 'installbin' directory (try `perl '-V:installbin'' to
check this location).  See the *metapage* documentation (`perldoc
metapage') for more information on configuring and using *metapage*.

USING THE METATEXT MODULE
=========================

   To import and use the MetaText module the following line should appear
in your Perl script:

     use Text::MetaText;

   MetaText is implemented using object-oriented methods.  A new MetaText
object is created and initialised using the Text::MetaText->new() method.
This returns a reference to a new MetaText object.

     my $mt = Text::MetaText->new;

   A number of configuration options can be specified when creating a
MetaText object.  A reference to a hash array of options and their
associated values should be passed as a parameter to the new() method.

     $my $mt = Text::MetaText->new( { 'opt1' => 'val1', 'opt2' => 'val2' } );

   The configurations options available are described in full below.  All
keywords are treated case-insensitively (i.e. "LIB", "lib" and "Lib" are
all considered equal).

LIB
     The INCLUDE directive causes the external file specified ("INCLUDE
     <file>") to be imported into the current document.  The LIB option
     specifies one or more directories in which the file can be found.
     Multiple directories should be separated by a colon or comma.  The
     current directory is also searched by default.

          my $mt = Text::MetaText->new( { LIB => "/tmp:/usr/metatext/lib" } );

CASE
     The default behaviour for MetaText is to treat variable names and
     identifiers case insensitively.   Thus, the following are treated
     identically:

          %% INCLUDE foo %%
          %% INCLUDE Foo %%
          %% INCLUDE FOO %%

     When running with CASE sensitivity disabled, the MetaText processor
     converts all variable and symbol names to lower case.

     Setting the CASE option to any non-zero value causes the document to
     be processed case sensitively.

          my $mt = Text::MetaText->new( { CASE => 1 } ); # case sensitive

     Note that the configuration options described in this section are
     always treated case insensitively regardless of the CASE setting.

CASEVARS
     When running in the default case-insensitive mode (CASE => 0), all
     variable names are folded to lower case.  It is convenient to allow
     applications to specify some variables that are upper or mixed case
     to distinguish them from normal variables.  The metapage utility uses
     this to define a number of 'system variables' that hold information
     about the file being processed: FILETIME, FILEMOD, FILEPATH, etc.  By
     defining these as CASEVARS, the processor will attempt to
     differentiate them from normal variables by their case.  Thus, the
     calling application can define variables that are guaranteed not to
     conflict with any user-defined variables (while CASE insensitive) and
     are also effectively read-only.

          my $mt = Text::MetaText->new( {
              CASEVARS => [ 'AUTHOR', 'COPYRIGHT' ],
          });

          print $mt->process_file($file, {
          	AUTHOR    => 'Andy Wardley',
          	COPYRIGHT => '(C) Copyright Andy Wardley 1998',
          });

     The input file:

          %% DEFINE copyright = "(C) Ima Plagiarist" %%
          %% COPYRIGHT %%
          %% copyright %%

     produces the following output:

          (C) Copyright Andy Wardley 1998        # COPYRIGHT
          (C) Ima Plagiarist                     # copyright

     Note that CASEVARS can only apply to variables that are pre-defined
     (i.e. specified in the hash array that is be passed to process_xxxx()
     as a second parameter).  It is not possible to re-define a CASEVARS
     variable with a DEFINE directive because the variable name will always
     be folded to lower case (when CASE == 0).  e.g.

          %% DEFINE COPYRIGHT = "..." %%

     is interpreted as:

          %% DEFINE copyright = "..." %%

     It is recommended that such variables always be specified in UPPER
     CASE as a visual clue to indicate that they have a special meaning and
     behaviour.

MAGIC
     MetaText directives are identifed in the document being processed as
     text blocks surrounded by special "magic" identifers.  The default
     identifiers are a double percent string, "%%", for both opening and
     closing identifiers.  Thus, a typical directive looks like:

          %% INCLUDE some/file %%
          
          and may be embedded within other text:

          normal text, blah, blah %% INCLUDE some/file %% more normal text

     The MAGIC option allows new identifiers to be defined.  A single
     value assigned to MAGIC defines a token to be used for both opening
     and closing identifiers:

          my $mt = Text::MetaText->new( { MAGIC => '++' } );

          ++ INCLUDE file ++

     A reference to an array providing two values (elements 0 and 1)
     indicates separate tokens to be used for opening and closing
     identifiers:

          my $mt = Text::MetaText->new( { MAGIC => [ '<!--', '-->' ] } );

          <!-- INCLUDE file -->

CHOMP
     When MetaText processes a file it identifies directives and replaces
     them with the result of whatever magical process the directive
     represents (e.g. file contents for an INCLUDE, variable value for a
     SUBST, etc).  Anything outside the directive, including newline
     characters, are left intact.  Where a directive is defined that has
     no corresponding output (DEFINE, for example, which silently sets a
     variable value), the trailing newline characters can leave large
     tracts of blank lines in the output documents.

     For example:

          line 1
          %% DEFINE f="foo" %%
          %% DEFINE b="bar" %%
          line 2

     Produces the following output:

          line 1

          line 2

     This happens because the newline characters at the end of the second
     and third lines are left intact in the output text.

     Setting CHOMP to any true value will remove any newline characters
     that appear *immediately after* a MetaText directive.  Any characters
     coming between the directive and the newline, including whitespace,
     will override this behaviour and cause the intervening characters and
     newline to be output intact.

     With CHOMP set, the following example demonstrates the behaviour:

          line 1
          %% DEFINE f="foo" %%
          %% DEFINE b="bar" %%<space>
          line 2

     Produces the following output (Note that "<space>" is intended to
     represent a single space character, not the string "<space>" itself,
     although the effect would be identical):

          line 1
          <space>
          line 2

TRIM
     The TRIM configuration parameter, when set to any true value, causes
     the leading and trailing newlines (if present) within a defined BLOCK
     to be deleted.  This behaviour is enabled by default.  The following
     block definition:

          %% BLOCK camel %%
          The eye of the needle
          %% ENDBLOCK %%

     would define the block as "The eye of the needle" rather than "\nThe
     eye of the needle\n".  With TRIM set to 0, the newlines are left
     intact.

     It is possible to override the TRIM behaviour by specifying the trim
     value as a parameter in a BLOCK definition directive:

          %% BLOCK trim %%
          ...content...
          %% ENDBLOCK %%

     or conversely:

          %% BLOCK trim=0 %%
          ...content...
          %% ENDBLOCK %%

FILTER
     There may be times when you may want to INCLUDE a file or element in a
     document but want to filter the contents in some way.  You may wish
     to escape (i.e. prefix with a backslash '\') certain characters such
     as quotes, search for certain text and replace with an alternative
     phrase, or perform some other post-processing task.  The FILTER option
     allows you to define one or more code blocks that can be called as
     filter functions from an INCLUDE directive.  Each code block is given
     a unique name to identify it and may have calling parameters
     (parenthesised and separated by commas) that can be specified as part
     of the directive.  e.g.

          %% INCLUDE foo filter="slurp(prm1, prm2, ...)" %%

     Two default filters are pre-defined: escape() and sr().  escape()
     takes as a parameter a perl-like regular expression pattern that
     indicates characters that should be 'escaped' (i.e. prefixed by a
     backslash '\') in the text.  For example, to escape any of the
     character class `["'\]' you would specify the filter as:

          %% INCLUDE foo filter="escape([\"'\\])" %%

     The second filter, sr(), takes two arguments, a search string and a
     replace string.  A simple substitution is made on the included text.
     e.g.

          %% INCLUDE foo filter="sr(spam, \"processed meat\")" %%

     Note that quotes and other special metacharacters should be escaped
     within the filter string as shown in the two examples above.

     Additional filters can be specified by passing a reference to a hash
     array that contains the name of the filter and the code itself in
     each key/value pair.  Your filter function should be designed to
     accept the name of the function as the first parameter, followed by a
     line of text to be processed.  Any additional parameters specified in
     the INCLUDE directive follow.  The filter function is called for each
     line of an INCLUDE block and should return the modified text.

     Example:

          my $mt = Text::MetaText->new( {
              FILTER => {
                  'xyzzy' => sub {
                       my ($filtername, $text, @params) = @_;
                       $text = # do something here...
          		 $text;  # return modified text
                  }
              }
          } );

          %% INCLUDE file1 filter="xyzzy(...)" %%

     A new FILTER definition will replace any existing filter with the
     same name.

EXECUTE
     The SUBST directive performs a simple substitution for the value of
     the named variable.  In the example shown below, the entire
     directive, including the surrounding 'magic' tokens '%%', is replaced
     with the value of the variable 'foo':

          %% SUBST foo %%  (or more succinctly, %% foo %%)

     If the named variable has not been defined, MetaText can interpret the
     variable as the name of an object method in the current class or as a
     function in the main package.

     If the EXECUTE flag is set to any true value, the MetaText processor
     will interpret the variable as an object method and attempt to apply
     it to its own object instance (i.e. $self->$method(...)).  If the
     method is not defined, the processor fails quietly (but see ROGUE
     below to see what can happens next).  This allows classes to be
     derived from MetaText that implement methods that can be called (when
     EXECUTE == 1) as follows:

          %% method1 ... %%       # calls $self->method1(...);
          %% method2 ... %%       # calls $self->method2(...);

     The text returned from the method is used as a replacement value for
     the directive.

     The following pseudo-code example demonstrates this:

          package MyMetaText;
          @ISA = qw( Text::MetaText );

          sub foo { "This is method 'foo'" }  # simple return string
          sub bar { "This is method 'bar'" }  # "        "         "

          package main;

          my $mt = MyMetaText->new( { EXECUTE => 1 } );
          print $mt->process("myfile");

     which, for the file 'myfile':

          %% foo %%
          %% bar %%

     generates the following output:

          This is method 'foo'
          This is method 'bar'

     If the EXECUTE flag is set to a value > 1 and the variable name does
     not correspond to a class method, the processor tries to interpret the
     variable as a function in the main package.  Like the example above,
     the processor fails silently if the function is not defined (but see
     ROGUE below).

     The following pseudo-code extract demonstrates this:

          my $mt = Text::MetaText->new( { EXECUTE => 2 } );
          print $mt->processs("myfile");

          sub foo { "This is function 'foo'" }  # simple return string
          sub bar { "This is function 'bar'" }  # "        "         "
          
          which, for the file 'myfile':

          %% foo %%
          %% bar %%

     generates the following output:

          This is function 'foo'
          This is function 'bar'

     Any additional parameters specified in the directive are passed to the
     class method or function as a hash array reference.  The original
     parameter string is also passed.  Note that the first parameter
     passed to class methods is the MetaText (or derivative) object
     reference itself.

     Example:

          %% foo name="Seuss" title="Dr" %%

     causes the equivalent of (when EXECUTE is any true value):

          $self->foo(                                  # implicit $self ref
          	{ 'name' => 'Seuss', 'title' => 'Dr' },  # hash ref of params
          	  'name="Seuss" title="Dr"' );           # parameter string

     and/or (when EXECUTE > 1):

          &main::foo(
          	{ 'name' => 'Seuss', 'title' => 'Dr' },  # hash ref of params
          	  'name="Seuss" title="Dr"' );           # parameter string

ROGUE
     This configuration item determines how MetaText behaves when it
     encounters a directive it does not recognise.  The ROGUE option may
     contain one or more of the ROGUE keywords separated by any non-word
     character.  The keywords and their associated meanings are:

          warn    Issue a warning (via the ERROR function, if
                  specified) when the directive is encountered.

          delete  Delete any unrecognised directives.

     The default behaviour is to silently leave any unrecognised directive
     in the processed text.

     Example:

          my $mt = Text::MetaText->new( { ROGUE => "delete,warn" } );

DELIMITER
     The DELIMITER item specifies the character or character sequence that
     is used to delimit lists of data.  This is used, for example, by the
     "in" operator which can be used in evaluation conditions.  e.g.

          %% INCLUDE hardenuf if="uid in abw,wrigley" %%

     In this case, the condition evaluates true if the uid variable
     contains the value "abw" or "wrigley".  The default delimiter
     character is a comma.

     The example:

          my $mt = Text::MetaText->new( { DELIMITER => ":" } );

     would thus correctly process:

          %% INCLUDE hardenuf if="uid in abw:wrigley" %%

ERROR
     The ERROR configuration item allows an alternative error reporting
     function to be specified for error handling.  The function should
     expect a printf() like calling convention.

     Example:

          my $mt = Text::MetaText->new( {
              ERROR => sub {
                  my ($format, @params) = @_;
                  printf(STDERR "ERROR: $format", @params);
              }
          } );

DEBUG
     The DEBUG item allows an alternative debug function to be provided.
     The function should expect a printf() like calling convention, as per
     the ERROR option described above.  The default DEBUG function sends
     debug messages to STDERR, prefixed by a debug string: 'D> '.

DEBUGLEVEL
     The DEBUGLEVEL item specifies which, if any, of the debug messages are
     displayed during the operation of the MetaText object.  Like the ROGUE
     option described above, the DEBUGLEVEL value should be constructed
     from one or more of the following keywords:

          none      no debugging information (default)
          info      general processing information
          config    MetaText object configuration items
          preproc   pre-processing phase
          process   processing phase
          postproc  post-processing phase
          data      additional data parameters in debug messages
          content   content of pre-processed INCLUDE blocks
          function  list functions calls as executed
          evaluate  trace conditional evaluations
          test      used for any temporary test code
          all       all of the above (excluding "none", obviously)

     Example:

          my $mt = Text::MetaText->new( {
          	DEBUGLEVEL => "preproc,process,data"
          } );

MAXDEPTH
     It is possible for MetaText to become stuck in an endless loop if a
     circular dependancy exists between one or more files.  For example:

          foo:
              %% INCLUDE bar %%

          bar:
              %% INCLUDE foo %%

     To detect and avoid such conditions, MetaText allows files to be
     nested up to MAXDEPTH times.  By default, this value is 32.  If you
     are processing a file which has nested INCLUDE directives to a depth
     greater than 32 and MetaText returns with a "Maximum recursion
     exceeded" warning, set this confiuration item to a higher value.  e.g.

          my $mt = Text::MetaText->new( { MAXDEPTH => 42 } );

PROCESSING TEXT FILES AND STRINGS
=================================

   The MetaText methods for processing text files and strings are:

     process_file($file, ...);
     process_text($text, ...);

   The process() method is also supported for backward compatibility with
older versions of MetaText.  The process() method simply calls
process_file(), passing all arguments to it.

   The process_file() method processes a text file interpreting any
MetaText directives embedded within it.  The first parameter should be the
name of the file which  should reside in the current working directory or
in one of the directories specified in the LIB configuration option.  A
filename starting with a slash '/' or a period '.' is considered to be an
absolute path or a path relative to the current working directory,
respectively.  In these cases, the LIB path is not searched.  The optional
second parameter may be a reference to a hash array containing a number of
variable/value definitions that should be pre-defined when processing the
file.

     print $mt->process_file("somefile", { name => "Fred" });

   If "somefile" contains:

     Hello %% name %%

   then the output generated would be:

     Hello Fred

   Pre-defining variables in this way is equivalent to using the DEFINE
directive (described below) at the start of the INCLUDE file

     %% DEFINE name="Fred" %%
     Hello %% name %%

   The process_file() function will continue until it reaches the end of
the file or a line containing the pattern "__END__" or "__MTEND__" by
itself ("END" or "MTEND" enclosed by double underscores, no other
characters or whitespace on the line).

   Note that the pre-processor (a private method which is called by
process(), so feel free to forget all about it) *does* scan past any
__END__ or __MTEND__ marker.  In practice, that means you can define
blocks after, but use them before, the terminating  marker. e.g.

     Martin, %% INCLUDE taunt %%

     __MTEND__               << processor stops here and ignores
                                everything following
     %% BLOCK taunt %%       << but the pre-processor has correctly
     you Camper!                continued and parsed this block so that
     %% ENDBLOCK %%             it can be included in the main body

   produces the output:

     Martin, you Camper!

   The process_file() function returns a string containing the processed
file or block output.  On error, a warning is generated (see `USING THE
METATEXT MODULE' in this node) and undef is returned.

     my $output = $mt->process_file("myfile");
     print $output if defined $output;

   The process_text() method is identical to process_file() except that the
first parameter should represent a text string to be processed rather than
the name of a file.  All other parameters, behaviour and return values are
the same as for process_file().

     my $text   = "%% INCLUDE header %% test! %% INCLUDE footer %%";
     my $output = $mt->process_text($text);
     print $output if defined $output;

METATEXT DIRECTIVES
===================

   A MetaText directive is a block of text in a file that is enclosed by
the MAGIC identifiers (by default '%%').  A directive may span multiple
lines and may include blank lines within in.  Whitespace within a
directive is generally ignored except where quoted as part of a specific
value.

     %% DEFINE
        name    = Yorick
        age     = 30
        comment = "A fellow of infinite jest"
     %%

   The first word of the directive indicates the directive type.
Directives may be specified in upper, lower or mixed case, irrespective of
the CASE sensitivity flag (which affects only variable names).  The general
convention is to specify the directive type in UPPER CASE to aid clarity.

   The MetaText directives are:

DEFINE
     Define the values for one or more variables

SUBST
     Substitute the value of a named variable

INCLUDE
     Process and include the contents of the named file or block

BLOCK
     Define a named block which can be subsequently INCLUDE'd

ENDBLOCK
     Marks the end of a BLOCK definition

   To improve clarity and reduce excessive, unnecessary and altogether
undesirable verbosity, a directive block that doesn't start with a
recognised MetaText directive is assumed to be a 'SUBST' variable
substitution.  Thus,

     %% SUBST foo %%

   can be written more succinctly as

     %% foo %%

   When MetaText processes directives, it is effectively performing a
"search and replace".  The MetaText directive block is replaced with
whatever text is appropriate for the directive specified.  Generally
speaking, MetaText does not alter any text content or formatting outside of
directive blocks.  The only exception to this rule is when CHOMP is turned
on (see `USING THE METATEXT MODULE' in this node) and newlines immediately
following a directive are subsequently deleted.

DEFINE
------

   The DEFINE directive allows simple variables to be assigned values.
Multiple variables may be defined in a single DEFINE directive.

     %% DEFINE
        name  = Caliban
        quote = "that, when I waked, I cried to dream again."
     %%

   It is also possible to use other variable values to DEFINE new
variables.  Use the '$' prefix to indicate a variable rather than an
absolute value.  If necessary, surround the variable name with braces '{'
'}' to separate it from any surrounding text.

     %% DEFINE
        server = www.kfs.org
        home   = /~abw/
     %%

     %% DEFINE
        homepage = http://$server${home}index.html
     %%

   In the above example, the 'homepage' variable adopts the value
'http://www.kfs.org/~abw/index.html' which is constructed from the text
string 'http://' and 'index.html' and the values for $server and $home.
Notice how the 'home' variable is enclosed in braces.  Without these, the
homepage variable would not be constructed correctly, looking instead for
a variable called 'homeindex.html'

     %% DEFINE
        homepage = http://$server$homeindex.html   ## WRONG!
     %%

   See `  ' in this node below for further information.

   Variables defined within a file or passed to the process_file() or
process_text() functions as a hash array remain defined until the file or
block is processed in entirety.  Variable values will be inherited by any
nested files or blocks INCLUDE'd into the file.  Re-definitions of
existing variables will persist within the file or block, masking any
existing values, until the end of the file or block when the previous
values will be restored.

   The following example illustrates this:

     foo:
         Hello %% name %%              # name assumes any predefined value
         %% DEFINE name=tom %%
     	Hello %% name %%              # name = 'tom'
         %% INCLUDE bar name='dick' %% # name = 'dick' for "INCLUDE bar"
     	Hello %% name %%              # name = 'tom'

     bar:
     	Hello %% name %%              # name = 'dick'
         %% DEFINE name='harry' %%     # name = 'harry'
         Hello %% name %%

   Processing the file 'foo' as follows:

     print $mt->process_file('foo', { 'name' => 'nobody' });

   produces the following output (with explanatory comments added for
clarity):

     Hello nobody                      # value from process() hash
     Hello tom                         # from foo
     Hello dick                        # from bar
     Hello harry                       # re-defined in bar
     Hello tom                         # restored to previous value in foo

SUBST
-----

   A SUBST directive performs a simple variable substitution.  If the
variable is defined, its value will be inserted in place of the directive.

   Example:

     %% DEFINE place = World %%
     Hello %% SUBST place %%!

   generates the following output:

     Hello World!

   The SUBST keyword can be omitted for brevity.  Thus "%% place %%" is
processed identically to "%% SUBST place %%".

   If the variable is undefined, the MetaText processor will, according to
the value of the EXECUTE configuration value, try to execute a class
method or a function in the main package with the same name as the SUBST
variable.  If EXECUTE is set to any true value, the processor will try to
make a corresponding method call for the current object (that is, the
current instantiation of the MetaText or derived class).  If no such
method exists and EXECUTE is set to any value greater than 1, the
processor will then try to execute a function in the main package with the
same name as the SUBST variable  In either case, the text returned from
the method or function is included into the current block in place of the
SUBST directive (non-text values are automatically coerced to text
strings).  If neither a variable, method or function exists, the SUBST
directive will either be deleted or left intact (and additionally, a
warning may be issued), depending on the value of the ROGUE configuration
item.

   See EXTENDING METATEXT below for more information on deriving MetaText
classes and using EXECUTE to extend the meta-language.

   The "format" and "filter" options as described in the INCLUDE section
below are applied to the processed SUBST result before being inserted back
into the document.

   Some MetaText variables have a special meaning.  Unless specifically
defined otherwise, the variable(s) listed below generate the following
output:

     TIME    The current system time in seconds since the epoch,
             00:00:00 Jan 1 1970.  Use the "format" option to
             specify a time/date format.

INCLUDE
-------

   The INCLUDE directive instructs MetaText to load and process the
contents of the file or block specified.  If the target is a file, it
should reside in the current directory or a directory specified in the LIB
configuration variable.  Alternatively, the target may be a text block
specified with BLOCK..ENDBLOCK directives (see below).

     %% INCLUDE chapter1 %%

   The target may also be a variable name and should be prefixed with a
'$' to identify it as such.  On evaluation, the value of the named
variable will be used as the target:

   Example:

     %% DEFINE chapter=ch1 %%
     %% INCLUDE $chapter   %%
     
     is equivalent to:

     %% INCLUDE ch1 %%

   Additional variables may be defined for substitution within the file:

     %% INCLUDE chapter2 bgcolor=#ffffff title="Chapter 2" %%

   The contents of the file "chapter2":

     <html><head><title>%%title%%</title></head>
     <body bgcolor="%% bgcolor %%">
       ...
     </body>

   would produce the output:

     <html><head><title>Chapter 2</title></head>
     <body bgcolor="#ffffff">
       ...
     </body>

   Defining variables in this way is equivalent to using the DEFINE
directive.  Variables remain in scope for the lifetime of the file being
processed and then revert to any previously defined values (or undefined).
Any additional files processed via further INCLUDE directives within the
file will also inherit any defined variable values.

   Example:

     %% INCLUDE file1 name="World" %%

   for the files:

     file1:                   # name => "World" from INCLUDE directive
         %% INCLUDE file2 %%
     
     file2:                   # inherits "name" variable from file1
         %% INCLUDE file3 %%

     file3:                   # inherits "name" variable from file2
         Hello %% name %%

   produces the output:

     Hello World

   The output generated by INCLUDE and SUBST directives can be formatted
using a printf-like template.  The format string should be specified as a
"format" option in the INCLUDE or SUBST directive.  Each line of the
included text is formatted and concatentated to create the final output.
Within the format string, '%s' is used to represent the text.

   For example, the 'author' element below could be used to display details
of the author of the current document.

     author:
         File:   %% file %%
         Author: %% name %%
     	Date:   %% date %%

   For inclusion in an HTML document, the text can be encapsulated in HTML
comment tags ("<!-" and "->") using a format string:

     %% INCLUDE author
        file   = index.html
        name   = "Andy Wardley"
        date   = 19-Mar-1987
        format = "<!-- %-12s -->"
     %%

   Which produces the following output:

     <!-- File:   index.html   -->
     <!-- Author: Andy Wardley -->
     <!-- Date:   19-Mar-1987  -->

   Note that the print format is applied to each line of the included
text.  To encapsulate the element as a whole, simply apply the formatting
outside of the INCLUDE directive:

     <!--
        %% INCLUDE author
        ...
        %%
     -->

   In these examples, the formatting is applied as if the replacement
value/line is a character string.  Any of the standard printf(3) format
tokens can be used to coerce the value into a specific type.

   There are a number of pre-defined format types:

     dquoted      # encloses each line in double quotes: "like this"
     squoted      # encloses each line in single quotes: 'like this'
     quoted       # same as "dquoted"

   Examples:

     %% some_quote format=quoted %%

   As mentioned in the SUBST section above, the TIME variable is used to
represent the current system time in seconds since the epoch (see time(2)).
The "format" option can also be employed to represent such values in a more
user-friendly format.  Any format string that does not contain a '%s'
token is assumed to be a time-based value and is formatted using the
time2str() function from the Date::Format module (distributed as part of
the TimeDate package).

   Example:

     The date is %% TIME format="%d-%b-%y" %%

   Generates:

     The date is 19-Mar-98

   See `perldoc Date::Format' for information on the formatting characters
available.

   The pragmatic token '%P' can be added to a format to override this
behaviour and force the use of printf().  The '%P' token is otherwise
ignored.

   Example:

     %% DEFINE foo=123456789  %%
     %% foo format="%d-%b-%y" %%  # "day-month-year" using time2str
     %% foo format="%d"       %%  # "day" using timestr
     %% foo format="%P%d"     %%  # decimal value using printf
     %% foo format="%s"       %%  # string value using printf
     
     Generates:

     29-Nov-73
     29
     123456789
     123456789

   Text that is inserted with an INCLUDE or SUBST directive can also be
filtered.  There are two default filters provided, 'escape' which can be
used to escape (prefix with a backslash '\') certain characters, and 'sr'
which is used to perform simple search and replace actions.  Other filters
may be added with the FILTER option when creating the object (see the
FILTER section in `USING THE METATEXT MODULE' in this node, above).

   Like the 'format' option, output filters work on a line of text at a
time.  Any parameters required for the filter can be specified in
parentheses after the filter name.  The 'escape' filter expects a
perl-style character class indicating the characters to escape.  The 'sr'
filter expects two parameters, a search pattern and a replacement string,
separated by a comma.  Note that parameters that include embedded spaces
should be quoted.  The quote characters themselves must also be escaped as
they already form part of a quoted string (the filter text).  (This way of
representing parameters is admittedly far from ideal and may be improved
in a future version.)

   Example:

     %% DEFINE text="Madam I'm Adam" %%
     %% SUBST  text filter="escape(['])"               %%
     %% SUBST  text filter="sr(Adam, \"Frank Bough\")" %%

   Generates:

     Madam I\'m Adam
     Madam I'm Frank Bough

   Conditional tests can be applied to INCLUDE blocks to determine if the
block should evaluated or ignored.  Variables and absolute values can be
used and can be evaluated in the following ways:

     a == b       # a is equal to b
     a != b       # a is not equal to b
     a >  b       # a is greater than b
     a <  b       # a is less than b
     a => b       # a is greater than or equal to b
     a <= b       # a is less than or equal to b
     a =~ b       # a matches the perl regex pattern b
     a !~ b       # a does not match the perl regex pattern b
     a in b,c,d   # a appears in the list b, c, d (see DELIMITER)

   The items on the right of the evaluations can be absolute values or
variable names which should be prefixed by a '$'.  The items on the left
of the evaluation are assumed to be variable names.  There is no need to
prefix these with a '$', but you can if you choose.

   The single equality, "a = b", is treated identically to a double
equality "a == b" although the two traditionally represent different
things (the first, an assignment, the second, a comparison).  In this
context, I consider the former usage confusing and would recommend use of
the latter at all times.

   Variables without any comparison operator or operand are tested for a
true/false value.

   Examples:

     %% INCLUDE foo if="name==fred"        %%
     %% INCLUDE foo if="$name==fred"       %%  # equivalent to above
     %% INCLUDE foo if="name==$goodguy"    %%
     %% INCLUDE foo if="hour > 10"         %%
     %% INCLUDE foo if="tonk =~ [Ss]pl?at" %%
     %% INCLUDE foo if="camper"            %%

   Multiple conditions can be joined using the following boolean operators

     a && b       # condition 'a' and 'b'
     a || b       # condition 'a' or  'b'
     a ^  b       # condition 'a' xor 'b'
     a and b      # same as "a && b" but with lower precedence
     a or  b      # same as "a || b" but with lower precedence
     a xor b      # same as "a ^  b" but with lower precedence

   Conditional equations are evaluated left to right and may include
parentheses to explicitly set precedence.

   Examples:

     %% INCLUDE tonk
        if="hardenuf && uid in abw,wrigley"
     %%
     %% INCLUDE tapestry
        if="(girly && studly < 1) || uid == neilb"
     %%
     %% INCLUDE tapestry
        if="($girly && $studly < 1) || $uid == neilb"
     %%

   Note that the third example above is identical in meaning to the second,
but explicitly prefixes variable names with '$'.  This is optional for
elements on the left hand side of comparison operators, but mandatory for
those on the right that might otherwise be interpreted as absolute values.

BLOCK..ENDBLOCK
---------------

   In some cases it is desirable to have a block of text available to be
inserted via INCLUDE without having to define it in an external file.  The
BLOCK..ENDBLOCK directives allow this.

   A BLOCK directive with a unique identifier marks the start of a block
definition.  The block continues, including any valid MetaText directives,
until an ENDBLOCK directive is found.

   A BLOCK..ENDBLOCK definition may appear anywhere in the file.  It is in
fact possible to INCLUDE the block before it has been defined as long as
the block definition resides in the same file.

   Processing of a file stops when it encounters an __END__ or __MTEND__
marker on a line by itself.  Blocks can be defined after this marker even
though the contents of the file after the marker are ignored by the
processor.

     # include a block defined later
     %% INCLUDE greeting name=Prospero %%

     __END__
     %% BLOCK greeting %%
     Hello %% name %%
     %% ENDBLOCK %%

   This produces the following output:

     # include a block defined later
     Hello Prospero

   Additional variable definitions specified in an INCLUDE directive will
be applied to blocks just as they would to external files.

   By default, BLOCK definitions are "trimmed".  That is, the leading and
trailing newlines (if present) in the block definition are deleted.  This
allows blocks to be defined:

     %% BLOCK example1 %%
     Like this!
     %% ENDBLOCK %%

   and not:

     %% BLOCK example2 %%Like this!%% ENDBLOCK %%

   This behaviour can be disabled by specifying a TRIM configuration
parameter with a zero value.  See the TRIM option, mentioned above.  A
"trim" or "trim=0" parameter can be added to a block to override the
behaviour for that BLOCK definition only.  e.g.

     %% BLOCK sig trim=0 %%
     --
     This is my .signature
     %% ENDBLOCK %%

   A BLOCK..ENDBLOCK definition that appears in the main part of a document
(i.e. before, or in the absence of an __END__ line) will not appear in the
processed output.  A simple "print" flag added to the BLOCK directive
overrides this behaviour, causing a copy of the BLOCK to appear in it's
place:

     %% DEFINE name=Caliban %%

     %% BLOCK greeting print %%
     Hello %% name %%
     %% ENDBLOCK %%

     %% INCLUDE greeting name="Prospero" %%

   produces the following output:

     Hello Caliban

     Hello Prospero

   Conditions ("if" and "unless") can be applied to BLOCK directives, but
they affect how and when the BLOCK itself is printed, rather than
determining if the block gets defined or not.  Conditionals have no effect
on BLOCK directives that do not include a "print" flag.

   It is possible to pre-declare blocks for subsequent inclusion by using
the public declare() method.  The first parameter should be a text string
containing the content of the block.  The second paramter is the block
name by which it should consequently be known.  The content string is
parsed and an internal block definition is stored.

   Example:

     $mt->declare("<title>%%title%%</title>", html_title);

   This can subsequently be used as if the block was defined in any other
way:

     %% INCLUDE html_title
        title = "My test page"
     %%

   It is also possible to pass an array reference to declare() as the
content parameter.  In this context, it is assumed that the array is a
pre-parsed list of text strings or Text::MetaText::Directive (or
derivative) references which should be installed as the block definition
for the named block.  This process assumes an understanding of the
MetaText directive structure and internal symbol table entries.  If you
don't know why you would want to do this, then the chances are that you
don't need to do it.  "Experts only" in other words.

VARIABLE INTERPOLATION
======================

   MetaText allows variable values to be interpolated into directive
operands and other variable values.  This is useful for style-sheet
processing and other applications where a particular view required can be
encoded in a variable and interpolated by the processor.

   By example, the file 'mousey.html':

     %% INCLUDE $style/header %%

     The cat sat on the mouse.

     %% INCLUDE $style/footer %%

   can be processed in the following ways to create customised output:

     $t1 = $mt->process_file('mousey.html', {'style' => 'text'});
     $t2 = $mt->process_file('mousey.html', {'style' => 'graphics'});

   Variable interpolation is also useful for building up complex variables
based on sub-elements:

     %% DEFINE root=/user/abw %%

     %% DEFINE
        docs   = $root/docs
        images = $root/images
     %%

   Note though, that there is no guaranteed order of definition for
multiple variables within a single DEFINE directive.  The following is
INCORRECT as there is no guarantee that 'base' will be defined before
'complex'.

     %% DEFINE
        base    = /here
        complex = $base/and/there    # WRONG! $base may not be defined yet
     %%

   In such circumstances, it is necessary to define variables in separate
directives.

     %% DEFINE base=/here %%
     %% DEFINE complex=$base/and/there %%

   Where necessary, variable names may be enclosed in braces to delimit
them from surrounding text:

     %% DEFINE
        homepage = http://$server${home}index.html
     %%

EXTENDING METATEXT
==================

   MetaText may be used as a base class for deriving other text processing
modules.  Any member function of a derived class can be called directly as
a MetaText directive.  See the EXECUTE configuration option for more
details.

   Pseudo-code example:

     package MyMetaText;
     @ISA = qw( Text::MetaText );

     # define a new derived class method, get_name()
     sub get_name {
         my $self   = shift;
         my $params = shift;

     # return name from an ID hash, for example
     	$self->{ PEOPLE }->{ $params->{'id'} } || 'nobody';
         }

     package main;

     # use the new derived class
     my $mmt = MyMetaText { EXECUTE => 1 };

     # process 'myfile'
     print $mmt->process('myfile');

   which, for a sample file, 'myfile':

     %% get_name id=foo %%
     %% get_name id=bar %%

   is equivalent to:

     print $mmt->get_name({ 'id' => 'foo' }), "\n";
     print $mmt->get_name({ 'id' => 'bar' }), "\n";

   Alternatively, a simple calling script can be written that defines
functions that themselves can be called from within a document:

     my $mt = Text::MetaText->new( { EXECUTE => 2 } );

     print $mt->process("myfile");

     sub get_name {
         my $params = shift;
         $global_people->{ $params->{'id'} } || 'nobody';
     }

WARNINGS AND ERRORS
===================

   The following list indicates warning or error messages that MetaText can
generate and their associated meanings.

"CASEVARS option expects an array reference"
     The configuration hash array passed to Text::MetaText->new() contained
     a CASEVARS entry that did not contain an array reference.  See `USING
     THE METATEXT MODULE' in this node.

"Closing directive tag missing in %s"
     A MetaText directive was found that was not terminated before the end
     of the file.  e.g. `%% INCLUDE something ...'  The processor attempts
     to compensate, but check your source files and add any missing MAGIC
     tokens.

"Directive constructor failed: %s"
     The MetaText parser detected a failed attempt to construct a Directive
     object.  This error should only happen in cases where a derived
     Directive class has been used (which should imply you know what you're
     doing and what the error means.  The specific Directive constructor
     error is appended to the error message.

"Invalid configuration parameter: %s"
     An invalid configuration parameter was identified in the hash array
     passed to Text::MetaText->new().  See `USING THE METATEXT MODULE' in
     this node.

"Invalid debug/error function"
     The debug or error handling routine specified for the ERROR or DEBUG
     configuration options was not a code reference.  See the ERROR and/or
     DEBUG sections for more details.

"Invalid debug option: %s"
     A token was specified for the DEBUGLEVEL configuration item which was
     invalid.  See the DEBUGLEVEL section for a complete list of valid
     tokens.

"Invalid factory object"
     A `FACTORY' configuration item was specified which did not contain a
     reference to a Text::MetaText::Factory object, or derivative.

"Invalid input reference passed to declare()"
     The declare() method was called and the first parameter was not a
     reference to an ARRAY or a text string.  These are (currently) the
     only two valid input types.

"Invalid rogue option: %s"
     A token was specified for the ROGUE configuration item which was
     invalid.  See the ROGUE section for a complete list of valid tokens.

"Maximum recursion exceeded"
     The processed file had multiple INCLUDE directives that nested to a
     depth greater than MAXDEPTH (default: 32).  Set MAXDEPTH higher to
     avoid this problem, or check your files for circular dependencies.

"Missing directive keyword"
     A MetaText directive was identified that had no keyword or other
     content.  e.g. `%%    %%'

"Parse error at %s line %s: %s"
     The pre-processor was unable to correctly parse a block or file.  The
     error message reports the file name and line number (or 'text string'
     in the case of parse_text()) and the specific error details.

"Text::MetaText->new expects a hash array reference"
     The new() method can accept a reference to a hash array as the first
     parameter which contains configuration variables and values.  This
     error is generated if the parameter is not a hash array reference.

"Unrecognise directive: %s"
     An internal error that should never happen.  The pre-processor has
     identified a directive type that the processor then failed to
     recognise.

"Unrecognised token: %s"
     A `%% SUBST <variable> %%' or `%% <variable> %%' directive was found
     for which there was no corresponding <variable> defined.  This
     warning is only generated when the 'warn' token is set for the ROGUE
     option.

"Unmatched parenthesis: %s"
     A conditional evaluation ("if" or "unless") for a directive is missing
     a closing parenthesis.  e.g. `%% INCLUDE foobar if="(foo && bar ||
     baz" %%'

"%s: non-existant or invalid filter"
     An INCLUDE or SUBST directive included a "filter" option that refers
     to a non-existant filter.  e.g. `%% INCLUDE foo filter=nosuchfilter()
     %%'

"%s: no such block defined"
     The _process($symbol) method could not process the named symbol
     because it was not defined in the symbol table.

AUTHOR
======

   Andy Wardley <abw@kfs.org>

   See also:

     http://www.kfs.org/~abw/

   My thanks extend to the people who have used and tested MetaText.  In
particular, the members of the Peritas Online team; Simon Matthews, Simon
Millns and Gareth Scott; who brutally tested the software over a period of
many months and provided valuable feedback, ideas and of course, bug
reports.  Deep respect is also due to the members of the SAS Team at Canon
Research Centre Europe Ltd; Tim "TimNix" O'Donoghue, Neil "NeilOS" Bowers,
Ave "AveSki" Wrigley, Martin "MarTeX" Portman, Channing "Chango" Walton and
Gareth "Gazola" Rees.  Don't go changing now...  :-)

   I welcome bug reports, enhancement suggestions, comments, criticisms
(hopefully constructive) and patches related to MetaText.  I would
appreciate hearing from you if you find MetaText particularly useful or
indeed if it *doesn't* do what you want, for whatever reason.  Hopefully
this will help me make MetaText help you more.

   It pains me to say that MetaText comes without guarantee or warranty of
suitability for any purpose whatsoever.  That doesn't mean it doesn't do
anything good, but just that I don't want some scrupulous old git to sue me
because they thought I implied it did something it doesn't.  *<sigh>*

   Text::MetaText is based on a template processing language I developed
while working at Peritas Ltd.  I am indebted to Peritas for allowing me to
use this work as the basis for MetaText and to release it to the public
domain.  I am also pleased to note that Canon Research Centre Europe
supports the Perl community and the Free Software ideology in general.

REVISION
========

   $Revision: 0.22 $

COPYRIGHT
=========

   Copyright (c) 1996-1998 Andy Wardley.  All Rights Reserved.

   This program is free software; you can redistribute it and/or modify it
under the terms of the Perl Artistic License.

SEE ALSO
========

   For more information, see the accompanying documentation and support
files:

     README    Text based version of this module documentation.
     Changes   Somewhat verbose list of per-version changes.
     Todo      Known bugs and possible future enhancements.
     Features  A summary of MetaText features and brief comparison to
               other perl 'template' modules.

   For information about the *metapage* utility, consult the specific
documentation:

     perldoc metapage
       or
     man metapage
     
     For more information about the author and other Perl development work:

     http://www.kfs.org/~abw/
     http://www.kfs.org/~abw/perl/
     http://www.cre.canon.co.uk/perl/

   For more information about Perl in general:

     http://www.perl.com/


