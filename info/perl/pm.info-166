This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Graphics/Plotter,  Next: Graphics/Simple,  Prev: Graphics/Libplot,  Up: Module List

Perl extension for C++ plotter library from GNU plotutils
*********************************************************

NAME
====

   Graphics::Plotter - Perl extension for C++ plotter library from GNU
plotutils

SYNOPSIS
========

     use Graphics::Plotter::<Type>;
     use Graphics::Plotter::<Type> qw(parampl);
     use Graphics::Plotter::<Type> qw(:marker_symbols :op_codes);
     use Graphics::Plotter::<Type> qw(:all);

EXAMPLE
=======

     $handle = Graphics::Plotter::X->new(STDIN,STDOUT,STDERR);

     if ($handle->openpl() < 0) {
     	die "Could not create plotter: $!\n";
     }

     $handle->fspace(0,0,1000,1000);
     $handle->flinewidth(0.25);
     $handle->pencolorname("red");
     $handle->erase();
     $handle->fmove(600,300);
     $handle->line(0,20,40 80);
     if ($handle->closepl() < 0) { die "closepl: $!\n";}

DESCRIPTION
===========

   Graphics::Plotter module is the Perl implementation of the GNU
plotutils' libplotter library - C++ function library for
device-independent two-dimensional vector graphics.  There is also libplot
library, based on C code, but with C++ library you do not need to switch
between plotters.

   The plotutils distribution is written by         Robert Maier
<rsm@math.arizona.edu>
(http://www.gnu.org/software/plotutils/plotutils.html).  Descriptions of
functions are based on Chapter 8 of plotutils info documentation.

   The latest version of Graphics::Plotter perl module is available at
   http://w3.man.torun.pl/~makler/prog/Plotter/

   The perl program can produce output in one of the following formats:

     X - new window on an X Window System display
     Xdrawable - existed X window or pixmap
     PNM - This is "portable anymap" format (PBM, PGM and PPM)
     GIF - Pseudo GIF (GIF format without LZW compression)
     AI - Adobe Illustrator (parameter ai)
     PS - idraw-editable Postscript (ps)
     Fig - xfig-editable format (fig)
     PCL - HP Printer Control Language format (pcl)
     HPGL - HP Graphics Language (hpgl)
     Tek - understood by Tektronix 4014 terminals (tek)
     Metafile - device-independent GNU graphics format (meta)

   To open a plotter you have to create a plotter object, e.g.:

FUNCTION SUMMARY
================

   This summary is BASED on plotutils info documentation. See plotutils
WWW page for more complete, more current, and more accurate description.
This summary is for the orientation only, and should be enough is you do
not ancounter any problem, and not using specific driver functions.

Construction/Destruction of Plotters
------------------------------------

new ()
new (outfile)
new (infile,outfile,errfile)
     creates a Plotter. You can select output, input and error filehandles
     for that Plotter. It returns the handle which is necessary for
     manipulating the Plotter. E.g.

          $object = Graphics::Plotter::X->new();
          # or even
          $disp_type = 'Meta'; # or 'X', 'AI', 'PS', etc.
          $plotter = "Graphics::Plotter" . $disp_type;
          $object = $plotter->new(STDIN, STDOUT, STDERR);

     The default output is STDOUT.  All the commands should be passed to
     the previously created plotter object, e.g. $object->function().

     First command should be openpl(), which opens a plotter.  Program
     should close that plotter with the command closepl().  If plotter is
     opened then you can manipulate plotter, e.g. drawing lines, cirles,
     changing colors etc.

openpl ()
     opens a plotter, i.e., begins a page of graphics. This resets the
     Plotter's drawing attributes to their default values. A negative
     return value indicates the Plotter could not be opened.

closepl ()
     closepl closes a Plotter, i.e., ends a page of graphics. A negative
     return value indicates the Plotter could not be closed.

flushpl ()
     flushes all plotting commands to the display device.

havecap (s)
     havecap tests whether or not a Plotter, which need not be open, has a
     specified capability. The return value is 0, 1, or 2, signifying
     no/yes/maybe.  For unrecognized capabilities the return value is zero.

parampl (parameter,value)
     Sets the value of the device driver parameter to value. E.g.

     parampl("BG_COLOR", "blue");

     sets the background color.

erase ()
     begins the next frame of a multiframe page, by clearing all previously
     plotted objects from the graphics display, and filling it with the
     background color (if any).

bgcolor (red, green, blue)
     bgcolor sets the background color for the Plotter's graphics display,
     using a 48-bit RGB color model. The arguments red, green and blue
     specify the red, green and blue intensities of the background color.
     Each is an integer in the range 0x0000...0xffff, i.e., 0...65535.

bgcolorname (name)
     bgcolorname sets the background color for the graphics display to be
     name.  unrecognized colors are interpreted as "white". bgcolorname
     and bgcolor has an effect only on X Plotters and X Drawable Plotters.

space (x0,y0,x1,y1) =item fspace (x0, y0, x1, y1)
     take two pairs of arguments, specifying the positions of the lower
     left corner and upper right corner of the graphics display, in user
     coordinates.  One of these operations must be performed at the
     beginning of each page of graphics, i.e., immediately after openpl is
     invoked.

space2 (x0,y0,x1,y1) =item fspace2 (x0, y0, x1, y1, x2, y2)
     space2 and fspace2 are extended versions of space and fspace, and may
     be used instead. Their arguments are the three defining vertices of
     an `Affine window' (a drawing parallelogram), in user coordinates.
     The specified vertices are the lower left, the lower right, and the
     upper left. This window will be mapped affinely onto the graphics
     display.

warning_handler (SUBPTR)
     warning_handler sets the default handler for warning messages (e.g.
     if there are some strange characters in label() function argument).
     SUBPTR means a pointer to subroutine. The warning message is available
     in @_ array variable. By default warning messages are displayed to
     the errfile filehandle specified in new() function, as "libplot:
     message". Example of use:

     warning_handler( sub { print "WARNING: $[$[]\n" } );

error_handler (SUBPTR)
     error_handler sets the default handler for error messages. SUBPTR
     means a pointer to subroutine. The error message is available in @_
     array variable.  By default error messages are displayed to the
     errfile filehandle specified in new() function, as "libplot: error:
     message".  Example of use:

     error_handler( \&print_error );

Drawing functions
-----------------

   The following are the "drawing functions". When invoked on a Plotter,
these functions cause it to draw objects (paths, circles, ellipses,
points, markers, and text strings) on the associated graphics display. A
path is a sequence of line segments and arcs (either circular or
elliptic). Paths may be drawn incrementally, one line segment or arc at a
time.

alabel (x_justify, y_justify, s)
     Draws a justified text string (s). x_justify could be "l", "c" or "r"
     (left, center and right justification. y_justify could be "b", "x",
     "c" or "t" (bottom, baseline, center and top of the string will be
     placed even with the current graphics cursor position.

arc (xc,yc,x0,y0,x1,y1)
farc (xc, yc, x0, y0, x1, y1)
farcrel (dxc, dyc, dx0, dy0, dx1, dy1)
     arc and farc take six arguments specifying the beginning (x0, y0),
     end (x1, y1), and center (xc, yc) of a circular arc. arcrel and
     farcrel use cursor-relative coordinates.

bezier2 (x0, y0, x1, y1, x2, y2);

fbezier2 (double x0, double y0, double x1, double y1, double x2, double y2);

bezier2rel (x0, y0, x1, y1, x2, y2);

fbezier2rel (double x0, double y0, double x1, double y1, double x2, double y2);
     bezier2 and fbezier2 take six arguments specifying the beginning
     p0=(x0, y0) and end p2=(x2, y2) of a quadratic Bezier curve, and its
     intermediate control point p1=(x1, y1). The graphics cursor is moved
     to p2. bezier2rel and fbezier2rel are similar to bezier2 and
     fbezier2, but use cursor-relative coordinates. The quadratic Bezier
     curve is tangent at p0 to the line segment joining p0 to p1, and is
     tangent at p2 to the line segment joining p1 to p2. So it fits snugly
     into a triangle with vertices p0, p1, and p2.

bezier3 (x0, y0, x1, y1, x2, y2, x3, y3);

fbezier3 (x0, y0, x1, y1, x2, y2, x3, y3);

bezier3rel (x0, y0, x1, y1, x2, y2, x3, y3);

fbezier3rel (x0, y0, x1, y1, x2, y2, x3, y3);
     bezier3 and fbezier3 take eight arguments specifying the beginning
     p0=(x0, y0) and end p3=(x3, y3) of a cubic Bezier curve, and its
     intermediate control points p1=(x1, y1) and p2=(x2, y2). The graphics
     cursor is moved to p3. bezier3rel and fbezier3rel are similar to
     bezier3 and fbezier3, but use cursor-relative coordinates. The cubic
     Bezier curve is tangent at p0 to the line segment joining p0 to p1,
     and is tangent at p3 to the line segment joining p2 to p3. So it fits
     snugly into a quadrangle with vertices p0, p1, p2, and p3.

box (x0,y0,x1,y1)
boxrel (dx0, dy0, dx1, dy1)
fbox (x0, y0, x1, y1)
fboxrel (dx0, dy0, dx1, dy1)
     box and fbox take four arguments specifying the lower left corner
     (x1, y1) and upper right corner (x2, y2) of a `box', or rectangle.
     boxrel and fboxrel use cursor-relative coordinates.

circle (x,y,r)
circlerel (dx, dy, r)
fcircle (x, y, r)
fcirclerel (dx, dy, r)
     circle and fcircle take three arguments specifying the center (xc,
     yc) and radius (r) of a circle. circlerel and fcirclerel use
     cursor-relative coordinates for xc and yc.

cont (x,y)
contrel (x, y)
fcont (x, y)
fcontrel (x, y)
     cont and fcont take two arguments specifying the coordinates (x, y)
     of a point. If a path is under construction, the line segment from
     the current graphics cursor position to the point (x, y) is added to
     it. Otherwise the line segment begins a new path. In all cases the
     graphics cursor is moved to (x, y). contrel and fcontrel use
     cursor-relative coordinates.

ellarc (xc, yc, x0, y0, x1, y1)
ellarcrel (dxc, dyc, dx0, dy0, dx1, dy1)
fellarc (xc, yc, x0, y0, x1, y1)
fellarcrel (dxc, dyc, dx0, dy0, dx1, dy1)
     ellarc and fellarc take six arguments specifying the three points
     pc=(xc,yc), p0=(x0,y0), and p1=(x1,y1) that define a so-called
     quarter ellipse. This is an elliptic arc from p0 to p1 with center
     pc. The quarter-ellipse is an affinely transformed version of a
     quarter circle.

ellipse (x, y, rx, ry, angle)
ellipserel (dx, dy, rx, ry, angle)
fellipse (x, y, rx, ry, angle)
fellipserel (dx, dy, rx, ry, angle)
     ellipse and fellipse take five arguments specifying the center (xc,
     yc) of an ellipse, the lengths of its semiaxes (rx and ry), and the
     inclination of the first semiaxis in the counterclockwise direction
     from the  @math{x axis} in the user coordinate system. ellipserel and
     fellipserel use cursor-relative coordinates.

endpath ()
     endpath terminates the path under construction, if any. Paths, which
     are formed by repeated calls to cont or fcont, arc or farc, ellarc or
     fellarc, and line or fline, are also terminated if any other object
     is drawn or any path-related drawing attribute is set. So endpath is
     almost redundant. However, if a Plotter plots objects in real time,
     calling endpath will ensure that a constructed path is drawn on the
     graphics display without delay.

label (s)
     label takes a single text argument s and draws a string at the current
     graphics cursor position with left justification. Graphics cursor is
     moved to the right end of the string. This function is equivalent to
     alabel(`l',`x',s).

labelwidth (s)
flabelwidth (s)
     return the width of a string in the current font, in the user
     coordinate system. The string is not plotted.

line (x0,y0,x1,y1)
linerel (dx0, dy0, dx1, dy1)
fline (x0, y0, x1, y1)
flinerel (dx0, dy0, dx1, dy1)
     line and fline take four arguments specifying the start point (x1,
     y1) and end point (x2, y2) of a line segment. linerel and flinerel
     use cursor-relative coordinates.

marker (x, y, type, size)
markerrel (dx, dy, type, size)
fmarker (x, y, type, size)
fmarkerrel (dx, dy, type, size)
     marker and fmarker take four arguments specifying the location (x,y)
     of a marker symbol, its type, and its size in user coordinates.
     markerrel and fmarkerrel use cursor-relative coordinates for the
     position (x,y).  Marker symbol types 0 through 31 are taken from a
     standard set, and marker symbol types 32 and above are interpreted as
     the index of a character in the current text font. See plotutils
     documentation for more information.

move (x,y)
moverel (x, y)
fmove (x, y)
fmoverel (x, y)
     move and fmove take two arguments specifying the coordinates (x, y)
     of a point to which the graphics cursor should be moved without
     drawing any line.  moverel and fmoverel use cursor-relative
     coordinates.

point (x,y)
pointrel (dx, dy)
fpoint (x, y)
fpointrel (dx, dy)
     point and fpoint take two arguments specifying the coordinates (x, y)
     of a point. The graphics cursor is moved to (x, y). pointrel and
     fpointrel use cursor-relative coordinates.

Attribute-setting functions
---------------------------

   The following are the "attribute functions". When invoked on a Plotter,
these functions set its drawing attributes, or save them or restore them.
Path-related attributes include pen color, fill color, line width, line
style, cap style, and join style. Text-related attributes include pen
color, font name, font size, and text angle.

capmod (s)
     capmod sets the cap mode (i.e., cap style) for all paths subsequently
     drawn on the graphics display. Recognized styles are "butt" (the
     default), "round", and "projecting".

color (red, green, blue)
     calling color is equivalent to calling both pencolor and fillcolor,
     to set both the the pen color and fill color of all objects
     subsequently drawn on the graphics display. Note that the physical
     fill color depends also on the fill fraction, which is specified by
     calling filltype.

colorname (name)
     calling colorname is equivalent to calling both pencolorname and
     fillcolorname, to set both the the pen color and fill color of all
     objects subsequently drawn on the graphics display.

filltype (level)
     filltype sets the fill fraction for all subsequently drawn objects. A
     value of 0 for level indicates that objects should be unfilled, or
     transparent. This is the default. A value in the range
     0x0001...0xffff, i.e., 1...65535, indicates that objects should be
     filled. A value of 1 signifies 100% filling (the fill color will
     simply be the color specified by calling fillcolor or fillcolorname).
     If level=0xffff, the fill color will be white. Values between 0x0001
     and 0xffff are interpreted as specifying a desaturation, or gray
     level.  For example, 0x8000 specifies 50% filling.

fillcolor (red, green, blue)
     fillcolor sets the fill color of all objects subsequently drawn on the
     graphics display, using a 48-bit RGB color model.

fillcolorname (name)
     fillcolorname sets the fill color of all objects subsequently drawn
     on the graphics display to be name.

fillmod (s)
     fillmod sets the fill mode, i.e., fill rule, for all objects
     subsequently drawn on the graphics display.  The fill rule affects
     only filled, self-intersecting paths: it determines which points are
     `inside'.  Two rules are supported: "even-odd" (the default for all
     Plotters), and "nonzero-winding". "alternate" is an alias for
     "even-odd" and "winding" is an alias for "nonzero-winding".

fmiterlimit (limit)
     fmiterlimit sets the miter limit for all paths subsequently drawn on
     the graphics display.  The miter limit controls the treatment of
     corners, if the join mode is set to "miter" (the default).  At a join
     point of a path, the `miter length' is defined to be the distance
     between the inner corner and the outer corner.  The miter limit is the
     maximum value that will be tolerated for the miter length divided by
     the line thickness.  If this value is exceeded, the miter will be cut
     off: the "bevel" join mode will be used instead.

     Examples of typical values for limit are 10.43 (the default, which
     cuts off miters if the join angle is less than 11 degrees), 2.0 (the
     same, for 60 degrees), and 1.414 (the same, for 90 degrees).  In
     general, the miter limit is the cosecant of one-half the minimum angle
     for mitered joins.  The minimum meaningful value for limit is 1.0,
     which converts all mitered joins to beveled joins, irrespective of
     join angle.  Specifying a value less than 1.0 resets the limit to the
     default.

fontname (s)
ffontname (s)
     fontname and ffontname take a single case-insensitive string argument,
     font_name, specifying the name of the font to be used for all text
     strings subsequently drawn on the graphics display. (The font for
     plotting strings is fully specified by calling fontname, fontsize,
     and textangle.) The size of the font in user coordinates is returned.

fontsize (size)
ffontsize (size)
     fontsize and ffontsize take a single argument, interpreted as the
     size, in the user coordinate system, of the font to be used for all
     text strings subsequently drawn on the graphics display. The size of
     the font in user coordinates is returned. A negative value for size
     sets the size to a default value, which depends on the type of
     Plotter.

joinmod (s)
     joinmod sets the join mode (i.e., join style) for all paths
     subsequently drawn on the graphics display. Recognized styles are
     "miter" (the default), "round", and "bevel".

linedash (\@dashes, offset)
flinedash (\@dashes, offset)
     linedash and flinedash set the line style for all paths, circles, and
     ellipses subsequently drawn on the graphics display.  They provide
     much finer control of dash patterns than the linemod function (see
     below) provides. dashes should be an array of length n.  Its
     elements, which should be positive, are interpreted as distances in
     the user coordinate system.  Along any path, circle, or ellipse, the
     elements dashes[0]...dashes[n-1] alternately specify the length of a
     dash and the length of a gap between dashes.  When the end of the
     array is reached, the reading of the array wraps around to the
     beginning.  If the array is empty, i.e., n equals zero, there is no
     dashing: the drawn line is solid.

     The offset argument specifies the `phase' of the dash pattern
     relative to the start of the path.  It is interpreted as the distance
     into the dash pattern at which the dashing should begin.  For example,
     if offset equals zero then the path will begin with a dash, of length
     dashes[0] in user space.  If offset equals dashes[0] then the path
     will begin with a gap of length dashes[1], and so forth. offset is
     allowed to be negative. Example:

     flinedash([30, 4, 10, 3],0)

linemod (s)
     linemod sets the linemode (i.e., line style) for all paths, circles,
     and ellipses subsequently drawn on the graphics display. The
     supported linemodes are "disconnected", "solid", "dotted",
     "dotdashed", "shortdashed", and "longdashed". The final five
     correspond more or less to the following bit patterns:

          "solid"             --------------------------------
          "dotted"            - - - - - - - - - - - - - - - -
          "dotdashed"         -----------  -  -----------  -
          "shortdashed"       --------        --------
          "longdashed"        ------------    ------------

     Circles and ellipses that are drawn when the linemode is
     "disconnected" will be invisible. Disconnected paths, circles, and
     ellipses are not filled.

linewidth (size)
flinewidth (size)
     linewidth and flinewidth set the width, in the user coordinate
     system, of all paths, circles, and ellipses subsequently drawn on the
     graphics display. A negative value means that a default width should
     be used. The default and zero width depends on the type of Plotter.

pencolor (red, green, blue)
     pencolor sets the pen color of all objects subsequently drawn on the
     graphics display, using a 48-bit RGB color model.

pencolorname (name)
     pencolorname sets the pen color of all objects subsequently drawn on
     the graphics display to be name.

restorestate ()
     restorestate pops the current graphics context off the stack of
     drawing states. The graphics context consists largely of libplot's
     drawing attributes, which are set by the attribute functions
     documented in this section. A path under construction is regarded as
     part of the graphics context. For this reason, calling restorestate
     automatically calls endpath to terminate the path under construction.
     All graphics contexts on the stack are popped off when closepl is
     called, as if restorestate had been called repeatedly.

savestate ()
     savestate pushes the current graphics context onto the stack of
     drawing states. When a graphics context is returned to, the path
     under construction may be continued.

textangle (angle)
ftextangle (angle)
     textangle and ftextangle take one argument, which specifies the angle
     in degrees counterclockwise from the @math{x} (horizontal) axis in
     the user coordinate system, for text strings subsequently drawn on
     the graphics display. The default angle is zero. The size of the font
     for plotting strings, in user coordinates, is returned.

Mapping functions
-----------------

   The following are the "mapping functions". When invoked on a Plotter,
these functions affect the affine transformation it employs for mapping
from the user coordinate system to the device coordinate system. They may
be viewed as performing transformations of the user coordinate system.
Their names resemble those of the corresponding functions in the
Postscript language.

fconcat (m0, m1, m2, m3, tx, ty)
     Apply a Postscript-style transformation matrix, i.e., affine map, to
     the user coordinate system. That is, apply the linear transformation
     defined by the two-by-two matrix [m0 m1 m2 m3] to the user coordinate
     system, and also translate by tx units in the @math{x direction} and
     ty units in the  @w{@math{y} direction}, relative to the former user
     coordinate system. The three functions (frotate, fscale, ftranslate)
     are special cases of fconcat.

frotate (theta)
     Rotate the user coordinate system axes about their origin by theta
     degrees, with respect to their former orientation. The position of
     the user coordinate origin and the size of the @math{x} @w{and
     @math{y}} units remain unchanged.

fscale (sx, sy)
     Make the @math{x} and @math{y} units in the user coordinate system be
     the size of sx and sy units in the former user coordinate system. The
     position of the user coordinate origin and the orientation of the
     coordinate axes are unchanged.

ftranslate (tx, ty)
     Move the origin of the user coordinate system by tx units in the
     @math{x direction} and ty units in the @w{@math{y} direction},
     relative to the former user coordinate system. The size of the
     @math{x} and @w{@math{y} units} and the orientation of the coordinate
     axes are unchanged.

Device driver parameters
------------------------

   With the parampl function you can set the following device dependent
driver parameters:

DISPLAY
     (Default NULL.) The X Window System display on which the graphics
     display will be popped up, as an X window. This is relevant only to X
     Plotters.

BITMAPSIZE
     (Default "570x570".) The size of the graphics display in terms of
     pixels. This is relevant only to X Plotters. If this parameter is not
     set, its value will automatically be taken from the X resource
     Xplot.geometry.

PAGESIZE
     (Default "letter".) The size of the page on which the graphics
     display will be positioned. This is relevant only to Illustrator,
     Postscript, Fig, PCL, and HP-GL Plotters. "letter" means an 8.5in by
     11in page. Any ISO page size in the range "a0"..."a4" or ANSI page
     size in the range "a"..."e" may be specified ("letter" is an alias
     for "a" and "tabloid" is an alias for "b"). "legal", "ledger", and
     "b5" are recognized page sizes also.

AI_VERSION
     (Default "5".) Relevant only to Illustrator Plotters. Recognized
     values are "5" and "3". "5" means that the output should be in the
     format used by version 5 of Adobe Illustrator, which is recognized by
     all later versions.

BG_COLOR
     (Default "white".) The initial background color of the graphics
     display, when drawing each page of graphics. This is relevant to X
     Plotters and X Drawable Plotters, although for the latter, the
     background color shows up only if erase is invoked. The background
     color may be changed at any later time by invoking the bgcolor (or
     bgcolorname) and erase operations.

HPGL_ASSIGN_COLORS
     (Default "no".) Relevant only to HP-GL Plotters, and only if the
     value of HPGL_VERSION is "2". "no" means to draw with a fixed set of
     pens, specified by setting the HPGL_PENS parameter. "yes" means that
     pen colors will not restricted to the palette specified in HPGL_PENS:
     colors will be assigned to "logical pens" in the range #1...#31, as
     needed. Other than color LaserJet printers and DesignJet plotters,
     not many HP-GL/2 devices allow the assignment of colors to logical
     pens. So this parameter should be used with caution.

HPGL_OPAQUE_MODE
     (Default "yes".) Relevant only to HP-GL Plotters, and only if the
     value of HPGL_VERSION is "2". "yes" means that the HP-GL/2 output
     device should be switched into opaque mode, rather than transparent
     mode. This allows objects to be filled with opaque white and other
     opaque colors. It also allows the drawing of visible white lines,
     which by convention are drawn with pen #0.

HPGL_PENS
     (Default "1=black:2=red:3=green:4=yellow:5=blue:6=magenta:7=cyan" if
     the value of HPGL_VERSION is "1.5" or "2" and "1=black" if the value
     of HPGL_VERSION is "1". Relevant only to HP-GL Plotters. The set of
     available pens; the format should be self-explanatory. The color for
     any pen in the range #1...#31 may be specified. Pen #1 must always be
     present, though it need not be black. Any other pen in the range
     #1...#31 may be omitted.

HPGL_ROTATE
     (Default "0".) Relevant only to HP-GL Plotters. The angle, in
     degrees, by which the graphics display should be rotated on the page
     relative to the default orientation. Recognized values are "0", "90",
     "180", and "270"; "no" and "yes" are equivalent to "0" and "90"
     respectively. This parameter is provided to facilitate switching
     between portrait and landscape orientations.  "180" and "270" are
     supported only if HPGL_VERSION is "2".

HPGL_VERSION
     (Default "2".) Relevant only to HP-GL Plotters. "1" means that the
     output should be generic HP-GL, "1.5" means that the output should be
     suitable for the HP7550A graphics plotter and the HP758x, HP7595A and
     HP7596A drafting plotters (HP-GL with some HP-GL/2 extensions), and
     "2" means that the output should be modern HP-GL/2. If the version is
     "1" or "1.5" then the only available fonts will be vector fonts, and
     all paths will be drawn with a default width. Additionally, if the
     version is "1" then the filling of arbitrary paths will not be
     supported (circles and rectangles aligned with the coordinate axes
     may be filled).

HPGL_XOFFSET, HPGL_YOFFSET
     (Defaults "0.0cm" and "0.0cm".) Relevant only to HP-GL Plotters.
     Adjustments, in the @math{x and @math{y}} directions, of the position
     of the graphics display on the page. They may be specified in
     centimeters, millimeters, or inches. For example, an offset could be
     specified as "2cm" or "1.2in".

MAX_LINE_LENGTH
     (Default "500".) The maximum number of points that a path may
     contain, before it is flushed to the display device. If this flushing
     occurs, the path will be split into two or more sub-paths, though the
     splitting should not be noticeable. Splitting will not be performed
     if the path is filled. This parameter is relevant to X, X Drawable,
     Illustrator, Postscript, Fig, PCL, and HP-GL Plotters. The reason for
     splitting long paths is that some display devices (e.g., old
     Postscript printers and HP-GL plotters) have limited buffer sizes. It
     is not relevant to Tektronix or Metafile Plotters, since they draw
     paths in real time and have no buffer limitations.

META_PORTABLE
     (Default "no".) Relevant only to Metafile Plotters. "yes" means that
     the output should be in a portable (human-readable) version of the
     metafile format, rather than the default (binary) version.

PCL_ASSIGN_COLORS
     (Default "no".) Relevant only to PCL Plotters. "no" means to draw
     with a fixed set of pens. "yes" means that pen colors will not
     restricted to this palette: colors will be assigned to "logical
     pens", as needed. Other than color LaserJet printers, not many PCL 5
     devices allow the assignment of colors to logical pens. So this
     parameter should be used with caution.

PCL_ROTATE
     (Default "0".) Relevant only to PCL Plotters. See explonation for
     HPGL_ROTATE.

PCL_XOFFSET, PCL_YOFFSET
     (Defaults "0.0cm" and "0.0cm".) Relevant only to PCL Plotters. See
     explonation for HPGL_XOFFSET.

TERM
     (Default NULL.) Relevant only to Tektronix Plotters.

USE_DOUBLE_BUFFERING
     (Default "no".) Relevant only to X Plotters and X Drawable Plotters.
     If the value is "yes", each frame of graphics, within a
     openpl...closepl pair, is written to an off-screen buffer rather than
     to the Plotter's display. When erase is invoked to end a frame, or
     when closepl is invoked, the contents of the off-screen buffer are
     copied to the Plotter's display, pixel by pixel.  This double
     buffering scheme is useful in creating the illusion of smooth
     animation. The "fast" is an alias for "yes". If there are standard
     DBE and MBX extensions to the X11 protocol to communicate with the
     display is available then these extensions are used. It may yield
     much faster animation.

VANISH_ON_DELETE
     (Default "no".) Relevant only to X Plotters. If the value is "yes",
     when a Plotter is deleted, the window or windows that it has popped
     up will vanish.  Otherwise, each such window will remain on the
     screen until it is removed by the user (by typing `q' in it, or by
     clicking with a mouse).

XDRAWABLE_COLORMAP
     (Default NULL.) Relevant only to X Drawable Plotters. If the value is
     non-NULL, it should be a Colormap *, a pointer to a colormap from
     which colors should be allocated. NULL indicates that the colormap to
     be used should be the default colormap of the default screen of the X
     display.

XDRAWABLE_DISPLAY
     (Default NULL.) Relevant only to X Drawable Plotters. The value
     should be a Display *, a pointer to the X display with which the
     drawable(s) to be drawn in are associated.

XDRAWABLE_DRAWABLE1

XDRAWABLE_DRAWABLE2
     (Default NULL.) Relevant only to X Drawable Plotters. If set, the
     value of each of these parameters should be a Drawable *, a pointer
     to a drawable to be drawn in. A `drawable' is either a window or a
     pixmap. At the time an X Drawable Plotter is created, at least one of
     the two parameters must be set. X Drawable Plotters support
     simultaneous drawing in two drawables because it is often useful to
     be able to draw graphics simultaneously in both an X window and its
     background pixmap. If two drawables are specified, they must have the
     same dimensions and depth, and be associated with the same screen of
     the X display.

   For more information on device driver parameters, fonts, strings and
symbols, markers, color names, markers, metafile format see plotutils
documentation.

Exported constants and functions
================================

   You can export the following functions: parampl, warning_handler and
error_handler. parampl is a static function of the Plotter superclass.
warning_handler and error_handler sets the pointer to the error message
handler functions.

   You can import into the main namespace the op codes (for metafile
format) with the command: use Graphics::Plotter qw(:marker_symbols), and
the marker symbols, with the command: use Graphics::Plotter qw(:op_codes),
or both of them with the command: use Graphics::Plotter qw(:all).  See
plotutils documentation for the explanation how to use op codes and marker
symbols.

AUTHOR
======

   Piotr Klaban <makler@man.torun.pl>

SEE ALSO
========

   perl(1), plotutils documentation


File: pm.info,  Node: Graphics/Simple,  Next: Graphics/Simple/Fig,  Prev: Graphics/Plotter,  Up: Module List

a simple , device-independent graphics API for Perl
***************************************************

NAME
====

   Graphics::Simple - a simple , device-independent graphics API for Perl

SYNOPSIS
========

     use Graphics::Simple;

     line 100,100,200,200;
     circle 50,50,25;
     stop(); clear(); # Wait for a button press, clear the page

DESCRIPTION
===========

   Ever had a Commodore C-64 or Vic-20 or some other of the machines of
that era? Where doing graphics was as simple as

     line 20,20,50,30;

   and you didn't have to go through things like `XOpenDisplay' etc.

   This module tries to bring back the spirit of that era in a modern
environment: this module presents a simple, unified API to several
different graphics devices - currently X (using Gtk and Gnome) and
PostScript.

   The interface is primarily made easy-to-use, starting from the idea
that the above line command must work. Therefore, it exports most of the
primitives by default (you can turn this off).

   However, everything is not sacrificed in the name of simplicity:
believing in "simple things simple, complicated things possible", this
module also allows multiple windows (all the primitives also work as
methods of window objects) as well as raw access to the underlying devices
- although the device-independence is then lost.  In future plans are some
sort of interactions with the devices with which it is possible as well as
the addition of more devices.

   The use command currently accepts the forms

     use Graphics::Simple;
     use Graphics::Simple qw/line circle/;
     use Graphics::Simple 300,400; # portrait paper
     use Graphics::Simple 300,400, qw/line circle/;

   i.e. the optional size of the default window first and then normal
Exporter arguments.

   `Graphics::Simple' has several different back-ends, currently
GnomeCanvas, TkCanvas, PostScript and (not fully working yet) Fig.  Other
backends are expected.

   To start `Graphics::Simple' with a given backend, you should set the
environment variable `GSIMPL' to the value, e.g. by running your script
with the command

     GSIMPL='PostScript' perl gt1.pl

   or by setting the environment variable permanently in your shell, by

     GSIMPL=PostScript
     export GSIMPL

   or

     setenv GSIMPL PostScript

   depending on which shell you use.

line [$win_to], [$name], $x1, $y1, $x2, $y2, ...
------------------------------------------------

   Draws a line through the points given.

arrow [$win_to], [$name], $x1, $y1, $x2, $y2, ...
-------------------------------------------------

   Like line, but makes an arrowhead in the end.

line_to [$win], [$name], $x1, $y1, $x2, $y2, ...
------------------------------------------------

   Called several times in a sequence, starts and continues adding points
to a line. If called with no coordinates, finishes the current line. This
is just a convenient wrapper over a line call with all the parameters
given - a faster way would just be to collect your parameters to an array.

circle [$win], [$name], $x, $y, $radius
---------------------------------------

   Duh.

ellipse [$win], [$name], $x1, $y1, $x2, $y2
-------------------------------------------

   The ellipse enclosed in the rectangle given by its two corners

text [$win], [$name], $x, $y, $string
-------------------------------------

   Duh...

image [$win], [$name], $x, $y, $width, $height, $depth, $string
---------------------------------------------------------------

   This command creates a rectangular bit- or pixmap. The $depth parameter
is the number of bytes per pixel (1 for B/W or 3 for RGB) and the string
is a string of packed bytes that describe the image.

   For instance, the module PDL is a good source for such strings.

clear, stop
-----------

     stop [$win]
     clear [$win]

   clear removes all the drawn elements from the window. <wait> waits for
a button press. These are usually coupled:

     stop; clear;

set_window, get_window
----------------------

   See the source - undocumented and potentially changing api

push_window, pop_window
-----------------------

   `Graphics::Simple' maintains a simple window stack so that subroutines
can easily use

     push_window $win;
     line ...
     pop_window();

   to avoid having too many method calls.

color [$win,] $color;
---------------------

   Set the current color to $color. Currently, the colors known are

     red green blue black white

   as well as any RGB color with the X syntax:

     color '#FFFF00';

   is yellow. You can also give an array ref of three numbers between 0
and 1 for RGB colors.

linewidth [$win,] $width
------------------------

BUGS
====

   This is an alpha proof-of-principle version - the API may still change
wildly.

AUTHOR
======

   Copyright(C) Tuomas J. Lukka 1999. All rights reserved.  This software
may be distributed under the same conditions as Perl itself.


File: pm.info,  Node: Graphics/Simple/Fig,  Next: Graphics/Simple/GnomeCanvas,  Prev: Graphics/Simple,  Up: Module List

implement Graphics::Simple in Fig (e.g. xfig) files
***************************************************

NAME
====

   Graphics::Simple::Fig - implement Graphics::Simple in Fig (e.g. xfig)
files

SYNOPSIS
========

     use Graphics::Simple;
     # use those operations

DESCRIPTION
===========

   The module `Graphics::Simple::Fig' is an implementation of the
`Graphics::Simple' API.

DEVICE-DEPENDENT OPERATIONS
===========================

stop
----

   Waiting is implemented by writing the current image as a snapshot to a
file.  The problem is that this only applies to the one window - code that
has two windows will not show all the upgrades that GnomeCanvas shows.
This should be adressed somehow - the problem is that we don't want to
duplicate all the static images in other windows if only one is changing.

   The files are currently written into `/tmp/'.

BUGS
====

   Writes much too much code, e.g. by setting width and color for each
object.  Should check if it is already set and leave the old setting and
other such optimizations.

AUTHOR
======

   Copyright(C) Tuomas J. Lukka 1999. All rights reserved.  This software
may be distributed under the same conditions as Perl itself.


File: pm.info,  Node: Graphics/Simple/GnomeCanvas,  Next: Graphics/Simple/PDLPlot,  Prev: Graphics/Simple/Fig,  Up: Module List

implement Graphics::Simple using Gnome Canvas
*********************************************

NAME
====

   Graphics::Simple::GnomeCanvas - implement Graphics::Simple using Gnome
Canvas

SYNOPSIS
========

     use Graphics::Simple;
     # use those operations

DESCRIPTION
===========

   The module `Graphics::Simple::GnomeCanvas' is an implementation of the
`Graphics::Simple' API.

DEVICE-DEPENDENT OPERATIONS
===========================

stop
----

   Waiting is implemented by waiting for a button click in any of the
windows managed by this module.

AUTHOR
======

   Copyright(C) Tuomas J. Lukka 1999. All rights reserved.  This software
may be distributed under the same conditions as Perl itself.


File: pm.info,  Node: Graphics/Simple/PDLPlot,  Next: Graphics/Simple/PostScript,  Prev: Graphics/Simple/GnomeCanvas,  Up: Module List

Plot PDL data using Graphics::Simple
************************************

NAME
====

   Graphics::Simple::PDLPlot - Plot PDL data using Graphics::Simple

DESCRIPTION
===========

   Functions:

     line $pdl_y;
     line $pdl_x, $pdl_y;

   Methods:

     $g = Graphics::Simple::PDLPlot::Graph->new();

     $g->line($pdl_x, $pdl_y);
     $g->points($pdl_x, $pdl_y);
     $g->x_axis(1.0,2.0);
     $g->y_axis(0.1,1000,LOG);
     $g->plot($win);

BUGS
====

   This module is in the wrong place - it should be in the PDL distribution
and will be in the future.

   Wildly inefficient - there must be more synergy between this module and
the `Graphics::Simple' implementations for vectorization.

AUTHOR
======

   Copyright(C) Tuomas J. Lukka 1999. All rights reserved.  This software
may be distributed under the same conditions as Perl itself.


File: pm.info,  Node: Graphics/Simple/PostScript,  Next: Gtk,  Prev: Graphics/Simple/PDLPlot,  Up: Module List

implement Graphics::Simple in PostScript files
**********************************************

NAME
====

   Graphics::Simple::PostScript - implement Graphics::Simple in PostScript
files

SYNOPSIS
========

     use Graphics::Simple;
     # use those operations

DESCRIPTION
===========

   The module `Graphics::Simple::PostScript' is an implementation of the
`Graphics::Simple' API.

DEVICE-DEPENDENT OPERATIONS
===========================

stop
----

   Waiting is implemented by writing the current image as a snapshot to a
file.  The problem is that this only applies to the one window - code that
has two windows will not show all the upgrades that GnomeCanvas shows.
This should be adressed somehow - the problem is that we don't want to
duplicate all the static images in other windows if only one is changing.

   The files are currently written into `/tmp/'.

BUGS
====

   Writes much too much code, e.g. by setting width and color for each
object.  Should check if it is already set and leave the old setting and
other such optimizations.

AUTHOR
======

   Copyright(C) Tuomas J. Lukka 1999. All rights reserved.  This software
may be distributed under the same conditions as Perl itself.


File: pm.info,  Node: Gtk,  Next: Gtk/ColorSelectButton,  Prev: Graphics/Simple/PostScript,  Up: Module List

Perl module for the Gimp Toolkit library
****************************************

NAME
====

   Gtk - Perl module for the Gimp Toolkit library

SYNOPSIS
========

     use Gtk '-init';
     my $window = new Gtk::Window;
     my $button = new Gtk::Button("Quit");
     $button->signal_connect("clicked", sub {Gtk->main_quit});
     $window->add($button);
     $window->show_all;
     Gtk->main;
     
     =head1 DESCRIPTION

   The Gtk module allows Perl access to the Gtk+ graphical user interface
library. You can find more information about Gtk+ on http://www.gtk.org.
The Perl binding tries to follow the C interface as much as possible,
providing at the same time a fully object oriented interface and
Perl-style calling conventions.

AUTHOR
======

   Kenneth Albanowski, Paolo Molaro

SEE ALSO
========

   perl(1)


File: pm.info,  Node: Gtk/ColorSelectButton,  Next: Gtk/HandyCList,  Prev: Gtk,  Up: Module List

Choose a color
**************

NAME
====

   Gtk::ColorSelectButton - Choose a color

SYNOPSIS
========

     use Gtk;
         use Gtk::ColorSelectButton;
     
         ...
         init Gtk;
         init Gtk::ColorSelectButton;
         ...

     $color_button = Gtk::ColorSelectButton->new();
     $hbox->pack_start($color_button, 1,1,0);
     $color_button->show();

     ...
     print $color_button->color; #shortcut for ->get('color')
     ...
     $color_button->set( color => "10 40 250" ); # R G B

DESCRIPTION
===========

   Gtk::ColorSelectButton shows a button with a uniform color. Pressing
this buton pops up the color_selection dialog in which a new color may be
chosen. When the color selection dialog is closed, the chosen color is
reflected in the color of the button.

   The gtk variable color provides a way to access the chosen color.

AUTHOR
======

   Dov Grobgeld <dov@imagic.weizmann.ac.il>, with modifications by Kenneth
Albanowski <kjahds@kjahds.com>.

COPYRIGHT
=========

   Copyright (c) 1998 Dov Grobgeld. All rights reserved. This program may
be redistributed and copied under the same licence as Perl itself.


File: pm.info,  Node: Gtk/HandyCList,  Next: HP200LX/DB,  Prev: Gtk/ColorSelectButton,  Up: Module List

A more Perl-friendly Columned List
**********************************

NAME
====

   Gtk::HandyCList - A more Perl-friendly Columned List

SYNOPSIS
========

     use Gtk::HandyCList;
     my $vbox = new Gtk::VBox(0,5);
     my $scrolled_window = new Gtk::ScrolledWindow( undef, undef );
     $vbox->pack_start( $scrolled_window, 1, 1, 0 );
     $scrolled_window->set_policy( 'automatic', 'always' );

     my $list = Gtk::HandyCList->new( qw(Name Date Cost) );
     $list->data( [ "Foo", "29/05/78", 12.33],
                  [ "Bar", "01/01/74", 104.21],
                  # ...
                );
     $list->sizes( Name => 100, Date => "30%", Cost => "40%" );
     $list->sortfuncs( Name => "alpha", Date => \&date_sort, Cost => "number");

DESCRIPTION
===========

   This is a version of `Gtk::CList|Gtk::CList' in this node which takes
care of some common things for the programmer. For instance, it keeps
track of what's stored in the list, so you don't need to keep a separate
array; when the column titles are clicked, the list will be re-sorted
according to user-supplied functions or some default rules. It allows you
to reference columns by name, instead of by number.

METHODS
=======

new(@titles)
     This is equivalent to `< Gtk::CList-'new_with_titles >>, but
     initialises all the data structures required for HandyCList.

data(@data)
     A get-set method to retrieve and/or set the data in the table. The
     data is specified as an array of rows, and each row may either be an
     array reference or a hash reference. If a hash reference, the keys of
     the hash must correspond to the columns of the table.

     Example: You may either say this, using array references:

          my $list = Gtk::HandyCList->new( qw(Name Date Cost) );
          $list->data( [ "Foo", "29/05/78", 12.33],
                       [ "Bar", "01/01/74", 104.21] );

     or this, using hash references:

          my $list = Gtk::HandyCList->new( qw(Name Date Cost) );
          $list->data( { Name => "Foo", Date => "29/05/78", Cost => 12.33 },
                       { Name => "Bar", Date => "01/01/74", Cost =>104.21 } );

     The data will be returned as an array of hash references.

clear
     Remove all entries from the list.

append(@items)
     Append some items to the list; semantics of `@items' are the same as
     for the data method above.

prepend(@items)
     Append some items to the start of the list

sortfuncs(@functions | %functions )
     HandyCList automatically takes care of sorting the columns in the list
     for you when the user clicks on the column titles. To do this, though,
     you need to provide indication of how the data should be sorted. You
     may provide either a list or a hash (keyed to columns as before) of
     subroutine references or the strings "alpha" or "number" for
     alphabetic and numeric comparison respectively.

     Subroutine references here are not the same as you would hand to
     sort: they must take two arguments and compare them, instead of
     comparing the implicit variables `$a' and $b.

refresh
     Make sure that the data displayed in the list is the same as the data
     you'd get back from `< $list-'data >>. You probably won't need to
     call this, unless you're doing freaky things.

sizes(@columns | %columns)
     Set the size of each column as a number of pixels or as a percentage.
     At least one of the columns must be given as a number of pixels.
     Percentages should be strings like `"40%"', not floating point
     numbers.

selection
     Return data regarding what is currently selected.  The return value
     is a hashref, the keys being the (0-based) row numbers selected, the
     values being hashrefs themselves, from column name to column data.

hide (@columns)
     Prevent certain columns from being displayed.

unhide (@columns)
     Re-allow display of certain columns

AUTHOR
======

   Simon Cozens, simon@cpan.org

SEE ALSO
========

   `GNOME' in this node, `Gtk::CList' in this node


File: pm.info,  Node: HP200LX/DB,  Next: HPUX/Ioscan,  Prev: Gtk/HandyCList,  Up: Module List

Perl module to access HP-200 LX database files
**********************************************

NAME
====

   HP200LX::DB - Perl module to access HP-200 LX database files

SYNOPSIS
========

     use HP200LX::DB;

     interface functions:
       $db= HP200LX::DB::openDB ($fnm)     read database and return an DB object
       $db= HP200LX::DB::new ($fnm)        create database and return an DB object
       $db->saveDB ($fnm)                  save DB object as a (new) file

     array tie implementation to access database data records:
       tie (@dbd, HP200LX::DB, $db);       access database data in array form
       TIEARRAY                            stub to get an tie for the database
       FETCH                               retrieve a record
       STORE                               store a record

     additional data retrieval and storage methods:
       $db->FETCH_data_raw ($idx)          retrieve raw data record
       $db->FETCH_note_raw ($idx)          retrieve raw note record
       $db->STORE_data_raw ($idx, $data)   store raw data record
       $db->STORE_note_raw ($idx, $note)   store raw note record
       $db->get_last_index ()              return highest index

     additional UNIMPLEMENTED data manipulation methods:
       T2D: $db->DELETE ($num)             delete given data record
       T2D: $db->INSERT ($num)             insert a new object at index

     internal methods:
       $db->show_db_def (*FH)              show database definition
       $db->show_card_def (*FH)            show card layout definition
       $db->get_field_def ($num)           retrieve field definition
       $db->print_summary ($header)        print DB summary line;
                                           print also header if $header==1
       show_field_def                      show a field definition
       fetch_data                          used by FETCH to get db record
       store_data                          used by STORE to save db record
       get_recheader                       read gdb internal record structure
       put_recheader                       store gdb internal record structure
       fmt_time_stamp                      create a readable date and time string
       get_fielddef                        decode a field definition record
       get_carddef                         decode a card definiton record

     Diagnostics and Debugging methods:
       $db->dump_db (*FH, $type)           dump a complete data base
       $db->dump_data                      dump all data records
       $db->recover_password               attempt to reconstruct DB password

     Diagnostics and Debugging functions:
       print_recheader (*FH, $txt, $rec)   print details about a record
       dump_def                            dump database definition
       dump_data_record                    print and dump data record
       hex_dump                            perform a hex dump of some data
       decode_password                     attempt to decote the DB password
       decode                              attempt to decode a DB recrod

DESCRIPTION
===========

     DB.pm implements the perl package HP200LX::DB which is intended
     to provide a perl 5 interface for files in the generic database
     format of the HP 200 LX palmtop computer.  The perl modules are
     intended to be used on a work station such as a PC or a Unix
     machine to read and write data records from and to a database
     file.  These modules are not intended to be run directly on the
     palmtop!

     Please see the README file for a few more details or consult
     the examples which can be found at the web site mentioned below.

Copyright
=========

     Copyright (c) 1998 Gerhard Gonter.  All rights reserved.
     This is free software; you can redistribute it and/or modify
     it under the same terms as Perl itself.

AUTHOR
======

     Gerhard Gonter, g.gonter@ieee.org or gonter@wu-wien.ac.at

SEE ALSO
========

     http://falbala.wu-wien.ac.at:8684/pub/english.cgi/0/24065
     perl(1).


