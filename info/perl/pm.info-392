This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: Tk/NoteBook,  Next: Tk/NumEntry,  Prev: Tk/Mwm,  Up: Module List

display several windows in limited space with notebook metaphor.
****************************************************************

NAME
====

   Tk::NoteBook - display several windows in limited space with notebook
metaphor.

SYNOPSIS
========

     use Tk::NoteBook;
     ...
     $w = $frame->NoteBook();
     $page1 = $w->add("page1", options);
     $page2 = $w->add("page2", options);
     ...
     $page2 = $w->add("page2", options);

DESCRIPTION
===========

   The NoteBook widget provides a notebook metaphor to display several
windows in limited space. The notebook is divided into a stack of pages of
which only one is displayed at any time. The other pages can be selected
by means of choosing the visual "tabs" at the top of the widget.
Additionally, the <Tab> key may be used to traverse the pages.  If
*-underline* is used, Alt- bindings will also work.

   The widget takes all the options that a Frame does. In addition, it
supports the following options:

*-dynamicgeometry*
     If set to false (default and recommended), the size of the NoteBook
     will match the size of the largest page. Otherwise the size will
     match the size of the current page causing the NoteBook to change
     size when different pages of different sizes are selected.

*-ipadx*
     The amount of internal horizontal padding around the pages.

*-ipady*
     The amount of internal vertical padding around the pages.

METHODS
=======

   The following methods may be used with a NoteBook object in addition to
standard methods.

add(*pageName*, options)
     Adds a page with name *pageName* to the notebook. Returns an object
     of type Frame. The recognized options are:

    *-anchor*
          Specifies how the information in a tab is to be displayed. Must
          be one of n, ne, e, *se*, s, sw, w, *nw* or center.

    *-bitmap*
          Specifies a bitmap to display on the tab of this page. The bitmap
          is displayed only if none of the *-label* or *-image* options
          are specified.

    *-image*
          Specifies an image to display on the tab of this page. The image
          is displayed only if the *-label* option is not specified.

    *-label*
          Specifies the text string to display on the tab of this page.

    -justify
          When there are multiple lines of text displayed in a tab, this
          option determines the justification of the lines.

    *-createcmd*
          Specifies a `callback|Tk::callbacks' in this node to be called
          the first time the page is shown on the screen. This option can
          be used to delay the creation of the contents of a page until
          necessary. It can be useful in situations where there are a
          large number of pages in a NoteBook widget; with *-createcmd*
          you do not have to make the user wait until all pages are
          constructed before displaying the first page.

    *-raisecmd*
          Specifies a `callback|Tk::callbacks' in this node to be called
          whenever this page is raised by the user.

    *-state*
          Specifies whether this page can be raised by the user. Must be
          either normal or disabled.

    *-underline*
          Specifies the integer index of a character to underline in the
          tab. This option is used by the default bindings to implement
          keyboard traversal for menu buttons and menu entries. 0
          corresponds to the first character of text displayed on the
          widget, 1 to the next character and so on.

    *-wraplength*
          This option specifies the maximum line length of the label string
          on this tab. If the line length of the label string exceeds this
          length, then it is wrapped onto the next line so that no line is
          longer than the specified length. The value may be specified in
          any standard forms for screen distances. If this value is less
          than or equal to 0, then no wrapping is done: lines will break
          only at newline characters in the text.

delete(*pageName*)
     Deletes the page identified by *pageName*.

*pagecget(**pageName*, *-option*)
     Returns the current value of the configuration option given by
     *-option* in the page given by *pageName*. Option may have any of the
     values accepted in the add method.

*pageconfigure(**pageName*, options)
     Like configure for the page indicated by *pageName*. Options may be
     any of the options accepted by the add method.

*raise(**pageName*)
     Raise the page identified by *pageName*.

raised()
     Returns the name of the currently raised page.

AUTHORS
=======

   *Rajappa Iyer*  <rsi@earthling.net> Nick Ing-Simmons
<nick@ni-s.u-net.com>

   This code and documentation was derived from NoteBook.tcl in Tix4.0
written by Ioi Lam. It may be distributed under the same conditions as
Perl itself.


File: pm.info,  Node: Tk/NumEntry,  Next: Tk/NumEntryPlain,  Prev: Tk/NoteBook,  Up: Module List

A numeric Entry widget with inc. & dec. Buttons
***********************************************

NAME
====

   Tk::NumEntry - A numeric Entry widget with inc. & dec. Buttons

SYNOPSIS
========

       *use Tk::NumEntry;*

       *$parent*->*NumEntry*(?*-option*=>value, ...?);

DESCRIPTION
===========

   *Tk::NumEntry* defines a widget for entering integer numbers. The widget
also contains buttons for increment and decrement.

   *Tk::NumEntry* supports all the options and methods that the plain
NumEntry widget provides (see *Note Tk/NumEntryPlain: Tk/NumEntryPlain,),
plus the following options

STANDARD OPTIONS
================

   Besides the standard options of the `Entry|Tk::Entry' in this node
widget NumEntry supports:

   *-orient* *-repeatdelay* *-repeatinterval*

   The *-orient* option specifies the packing order of the increment and
decrement buttons.

WIDGET-SPECIFIC OPTIONS
=======================

Name:             *buttons*
Class:            Buttons
Switch:           *-buttons*
Fallback:		1
     Boolean that defines if the inc and dec buttons are visible.

WIDGET METHODS
==============

   Subclasses of NumEntry may override the following methods to use
different widgets for the composition of the NumEntry. These are:
NumEntryPlainWidget, FireButtonWidget, IncFireButtonWidget and
DecFireButtonWidget. FireButtonWidget is used if IncFireButtonWidget or
DecFireButtonWidget are not defined.

AUTHOR
======

   Graham Barr <`gbarr@pobox.com'>

   Current maintainer is Slaven Rezic <`eserte@cs.tu-berlin.de'>.

ACKNOWLEDGEMENTS
================

   I would to thank  Achim Bohnet <`ach@mpe.mpg.de'> for all the feedback
and testing. And for the splitting of the original Tk::NumEntry into
Tk::FireButton, Tk::NumEntryPlain and Tk::NumEntry

COPYRIGHT
=========

   Copyright (c) 1997-1998 Graham Barr. All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

   Except the typo's, they blong to Achim :-)


File: pm.info,  Node: Tk/NumEntryPlain,  Next: Tk/ObjEditor,  Prev: Tk/NumEntry,  Up: Module List

A numeric entry widget
**********************

NAME
====

   Tk::NumEntryPlain - A numeric entry widget

SYNOPSIS
========

       *use Tk::NumEntryPlain*;

DESCRIPTION
===========

   *Tk::NumEntryPlain* defines a widget for entering integer numbers.

   *Tk::NumEntryPlain* supports all the options and methods that a normal
`Entry|Tk::Entry' in this node widget provides, plus the following options

STANDARD OPTIONS
================

   *-repeatdelay* *-repeatinterval*

WIDGET-SPECIFIC OPTIONS
=======================

-minvalue
     Defines the minimum legal value that the widget can hold. If this
     value is undef then there is no minimum value (default = undef).

-maxvalue
     Defines the maximum legal value that the widget can hold. If this
     value is undef then there is no maximum value (default = undef).

-bell
     Specifies a boolean value. If true then a bell will ring if the user
     attempts to enter an illegal character into the entry widget, and
     when the user reaches the upper or lower limits when using the
     up/down buttons for keys (default = true).

-textvariable
     Reference to a scalar variable that contains the value currently in
     the *NumEntry*.  Use the variable only for reading (see `"CAVEATS"'
     in this node below).

-value
     Specifies the value to be inserted into the entry widget. Similar to
     the standard *-text* option, but will perform a range check on the
     value.

WIDGET METHODS
==============

*$numentry*->*incdec*(*increment*)
     Increment the value of the entry widget by the specified increment. If
     increment is 0, then perform a range check.

CAVEATS
=======

-textvariable
     *-textvariable* should only be used to read out the current value in
     the *NumEntry*.

     Values set via *-textvariable* are not valided. Therefore it's
     possible to insert, e.g., 'abc', into the *NumEntry*.

SEE ALSO
========

   `Tk::NumEntry|Tk::NumEntry' in this node `Tk::Entry|Tk::Entry' in this
node

HISTORY
=======

   The code was extracted from *Tk::NumEntry* and slightly modified by
Achim Bohnet <ach@mpe.mpg.de>.  *Tk::NumEntry*'s author is Graham Barr
<gbarr@pobox.com>.

   Current maintainer is Slaven Rezic <eserte@cs.tu-berlin.de>.

COPYRIGHT
=========

   Copyright (c) 1997-1998 Graham Barr. All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Tk/ObjEditor,  Next: Tk/ObjEditorDialog,  Prev: Tk/NumEntryPlain,  Up: Module List

Tk composite widget Obj editor
******************************

NAME
====

   Tk::ObjEditor - Tk composite widget Obj editor

SYNOPSIS
========

     use Tk::ObjEditor;
     
     my $editor = $mw->ObjEditor( caller => $object,
                                   direct => [1|0],
                                   [title=>"windows"]) -> pack ;

DESCRIPTION
===========

   This widget provides a GUI to edit the attributes of an object or the
elements of a simple hash or array.

   The editor is a *Note Tk/ObjScanner: Tk/ObjScanner, with additional
function to edit data.

   When the user double clicks (with left button) on an item, the value of
the item will be displayed in the HList.

   If the value is a scalar, the scalar will be displayed in the text
window.  (Which is handy if the value is a multi-line string)

   Use the right button of the mouse of an element to modify its value.
Depending on the context, you will also be able to delete the element or
to add a sub-element.

   This may be not clear. If yes, I think that trying this widget will be
much clearer than any explanation I can write. So run the Tk widget demo
and you'll find the Obj editor demo in the "User Contributed
Demonstration" section.

Direct or undirect edit
=======================

   As the constructor will pass a reference to the data structure to be
edited, the data can be edited :

not directly
     In this case, the data structure is cloned. The widget will edit the
     cloned version of the data structure. This enable the user to cancel
     the edition. This means that any reference to the internals of old
     data structure will stay on the old datastructure and will not be
     aware of the new values entered with this widget.

directly
     In this case, the data structure is not cloned. The edition is
     performed on the passed reference. Any reference to the internals of
     old data structure will be updated on-line. The drawback is that the
     user cannot cancel (or undo) the edition.

Constructor parameters
======================

   * caller: The ref of the object or hash or array to edit (mandatory).

   * title: the title of the menu created by the editor (optionnal)

   * direct: Set to 1 if you want to perform direct edition.

CAVEATS
=======

   Like *Note Tk/ObjScanner: Tk/ObjScanner, ObjEditor does not detect
recursive data structures. It will just keep on displaying the tree until
the user gets tired of clicking on the HList items.

AUTHOR
======

   Dominique Dumont, Guillaume Degremont.

   Copyright (c) 1997-2001 Dominique Dumont, Guillaume Degremont. All
rights reserved.  This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.

SEE ALSO
========

   perl(1), *Note Tk: Tk,, *Note Tk/HList: Tk/HList,, *Note Tk/ObjScanner:
Tk/ObjScanner,


File: pm.info,  Node: Tk/ObjEditorDialog,  Next: Tk/ObjScanner,  Prev: Tk/ObjEditor,  Up: Module List

Tk composite widget obj editor popup dialog
*******************************************

NAME
====

   Tk::ObjEditorDialog - Tk composite widget obj editor popup dialog

SYNOPSIS
========

     use Tk::ObjEditorDialog;
     
     my $editor = $mw->ObjEditorDialog( caller => $object,
                                         direct => [1|0],
                                         [title=>"windows"]) ;

     $editor -> Show;

DESCRIPTION
===========

   This widget is a `ObjEditor' in this node within a `DialogBox' in this
node widget. I.e. it will appear in its own toplevel window when you
invoke the Show() method like the FileDialog widget.

Constructor parameters
======================

   * caller: The ref of the object or hash or array to edit (mandatory).

   * title: the title of the menu created by the editor (optionnal)

   * direct: Set to 1 if you want to perform direct edition.

Method
======

Show(grab)
----------

   As in *Note Tk/DialogBox: Tk/DialogBox,, this method displays the
dialog box, until user invokes one of the buttons in the bottom frame. If
the grab type is specified in grab, then Show uses that grab; otherwise it
uses a local grab. Returns the name of the button invoked.

CAVEATS
=======

   Like *Note Tk/ObjScanner: Tk/ObjScanner, ObjEditor does not detect
recursive data structures. It will just keep on displaying the tree until
the user gets tired of clicking on the HList items.

AUTHOR
======

   Dominique Dumont.

   Copyright (c) 2001 Dominique Dumont. All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.

SEE ALSO
========

   perl(1), *Note Tk: Tk,, *Note Tk/HList: Tk/HList,, *Note Tk/ObjScanner:
Tk/ObjScanner,, *Note Tk/ObjEditor: Tk/ObjEditor,, *Note Tk/DialogBox:
Tk/DialogBox,


File: pm.info,  Node: Tk/ObjScanner,  Next: Tk/OlWm,  Prev: Tk/ObjEditorDialog,  Up: Module List

Tk data scanner
***************

NAME
====

   Tk::ObjScanner - Tk data scanner

SYNOPSIS
========

     use Tk::ObjScanner;
     
     my $scanner = $mw->ObjScanner( caller => $object,
                                    title=>"windows") -> pack ;
     
     my $mw -> ObjScanner
     (
      caller 		    => $object,
      title 		    => 'demo setting the scanner options',
      background 	    => 'white',
      selectbackground => 'beige',
      foldImage 		=> $mw->Photo(-file => Tk->findINC('folder.xpm')),
      openImage 		=> $mw->Photo(-file => Tk->findINC('openfolder.xpm')),
      itemImage 		=> $mw->Photo(-file => Tk->findINC('textfile.xpm')),
     )
     -> pack(expand => 1, fill => 'both') ;

DESCRIPTION
===========

   The scanner provides a GUI to scan the attributes of an object. It can
also be used to scan the elements of a hash or an array.

   The scanner is a composite widget made of a *Note Tk/HList: Tk/HList,
and a text window (actually a `TK::ROText' in this node). This widget acts
as a scanner to the object (or hash ref) passed with the 'caller'
parameter. The scanner will retrieve all keys of the hash/object and
insert them in the HList.

   When the user double clicks on a key, the corresponding value will be
added in the HList.

   If the value is a scalar, the scalar will be displayed in the text
window.  (Which is handy if the value is a multi-line string)

Constructor parameters
======================

   * caller: The ref of the object or hash or array to scan (mandatory).

   * title: the title of the menu created by the scanner (optional)

   * destroyable: If set, a menu entry will allow the user to destroy the
     scanner widget. (optional, default 1) . You may want to set this
     parameter to 0 if the destroy can be managed by a higher level object.

   * background: the background color for subwidgets (optional)

   * selectbackground: the select background color for HList (optional)

   * itemImage: the image for a scalar item (optional, default 'file.xbm')

   * foldImage: the image for a composite item (array or hash) when closed
     (optional, default 'folder.xbm')

   * openImage: the image for a composite item (array or hash) when open
     (optional, default 'openfolder.xbm')

WIDGET-SPECIFIC METHODS
=======================

updateListBox
-------------

   Update the keys of the listbox. This method may be handy if the scanned
object wants to update the listbox of the scanner when the scanned object
gets new attributes.

CAVEATS
=======

   The name of the widget is misleading as any data (not only object) may
be scanned. This widget is in fact a DataScanner.

   ObjScanner may fail if an object involves a lot of internal perl magic.
In this case, I'd be glad to hear about and I'll try to fix the problem.

   ObjScanner does not detect recursive data structures. It will just keep
on displaying the tree until the user gets tired of clicking on the HList
items.

   There's no sure way to detect if a reference is a pseudo-hash or not.
When a reference is believed to be a pseudo-hash, ObjScanner will display
the content of the reference like a hash. If the reference is should not
be displayed like a pseudo-hash, you can turn off the pseudo-hash view
with the check button on the top right of the widget.

THANKS
======

   To Rudi Farkas for all the improvements provided to ObjScanner.

   To Slaven Rezic for the propotype code of the pseudo-hash viewer.

AUTHOR
======

   Dominique Dumont, Dominique_Dumont@grenoble.hp.com

   Copyright (c) 1997-2001 Dominique Dumont. All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

SEE ALSO
========

   perl(1), Tk(3), Tk::HList(3)


File: pm.info,  Node: Tk/OlWm,  Next: Tk/Optionmenu,  Prev: Tk/ObjScanner,  Up: Module List

Interface to OpenLook properties of toplevel windows.
*****************************************************

NAME
====

   Tk::OlWm - Interface to OpenLook properties of toplevel windows.

     use Tk::OlWm;

     $toplevel->OL_DECOR(
                          CLOSE  => flag,
                          FOOTER => flag,
                          HEADER => flag,
                          RESIZE => flag,
                          PIN => flag,
                          ICON_NAME => flag,
                        );

     $toplevel->OL_WIN_BUSY( flag );

     $toplevel->OL_PIN_STATE( flag );

DESCRIPTION
===========

   A simple perl-only module that adds a few methods to `Tk::Wm|Tk::Wm' in
this node class.  These methods manipulate properties of the
`$toplevel|Tk::Toplevel' in this node to communicate with an OpenLook
window manager, e.g. Sun's `olwm' or `olvwm'.

   In the synopsis above flag is a "boolean" value - i.e. an integer with
0 meaning false and other values meaning true.

   All the *name => flag* pairs are optional.

STATUS
======

   Works for me, it is in 'Contrib' because I cannot support something
which has been developed just by dumping properties of Sun applications
and guessing.

AUTHOR
======

   Nick Ing-Simmons <nik@tiuk.ti.com>


File: pm.info,  Node: Tk/Optionmenu,  Next: Tk/PNG,  Prev: Tk/OlWm,  Up: Module List

Let the user select one of some predefined options values
*********************************************************

NAME
====

   Tk::Optionmenu - Let the user select one of some predefined options
values

SYNOPSIS
========

     use Optionmenu;

     $opt = $w->Optionmenu(
     			-options => REFERENCE_to_OPTIONLIST,
     			-command => CALLBACK,
     			-variable => SCALAR_REF,
     			);

     $opt->addOptions( OPTIONLIST );

     # OPTION LIST is
     #   a)  $val1, $val2, $val3,...
     #   b)  [ $lab1=>$val1], [$lab2=>val2], ... ]
     #   c)  combination of a) and b), e.g.,
     #       val1, [$lab2=>val2], val3, val4, [...], ...

DESCRIPTION
===========

   The *Optionmenu* widget allows the user chose between a given set of
options.

   If the user should be able to change the available option have a look
at *Note Tk/BrowseEntry: Tk/BrowseEntry,.

OPTIONS
=======

-options
     (Re)sets the list of options presented.

-command
     Defines the `callback|Tk::callbacks' in this node that is invokes
     when a new option is selected.

-variable
     Reference to a scalar that contains the current value of the selected
     option.

METHODS
=======

addOptions
     Adds OPTION_LIST to the already available options.

EXAMPLE
=======

     use Tk;
     my $mw = MainWindow->new();

     my $var;
     my $opt = $mw->Optionmenu(
                 -options => [qw(jan feb mar apr)],
                 -command => sub { print "got: ", shift, "\n" },
     		-variable => \$var,
                 )->pack;

     $opt->addOptions([may=>5],[jun=>6],[jul=>7],[aug=>8]);

     $mw->Label(-textvariable=>\$var, -relief=>'groove')->pack;
     $mw->Button(-text=>'Exit', -command=>sub{$mw->destroy})->pack;

     MainLoop;

SEE ALSO
========

   *Note Tk/Menubutton: Tk/Menubutton,, *Note Tk/BrowseEntry:
Tk/BrowseEntry,


File: pm.info,  Node: Tk/PNG,  Next: Tk/Pane,  Prev: Tk/Optionmenu,  Up: Module List

PNG loader for Tk::Photo
************************

NAME
====

   Tk::PNG - PNG loader for Tk::Photo

SYNOPSIS
========

     use Tk;
     use Tk::PNG;

     my $image = $widget->Photo('-format' => 'png', -file => 'something.png');

DESCRIPTION
===========

   This is an extension for Tk800.* which supplies PNG format loader for
Photo image type.

AUTHOR
======

   Nick Ing-Simmons <nick@ni-s.u-net.com>


File: pm.info,  Node: Tk/Pane,  Next: Tk/Panel,  Prev: Tk/PNG,  Up: Module List

A window panner
***************

NAME
====

   Tk::Pane - A window panner

     use Tk::Pane;
     
     $pane = $mw->Scrolled(Pane, Name => 'fred',
     	-scrollbars => 'soe',
     	-sticky => 'we',
     	-gridded => 'y'
     );

     $pane->Frame;

     $pane->pack;

DESCRIPTION
===========

   *Tk::Pane* provides a scrollable frame widget. Once created it can be
treated as a frame, except it is scrollable.

OPTIONS
=======

*-gridded* => *direction*
     Specifies if the top and left edges of the pane should snap to a grid
     column. This option is only useful if the widgets in the pane are
     managed by the grid geometry manager. Possible values are x, y and
     *xy*.

*-sticky* => style
     If Pane is larger than its requested dimensions, this option may be
     used to position (or stretch) the slave within its cavity. Style is a
     string that contains zero or more of the characters n, s, e or w. The
     string can optionally contains spaces or commas, but they are
     ignored. Each letter refers to a side (north, south, east, or west)
     that the slave will "stick" to. If both n and s (or e and w) are
     specified, the slave will be stretched to fill the entire height (or
     width) of its cavity.

METHODS
=======

*$pane*->see($widget ?,options?)
     Adjusts the view so that $widget is visable. Aditional parameters in
     *options-value* pairs can be passed, each *option-value* pair must be
     one of the following

    *-anchor* => anchor
          Specifies how to make the widget visable. If not given then as
          much of the widget as possible is made visable.

          Possible values are n, s, w, e, *nw*, ne, sw and *se*.  This
          will cause an edge on the widget to be aligned with the
          corresponding edge on the pane. for example *nw* will cause the
          top left of the widget to be placed at the top left of the pane.
          s will cause the bottom of the widget to be placed at the bottom
          of the pane, and as much of the widget as possible made visable
          in the x direction.

*$pane*->*xview*
     Returns a list containing two elements, both of which are real
     fractions between 0 and 1. The first element gives the position of
     the left of the window, relative to the Pane as a whole (0.5 means it
     is halfway through the Pane, for example). The second element gives
     the position of the right of the window, relative to the Pane as a
     whole.

*$pane*->*xview*($widget)
     Adjusts the view in the window so that widget is displayed at the
     left of the window.

*$pane*->*xview*(*moveto* => *fraction*)
     Adjusts the view in the window so that *fraction* of the total width
     of the Pane is off-screen to the left. fraction must be a fraction
     between 0 and 1.

*$pane*->*xview*(scroll => number, *what*)
     This command shifts the view in the window left or right according to
     number and *what*. Number must be an integer. What must be either
     *units* or *pages* or an abbreviation of one of these. If *what* is
     *units*, the view adjusts left or right by number*10 screen units on
     the display; if it is *pages* then the view adjusts by number
     screenfuls. If number is negative then widgets farther to the left
     become visible; if it is positive then widgets farther to the right
     become visible.

*$pane*->*yview*
     Returns a list containing two elements, both of which are real
     fractions between 0 and 1. The first element gives the position of
     the top of the window, relative to the Pane as a whole (0.5 means it
     is halfway through the Pane, for example). The second element gives
     the position of the bottom of the window, relative to the Pane as a
     whole.

*$pane*->*yview*($widget)
     Adjusts the view in the window so that widget is displayed at the top
     of the window.

*$pane*->*yview*(*moveto* => *fraction*)
     Adjusts the view in the window so that *fraction* of the total width
     of the Pane is off-screen to the top. fraction must be a fraction
     between 0 and 1.

*$pane*->*yview*(scroll => number, *what*)
     This command shifts the view in the window up or down according to
     number and *what*. Number must be an integer. What must be either
     *units* or *pages* or an abbreviation of one of these. If *what* is
     *units*, the view adjusts up or down by number*10 screen units on the
     display; if it is *pages* then the view adjusts by number screenfuls.
     If number is negative then widgets farther up become visible; if it
     is positive then widgets farther down become visible.

AUTHOR
======

   Graham Barr <`gbarr@pobox.com'>

COPYRIGHT
=========

   Copyright (c) 1997-1998 Graham Barr. All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.


File: pm.info,  Node: Tk/Panel,  Next: Tk/Parse,  Prev: Tk/Pane,  Up: Module List

A collapsable frame with title.
*******************************

NAME
====

   Tk::Panel - A collapsable frame with title.

SYNOPSIS
========

     use Tk;
     use Tk::Panel;

     $m = $parent->Tk::Panel(
     		-relief	=> <relief of inner boundary>,
     		-border	=> <border size of inner boundary>
     		-text	=> <text of title>
     		-toggle	=> <0|1>
     		-state	=> <normal|active|disabled>
     		-show	=> 1|0
     	);

     $m->Widget()->pack();

DESCRIPTION
===========

     This is a frame type object with a boundary and a title.
     The title can include a checkbox allowing the contents of
     the panel to be collapsed.

     Further widgets can be created inside the Panel.

OPTIONS
=======

-relief => <relief of inner boundary>
-------------------------------------

     Sets the relief of inner boundary. The default is 'raised'.

-border => <border size of inner boundary>
------------------------------------------

     Sets the relief of inner boundary.

-text => "title text"
---------------------

     Sets the title of the Panel.

-toggle => 1|0
--------------

     This sets if the Panel can be collapsed via the title.

-state => <normal|active|disabled>
----------------------------------

     This sets the state of the check button version of the title.

-show => 1|0
------------

     This sets if the Panel is expanded or collapsed.


File: pm.info,  Node: Tk/Parse,  Next: Tk/Photo,  Prev: Tk/Panel,  Up: Module List

Parse perl's pod files.
***********************

NAME
====

   Pod::Parse - Parse perl's pod files.

SYNOPSIS
========

   *THIS TK SNAPSHOT SHOULD BE REPLACED BY A CPAN MODULE*

DESCRIPTION
===========

   A module designed to simplify the job of parsing and formatting "pods",
the documentation format used by perl5. This consists of several different
functions to present and modify predigested pod files.

GUESSES
=======

   This is a work in progress, so I may have some stuff wrong, perhaps
badly.  Some of my more reaching guesses:

   * An =index paragraph should be split into lines, and each line placed
     inside an `X' formatting command which is then preprended to the next
     paragraph, like this:

          =index foo
          foo2
          foo3
          foo2!subfoo
          
          Foo!
          
          Will become:

          X<foo>X<foo2>X<foo3>X<foo2!subfoo>Foo!

   * A related change: that an `X' command is to be used for indexing
     data. This implies that all formatters need to at least ignore the
     `X' command.

   * Inside an =command, no special significance is to be placed on the
     first line of the argument. Thus the following two lines should be
     parsed identically:

          =item 1. ABC
          
          =item 1.
          ABC

     Note that neither of these are identical to this:

          =item 1.
          
          ABC

     which puts the "ABC" in a separate paragraph.

   * I actually violate this rule twice: in parsing =index commands, and in
     passing through the =pragma commands. I hope this make sense.

   * I added the =comment command, which simply ignores the next paragraph

   * I also added =pragma, which also ignores the next paragraph, but this
     time it gives the formatter a chance at doing something sinister with
     it.

POD CONVENTIONS
===============

   This module has two goals: first, to simplify the usage of the pod
format, and secondly the codification of the pod format. While perlpod
contains some information, it hardly gives the entire story. Here I
present "the rules", or at least the rules as far as I've managed to work
them out.

Paragraphs: The basic element
     The fundamental "atom" of a pod file is the paragraph, where a
     paragraph is defined as the text up to the next completely blank line
     ("\n\n"). Any pod parser will read in paragraphs sequentially,
     deciding what do to with each based solely on the current state and
     on the text at the _beginning_ of the paragraph.

Commands: The method of communication
     A paragraph that starts with the `=' symbol is assumed to be a
     special command.  All of the alphanumeric characters directly after
     the `=' are assumed to be part of the name of the command, up to the
     first whitespace. Anything past that whitespace is considered "the
     arugment", and the argument continues up till the end of the
     paragraph, regardless of newlines or other whitespace.

Text: Commands that aren't Commands
     A paragraph that doesn't start with `=' is treated as either of two
     types of text. If it starts with a space or tab, it is considered a
     verbatim paragraph, which will be printed out... verbatim. No
     formatting changes whatsover may be done. (Actually, this isn't quite
     true, but I'll get back to that at a later date.)

     A paragraph that doesn't start with whitespace or `=' is assumed to
     consist of formmated text that can be molded as the formatter sees
     fit. Reformatting to fit margins, whatever, it's fair game. These
     paragraphs also can contain a number of different formatting codes,
     which verbatim paragraphs can't. These formatting codes are covered
     later.

=cut: The uncommand
     There is one command that needs special mention: =cut. Anything after
     a paragraph starting with =cut is simply ignored by the formatter. In
     addition, any text before a valid command is equally ignored. Any
     valid `=' command will reenable formating. This fact is used to great
     benefit by Perl, which is glad to ignore anything between an `='
     command and `=cut', so you can embed a pod document right inside a
     perl program, and neither will bother the other.

Reference to paragraph commands

    =cut
          Ignore anything till the next paragraph starting with `='.

    =head1
          A top-level heading. Anything after the command (either on the
          same line or on further lines) is included in the heading, up
          until the end of the paragraph.

    =head2
          Secondary heading. Same as =head1, but different. No, there
          isn't a head3, head4, etc.

    =over [N]
          Start a list. The N is the number of characters to indent by.
          Not all formatters will listen to this, though. A good number to
          use is 4.

          While =over sounds like it should just be indentation, it's more
          complex then that. It actually starts a nested environment,
          specifically for the use of =item's. As this command recurses
          properly, you can use more then one, you just have to make sure
          they are closed off properly by =back commands.

    =back
          Ends the last =over block. Resets the indentation to whatever it
          was previously. Closes off the list of =item's.

    =item
          The point behind =over and =back. This command should only be
          used between them. The argument supplied should be consistent
          (within a list) to one of three types: enumeration, itemization,
          or description. To exemplify:

          An itemized list

               =over 4
               
               =item *
               
               A bulleted item
               
               =item *
               
               Another bulleted item
               
               =back
               
               An enumerated list

               =over 4
               
               =item 1.
               
               First item.
               
               =item 2.
               
               Second item.
               
               =back
               
               A described list

               =over 4
               
               =item Item #1
               
               First item
               
               =item Item #2 (which isn't really like #1, but is the second).
               
               Second item
               
               =back
               
               
               If you aren't consistent about the arguments to =item, Pod::Parse will
               complain.

    =comment
          Ignore this paragraph

    =pragma
          Ignore this paragraph, as well, unless you know what you are
          doing.

    =index
          Undecided at this time, but probably magic involving X<>.

Reference to formatting directives

    ...
          Format text inside the brackets as bold.

    ...
          Format text inside the brackets as italics.


          Replace with a zero-width character. You'll probably figure out
          some uses for this.

    And yet more that I haven't described yet...
USAGE
=====

Parse
-----

   This function takes a list of files as an argument. If no argument is
given, it defaults to the contents of @ARGV. Parse then reads through each
file and returns the data as a list. Each element of this list will be a
nested list containing data from a paragraph of the pod file. Elements
pertaining to "=over" paragraphs will themselves contain the nested
entries for all of the paragraphs within that list. Thus, it's easier to
parse the output of Parse using a recursive parses. (Um, did that parse?)

   It is *highly* recommended that you use the output of Simplify, not
Parse, as it's simpler.

   The output will consist of a list, where each element in the list
matches one of these prototypes:

[0,0,0,0,$filename]
     This is produced at the beginning of each file parsed, where
     $filename is the name of that file.

[-1,0,0,0,$filename]
     End of same.

[1,$line,$pos,0,$verbatim]
     This is produced for each paragraph of verbatim text. $verbatim is
     the text, $line is the line offset of the paragraph within the file,
     and $pos is the byte offset. (In all of the following elements, $pos
     and $line have identical meanings, so I'll skip explaining them each
     time.)

[2,$line,$pos,$level,$heading]
     Producded by a =head1 or =head2 command. $level is either 1 or 2, and
     $heading is the argument.

[3,$line,$pos,0,$item]
     $item is the argument from an =item paragraph.

[4,$line,$pos,0,$index]
     $index is the argument from an =index paragraph.

[6,$line,$pos,0,$text]
     Normal formatted text paragraph. $text is the text.

[7,$line,$pos,0,$pragma]
     $pragma is the argument from a =pragma paragraph.

[8,$line,$pos,$indentation,$type,...]
     This item is produced for each matching =over/=back pair.
     $indentation is the argument to =over, $type is 1 if the embedded
     =item's are bulleted, 2 if they are enumerated, 3 if they are text,
     and 0 if there are no items.

     The "..." indicates an unlimited number of further elements which are
     themselves nested arrays in exactly the format being described. In
     other words, a list item includes all the paragraphs inside the list
     inside itself. (Clear? No? Nevermind.)

[9,$line,$pos,0,$cut]
     $cut contains the text from a =cut paragraph. You shouldn't need to
     use this, but I _suppose_ it might be necessary to do special breaks
     on a cut. I doubt it though. This one is "depreciated", as Larry put
     it. Or perhaps disappreciated.

Simplify
--------

   This procedure takes as it's input the convoluted output from Parse(),
and outputs a much simpler array consisting of pairs of commands and
arguments, designed to be easy (easier?) to parse in your pod formatting
code.

   It is used very simply by saying something like:

     @Pod = Simplify(Parse());
     
     while($cmd = shift @Pod) { $arg = shift @Pod;
     	#...
     }

   Where #... is the code that responds to any of the commands from the
following list. Note that you are welcome to ignore any of the commands
that you want to. Many contain duplicate information, or at least
information that will go unused. A formatted based on this data can be
quite simple indeed. (See pod2text for entirely too simple an example.)

Reference to Simplify commands
------------------------------

"filename"
     The argument contains the name of the pod file that is being parsed.
     These will be present at the start of each file. You should open an
     output file, output headers, etc., based on this, and not when you
     start parsing.

"endfile"
     The end of the file. Each file will be ended before the next one
     begins, and after all files are done with. You can do end processing
     here. The argument is the same name as in "filename".

"setline"
     This gives you a chance to record the "current" input line, probably
     for debugging purposes. In this case, "current" means that the next
     command you see that was derived from an input paragraph will have
     start at the arguments line in the file.

"setloc"
     Same as setline, but the byte offset in the input, instead of the
     line offset.

"pragma"
     The argument contains the text of a pragma command.

"text"
     The argument contains a paragraph of formatted text.

"verbatim"
     The argument contains a paragraph of verbatim text.

"cut"
     A =cut command was hit. You shouldn't really need to listen for this
     one.

"index"
     The argument contains an =index paragraph. (Note: Current =index
     commands are not fed through, but turned into X<> commands.)

"head1"

"head2"
     The argument contains the argument from a header command.

"setindent"
     If you are tracking indentation, use the argument to set the
     indentation level.

"listbegin"
     Start a list environment. The argument is the type of list (1,2,3 or
     0).

"listend"
     Ends a list environment. Same argument as listbegin.

"listtype"
     The argument is the type of list. You can just record the argument
     when you see one of these, instead of paying attention to listbegin &
     listend.

"over"
     The argument is the indentation. It's probably better to listen to the
     "list..." commands.

"back"
     Ends an "over" list. The argument is the original indentation.

"item"
     The argument is the text of the =item command.

   Note that all of these various commands you've seen are syncronized
properly so you don't have to pay attention to all at once, but they are
all output for your benefit. Consider the following example:

     listtype 2
     listbegin 2
     setindent 4
     over 4
     item 1.
     text Item #1
     item 2.
     text Item #2
     setindent 0
     listend 2
     back 0
     listtype 0
     
     =head2 Normalize

   This command is normally invoked by Parse, so you shouldn't need to deal
with it. It just cleans up text a little, turning spare '<', '>', and '&'
characters into HTML escapes (<, etc.) as well as generating warnings for
some pod formatting mistakes.

Normalize2
----------

   A little more aggresive formating based on heuristics. Not applied by
default, as it might confuse your own heuristics.

%Escapes
--------

   This hash is exported from Pod::Parse, and contains default ASCII
translations for some common HTML escape sequences. You might like to use
this as a basis for an %HTML_Escapes array in your own formatter.


File: pm.info,  Node: Tk/Photo,  Next: Tk/Pixmap,  Prev: Tk/Parse,  Up: Module List

Full-color images
*****************

NAME
====

   Tk::Photo - Full-color images

       $widget->Photo(?name??, options?)

DESCRIPTION
===========

   A photo is an `image|Tk::Image' in this node whose pixels can display
any color or be transparent.  A photo image is stored internally in full
color (32 bits per pixel), and is displayed using dithering if necessary.
Image data for a photo image can be obtained from a file or a string, or it
can be supplied from C code through a procedural interface.  At present,
only GIF and PPM/PGM formats are supported, but an interface exists to
allow additional image file formats to be added easily.  A photo image is
transparent in regions where no image data has been supplied.

CREATING PHOTOS
===============

   Photos are created using the Photo method.  Photo supports the
following options:

*-data* => string
     Specifies the contents of the image as a string.  The format of the
     string must be one of those for which there is an image file format
     handler that will accept string data.  If both the *-data* and
     *-file* options are specified, the *-file* option takes precedence.

*-format* => *format-name*
     Specifies the name of the file format for the data specified with the
     *-data* or *-file* option.

*-file* => name
     name gives the name of a file that is to be read to supply data for
     the photo image.  The file format must be one of those for which
     there is an image file format handler that can read data.

*-gamma* => value
     Specifies that the colors allocated for displaying this image in a
     window should be corrected for a non-linear display with the specified
     gamma exponent value.  (The intensity produced by most CRT displays
     is a power function of the input value, to a good approximation;
     gamma is the exponent and is typically around 2).  The value
     specified must be greater than zero.  The default value is one (no
     correction).  In general, values greater than one will make the image
     lighter, and values less than one will make it darker.

*-height* => number
     Specifies the height of the image, in pixels.  This option is useful
     primarily in situations where the user wishes to build up the contents
     of the image piece by piece.  A value of zero (the default) allows the
     image to expand or shrink vertically to fit the data stored in it.

*-palette* => *palette-spec*
     Specifies the resolution of the color cube to be allocated for
     displaying this image, and thus the number of colors used from the
     colormaps of the windows where it is displayed.  The *palette-spec*
     string may be either a single decimal number, specifying the number
     of shades of gray to use, or three decimal numbers separated by
     slashes (/), specifying the number of shades of red, green and blue
     to use, respectively.  If the first form (a single number) is used,
     the image will be displayed in monochrome (i.e., grayscale).

*-width* => number
     Specifies the width of the image, in pixels.    This option is useful
     primarily in situations where the user wishes to build up the contents
     of the image piece by piece.  A value of zero (the default) allows the
     image to expand or shrink horizontally to fit the data stored in it.

IMAGE METHODS
=============

   When a photo image is created, Tk also creates a new object.  This
object supports the configure and cget methods described in *Note
Tk/options: Tk/options, which can be used to enquire and modify the
options described above.

   Those options that write data to the image generally expand the size of
the image, if necessary, to accommodate the data written to the image,
unless the user has specified non-zero values for the *-width* and/or
*-height* configuration options, in which case the width and/or height,
respectively, of the image will not be changed.

   The following addition methods are available for photo images:

*$image*->*blank*
     Blank the image; that is, set the entire image to have no data, so it
     will be displayed as transparent, and the background of whatever
     window it is displayed in will show through.

*$image*->copy(*sourceImage* ?,*option value(s) ...*?)
     Copies a region from the image called *sourceImage* (which must be a
     photo image) to the image called *$image*, possibly with pixel
     zooming and/or subsampling.  If no options are specified, this method
     copies the whole of *sourceImage* into *$image*, starting at
     coordinates (0,0) in *$image*.  The following options may be
     specified:

    *-from* => *x1 y1 ?x2 y2?*
          Specifies a rectangular sub-region of the source image to be
          copied.  (*x1,y1*) and (*x2,y2*) specify diagonally opposite
          corners of the rectangle.  If x2 and *y2* are not specified, the
          default value is the bottom-right corner of the source image.
          The pixels copied will include the left and top edges of the
          specified rectangle but not the bottom or right edges.  If the
          *-from* option is not given, the default is the whole source
          image.

    *-to* => *x1 y1 ?x2 y2?*
          Specifies a rectangular sub-region of the destination image to be
          affected.  (*x1,y1*) and (*x2,y2*) specify diagonally opposite
          corners of the rectangle.  If x2 and *y2* are not specified, the
          default value is (*x1,y1*) plus the size of the source region
          (after subsampling and zooming, if specified).  If x2 and *y2*
          are specified, the source region will be replicated if necessary
          to fill the destination region in a tiled fashion.

    *-shrink*
          Specifies that the size of the destination image should be
          reduced, if necessary, so that the region being copied into is
          at the bottom-right corner of the image.  This option will not
          affect the width or height of the image if the user has
          specified a non-zero value for the *-width* or *-height*
          configuration option, respectively.

    *-zoom* => *x y*
          Specifies that the source region should be magnified by a factor
          of x in the X direction and y in the Y direction.  If y is not
          given, the default value is the same as x.  With this option,
          each pixel in the source image will be expanded into a block of
          x x y pixels in the destination image, all the same color.  x
          and y must be greater than 0.

    *-subsample* => *x y*
          Specifies that the source image should be reduced in size by
          using only every xth pixel in the X direction and yth pixel in
          the Y direction.  Negative values will cause the image to be
          flipped about the Y or X axes, respectively.  If y is not given,
          the default value is the same as x.

*$image*->data(?*option value(s), ...*?)
     returns image data in the form of a string.  The following options
     may be specified:

    *-background* => * color*
          If the color is specified, the data will not contain any
          transparency information. In all transparent pixels the color
          will be replaced by the specified color.

    *-format* => *format-name*
          Specifies the name of the image file format handler to be used to
          convert the data.  Specifically, this method searches for the
          first handler whose name matches a initial substring of
          *format-name* and which has the capability to write an string.
          If this option is not given, the data is returned in the default
          format as accepted by *$image*->put.

    *-from* => *x1 y1 ?x2 y2?*
          Specifies a rectangular region of *$image* to be written to the
          string.  If only x1 and *y1* are specified, the region extends
          from *(x1,y1)* to the bottom-right corner of *$image*.  If all
          four coordinates are given, they specify diagonally opposite
          corners of the rectangular region.  The default, if this option
          is not given, is the whole image.

*-grayscale*
     If this options is specified, the data will not contain color
     information. All pixel data will be transformed into grayscale.

*$image*->get(*x,y*)
     Returns the color of the pixel at coordinates (x,y) in the image as a
     list of three integers between 0 and 255, representing the red, green
     and blue components respectively.

*$image*->put(data ?,*-format*=>*format-name*? ?,*-to*=>* x1 y1 ?x2 y2?*?)
     Sets pixels in * imageName* to the data specified in data. This
     command first searches the list of image file format handlers for a
     handler that can interpret the data in data, and then reads the image
     in filename into imageName (the destination image). The following
     options may be specified:

    *-format **format-name*
          Specifies the format of the image data in data.  Specifically,
          only image file format handlers whose names begin with
          *format-name* will be used while searching for an image data
          format handler to read the data. Otherwise data is used to form
          a two-dimensional array of pixels that are then copied into the
          *$image*. data is structured then as a list of horizontal rows,
          from top to bottom, each of which is a list of colors, listed
          from left to right.  Each color may be specified by name (e.g.,
          blue) or in hexadecimal form (e.g., #2376af).

    *-from **x1 y1 x2 y2*
          Specifies a rectangular sub-region of the image file data to be
          returned. If only x1 and *y1* are specified, the region extends
          from (*x1,y1*) to the bottom-right corner of the image in the
          image file.  If all four coordinates are specified, they specify
          diagonally opposite corners or the region. The default, if this
          option is not specified, is the whole of the image.

    *-shrink*
          If this option, the size of imageName will be reduced, if
          necessary, so that the region into which the image file data are
          read is at the bottom-right corner of the imageName.  This option
          will not affect the width or height of the image if the user has
          specified a non-zero value for the *-width* or *-height*
          configuration option, respectively.

    *-to **x y*
          Specifies the coordinates of the top-left corner of the region of
          imageName into which data from filename are to be read.  The
          default is (0,0).

*$image*->read(filename ?,*option value(s), ...*?)
     Reads image data from the file named filename into the image.  This
     method first searches the list of image file format handlers for a
     handler that can interpret the data in filename, and then reads the
     image in filename into *$image* (the destination image).  The
     following options may be specified:

    *-format* => *format-name*
          Specifies the format of the image data in filename.
          Specifically, only image file format handlers whose names begin
          with *format-name* will be used while searching for an image data
          format handler to read the data.

    *-from* => *x1 y1 ?x2 y2?*
          Specifies a rectangular sub-region of the image file data to be
          copied to the destination image.  If only x1 and *y1* are
          specified, the region extends from (*x1,y1*) to the bottom-right
          corner of the image in the image file.  If all four coordinates
          are specified, they specify diagonally opposite corners or the
          region.  The default, if this option is not specified, is the
          whole of the image in the image file.

    *-shrink*
          If this option, the size of *$image* will be reduced, if
          necessary, so that the region into which the image file data are
          read is at the bottom-right corner of the *$image*.  This option
          will not affect the width or height of the image if the user has
          specified a non-zero value for the *-width* or *-height*
          configuration option, respectively.

    *-to* => *x y*
          Specifies the coordinates of the top-left corner of the region of
          *$image* into which data from filename are to be read.  The
          default is (0,0).

*$image*->*redither*
     The dithering algorithm used in displaying photo images propagates
     quantization errors from one pixel to its neighbors.  If the image
     data for *$image* is supplied in pieces, the dithered image may not
     be exactly correct.  Normally the difference is not noticeable, but
     if it is a problem, this method can be used to recalculate the
     dithered image in each window where the image is displayed.

*$image*->write(filename ?,*option value(s), ...*?)
     Writes image data from *$image* to a file named filename.  The
     following options may be specified:

    *-background** color*
          If the color is specified, the data will not contain any
          transparency information. In all transparent pixels the color
          will be replaced by the specified color.

    *-format* => *format-name*
          Specifies the name of the image file format handler to be used to
          write the data to the file.  Specifically, this subcommand
          searches for the first handler whose name matches a initial
          substring of *format-name* and which has the capability to write
          an image file.  If this option is not given, this subcommand
          uses the first handler that has the capability to write an image
          file.

    *-from* => *x1 y1 ?x2 y2?*
          Specifies a rectangular region of *$image* to be written to the
          image file.  If only x1 and *y1* are specified, the region
          extends from *(x1,y1)* to the bottom-right corner of *$image*.
          If all four coordinates are given, they specify diagonally
          opposite corners of the rectangular region.  The default, if
          this option is not given, is the whole image.

    *-grayscale*
          If this options is specified, the data will not contain color
          information. All pixel data will be transformed into grayscale.

IMAGE FORMATS
=============

   The photo image code is structured to allow handlers for additional
image file formats to be added easily.  The photo image code maintains a
list of these handlers.  Handlers are added to the list by registering
them with a call to *Tk_CreatePhotoImageFormat*.  The standard Tk
distribution comes with handlers for PPM/PGM and GIF formats, which are
automatically registered on initialization.

   When reading an image file or processing string data specified with the
*-data* configuration option, the photo image code invokes each handler in
turn until one is found that claims to be able to read the data in the
file or string.  Usually this will find the correct handler, but if it
doesn't, the user may give a format name with the *-format* option to
specify which handler to use.  In fact the photo image code will try those
handlers whose names begin with the string specified for the *-format*
option (the comparison is case-insensitive).  For example, if the user
specifies *-format gif*, then a handler named GIF87 or GIF89 may be
invoked, but a handler named JPEG may not (assuming that such handlers had
been registered).

   When writing image data to a file, the processing of the *-format*
option is slightly different: the string value given for the *-format*
option must begin with the complete name of the requested handler, and may
contain additional information following that, which the handler can use,
for example, to specify which variant to use of the formats supported by
the handler.

COLOR ALLOCATION
================

   When a photo image is displayed in a window, the photo image code
allocates colors to use to display the image and dithers the image, if
necessary, to display a reasonable approximation to the image using the
colors that are available.  The colors are allocated as a color cube, that
is, the number of colors allocated is the product of the number of shades
of red, green and blue.

   Normally, the number of colors allocated is chosen based on the depth
of the window.  For example, in an 8-bit PseudoColor window, the photo
image code will attempt to allocate seven shades of red, seven shades of
green and four shades of blue, for a total of 198 colors.  In a 1-bit
StaticGray (monochrome) window, it will allocate two colors, black and
white.  In a 24-bit DirectColor or TrueColor window, it will allocate 256
shades each of red, green and blue.  Fortunately, because of the way that
pixel values can be combined in DirectColor and TrueColor windows, this
only requires 256 colors to be allocated.  If not all of the colors can be
allocated, the photo image code reduces the number of shades of each
primary color and tries again.

   The user can exercise some control over the number of colors that a
photo image uses with the *-palette* configuration option.  If this option
is used, it specifies the maximum number of shades of each primary color
to try to allocate.  It can also be used to force the image to be
displayed in shades of gray, even on a color display, by giving a single
number rather than three numbers separated by slashes.

CREDITS
=======

   The photo image type was designed and implemented by Paul Mackerras,
based on his earlier photo widget and some suggestions from John
Ousterhout.

SEE ALSO
========

   `Tk::Bitmap|Tk::Bitmap' in this node `Tk::Image|Tk::Image' in this node
`Tk::Pixmap|Tk::Pixmap' in this node

KEYWORDS
========

   photo, image, color


