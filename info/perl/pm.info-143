This is Info file pm.info, produced by Makeinfo version 1.68 from the
input file bigpm.texi.


File: pm.info,  Node: File/chmod,  Next: File/lockf,  Prev: File/Temp,  Up: Module List

Implements symbolic and ls chmod modes
**************************************

NAME
====

   File::chmod - Implements symbolic and ls chmod modes

VERSION
=======

   This is File::chmod v0.31.

SYNOPSIS
========

     use File::chmod;

     # chmod takes all three types
     # these all do the same thing
     chmod(0666,@files);
     chmod("=rw",@files);
     chmod("-rw-rw-rw-",@files);

     # or

     use File::chmod qw( symchmod lschmod );

     chmod(0666,@files);		# this is the normal chmod
     symchmod("=rw",@files);	# takes symbolic modes only
     lschmod("-rw-rw-rw-",@files);	# takes "ls" modes only

     # more functions, read on to understand

DESCRIPTION
===========

   File::chmod is a utility that allows you to bypass system calls or bit
processing of a file's permissions.  It overloads the chmod() function
with its own that gets an octal mode, a symbolic mode (see below), or an
"ls" mode (see below).  If you wish not to overload chmod(), you can
export symchmod() and lschmod(), which take, respectively, a symbolic mode
and an "ls" mode.

   Symbolic modes are thoroughly described in your chmod(1) man page, but
here are a few examples.

     # NEW: if $UMASK is true, symchmod() applies a bit-mask found in $MASK

     chmod("+x","file1","file2");	# overloaded chmod(), that is...
     # turns on the execute bit for all users on those two files

     chmod("o=,g-w","file1","file2");
     # removes 'other' permissions, and the write bit for 'group'

     chmod("=u","file1","file2");
     # sets all bits to those in 'user'

   "ls" modes are the type produced on the left-hand side of an `ls -l' on
a directory.  Examples are:

     chmod("-rwxr-xr-x","file1","file2");
     # the 0755 setting; user has read-write-execute, group and others
     # have read-execute priveleges

     chmod("-rwsrws---","file1","file2");
     # sets read-write-execute for user and group, none for others
     # also sets set-uid and set-gid bits

   The regular chmod() and lschmod() are absolute; that is, they are not
appending to or subtracting from the current file mode.  They set it,
regardless of what it had been before.  symchmod() is useful for allowing
the modifying of a file's permissions without having to run a system call
or determining the file's permissions, and then combining that with
whatever bits are appropriate.  It also operates separately on each file.

   An added feature to version 0.30 is the $UMASK variable, explained
below; if symchmod() is called and this variable is true, then the
function uses the (also new) $MASK variable (which defaults to umask()) as
a mask against the new mode.  This is documented below more clearly.

Functions
---------

   Exported by default:

chmod(MODE,FILES)
     Takes an octal, symbolic, or "ls" mode, and then chmods each file
     appropriately.

getchmod(MODE,FILES)
     Returns a list of modified permissions, without chmodding files.
     Accepts any of the three kinds of modes.

          @newmodes = getchmod("+x","file1","file2");
          # @newmodes holds the octal permissons of the files'
          # modes, if they were to be sent through chmod("+x"...)

   Exported by request:

symchmod(MODE,FILES)
     Takes a symbolic permissions mode, and chmods each file.

lschmod(MODE,FILES)
     Takes an "ls" permissions mode, and chmods each file.

getsymchmod(MODE,FILES)
     Returns a list of modified permissions, without chmodding files.
     Accepts only symbolic permisson modes.

getlschmod(MODE,FILES)
     Returns a list of modified permissions, without chmodding files.
     Accepts only "ls" permisson modes.

getmod(FILES)
     Returns a list of the current mode of each file.

Variables
---------

$File::chmod::DEBUG
     If set to a true value, it will report warnings, similar to those
     produced by chmod() on your system.  Otherwise, the functions will
     not report errors.  Example: a file can not have file-locking and the
     set-gid bits on at the same time.  If $File::chmod::DEBUG is true,
     the function will report an error.  If not, you are not warned of the
     conflict.  It is set to 1 as default.

$File::chmod::MASK
     Contains the umask to apply to new file modes when using
     getsymchmod().  This defaults to the return value of umask() at
     compile time.  Is only applied if $UMASK is true.

$File::chmod::UMASK
     This is a boolean which tells getsymchmod() whether or not to apply
     the umask found in $MASK.  It defaults to true.

REVISIONS
=========

   *Note: this section was started with version 0.30.*

   This is an in-depth look at the changes being made from version to
version.

0.30 to 0.31
------------

*fixed getsymchmod() bug*
     Whoa.  getsymchmod() was doing some crazy ish.  That's about all I
     can say.  I did a great deal of debugging, and fixed it up.  It ALL
     had to do with two things:

          $or = (/+=/ ? 1 : 0); # should have been /[+=]/

          /u/ && $ok ? u_or() : u_not(); # should have been /u/ and $ok

*fixed getmod() bug*
     I was using map() incorrectly in getmod().  Fixed that.

*condensed lschmod()*
     I shorted it up, getting rid a variable.

0.21 to 0.30
------------

*added umask() honoring for symchmod()*
     The symchmod() function now honors the $UMASK and $MASK variables.
     $UMASK is a boolean which indicates whether or not to honor the $MASK
     variable.  $MASK holds a umask, and it defaults to umask().  $UMASK
     defaults to true.  These variables are NOT exported.  They must
     explictly set (i.e. $File::chmod::UMASK = 0).

*function name changes*
     Renamed internal function determine_mode() to mode().  However, if
     you happen to be using determine_mode() somewhere, mode() will be
     called, but you'll also get a warning about deprecation.

     Renamed internal functions {or,not}_{l,s,t} to {l,s,t}_{or,not}.
     This is to keep in standard with the OTHER 6 pairs of bitwise
     functions, such as r_or() and g_not().  I don't know WHY the others
     had 'not' or 'or' in the front.

*fixed debugging bugs*
     Certain calls to warn() were not guarded by the $DEBUG variable, and
     now they are.  Also, for some reason, I left a debugging check (that
     didn't check to see if $DEBUG was true) in getsymchmod(), line 118.
     It printed "ENTERING /g/".  It's gone now.

*fixed set-uid and set-gid bug*
     Heh, it seems that in the previous version of File::chmod, the
     following code went along broken:

          # or_s sub, File/chmod.pm, v0.21, line 330
          ($VAL & 00100) && do {
            $DEBUG && warn("execute bit must be on for set-uid"); 1;
          } && next;

     Aside from me using '&&' more than enough (changed in the new code),
     this is broken.  This is now fixed.

*fixed file lock/set-gid bug*
     The not_l() function (now renamed to l_not()) used to take the file
     mode and bit-wise NOT it with ~02000.  However, it did not check if
     the file was locked vs. set-gid.  Now, the function is `$VAL &=
     ~02000 if not $VAL & 00010;'.

*removed useless data structures*
     I do not know why I had the $S variable, or %r, %w, and %x hashes.
     In fact, $S was declared in `use vars qw( ... );', but never given a
     value, and the %r, %w, and %x hashes had a 'full' key which never got
     used.  And the hashes themselves weren't really needed anyway.  Here
     is a list of the variables no longer in use, and what they have been
     replaced with (if any):

          $S		nothing
          $U, $G, $O	$W
          %r, %w, %x	octal numbers
          @files	@_ (I had @files = @_; in nearly EVERY sub)
          $c		$_

*compacted code*
     The first version of File::chmod that was published was 0.13, and it
     was written in approximately 10 days, being given the off-and-on
     treatment I end up having to give several projects, due to more
     pressing matters.  Well, since then, most of the code has stayed the
     same, although bugs were worked out.  Well, I got rid of a lot of
     slow, clunky, and redundant sections of code in this version.
     Sections include the processing of each character of the mode in
     getsymchmod(), the getmod() subroutine, um, nearly ALL of the
     getsymchmod() function, now that I look at it.

     Here's part of the getsymchmod() rewrite:

          for ($c){
            if (/u/){
              u_or() if $MODE eq "+" or $MODE eq "=";
              u_not() if $MODE eq "-";
            }
          ...
          }

          # changed to

          /u/ && $or ? u_or() : u_and();
          # note: operating on $_, $c isn't used anymore
          # note: $or holds 1 if the $MODE was + or =, 0 if $MODE was -
          # note: previous was redundant.  didn't need $MODE eq "-" check
          #       because u_or() and u_not() both go to the next character

PORTING
=======

   This is only good on Unix-like boxes.  I would like people to help me
work on File::chmod for any OS that deserves it.  If you would like to
help, please email me (address below) with the OS and any information you
might have on how chmod() should work on it; if you don't have any
specific information, but would still like to help, hey, that's good too.
I have the following information (from `' in this node):

Win32
     Only good for changing "owner" read-write access, "group", and
     "other" bits are meaningless.  *NOTE: Win32::File and
     Win32::FileSecurity already do this.  I do not currently see a need
     to port File::chmod.*

MacOS
     Only limited meaning. Disabling/enabling write permission is mapped to
     locking/unlocking the file.

RISC OS
     Only good for changing "owner" and "other" read-write access.

AUTHOR
======

   Jeff Pinyan, japhy+perl@pobox.com, CPAN ID: PINYAN

SEE ALSO
========

     Stat::lsMode (by Mark-James Dominus, CPAN ID: MJD)
     chmod(1) manpage
     perldoc -f chmod
     perldoc -f stat


File: pm.info,  Node: File/lockf,  Next: File/stat,  Prev: File/chmod,  Up: Module List

Perl module interface to the lockf system call
**********************************************

NAME
====

   File::lockf - Perl module interface to the lockf system call

SYNOPSIS
========

     use File::lockf;

DESCRIPTION
===========

   File-Lockf is an interface to the lockf system call. Perl supports the
flock system call natively, but that does not acquire network locks. Perl
also supports the fcntl system call, but that is somewhat ugly to use.
There are other locking modules available for Perl, but none of them
provided what I wanted - a simple, clean interface to the lockf system
call, without any bells or whistles getting in the way.

   File-Lockf contains four functions which map directly to the four modes
of lockf, and an OO wrapper class that encapulates the basic locking
functionality along with an additional utility method that iteratively
attempts to acquire a lock.

Lock functions
==============

   The following functions return 0 (zero) on success, and the system error
number from errno on failure. They each take an open file handle as the
first argument, and optionally a size parameter. Please see your system
lockf man page for more details about lockf functionality on your system.

$status = File::lockf::lock(FH, size = 0)
     This function maps to the F_LOCK mode of lockf.

$status = File::lockf::tlock(FH, size = 0)
     This function maps to the F_TLOCK mode of lockf.

$status = File::lockf::ulock(FH, size = 0)
     This function maps to the F_ULOCK mode of lockf.

$status = File::lockf::test(FH, size = 0)
     This function maps to the F_TEST mode of lockf.

OO wrapper
==========

   File-Lockf also provides a simple OO wrapper class around the locking
functionality, which allows you to create a lock object for a file handle
and then perform lock operations with it. All of the methods return 0
(zero) on success, and the system error number from errno on failure.

$lock = new File::lockf(\*FH)
     This function returns a new lock object bound to the given file
     handle. Note that you need to pass a reference to the file handle to
     the constructor, not the file handle itself.

$status = $lock->lock(size = 0)
     This method calls File::lockf::lock on the bound file handle.

$status = $lock->tlock(size = 0)
     This method calls File::lockf::tlock on the bound file handle.

$status = $lock->ulock(size = 0)
     This method calls File::lockf::ulock on the bound file handle.

$status = $lock->test(size = 0)
     This method calls File::lockf::test on the bound file handle.

$status = $lock->slock(count = 5, delay = 2, size = 0)
     This method will attempt to lock the bound file handle <count> times,
     sleeping <delay> seconds after each try. It will return 0 if the lock
     succeeded, or the system error number from errno if all attempts fail.

AUTHOR
======

   Paul Henson <henson@acm.org>

SEE ALSO
========

   perl(1).


File: pm.info,  Node: File/stat,  Next: FileCache,  Prev: File/lockf,  Up: Module List

by-name interface to Perl's built-in stat() functions
*****************************************************

NAME
====

   File::stat - by-name interface to Perl's built-in stat() functions

SYNOPSIS
========

     use File::stat;
     $st = stat($file) or die "No $file: $!";
     if ( ($st->mode & 0111) && $st->nlink > 1) ) {
         print "$file is executable with lotsa links\n";
     }

     use File::stat qw(:FIELDS);
     stat($file) or die "No $file: $!";
     if ( ($st_mode & 0111) && $st_nlink > 1) ) {
         print "$file is executable with lotsa links\n";
     }

DESCRIPTION
===========

   This module's default exports override the core stat() and lstat()
functions, replacing them with versions that return "File::stat" objects.
This object has methods that return the similarly named structure field
name from the stat(2) function; namely, dev, ino, mode, nlink, uid, gid,
rdev, size, atime, mtime, ctime, blksize, and blocks.

   You may also import all the structure fields directly into your
namespace as regular variables using the :FIELDS import tag.  (Note that
this still overrides your stat() and lstat() functions.)  Access these
fields as variables named with a preceding `st_' in front their method
names.  Thus, `$stat_obj->dev()' corresponds to $st_dev if you import the
fields.

   To access this functionality without the core overrides, pass the use
an empty import list, and then access function functions with their full
qualified names.  On the other hand, the built-ins are still available via
the `CORE::' pseudo-package.

NOTE
====

   While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.

AUTHOR
======

   Tom Christiansen


File: pm.info,  Node: FileCache,  Next: FileHandle,  Prev: File/stat,  Up: Module List

keep more files open than the system permits
********************************************

NAME
====

   FileCache - keep more files open than the system permits

SYNOPSIS
========

     cacheout $path;
     print $path @data;

DESCRIPTION
===========

   The `cacheout' function will make sure that there's a filehandle open
for writing available as the pathname you give it.  It automatically
closes and re-opens files if you exceed your system file descriptor
maximum.

BUGS
====

   `sys/param.h' lies with its `NOFILE' define on some systems, so you may
have to set $FileCache::cacheout_maxopen yourself.


File: pm.info,  Node: FileHandle,  Next: FileHandle/Multi,  Prev: FileCache,  Up: Module List

supply object methods for filehandles
*************************************

NAME
====

   FileHandle - supply object methods for filehandles

SYNOPSIS
========

     use FileHandle;

     $fh = new FileHandle;
     if ($fh->open("< file")) {
         print <$fh>;
         $fh->close;
     }

     $fh = new FileHandle "> FOO";
     if (defined $fh) {
         print $fh "bar\n";
         $fh->close;
     }

     $fh = new FileHandle "file", "r";
     if (defined $fh) {
         print <$fh>;
         undef $fh;       # automatically closes the file
     }

     $fh = new FileHandle "file", O_WRONLY|O_APPEND;
     if (defined $fh) {
         print $fh "corge\n";
         undef $fh;       # automatically closes the file
     }

     $pos = $fh->getpos;
     $fh->setpos($pos);

     $fh->setvbuf($buffer_var, _IOLBF, 1024);

     ($readfh, $writefh) = FileHandle::pipe;

     autoflush STDOUT 1;

DESCRIPTION
===========

   NOTE: This class is now a front-end to the IO::* classes.

   `FileHandle::new' creates a FileHandle, which is a reference to a newly
created symbol (see the Symbol package).  If it receives any parameters,
they are passed to `FileHandle::open'; if the open fails, the FileHandle
object is destroyed.  Otherwise, it is returned to the caller.

   `FileHandle::new_from_fd' creates a FileHandle like new does.  It
requires two parameters, which are passed to `FileHandle::fdopen'; if the
fdopen fails, the FileHandle object is destroyed.  Otherwise, it is
returned to the caller.

   `FileHandle::open' accepts one parameter or two.  With one parameter,
it is just a front end for the built-in open function.  With two
parameters, the first parameter is a filename that may include whitespace
or other special characters, and the second parameter is the open mode,
optionally followed by a file permission value.

   If `FileHandle::open' receives a Perl mode string (">", "+<", etc.)  or
a POSIX fopen() mode string ("w", "r+", etc.), it uses the basic Perl open
operator.

   If `FileHandle::open' is given a numeric mode, it passes that mode and
the optional permissions value to the Perl sysopen operator.  For
convenience, `FileHandle::import' tries to import the O_XXX constants from
the Fcntl module.  If dynamic loading is not available, this may fail, but
the rest of FileHandle will still work.

   `FileHandle::fdopen' is like open except that its first parameter is
not a filename but rather a file handle name, a FileHandle object, or a
file descriptor number.

   If the C functions fgetpos() and fsetpos() are available, then
`FileHandle::getpos' returns an opaque value that represents the current
position of the FileHandle, and `FileHandle::setpos' uses that value to
return to a previously visited position.

   If the C function setvbuf() is available, then `FileHandle::setvbuf'
sets the buffering policy for the FileHandle.  The calling sequence for
the Perl function is the same as its C counterpart, including the macros
`_IOFBF', `_IOLBF', and `_IONBF', except that the buffer parameter
specifies a scalar variable to use as a buffer.  WARNING: A variable used
as a buffer by `FileHandle::setvbuf' must not be modified in any way until
the FileHandle is closed or until `FileHandle::setvbuf' is called again,
or memory corruption may result!

   See *Note Perlfunc: (perl.info)perlfunc, for complete descriptions of
each of the following supported FileHandle methods, which are just front
ends for the corresponding built-in functions:

     close
     fileno
     getc
     gets
     eof
     clearerr
     seek
     tell

   See *Note Perlvar: (perl.info)perlvar, for complete descriptions of
each of the following supported FileHandle methods:

     autoflush
     output_field_separator
     output_record_separator
     input_record_separator
     input_line_number
     format_page_number
     format_lines_per_page
     format_lines_left
     format_name
     format_top_name
     format_line_break_characters
     format_formfeed

   Furthermore, for doing normal I/O you might need these:

$fh->print
     See `print', *Note Perlfunc: (perl.info)perlfunc,.

$fh->printf
     See `printf', *Note Perlfunc: (perl.info)perlfunc,.

$fh->getline
     This works like <$fh> described in `"I', *Note Perlop:
     (perl.info)perlop, except that it's more readable and can be safely
     called in an array context but still returns just one line.

$fh->getlines
     This works like <$fh> when called in an array context to read all the
     remaining lines in a file, except that it's more readable.  It will
     also croak() if accidentally called in a scalar context.

   There are many other functions available since FileHandle is descended
from IO::File, IO::Seekable, and IO::Handle.  Please see those respective
pages for documentation on more functions.

SEE ALSO
========

   The IO extension, *Note Perlfunc: (perl.info)perlfunc,, `"I', *Note
Perlop: (perl.info)perlop,.


File: pm.info,  Node: FileHandle/Multi,  Next: FileSys/Ext2,  Prev: FileHandle,  Up: Module List

Print to multiple filehandles with one output call
**************************************************

NAME
====

   Multi - Print to multiple filehandles with one output call

SYNOPSIS
========

     use FileHandle::Multi;
     $mult_obj=new FileHandle::Multi;
     $mult_obj->open('>-');
     $mult_obj->open('>file');
     $mult_obj->open(">$file");
     $mult_obj->open('>>file2');
     $mult_obj->print("This will be printed to several filehandles\n");
     $mult_obj->printf("This will be printed to %d filehandles\n",
         scalar @{$mult_obj->{handles}});
     $mult_obj->autoflush();
     @handle_refs = $mult_obj->members();
     $mult_obj->output_field_separator(':');
     $mult_obj->output_record_separator('\n');
     $mult_obj->format_page_number(2);
     $mult_obj->format_lines_per_page(66);
     $mult_obj->format_lines_left(10);
     $mult_obj->format_name('AN_REPORT');
     $mult_obj->format_top_name('AN_REPORT_TOP');
     $mult_obj->format_line_break_characters('\n');
     $mult_obj->format_formfeed('\l');
     $mult_obj->close();

DESCRIPTION
===========

   This module requires that the user have the FileHandle module installed
(it comes with the perl distribution).  Create objects for each of the
output filehandles you'll have - then call the print() and printf()
methods to send output to ALL the filehandles associated with an object.

EXAMPLES
========

   Look at the SYNOPSIS section.  Also, here is a simple implementation of
the unix tee(1) program (non-append mode):

     #!/local/bin/perl
     use Multi;
     $mh=new Multi;
     $mh->open('>-');
     for (@ARGV) { $mh->open(">$_"); }
     while (<STDIN>) { $mh->print($_); }

BUGS
====

   I don't think using my()s the way I am in the open() method is all that
good.  binmode isn't supported, but I don't see anybody using that anyways.
In order to use fcntl(), fileno(), or flock() you'll have to access the
filehandles yourself by calling members().  There's no write() yet (but I'm
working on it!).  Also, any limitations to the FileHandle module also apply
here.

AUTHOR
======

   Nem W Schlecht (nem@plains.nodak.edu).  Comments, bugs fixes, and
suggestions welcome.


File: pm.info,  Node: FileSys/Ext2,  Next: Filesys/Df,  Prev: FileHandle/Multi,  Up: Module List

Interface to e2fs filesystem attributes
***************************************

NAME
====

   FileSys::Ext2 - Interface to e2fs filesystem attributes

SYNOPSIS
========

     use FileSys::Ext2 qw(chattr lsattr);
     $mode = lsattr("/etc/passwd");
     chattr($mode+0003, "/etc/passwd");

DESCRIPTION
===========

`chattr($mask, @files)'
     Change the mode of `@files' to match $mask.  $mask may be a symbolic
     mode or a bitmask.

`lsattr($file)'
     In list context it returns a list containing symbols representing the
     symbolic mode of $file.  In scalar context it returns a bitmask.

`lstat($file)'
     Same as CORE::lstat, but appends the numerical attribute bitmask.

`stat($file)'
     Same as CORE::stat, but appends the numerical attribute bitmask.

`calcSymMask'
     Accepts a bitmask and returns the symbolic mode.  In list context it
     returns a symbol list like lsattr, in scalar mode it returns a string
     that matches the ------- region of lsattr (akin to that of ls -l e.g.
     drwxr-x--)

SEE ALSO
========

   chattr(1), lsattr(1)

NOTES
=====

   Of course, this would be more efficient if it were an XSUB.

   The bit mappings for attributes, from ext2_fs.h

     s #define EXT2_SECRM_FL           0x00000001 /* Secure deletion */
     u #define EXT2_UNRM_FL            0x00000002 /* Undelete */
     c #define EXT2_COMPR_FL           0x00000004 /* Compress file */
     S #define EXT2_SYNC_FL            0x00000008 /* Synchronous updates */
     i #define EXT2_IMMUTABLE_FL       0x00000010 /* Immutable file */
     a #define EXT2_APPEND_FL          0x00000020 /* writes to file may only append */
     d #define EXT2_NODUMP_FL          0x00000040 /* do not dump file */
     A #define EXT2_NOATIME_FL         0x00000080 /* do not update atime */

AUTHOR
======

   Jerrad Pierce <belg4mit@mit.edu>, <webmaster@pthbb.org>


File: pm.info,  Node: Filesys/Df,  Next: Filesys/DiskFree,  Prev: FileSys/Ext2,  Up: Module List

Perl extension for obtaining file system stats.
***********************************************

NAME
====

   Filesys::Df - Perl extension for obtaining file system stats.

SYNOPSIS
========

     use Filesys::Df;
     $ref = df("/tmp", 512); #Display output in 512 byte blocks
                             #Default is 1024 byte blocks.
     print"Percent Full:               $ref->{per}\n";
     print"Superuser Blocks:           $ref->{blocks}\n";
     print"Superuser Blocks Available: $ref->{bfree}\n";
     print"User Blocks:                $ref->{user_blocks}\n";
     print"User Blocks Available:      $ref->{bavail}\n";
     print"Blocks Used:                $ref->{used}\n";

DESCRIPTION
===========

   This module will produce information on the amount disk space available
to the normal user and the superuser for any given filesystem.

   It contains one function df(), which takes a directory as the first
argument and an optional second argument which will let you specify the
block size for the output.  Note that the inode values are not changed by
the block size argument.

   The return value of df() is a refrence to a hash.  The main keys of
intrest in this hash are:

   {per} Percent used. This is based on what the non-superuser will have
used.  (In other words, if the filesystem has 10% of its space reserved for
the superuser, then the percent used can go up to 110%.)

   {blocks} Total number of blocks on the file system.

   {used} Total number of blocks used.

   {bavail} Total number of blocks available.

   {fper} Percent of inodes used. This is based on what the non-superuser
will have used.

   {files} Total inodes on the file system.

   {fused} Total number of inodes used.

   {favail} Inodes available.

   Most filesystems have a certain amount of space reserved that only the
superuser can access.

   If you wish to differentiate between the amount of space that the
normal user can access, and the amount of space the superuser can access,
you can use these keys:

   {su_blocks} or {blocks} Total number of blocks on the file system.

   {user_blocks} Total number of blocks on the filesystem for the
non-superuser.

   {su_bavail} or {bfree} Total number of blocks available to the
superuser.

   {user_bavail} or {bavail} Total number of blocks available to the
non-superuser.

   {su_files} or {files} Total inodes on the file system.

   {user_files} Total number of inodes on the filesystem for the
non-superuser.

   {su_favail} or {ffree} Inodes available in file system.

   {user_favail} or {favail} Inodes available to non-superuser.

   Most 'df' applications will print out the 'blocks' or 'user_blocks',
'bavail', 'used', and the percent full values. So you will probably end up
using these values the most.

   If the file system does not contain a diffrential in space for the
superuser then the user_ keys will contain the same values as the su_ keys.

   If there was an error df() will return undef and $! will have been set.

   Requirements: Your system must contain statvfs().  You must be running
perl.5003 or higher.

   Note: The way the percent full is measured is based on what the HP-UX
application 'bdf' returns.  The 'bdf' application seems to round a bit
different than 'df' does but I like 'bdf' so that is what I based the
percentages on.

AUTHOR
======

   Ian Guthrie IGuthrie@aol.com

   Copyright (c) 1998 Ian Guthrie. All rights reserved.
This program is free software; you can redistribute it and/or
 modify it under the same terms as Perl itself.

SEE ALSO
========

   statvfs(2), df(1M), bdf(1M)

   perl(1).


File: pm.info,  Node: Filesys/DiskFree,  Next: Filesys/DiskSpace,  Prev: Filesys/Df,  Up: Module List

perform the Unix command 'df' in a portable fashion
***************************************************

NAME
====

   Filesys::DiskFree - perform the Unix command 'df' in a portable fashion

SYNOPSIS
========

     use Filesys::DiskFree;

     $handle = new Filesys::DiskFree;
     $handle->df();
     print "The root device is ".$handle->device("/")."\n";
     print "It has ".$handle->avail("/")." bytes available\n";
     print "It has ".$handle->total("/")." bytes total\n";
     print "It has ".$handle->used("/")." bytes used\n";

DESCRIPTION
===========

   Filesys::DiskFree does about what the unix command df(1) does, listing
the mounted disks, and the amount of free space used & available.

Functions
---------

Filesys::DiskFree->set('option' => 'value')
     Sets various options within the module.

     The most common option to change is the mode, which can be either
     blocks or inodes. By default, blocks is used.

     If reading a file from a 'foreign' OS using the load() function,
     format may be used, which takes the name of an OS as set in the $^O
     variable.

     Returns the previous values of the options.

Filesys::DiskFree->df()
     Perfoms a 'df' command, and stores the values for later use.

Filesys::DiskFree->command()
     Returns the appropriate command to do a 'df' command, for the current
     format.  This is used when you wish to call a df on a remote system.
     Use the df() method for local df's.

     Returns undef if there isn't an appropriate command.

Filesys::DiskFree->load($line)
     Reads in the output of a 'df', $line can be either a scalar or a
     filehandle.  If $line is a filehandle, then the filehandle is read
     until EOF.

     Returns undef on failure

Filesys::DiskFree->disks()
     Returns all the disks known about

Filesys::DiskFree->device($id)
     Returns the device for $id, which is a scalar containing the device
     name of a disk or a filename, in which case the disk that filename in
     stored upon is used. If a filename doesn't begin with '/', then it is
     treated as if is '/'.

Filesys::DiskFree->mount($id)
     Returns the mount point for $id, which is a scalar containing the
     device name of a disk or a filename, in which case the disk that
     filename in stored upon is used.

Filesys::DiskFree->avail($id)
     Returns the amount of available space in bytes for $id, which is a
     scalar containing the device name of a disk or a filename, in which
     case the disk that filename in stored upon is used.

Filesys::DiskFree->total($id)
     Returns the amount of total space in bytes for $id, which is a scalar
     containing the device name of a disk or a filename, in which case the
     disk that filename in stored upon is used.

Filesys::DiskFree->used($id)
     Returns the amount of used space in bytes for $id, which is a scalar
     containing the device name of a disk or a filename, in which case the
     disk that filename in stored upon is used.

BUGS
====

   It should support more formats, currently only Linux, Irix, Solaris &
BSD are supported. Other formats will be added as available. Please sent
your OS Name & version, the 'best' df options to use, and the output of df
with those options, and the contents of $^O if you have access to a
non-supported format.

AUTHOR
======

   Alan R. Barclay <gorilla@drink.com>


File: pm.info,  Node: Filesys/DiskSpace,  Next: Filesys/Ext2,  Prev: Filesys/DiskFree,  Up: Module List

Perl df
*******

NAME
====

   Filesys::DiskSpace - Perl df

SYNOPSIS
========

     use Filesys::DiskSpace;
     ($fs_type, $fs_desc, $used, $avail, $fused, $favail) = df $dir;

DESCRIPTION
===========

   This routine displays information on a file system such as its type, the
amount of disk space occupied, the total disk space and the number of
inodes.  It tries `syscall(SYS_statfs)' and `syscall(SYS_statvfs)' in
several ways.  If all fails, it croaks.

OPTIONS
=======

$fs_type
     [number] type of the filesystem.

$fs_desc
     [string] description of this fs.

$used
     [number] size used (in Kb).

$avail
     [number] size available (in Kb).

$ffree
     [number] free inodes.

$fused
     [number] inodes used.

Installation
============

   See the INSTALL file.

COPYRIGHT
=========

   Copyright (c) 1996-1999 Fabien Tassin. All rights reserved.  This
program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

AUTHOR
======

   Fabien Tassin <fta@oleane.net>

NOTES
=====

   This module was formerly called File::Df. It has been renamed into
Filesys::DiskSpace. It could have be Filesys::Df but unfortunatly another
module created in the meantime uses this name.

   Tested with Perl 5.003 under these systems :

     - Solaris 2.[4/5]
     - SunOS 4.1.[2/3/4]
     - HP-UX 9.05, 10.[1/20] (see below)
     - OSF1 3.2, 4.0
     - Linux 2.0.*, 2.2.*

   Note for HP-UX users :

     if you obtain this message :
     "Undefined subroutine &main::SYS_statfs called at Filesys/DiskSpace.pm
     line XXX" and if you are using a hp9000s700, then edit the syscall.ph file
     (in the Perl lib tree) and copy the line containing "SYS_statfs {196;}"
     outside the "if (defined &__hp9000s800)" block (around line 356).


File: pm.info,  Node: Filesys/Ext2,  Next: Filesys/SmbClient,  Prev: Filesys/DiskSpace,  Up: Module List

Interface to e2fs filesystem attributes
***************************************

NAME
====

   Filesys::Ext2 - Interface to e2fs filesystem attributes

SYNOPSIS
========

     use Filesys::Ext2 qw(chattr lsattr);
     $mode = lsattr("/etc/passwd");
     chattr("+aud", "/etc/passwd");
     	#or equivalently
     #chattr($mode|0x0062, "/etc/passwd");

DESCRIPTION
===========

`chattr($mask, @files)'
     Change the mode of *@files* to match $mask.  $mask may be a symbolic
     mode or a bitmask.

`lsattr($file)'
     In list context it returns a list containing symbols representing the
     symbolic mode of $file.  In scalar context it returns a bitmask.

`lstat($file)'
     Same as `CORE::lstat', but appends the numerical attribute bitmask.

`stat($file)'
     Same as `CORE::stat', but appends the numerical attribute bitmask.

`calcSymMask'
     Accepts a bitmask and returns the symbolic mode.  In list context it
     returns a symbol list like lsattr, in scalar mode it returns a string
     that matches the ------- region of *lsattr(1)* (akin to that of *ls
     -l* e.g. drwxr-x--)

SEE ALSO
========

   *chattr(1)*, *lsattr(1)*

NOTES
=====

   Of course, this would be more efficient if it were an XSUB.

   The bit mappings for attributes, from ext2_fs.h

     s #define EXT2_SECRM_FL           0x00000001 /* Secure deletion */
     u #define EXT2_UNRM_FL            0x00000002 /* Undelete */
     c #define EXT2_COMPR_FL           0x00000004 /* Compress file */
     S #define EXT2_SYNC_FL            0x00000008 /* Synchronous updates */
     i #define EXT2_IMMUTABLE_FL       0x00000010 /* Immutable file */
     a #define EXT2_APPEND_FL          0x00000020 /* writes to file may only append */
     d #define EXT2_NODUMP_FL          0x00000040 /* do not dump file */
     A #define EXT2_NOATIME_FL         0x00000080 /* do not update atime */

AUTHOR
======

   Jerrad Pierce <belg4mit@mit.edu>, <webmaster@pthbb.org>


File: pm.info,  Node: Filesys/SmbClient,  Next: Filesys/SmbClientParser,  Prev: Filesys/Ext2,  Up: Module List

Perl extension for access Samba filesystem with libsmclient.so
**************************************************************

NAME
====

   Filesys::SmbClient - Perl extension for access Samba filesystem with
libsmclient.so

SYNOPSIS
========

     use POSIX;
     use Filesys::SmbClient;

     my $smb = new Filesys::SmbClient("alian",10);

     # Read a directory
     my $fd = $smb->opendir("smb://jupiter/doc");
     while ($smb->readdir($fd)) {print $_,"\n";}
     close($fd);

     # Read long info on a directory
     my $fd = $smb->opendir("smb://jupiter/doc");
     while (my $f = $smb->readdir_struct($fd))
       {
       if ($f->[0] == SMBC_DIR) {print "Directory ",$f->[1],"\n";}
       elsif ($f->[0] == SMBC_FILE) {print "File ",$f->[1],"\n";}
       # ...
       }
     close($fd);

     # Create a directory
     $smb->mkdir("smb://jupiter/doc/toto",'0666');

     # Read a file
     my $fd = $smb->open("smb://jupiter/doc/toto",O_RDONLY,'0666');
     while (defined(my $l= $smb->read($fd,50))) {print $l; }
     $smb->close(fd);

     # Write a file
     my $fd = $smb->open("smb://jupiter/doc/test",O_CREAT, 0666);
     $smb->write($fd,"A test of write call") || print $!,"\n";
     $smb->close(fd);

     # Rename a file
     $smb->rename("smb://jupiter/doc/toto","smb://jupiter/doc/tata"),"\n";

     # Delete a file
     $smb->unlink("smb://jupiter/doc/test");

     # Stat a file
     my @tab = $smb->stat("smb://jupiter/doc/tata");
     for (10..12) {$tab[$_] = localtime($tab[$_]);}
     print join("\n",@tab);

DESCRIPTION
===========

   Provide interface to access routine defined in libsmbclient.so.  On
2001/01/21, this library is only available with CVS source of Samba
(target head), See on samba.org web site, section download. This module is
a beta version !

   When a path is used, his scheme is :

     smb://server/share/rep/doc

VERSION
=======

   $Revision: 0.2 $

FONCTIONS
=========

new($wgroup,$debug)
     Init some things

          $wgroup : Current workgroup
          $debug : level of debug

     Return 0 on succes, errno else.

Directory
---------

mkdir($fname,$mode)
     Create directory $fname with permissions set to $mode

opendir($fname)
     Open directory $fname and return file descriptor.

readdir($fd)
     Read a directory. In a list context, return the full content of the
     directory $fd, else return next element. Each elem is a name of a
     directory or files.

     Return undef at end of directory.

readdir_struct($fd)
     Read a directory. In a list context, return the full content of the
     directory $fd, else return next element. Each element is a ref to an
     array with type and name. Type can be :

     Return undef at end of directory.

    SMBC_WORKGROUP
    SMBC_SERVER
    SMBC_FILE_SHARE
    SMBC_PRINTER_SHARE
    SMBC_COMMS_SHARE
    SMBC_IPC_SHARE
    SMBC_DIR
    SMBC_FILE
    SMBC_LINK
closedir($fd)
     Close directory $fd.

Files
-----

unlink($fname)
     Delete file $fname

     Return 0 on succes, errno else.

stat($fname)
     Stat a file to get info via file $fname. Return a array with info on
     success, else errno is return and $! is set. Tab is made with:

        * device

        * inode

        * protection

        * number of hard links

        * user ID of owner

        * group ID of owner

        * device type (if inode device)

        * total size, in bytes

        * blocksize for filesystem I/O

        * number of blocks allocated

        * time of last access

        * time of last modification

        * time of last change

rename($oname,$nname)
     Rename $oname in  $nname. Return 0 on success, else -1 is return and
     errno and $! is set.

open($fname, $flags, $mode)
     Open file $fname with flags $flags and mode $mode. Return file
     descriptor on success, else -1 is return and errno and $! is set.

read($fd,$count)
     Read $count bytes of data on file descriptor $fd. Return buffer read
     on success, undef at end of file, -1 is return on error and $! is set.

write($fd,$buf)
     Write $buf on file descriptor $fd. Return number of bytes wrote, else
     -1 is return and errno and $! is set.

close($fd)
     Close file descriptior $fd. Return 0 on success, else -1 is return and
     errno and $! is set.

AUTHOR
======

   Alain BARBET,  alian@alianwebserver.com


File: pm.info,  Node: Filesys/SmbClientParser,  Next: Filesys/Statvfs,  Prev: Filesys/SmbClient,  Up: Module List

Perl client to reach Samba ressources
*************************************

NAME
====

   Filesys::SmbClientParser - Perl client to reach Samba ressources

SYNOPSIS
========

     use Filesys::SmbClientParser;
     my $smb = new Filesys::SmbClientParser;

     # Set parameters for connect
     $smb->User('Administrateur');
     $smb->Password('password');
     $smb->Host('jupiter');

     # List host available on this network machine
     my @l = $smb->GetHosts;
     foreach (@l) {print $_->{name},"\t",$_->{comment},"\n";}

     # List share disk available
     my @l = $smb->GetShr;
     foreach (@l) {print $_->{name},"\n";}

     # Choose a shared disk
     $smb->Share('games2');

     # List content
     my @l = $smb->dir;
     foreach (@l) {print $_->{name},"\n";}

     # Send a Winpopup message
     $smb->sendWinpopupMessage('jupiter',"Hello world !");

     # File manipulation
     $smb->cd('jdk1.1.8');
     $smb->get("COPYRIGHT");
     $smb->mkdir('tata');
     $smb->cd('tata');
     $smb->put("COPYRIGHT");
     $smb->del("COPYRIGHT");
     $smb->cd('..');
     $smb->rmdir('tata');

     # Archive method
     $smb->tar('c','/tmp/jdk.tar');
     $smb->cd('..');
     $smb->mkdir('tatz');
     $smb->cd('tatz');
     $smb->tar('x','/tmp/jdk.tar');

DESCRIPTION
===========

   SmbClientParser work with output of bin smbclient, so it doesn't work
on win platform. (but query of win platform work of course)

   A best method is work with a samba shared librarie and xs language, but
on Nov.2000 (Samba version prior to 2.0.8) there is no public interface
and shared library defined in Samba projet.

   Request has been submit and accepted on Samba-technical mailing list,
so a new module with name SmbClient will be done as soon as the public
interface has been known.

   For Samba client prior to 2.0.8, use this module !

   SmbClientParser is adapted from SMB.pm make by Remco van Mook
mook@cs.utwente.nl on smb2www project.

AUTHOR
======

   Alain BARBET alian@alianwebserver.com

SEE ALSO
========

   smbclient(1) man pages.

DESCRIPTION
===========

Objects methods
---------------

new([$path_of_smbclient])
Network methods
---------------

GetShr
     Return an array with sorted share listing

     Syntax: @output = $smb->GetShr

     array contains hashes; keys: name, type, comment

GetHosts
     Return an array with sorted host listing

     Syntax: @output = $smb->GetHosts

     array contains hashes; keys: name, comment

sendWinpopupMessage($dest,$text)
     This method allows you to send messages, using the "WinPopup"
     protocol, to another computer. If the receiving computer is running
     WinPopup the user will receive the message and probably a beep. If
     they are not running WinPopup the message will be lost, and no error
     message will occur.

     The message is also automatically truncated if the message is over
     1600 bytes, as this is the limit of the protocol.

     Parameters :

          $dest: name of host or user to send message
          $text: text to send

Operations
----------

cd [$dir]
     cd [directory name] If "directory name" is specified, the current
     working directory on the server will be changed to the directory
     specified. This operation will fail if for any reason the specified
     directory is inaccessible. Return list.

     If no directory name is specified, the current working directory on
     the server will be reported.

dir
     Return an array with sorted dir and filelisting

     Syntax: @output = $smb->dir (host,share,dir,user,pass)

     Array contains hashes; keys: name, attr, size, date

mkdir($masq)
     mkdir <mask> Create a new directory on the server (user access
     privileges permitting) with the specified name.

rmdir($masq)
     Remove the specified directory (user access privileges permitting)
     from the server.

get($file, $target, [$dir])
     Gets the file $file, using $user and $pass, to $target on courant SMB
     server and return the error code.  If $target is unspecified, courant
     directory will be used For use STDOUT, set target to '-'.

     Syntax: $error = $smb->get ($file,$target,[$dir])

mget($file,[$recurse])
     Gets file(s) $file on current SMB server,directory and return the
     error code. If multiple file, push an array ref as first parameter or
     pattern * or file separated by space

     Syntax:

          $error = $smb->mget ('file'); #or
          $error = $smb->mget (join(' ',@file); #or
          $error = $smb->mget (\@file); #or
          $error = $smb->mget ("*",1);

put$($orig,$file,[$dir])
     Puts the file $orig to $file, using $user and $pass on courant SMB
     server and return the error code.  If $orig is unspecified, STDIN is
     used (-).

     Syntax: $error = $smb->PutFile ($host,$share,$file,$user,$pass,$orig)

mput($file,[$recurse])
     Puts file(s) $file on current SMB server,directory and return the
     error code. If multiple file, push an array ref as first parameter or
     pattern * or file separated by space

     Syntax:

          $error = $smb->mput ('file'); #or
          $error = $smb->mput (join(' ',@file); #or
          $error = $smb->mput (\@file); #or
          $error = $smb->mput ("*",1);

del($mask)
     del <mask> The client will request that the server attempt to delete
     all files matching "mask" from the current working directory on the
     server

Archives methods
----------------

tar($command,$target)
     Execute TAR commande on //$host/$share/$dir, using $user and $pass,
     to $target.  and return the error code. If $target is unspecified,
     current directory will be used.

     Syntax: $error = $smb->tar ($command) where command in ('x','c',...)
     See smbclient man page

Private methods
---------------

byname
     sort an array of hashes by $_->{name} (for GetSMBDir et al)

operation(...)
command($args,$command)

File: pm.info,  Node: Filesys/Statvfs,  Next: Filter/Handle,  Prev: Filesys/SmbClientParser,  Up: Module List

Perl extension for statvfs().
*****************************

NAME
====

   Filesys::Statvfs - Perl extension for statvfs().

SYNOPSIS
========

     use Filesys::Statvfs;

     my($bsize, $frsize, $blocks, $bfree, $bavail,
     $files, $ffree, $favail, $fsid, $basetype, $flag,
     $namemax, $fstr) = statvfs("/tmp");

     ##### On HP-UX 10x systems f_time and f_size are avaliable

     ($bsize, $frsize, $blocks, $bfree, $bavail,
     $files, $ffree, $favail, $fsid, $basetype, $flag,
     $namemax, $fstr, $size, $time) = statvfs("/tmp");

DESCRIPTION
===========

   Interface for statvfs();

   The statvfs() function will return a list of values or will return
undef and set $! if there was an error.

   The values returned are described in the statvfs header or the
statvfs() man page.

   Note: On Digital Unix $fstr will be NULL.

   $size and $time are only returned on HP-UX systems.

AUTHOR
======

   Ian Guthrie IGuthrie@aol.com

   Copyright (c) 1998 Ian Guthrie. All rights reserved.
This program is free software; you can redistribute it and/or
 modify it under the same terms as Perl itself.

SEE ALSO
========

   statvfs(2), df(1M)


File: pm.info,  Node: Filter/Handle,  Next: Filter/Simple,  Prev: Filesys/Statvfs,  Up: Module List

Apply filters to output filehandles
***********************************

NAME
====

   Filter::Handle - Apply filters to output filehandles

SYNOPSIS
========

     use Filter::Handle;
     my $f = Filter::Handle->new(\*STDOUT);
     $f->print(...);

     use Filter::Handle qw/subs/;
     Filter \*STDOUT;
     ...
     UnFilter \*STDOUT;

     tie *STDOUT, 'Filter::Handle', \*HANDLE;
     ...
     untie *STDOUT;

DESCRIPTION
===========

   *Filter::Handle* allows you to apply arbitrary filters to output
filehandles. You can perform any sorts of transformations on the outgoing
text: you can prepend it with some data, you can replace all instances of
one word with another, etc.

   You can even filter all of your output to one filehandle and send it to
another; for example, you can filter everything written to STDOUT and
write it instead to another filehandle. To do this, you need to explicitly
use the tie interface (see below).

Calling Interfaces
------------------

   There are three interfaces to filtering a handle:

   * Functional
          use Filter::Handle qw/subs/;

          Filter \*STDOUT;
          print "I am filtered text";
          UnFilter \*STDOUT;

          print "I am normal text";

     The functional interface works by exporting two functions into the
     caller's namespace: Filter and *UnFilter*. To start filtering a
     filehandle, call the Filter function; to stop, call *UnFilter* on
     that same filehandle.

     Any writes between the time you start and stop filtering will be
     filtered.

   * Object-Oriented
          use Filter::Handle;

          {
              my $f = Filter::Handle->new(\*STDOUT);
              $f->print("I am filtered text");
          }

          print "I am normal text";

     The object-oriented interface works differently than the other two
     interfaces (Functional and Tie); while the others use Perl's tie
     mechanism to provide the filtering, the OO interface expects you to
     explicitly call methods on your *Filter::Handle* object. This is
     really just a difference of approach; you should get the same results,
     either way. The filter is in scope as long as your *Filter::Handle*
     object is in scope. But in order to write to the filtered filehandle,
     you must explicitly use either print or printf methods.

   * Tie
          use Filter::Handle;

          local *HANDLE;
          tie *STDOUT, 'Filter::Handle', \*HANDLE;

          print "I am filtered text written to HANDLE";

          untie *STDOUT;

     The tie interface will filter your filehandle until you explicitly
     untie it. This is the only interface that allows you to filter one
     filehandle through another.  The above example will filter all writes
     to STDOUT through the output filter, then write it out on HANDLE.
     Note that this is different behavior than that of the first two
     interfaces; if you want your output written to the same handle that
     you're filtering, you could use:

          tie *STDOUT, 'Filter::Handle', \*STDOUT;

Customized Filters
------------------

   The default filter is relatively boring: it simply prepends any text
you print with the filename and line of the invoking caller. You'll
probably want to do something more interesting.

   To do so, pass an anonymous subroutine as a second argument to either
the new method, if you're using the OO interface, or to the Filter
function, if you're using the functional interface. Your subroutine will
be passed the list originally passed to print, and it should return
another list, suitable for passing to your (unfiltered) output filehandle.

   For example, say that we want to replace all instances of "blue" with
"red". We could say:

     use Filter::Handle qw/subs/;

     Filter \*STDOUT,
         sub { local $_ = "@_"; s/blue/red/g; $_ };

     print "My house is blue.\n";
     print "So is my cat, whose nose is blue.\n";

     UnFilter \*STDOUT;

     print "And the plane is also blue.\n";

   This prints:

     My house is red.
     So is my cat, whose nose is red.
     And the plane is also blue.

   As expected.

Tips, Tricks, Samples
---------------------

   * Capturing Output

     Normally, output is passed through your filtering function, then
     printed on the output filehandle that you're filtering. Suppose that,
     instead of writing the filtered output to the filehandle, you just
     want to capture that filtered output. In other words, you want to
     store the output and not have it written to the filehandle. Here's an
     example that does just that:

          my($out, $i);
          Filter \*STDOUT, sub {
              $out .= sprintf "%d: %s\n", $i++, "@_";
              ()
          };
          print "Foo";
          print "Bar";
          UnFilter \*STDOUT;

     `$out' now contains:

          0: Foo
          1: Bar

     And nothing has been written to STDOUT.

CAVEATS
=======

   Note that this won't work correctly with output from XSUBs or system
calls. This is due to a limitation of Perl's tie mechanism when tying
filehandles.

AUTHOR
======

   Benjamin Trott, ben@rhumba.pair.com

CREDITS
=======

   Thanks to tilly, chromatic, and merlyn at PerlMonks.org for
suggestions, critiques, and code samples.


